# Python Programlama Dili Referans Belgesi
Bu belge, Python programlama dilinin temel kavramlarını Türkçe olarak açıklamaktadır.
---

# istihza.com

## Bu Kitap Hakkında

Elinizdeki kitap, Python programlama dili için kapsamlı bir Türkçe kaynak oluşturma projesi olanyazbel.com’un bir ürünüdür.
Bu kitabın amacı, herhangi bir sebeple Python programlama diline ilgi duyan, bu programlama dilini öğrenmek isteyen kişilere bu dili olabildiğince hızlı, ayrıntılı ve kolay bir şekilde öğretmektir.

Bu kitabın hedef kitlesi, programlamayı hiç bilmeyen kişilerdir.
Bu sebeple, bu kitapta ders konularını olabildiğince ayrıntılı ve basitleştirilmiş bir şekilde ele almaya çalıştık.

### Bu Kitaptan Nasıl Yararlanabilirim?

Elinizdeki kitap, epey uzun ve ayrıntılı makalelerden oluşuyor.
Dolayısıyla bu kitabı elinize alıp bir roman gibi okumaya çalışırsanız, sıkılıp öğrenme azminizi kaybedebilirsiniz.
Bu kitabı sıkılmadan ve bıkkınlığa düşmeden takip edebilmeniz için size birkaç öneride bulunalım.

Programlama dillerini, sanki tarih, coğrafya veya felsefe çalışıyormuşsunuz gibi, kitaba gömülüp harıl harıl okuyarak öğrenemezsiniz.
Programlama dillerini öğrenebilmek için sizin de etkin bir şekilde öğrenme sürecine katılmanız gerekir.
Yani bu kitaptaki makalelere kafanızı gömmek yerine, bol bol örnek kod yazmaya çalışırsanız, öğrendiğiniz şeyler zihninizde daha kolay yer edecektir.
Birincisi bu.

İkincisi, kimse sizden bu kitaptaki her ayrıntıyı ezberlemenizi beklemiyor.
Maharet, bir konuya ilişkin bütün ayrıntıları akılda tutabilmekte değildir.
İyi bir programcı, bir konuya dair nasıl araştırma yapacağını ve kaynaklardan nasıl faydalanacağını bilir.
Bir yazılım geliştirici adayı olarak sizin de öğrenmeniz gereken şey, gördüğünüz bütün konuları en ince ayrıntısına kadar ezberlemeye kalkışmaktan ziyade, o konuya ilişkin ilk aşamada fikir sahibi olmaya çalışmaktır.
Python’da ilerledikçe, zaten belli alanlara ilgi duyacak, kendinizi o alanlarda geliştirmeye çalışacaksınız.
Elbette çok uğraştığınız konulara ilişkin ayrıntılar da daha kolay aklınızda kalacaktır.
Üstelik bir projeye ilişkin gerekliliklerin sizi yönlendirmesiyle, belli konularda daha ayrıntılı araştırma yapma fırsatı da bulacaksınız.

Üçüncüsü, bir konuyu çalışırken yeterince anlayamadığınızı hissederseniz, lütfen dudağınızı büzüp bir duvar köşesine kıvrılarak kendi kendinizi yılgınlığa düşürmeyin.
Eğer bir konuyu anlamadıysanız, okuyup geçin.
Okuyup geçmek içinize sinmiyorsa, aşağıda belirttiğimiz şekilde yardım isteyin.

Son olarak, bu kitaptan çevrimdışı olarak faydalanmak istiyorsanızburadakiseçenekleri takip edebilirsiniz.

### Nereden Yardım Alabilirim?

Bu kitapta Python programlama diline ilişkin konuları olabildiğince temiz ve anlaşılır bir dille anlatmaya çalıştık.
Ancak yine de bazı konular zihninizde tam olarak yer etmeyebilir.
Üstelik kimi zaman, bir konuyu daha iyi anlayabilmek ya da bir sorunun üstesinden gelebilmek için bilen birilerinin yardımına da ihtiyaç duyabilirsiniz.
İşte böyle durumlarda yazbel.com’unforum alanınauğrayarak başka Python programcılarından yardım isteyebilirsiniz.

Forum alanı hem bilgi edinmek, hem de bildiklerinizi paylaşmak için oldukça elverişli bir ortamdır.
Foruma ilk girişiniz muhtemelen yardım istemek için olacaktır.
Ama ilerleyen zamanlarda Python bilginiz arttıkça bir de bakacaksınız ki yardım ararken yardım eder duruma gelmişsiniz.
İşte forum; kendinizdeki değişimi görmek, bilgi düzeyinizdeki artışı takip etmek ve hatta yeni şeyler öğrenmek için bulunmaz bir fırsattır.

### Projeye Nasıl Yardımcı Olabilirim?

Bu kitabın amacı, kitabı okuyanlara Python programlama dilini doğru ve ayrıntılı bir şekilde öğretmek olduğu kadar, bu programlama dilini öğretirken düzgün ve anlaşılır bir Türkçe de kullanmaktır.
Bu bakımdan, kitapta bulabileceğiniz kod hatalarıyla birlikte, kitaptaki anlatım, yazım ve noktalama hatalarını daGitHub’daki veri havuzundadüzelterek ya daGitHub’da bir konu açarakbu projeye önemli bir katkıda bulunmuş olursunuz.

> **Ayrıca bakınız**
> Projeye bu şekilde katkıda bulunanların listesiniKatkıda Bulunanlarbaşlıklı sayfada görebilirsiniz.

Ayrıca bakınız

Projeye bu şekilde katkıda bulunanların listesiniKatkıda Bulunanlarbaşlıklı sayfada görebilirsiniz.

Bunun dışında, projeye destek olmanın bir başka yolu, forum alanında sorulan soruları cevaplamaya çalışmaktır.
Bu şekilde hem projeye destek olmuş, hem başkalarına yardım etmiş, hem de kendi bilginizi artırmış olursunuz.

Python’da kendinizi belli bir seviyeye getirdikten sonra, eğer kaleminize de güveniyorsanız eksik konular hakkında yazıp kitaba katkıda bile bulunabilirsiniz.

### Kullanım Koşulları

Bu kitaptaki bilgilerCreative Commons lisansıaltındadır.
Bu lisansa göre, bu kitaptaki bütün bilgilerden herkes ücretsiz olarak yararlanabilir.
Eğer isterseniz burada gördüğünüz belgelerin çıktısını alabilir, tanıdığınız veya tanımadığınız herkesle gönül rahatlığıyla paylaşabilirsiniz.
Ancak bu belgeleri başka bir yerde kullanacaksanız, yine bu lisans altında kullanmalı ve bu belgeleri kesinlikle satmamalısınız.
Arzu ederseniz belgeleri çoğaltıpücretsiz olarakdağıtabilirsiniz.

## Python Hakkında

Eğer yaşamınızın bir döneminde herhangi bir programlama dili ile az veya çok ilgilendiyseniz, Python adını duymuş olabilirsiniz.
Önceden bir programlama dili deneyiminiz hiç olmamışsa dahi, Python adının bir yerlerden kulağınıza çalınmış olma ihtimali bir hayli yüksek.
Bu satırları okuyor olduğunuza göre, Python adını en az bir kez duymuş olduğunuzu ve buşeyekarşı içinizde hiç değilse bir merak uyandığını varsayabiliriz.

Peki, en kötü ihtimalle kulak dolgunluğunuz olduğunu varsaydığımız buşeyhakkında acaba neler biliyorsunuz?

İşte biz bu ilk bölümde, fazla teknik ayrıntıya kaçmadan, Python hakkında kısa kısa bilgiler vererek Python’ın ne olduğunu ve bununla neler yapabileceğinizi anlatmaya çalışacağız.

### Python Nedir?

Tahmin edebileceğiniz gibi Python (C, C++, Perl, Ruby ve benzerleri gibi) bir programlama dilidir ve tıpkı öteki programlama dilleri gibi, önünüzde duran kara kutuya, yani bilgisayara hükmetmenizi sağlar.

Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür.
Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez.
Guido Van Rossum bu programlama dilini,The Monty Pythonadlı bir İngiliz komedi grubunun,Monty Python’s Flying Circusadlı gösterisinden esinlenerek adlandırmıştır.
Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır.

Dediğimiz gibi, Python bir programlama dilidir.
Üstelik pek çok dile kıyasla öğrenmesi kolay bir programlama dilidir.
Bu yüzden, eğer daha önce hiç programlama deneyiminiz olmamışsa, programlama maceranıza Python’la başlamayı tercih edebilirsiniz.

### Neden Programlama Öğrenmek İsteyeyim?

Günlük yaşamınıza şöyle bir bakın.
Gerek iş yerinizde olsun, gerek evde bilgisayar başında olsun, belli işleri tekdüze bir şekilde tekrar ettiğinizi göreceksiniz.
Mesela sürekli olarak yazılı belgelerle uğraşmanızı gerektiren bir işte çalışıyor olabilirsiniz.
Belki de her gün onlarca belgeyi açıp bu belgelerde birtakım bilgiler arıyor, bu bilgileri düzeltiyor, yeniliyor veya siliyorsunuzdur.
Bu işlemlerin ne kadar vakit alıcı ve sıkıcı olduğunu düşünün.
Eğer bir programlama dili biliyor olsaydınız, bütün bu işlemleri sizin yerinize bu programlama dili hallediyor olabilirdi.

İşte Python programlama dili böyle bir durumda devreye girer.
Her gün saatler boyunca uğraştığınız işlerinizi, yalnızca birkaç satır Python kodu yardımıyla birkaç saniye içinde tamamlayabilirsiniz.

Ya da şöyle bir durum düşünün:
Çalıştığınız iş yerinde PDF belgeleriyle bolca haşır neşir oluyor olabilirsiniz.
Belki de yüzlerce sayfalık kaşeli ve imzalı belgeyi PDF haline getirmeniz gerekiyordur.
Üstelik sizden bu belgeleri mümkün olduğunca tek parça halinde PDF’lemeniz isteniyor olabilir.
Ama o yüzlerce sayfayı tarayıcıdan geçirirken işin tam ortasında bir aksilik oluyor, makine arızalanıyor ve belki de ister istemez belgeniz bölünüyordur.

İşte Python programlama dili böyle bir durumda da devreye girer.
Eğer Python programlama dilini öğrenirseniz, İnternet’te saatlerce ücretsiz PDF birleştirme programı aramak veya profesyonel yazılımlara onlarca dolar para vermek yerine, belgelerinizi birleştirip işinizi görecek programı kendiniz yazabilirsiniz.

Elbette Python’la yapabilecekleriniz yukarıda verdiğimiz basit örneklerle sınırlı değildir.
Python’ı kullanarak masaüstü programlama, oyun programlama, taşınabilir cihaz programlama, web programlama ve ağ programlama gibi pek çok alanda çalışmalar yürütebilirsiniz.

### Neden Python?

Python programlarının en büyük özelliklerinden birisi, C ve C++ gibi dillerin aksine, derlenmeye gerek olmadan çalıştırılabilmeleridir.
Python’da derleme işlemi ortadan kaldırıldığı için, bu dille oldukça hızlı bir şekilde program geliştirilebilir.

Ayrıca Python programlama dilinin basit ve temiz söz dizimi, onu pek çok programcı tarafından tercih edilen bir dil haline getirmiştir.
Python’ın söz diziminin temiz ve basit olması sayesinde hem program yazmak, hem de başkası tarafından yazılmış bir programı okumak, başka dillere kıyasla çok kolaydır.

Python’ın yukarıda sayılan özellikleri sayesinde dünya çapında ün sahibi büyük kuruluşlar (Google, YouTube ve Yahoo! gibi) bünyelerinde her zaman Python programcılarına ihtiyaç duyuyor.
Mesela pek çok büyük şirketin Python bilen programcılara iş imkanı sağladığını, Python’ın baş geliştiricisi Guido Van Rossum’un 2005 ile 2012 yılları arasında Google’da çalıştığını, 2012 yılının sonlarına doğru ise Dropbox şirketine geçtiğini söylersek, bu programlama dilinin önemi ve geçerliliği herhalde daha belirgin bir şekilde ortaya çıkacaktır.

Python programlama dili ve bu dili hakkıyla bilenler sadece uluslararası şirketlerin ilgisini çekmekle kalmıyor.
Python son zamanlarda Türkiye’deki kurum ve kuruluşların da dikkatini çekmeye başladı.
Bu dil artık yavaş yavaş Türkiye’deki üniversitelerin müfredatında da kendine yer buluyor.

Sözün özü, pek çok farklı sebepten, başka bir programlama dilini değil de, Python programlama dilini öğrenmek istiyor olabilirsiniz.

### Python Nasıl Telaffuz Edilir?

Python programlama dili üzerine bu kadar söz söyledik.
Peki yabancı bir kelime olanpython’ı nasıl telaffuz edeceğimizi biliyor muyuz?

Geliştiricisi Hollandalı olsa dapythonİngilizce bir kelimedir.
Dolayısıyla bu kelimenin telaffuzunda İngilizcenin kuralları geçerli.
Ancak bu kelimeyi hakkıyla telaffuz etmek, ana dili Türkçe olanlar için pek kolay değil.
Çünkü bu kelime içinde, Türkçede yer almayan ve telaffuzu peltek s’yi andıran [th] sesi var.
İngilizce bilenler bu sesithink(düşünmek) kelimesinden hatırlayacaklardır.
Ana dili Türkçe olanlarthinkkelimesini genellikle [tink] şeklinde telaffuz eder.
Dolayısıylapythonkelimesini de [paytın] şeklinde telaffuz edebilirsiniz.

Pythonkelimesini tamamen Türkçeleştirerek [piton] şeklinde telaffuz etmeyi yeğleyenler de var.
Elbette siz de dilinizin döndüğü bir telaffuzu tercih etmekte özgürsünüz.

Bu arada, eğerpythonkelimesinin İngilizce telaffuzunu dinlemek istiyorsanızhowjsay.comadresini ziyaret edebilir, Guido Van Rossum’un bu kelimeyi nasıl telaffuz ettiğini merak ediyorsanız dahttps://www.youtube.com/watch?v=UIDdgeISLUIadresindeki tanıtım videosunu izleyebilirsiniz.

### Platform Desteği

Python programlama dili pek çok farklı işletim sistemi ve platform üzerinde çalışabilir.
GNU/Linux, Windows, Mac OS X, AS/400, BeOS, MorphOS, MS-DOS, OS/2, OS/390, z/OS, RiscOS, S60, Solaris, VMS, Windows CE, HP-UX, iOS ve Android gibi, belki adını dahi duymadığınız pek çok ortamda Python uygulamaları geliştirebilirsiniz.
Ayrıca herhangi bir ortamda yazdığınız bir Python programı, üzerinde hiçbir değişiklik yapılmadan veya ufak değişikliklerle başka ortamlarda da çalıştırılabilir.

Biz bu belgelerde Python programlama dilini GNU/Linux ve Microsoft Windows işletim sistemi üzerinden anlatacağız.
Ancak sıkı sıkıya bel bağlayacağımız özel bir GNU/Linux dağıtımı veya Windows sürümü yok.
Bu yüzden, hangi GNU/Linux dağıtımını veya hangi Windows sürümünü kullanıyor olursanız olun, buradaki bilgiler yardımıyla Python programlama dilini öğrenebilir, öğrendiklerinizi kendi işletim sisteminize uyarlayabilirsiniz.

> **Not**
> Bu satırların yazarının,Ubuntu,CentOS,Windows 7veWindows 10kurulu bilgisayarlara erişimi olduğu için, bu kitaptaki ekran görüntüleri genellikle bu işletim sistemlerinden alınmış olacaktır.

Not

Bu satırların yazarının,Ubuntu,CentOS,Windows 7veWindows 10kurulu bilgisayarlara erişimi olduğu için, bu kitaptaki ekran görüntüleri genellikle bu işletim sistemlerinden alınmış olacaktır.

### Farklı Python Sürümleri

Eğer daha önce Python programlama dili ile ilgili araştırma yaptıysanız, şu anda piyasada iki farklı Python serisinin olduğu dikkatinizi çekmiş olmalı.
19.08.2024 tarihi itibariyle piyasada olan en yeni Python sürümleri Python 2.7.18 ve Python 3.12.1’dir.

Eğer bir Python sürümü 2 sayısı ile başlıyorsa (mesela 2.7.15), o sürüm Python 2.x serisine aittir.
Yok eğer bir Python sürümü 3 sayısı ile başlıyorsa (mesela 3.7.0), o sürüm Python 3.x serisine aittir.

Peki neden piyasada iki farklı Python sürümü var ve bu bizim için ne anlama geliyor?

Python programlama dili 1990 yılından bu yana geliştirilen bir dil.
Bu süre içinde pek çok Python programı yazıldı ve insanların kullanımına sunuldu.
Şu anda piyasada Python’ın 2.x serisinden bir sürümle yazılmış pek çok program bulunuyor.
3.x serisi ise ancak son yıllarda yaygınlık kazanmaya başladı.

> **Not**
> Biz bu kitapta kolaylık olsun diye Python’ın 3.x serisini Python3; 2.x serisini ise Python2 olarak adlandıracağız.

Not

Biz bu kitapta kolaylık olsun diye Python’ın 3.x serisini Python3; 2.x serisini ise Python2 olarak adlandıracağız.

Python3, Python2’ye göre hem çok daha güçlüdür, hem de Python2’nin hatalarından arındırılmıştır.
Python3’teki büyük değişikliklerden ötürü, Python2 ile yazılmış bir program Python3 altında çalışmayacaktır.
Aynı durum bunun tersi için de geçerlidir.
Yani Python3 kullanarak yazdığınız bir program Python2 altında çalışmaz.

Dediğimiz gibi, piyasada Python2 ile yazılmış çok sayıda program var.
İşte bu sebeple Python geliştiricileri uzun bir süre daha Python2’yi geliştirmeye devam edecek.
Elbette geliştiriciler bir yandan da Python3 üzerinde çalışmayı ve bu yeni seriyi geliştirmeyi sürdürecek.

Farklı Python serilerinin var olmasından ötürü, Python ile program yazarken hangi seriye ait sürümlerden birini kullandığınızı bilmeniz, yazacağınız programın kaderi açısından büyük önem taşır.

> **Not**
> Biz bu kitapta Python 3.7 kullanacağız. Aksi belirtilmediği sürece bütün kodların bu sürüm ile çalıştırıldığını varsayabilirsiniz.
Ayrıca Python3.7 için yazacağımız kodlar daha yüksek versiyonlarda da çalışacaktır.

Not

Biz bu kitapta Python 3.7 kullanacağız. Aksi belirtilmediği sürece bütün kodların bu sürüm ile çalıştırıldığını varsayabilirsiniz.
Ayrıca Python3.7 için yazacağımız kodlar daha yüksek versiyonlarda da çalışacaktır.

### Hangi Seriyi Öğrenmeliyim?

Dediğimiz gibi, şu anda piyasada iki farklı Python serisi var: Python3 ve Python2.
Peki acaba hangi seriye ait bir sürümü öğrenmelisiniz?

[Kısa cevap]

Python3’ü öğrenmelisiniz.

[Uzun cevap]

Eğer Python programlama diline yeni başlıyorsanız Python3’ü öğrenmeniz daha doğru olacaktır.
Ama eğer Python programlama dilini belirli bir proje üzerinde çalışmak üzere öğreniyorsanız, hangi sürümü öğrenmeniz gerektiği, projede kullanacağınız yardımcı modüllerin durumuna bağlıdır.
Zira şu anda piyasada bulunan bütün Python modülleri/programları henüz Python3’e aktarılmış değil.

Eğer projenizde kullanmayı planladığınız yardımcı modüller halihazırda Python3’e aktarılmışsa Python3’ü öğrenebilirsiniz.
Ancak eğer bu modüllerin henüz Python3 sürümü çıkmamışsa sizin de Python2 ile devam etmeniz daha uygun olabilir.
Ama her halükarda Python3’ün bu dilin geleceği olduğunu ve günün birinde Python2’nin tamamen tedavülden kalkacağını da aklınızın bir köşesinde bulundurun.

> **Uyarı**
> 1 Ocak 2020 itibarıyla Python2’ye verilen destek bitmiştir.Python Yazılım Vakfıartık Python2.x sürümlerini geliştirmemektedir.
Yukarıda yazarın yazdığı satırların günümüzde bir geçerliliği kalmamış, önemli Python kütüphanelerinin neredeyse hepsi Python3’e
geçmiş ve Python2 desteklerini 2021’de bırakacaklarını duyurmuştur. Python’u yeni öğrenen biri olarak Python2 yerine Python3’ü seçmeniz
çok daha doğru olur.
Ayrıntılı bilgi için bu linklere bakabilirsiniz:
> https://www.python.org/doc/sunset-python-2/
> https://pythonclock.org/
> https://python3statement.github.io

Uyarı

1 Ocak 2020 itibarıyla Python2’ye verilen destek bitmiştir.Python Yazılım Vakfıartık Python2.x sürümlerini geliştirmemektedir.
Yukarıda yazarın yazdığı satırların günümüzde bir geçerliliği kalmamış, önemli Python kütüphanelerinin neredeyse hepsi Python3’e
geçmiş ve Python2 desteklerini 2021’de bırakacaklarını duyurmuştur. Python’u yeni öğrenen biri olarak Python2 yerine Python3’ü seçmeniz
çok daha doğru olur.
Ayrıntılı bilgi için bu linklere bakabilirsiniz:
- https://www.python.org/doc/sunset-python-2/
- https://pythonclock.org/
- https://python3statement.github.io

https://www.python.org/doc/sunset-python-2/

https://pythonclock.org/

https://python3statement.github.io

## Python Nasıl Kurulur?

Python ile program yazabilmemiz için bu programlama dilinin bilgisayarımızda kurulu olması gerekiyor.
Bu programlama dilini kurmanızın gerekip gerekmediği, kullandığınız işletim sistemine bağlıdır.
Biz burada hem GNU/Linux hem de Windows kullanıcılarının durumunu sırasıyla ve ayrı ayrı inceleyeceğiz.
Dilerseniz öncelikle GNU/Linux kullanıcılarının durumuna bakalım:

> **Not**
> Bu kitap boyunca bazı konuların GNU/Linux ve Windows kullanıcıları için ayrı ayrı anlatıldığını göreceksiniz.
Ancak konular bu şekilde ayrılmış da olsa, ben size her ikisini de okumanızı tavsiye ederim.
Çünkü bu bölümlerde her iki kullanıcı grubunun da ilgisini çekebilecek bilgilere rastlayacaksınız.
Ayrıca bu bölümler farklı kullanıcı gruplarına hitap ediyor olsa da, aslında bu bölümlerin birbirini tamamlayıcı nitelikte olduğunu göreceksiniz.

Not

Bu kitap boyunca bazı konuların GNU/Linux ve Windows kullanıcıları için ayrı ayrı anlatıldığını göreceksiniz.
Ancak konular bu şekilde ayrılmış da olsa, ben size her ikisini de okumanızı tavsiye ederim.
Çünkü bu bölümlerde her iki kullanıcı grubunun da ilgisini çekebilecek bilgilere rastlayacaksınız.
Ayrıca bu bölümler farklı kullanıcı gruplarına hitap ediyor olsa da, aslında bu bölümlerin birbirini tamamlayıcı nitelikte olduğunu göreceksiniz.

### GNU/Linux Kullanıcıları

GNU/Linux dağıtımlarına Python programlama dilini kurarken bazı noktaları göz önünde bulundurmamız gerekiyor.
İşte bu bölümde bu önemli noktaların neler olduğunu inceleyeceğiz.

#### Kurulu Python Sürümü

Hemen hemen bütün GNU/Linux dağıtımlarında Python programlama dili kurulu olarak gelir.
Örneğin Ubuntu’da Python zaten kuruludur.

Ancak burada şöyle bir durum var:

Daha önce de belirttiğimiz gibi, şu anda piyasada iki farklı Python serisi bulunuyor.
Bunlardan birinin Python’ın 2.x serisi, ötekinin ise 3.x serisi olduğunu biliyorsunuz.

Sisteminizde kurulu olan Python sürümünü denetlemek için komut satırında öncelikle şu komutu vermeyi deneyin (büyük ‘V’ ile):

```python
python -V

```

Eğer bu komuttanPython 2.x.yşeklinde bir çıktı alıyorsanız, yani x ve y’den önceki kısım 2 ile başlıyorsa sisteminizde Python2 kuruludur.

Ancakpython-VkomutundanPython 2.x.yşeklinde bir çıktı almanız sisteminizdesadecePython2’nin kurulu olduğunu göstermez.
Sisteminizde Python2 ile birlikte Python3 de halihazırda kurulu olabilir.
Örneğin Ubuntu GNU/Linux’un12.10sürümünden itibaren hem Python2, hem de Python3 sistemde kurulu vaziyettedir.

Kullandığınız GNU/Linux dağıtımında durumun ne olduğunu denetlemek için yukarıdaki komutu bir depython3-Vşeklinde çalıştırmayı deneyebilirsiniz.
Eğer bu komut size bir hata mesajı yerine bir sürüm numarası veriyorsa sisteminizde Python3 de kuruludur.

Sisteminizdeki Python sürümlerine ilişkin daha kesin bir rapor içinse şu komutu kullanabilirsiniz:

```python
ls -g {,/usr{,/local}}/bin | grep python

```

Buradan aldığınız çıktıyı inceleyerek de sisteminizde birden fazla Python sürümünün kurulu olup olmadığını görebilirsiniz.

Ayrıca kullandığınız GNU/Linux dağıtımındawhereispythongibi bir komut vererek de sistemde kurulu Python sürümleri hakkında bilgi edinebilirsiniz.

Eğer sisteminizde Python3 kuruluysa ve siz de kurulu olan Python3 sürümünden memnunsanız herhangi bir şey yapmanıza gerek yok.
Farklı bir Python sürümü kurmaya çalışmadan yolunuza devam edebilirsiniz.

#### Paket Deposundan Kurulum

Sistemlerinde öntanımlı olarak herhangi bir Python3 sürümü kurulu olmayan veya sistemlerinde kurulu öntanımlı Python3 sürümünden memnun olmayan GNU/Linux kullanıcılarının, Python3’ü elde etmek için tercih edebileceği iki yol var:
Birincisi ve benim size önereceğim yol, öncelikle kullandığınız dağıtımın paket yöneticisini kontrol etmenizdir.
Python3 sisteminizde kurulu olmasa bile, dağıtımınızın depolarında bu sürüm paketlenmiş halde duruyor olabilir.
O yüzden sisteminize uygun bir şekilde paket yöneticinizi açıp orada ‘python’ kelimesini kullanarak bir arama yapmanızı öneririm.
Örneğin Ubuntu GNU/Linux dağıtımının paket depolarında Python3 var.
Dolayısıyla Ubuntu kullanıcıları, eğer sistemlerinde zaten kurulu değilse (ki muhtemelen kuruludur), bu paketi Ubuntu Yazılım Merkezi aracılığıyla veya doğrudan şu komutla kurabilir:

```python
sudo apt-get install python3

```

RHEL/CentOS kullanıcıları ise şu komutu kullanabilir:

```python
sudo yum install python3

```

Bu komutlar, Python3’ü bütün bağımlılıkları ile beraber bilgisayarınıza kuracaktır.

#### Kaynaktan Kurulum

Peki ya kullandığınız dağıtımın depolarında Python3 yoksa veya depodaki Python3 sürümü eskiyse ve siz daha yeni bir Python3 sürümü kullanmak istiyorsanız ne yapacaksınız?

Eğer dağıtımınızın depolarında Python3 paketini bulamazsanız veya depodaki sürüm sizi tatmin etmiyorsa, Python3’ü kaynaktan derlemeniz gerekecektir.
Python3’ü kaynaktan derlerken iki seçeneğiniz var:
Python3’üroothakları ile kurmak veya Python3’ü yetkisiz kullanıcı olarak kurmak.
Normal şartlar altında eğer kullandığınız sistemderoothaklarına sahipseniz Python3’ü yetkili kullanıcı olarak kurmanızı tavsiye ederim.

##### root Hakları İle Kurulum

Python’ı kurmadan önce sistemimizde bulunması gereken bazı programlar var.
Aslında bu programlar olmadan da Python kurulabilir, ancak eğer bu programları kurmazsanız Python’ın bazı özelliklerinden yararlanamazsınız.
Bu programlar şunlardır:
1. tcl-dev
1. tk-dev
1. zlib1g-dev
1. ncurses-dev
1. libreadline-dev
1. libdb-dev
1. libgdbm-dev
1. libzip-dev
1. libssl-dev
1. libsqlite3-dev
1. libbz2-dev
1. liblzma-dev

tcl-dev

tk-dev

zlib1g-dev

ncurses-dev

libreadline-dev

libdb-dev

libgdbm-dev

libzip-dev

libssl-dev

libsqlite3-dev

libbz2-dev

liblzma-dev

Bu programları, kullandığınız GNU/Linux dağıtımının paket yöneticisi aracılığıyla kurabilirsiniz.
Yalnız paket adlarının ve gerekli paket sayısının dağıtımlar arasında farklılık gösterebileceğini unutmayın.
Yukarıdaki liste Ubuntu için geçerlidir.
Mesela yukarıdatcl-devolarak verdiğimiz paket adı başka bir dağıtımda sadecetclolarak geçiyor ya da yukarıdaki paketlerin bazıları kullandığınız dağıtımda halihazırda kurulu olduğu için sizin daha az bağımlılık kurmanız gerekiyor olabilir.

Ubuntu’da yukarıdaki paketlerin hepsini şu komutla kurabilirsiniz:

```python
sudo apt-get install tcl-dev tk-dev zlib1g-dev ncurses-dev libreadline-dev libdb-dev libgdbm-dev libzip-dev libssl-dev libsqlite3-dev libbz2-dev liblzma-dev

```

Yukarıdaki programları kurduktan sonrahttps://www.python.org/ftp/python/3.7.0adresine gidiyoruz.
Bu adreste, üzerinde ‘Python-3.7.0.tar.xz’ yazan bağlantıya tıklayarak sıkıştırılmış kurulum dosyasını bilgisayarımıza indiriyoruz.

Daha sonra bu sıkıştırılmış dosyayı açıyoruz.
Açılan klasörün içine girip, orada ilk olarak şu komutu veriyoruz:

```python
./configure

```

Bu komut, Python programlama dilinin sisteminize kurulabilmesi için gereken hazırlık aşamalarını gerçekleştirir.
Bu betiğin temel olarak yaptığı iş, sisteminizin Python programlama dilinin kurulmasına uygun olup olmadığını, derleme işlemi için gereken yazılımların sisteminizde kurulu olup olmadığını denetlemektir.
Bu betik ayrıca, bir sonraki adımda gerçekleştireceğimiz inşa işleminin nasıl yürüyeceğini tarif edenMakefileadlı bir dosya da oluşturur.

Bu arada bu komutun başındaki./işareti, o anda içinde bulunduğunuz dizinde yer alanconfigureadlı bir betiği çalıştırmanızı sağlıyor.
Eğer yalnızcaconfigurekomutu verirseniz, işletim sistemi bu betiği PATH dizinleri içinde arayacak ve bulamayacağı için de hata verecektir.

./configurekomutu hatasız olarak tamamlandıktan sonra ikinci olarak şu komutu veriyoruz:

```python
make

```

Burada aslında./configurekomutu ile oluşanMakefileadlı dosyayımakeadlı bir program aracılığıyla çalıştırmış oluyoruz.makebir sistem komutudur.
Bu komutu yukarıdaki gibi parametresiz olarak çalıştırdığımızdamakekomutu, o anda içinde bulunduğumuz dizinde birMakefiledosyası arar ve eğer böyle bir dosya varsa onu çalıştırır.
Eğer bir önceki adımda çalıştırdığımız./configurekomutu başarısız olduysa, dizinde birMakefiledosyası oluşmayacağı için yukarıdakimakekomutu da çalışmayacaktır.
O yüzden derleme işlemi sırasında verdiğimiz komutların çıktılarını takip edip, bir sonraki aşamaya geçmeden önce komutun düzgün sonlanıp sonlanmadığından emin olmamız gerekiyor.

makekomutunun yaptığı iş, Python programlama dilinin sisteminize kurulması esnasında sistemin çeşitli yerlerine kopyalanacak olan dosyaları inşa edip oluşturmaktır.
Bu komutun tamamlanması, kullandığınız bilgisayarın kapasitesine bağlı olarak biraz uzun sürebilir.

makekomutu tamamlandıktan sonra, komut çıktısının son satırlarına doğru şöyle bir uyarı mesajı görebilirsiniz:

```python
Python build finished, but the necessary bits to build these modules were not found:
[burada eksik olan modül veya modüllerin adları sıralanır]

```

Burada Python, sistemimizde bazı paketlerin eksik olduğu konusunda bizi uyarıyor.
Uyarı mesajında bir veya daha fazla paketin eksik olduğunu görebilirsiniz.
Eğer öyleyse, eksik olduğu bildirilen bütün paketleri kurmamız gerekiyor.

Gerekli paketi ya da paketleri kurduktan sonramakekomutunu tekrar çalıştırıyoruz.
Endişe etmeyin,makekomutunu ikinci kez verdiğimizde komutun tamamlanması birincisi kadar uzun sürmez.
Eğer bu komutu ikinci kez çalıştırdığınızda yukarıdaki uyarı mesajı kaybolduysa şu komutla yolunuza devam edebilirsiniz:

```python
sudo make altinstall

```

Daha önce kaynaktan program derlemiş olan GNU/Linux kullanıcılarının eli,makekomutundan sonramakeinstallkomutunu vermeye gitmiş olabilir.
Ama burada bizimmakeinstallyerinemakealtinstallkomutunu kullandığımıza dikkat edin.makealtinstallkomutu, Python kurulurken klasör ve dosyalara sürüm numarasının da eklenmesini sağlar.
Böylece yeni kurduğunuz Python, sistemdeki eski Python3 sürümünü silip üzerine yazmamış olur ve iki farklı sürüm yan yana varolabilir.
Eğermakealtinstallyerinemakeinstallkomutunu verirseniz sisteminizde zaten varolan eski bir Python3 sürümüne ait dosya ve dizinlerin üzerine yazıp silerek o sürümü kullanılamaz hale getirebilirsiniz.
Bu da sistemde beklenmedik problemlerin ortaya çıkmasına yol açabilir.
Bu önemli ayrıntıyı kesinlikle gözden kaçırmamalısınız.

Derleme aşamalarının hiçbirinde herhangi bir hata mesajı almadıysanız kurulum başarıyla gerçekleşmiş ve sisteminize Python programlama dilinin 3.x sürümü kurulmuş demektir.

##### Yetkisiz Kullanıcı Olarak Kurulum

Elbettesudomakealtinstallkomutunu verip Python’ı kurabilmek içinroothaklarına sahip olmanız gerekiyor.
Ama eğer kullandığınız sistemde bu haklara sahip değilseniz Python’ı bu şekilde kuramazsınız.
Kısıtlı haklara sahip olduğunuz bir sistemde Python’ı ancak kendi ev dizininize ($HOME) kurabilirsiniz.

Eğer Python’ı yetkisiz kullanıcı olarak kuracaksanız, öncelikle yukarıda bahsettiğimiz Python bağımlılıklarının sisteminizde kurulu olup olmadığını kontrol etmeniz lazım.
Kullandığınız sistemde herhangi bir Python sürümü halihazırda kuruluysa, bu bağımlılıklar da muhtemelen zaten kuruludur.
Ama değilse, bunları kurması için ya sistem yöneticisine ricada bulunacaksınız, ya da bu bağımlılıkları da tek tek kendi ev dizininize kuracaksınız.
Eğer sistem yöneticisini bu bağımlılıkları kurmaya ikna edemezseniz, internet üzerinden bulabileceğiniz bilgiler yardımıyla bu bağımlılıkları tek tek elle kendiniz kurabilirsiniz.
Ancak bu işlemin epey zaman alacağını ve süreç sırasında pek çok başka bağımlılıkla da karşılacağınızı söyleyebilirim.
O yüzden ne yapıp edip sistem yöneticisini bağımlılıkları kurmaya ikna etmenizi tavsiye ederim…
Tabii sistem yöneticisini bu bağımlılıkları kurmaya ikna edebilirseniz, istediğiniz Python sürümünü de kurmaya ikna edebileceğinizi düşünebiliriz!
Ama biz burada sizin Python’ı kendinizin kuracağını varsayarak yolumuza devam edelim.

Python’ı yetkisiz olarak kurmak,roothaklarıyla kurmaya çok benzer.
Aralarında yalnızca bir-iki ufak fark vardır.
Mesela Python’ı yetkisiz kullanıcı olarak kurarken,./configurekomutunu şu şekilde vermeniz gerekiyor:

```python
./configure --prefix=$HOME/python

```

Python’ıroothaklarıyla kurduğunuzda Python/usrdizini altına kurulacaktır.
Ancak siz yetkisiz kullanıcı olduğunuz için/usrdizinine herhangi bir şey kuramazsınız.
İşte bu yüzden,configurebetiğine verdiğimiz–prefixparametresi yardımıyla Python’ı, yazma yetkimiz olan bir dizine kuruyoruz.
Mesela yukarıdaki komut Python’ın/usrdizinine değil, ev dizininiz içindepythonadlı bir klasöre kurulmasını sağlayacaktır.
Elbette sizpythonyerine farklı bir dizin adı da belirleyebilirsiniz.
Burada önemli olan nokta,–prefixparametresine vereceğiniz dizin adının, sizin yazmaya yetkili olduğunuz bir dizin olmasıdır.

Bu komutu çalıştırdıktan sonramakekomutunu normal bir şekilde veriyoruz.
Bunun ardından damakeinstall(veya duruma göremakealtinstall) komutuyla Python’ı ev dizinimize kuruyoruz.
Buradamakeinstallkomutunusudo’suz kullandığımıza dikkat edin.
Çünkü, dediğimiz gibi, siz yetkili kullanıcı olmadığınız içinsudokomutunu kullanamazsınız.

Python’ı bu şekilde ev dizininiz altında bir klasöre kurduğunuzda Python ile ilgili bütün dosyaların bu klasör içinde yer aldığını göreceksiniz.
Bu klasörü dikkatlice inceleyip neyin nerede olduğuna aşinalık kazanmaya çalışın.
Eğer mümkünseroothakları ile kurulmuş bir Python sürümünü inceleyerek, dosyaların iki farklı kurulum türünde nerelere kopyalandığını karşılaştırın.

Böylece Python programlama dilini bilgisayarımıza nasıl kuracağımızı öğrenmiş olduk.
Ama bu noktada bir uyarı yapmadan geçmeyelim:
Python özellikle bazı GNU/Linux dağıtımlarında pek çok sistem aracıyla sıkı sıkıya bağlantılıdır.
Yani Python, kullandığınız dağıtımın belkemiği durumunda olabilir.
Bu yüzden Python’ı kaynaktan derlemek bazı riskler taşıyabilir.
Eğer yukarıda anlatıldığı şekilde, kaynaktan Python derleyecekseniz, karşı karşıya olduğunuz risklerin farkında olmalısınız.
Ayrıca GNU/Linux üzerinde kaynaktan program derlemek konusunda tecrübeli değilseniz ve eğer yukarıdaki açıklamalar size kafa karıştırıcı geliyorsa, mesela ‘Ben bu komutları nereye yazacağım?’ diye bir soru geçiyorsa aklınızdan, kesinlikle dağıtımınızla birlikte gelen Python sürümünü kullanmalısınız.
Python sürümlerini başa baş takip ettiği için, ben size Ubuntu GNU/Linux’u denemenizi önerebilirim.
Ubuntu’nun depolarında Python’ın en yeni sürümlerini rahatlıkla bulabilirsiniz.
Ubuntu’nun resmi sitesineubuntu.comadresinden, yerel Türkiye sitesine iseforum.ubuntu-tr.netadresinden ulaşabilirsiniz.
Eğer şu anda kullandığınız GNU/Linux dağıtımından vazgeçmek istemiyorsanız, sabit diskinizden küçük bir bölüm ayırıp bu bölüme sadece Python çalışmalarınız için Ubuntu dağıtımını da kurmayı tercih edebilirsiniz.

Yalnız küçük bir uyarı daha yapalım.
Kaynaktan kurulum ile ilgili bu söylediklerimizden, Python’ın GNU/Linux’a kesinlikle kaynaktan derlenerek kurulmaması gerektiği anlamı çıkmamalı.
Yukarıdaki uyarıların amacı, kullanıcının Python’ı kaynaktan derlerken sadece biraz daha dikkatli olması gerektiğini hatırlatmaktır.
Örneğin bu satırların yazarı, kullandığı Ubuntu sisteminde Python3’ü kaynaktan derleyerek kullanmayı tercih ediyor ve herhangi bir problem yaşamıyor.

Bu önemli uyarıları da yaptığımıza göre gönül rahatlığıyla yolumuza devam edebiliriz.

Kurduğumuz yeni Python’ı nasıl çalıştıracağımızı biraz sonra göreceğiz.
Ama önce Windows kullanıcılarının Python3’ü nasıl kuracaklarına bakalım.

#### Sürüm Yöneticisi ile Kurulum (pyenv)

Sisteminize bir veya birden fazla Python sürümü kurmak istiyorsunuz fakat root hakları, kaynaktan sürüm derlemeleri vb. işlemler gözünüzü mü korkutuyor? Bütün bu işlemleri çok daha hızlı, pratik ve güvenli bir şekildepyenvile gerçekleştirebilirsiniz.pyenvsisteminizde birden fazla Python sürümünü kullanabilmenizi sağlayan ve birçok kolaylığı da beraberinde getiren bir araçtır. Bunun için önceliklepyenv-installerile sistemimizepyenvkurmamız gerekmektedir. Kurulum için aşağıdaki komutu çalıştırmanız yeterlidir:

```python
curl https://pyenv.run | bash

```

Kurulum tamamlandıktan sonra aşağıdaki şekilde bir mesaj çıkacaktır:

```python
# Load pyenv automatically by adding
# the following to ~/.bashrc:

export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"

```

Buradaki son 3 satırı ana dizininizdeki.bashrcdosyanızın(veya farklı bir shell kullanıyorsanız ilgili dosyanın)sonuna eklemeniz gerekmektedir. Eklemeyi yapıp kaydettikten sonrapyenv’i kullanmaya başlamak için terminali yeniden başlatmanız veya terminalesource~/.bashrcyazmanız yeterlidir.

pyenvile yükleyebileceğiniz Python sürümlerini listeleyebilmek için tek yapmanız gereken şu komutu çalıştırmaktır:

```python
pyenv install --list

```

Yalnızca 3.8.x sürümlerini listelemek içinse:

```python
pyenv install --list |grep " 3.8.*"

```

Komutunu çalıştırabilirsiniz. Eğer bütün sürümleri listelediyseniz görebileceğiniz üzere,pyenvile kurabileceğiniz Python sürümü sayısı oldukça fazladır. Bu sürümlerden herhangi bir tanesini kurmadan öncepyenv’in kurulumları tamamlayabilmesi için ihtiyaç duyduğu bağımlılıkları kurmanızı tavsiye ederim. Aksi takdirde kurulumu bekleyip hata alma olasılığınız yüksektir. O hata mesajı da sizi şu linke yönlendirecektir:(pyenv | Sık Karşılaşılan Hatalar)

##### pyenv Bağımlılıkların Kurulumu
- Ubuntu/Debian:sudo apt-get install -y build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \
xz-utils tk-dev libffi-dev liblzma-dev python-openssl git
- Fedora:sudo dnf install zlib-devel bzip2 bzip2-devel readline-devel sqlite \
sqlite-devel openssl-devel xz xz-devel libffi-devel findutils
- RHEL/CentOS:sudo yum install zlib-devel bzip2 bzip2-devel readline-devel sqlite \
sqlite-devel openssl-devel xz xz-devel libffi-devel findutils
- Arch ve türevleri:pacman -S --needed base-devel openssl zlib bzip2 readline sqlite curl \
llvm ncurses xz tk libffi python-pyopenssl git

Ubuntu/Debian:

```python
sudo apt-get install -y build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \
xz-utils tk-dev libffi-dev liblzma-dev python-openssl git

```

Fedora:

```python
sudo dnf install zlib-devel bzip2 bzip2-devel readline-devel sqlite \
sqlite-devel openssl-devel xz xz-devel libffi-devel findutils

```

RHEL/CentOS:

```python
sudo yum install zlib-devel bzip2 bzip2-devel readline-devel sqlite \
sqlite-devel openssl-devel xz xz-devel libffi-devel findutils

```

Arch ve türevleri:

```python
pacman -S --needed base-devel openssl zlib bzip2 readline sqlite curl \
llvm ncurses xz tk libffi python-pyopenssl git

```

##### Yeni Sürümlerin Kurulumu

pyenviçin gerekli ayarları yaptıktan sonra yeni bir Python sürümü kurabilmek için tek yapmanız gerekenpyenvinstall<python-sürümü>şeklinde bir komut çalıştırmaktır.<python-sürümü>kısmına yazacağımız sürüm bilgisipyenvinstall--listsonuçları ile aynı isimde olmalıdır. Python 3.8.5 sürümünü kurmak için yapmanız gereken aşağıdaki komutu çalıştırmaktır:

```python
pyenv install 3.8.5

```

Bu komut ile3.8.5sürümü sisteminize yüklenecektir.

##### Yüklenen Sürümün Kullanımı

Yüklediğiniz sürümün doğrulamasını yapmak içinpyenvversionskomutunu çalıştırabilirsiniz. Eğer yükleme uygun bir şekilde tamamlandı ise komutu çalıştırdığınızda görmeniz gereken çıktı şu şekildedir:

```python
* system
3.8.5

```

*işareti hali hazırda aktif olan sürümü temsil etmektedir. Kurduğunuz sürümü aktif olarak kullanabilmek için çalıştırmanız gereken komut şudur:

```python
pyenv global 3.8.5

```

pyenvile temel seviyede Python yükleme ve etkinleştirme kısmı bu şekilde özetlenebilir.pyenvkullanımıyla ilgili detaylaraGNU/Linux’ta Farklı Sürümleri Birlikte Kullanmak :ref:`gnu-linux-ta-farkli-surumleri-birlikte-kullanmakkısmında değineceğiz.

### Windows Kullanıcıları

Windows sürümlerinin hiçbirinde Python kurulu olarak gelmez.
O yüzden Windows kullanıcıları, Python’ı sitesinden indirip kuracak.

Bunun için önceliklehttps://www.python.org/downloads/adresine gidiyoruz.

Bu adrese gittiğinizde, üzerinde ‘Download Python 3.7.0’ yazan bir düğme göreceksiniz.
Daha önce de söylediğimiz gibi, eğer bir Python sürüm numarası ‘2’ ile başlıyorsa o sürüm 2.x serisine, yok eğer ‘3’ ile başlıyorsa 3.x serisine aittir.
Dolayısıyla bu düğme Python3 sürümünü içerir.

Bu düğmeye tıklıyoruz.
Bu düğmeye tıkladığınızda bilgisayarınıza.exeuzantılı kurulum dosyası inecek.
Bu dosyaya çift tıklayarak kurulum programını başlatabilirsiniz.

> **Not**
> Eğer indireceğiniz Python sürümünün mimarisini ve sürümünü kendiniz seçmek istersenizhttps://www.python.org/ftp/python/3.7.0adresinden kendinize uygun olan sürümü bulup indirebilirsiniz.

Not

Eğer indireceğiniz Python sürümünün mimarisini ve sürümünü kendiniz seçmek istersenizhttps://www.python.org/ftp/python/3.7.0adresinden kendinize uygun olan sürümü bulup indirebilirsiniz.

Kurulum dosyasına çift tıkladığınızda karşınıza ilk gelen ekranda, pencerenin alt tarafında şu kutucukları göreceksiniz:
1. Install launcher for all users (recommended)
1. Add Python 3.7 to PATH

Install launcher for all users (recommended)

Add Python 3.7 to PATH

Burada ilk kutucuk zaten seçilidir.
Bunu bu şekilde bırakabilirsiniz.
İkinci kutucuk ise Python’ı yola eklememizi, böylece yalnızcapythonkomutu vererek Python’ı başlatabilmemizi sağlayacak.
O yüzden oradaki ikinci kutucuğu da işaretliyoruz.

Aynı pencerenin üst tarafında ise şu seçenekleri göreceksiniz:
1. -> Install Now
1. -> Customize Installation

-> Install Now

-> Customize Installation

Burada ‘Install Now’ yazan kısma tıklayarak kurulumu başlatıyoruz.

Eğer Python’ın bilgisayarda nereye kurulacağını ve başka birtakım kurulum özelliklerini değiştirmek istiyorsanız ‘Customize Installation’ yazılı kısma tıklayabilirsiniz.
Ben bu kitapta sizin ‘Install Now’ yazan kısma tıklayarak kurulum yaptığınızı varsayacağım.

> **Not**
> Python’ın resmi sitesinde dolaşırken kurulum dosyaları arasında, ‘web-based installer’ (web tabanlı kurulum betiği) adlı bir kurulum dosyası görebilirsiniz.
Bu kurulum dosyası, Python’ın çalışması için gereken dosyaları kurulum esnasında internetten indirip kuran, 1MB’dan küçük bir kurulum programı içerir.
Dolayısıyla eğer kurulumu bu dosyadan yapacaksanız, kesintisiz bir internet bağlantısına ihtiyacınız olacak.

Not

Python’ın resmi sitesinde dolaşırken kurulum dosyaları arasında, ‘web-based installer’ (web tabanlı kurulum betiği) adlı bir kurulum dosyası görebilirsiniz.
Bu kurulum dosyası, Python’ın çalışması için gereken dosyaları kurulum esnasında internetten indirip kuran, 1MB’dan küçük bir kurulum programı içerir.
Dolayısıyla eğer kurulumu bu dosyadan yapacaksanız, kesintisiz bir internet bağlantısına ihtiyacınız olacak.

> **Uyarı**
> Eğer Windows’ta Python’ı kurmaya çalışırken hata alıyorsanız, muhtemelen işletim sisteminiz güncel değildir.
Örneğin Windows 7’de Python kurabilmeniz için, SP1 (Service Pack 1) kurulu olmalıdır.
Windows güncellemelerini kurduktan sonra Python’ı kurmayı tekrar deneyin. Ancak Windows XP kullanıyorsanız kurabileceğiniz en yüksek sürüm, Python 3.4’tür.
Ne yazık ki Windows XP artık desteklenmiyor.

Uyarı

Eğer Windows’ta Python’ı kurmaya çalışırken hata alıyorsanız, muhtemelen işletim sisteminiz güncel değildir.
Örneğin Windows 7’de Python kurabilmeniz için, SP1 (Service Pack 1) kurulu olmalıdır.
Windows güncellemelerini kurduktan sonra Python’ı kurmayı tekrar deneyin. Ancak Windows XP kullanıyorsanız kurabileceğiniz en yüksek sürüm, Python 3.4’tür.
Ne yazık ki Windows XP artık desteklenmiyor.

### Python Kurulum ve Çalışma Dizini

Python programlama dilini, kullandığımız işletim sistemine nasıl kurabileceğimizi bilmek kadar önemli bir konu da Python’ı hangi dizine kurduğumuzu bilmektir.
Zira programcılık maceramız boyunca karşılaşacağımız bazı sorunlar, Python’ın kurulu olduğu dizine gitmemizi gerektirecek, üstelik kendi yazdığımız bazı programlarda da Python’ın kurulu olduğu dizinde çeşitli işlemler yapmak ihtiyacı duyacağız.
Ayrıca bazı durumlarda, o anda çalışan Python sürümünün hangi konumdan çalıştığını tespit etmemiz de gerekebilir.

İşte bu sebeplerden, Python’ın hangi dizine kurulduğunu mutlaka biliyor olmamız lazım.

Python’ın, işletim sisteminizde hangi dizine kurulduğu, Python’ı nasıl kurduğunuza bağlı olarak farklılık gösterir.

GNU/Linux dağıtımlarında Python genellikle/usr/lib/python3.7dizininde kurulur.
Ama elbette, eğer siz Python’ı kaynaktan derlediyseniz, derleme sırasındaconfigurebetiğine verdiğiniz–prefixparametresi yardımıyla Python’ın kurulum dizinini kendiniz de belirlemiş olabilirsiniz.

Windows’ta Python programlama dilini aynen bu kitapta gösterdiğimiz şekilde kurduysanız, Python%LOCALAPPDATA%\Programs\Pythondizini içine kurulacaktır.
Ancak eğer kurulum penceresinde ‘Customize Installation’ düğmesine basarak kurulumu özelleştirdiyseniz ve ‘Install for all users’ seçeneğini işaretlediyseniz Python%PROGRAMFILES%veya%PROGRAMFILES(x86)adlı çevre değişkenlerinin işaret ettiği dizin içine kurulacaktır.

## Python Nasıl Çalıştırılır?

Bir önceki bölümde, Python’ı farklı platformlara nasıl kuracağımızı bütün ayrıntılarıyla anlattık.
Bu bölümde ise kurduğumuz bu Python programını hem GNU/Linux’ta hem de Windows’ta nasıl çalıştıracağımızı göreceğiz.
Öncelikle GNU/Linux kullanıcılarının Python’ı nasıl çalıştıracağına bakalım.

### GNU/Linux Kullanıcıları

Geçen bölümlerde gördüğünüz gibi, Python3’ü GNU/Linux sistemleri üzerine farklı şekillerde kurabiliyoruz.
Bu bölümde, her bir kurulum türü için Python3’ün nasıl çalıştırılacağını ayrı ayrı inceleyeceğiz.

#### Kurulu Python3’ü Kullananlar

Eğer sisteminizde zaten Python3 kurulu ise komut satırında yalnızca şu komutu vererek Python3’ü başlatabilirsiniz:

```python
python

```

Ancak daha önce de dediğimiz gibi, 19.08.2024 tarihi itibariyle pek çok GNU/Linux dağıtımında öntanımlı olarak Python2 kuruludur.
Dolayısıylapythonkomutunu verdiğinizde çalışan sürüm muhtemelen Python2 olacaktır.
Bu yüzden sistemimizde öntanımlı olarak hangi sürümün kurulu olduğuna vepythonkomutunun hangi sürümü başlattığına çok dikkat etmelisiniz.

Yine daha önce de söylediğimiz gibi, sisteminizde hem Python2 hem de Python3 zaten kurulu durumda olabilir.
O yüzden yukarıdaki komutu bir depython3şeklinde vermeyi deneyebilirsiniz.

Örneğin Ubuntu GNU/Linux dağıtımının12.10sürümünden itibarenpythonkomutu Python2’yi;python3komutu ise Python3’ü çalıştırıyor.

#### Python3’ü Depodan Kuranlar

Dediğimiz gibi, 19.08.2024 tarihi itibariyle GNU/Linux dağıtımlarında öntanımlı Python sürümü ağırlıklı olarak Python2’dir.
Dolayısıylapythonkomutu Python’ın 2.x sürümlerini çalıştırır.
Bu durumdan ötürü, herhangi bir çakışmayı önlemek için GNU/Linux dağıtımları Python3 paketini farklı bir şekilde adlandırma yoluna gider.
Şu anda piyasada bulunan dağıtımların ezici çoğunluğu Python3 paketini ‘python3’ şeklinde adlandırıyor.
O yüzden GNU/Linux kullanıcıları, eğer paket yöneticilerini kullanarak Python kurulumu gerçekleştirmiş iseler, komut satırında şu komutu vererek Python3’ü başlatabilirler:

```python
python3

```

Bu komutun ardından şuna benzer bir ekranla karşılaşmış olmalısınız:

yazbel@ubuntu:~$# python3
Python 3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux
Type “help”, “copyright”, “credits” or “license” for more information.
>>>

Eğer yukarıdaki ekranı gördüyseniz Python’la programlama yapmaya hazırsınız demektir.
Değilse, geriye dönüp işlerin nerede ters gittiğini bulmaya çalışabilirsiniz.

Bu aşamada işlerin nerede ters gitmiş olabileceğine dair birkaç ipucu verelim:
1. Python3 kurulurken paket yöneticinizin herhangi bir hata vermediğinden, programın sisteminize başarıyla kurulduğundan emin olun.
Bunun için Python3’ün kurulu paketler listesinde görünüp görünmediğini denetleyebilirsiniz.
1. python3komutunu doğru verdiğinize emin olun.
Python programlama diline özellikle yeni başlayanların en sık yaptığı hatalardan biripythonkelimesini yanlış yazmaktır.Pythonyerine yanlışlıklapyhton,pytonveyaphytonyazmış olabilirsiniz.
Ayrıcapython3komutunun tamamen küçük harflerden oluştuğuna dikkat edin.Pythonvepythonbilgisayar açısından aynı şeyler değildir.
1. Kullandığınız dağıtımın Python3 paketini adlandırma politikası yukarıda anlattığımızdan farklı olabilir.
Yani sizin kullandığınız dağıtım, belki de Python3 paketini farklı bir şekilde adlandırmıştır.
Eğer durum böyleyse, dağıtımınızın yardım kaynaklarını (wiki, forum, irc, yardım belgeleri, kullanıcı listeleri, vb.) kullanarak ya daforum.yazbel.comadresinde sorarak Python3’ün nasıl çalıştırılacağını öğrenmeyi deneyebilirsiniz.

Python3 kurulurken paket yöneticinizin herhangi bir hata vermediğinden, programın sisteminize başarıyla kurulduğundan emin olun.
Bunun için Python3’ün kurulu paketler listesinde görünüp görünmediğini denetleyebilirsiniz.

python3komutunu doğru verdiğinize emin olun.
Python programlama diline özellikle yeni başlayanların en sık yaptığı hatalardan biripythonkelimesini yanlış yazmaktır.Pythonyerine yanlışlıklapyhton,pytonveyaphytonyazmış olabilirsiniz.
Ayrıcapython3komutunun tamamen küçük harflerden oluştuğuna dikkat edin.Pythonvepythonbilgisayar açısından aynı şeyler değildir.

Kullandığınız dağıtımın Python3 paketini adlandırma politikası yukarıda anlattığımızdan farklı olabilir.
Yani sizin kullandığınız dağıtım, belki de Python3 paketini farklı bir şekilde adlandırmıştır.
Eğer durum böyleyse, dağıtımınızın yardım kaynaklarını (wiki, forum, irc, yardım belgeleri, kullanıcı listeleri, vb.) kullanarak ya daforum.yazbel.comadresinde sorarak Python3’ün nasıl çalıştırılacağını öğrenmeyi deneyebilirsiniz.

Gelelim Python3’ü kaynaktan derlemiş olanların durumuna…

#### Python3’ü root Olarak Derleyenler

Eğer Python3’ü önceki bölümlerde anlattığımız şekilde kaynaktanroothakları ile derlediysenizpython3komutu çalışmayacaktır.
Bunun yerine şu komutu kullanmanız gerekecek:

```python
python3.7
```

> **Not**
> Kurduğunuz Python3 sürümünün3.7olduğunu varsayıyorum.
Eğer farklı bir Python3 sürümü kurduysanız, elbette başlatıcı komut olarak o sürümün adını kullanmanız gerekecektir.
Mesela:python3.0veyapython3.1.
Bu aradapython3.7komutunda 37 sayısının rakamları arasında bir adet nokta işareti olduğunu gözden kaçırmıyoruz…

Not

Kurduğunuz Python3 sürümünün3.7olduğunu varsayıyorum.
Eğer farklı bir Python3 sürümü kurduysanız, elbette başlatıcı komut olarak o sürümün adını kullanmanız gerekecektir.
Mesela:python3.0veyapython3.1.
Bu aradapython3.7komutunda 37 sayısının rakamları arasında bir adet nokta işareti olduğunu gözden kaçırmıyoruz…

Tıpkı paket deposundan kurulumda olduğu gibi, eğer yukarıdaki komut Python’ı çalıştırmanızı sağlamıyorsa, kurulum esnasında bazı şeyler ters gitmiş olabilir.
Örneğin kaynaktan kurulumun herhangi bir aşamasında bir hata almış olabilirsiniz ve bu da Python’ın kurulumunu engellemiş olabilir.

Gördüğünüz gibi, Python’ı kaynaktan derleyenler Python programlama dilini çalıştırabilmek için Python’ın tam sürüm adını belirtiyor.
Dilerseniz bu şekilde çalışmaya devam edebilirsiniz.
Bunun hiçbir sakıncası yok.
Ancak ben size kolaylık açısından,/usr/bin/dizini altınapy3adında bir sembolik bağ yerleştirmenizi tavsiye ederim.
Böylece sadecepy3komutunu vererek Python3’ü başlatabilirsiniz.

Peki bunu nasıl yapacağız?

Python kaynaktan derlendiğinde çalıştırılabilir dosya/usr/local/bin/dizini içinePython3.7(veya kurduğunuz Python3 sürümüne bağlı olarakPython3.0ya daPython3.1) adıyla kopyalanır.
Bu nedenle Python3’ü çalıştırabilmek içinpython3.7komutunu kullanmamız gerekir.
Python3’ü çalıştırabilmek için mesela sadecepy3gibi bir komut kullanmak istiyorsak yapacağımız tek şey/usr/local/bin/dizini içindekipython3.7adlı dosyaya/usr/bindizini altından,py3adlı bir sembolik bağ oluşturmak olacaktır.
Bunun içinlnkomutunu kullanacağız:

```python
ln -s /usr/local/bin/python3.7 /usr/bin/py3
```

Tabii bu komutu yetkili kullanıcı olarak vermeniz gerektiğini söylememe herhalde gerek yoktur.
Bu komutu verdikten sonra artık sadecepy3komutu ile Python programlama dilini başlatabilirsiniz.

##### Çok Önemli Bir Uyarı

Bir önceki adımda anlattığımız gibi Python3’ü resmi sitesinden indirip kendiniz derlediniz.
Gayet güzel.
Ancak bu noktada çok önemli bir konuya dikkatinizi çekmek isterim.
En baştan beri söylediğimiz gibi, Python programlama dili GNU/Linux işletim sistemlerinde çok önemli bir yere sahiptir.
Öyle ki bu programlama dili, kullandığınız dağıtımın belkemiği durumunda olabilir.

Örneğin Ubuntu GNU/Linux dağıtımında pek çok sistem aracı Python ile yazılmıştır.
Bu yüzden, sistemdeki öntanımlı Python sürümünün ne olduğu ve dolayısıylapythonkomutunun hangi Python sürümünü çalıştırdığı çok önemlidir.
Çünkü sisteminizdeki hayati bazı araçlar,pythonkomutunun çalıştırdığı Python sürümüne bel bağlamış durumdadır.
Dolayısıyla sizin bupythonkomutunun çalıştırdığı Python sürümüne dokunmamanız gerekir.

Mesela eğer kullandığınız işletim sistemindepythonkomutu Python’ın 2.x sürümlerinden birini çalıştırıyorsa sembolik bağlar veya başka araçlar vasıtasıylapythonkomutunu Python’ın başka bir sürümüne bağlamayın.
Bu şekilde bütün sistemi kullanılmaz hale getirirsiniz.
Elbette eğer kurulum aşamasında tarif ettiğimiz gibi, Python3’ümakeinstallyerinemakealtinstallkomutu ile kurmaya özen gösterdiyseniz, sonradan oluşturduğunuz bağ dosyasını silippythonkomutunu yine sistemdeki öntanımlı sürüme bağlayabilirsiniz.
Bu şekilde her şey yine eski haline döner.
Ama eğer Python’ımakeinstallkomutuyla kurmanızdan ötürü sistemdeki öntanımlı Python sürümüne ait dosyaları kaybettiyseniz sizin için yapılacak fazla bir şey yok…
Sistemi tekrar eski kararlı haline getirmek için kan, ter ve gözyaşı dökeceksiniz…

Aynı şekilde, kullandığınız dağıtımdapython3komutunun öntanımlı olarak belirli bir Python sürümünü başlatıp başlatmadığı da önemlidir.
Yukarıdapythonkomutu ile ilgili söylediklerimizpython3ve buna benzer başka komutlar için de aynen geçerli.

Örneğin, Ubuntu GNU/Linux dağıtımındapythonkomutu sistemde kurulu olan Python 2.x sürümünü;python3komutu ise sistemde kurulu olan Python 3.x sürümünü çalıştırdığından, biz kendi kurduğumuz Python sürümleri için, sistemdeki sürümlerle çakışmayacak isimler seçtik.
Mesela kendi kurduğumuz Python3 sürümünü çalıştırmak içinpy3gibi bir komut tercih ettik.

İyi bir test olarak, Python programlama dilini kendiniz kaynaktan derlemeden önce şu komutun çıktısını iyice inceleyebilirsiniz:

```python
ls -g {,/usr{,/local}}/bin | grep python

```

Bu komut iki farklı Python sürümünün kurulu olduğu sistemlerde şuna benzer bir çıktı verir (çıktı kırpılmıştır):

```python
dh_python2
dh_python3
pdb2.7 -> ../lib/python2.7/pdb.py
pdb3.7 -> ../lib/python3.7/pdb.py
py3versions -> ../share/python3/py3versions.py
python -> python2.7
python2 -> python2.7
python2.7
python3 -> python3.7
python3.7 -> python3.7mu
python3.7mu
python3mu -> python3.7mu
pyversions -> ../share/python/pyversions.py
```

Yatık harflerle gösterdiğimiz kısımlara dikkat edin.
Gördüğünüz gibipythonvepython2komutları bu sistemde Python’ın 2.7 sürümünü çalıştırıyor.python3komutu ise Python’ın 3.7 sürümünü…
Dolayısıyla yukarıdaki çıktıyı aldığımız bir sistemde kendi kurduğumuz Python sürümlerine ‘python’, ‘python2’ veya ‘python3’ gibi isimler vermekten kaçınmalıyız.

Sözün özü, bir GNU/Linux kullanıcısı olarak sistemdeki öntanımlı hiçbir Python sürümünü silmemeli, öntanımlı sürüme ulaşan komutları değiştirmemelisiniz.
Eğer mesela sisteminizdepython3komutu halihazırda bir Python sürümünü çalıştırıyorsa, siz yeni kurduğunuz Python sürümüne ulaşmak için öntanımlı adla çakışmayacak başka bir komut adı kullanın.
Yani örneğin sisteminizdepython3komutu Python’ın3.7sürümünü çalıştırıyorsa, siz yeni kurduğunuz sürümü çalıştırmak içinpy3gibi bir sembolik bağ oluşturun.
Bırakın öntanımlı komut (python,python3vb.) öntanımlı Python sürümünü çalıştırmaya devam etsin.

Asla unutmayın.
Siz bir programcı adayı olarak, program yazacağınız işletim sistemini enine boyuna tanımakla yükümlüsünüz.
Dolayısıyla işletim sisteminizi kararsız hale getirecek davranışları bilmeli, bu davranışlardan kaçınmalı, yanlış bir işlem yaptığınızda da nasıl geri döneceğinizi bilmelisiniz.
Hele ki bir programı kaynaktan derlemeye karar vermişseniz…

Bu ciddi uyarıyı da yaptığımıza göre gönül rahatlığıyla yolumuza devam edebiliriz.

#### Python3’ü Ev Dizinine Kuranlar

Eğer Python3’ü kısıtlı kullanıcı hakları ile derleyip ev dizininize kurduysanız yukarıdaki komutlar Python’ı çalıştırmanızı sağlamayacaktır.
Python3’ü ev dizinine kurmuş olan kullanıcılar Python3’ü çalıştırabilmek için, öncelikle komut satırı aracılığıyla Python3’ü kurdukları dizine, oradan da o dizin altındakibin/klasörüne ulaşacak ve orada şu komutu verecek:

```python
./python3.7
```

Diyelim ki Python3’ü$HOME/pythonadlı dizine kurdunuz.
Önce şu komutla$HOME/python/binadlı dizine ulaşıyoruz:

```python
cd $HOME/python/bin

```

Ardından da şu komutu veriyoruz:

```python
./python3.7
```

> **Not**
> Komutun başındaki./işaretinin ne işe yaradığını artık adınız gibi biliyorsunuz…

Not

Komutun başındaki./işaretinin ne işe yaradığını artık adınız gibi biliyorsunuz…

> **Not**
> Elbette ben burada kurduğunuz Python sürümünün 3.7 olduğunu varsaydım.
Eğer farklı bir sürüm kurduysanız yukarıdaki komutu ona göre yazmanız gerekiyor.

Not

Elbette ben burada kurduğunuz Python sürümünün 3.7 olduğunu varsaydım.
Eğer farklı bir sürüm kurduysanız yukarıdaki komutu ona göre yazmanız gerekiyor.

Eğer isterseniz bu şekilde çalışmaya devam edebilirsiniz.
Ancak her defasında Python’ın kurulu olduğu dizin altına gelip orada ./python3.7 komutunu çalıştırmak bir süre sonra eziyete dönüşecektir.
İşlerinizi kolaylaştırmak için şu işlemleri takip etmelisiniz:

1. ev dizininizin altında bulunan.profile(veya kullandığınız dağıtıma göre.bash_profileya da.bashrc) adlı dosyayı açın.

2. Bu dosyanın en sonuna şuna benzer bir satır yerleştirerek Python’ı çalıştırmamızı sağlayan dosyanın bulunduğu dizini yola ekleyin:

```python
export PATH=$PATH:$HOME/python/bin/

```

3.$HOME/python/bin/satırı Python3’ün çalıştırılabilir dosyasının hangi dizin altında olduğunu gösteriyor.
Ben burada Python3’ün çalıştırılabilir dosyasının$HOME/python/bindizini içinde olduğunu varsaydım.
O yüzden de$HOME/python/bin/gibi bir satır yazdım.
Ama eğer Python3’ün çalıştırılabilir dosyası sizde farklı bir dizindeyse bu satırı ona göre yazmalısınız.

4. Kendi sisteminize uygun satırı dosyaya ekledikten sonra dosyayı kaydedip çıkın.
Dosyada yaptığımız değişikliğin etkin hale gelebilmesi için şu komutu verin:

```python
source .profile

```

Elbette eğer sizin sisteminizdeki dosyanın adı.bash_profileveya.bashrcise yukarıdaki komutu ona göre değiştirmelisiniz.

5. Daha sonra$HOME/python/bin/python3.7adlı dosyaya$HOME/python/bin/dizini altından meselapy3gibi bir sembolik bağ verin:

```python
ln -s $HOME/python/bin/python3.7 $HOME/python/bin/py3
```

6. Bilgisayarınızı yeniden başlatın.

7. Artık hangi konumda bulunursanız bulunun, şu komutu vererek Python3’ü başlatabilirsiniz:

```python
py3

```

Burada da eğer yukarıdaki komut Python3’ü çalıştırmanızı sağlamıyorsa, bazı şeyleri eksik veya yanlış yapmış olabilirsiniz.
Yardım almak içinforum.yazbel.comadresine uğrayabilirsiniz.

Python3’ü başarıyla kurup çalıştırabildiğinizi varsayarak yolumuza devam edelim.

#### GNU/Linux’ta Farklı Sürümleri Birlikte Kullanmak

Daha önce de dediğimiz gibi, şu anda piyasada iki farklı Python serisi bulunuyor:
Python2 ve Python3.
2020 yılı itibariyle Python2 desteği bitmiştir fakat hem Python2 ile yazılmış programları çalıştırmak, hem de Python3 ile geliştirme yapmak istiyorsanız, sisteminizde hem Python2’yi hem de Python3’ü aynı anda bulundurmayı tercih edebilir veya yazdığınız kodu farklı sürümlerde test etmek isteyebilirsiniz.
Peki bunu nasıl yapacaksınız?

En başta da söylediğimiz gibi, hemen hemen bütün GNU/Linux dağıtımlarında Python2 kurulu olarak gelir.
Dolayısıyla eğer sisteminize ek olarak Python3’ü de kurduysanız (kaynaktan veya paket deposundan), başka herhangi bir şey yapmanıza gerek yok.
Yukarıda anlattığımız yönergeleri takip ettiyseniz, konsoldapythonkomutu verdiğinizde Python2,python3(veyapy3) komutunu verdiğinizde ise Python3 çalışacaktır.

Ama eğer sisteminizde Python2 bile kurulu değilse, ki bu çok çok düşük bir ihtimaldir, Python2’yi paket yöneticiniz yardımıyla sisteminize kurabilirsiniz.
Şu anda piyasada olup da paket deposunda Python bulundurmayan GNU/Linux dağıtımı pek azdır.

##### pyenv ile Sürümleri Yönetmek

Sürüm Yöneticisi ile Kurulum (pyenv)kısmında anlatıldığı şekilde pyenv kurulumu yaptıktan sonrapyenvinstall<python-sürümü>ile istediğiniz python sürümünü kolayca kurabilir ve sürümler arasında geçiş yapabilirsiniz. Sürüm geçişlerini şu şekilde örneklendirebiliriz. Sisteminizde 3.8.5 sürümünün aktif olduğunu varsayarak sisteme 2 yeni Python sürümü daha kuralım:

```python
pyenv install 2.7.18
pyenv install 3.6.9

```

Bu durumdapyenvversionskomutunun çıktısı şu şekilde olacaktır:

```python
system
2.7.18
3.6.9
* 3.8.5 (set by /home/{kullanıcı-adınız}/.pyenv/version)

```

pyenvile kurulan sürümlerin kullanılabilmesi için 3 farklı komut bulunmaktadır.
- pyenvlocal:pyenv local <python-sürümü>

pyenvlocal:

```python
pyenv local <python-sürümü>

```

localkomutu ile sürüm seçtiğinizde, bulunduğunuz dizinde .python-version isimli bir dosya oluşur. Bu dosya içerisinde yalnızca seçtiğiniz Python sürümü numarası bulunur ve bu sürüm yalnızca mevcut dizin içerisinde aktif olur. Aşağıdaki şekilde bir klasör yapısındaproje1dizinindepyenvlocal3.6.9komutunu çalıştırdığımızı düşünelim:

```python
projeler
├── proje1
│   └── .python-version # 3.6.9
└── proje2

```

Bu durumdaproje1dizinindepythonkomutu3.6.9sürümü, bunun dışındaki bütün dizinlerde3.8.5sürümü çalışacaktır.
- pyenvglobal:pyenv global <python-sürümü>

pyenvglobal:

```python
pyenv global <python-sürümü>

```

Kurulum kısmında da bahsettiğimiz gibi aktif kullandığınız Python sürümünüglobalkomutu ile etkinleştirerek sürekli olarak kullanabilirsiniz. Python2 yüklü sistemlerdepythonkomutu Python2 sürümünü çalıştırırken,globalkomutu ile aktifleştirme sonrasındapythonyazdığınızda seçtiğiniz Python sürümü çalışacaktır.

pyenvglobal3.8.5
- pyenvshell:pyenv shell <python-sürümü>

pyenvshell:

```python
pyenv shell <python-sürümü>

```

shellkomutu ile aktifleştirdiğiniz Python sürümü mevcut terminal oturumunuz süresince aktif olacaktır.shellkomutulocalveglobalsürümleri geçersiz kılar. Yani local olarak ayarladığınız bir dizine girdiğinizde bile hala shell ile aktifleştirdiğiniz sürüm çalışır. Normal şekilde kullanmaya devam edebilmek içinpyenvshell--unsetkomutunu çalıştırmalı veya terminali yeniden başlatmalısınız.

Yeni Python sürümleri çıktıkçapyenv’e eklenmektedir. Yeni sürümleri indirebilmek içinpyenvupdatekomutu ilepyenvaracını güncellemelisiniz.

GNU/Linux’ta Python’ı nasıl çalıştıracağımızı ve farklı Python sürümlerini bir arada nasıl kullanacağımızı öğrendiğimize göre, Windows kullanıcılarının durumuna bakabiliriz.

### Windows Kullanıcıları

Windows kullanıcıları Python3’ü iki şekilde başlatabilir:
1. Başlat > Tüm Programlar > Python3.7> Python3.7yolunu takip ederek.
1. Komut satırındapythonkomutunu vererek.

Başlat > Tüm Programlar > Python3.7> Python3.7yolunu takip ederek.

Komut satırındapythonkomutunu vererek.

Eğer birinci yolu tercih ederseniz, Python’ın size sunduğu komut satırına doğrudan ulaşmış olursunuz.
Ancak Python komut satırına bu şekilde ulaştığınızda bazı kısıtlamalarla karşı karşıya kalırsınız.
Doğrudan Python’ın komut satırına ulaşmak yerine önce MS-DOS komut satırına ulaşıp, oradan Python komut satırına ulaşmak özellikle ileride yapacağınız çalışmalar açısından çok daha mantıklı olacaktır.
O yüzden komut satırına bu şekilde ulaşmak yerine ikinci seçeneği tercih etmenizi tavsiye ederim.
Bunun için komut satırına ulaşın ve orada şu komutu çalıştırın:

```python
python

```

Bu komutu verdiğinizde şuna benzer bir ekranla karşılaşacaksınız:

C:\Users\yazbel>python3
Python 3.7.0 (v3.7.0:c0e311e010fc, 19.08.2024, 12:24:55) [MSC v.1600 32 bit (Intel)] on win32
Type “help”, “copyright”, “credits” or “license” for more information.
>>>

Eğer bu komut yukarıdakine benzer bir ekran yerine bir hata mesajı verdiyse kurulum sırasında bazı adımları eksik veya yanlış yapmış olabilirsiniz.
Yukarıdaki komut çalışmıyorsa, muhtemelen kurulum sırasındaAdd Python3.7to PATHkutucuğunu işaretlemeyi unutmuşsunuzdur.
Eğer öyleyse, kurulum dosyasını tekrar çalıştırıp, ilgili adımı gerçekleştirmeniz veya Python’ı kendiniz YOL’a eklemeniz gerekiyor.

pythonkomutunu başarıyla çalıştırabildiğinizi varsayarak yolumuza devam edelim.

#### Windows’ta Farklı Sürümleri Birlikte Kullanmak

Daha önce de dediğimiz gibi, şu anda piyasada iki farklı Python serisi bulunuyor:
Python2 ve Python3.
Çok uzun zamandan beri kullanımda olduğu için, Python2 Python3’e kıyasla daha yaygın.
Eğer hem Python2 ile yazılmış programları çalıştırmak, hem de Python3 ile geliştirme yapmak istiyorsanız, sisteminizde hem Python2’yi hem de Python3’ü aynı anda bulundurmayı tercih edebilirsiniz.
Peki bunu nasıl yapacaksınız?

Windows’ta bu işlemi yapmak çok kolaydır.python.org/downloadadresine giderek farklı Python sürümlerini bilgisayarınıza indirebilir ve bunları bilgisayarınıza normal bir şekilde kurabilirsiniz.
Bu şekilde sisteminize istediğiniz sayıda farklı Python sürümü kurabilirsiniz.
Peki bu farklı sürümlere nasıl ulaşacaksınız?

Python, bilgisayarımızdaki farklı Python sürümlerini çalıştırabilmemiz için bize ‘py’ adlı özel bir program sunar.

> **Not**
> Py programı yalnızca Windows’a özgüdür.
GNU/Linux’ta böyle bir program bulunmaz.

Not

Py programı yalnızca Windows’a özgüdür.
GNU/Linux’ta böyle bir program bulunmaz.

Py programını çalıştırmak için, sistem komut satırına ulaşıyoruz ve orada şu komutu veriyoruz:

```python
py

```

Bu komutu verdiğinizde (teorik olarak) sisteminize en son kurduğunuz Python sürümü çalışmaya başlayacaktır.
Ancak bu her zaman böyle olmayabilir.
Ya da aldığınız çıktı beklediğiniz gibi olmayabilir.
O yüzden bu komutu verdiğinizde hangi sürümün başladığına dikkat edin.

Eğer sisteminizde birden fazla Python sürümü kurulu ise, bu betik yardımıyla istediğiniz sürümü başlatabilirsiniz.
Mesela sisteminizde hem Python’ın 2.x sürümlerinden biri, hem de Python’ın 3.x sürümlerinden biri kurulu ise, şu komut yardımıyla Python 2.x’i başlatabilirsiniz:

```python
py -2

```

Python 3.x’i başlatmak için ise şu komutu veriyoruz:

```python
py -3

```

Eğer sisteminizde birden fazla Python2 veya birden fazla Python3 sürümü kurulu ise, ana ve alt sürüm numaralarını belirterek istediğiniz sürüme ulaşabilirsiniz:

```python
py -2.6

```

```python
py -2.7

```

```python
py -3.4

```

```python
py -3.5

```

Bu arada dikkat ettiyseniz, Python programlarını başlatabilmek için hempythonhem depykomutunu kullanma imkanına sahibiz.
Eğer sisteminizde tek bir Python sürümü kurulu ise, Python’ı başlatmak içinpythonkomutunu kullanmak isteyebilir, farklı sürümlerin bir arada bulunduğu durumlarda isepyile bu farklı sürümlere tek tek erişmek isteyebilirsiniz.

Böylece Python’la ilgili en temel bilgileri edinmiş olduk.
Bu bölümde öğrendiklerimiz sayesinde Python programlama dilini bilgisayarımıza kurabiliyor ve bu programlama dilini başarıyla çalıştırabiliyoruz.

### Hangi Komut Hangi Sürümü Çalıştırıyor?

Artık Python programlama dilinin bilgisayarımıza nasıl kurulacağını ve bu programlama dilinin nasıl çalıştırılacağını biliyoruz.
Ancak konunun öneminden ötürü, tekrar vurgulayıp, cevabını bilip bilmediğinizden emin olmak istediğimiz bir soru var:
Kullandığınız işletim sisteminde acaba hangi komut, hangi Python sürümünü çalıştırıyor?

Bu kitapta anlattığımız farklı yöntemleri takip ederek, Python programlama dilini bilgisayarınıza farklı şekillerde kurmuş olabilirsiniz.
Örneğin Python programlama dilini, kullandığınız GNU/Linux dağıtımının paket yöneticisi aracılığıyla kurduysanız, Python’ı başlatmak içinpython3komutunu kullanmanız gerekebilir.
Aynı şekilde, eğer Python’ı Windows’a kurduysanız, bu programlama dilini çalıştırmak içinpythonkomutunu kullanıyor olabilirsiniz.
Bütün bunlardan farklı olarak, eğer Python’ın kaynak kodlarını sitesinden indirip derlediyseniz, Python’ı çalıştırmak için kendi belirlediğiniz bambaşka bir adı da kullanıyor olabilirsiniz.
Örneğin belki de Python’ı çalıştırmak içinpy3gibi bir komut kullanıyorsunuzdur…

Python programlama dilini çalıştırmak için hangi komutu kullanıyor olursanız olun, lütfen bir sonraki konuya geçmeden önce kendi kendinize şu soruları sorun:
1. Kullandığım işletim sisteminde Python programı halihazırda kurulu mu?
1. Kullandığım işletim sisteminde toplam kaç farklı Python sürümü var?
1. pythonkomutu bu Python sürümlerinden hangisini çalıştırıyor?
1. python3komutu çalışıyor mu?
1. Eğer çalışıyorsa, bu komut Python sürümlerinden hangisini çalıştırıyor?
1. Kaynaktan derlediğim Python sürümünü çalıştırmak için hangi komutu kullanıyorum?

Kullandığım işletim sisteminde Python programı halihazırda kurulu mu?

Kullandığım işletim sisteminde toplam kaç farklı Python sürümü var?

pythonkomutu bu Python sürümlerinden hangisini çalıştırıyor?

python3komutu çalışıyor mu?

Eğer çalışıyorsa, bu komut Python sürümlerinden hangisini çalıştırıyor?

Kaynaktan derlediğim Python sürümünü çalıştırmak için hangi komutu kullanıyorum?

Biz bu kitapta şunları varsayacağız:
1. Kullandığınız işletim sisteminde Python’ın2.xsürümlerinipythonkomutuyla çalıştırıyorsunuz.
1. Kullandığınız işletim sisteminde Python’ın3.xsürümlerinipython3komutuyla çalıştırıyorsunuz.

Kullandığınız işletim sisteminde Python’ın2.xsürümlerinipythonkomutuyla çalıştırıyorsunuz.

Kullandığınız işletim sisteminde Python’ın3.xsürümlerinipython3komutuyla çalıştırıyorsunuz.

Bu kitaptan yararlanırken, bu varsayımları göz önünde bulundurmalı, eğer bunlardan farklı komutlar kullanıyorsanız, kodlarınızı ona göre ayarlamalısınız.

### Sistem Komut Satırı ve Python Komut Satırı

Buraya kadar Python programlama dilini nasıl çalıştıracağımız konusundaki bütün bilgileri edindik.
Ancak programlamaya yeni başlayanların çok sık yaptığı bir hata var:
Sistem komut satırı ile Python komut satırını birbirine karıştırmak.

Asla unutmayın, kullandığınız işletim sisteminin komut satırı ile Python’ın komut satırı birbirinden farklı iki ortamdır.
Yani Windows’tacmd, Ubuntu’da iseCtrl+Alt+Tile ulaştığınız ortam, sistem komut satırı iken, bu ortamı açıppython3(veyapythonya dapy3) komutu vererek ulaştığınız ortam Python’ın komut satırıdır.
Sistem komut satırında sistem komutları (meselacd,ls,dir,pwd) verilirken, Python komut satırında, biraz sonra öğrenmeye başlayacağımız Python komutları verilir.
Dolayısıylapython3(veyapythonya dapy3) komutunu verdikten sonra ulaştığınız ortamdacdDesktopvelsgibi sistem komutlarını kullanmaya çalışmanız sizi hüsrana uğratacaktır.

## Etkileşimli Python

Şu ana kadar öğrendiklerimiz sayesinde Python programlama dilinin farklı sistemlere nasıl kurulacağını ve nasıl çalıştırılacağını biliyoruz.
Dolayısıyla Python’ı bir önceki bölümde anlattığımız şekilde çalıştırdığımız zaman şuna benzer bir ekranla karşılaşacağımızın farkındayız:

yazbel@ubuntu:~$# python3
Python 3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux
Type “help”, “copyright”, “credits” or “license” for more information.
>>>

Biz şimdiye kadar bu ekrana Python komut satırı demeyi tercih ettik.
Dilerseniz bundan sonra da bu adı kullanmaya devam edebilirsiniz.
Ancak teknik olarak bu ekrana etkileşimli kabuk (interactive shell) adı verildiğini bilmemizde fayda var.
Etkileşimli kabuk, bizim Python programlama dili ile ilişki kurabileceğimiz, yani onunla etkileşebileceğimiz bir üst katmandır.
Etkileşimli kabuk, asıl programımız içinde kullanacağımız kodları deneme imkanı sunar bize.
Burası bir nevi test alanı gibidir.
Örneğin bir Python kodunun çalışıp çalışmadığını denemek veya nasıl çalıştığını, ne sonuç verdiğini görmek istediğimizde bu ekran son derece faydalı bir araç olarak karşımıza çıkar.
Bu ortam, özellikle Python’a yeni başlayanların bu programlama diline aşinalık kazanmasını sağlaması açısından da bulunmaz bir araçtır.
Biz de bu bölümde etkileşimli kabuk üzerinde bazı çalışmalar yaparak, Python’a alışma turları atacağız.

Bu arada, geçen bölümde söylediğimiz gibi, bu ortamın sistem komut satırı adını verdiğimiz ortamdan farklı olduğunu aklımızdan çıkarmıyoruz.
O zaman da dediğimiz gibi, sistem komut satırında sistem komutları, Python komut satırında (yani etkileşimli kabukta) ise Python komutları verilir.
Meselaecho%PATH%,cdDesktop,dirvelsbirer sistem komutudur.
Eğer bu komutları etkileşimli kabukta vermeye kalkışırsanız, bunlar birer Python komutu olmadığı için, Python size bir hata mesajı gösterecektir.
Mesela Python’ın etkileşimli kabuğundacdDesktopkomutunu verirseniz şöyle bir hata alırsınız:

```python
>>> cd Desktop

 File "<stdin>", line 1
 cd Desktop
 ^
SyntaxError: invalid syntax

```

ÇünkücdDesktopbir Python komutu değildir.
O yüzden bu komutu Python’ın etkileşimli kabuğunda veremeyiz.
Bu komutu ancak ve ancak kullandığımız işletim sisteminin komut satırında verebiliriz.

Ne diyorduk?
Etkileşimli kabuk bir veya birkaç satırlık kodları denemek/test etmek için gayet uygun bir araçtır.
İsterseniz konuyu daha fazla lafa boğmayalım.
Zira etkileşimli kabuğu kullandıkça bunun ne büyük bir nimet olduğunu siz de anlayacaksınız.
Özellikle derlenerek çalıştırılan programlama dilleri ile uğraşmış olan arkadaşlarım, etkileşimli kabuğun gücünü gördüklerinde göz yaşlarına hakim olamayacaklar.

Farklı işletim sistemlerindepy3,py-3,python3veyapythonkomutunu vererek Python’ın komut satırına nasıl erişebileceğimizi önceki derslerde ayrıntılı olarak anlatmıştık.
Etkileşimli kabuğa ulaşmakta sıkıntı yaşıyorsanız eski konuları tekrar gözden geçirmenizi tavsiye ederim.

Etkileşimli kabuk üzerinde çalışmaya başlamadan önce dilerseniz önemli bir konuyu açıklığa kavuşturalım:
Etkileşimli kabuğu başarıyla çalıştırdık.
Peki bu kabuktan çıkmak istersek ne yapacağız?
Elbette doğrudan pencere üzerindeki çarpı tuşuna basarak bu ortamı terk edebilirsiniz.
Ancak bu işlemi kaba kuvvete başvurmadan yapmanın bir yolu olmalı, değil mi?

Etkileşimli kabuktan çıkmanın birkaç farklı yolu vardır:
1. Pencere üzerindeki çarpı düğmesine basmak (kaba kuvvet)
1. ÖnceCtrl+Ztuşlarına, ardından daEntertuşuna basmak (Windows)
1. Ctrl+Ztuşlarına basmak (GNU/Linux)
1. ÖnceF6tuşuna, ardından daEntertuşuna basmak (Windows)
1. quit()yazıpEntertuşuna basmak (Bütün işletim sistemleri)
1. importsys;sys.exit()komutunu vermek (Bütün işletim sistemleri)

Pencere üzerindeki çarpı düğmesine basmak (kaba kuvvet)

ÖnceCtrl+Ztuşlarına, ardından daEntertuşuna basmak (Windows)

Ctrl+Ztuşlarına basmak (GNU/Linux)

ÖnceF6tuşuna, ardından daEntertuşuna basmak (Windows)

quit()yazıpEntertuşuna basmak (Bütün işletim sistemleri)

importsys;sys.exit()komutunu vermek (Bütün işletim sistemleri)

Siz bu farklı yöntemler arasından, kolayınıza hangisi geliyorsa onu seçebilirsiniz.
Bu satırların yazarı, Windows’ta 2 numaralı; GNU/Linux’ta ise 3 numaralı seçeneği tercih ediyor.

### Etkileşimli Kabukta İlk Adımlar

Python’da etkileşimli kabuğu nasıl çalıştıracağımızı ve bu ortamı nasıl terk edeceğimizi öğrendiğimize göre artık etkileşimli kabuk aracılığıyla Python programlama dilinde ilk adımlarımızı atmaya başlayabiliriz.

Şimdi kendi sistemimize uygun bir şekilde etkileşimli kabuğu tekrar çalıştıralım.
Etkileşimli kabuğu çalıştırdığımızda ekranda görünen>>>işareti Python’ın bizden komut almaya hazır olduğunu gösteriyor.
Python kodlarımızı bu>>>işaretinden hemen sonra,hiç boşluk bırakmadanyazacağız.

Buradaki ‘hiç boşluk bırakmadan’ kısmı önemli.
Python’a yeni başlayanların en sık yaptığı hatalardan biri>>>işareti ile komut arasında boşluk bırakmalarıdır.
Eğer bu şekilde boşluk bırakırsanız yazdığınız kod hata verecektir.

İsterseniz basit bir deneme yapalım.>>>işaretinden hemen sonra, hiç boşluk bırakmadan şu komutu yazalım:

```python
>>> "Merhaba Zalim Dünya!"

```

Bu arada yukarıdaki kodlar içinde görünen>>>işaretini siz yazmayacaksınız.
Bu işareti etkileşimli kabuğun görünümünü temsil etmek için yerleştirdik oraya.
Siz“Merhaba Zalim Dünya!”satırını yazdıktan sonra doğrucaEnterdüğmesine basacaksınız.

Bu komutu yazıpEntertuşuna bastığımızda şöyle bir çıktı almış olmalıyız:

```python
'Merhaba Zalim Dünya!'

```

Böylece yarım yamalak da olsa ilk Python programımızı yazmış olduk…

Muhtemelen bu kod, içinizde en ufak bir heyecan dahi uyandırmamıştır.
Hatta böyle bir kod yazmak size anlamsız bile gelmiş olabilir.
Ama aslında şu küçücük kod parçası bile bize Python programlama dili hakkında çok önemli ipuçları veriyor.
Gelin isterseniz bu tek satırlık kodu biraz inceleyelim…

#### Karakter Dizilerine Giriş

Dediğimiz gibi, yukarıda yazdığımız küçücük kod parçası sizi heyecanlandırmamış olabilir, ama aslında bu kod Python programlama dili ve bu dilin yapısı hakkında çok önemli bilgileri içinde barındırıyor.

Teknik olarak söylemek gerekirse, yukarıda yazdığımız“Merhaba Zalim Dünya!”ifadesi bir karakter dizisidir.
İngilizcede bunastringadı verilir ve programlama açısından son derece önemli bir kavramdır bu.
Kavramın adından da rahatlıkla anlayabileceğiniz gibi, bir veya daha fazla karakterden oluşan öğelere karakter dizisi (string) diyoruz.

Karakter dizileri bütün programcılık maceramız boyunca karşımıza çıkacak.
O yüzden bu kavramı ne kadar erken öğrenirsek o kadar iyi.

Peki bir verinin karakter dizisi olup olmamasının bize ne faydası var?
Yani yukarıdaki cümle karakter dizisi olmuş olmamış bize ne?

Python’da, o anda elinizde bulunan bir verinin hangi tipte olduğunu bilmek son derece önemlidir.
Çünkü bir verinin ait olduğu tip, o veriyle neler yapıp neler yapamayacağınızı belirler.
Python’da her veri tipinin belli başlı özellikleri vardır.
Dolayısıyla, elimizdeki bir verinin tipini bilmezsek o veriyi programlarımızda etkin bir şekilde kullanamayız.
İşte yukarıda örneğini verdiğimiz“Merhaba Zalim Dünya!”adlı karakter dizisi de bir veri tipidir.
Python’da karakter dizileri dışında başka veri tipleri de bulunur.
Biraz sonra başka veri tiplerini de inceleyeceğiz.

Dikkat ederseniz“Merhaba Zalim Dünya!”adlı karakter dizisini tırnak içinde gösterdik.
Bu da çok önemli bir bilgidir.
Eğer bu cümleyi tırnak içine almazsak programımız hata verecektir:

```python
>>> Merhaba Zalim Dünya!
 File "<stdin>", line 1
 Merhaba Zalim Dünya!
 ^
SyntaxError: invalid syntax

```

Zaten tırnak işaretleri, karakter dizilerinin ayırt edici özelliğidir.
Öyle ki, Python’da tırnak içinde gösterdiğiniz her şey bir karakter dizisidir.
Örneğin şu bir karakter dizisidir:

```python
>>> "a"

```

Gördüğünüz gibi, tırnak içinde gösterilen tek karakterlik bir öğe de Python’da karakter dizisi sınıfına giriyor.

Mesela şu, içi boş bir karakter dizisidir:

```python
>>> ""

```

Şu da içinde bir adet boşluk karakteri barındıran bir karakter dizisi…

```python
>>> " "

```

Bu ikisi arasındaki farka dikkat ediyoruz:
Python’da ‘boş karakter dizisi’ ve ‘bir adet boşluktan oluşan karakter dizisi’ birbirlerinden farklı iki kavramdır.
Adından da anlaşılacağı gibi, boş karakter dizileri içlerinde hiçbir karakter (başka bir deyişle ‘öğe’) barındırmayan karakter dizileridir.
Bir (veya daha fazla) boşluktan oluşan karakter dizileri ise içlerinde boşluk karakteri barındıran karakter dizileridir.
Yani bu karakter dizilerinden biri boş, öteki ise doludur.
Ama neticede her ikisi de karakter dizisidir.
Şu anda oldukça anlamsız bir konu üzerinde vakit kaybediyormuşuz hissine kapılmış olabilirsiniz, ama emin olun, Python programlama diline yeni başlayanların önemli tökezleme noktalarından biridir bu söylediğimiz şey…

Dilerseniz biz karakter dizilerine elimizin alışması için birkaç örnek verelim:

```python
>>> "Elma"

'Elma'

>>> "Guido Van Rossum"

'Guido Van Rossum'

>>> "Python programlama dili"

'Python programlama dili'

>>> "ömnhbgfgh"

'ömnhbgfgh'

>>> "$5&"

'$5&'

>>> ""

''

>>> " "

' '

```

Yukarıdaki örneklerin hepsi birer karakter dizisidir.
Dikkat ettiyseniz yukarıdaki karakter dizilerinin hepsinin ortak özelliği tırnak içinde gösteriliyor olmasıdır.
Dediğimiz gibi, tırnak işaretleri karakter dizilerinin ayırt edici özelliğidir.

Peki bir verinin karakter dizisi olup olmadığından nasıl emin olabilirsiniz?

Eğer herhangi bir verinin karakter dizisi olup olmadığı konusunda tereddütünüz varsa,type()adlı bir fonksiyondan yararlanarak o verinin tipini sorgulayabilirsiniz.
Bu fonksiyonu şöyle kullanıyoruz:

```python
>>> type("Elma")

<class 'str'>

```

> **Not**
> Bu ‘fonksiyon’ kelimesinin kafanızı karıştırmasına izin vermeyin.
İleride fonksiyonları oldukça ayrıntılı bir şekilde inceleyeceğimiz için,type()ifadesinin bir fonksiyon olduğunu bilmeniz şimdilik yeterli olacaktır.
Üstelik fonksiyon konusunu ayrıntılı bir şekilde anlatma vakti geldiğinde siz fonksiyonlara dair pek çok şeyi zaten öğrenmiş olacaksınız.

Not

Bu ‘fonksiyon’ kelimesinin kafanızı karıştırmasına izin vermeyin.
İleride fonksiyonları oldukça ayrıntılı bir şekilde inceleyeceğimiz için,type()ifadesinin bir fonksiyon olduğunu bilmeniz şimdilik yeterli olacaktır.
Üstelik fonksiyon konusunu ayrıntılı bir şekilde anlatma vakti geldiğinde siz fonksiyonlara dair pek çok şeyi zaten öğrenmiş olacaksınız.

Burada amacımız“Elma”adlı öğenin tipini denetlemek.
Denetlenecek öğeyitype()fonksiyonunun parantezleri arasında belirttiğimize dikkat edin.
(Fonksiyonların parantezleri içinde belirtilen değerlere teknik dilde parametre adı verilir.)

Yukarıdaki çıktıda bizi ilgilendiren kısım, sondaki ‘str’ ifadesi.
Tahmin edebileceğiniz gibi, bu ifadestringkelimesinin kısaltmasıdır.
Bu kelimenin Türkçede karakter dizisi anlamına geldiğini söylemiştik.
O halde yukarıdaki çıktıya bakarak,“Elma”öğesinin bir karakter dizisi olduğunu söyleyebiliyoruz.

type()fonksiyonu yardımıyla kendi kendinize bazı denemeler yaparak konuyu iyice sindirmenizi tavsiye ederim.
Mesela“½{656$#gfd”ifadesinin hangi sınıfa girdiğini kontrol etmekle başlayabilirsiniz.

Peki karakter dizileri ile neler yapabiliriz?
Şu anda Python bilgimiz kısıtlı olduğu için karakter dizileri ile çok fazla şey yapamayız, ama ileride bilgimiz arttıkça, karakter dizileriyle sıkı fıkı olacağız.

Esasında, henüz bilgimiz kısıtlı da olsa karakter dizileriyle yine de ufak tefek bazı şeyler yapamayacak durumda değiliz.
Mesela şu anki bilgilerimizi ve görür görmez size tanıdık gelecek bazı basit parçaları kullanarak, karakter dizilerini birbirleriyle birleştirebiliriz:

```python
>>> "yazbel" + ".com"

'yazbel.com'

```

Burada+işaretini kullanarak karakter dizilerini nasıl birleştirebildiğimize dikkat edin.
İki karakter dizisini+işareti ile birleştirdiğimizde karakter dizilerinin arasında boşluk olmadığına özellikle dikkatinizi çekmek isterim.
Bu durumu şu örnekte daha net görebiliriz:

```python
>>> "Fırat" + "Özgül"

'FıratÖzgül'

```

Gördüğünüz gibi, bu iki karakter dizisi, arada boşluk olmadan birbiriyle bitiştirildi.
Araya boşluk eklemek için birkaç farklı yöntemden yararlanabilirsiniz:

```python
>>> "Fırat" + " " + "Özgül"

'Fırat Özgül'

```

Burada iki karakter dizisi arasına bir adet boşluk karakteri yerleştirdik.
Aynı etkiyi şu şekilde de elde edebilirsiniz:

```python
>>> "Fırat" + " Özgül"

```

Burada daÖzgülkarakter dizisinin başına bir adet boşluk yerleştirerek istediğimiz çıktıyı elde ettik.

Bu arada, karakter dizilerini birleştirmek için mutlaka+işareti kullanmak zorunda değilsiniz.
Siz+işaretini kullanmasanız da Python sizin karakter dizilerini birleştirmek istediğinizi anlayacak kadar zekidir:

```python
>>> "www" "." "google" "." "com"

'www.google.com'

```

Ancak gördüğünüz gibi,+işaretini kullandığınızda kodlarınız daha okunaklı oluyor.

+işareti dışında karakter dizileri ile birlikte*(çarpı) işaretini de kullanabiliriz.
O zaman şöyle bir etki elde ederiz:

```python
>>> "w" * 3

'www'

>>> "yavaş " * 2

'yavaş yavaş '

>>> "-" * 10

'----------'

>>> "uzak" + " " * 5 + "çok uzak..."

'uzak çok uzak...'

```

Gördüğünüz gibi, çok basit parçaları bir araya getirerek karmaşık çıktılar elde edebiliyoruz.
Mesela son örnekte“uzak”adlı karakter dizisine önce5adet boşluk karakteri (""*5), ardından da“çok uzak…”adlı karakter dizisini ekleyerek istediğimiz çıktıyı aldık.

Burada+ve*adlı iki yeni araç görüyoruz.
Bunlar aslında sayılarla birlikte kullanılan birer aritmetik işleçtir.
Normalde+işleci toplama işlemleri için,*işleci ise çarpma işlemleri için kullanılır.
Ama yukarıdaki örneklerde,+işaretinin ‘birleştirme’;*işaretinin ise ‘tekrarlama’ anlamından ötürü bu iki işleci bazı durumlarda karakter dizileri ile birlikte de kullanabiliyoruz.
Bunların dışında bir de-(eksi) ve/(bölü) işleçleri bulunur.
Ancak bu işaretleri karakter dizileri ile birlikte kullanamıyoruz.

Karakter dizilerini sonraki bir bölümde bütün ayrıntılarıyla inceleyeceğiz.
O yüzden şimdilik bu konuya bir ara verelim.

#### Sayılara Giriş

Dedik ki, Python’da birtakım veri tipleri bulunur ve karakter dizileri de bu veri tiplerinden yalnızca biridir.
Veri tipi olarak karakter dizilerinin dışında, biraz önce aritmetik işleçler vesilesiyle sözünü ettiğimiz, bir de ‘sayı’ (number) adlı bir veri tipi vardır.

Herhalde sayıların ne anlama geldiğini tarif etmeye gerek yok.
Bunlar bildiğimiz sayılardır.
Mesela:

```python
>>> 23

23

>>> 4567

4567

>>> 2.3

2.3

>>> (10+2j)

(10+2j)

```

Python’da sayıların farklı alt türleri bulunur.
Mesela tamsayılar, kayan noktalı sayılar, karmaşık sayılar…

Yukarıdaki örnekler arasında geçen23ve4567birer tamsayıdır.
İngilizcede bu tür sayılaraintegeradı verilir.

2.3ise bir kayan noktalı sayıdır (floating point numberveya kısacafloat).
Bu arada kayan noktalı sayılarda basamak ayracı olarak virgül değil, nokta işareti kullandığımıza dikkat edin.

En sonda gördüğümüz10+2jsayısı ise bir karmaşık sayıdır (complex).
Ancak eğer matematikle yoğun bir şekilde uğraşmıyorsanız karmaşık sayılar pek karşınıza çıkmaz.

Sayıları temel olarak öğrendiğimize göre etkileşimli kabuğu basit bir hesap makinesi niyetine kullanabiliriz:

```python
>>> 5 + 2

7

>>> 25 * 25

625

>>> 5 / 2

2.5

>>> 10 - 3

7

```

Yukarıdaki örneklerde kullandığımız aritmetik işleçlerden biraz önce bahsetmiştik.
O yüzden bunlara yabancılık çektiğinizi zannetmiyorum.
Ama biz yine de bu işleçleri ve görevlerini şöylece sıralayalım:
| İşleç | Görevi |
| --- | --- |
| + | toplama |
| - | çıkarma |
| * | çarpma |
| / | bölme |

İşleç

Görevi

+

toplama

-

çıkarma

*

çarpma

/

bölme

Yukarıdaki örneklerde bir şey dikkatinizi çekmiş olmalı:
Karakter dizilerini tanımlarken tırnak işaretlerini kullandık.
Ancak sayılarda tırnak işareti yok. Daha önce de dediğimiz gibi, tırnak işaretleri karakter dizilerinin ayırt edici özelliğidir.
Python’da tırnak içinde gösterdiğiniz her şey bir karakter dizisidir.
Mesela şu örneklere bakalım:

```python
>>> 34657

34657

```

Bu bir sayıdır.
Peki ya şu?

```python
>>> "34657"

'34657'

```

Bu ise bir karakter dizisidir.
Dilerseniz biraz önce öğrendiğimiztype()fonksiyonu yardımıyla bu verilerin tipini sorgulayalım:

```python
>>> type(34657)

<class 'int'>

```

Buradaki ‘int’ ifadesi İngilizce “integer”, yani tamsayı kelimesinin kısaltmasıdır.
Demek ki34657sayısı bir tamsayı imiş.
Bir de şuna bakalım:

```python
>>> type("34657")

<class 'str'>

```

Gördüğünüz gibi,34657sayısını tırnak içine aldığımızda bu sayı artık sayı olma özelliğini yitiriyor ve bir karakter dizisi oluyor.
Şu anda bu çok önemsiz bir ayrıntıymış gibi gelebilir size, ama aslında son derece önemli bir konudur bu.
Bu durumun etkilerini şu örneklerde görebilirsiniz:

```python
>>> 23 + 65

88

```

Burada normal bir şekilde iki sayıyı birbiriyle topladık.

Bir de şuna bakın:

```python
>>> "23" + "65"

'2365'

```

Burada ise Python iki karakter dizisini yan yana yazmakla yetindi; yani bunları birleştirdi.
Python açısından“23”ve23birbirinden farklıdır.“23”bir karakter dizisi iken,23bir sayıdır.
Aynı şey“65”ve65için de geçerlidir.
Yani Python açısından“65”ile“Merhaba Zalim Dünya!”arasında hiç bir fark yoktur.
Bunların ikisi de karakter dizisi sınıfına girer.
Ancak65ile“65”birbirinden farklıdır.65bir sayı iken,“65”bir karakter dizisidir.

Bu bilgi, özellikle aritmetik işlemlerde büyük önem taşır.
Bunu dilerseniz şu örnekler üzerinde gösterelim:

```python
>>> 45 + "45"

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'

```

Gördüğünüz gibi, yukarıdaki kodlar hata veriyor.
Bunun sebebi bir sayı (45) ile bir karakter dizisini (“45”) birbiriyle toplamaya çalışmamızdır.
Asla unutmayın, aritmetik işlemler ancak sayılar arasında yapılır.
Karakter dizileri ile herhangi bir aritmetik işlem yapılamaz.

Bir de şuna bakalım:

```python
>>> 45 + 45

90

```

Bu kodlar ise düzgün çalışır.
Çünkü burada iki sayıyı aritmetik işleme soktuk ve başarılı olduk.

Son olarak şu örneği verelim:

```python
>>> "45" + "45"

'4545'

```

Burada+işlecinin toplama anlamına gelmediğine dikkat edin.
Bu işleç burada iki karakter dizisini birleştirme görevi üstleniyor.
Yani yukarıdaki örneğin şu örnekten hiçbir farkı yoktur:

```python
>>> "yazbel." + "com"

'yazbel.com'

```

Bu iki örnekte de yaptığımız şey karakter dizilerini birbiriyle birleştirmektir.

Gördüğünüz gibi,+işlecinin sağındaki ve solundaki değerler birer karakter dizisi ise bu işleç bu iki değeri birbiriyle birleştiriyor.
Ama eğer bu değerler birer sayı ise+işleci bu değerleri birbiriyle aritmetik olarak topluyor.

*işleci de+işlecine benzer bir iş yapar.
Yani eğer*işleci bir sayı ve bir karakter dizisi ile karşılaşırsa, o karakter dizisini, verilen sayı kadar tekrarlar.
Örneğin:

```python
>>> "w" * 3

'www'

```

Burada*işleci bir karakter dizisi (“w”) ve bir sayı (3) arasında işlem yaptığı için, karakter dizisini, ilgili sayı kadar tekrarlıyor.
Yani“w”karakter dizisini3kez tekrarlıyor.

Bir de şuna bakalım:

```python
>>> 25 * 3

75

```

Burada ise*işleci iki adet sayı arasında işlem yaptığı için bu değerleri birbiriyle aritmetik olarak çarpıyor ve75değerini elde etmemizi sağlıyor.

Gördüğünüz gibi, o anda elimizde bulunan verilerin tipini bilmek gerçekten de büyük önem taşıyor.
Çünkü eğer elimizdeki verilerin tipini bilmezsek nasıl sonuçlar elde edeceğimizi de kestiremeyiz.

Böylece karakter dizileri ile sayılar arasındaki farkı öğrenmiş olduk.
Bu bilgiler size önemsizmiş gibi gelebilir, ama aslında karakter dizileri ile sayılar arasındaki farkı anlamak, Python programlama dilinin önemli bir bölümünü öğrenmiş olmak demektir.
İleride yazacağınız en karmaşık programlarda bile, bazen programınızın çalışmamasının (veya daha kötüsü yanlış çalışmasının) nedeninin karakter dizileri ile sayıları birbirine karıştırmanız olduğunu göreceksiniz.
O yüzden burada öğrendiğiniz hiçbir bilgi kırıntısını baştan savmamanızı (ve sabırsızlık ya da acelecilik etmemenizi) tavsiye ederim.

#### Değişkenler

Şimdi şöyle bir durum düşünün:
Diyelim ki sisteme kayıt için kullanıcı adı ve parola belirlenmesini isteyen bir program yazıyorsunuz.
Yazacağınız bu programda, belirlenebilecek kullanıcı adı ve parolanın toplam uzunluğu40karakteri geçmeyecek.

Bu programı yazarken ilk aşamada yapmanız gereken şey, kullanıcının belirlediği kullanıcı adı ve parolanın uzunluğunu tek tek denetlemek olmalı.

Mesela kullanıcı şöyle bir kullanıcı adı belirlemiş olsun:

```python
firat_ozgul_1980

```

Kullanıcının belirlediği parola ise şu olsun:

```python
rT%65#$hGfUY56123

```

İşte bizim öncelikle kullanıcıdan gelen bu verilerin teker teker uzunluğunu biliyor olmamız lazım, ki bu verilerin toplam40karakter sınırını aşıp aşmadığını denetleyebilelim.

Peki bu verilerin uzunluğunu nasıl ölçeceğiz?
Elbette bunun için verilerdeki harfleri elle tek tek saymayacağız.
Bunun yerine, Python programlama dilinin bize sunduğu bir aracı kullanacağız.
Peki nedir bu araç?

Hatırlarsanız birkaç sayfa öncetype()adlı bir fonksiyondan söz etmiştik.
Bu fonksiyonun görevi bir verinin hangi tipte olduğunu bize bildirmekti.
İşte tıpkıtype()gibi, Python’dalen()adlı başka bir fonksiyon daha bulunur.
Bu fonksiyonun görevi ise karakter dizilerinin (ve ileride göreceğimiz gibi, başka veri tiplerinin) uzunluğunu ölçmektir.
Yani bu fonksiyonu kullanarak bir karakter dizisinin toplam kaç karakterden oluştuğunu öğrenebiliriz.

Biz henüz kullanıcıdan nasıl veri alacağımızı bilmiyoruz.
Ama şimdilik şunu söyleyebiliriz:
Python’da kullanıcıdan herhangi bir veri aldığımızda, bu veri bize bir karakter dizisi olarak gelecektir.
Yani kullanıcıdan yukarıdaki kullanıcı adı ve parolayı aldığımızı varsayarsak, bu veriler bize şu şekilde gelir:

```python
"firat_ozgul_1980"

```

ve:

```python
"rT%65#$hGfUY56123"

```

Gördüğünüz gibi, elde ettiğimiz veriler tırnak içinde yer alıyor.
Yani bunlar birer karakter dizisi.
Şimdi gelin yukarıda bahsettiğimizlen()fonksiyonunu kullanarak bu karakter dizilerinin uzunluğunu ölçelim.

Dediğimiz gibi,len()de tıpkıtype()gibi bir fonksiyondur.
Dolayısıylalen()fonksiyonunun kullanımıtype()fonksiyonunun kullanımına çok benzer.
Nasıltype()fonksiyonu bize, kendisine verdiğimiz parametrelerintipinisöylüyorsa,len()fonksiyonu da kendisine verdiğimiz parametrelerinuzunluğunusöyler.

Dikkatlice bakın:

```python
>>> len("firat_ozgul_1980")

16

>>> len("rT%65#$hGfUY56123")

17

```

Demek ki“firat_ozgul_1980”adlı karakter dizisinde16;“rT%65#$hGfUY56123”adlı karakter dizisinde ise17karakter varmış.
Bizim istediğimiz şey bu iki değerin toplam uzunluğunun40karakteri aşmaması.
Bunu denetlemek için yapmamız gereken şey bu iki değerin uzunluğunu birbiriyle toplamak olmalı.
Yani:

```python
>>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123")

```

Buradan alacağımız sonuç33olacaktır.
Demek ki kullanıcı40karakter limitini aşmamış.
O halde programımız bu kullanıcı adı ve parolayı kabul edebilir…

Bu arada, belki farkettiniz, belki de farketmediniz, ama burada da çok önemli bir durumla karşı karşıyayız.
Gördüğünüz gibilen()fonksiyonu bize sayı değerli bir veri gönderiyor.
Gelin isterseniz bunu teyit edelim:

```python
>>> type(len("firat_ozgul_1980"))

<class 'int'>

```

len()fonksiyonunun bize sayı değerli bir veri göndermesi sayesinde bu fonksiyondan elde ettiğimiz değerleri birbiriyle toplayabiliyoruz:

```python
>>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123")

33

```

Eğerlen()fonksiyonu bize sayı değil de mesela karakter dizisi verseydi, bu fonksiyondan elde ettiğimiz değerleri yukarıdaki gibi doğrudan birbiriyle aritmetik olarak toplayamazdık.
Öyle bir durumda, bu iki veriyi birbiriyle toplamaya çalıştığımızda,+işleci16ve17değerlerini birbiriyle toplamak yerine bu değerleri birbiriyle birleştirerek bize‘1617’gibi bir sonuç verecekti.

Her zaman söylediğimiz gibi, Python’da veri tipi kavramını çok iyi anlamak ve o anda elimizde bulunan bir verinin hangi tipte olduğunu bilmek çok önemlidir.
Aksi halde programlarımızda hata yapmamız kaçınılmazdır.

Eğer yukarıda anlattığımız şeyleri kafa karıştırıcı bulduysanız hiç endişe etmeyin.
Birkaç bölüm sonrainput()adlı bir fonksiyondan bahsettiğimizde şimdi söylediğimiz şeyleri çok daha net anlayacaksınız.

Biraz sonralen()fonksiyonundan bahsetmeye devam edeceğiz, ama isterseniz ondan önce çok önemli bir konuya değinelim.

Biraz önce şöyle bir örnek vermiştik:

```python
>>> len("firat_ozgul_1980")

16

>>> len("rT%65#$hGfUY56123")

17

>>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123")

```

Bu kodlar, istediğimiz şeyi gayet güzel yerine getiriyor.
Ama sizce de yukarıdaki kodlarda çok rahatsız edici bir durum yok mu?

Dikkat ederseniz, yukarıdaki örneklerde kullandığımız verileri, program içinde her ihtiyaç duyduğumuzda tekrar tekrar yazdık.
Böylece aynı program içinde iki kez“firat_ozgul_1980”; iki kez de“rT%65#$hGfUY56123”yazmak zorunda kaldık.
Halbuki bu verileri programlarımızın içinde her ihtiyaç duyduğumuzda tekrar tekrar yazmak yerine bir değişkene atasak ve gerektiğinde o değişkeni kullansak çok daha iyi olmaz mı?
Herhalde olur…

Peki nedir bu değişken dediğimiz şey?

Python’da bir program içinde değerlere verilen isimlere değişken denir.
Hemen bir örnek verelim:

```python
>>> n = 5

```

Burada5sayısını bir değişkene atadık.
Değişkenimiz isen.
Ayrıca5sayısını bir değişkene atamak için=işaretinden yararlandığımıza da çok dikkat edin.
Buradan,=işaretinin Python programlama dilinde değer atama işlemleri için kullanıldığı sonucunu çıkarıyoruz.

n=5gibi bir komut yardımıyla5değerininadlı değişkene atamamız sayesinde artık ne zaman5sayısına ihtiyaç duysak bundeğişkenini çağırmamız yeterli olacaktır:

```python
>>> n

5

>>> n * 10

50

>>> n / 2

2.5

```

Gördüğünüz gibi,5değerini bir değişkene atadıktan sonra, bu5değerini kullanmamız gereken yerlerde sadece değişkenin adını kullandığımızda değişkenin değerini Python otomatik olarak yerine koyabiliyor.
Yanin=5komutuylanadlı bir değişken tanımladıktan sonra, artık ne zaman5sayısına ihtiyaç duysakndeğişkenini çağırmamız yeterli olacaktır.
Python o5değerini otomatik olarak yerine koyar.

Şimdi depiadlı başka bir değişken tanımlayalım:

```python
>>> pi = 3.14

```

Bupideğişkeninin değeri ilendeğişkeninin değerini toplayalım:

```python
>>> pi + n

8.14

```

Gördüğünüz gibi, değerleri her defasında tekrar yazmak yerine bunları bir değişkene atayıp, gereken yerde bu değişkeni kullanmak çok daha pratik bir yöntem.

Aynı şeyi programımız için de yapabiliriz:

```python
>>> kullanıcı_adı = "firat_ozgul_1980"
>>> parola = "rT%65#$hGfUY56123"

```

=işaretini kullanarak ilgili değerlere artık birer ad verdiğimiz, yani bu değerleri birer değişkene atadığımız için, bu değerleri kullanmamız gereken yerlerde değerlerin kendisini uzun uzun yazmak yerine, belirlediğimiz değişken adlarını kullanabiliriz.
Mesela:

```python
>>> len(kullanıcı_adı)

16

>>> len(parola)

17

>>> len(kullanıcı_adı) + len(parola)

33

>>> k_adı_uzunluğu = len(kullanıcı_adı)
>>> type(k_adı_uzunluğu)

<class 'int'>

```

Gördüğünüz gibi, değişken kullanımı işlerimizi bir hayli kolaylaştırıyor.

##### Değişken Adı Belirleme Kuralları

Python programlama dilinde, değişken adı olarak belirleyebileceğimiz kelime sayısı neredeyse sınırsızdır.
Yani hemen hemen her kelimeyi değişken adı olarak kullanabiliriz.
Ama yine de değişken adı belirlerken dikkat etmemiz gereken bazı kurallar var.
Bu kuralların bazıları zorunluluk, bazıları ise yalnızca tavsiye niteliğindedir.

Şimdi bu kuralları tek tek inceleyelim:

1. Değişken adları bir sayı ile başlayamaz.
Yani şu kullanım yanlıştır:

```python
>>> 3_kilo_elma = "5 TL"

```

2. Değişken adları aritmetik işleçlerle başlayamaz.
Yani şu kullanım yanlıştır:

```python
>>> +değer = 4568

```

3. Değişken adları ya bir alfabe harfiyle ya da_işaretiyle başlamalıdır:

```python
>>> _değer = 4568
>>> değer = 4568

```

4. Değişken adları içinde Türkçe karakterler kullanabilirsiniz.
Ancak ileride beklenmedik uyum sorunları çıkması ihtimaline karşı değişken adlarında Türkçe karakter kullanmaktan kaçınmak isteyebilirsiniz.

5. Aşağıdaki kelimeleri değişken adı olarak kullanamazsınız:

```python
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del',
'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',
'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

```

Bunlar Python’da özel anlam ifade eden kelimelerdir.
Etkileşimli kabuk zaten bu kelimeleri değişken adı olarak kullanmanıza izin vermez.
Örneğin:

```python
>>> elif = "hoş kız"

 File "<stdin>", line 1
 elif = "hoş kız"
 ^
SyntaxError: invalid syntax

>>> as = "kare"

 File "<stdin>", line 1
 as = "kare"
 ^
SyntaxError: invalid syntax

>>> False = 45

 File "<stdin>", line 1
SyntaxError: assignment to keyword

```

Ama ileride göreceğimiz gibi, programlarınızı bir dosyaya yazarken bu kelimeleri değişken adı olarak kullanmaya çalışırsanız programınız tespit etmesi çok güç hatalar üretecektir.

Bu arada elbette yukarıdaki listeyi bir çırpıda ezberlemeniz beklenmiyor sizden.
Python programlama dilini öğrendikçe özel kelimeleri bir bakışta tanıyabilecek duruma geleceksiniz.
Ayrıca eğer isterseniz şu komutları vererek, istediğiniz her an yukarıdaki listeye ulaşabilirsiniz:

```python
>>> import keyword
>>> keyword.kwlist

['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del',
'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal',
'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

```

Size bir soru:
Acaba bu listede kaç tane kelime var?

Bu soru karşısında listedeki kelimeleri tek tek elle saymaya kalkışan arkadaşlarıma teessüflerimi iletiyorum…
Bu tür işler için hangi aracı kullanabileceğimizi artık çok iyi biliyor olmalısınız:

```python
>>> len(keyword.kwlist)

35

```

Bu kodları şöyle yazabileceğimizi de biliyorsunuz:

```python
>>> yasaklı_kelimeler = keyword.kwlist
>>> len(yasaklı_kelimeler)

35

```

Bu arada, yukarıdaki kodların bir kısmını henüz anlayamamış olabilirsiniz.
Hiç endişe etmeyin.
Yukarıdaki kodları vermemizin sebebi değişken adı olarak kullanılamayacak kelimelere kısa yoldan nasıl ulaşabileceğinizi gösterebilmek içindir.
Bir-iki bölüm sonra burada yazdığımız kodları rahatlıkla anlayabilecek düzeye geleceksiniz.

Yukarıda verdiğimiz kodların çıktısından anladığımıza göre, toplam35tane kelime varmış değişken adı belirlerken kullanmaktan kaçınmamız gereken…

6. Yukarıdaki kelimeler dışında, Python programlama diline ait fonksiyon ve benzeri araçların adlarını da değişken adı olarak kullanmamalısınız.
Örneğin yazdığınız programlarda değişkenlerinizetypeveyalenadı vermeyin.
Çünkü ‘type’ ve ‘len’ Python’a ait iki önemli fonksiyonun adıdır.
Eğer mesela bir değişkenetypeadını verirseniz, o programda artıktype()fonksiyonunu kullanamazsınız:

```python
>>> type = 3456

```

Bu örnektetypeadında bir değişken tanımladık.
Şimdi mesela“elma”kelimesinin tipini denetlemek içintype()fonksiyonunu kullanmaya çalışalım:

```python
>>> type("elma")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable

```

Gördüğünüz gibi, artıktype()fonksiyonu çalışmıyor.
Çünkü siz ‘type’ kelimesini bir değişken adı olarak kullanarak,type()fonksiyonunu kullanılamaz hale getirdiniz.

Bu durumdan kurtulmak için etkileşimli kabuğu kapatıp tekrar açabilirsiniz.
Ya da eğer etkileşimli kabuğu kapatmak istemiyorsanız şu komut yardımıylatypedeğişkenini ortadan kaldırmayı da tercih edebilirsiniz:

```python
>>> del type

```

Böylece, (tahmin edebileceğiniz gibidelete(silmek) kelimesinin kısaltması olan)delkomutuylatypedeğişkenini silmiş oldunuz.
Artık ‘type’ kelimesi yinetype()fonksiyonunu çağıracak:

```python
>>> type("elma")

<class 'str'>

```

7. Değişken adlarını belirlerken, değişkeni oluşturan kelimeler arasında boşluk bırakılamaz.
Yani şu kullanım yanlıştır:

```python
>>> kullanıcı adı = "yazbel"

```

Yukarıdaki değişkeni şu şekilde tanımlayabiliriz:

```python
>>> kullanıcı_adı = "yazbel"

```

Ya da şöyle:

```python
>>> kullanıcıAdı = "yazbel"

```

8. Değişken adları belirlerken, değişken adının, değişkenin değerini olabildiğince betimlemesine dikkat etmemiz kodlarımızın okunaklılığını artıracaktır.
Örneğin:

```python
>>> personel_sayısı = 45

```

Yukarıdaki, tanımladığı değere uygun bir değişken adıdır.
Şu ise kurallara uygun bir değişken adı olsa da yeterince betimleyici değildir:

```python
>>> sayı = 45

```

9. Değişken adları ne çok kısa, ne de çok uzun olmalıdır.
Mesela şu değişken adı, kodları okuyan kişiye, değişken değerinin anlamı konusunda pek fikir vermez:

```python
>>> a = 345542353

```

Şu değişken adı ise gereksiz yere uzundur:

```python
>>> türkiye_büyük_millet_meclisi_milletvekili_sayısı = 600

```

Değişken adlarının uzunluğunu makul seviyede tutmak esastır:

```python
>>> tbmm_mv_sayısı = 600

```

Yukarıda verdiğimiz bütün bu örnekler bize, Python’da değişkenlerin, değerlere atanmış adlardan ibaret olduğunu gösteriyor.
Değişkenler, yazdığımız programlarda bize çok büyük kolaylık sağlar.
Mesela123432456322gibi bir sayıyı ya da“Türkiye Cumhuriyeti Çalışma ve Sosyal Güvenlik Bakanlığı”gibi bir karakter dizisini gerektiği her yerde tek tek elle yazmak yerine, bunları birer değişkene atayarak, gerektiğinde sadece bu değişken adını kullanmak çok daha mantıklı bir iştir.

Ayrıca zaten ileride kullanıcıdan veri almaya başladığınızda, aldığınız bu verileri, yazdığınız programda kullanabilmek için mutlaka bir değişkene atamanız gerekecek.
O yüzden Python’daki değişken kavramını şimdiden iyi tanıyıp anlamakta büyük fayda var.

##### Uygulama Örnekleri

Gelin isterseniz yukarıda verdiğimiz bilgileri pekiştirmek için birkaç ufak alıştırma yapalım, alıştırma yaparken de sizi yine Python programlama diline ilişkin çok önemli bazı yeni bilgilerle tanıştıralım.

Diyelim ki aylık yol masrafımızı hesaplayan bir program yazmak istiyoruz.
Elimizdeki verilerin şunlar olduğunu varsayalım:
1. Cumartesi-Pazar günleri çalışmıyoruz.
1. Dolayısıyla ayda22gün çalışıyoruz.
1. Evden işe gitmek için kullandığımız vasıtanın ücreti1.5TL
1. İşten eve dönmek için kullandığımız vasıtanın ücreti1.4TL

Cumartesi-Pazar günleri çalışmıyoruz.

Dolayısıyla ayda22gün çalışıyoruz.

Evden işe gitmek için kullandığımız vasıtanın ücreti1.5TL

İşten eve dönmek için kullandığımız vasıtanın ücreti1.4TL

Aylık yol masrafımızı hesaplayabilmek için gidiş ve dönüş ücretlerini toplayıp, bunları çalıştığımız gün sayısıyla çarpmamız yeterli olacaktır.
Elimizdeki bu bilgilere göre aylık yol masrafımızı hesaplamak için şöyle bir formül üretebiliriz:

```python
masraf = gün sayısı x (gidiş ücreti + dönüş ücreti)

```

Dilerseniz hemen bunu bir Python programı haline getirelim:

```python
>>> 22 * (1.5 + 1.4)

63.8

```

Demek ki bir ayda63.8TL’lik bir yol masrafımız varmış.

Bu arada, yukarıdaki örnekte bir şey dikkatinizi çekmiş olmalı.
Aritmetik işlemi yaparken bazı sayıları parantez içine aldık.
Python’da aritmetik işlemler yapılırken alıştığımız matematik kuralları geçerlidir.
Yani mesela aynı anda bölme, çıkarma, toplama ve çarpma işlemleri yapılacaksa işlem öncelik sırası önce bölme ve çarpma, sonra toplama ve çıkarma şeklinde olacaktır.
Elbette siz parantezler yardımıyla bu işlem sırasını değiştirebilirsiniz.

Bu anlattıklarımıza göre, eğer yukarıda yol masrafını hesaplayan programda parantezleri kullanmazsak, işlem öncelik kuralları gereğince Python önce22ile1.5’i çarpıp, çıkan sonucu1.4ile toplayacağı için elde ettiğimiz sonuç yanlış çıkacaktır.
Bizim burada doğru sonuç alabilmemiz için önce1.5ile1.4’ü toplamamız, çıkan sonucu da22ile çarpmamız gerekiyor.
Bu sıralamayı da parantezler yardımıyla elde ediyoruz.

Yine dikkat ederseniz, yukarıdaki örnek programda aslında çok verimsiz bir yol izledik.
Gördüğünüz gibi, bu programda bütün değerleri tek tek elle kendimiz giriyoruz.
Örneğin çalışılan gün sayısına karşılık gelen22değerini başka bir yerde daha kullanmak istesek aynı sayıyı tekrar elle doğrudan kendimiz girmek zorundayız.
Mesela yılda kaç gün çalıştığımızı hesaplayalım:

```python
>>> 22 * 12

264

```

Gördüğünüz gibi, burada da22sayısına ihtiyaç duyduk.
Aslında değerleri bu şekilde her defasında tekrar tekrar elle girmek hem hata yapma riskini artırdığı, hem de bize fazladan iş çıkardığı için tercih edilmeyen bir yöntemdir.
Bunun yerine,22sayısına bir isim verip, gereken yerlerde bu ismi kullanmak daha mantıklı olacaktır.
Yani tıpkı kullanıcı ve parola örneğinde olduğu gibi, burada da verileri öncelikle bir değişkene atamak çok daha akıllıca bir iştir:

```python
>>> gün = 22
>>> gidiş_ücreti = 1.5
>>> dönüş_ücreti = 1.4
>>> gün * (gidiş_ücreti + dönüş_ücreti)

63.8

```

Bütün değerleri birer değişkene atadığımız için, artık bu değişkenleri istediğimiz yerde kullanabiliriz.
Mesela yılda toplam kaç gün çalıştığımızı bulmak istersek, ilgili değeri elle yazmak yerine, yukarıda tanımladığımızgündeğişkenini kullanabiliriz:

```python
>>> gün * 12

264

```

İlerleyen zamanda aylık çalışılan gün sayısı değişirse sadecegündeğişkeninin değerini değiştirmemiz yeterli olacaktır:

```python
>>> gün = 23
>>> gün * (gidiş_ücreti + dönüş_ücreti)

66.7

>>> gün * 12

276

```

Eğer bu şekilde değişken atamak yerine, değerleri gerektiği her yerde elle yazsaydık, bu değerlerde herhangi bir değişiklik yapmamız gerektiğinde program içinde geçen ilgili bütün değerleri bulup tek tek değiştirmemiz gerekecekti:

```python
>>> 23 * (1.6 + 1.5)

71.3

>>> 23 * 12

276

```

Değişken kavramı şu anda gözünüze pek anlamlı görünmemiş olabilir.
Ama programlarımızı ileride dosyaya kaydettiğimiz zaman bu değişkenler çok daha kullanışlı araçlar olarak karşımıza çıkacaktır.

Dilerseniz bir örnek daha yaparak yukarıdaki bilgilerin kafamıza iyice yerleşmesini sağlayalım.
Mesela bir dairenin alanını (yaklaşık olarak) hesaplayan bir program yazalım.

Öncelikleçapadlı bir değişken tanımlayarak dairenin çapını belirleyelim:

```python
>>> çap = 16

```

Bu değeri kullanarak dairemizin yarıçapını hesaplayabiliriz.
Bunun içinçapdeğişkeninin değerinin yarısını almamız yeterli olacaktır:

```python
>>> yarıçap = çap / 2

```

pi sayısını3.14159olarak alalım.

```python
>>> pi = 3.14159

```

Bir dairenin alan formülü (pi)r2’dir:

```python
>>> alan = pi * (yarıçap * yarıçap)

```

Son olarakalandeğişkeninin değerini ekrana yazdırabiliriz:

```python
>>> alan

201.06176

```

Böylece bir dairenin alanını yaklaşık olarak hesaplamış olduk.
Dilerseniz programımızı bir de derli toplu olarak görelim:

```python
>>> çap = 16
>>> yarıçap = çap / 2
>>> pi = 3.14159
>>> alan = pi * (yarıçap * yarıçap)
>>> alan

201.06176

```

Görüyorsunuz ya, değişkenler işimizi nasıl da kolaylaştırıyor.
Eğer yukarıdaki programda değişken kullanmasaydık kodlarımız şöyle görünecekti:

```python
>>> 3.14159 * ((16/2) * (16/2))

201.06176

```

Bu kodlar tek kullanımlıktır.
Eğer yukarıdaki örnekte mesela dairenin çapını değiştirmeniz gerekirse, iki yerde elle değişiklik yapmanız gerekir.
Ama değişkenleri kullandığımızda sadeceçapdeğişkeninin değerini değiştirmeniz yeterli olacaktır.
Ayrıca değişken kullanmadığınızda, ilgili değeri program boyunca aklınızda tutmanız gerekir.
Örneğinçapdeğişkenini kullanmak yerine, gereken her yerde16değerini kullanacaksanız, bu16değerini sürekli aklınızda tutmanız lazım.
Ama bu değeri en başta bir değişkene atarsanız,16değerini kullanmanız gereken yerlerde, akılda tutması daha kolay bir ifade olançapismini kullanabilirsiniz.

Bu arada yeri gelmişken sizi yeni bir işleçle daha tanıştıralım.
Şimdiye kadar Python’da toplama (+), çıkarma (-), çarpma (*), bölme (/) ve değer atama (=) işleçlerini gördük.
Ama yukarıda verdiğimiz son örnek, başka bir işleç daha öğrenmemizi gerektiriyor…

Yukarıdaki şu örneğe tekrar bakalım:

```python
alan = pi * (yarıçap * yarıçap)

```

Buradayarıçapdeğişkeninin karesini alabilmek için bu değeri kendisiyle çarptık.
Aslında gayet mantıklı ve makul bir yöntem.
Kare bulmak için değeri kendisiyle çarpıyoruz.
Eğer bir sayının küpünü bulmak isteseydik o sayıyı üç kez kendisiyle çarpacaktık:

```python
>>> 3 * 3 * 3

27

```

Peki ya bir sayının mesela beşinci kuvvetini hesaplamak istersek ne yapacağız?
O sayıyı beş kez kendisiyle mi çarpacağız?
Bu ne kadar vasat bir yöntem, değil mi?

Elbette bir sayının herhangi bir kuvvetini hesaplamak için o sayıyı kendisiyle kuvvetince çarpmayacağız.
Python’da bu tür ‘kuvvet hesaplamaları’ için ayrı bir işleç (ve fonksiyon) bulunur.

Öncelikle kuvvet hesaplarını yapmamızı sağlayan işleçten söz edelim.

Python’da**adlı bir işleç bulunur.
Bu işlecin görevi bir sayının kuvvetini hesaplamamızı sağlamaktır.
Örneğin bir sayının2.kuvvetini, ya da başka bir deyişle karesini hesaplamak istersek şöyle bir kod yazabiliriz:

```python
>>> 12 ** 2

144

```

Burada12sayısının2.kuvvetini, yani karesini hesapladık.
Bu bilgiyi yukarıdaki formüle uygulayalım:

```python
>>> alan = pi * (yarıçap ** 2)

```

Bu işleci herhangi bir sayının herhangi bir kuvvetini hesaplamak için kullanabiliriz elbette.
Mesela23sayısının küpünü (yani3.kuvvetini) hesaplayalım:

```python
>>> 23 ** 3

12167

```

Aynı işleçten, bir sayının karekökünü hesaplamak için de yararlanabilirsiniz.
Neticede bir sayının0.5’inci kuvveti, o sayının kareköküdür:

```python
>>> 144 ** 0.5

12.0

```

Gördüğünüz gibi, kuvvet hesaplama işlemleri için bu işleç son derece kullanışlı bir araç vazifesi görüyor.
Ama eğer istersek aynı iş için özel bir fonksiyondan da yararlanabiliriz.
Bu fonksiyonun adıpow().

Peki bu fonksiyonu nasıl kullanacağız?

Daha önce öğrendiğimiztype()velen()fonksiyonlarını nasıl kullanıyorsakpow()fonksiyonu da aynı şekilde kullanacağız.

type()velen()fonksiyonlarını birtakım parametreler ile birlikte kullanıyorduk hatırlarsanız.
Aynı şekildepow()fonksiyonu da birtakım parametreler alır.

Daha önce öğrendiğimiz fonksiyonları tek bir parametre ile birlikte kullanmıştık.pow()fonksiyonu ise toplam üç farklı parametre alır.
Ama genellikle bu fonksiyon yalnızca iki parametre ile kullanılır.

Bu fonksiyonu şöyle kullanıyoruz:

```python
>>> pow(12, 2)

144

>>> pow(23, 3)

12167

>>> pow(144, 0.5)

12.0

```

Gördüğünüz gibi,pow()fonksiyonunun ilk parametresi asıl sayıyı, ikinci parametresi ise bu sayının hangi kuvvetini hesaplamak istediğimizi gösteriyor.

Bu arada, fonksiyonun parantezleri içinde belirttiğimiz parametreleri birbirinden virgül ile ayırdığımızı gözden kaçırmayın.

Dediğimiz gibi,pow()fonksiyonu, pek kullanılmayan üçüncü bir parametre daha alır.
Bu fonksiyonun üçüncü parametresi şöyle kullanılır.
Dikkatlice bakın:

```python
>>> pow(16, 2, 2)

0

```

Bu komut şu anlama gelir:

16sayısının2’nci kuvvetini hesapla ve çıkan sayıyı2’ye bölüp, bölme işleminden kalan sayıyı göster!

16sayısının2.kuvveti256sayısıdır.256sayısını2’ye böldüğümüzde, bölme işleminin kalanı0’dır.
Yani256sayısı2’ye tam bölünür…

Bir örnek daha verelim:

```python
>>> pow(11, 3, 4)

3

```

Demek ki,11sayısının3.kuvveti olan1331sayısı4’e bölündüğünde, bölme işleminden kalan sayı3imiş…

Dediğimiz gibi,pow()fonksiyonu genellikle sadece iki parametre ile kullanılır.
Üçüncü parametrenin kullanım alanı oldukça dardır.

##### Değişkenlere Dair Bazı İpuçları

Değişkenin ne demek olduğunu öğrendiğimize göre, değişkenlere dair bazı ufak ipuçları verebiliriz.

###### Aynı Değere Sahip Değişkenler Tanımlama

Şimdi size şöyle bir soru sormama izin verin:
Acaba aynı değere sahip iki değişkeni nasıl tanımlayabiliriz?
Yani mesela değeri4sayısı olan iki farklı değişkeni nasıl belirleyeceğiz?

Aklınıza şöyle bir çözüm gelmiş olabilir:

```python
>>> a = 4
>>> b = 4

```

Böylece ikisi de4değerine sahipavebadlı iki farklı değişken tanımlamış olduk.
Bu tamamen geçerli bir yöntemdir.
Ancak Python’da bu işlemi yapmanın daha kolay bir yolu var. Bakalım:

```python
>>> a = b = 4

```

Bu kodlar bir öncekiyle tamamen aynı işlevi görür.
Yani her iki kod da4değerine sahipavebdeğişkenleri tanımlamamızı sağlar:

```python
>>> a

4

>>> b

4

```

Bu bilgiyi kullanarak mesela bir yıl içindeki her bir ayın çektiği gün sayısını ay adlarına atayabilirsiniz:

```python
>>> ocak = mart = mayıs = temmuz = ağustos = ekim = aralık = 31
>>> nisan = haziran = eylül = kasım = 30
>>> şubat = 28

```

Böylece bir çırpıda değeri31olan yedi adet değişken, değeri30olan dört adet değişken, değeri28olan bir adet değişken tanımlamış olduk.
Bu değişkenlerin değerine nasıl ulaşacağınızı biliyorsunuz:

```python
>>> ocak

31
>>> haziran

30

>>> şubat

28

>>> mayıs

31

>>> ekim

31

>>> eylül

30

```

Eğer Python’ın aynı anda birden fazla değişkene tek bir değer atama özelliği olmasaydı yukarıdaki kodları şöyle yazmamız gerekirdi:

```python
>>> ocak = 31
>>> şubat = 28
>>> mart = 31
>>> nisan = 30
>>> mayıs = 31
>>> haziran = 30
>>> temmuz = 31
>>> ağustos = 31
>>> eylül = 30
>>> ekim = 31
>>> kasım = 30
>>> aralık = 31

```

Bu değişkenleri nasıl bir program içinde kullanacağınız tamamen sizin hayal gücünüze kalmış.
Mesela bu değişkenleri kullanarak aylara göre doğalgaz faturasını hesaplayan bir program yazabiliriz.

Hemen son gelen doğalgaz faturasını (örn. Mart ayı) elimize alıp inceliyoruz ve bu faturadan şu verileri elde ediyoruz:

Mart ayı doğalgaz faturasına göre sayaçtan ölçülen hacim346m3.
Demek ki bir ayda toplam346m3doğalgaz harcamışız.

Fatura tutarı273.87TL imiş. Yani346m3doğalgaz tüketmenin bedeli273.87TL.
Buna göre değişkenlerimizi tanımlayalım:

```python
>>> aylık_sarfiyat = 346
>>> fatura_tutarı = 273.87

```

Bu bilgiyi kullanarak doğalgazın birim fiyatını hesaplayabiliriz.
Formülümüz şöyle olmalı:

```python
>>> birim_fiyat = fatura_tutarı / aylık_sarfiyat

>>> birim_fiyat

0.7915317919075144

```

Demek ki doğalgazın m3fiyatı (vergilerle birlikte yaklaşık)0.79TL’ye karşılık geliyormuş.

Bu noktada günlük ortalama doğalgaz sarfiyatımızı da hesaplamamız gerekiyor:

```python
>>> günlük_sarfiyat = aylık_sarfiyat / mart
>>> günlük_sarfiyat

11.161290322580646

```

Demek ki Mart ayında günlük ortalama11m3doğalgaz tüketmişiz.

Bütün bu bilgileri kullanarak Nisan ayında gelecek faturayı tahmin edebiliriz:

```python
>>> nisan_faturası = birim_fiyat * günlük_sarfiyat * nisan
>>> nisan_faturası

265.03548387096777

```

Şubat ayı faturası ise şöyle olabilir:

```python
>>> şubat_faturası = birim_fiyat * günlük_sarfiyat * şubat
>>> şubat_faturası

247.36645161290326

```

Burada farklı değişkenlerin değerini değiştirerek daha başka işlemler de yapabilirsiniz.
Örneğin pratik olması açısındangünlük_sarfiyatdeğişkeninin değerini15yaparak hesaplamalarınızı buna göre güncelleyebilirsiniz.

Gördüğünüz gibi, aynı anda birden fazla değişken tanımlayabilmek işlerimizi epey kolaylaştırıyor.

Değişkenlerle ilgili bir ipucu daha verelim…

###### Değişkenlerin Değerini Takas Etme

Diyelim ki, işyerinizdeki personelin unvanlarını tuttuğunuz bir veritabanı var elinizde.
Bu veritabanında şuna benzer ilişkiler tanımlı:

```python
>>> osman = "Araştırma Geliştirme Müdürü"
>>> mehmet = "Proje Sorumlusu"

```

İlerleyen zamanda işvereniniz sizden Osman ve Mehmet’in unvanlarını değiştirmenizi talep edebilir.
Yani Osman’ı Proje Sorumlusu, Mehmet’i de Araştırma Geliştirme Müdürü yapmanızı isteyebilir sizden.

Patronunuzun bu isteğini Python’da çok rahat bir biçimde yerine getirebilirsiniz.
Dikkatlice bakın:

```python
>>> osman, mehmet = mehmet, osman

```

Böylece tek hamlede bu iki kişinin unvanlarını takas etmiş oldunuz.
Gelin isterseniz değişkenlerin son durumuna bakalım:

```python
>>> osman

'Proje Sorumlusu

>>> mehmet

'Araştırma Geliştirme Müdürü'

```

Gördüğünüz gibi,osmandeğişkeninin değerinimehmet’e;mehmetdeğişkeninin değerini iseosman’a başarıyla verebilmişiz.

Yukarıdaki yöntem Python’ın öteki diller üzerinde önemli bir üstünlüğüdür.
Başka programlama dillerinde bu işlemi yapmak için geçici bir değişken tanımlamanız gerekir.
Yani mesela:

```python
>>> osman = "Araştırma Geliştirme Müdürü"
>>> mehmet = "Proje Sorumlusu"

```

Elimizdeki değerler bunlar.
Biz şimdi Osman’ın değerini Mehmet’e; Mehmet’in değerini ise Osman’a aktaracağız.
Bunun için öncelikle bir geçici değişken tanımlamalıyız:

```python
>>> geçici = "Proje Sorumlusu"

```

Bu sayede“Proje Sorumlusu”değerini yedeklemiş olduk.
Bu işlem sayesinde, takas sırasında bu değeri kaybetmeyeceğiz.

Şimdi Osman’ın değerini Mehmet’e aktaralım:

```python
>>> mehmet = osman

```

Şimdi elimizde iki tane Araştırma Geliştirme Müdürü olmuş oldu:

```python
>>> mehmet

'Araştırma Geliştirme Müdürü'

>>> osman

'Araştırma Geliştirme Müdürü'

```

Gördüğünüz gibi,mehmet=osmankodunu kullanarakmehmetdeğişkeninin değeriniosmandeğişkeninin değeriyle değiştirdiğimiz için“Proje Sorumlusu”değeri ortadan kayboldu.
Ama biz önceden bu değerigeçiciadlı değişkene atadığımız için bu değeri kaybetmemiş olduk.
Şimdi Osman’ageçicideğişkeni içinde tuttuğumuz“Proje Sorumlusu”değerini verebiliriz:

```python
>>> osman = geçici

```

Böylece istediğimiz takas işlemini gerçekleştirmiş olduk.
Son durumu kontrol edelim:

```python
>>> osman

'Proje Sorumlusu

>>> mehmet

'Araştırma Geliştirme Müdürü'

```

Basit bir işlem için ne kadar büyük bir zaman kaybı, değil mi?
Ama dediğimiz gibi, Python’da bu şekilde geçici bir değişken atamakla uğraşmamıza hiç gerek yok.
Sadece şu formülü kullanarak değişkenlerin değerini takas edebiliriz:

```python
a, b = b, a

```

Bu şekildeadeğişkeninin değerinibdeğişkenine;bdeğişkeninin değerini iseadeğişkenine vermiş oluyoruz.
Eğer bu işlemi geri alıp her şeyi eski haline döndürmek istersek, tahmin edebileceğiniz gibi yine aynı yöntemden yararlanabiliriz:

```python
b, a = a, b

```

Böylece değişkenler konusunu da oldukça ayrıntılı bir şekilde incelemiş olduk.
Ayrıca bu esnadalen()vepow()adlı iki yeni fonksiyon ile**adlı bir işleç de öğrendik.

Hazır lafı geçmişken,len()fonksiyonunun bazı kısıtlamalarından söz edelim.
Dediğimiz gibi, bu fonksiyonu kullanarak karakter dizileri içinde toplam kaç adet karakter bulunduğunu hesaplayabiliyoruz.
Örneğin:

```python
>>> kelime = "muvaffakiyet"
>>> len(kelime)

12

```

Yalnız bulen()fonksiyonunu sayıların uzunluğunu ölçmek için kullanamıyoruz:

```python
>>> len(123456)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: object of type 'int' has no len()

```

Gördüğünüz gibi,len()fonksiyonu, şu ana kadar öğrendiğimiz veri tipleri arasında yalnızca karakter dizileri ile birlikte kullanılabiliyor.
Bu fonksiyonu sayılarla birlikte kullanamıyoruz.

Bu bölümün başında, o anda elimizde bulunan bir verinin tipini bilmemizin çok önemli olduğunu ve Python’da bir verinin tipinin, o veri ile neler yapıp neler yapamayacağınızı belirlediğini söylediğimizi hatırlıyorsunuz, değil mi?
İştelen()fonksiyonu bu duruma çok güzel bir örnektir.

len()fonksiyonu sayılarla birlikte kullanılamaz.
Dolayısıyla eğer elinizdeki verinin bir sayı olduğunu bilmezseniz, bu sayıyılen()fonksiyonu ile birlikte kullanmaya çalışabilir ve bu şekilde programınızın hata vererek çökmesine yol açabilirsiniz.

Ayrıca daha önce de söylediğimiz gibi,len()fonksiyonunu doğru kullanabilmek için, bu fonksiyonun bize sayı değerli bir çıktı verdiğini de bilmemiz gerekir.

len()fonksiyonu ile ilgili bu durumu da bir kenara not ettikten sonra yolumuza kaldığımız yerden devam edelim.

### Etkileşimli Kabuğun Hafızası

Bir önceki bölümde Python’ın etkileşimli kabuğunun nasıl kullanılacağına dair epey örnek verdik ve etkileşimli kabuk üzerinden Python’ın bazı temel araçlarına kısa bir giriş yaptık.
Şimdi isterseniz yeri gelmişken Python’ın etkileşimli kabuğunun bir başka yeteneğinden daha söz edelim.

Etkileşimli kabukta_adlı işaret (alt çizgi işareti), yapılan son işlemin veya girilen son öğenin değerini tutma işlevi görür.
Yani:

```python
>>> 2345 + 54355

56700

```

Eğer bu işlemin ardından_komutunu verirsek şöyle bir çıktı alırız:

```python
>>> _

56700

```

Gördüğünüz gibi,_komutu son girilen öğeyi hafızasında tutuyor.
Bu özellikten çeşitli şekillerde yararlanabilirsiniz:

```python
>>> _ + 15

56715

```

Burada_komutunun değeri bir önceki işlemin sonucu olan56700değeri olduğu için,_komutuna15eklediğimizde56715değerini elde ediyoruz._komutunun değerini tekrar kontrol edelim:

```python
>>> _

56715

```

Gördüğünüz gibi,_komutunun değeri artık56715sayısıdır…

_komutu yalnızca sayıları değil, karakter dizilerini de hafızasında tutabilir:

```python
>>> "www"

'www'

>>> _

'www'

>>> _ + ".yazbel.com"

'www.yazbel.com'

```

Bu işaret öyle çok sık kullanılan bir araç değildir, ama zaman zaman işinizi epey kolaylaştırır.
Yalnız, unutmamamız gereken şey, bu özelliğin sadece etkileşimli kabuk ortamında geçerli olmasıdır._komutunun etkileşimli kabuk ortamı dışında herhangi bir geçerliliği yoktur.

Aslında burada söylenecek daha çok şey var.
Ama biz şimdilik bunları sonraki konulara bırakacağız.
Zira bu bölümdeki amacımız size konuların her ayrıntısını vermekten ziyade, Python’a ısınmanızı sağlamaktır.

## print() Fonksiyonu

Geçen bölümde bir yandan Python’ın etkileşimli kabuğunu yakından tanıyıp bu
vesileyle bazı önemli fonksiyon ve araçları öğrenirken, öbür yandan bu
öğrendiklerimizi kullanarak örnek programlar yazdık. Gördüğünüz gibi, azıcık bir
bilgiyle dahi az çok işe yarar programlar yazmak mümkün olabiliyor. Daha yararlı
programlar yazabilmek için henüz öğrenmemiz gereken pek çok şey var. İşte bu
bölümde, ‘daha yararlı programlar yazmamızı’ sağlayacak çok önemli bir araçtan
söz edeceğiz. Öneminden dolayı ayrıntılı bir şekilde anlatacağımız bu aracın adıprint()fonksiyonu.

Elbette bu bölümde sadeceprint()fonksiyonundan bahsetmeyeceğiz. Bu bölümdeprint()fonksiyonunun yanısıra Python’daki bazı önemli temel konuları da ele
alacağız. Mesela bu bölümde Python’daki karakter dizilerine ve sayılara ilişkin
çok önemli bilgiler vereceğiz. Ayrıcaprint()fonksiyonu vesilesiyle
Python’daki ‘fonksiyon’ konusuna da sağlam bir giriş yapmış, bu kavram ile
ilgili ilk bilgilerimizi almış olacağız. Sözün özü, bu bölüm bizim için, deyim
yerindeyse, tam anlamıyla bir dönüm noktası olacak.

O halde isterseniz lafı daha fazla uzatmadan işeprint()fonksiyonunun ne
olduğu ve ne işe yaradığını anlatarak başlayalım.

### Nedir, Ne İşe Yarar?

Şimdiye kadar etkileşimli kabukta gerek karakter dizilerini gerekse sayıları
doğrudan ekrana yazdık. Yani şöyle bir şey yaptık:

```python
>>> "Python programlama dili"

'Python programlama dili'

>>> 6567

6567

```

Etkileşimli kabuk da, ekrana yazdığımız bu karakter dizisi ve sayıyı doğrudan
bize çıktı olarak verdi. Ancak ilerde Python kodlarımızı bir dosyaya kaydedip
çalıştırdığımızda da göreceğiniz gibi, Python’ın ekrana çıktı verebilmesi için
yukarıdaki kullanım yeterli değildir. Yani yukarıdaki kullanım yalnızca
etkileşimli kabukta çalışır. Bu kodları bir dosyaya kaydedip çalıştırmak
istediğimizde hiçbir çıktı alamayız. Python’da yazdığımız şeylerin ekrana çıktı
olarak verilebilmesi içinprint()adlı özel bir fonksiyondan yararlanmamız
gerekir.

O halde gelin buprint()fonksiyonunun ne işe yaradığını ve nasıl
kullanıldığını anlamaya çalışalım:

print()de tıpkı daha önce gördüğümüztype(),len()vepow()gibi bir fonksiyondur. Fonksiyonları ilerde daha ayrıntılı bir şekilde
inceleyeceğimizi söylemiştik hatırlarsanız. O yüzden fonksiyon kelimesine
takılarak, burada anlattığımız şeylerin kafanızı karıştırmasına, moralinizi
bozmasına izin vermeyin.

print()fonksiyonunun görevi ekrana çıktı vermemizi sağlamaktır. Hemen
bununla ilgili bir örnek verelim:

```python
>>> print("Python programlama dili")

Python programlama dili

```

Bildiğiniz gibi burada gördüğümüz“Python programlama dili”bir karakter
dizisidir. İşteprint()fonksiyonunun görevi bu karakter dizisini ekrana
çıktı olarak vermektir. Peki bu karakter dizisiniprint()fonksiyonu olmadan
yazdığımızda da ekrana çıktı vermiş olmuyor muyuz? Aslında olmuyoruz. Dediğimiz
gibi, ilerde programlarımızı dosyalara kaydedip çalıştırdığımızda, başındaprint()olmayan ifadelerin çıktıda görünmediğine şahit olacaksınız.

Daha önce de dediğimiz gibi, etkileşimli kabuk bir test ortamı olması açısından
rahat bir ortamdır. Bu sebeple bu ortamda ekrana çıktı verebilmek içinprint()fonksiyonunu kullanmak zorunda değilsiniz. Yani başındaprint()olsa da olmasa da etkileşimli kabuk ekrana yazdırmak istediğiniz şeyi yazdırır.
Ama iyi bir alışkanlık olması açısından, ekrana herhangi bir şey
yazdıracağınızda ben sizeprint()fonksiyonunu kullanmanızı tavsiye ederim.

print()son derece güçlü bir fonksiyondur. Gelin isterseniz bu güçlü ve
faydalı fonksiyonu derin derin incelemeye koyulalım.

### Nasıl Kullanılır?

Yukarıda verdiğimiz örnekte ilk gözümüze çarpan şey, karakter dizisiniprint()fonksiyonunun parantezleri içine yazmış olmamızdır. Biz bir
fonksiyonun parantezleri içinde belirtilen öğelere ‘parametre’ dendiğini geçen
bölümde öğrenmiştik. Tıpkı öğrendiğimiz öteki fonksiyonlar gibi,print()fonksiyonu da birtakım parametreler alır.

Bu aradaprint()fonksiyonunun parantezini açıp parametreyi yazdıktan sonra,
parantezi kapatmayı unutmuyoruz. Python programlama diline yeni başlayanların,
hatta bazen deneyimli programcıların bile en sık yaptığı hatalardan biri
açtıkları parantezi kapatmayı unutmalarıdır.

Elbette, eğer istersek burada doğrudan“Python programlama dili”adlı karakter
dizisini kullanmak yerine, önce bu karakter dizisini bir değişkene atayıp, sonra
daprint()fonksiyonunun parantezleri içinde bu değişkeni kullanabiliriz.
Yani:

```python
>>> dil = "Python programlama dili"
>>> print(dil)

Python programlama dili

```

Bu arada, hem şimdi verdiğimiz, hem de daha önce yazdığımız örneklerde bir şey
dikkatinizi çekmiş olmalı. Şimdiye kadar verdiğimiz örneklerde karakter
dizilerini hep çift tırnakla gösterdik. Ama aslında tek seçeneğimiz çift tırnak
değildir. Python bize üç farklı tırnak seçeneği sunar:
1. Tek tırnak (’ ‘)
1. Çift tırnak (” “)
1. Üç tırnak (“”” “””)

Tek tırnak (’ ‘)

Çift tırnak (” “)

Üç tırnak (“”” “””)

Dolayısıyla yukarıdaki örneği üç farklı şekilde yazabiliriz:

```python
>>> print('Python programlama dili')

Python programlama dili

>>> print("Python programlama dili")

Python programlama dili

>>> print("""Python programlama dili""")

Python programlama dili

```

Gördüğünüz gibi çıktılar arasında hiçbir fark yok.

Peki çıktılarda hiçbir fark yoksa neden üç farklı tırnak çeşidi var?

İsterseniz bu soruyu bir örnek üzerinden açıklamaya çalışalım. Diyelim ki ekrana
şöyle bir çıktı vermek istiyoruz:

```python
Python programlama dilinin adı "piton" yılanından gelmez

```

Eğer bu cümleyi çift tırnaklar içinde gösterirsek programımız hata verecektir:

```python
>>> print("Python programlama dilinin adı "piton" yılanından gelmez")

File "<stdin>", line 1
 print("Python programlama dilinin adı "piton" yılanından gelmez")
 ^
SyntaxError: invalid syntax

```

Bunun sebebi, cümle içinde geçen ‘piton’ kelimesinin de çift tırnaklar içinde
gösterilmiş olmasıdır. Cümlenin, yani karakter dizisinin kendisi de çift tırnak
içinde gösterildiği için Python, karakter dizisini başlatan ve bitiren
tırnakların hangisi olduğunu ayırt edemiyor. Yukarıdaki cümleyi en kolay şu
şekilde ekrana yazdırabiliriz:

```python
>>> print('Python programlama dilinin adı "piton" yılanından gelmez')

Python programlama dilinin adı "piton" yılanından gelmez

```

Burada karakter dizisini tek tırnak içine aldık. Karakter dizisi içinde geçen
‘piton’ kelimesi çift tırnak içinde olduğu için, karakter dizisini başlatıp
bitiren tırnaklarla ‘piton’ kelimesindeki tırnakların birbirine karışması gibi
bir durum söz konusu değildir.

Bir de şöyle bir örnek verelim: Diyelim ki aşağıdaki gibi bir çıktı elde etmek
istiyoruz:

```python
İstanbul'un 5 günlük hava durumu tahmini

```

Eğer bu karakter dizisini tek tırnak işaretleri içinde belirtirseniz Python size
bir hata mesajı gösterecektir:

```python
>>> print('İstanbul'un 5 günlük hava durumu tahmini')

File "<stdin>", line 1
 print('İstanbul'un 5 günlük hava durumu tahmini')
 ^
SyntaxError: invalid syntax

```

Bu hatanın sebebi ‘İstanbul’un’ kelimesi içinde geçen kesme işaretidir. Tıpkı
bir önceki örnekte olduğu gibi, Python karakter dizisini başlatan ve bitiren
tırnakların hangisi olduğunu kestiremiyor. Python, karakter dizisinin en
başındaki tek tırnak işaretinin ardından ‘İstanbul’un’ kelimesi içindeki kesme
işaretini görünce karakter dizisinin burada sona erdiğini zannediyor. Ancak
karakter dizisini soldan sağa doğru okumaya devam edince bir yerlerde bir
terslik olduğunu düşünüyor ve bize bir hata mesajı göstermekten başka çaresi
kalmıyor. Yukarıdaki karakter dizisini en kolay şöyle tanımlayabiliriz:

```python
>>> print("İstanbul'un 5 günlük hava durumu tahmini")

İstanbul'un 5 günlük hava durumu tahmini

```

Burada da, karakter dizisi içinde geçen kesme işaretine takılmamak için karakter
dizimizi çift tırnak işaretleri içine alıyoruz.

Yukarıdaki karakter dizilerini düzgün bir şekilde çıktı verebilmek için üç
tırnak işaretlerinden de yararlanabiliriz:

```python
>>> print("""Python programlama dilinin adı "piton" yılanından gelmez""")

Python programlama dilinin adı "piton" yılanından gelmez

>>> print("""İstanbul'un 5 günlük hava durumu tahmini""")

İstanbul'un 5 günlük hava durumu tahmini

```

Bütün bu örneklerden sonra kafanızda şöyle bir düşünce uyanmış olabilir:

Görünüşe göre üç tırnak işaretiyle her türlü karakter dizisini hatasız bir
şekilde ekrana çıktı olarak verebiliyoruz. O zaman ben en iyisi bütün
karakter dizileri için üç tırnak işaretini kullanayım!

Elbette, eğer istersenizpek çok karakter dizisi içinüç tırnak işaretini
kullanabilirsiniz. Ancak Python’da karakter dizileri tanımlanırken genellikle
tek tırnak veya çift tırnak işaretleri kullanılır. Üç tırnak işaretlerinin asıl
kullanım yeri ise farklıdır. Peki nedir bu üç tırnak işaretlerinin asıl kullanım
yeri?

Üç tırnak işaretlerini her türlü karakter dizisiyle birlikte kullanabiliyor
olsak da, bu tırnak tipi çoğunlukla sadece birden fazla satıra yayılmış karakter
dizilerini tanımlamada kullanılır. Örneğin şöyle bir ekran çıktısı vermek
istediğinizi düşünün:

```python
[H]=========HARMAN========[-][o][x]
| |
| Programa Hoşgeldiniz! |
| Sürüm 0.8 |
| Devam etmek için herhangi |
| bir düğmeye basın. |
| |
|=================================|

```

Böyle bir çıktı verebilmek için eğer tek veya çift tırnak kullanmaya
kalkışırsanız epey eziyet çekersiniz. Bu tür bir çıktı vermenin en kolay yolu üç
tırnakları kullanmaktır:

```python
>>> print("""
... [H]=========HARMAN========[-][o][x]
... | |
... | Programa Hoşgeldiniz! |
... | Sürüm 0.8 |
... | Devam etmek için herhangi |
... | bir düğmeye basın. |
... | |
... |=================================|
... """)

```

Burada bazı şeyler dikkatinizi çekmiş olmalı. Gördüğünüz gibi, üç tırnaklı yapı
öteki tırnak tiplerine göre biraz farklı davranıyor. Şimdi şu örneğe bakın:

```python
>>> print("""Game Over!
...

```

Buraya çok dikkatli bakın. Karakter dizisine üç tırnakla başladıktan sonra,
kapanış tırnağını koymadanEntertuşuna bastığımızda>>>işareti…işaretine dönüştü. Python bu şekilde bize, ‘yazmaya devam et!’ demiş oluyor. Biz
de buna uyarak yazmaya devam edelim:

```python
>>> print("""Game Over!
... Insert Coin!""")

Game Over!
Insert Coin!

```

Kapanış tırnağı koyulmadanEntertuşuna basıldığında>>>işaretinin…işaretine dönüşmesi üç tırnağa özgü bir durumdur. Eğer aynı şeyi tek veya çift
tırnaklarla yapmaya çalışırsanız programınız hata verir:

```python
>>> print("Game Over!

File "<stdin>", line 1
 print("Game Over!
 ^
SyntaxError: EOL while scanning string literal

```

…veya:

```python
>>> print('Game Over!

File "<stdin>", line 1
 print("Game Over!
 ^
SyntaxError: EOL while scanning string literal

```

Üç tırnak işaretlerinin tırnak kapanmadanEntertuşuna basıldığında hata
vermeme özelliği sayesinde, bu tırnak tipi özellikle birden fazla satıra
yayılmış karakter dizilerinin gösterilmesi için birebirdir.

Gelin isterseniz üç tırnak kullanımına ilişkin bir örnek daha verelim:

```python
>>> print("""Python programlama dili Guido Van Rossum
... adlı Hollandalı bir programcı tarafından 90’lı
... yılların başında geliştirilmeye başlanmıştır. Çoğu
... insan, isminin "Python" olmasına bakarak, bu programlama
... dilinin, adını piton yılanından aldığını düşünür.
... Ancak zannedildiğinin aksine bu programlama dilinin
... adı piton yılanından gelmez.""")

Python programlama dili Guido Van Rossum
adlı Hollandalı bir programcı tarafından 90'lı
yılların başında geliştirilmeye başlanmıştır. Çoğu
insan, isminin "Python" olmasına bakarak, bu programlama
dilinin, adını piton yılanından aldığını düşünür.
Ancak zannedildiğinin aksine bu programlama dilinin
dı piton yılanından gelmez.

```

Elbette eğer istersek bu metni önce bir değişkene atamayı da tercih edebiliriz:

```python
>>> python_hakkinda = """Python programlama dili Guido Van Rossum
... adlı Hollandalı bir programcı tarafından 90’lı
... yılların başında geliştirilmeye başlanmıştır. Çoğu
... insan, isminin "Python" olmasına bakarak, bu programlama
... dilinin, adını piton yılanından aldığını düşünür.
... Ancak zannedildiğinin aksine bu programlama dilinin
... adı piton yılanından gelmez."""
>>> print(python_hakkinda)

Python programlama dili Guido Van Rossum
adlı Hollandalı bir programcı tarafından 90'lı
yılların başında geliştirilmeye başlanmıştır. Çoğu
insan, isminin "Python" olmasına bakarak, bu programlama
dilinin, adını piton yılanından aldığını düşünür.
Ancak zannedildiğinin aksine bu programlama dilinin
adı piton yılanından gelmez.

```

Siz yukarıdaki çıktıyı tek veya çift tırnak kullanarak nasıl ekrana
yazdırabileceğinizi düşünedurun, biz önemli bir konuya geçiş yapalım!

### Bir Fonksiyon Olarak print()

print()ifadesinin bir fonksiyon olduğunu söylemiştik hatırlarsanız.
Dediğimiz gibi, fonksiyonlarla ilgili ayrıntılı açıklamaları ilerleyen derslerde
vereceğiz. Ancak şimdi dilerseniz bundan sonra anlatacaklarımızı daha iyi
kavrayabilmemiz için, fonksiyonlar hakkında bilmemiz gereken bazı temel şeyleri
öğrenmeye çalışalım.

Gördüğünüz gibi,print()fonksiyonunu şöyle kullanıyoruz:

```python
>>> print("Aramak istediğiniz kelimeyi yazın: ")

```

Buradaprint()bir fonksiyon,“Aramak istediğiniz kelimeyi yazın:”adlı
karakter dizisi ise bu fonksiyonun parametresidir. Daha öncelen()adlı
başka bir fonksiyon daha öğrenmiştik hatırlarsanız. Onu da şöyle kullanıyorduk:

```python
>>> len("elma")

```

Burada dalen()bir fonksiyon,“elma”adlı karakter dizisi ise bu
fonksiyonun parametresidir. Aslında biçim olarakprint()velen()fonksiyonlarının birbirinden hiçbir farkı olmadığını görüyorsunuz.

Daha önce söylediğimiz ve bu örneklerden de anladığımız gibi, bir fonksiyonun
parantezleri içinde belirtilen öğelere parametre adı veriliyor. Mesela aşağıdaki
örnekteprint()fonksiyonunu tek bir parametre ile kullanıyoruz:

```python
>>> print('En az 8 haneli bir parola belirleyin.')

```

print()fonksiyonu, tıpkıpow()fonksiyonu gibi, birden fazla parametre alabilir:

```python
>>> print('Fırat', 'Özgül')

Fırat Özgül

```

Bu örnekte bizim için çıkarılacak çok dersler var. Bir defa buradaprint()fonksiyonunu iki farklı parametre ile birlikte kullandık. Bunlardan ilkiFıratadlı bir karakter dizisi, ikincisi iseÖzgüladlı başka bir karakter dizisi.
Python’ın bu iki karakter dizisini nasıl birleştirdiğine dikkat edin.print()fonksiyonu bu iki karakter dizisini çıktı olarak verirken aralarına
da birer boşluk yerleştirdi. Ayrıca, geçen derste de vurguladığımız gibi,
parametrelerin birbirinden virgül ile ayrıldığını da gözden kaçırmıyoruz.

Gelin bununla ilgili bir iki örnek daha verelim elimizin alışması için:

```python
>>> print("Python", "Programlama", "Dili")

Python Programlama Dili

>>> print('Fırat', 'Özgül', 'Adana', 1980)

Fırat Özgül Adana 1980

```

Bu arada dikkatinizi önemli bir noktaya çekmek istiyorum. Yukarıdaki örneklerde
bazen tek tırnak, bazen de çift tırnak kullandık. Daha önce de söylediğimiz
gibi, hangi tırnak tipini kullandığımız önemli değildir. Python hangi tırnak
tipini kullandığımızdan ziyade, tırnak kullanımında tutarlı olup olmadığımızla
ilgilenir. Yani Python için önemli olan, karakter dizisini hangi tırnakla
başlatmışsak, o tırnakla bitirmemizdir. Yani şu tip kullanımlar geçerli
değildir:

```python
>>> print("karakter dizisi')

>>> print('karakter dizisi")

```

Karakter dizisini tanımlamaya başlarken kullandığımız tırnak tipi ile karakter
dizisini tanımlamayı bitirirken kullandığımız tırnak tipi birbirinden farklı
olduğu için bu iki kullanım da hata verecektir.

### print() Fonksiyonunun Parametreleri

Şimdiye kadar verdiğimiz örneklerde belki çok da belli olmuyordur, ama aslındaprint()fonksiyonu son derece güçlü bir araçtır. İşte şimdi biz bu
fonksiyonun gücünü gözler önüne seren özelliklerini incelemeye başlayacağız. Bu
bölümü dikkatle takip etmeniz, ilerde yapacağımız çalışmaları daha rahat
anlayabilmeniz açısından büyük önem taşır.

#### sep

print()fonksiyonu ile ilgili olarak yukarıda verdiğimiz örnekleri
incelediğimizde, bu fonksiyonun kendine özgü bir davranış şekli olduğunu
görüyoruz. Mesela bir önceki bölümde verdiğimiz şu örneğe bakalım:

```python
>>> print('Fırat', 'Özgül')

Fırat Özgül

```

Buradaprint()fonksiyonunu iki farklı parametre ile birlikte kullandık. Bu
fonksiyon, kendisine verdiğimiz bu parametreleri belli bir düzene göre
birbiriyle birleştirdi. Bu düzen gereğinceprint(), kendisine verilen
parametreleri birleştirirken, parametreler arasına bir boşluk yerleştiriyor.
Bunu daha net görmek için şöyle bir örnek daha verelim:

```python
>>> print("Python", "PHP", "C++", "C", "Erlang")

Python PHP C++ C Erlang

```

Gördüğünüz gibi,print()fonksiyonu gerçekten de, kendisine verilen
parametreleri birleştirirken, parametrelerin her biri arasına bir boşluk
yerleştiriyor. Halbuki bu boşluğu biz talep etmedik! Python bize bu boşluğu
eşantiyon olarak verdi. Çoğu durumda istediğimiz şey bu olacaktır, ama bazı
durumlarda bu boşluğu istemeyebiliriz. Örneğin:

```python
>>> print("http://", "www.", "istihza.", "com")

http:// www. istihza. com

```

Ya da boşluk karakteri yerine daha farklı bir karakter kullanmak istiyor da
olabiliriz. Peki böyle bir durumda ne yapmamız gerekir?

İşte bu noktada bazı özel araçlardan yararlanarakprint()fonksiyonunun
öntanımlı davranış kalıpları üzerinde değişiklikler yapabiliriz.

Peki nedirprint()fonksiyonunu özelleştirmemizi sağlayacak bu araçlar?

Hatırlarsanız, Python’da fonksiyonların parantezleri içindeki değerlere
parametre adı verildiğini söylemiştik. Meselaprint()fonksiyonunu bir ya da
daha fazla parametre ile birlikte kullanabileceğimizi biliyoruz:

```python
>>> print("Mehmet", "Öz", "İstanbul", "Çamlıca", 156, "/", 45)

Mehmet Öz İstanbul Çamlıca 156 / 45

```

print()fonksiyonu içinde istediğimiz sayıda karakter dizisi ve/veya sayı
değerli parametre kullanabiliriz.

Fonksiyonların bir de daha özel görünümlü parametreleri vardır. Meselaprint()fonksiyonununsepadlı özel bir parametresi bulunur. Bu parametreprint()fonksiyonunda görünmese bile her zaman oradadır. Yani diyelim ki
şöyle bir kod yazdık:

```python
>>> print("http://", "www.", "google.", "com")

```

Burada herhangi birsepparametresi görmüyoruz. Ancak Python yukarıdaki kodu
aslında şöyle algılar:

```python
>>> print("http://", "www.", "google.", "com", sep=" ")

```

sepifadesi, İngilizcedeseparator(ayırıcı, ayraç) kelimesinin
kısaltmasıdır. Dolayısıylaprint()fonksiyonundaki busepparametresi,
ekrana basılacak öğeler arasına hangi karakterin yerleştirileceğini gösterir. Bu
parametrenin öntanımlı değeri bir adet boşluk karakteridir (” “). Yani siz bu
özel parametrenin değerini başka bir şeyle değiştirmezseniz, Python bu
parametrenin değerini bir adet boşluk karakteri olarak alacak ve ekrana
basılacak öğeleri birbirinden birer boşlukla ayıracaktır. Ancak eğer biz
istersek busepparametresinin değerini değiştirebiliriz. Böylece Python,
karakter dizilerini birleştirirken araya boşluk değil, bizim istediğimiz başka
bir karakteri yerleştirebilir. Gelin şimdi bu parametrenin değerini nasıl
değiştireceğimizi görelim:

```python
>>> print("http://", "www.", "istihza.", "com", sep="")

http://www.istihza.com

```

Gördüğünüz gibi, karakter dizilerini başarıyla birleştirip, geçerli bir internet
adresi elde ettik.

Burada yaptığımız şey aslında çok basit. Sadecesepparametresinin ‘bir adet
boşluk karakteri’ olan öntanımlı değerini silip, yerine ‘boş bir karakter
dizisi’ değerini yazdık. Bu iki kavramın birbirinden farklı olduğunu
söylediğimizi hatırlıyorsunuz, değil mi?

Gelin bir örnek daha yapalım:

```python
>>> print("T", "C", sep=".")

T.C

```

Burada Python’a şöyle bir emir vermiş olduk:

“T”ve“C”karakter dizilerini birbiriyle birleştir! Bunu yaparken de bu
karakter dizilerinin arasına nokta işareti yerleştir!

sepparametresinin öteki parametrelerden farkı her zaman ismiyle birlikte
kullanılmasıdır. Zaten teknik olarak da bu tür parametrelere ‘isimli
parametreler’ adı verilir. Örneğin:

```python
>>> print("Adana", "Mersin", sep="-")

Adana-Mersin

```

Eğer buradasepparametresinin ismini belirtmeden, doğrudan parametrenin
değerini yazarsak, bu değerin öteki parametrelerden hiçbir farkı kalmayacaktır:

```python
>>> print("Adana", "Mersin", "-")

Adana Mersin -

```

Gelin isterseniz bu parametreyle ilgili bir örnek daha yapalım:

‘Bir mumdur iki mumdur…’ diye başlayan türküyü biliyorsunuzdur. Şimdi bu
türküyü Python’la nasıl yazabileceğimizi görelim!

```python
>>> print("bir", "iki", "üç", "dört", "on dört", sep="mumdur")

birmumdurikimumdurüçmumdurdörtmumduron dört

```

Burada bir terslik olduğu açık! Karakter dizileri birbirlerine sıkışık düzende
birleştirildi. Bunların arasında birer boşluk olsa tabii daha iyi olurdu. Ancak
biliyorsunuzsepparametresinin öntanımlı değerini silip, yerine“mumdur”değerini yerleştirdiğimiz için, Python’ın otomatik olarak yerleştirdiği boşluk
karakteri kayboldu. Ama eğer istersek o boşluk karakterlerini kendimiz de
ayarlayabiliriz:

```python
>>> print("bir", "iki", "üç", "dört", "on dört", sep=" mumdur ")

bir mumdur iki mumdur üç mumdur dört mumdur on dört

```

Gördüğünüz gibi,sepparametresine verdiğimiz“mumdur”değerinin sağında ve
solunda birer boşluk bırakarak sorunumuzu çözebildik. Bu sorunu çözmenin başka
bir yolu daha var. Hatırlarsanız etkileşimli kabukta ilk örneklerimizi verirken
karakter dizilerini birleştirmek için+işaretinden de yararlanabileceğimizi
söylemiştik. Dolayısıylasepparametresini şöyle de yazabiliriz:

```python
>>> print("bir", "iki", "üç", "dört", "on dört", sep=" " + "mumdur" + " ")

```

Burada da,“mumdur”adlı karakter dizisinin başında ve sonunda birer boşluk
bırakmak yerine, gerekli boşlukları+işareti yardımıyla bu karakter dizisine
birleştirdik. Hatta istersek+işlecini kullanmak zorunda olmadığımızı dahi
biliyorsunuz:

```python
>>> print("bir", "iki", "üç", "dört", "on dört", sep=" " "mumdur" " ")

```

Ama gördüğünüz gibi bir problemimiz daha var. Türkünün sözleri şu şekilde
olmalıydı:

bir mumdur iki mumdur üç mumdur dört mumdur on dört mumdur

Ama sondaki ‘mumdur’ kelimesi yukarıdaki çıktıda yok. Normal olan da bu aslında.sepparametresi, karakter dizilerininarasınabir değer yerleştirir.
Karakter dizilerinin son tarafıyla ilgilenmez. Bu iş içinprint()fonksiyonu
başka bir parametreye sahiptir.

Bu arada, yukarıdaki örneklerde hep karakter dizilerini kullanmış olmamız sizi
yanıltmasın.sepparametresi yalnızca karakter dizilerinin değil sayıların
arasına da istediğiniz bir değerin yerleştirilmesini sağlayabilir. Mesela:

```python
>>> print(1, 2, 3, 4, 5, sep="-")

1-2-3-4-5

```

Ancaksepparametresine değer olarak yalnızca karakter dizilerini veNoneadlı özel bir sözcüğü verebiliriz. (Nonesözcüğünden ileride söz edeceğiz):

```python
>>> print(1, 2, 3, 4, 5, sep=0)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: sep must be None or a string, not int

```

Gördüğünüz gibi,sepparametresine bir sayı olan0değerini veremiyoruz.

Peki bu parametreyeNonedeğeri verirsek ne olur? Bu parametreyeNonedeğeri
verildiğinde,print()fonksiyonu bu parametre için öntanımlı değeri (yani
bir adet boşluk) kullanır:

```python
>>> print('a', 'b', sep=None)

a b

```

Eğer amacınız parametreleri birbirine bitiştirmekse, yanisepparametresinin
öntanımlı değeri olan boşluk karakterini ortadan kaldırmaksa,sepparametresine boş bir karakter dizisi vermeniz gerektiğini biliyorsunuz:

```python
>>> print('a', 'b', sep='')

ab

```

print()fonksiyonununsepparametresini bütün ayrıntılarıyla
incelediğimize göre, bu fonksiyonun bir başka özel parametresinden söz
edebiliriz.

#### end

Bir önceki bölümde şöyle bir laf etmiştik:

print()fonksiyonunsepadlı özel bir parametresi bulunur. Bu
parametreprint()fonksiyonunda görünmese bile her zaman oradadır.

Aynı bu şekilde,print()fonksiyonununendadlı özel bir parametresi daha
bulunur. Tıpkısepparametresi gibi,endparametresi deprint()fonksiyonunda görünmese bile her zaman oradadır.

Bildiğiniz gibi,sepparametresiprint()fonksiyonuna verilen parametreler
birleştirilirken araya hangi karakterin gireceğini belirliyordu.endparametresi ise bu parametrelerin sonuna neyin geleceğini belirler.

print()fonksiyonu öntanımlı olarak, parametrelerin sonuna ‘satır başı
karakteri’ ekler. Peki bu satır başı karakteri (veya ‘yeni satır karakteri’)
denen şey de ne oluyor?

Dilerseniz bunu bir örnek üzerinde görelim.

Şöyle bir kodumuz olsun:

```python
>>> print("Pardus ve Ubuntu birer GNU/Linux dağıtımıdır.")

```

Bu kodu yazıpEntertuşuna bastığımız andaprint()fonksiyonu iki farklı
işlem gerçekleştirir:
1. Öncelikle karakter dizisini ekrana yazdırır.
1. Ardından bir alt satıra geçip bize>>>işaretini gösterir.

Öncelikle karakter dizisini ekrana yazdırır.

Ardından bir alt satıra geçip bize>>>işaretini gösterir.

İşte bu ikinci işlem, karakter dizisinin sonunda bir adet satır başı karakteri
olmasından, daha doğrusuprint()fonksiyonunun, satır başı karakterini
karakter dizisinin sonuna eklemesinden kaynaklanır. Bu açıklama biraz kafa
karıştırıcı gelmiş olabilir. O halde biraz daha açıklayalım. Şu örneğe bakın:

```python
>>> print("Pardus\nUbuntu")

Pardus
Ubuntu

```

Burada“Pardus”ve“Ubuntu”karakter dizilerinin tam ortasında çok özel bir
karakter dizisi daha görüyorsunuz. Bu karakter dizisi şudur:\n. İşte bu özel
karakter dizisine satır başı karakteri (newline) adı verilir. Bu karakterin
görevi, karakter dizisini, bulunduğu noktadan bölüp, karakter dizisinin geri
kalanını bir alt satıra geçirmektir. Zaten çıktıda da bu işlevi yerine
getirdiğini görüyorsunuz. Karakter dizisi“Pardus”kısmından sonra ikiye
bölünüyor ve bu karakter dizisinin geri kalan kısmı olan“Ubuntu”karakter
dizisi bir alt satıra yazdırılıyor. Bunu daha iyi anlamak için bir örnek daha
verelim:

```python
>>> print("birinci satır\nikinci satır\nüçüncü satır")

birinci satır
ikinci satır
üçüncü satır

```

Peki size bir soru sorayım: Acaba yukarıdaki kodları daha verimli bir şekilde
nasıl yazabiliriz?

Evet, doğru tahmin ettiniz… Tabii kisepparametresini kullanarak:

```python
>>> print("birinci satır", "ikinci satır", "üçüncü satır", sep="\n")

birinci satır
ikinci satır
üçüncü satır

```

Burada yaptığımız şey çok basit.sepparametresinin değerini\n, yani yeni
satır karakteri (veya satır başı karakteri) olarak değiştirdik. Böylece karakter
dizileri arasına birer\nkarakteri yerleştirerek her bir karakter dizisinin
farklı satıra yazdırılmasını sağladık.

İşteendparametresinin öntanımlı değeri de bu\nkarakteridir ve bu
parametreprint()fonksiyonunda görünmese bile her zaman oradadır.

Yani diyelim ki şöyle bir kod yazdık:

```python
>>> print("Bugün günlerden Salı")

```

Burada herhangi birendparametresi görmüyoruz. Ancak Python yukarıdaki kodu
aslında şöyle algılar:

```python
>>> print("Bugün günlerden Salı", end="\n")

```

Biraz önce de dediğimiz gibi, bu kodu yazıpEntertuşuna bastığımız andaprint()fonksiyonu iki farklı işlem gerçekleştirir:
1. Öncelikle karakter dizisini ekrana yazdırır.
1. Ardından bir alt satıra geçip bize>>>işaretini gösterir.

Öncelikle karakter dizisini ekrana yazdırır.

Ardından bir alt satıra geçip bize>>>işaretini gösterir.

Bunun ne demek olduğunu anlamak içinendparametresinin değerini değiştirmemiz
yeterli olacaktır:

```python
>>> print("Bugün günlerden Salı", end=".")

Bugün günlerden Salı.>>>

```

Gördüğünüz gibi,endparametresinin öntanımlı değeri olan\nkarakterini
silip yerine.(nokta) işareti koyduğumuz için, komutu yazıpEntertuşuna
bastığımızdaprint()fonksiyonu satır başına geçmedi. Yeni satıra geçebilmek
içinEntertuşuna kendimiz basmalıyız. Elbette, eğer yukarıdaki kodları şöyle
yazarsanız,print()fonksiyonu hem karakter dizisinin sonuna nokta
ekleyecek, hem de satır başına geçecektir:

```python
>>> print("Bugün günlerden Salı", end=".\n")

Bugün günlerden Salı.

```

Şimdi bu öğrendiklerimizi türkümüze uygulayalım:

```python
>>> print("bir", "iki", "üç", "dört", "on dört",
... sep=" mumdur ", end=" mumdur\n")

```

> **Not**
> Burada kodlarımızın sağa doğru çirkin bir şekilde uzamasını engellemek
için“on dört”karakter dizisini yazıp virgülü koyduktan sonraEntertuşuna
basarak bir alt satıra geçtik. Bir alt satıra geçtiğimizde>>>işaretinin…işaretine dönüştüğüne dikkat edin. Python’da doğru kod yazmak kadar,
yazdığımız kodların düzgün görünmesi de önemlidir. O yüzden yazdığımız her bir
kod satırının mümkün olduğunca 79 karakteri geçmemesini sağlamalıyız. Eğer
yazdığınız bir satır 79 karakteri aşıyorsa, aşan kısmı yukarıda gösterdiğimiz
şekilde alt satıra alabilirsiniz.

Not

Burada kodlarımızın sağa doğru çirkin bir şekilde uzamasını engellemek
için“on dört”karakter dizisini yazıp virgülü koyduktan sonraEntertuşuna
basarak bir alt satıra geçtik. Bir alt satıra geçtiğimizde>>>işaretinin…işaretine dönüştüğüne dikkat edin. Python’da doğru kod yazmak kadar,
yazdığımız kodların düzgün görünmesi de önemlidir. O yüzden yazdığımız her bir
kod satırının mümkün olduğunca 79 karakteri geçmemesini sağlamalıyız. Eğer
yazdığınız bir satır 79 karakteri aşıyorsa, aşan kısmı yukarıda gösterdiğimiz
şekilde alt satıra alabilirsiniz.

endparametresi de, tıpkısepparametresi gibi, her zaman ismiyle birlikte
kullanılması gereken bir parametredir. Yani eğerendparametresinin ismini
belirtmeden sadece değerini kullanmaya çalışırsak Python ne yapmaya
çalıştığımızı anlayamaz.

Yine tıpkısepparametresi gibi,endparametresinin değeri de sadece bir
karakter dizisi veyaNoneolabilir:

```python
>>> print(1, 2, 3, 4, 5, end=0)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: end must be None or a string, not int

```

Gördüğünüz gibi,endparametresine bir sayı olan0değerini veremiyoruz.

Eğer bu parametreyeNonedeğeri verirsek, tıpkısepparametresinde olduğu
gibi,print()fonksiyonu bu parametre için öntanımlı değeri (yani satır başı
karakteri) kullanır:

```python
>>> print('a', 'b', end=None)

a b

```

Eğer amacınız yeni satıra geçilmesini engellemekse, yaniendparametresinin
öntanımlı değeri olan\nkaçış dizisini ortadan kaldırmaksa,endparametresine boş bir karakter dizisi vermelisiniz:

```python
>>> print('a', 'b', end='')

a b>>>

```

#### file

> **Not**
> Burada henüz öğrenmediğimiz bazı şeyler göreceksiniz. Hiç endişe
etmeyin. Bunları ilerde bütün ayrıntılarıyla öğreneceğiz. Şimdilik konu hakkında
biraz olsun fikir sahibi olmanızı sağlayabilirsek kendimizi başarılı sayacağız.

Not

Burada henüz öğrenmediğimiz bazı şeyler göreceksiniz. Hiç endişe
etmeyin. Bunları ilerde bütün ayrıntılarıyla öğreneceğiz. Şimdilik konu hakkında
biraz olsun fikir sahibi olmanızı sağlayabilirsek kendimizi başarılı sayacağız.

print()fonksiyonununsepveenddışında üçüncü bir özel parametresi
daha bulunur. Bu parametrenin adıfile’dır. Görevi ise,print()fonksiyonuna verilen karakter dizisi ve/veya sayıların, yani parametrelerin
nereye yazılacağını belirtmektir.

Bu parametrenin öntanımlı değerisys.stdout’tur. Peki bu ne anlama geliyor?sys.stdout, ‘standart çıktı konumu’ anlamına gelir. Peki ‘standart çıktı
konumu’ ne demek?

Standart çıktı konumu; bir programın, ürettiği çıktıları verdiği yerdir. Aslında
bu kavramın ne demek olduğu adından da anlaşılıyor:

standart çıktı konumu = çıktıların standart olarak verildiği konum.

Mesela Python öntanımlı olarak, ürettiği çıktıları ekrana verir. Eğer o anda
etkileşimli kabukta çalışıyorsanız, Python ürettiği çıktıları etkileşimli kabuk
üzerinde gösterir. Eğer yazdığınız bir programı komut satırında
çalıştırıyorsanız, üretilen çıktılar komut satırında görünür. Dolayısıyla
Python’ın standart çıktı konumu etkileşimli kabuk veya komut satırıdır. Yaniprint()fonksiyonu yardımıyla bastığınız çıktılar etkileşimli kabukta ya da
komut satırında görünecektir.

Şimdi bu konuyu daha iyi anlayabilmek için birkaç örnek yapalım.

Normal şartlar altındaprint()fonksiyonunun çıktısını etkileşimli kabukta
görürüz:

```python
>>> print("Ben Python, Monty Python!")

Ben Python, Monty Python!

```

Ama eğer istersekprint()fonksiyonunun, çıktılarını ekrana değil, bir
dosyaya yazdırmasını da sağlayabiliriz. Mesela biz şimdiprint()fonksiyonunundeneme.txtadlı bir dosyaya çıktı vermesini sağlayalım.

Bunun için sırasıyla şu kodları yazalım:

```python
>>> dosya = open("deneme.txt", "w")
>>> print("Ben Python, Monty Python!", file=dosya)
>>> dosya.close()

```

Herhangi bir çıktı almadınız, değil mi? Evet. Çünkü yazdığımız bu kodlar
sayesindeprint()fonksiyonu, çıktılarınıdeneme.txtadlı bir dosyaya
yazdırdı.

Gelin isterseniz yukarıdaki kodları satır satır inceleyelim:

1. Öncelikledeneme.txtadlı bir dosya oluşturduk ve bu dosyayıdosyaadlı
bir değişkene atadık. Burada kullandığımızopen()fonksiyonuna çok
takılmayın. Bunu birkaç bölüm sonra inceleyeceğiz. Biz şimdilik bu şekilde dosya
oluşturulduğunu bilelim yeter. Bu aradaopenfonksiyonunun da biçim olaraktype(),len(),pow()veprint()fonksiyonlarına ne kadar
benzediğine dikkat edin. Gördüğünüz gibiopen()fonksiyonu da tıpkıtype(),len(),pow()veprint()fonksiyonları gibi birtakım
parametreler alıyor. Bu fonksiyonun ilk parametresi“deneme.txt”adlı bir
karakter dizisi. İşte bu karakter dizisi bizim oluşturmak istediğimiz dosyanın
adını gösteriyor. İkinci parametre ise“w”adlı başka bir karakter dizisi. Bu
dadeneme.txtdosyasının yazma kipinde (modunda) açılacağını gösteriyor. Ama
dediğim gibi, siz şimdilik bu ayrıntılara fazla takılmayın. İlerleyen derslerde,
bu konuları adınızı bilir gibi bileceğinizden emin olabilirsiniz.

2. Oluşturduğumuz budeneme.txtadlı dosya, o anda bulunduğunuz dizin içinde
oluşacaktır. Bu dizinin hangisi olduğunu öğrenmek için şu komutları
verebilirsiniz:

```python
>>> import os
>>> os.getcwd()

```

Bu komutun çıktısında hangi dizinin adı görünüyorsa,deneme.txtdosyası da o
dizinin içindedir. Mesela bendeki çıktı/home/yazbel/Desktop. Demek ki
oluşturduğumdeneme.txtadlı dosya masaüstündeymiş. Ben bu komutları Ubuntu
üzerinde verdim. Eğer Windows üzerinde verseydim şuna benzer bir çıktı
alacaktım:C:\Users\yazbel\Desktop

3. Ardından da normal bir şekildeprint()fonksiyonumuzu çalıştırdık. Ama
gördüğünüz gibiprint()fonksiyonu bize herhangi bir çıktı vermedi. Çünkü,
daha önce de söylediğimiz gibi,print()fonksiyonunu biz ekrana değil,
dosyaya çıktı verecek şekilde ayarladık. Bu işlemi,fileadlı bir parametreye,
biraz önce tanımladığımızdosyadeğişkenini yazarak yaptık.

4. Son komut yardımıyla da, yaptığımız değişikliklerin dosyada görünebilmesi
için ilk başta açtığımız dosyayı kapatıyoruz.

Şimdideneme.txtadlı dosyayı açın. Biraz önceprint()fonksiyonuyla
yazdırdığımız“Ben Python, Monty Python!”karakter dizisinin dosyaya işlenmiş
olduğunu göreceksiniz.

Böyleceprint()fonksiyonunun standart çıktı konumunu değiştirmiş olduk.
Yaniprint()fonksiyonununfileadlı parametresine farklı bir değer
vererek,print()fonksiyonunun etkileşimli kabuğa değil dosyaya yazmasını
sağladık.

Tıpkısepveendparametreleri gibi,fileparametresi de, siz görmeseniz
bile her zamanprint()fonksiyonunun içinde vardır. Yani diyelim ki şöyle
bir komut verdik:

```python
>>> print("Tahir olmak da ayıp değil", "Zühre olmak da")

```

Python bu komutu şöyle algılar:

```python
>>> print("Tahir olmak da ayıp değil", "Zühre olmak da",
... sep=" ", end="\n", file=sys.stdout)

```

Yani kendisine parametre olarak verilen değerleri ekrana yazdırırken sırasıyla
şu işlemleri gerçekleştirir:
1. Parametrelerin arasına birer boşluk koyar (sep=""),
1. Ekrana yazdırma işlemi bittikten sonra parametrelerin sonuna satır başı
karakteri ekler (end="\n")
1. Bu çıktıyı standart çıktı konumuna gönderir (file=sys.stdout).

Parametrelerin arasına birer boşluk koyar (sep=""),

Ekrana yazdırma işlemi bittikten sonra parametrelerin sonuna satır başı
karakteri ekler (end="\n")

Bu çıktıyı standart çıktı konumuna gönderir (file=sys.stdout).

İşte biz buradafileparametresinin değeri olan standart çıktı konumuna başka
bir değer vererek bu konumu değiştiriyoruz.

Gelin isterseniz bununla ilgili bir örnek daha yapalım. Mesela kişisel
bilgilerimizi bir dosyaya kaydedelim. Öncelikle bilgileri kaydedeceğimiz dosyayı
oluşturalım:

```python
>>> f = open("kişisel_bilgiler.txt", "w")

```

Bu kodlarla,kişisel_bilgiler.txtadını taşıyan bir dosyayı yazma kipinde
(w) açmış ve bu dosyayıfadlı bir değişkene atamış olduk. Şimdi bilgileri
yazmaya başlayabiliriz:

```python
>>> print("Fırat Özgül", file=f)
>>> print("Adana", file=f)
>>> print("Ubuntu", file=f)

```

İşimiz bittiğinde dosyayı kapatmayı unutmuyoruz. Böylece bütün bilgiler dosyaya
yazılmış oluyor:

```python
>>> f.close()

```

Oluşturduğumuzkişisel_bilgiler.txtadlı dosyayı açtığımızda,print()fonksiyonuna verdiğimiz parametrelerin dosyaya yazdırıldığını görüyoruz.

En başta da söylediğim gibi, bu bölümde henüz öğrenmediğimiz bazı şeylerle
karşılaştık. Eğer yukarıda verilen örnekleri anlamakta zorlandıysanız hiç endişe
etmenize gerek yok. Birkaç bölüm sonra burada anlattığımız şeyler size çocuk
oyuncağı gibi gelecek…

#### flush

Şimdiye kadarprint()fonksiyonununsep,endvefileadlı özel
birtakım parametreleri olduğunu öğrendik.print()fonksiyonunun bunların
dışında başka bir özel parametresi daha bulunur. Bu parametrenin adıflush.
İşte şimdi bizprint()fonksiyonunun buflushadlı parametresinden söz
edeceğiz.

Bildiğiniz gibi,print()gibi bir komut verdiğimizde Python, yazdırmak
istediğimiz bilgiyi standart çıktı konumuna gönderir. Ancak Python’da bazı
işlemler standart çıktı konumuna gönderilmeden önce bir süre tamponda bekletilir
ve daha sonra bekleyen bu işlemler topluca standart çıktı konumuna gönderilir.
Peki ilk başta çok karmaşıkmış gibi görünen bu ifade ne anlama geliyor?

Aslında siz bu olguya hiç yabancı değilsiniz.fileparametresini anlatırken
verdiğimiz şu örneği tekrar ele alalım:

```python
>>> f = open("kişisel_bilgiler.txt", "w")

```

Bu komutlakişisel_bilgiler.txtadlı bir dosyayı yazma kipinde açtık. Şimdi bu
dosyaya bazı bilgiler ekleyelim:

```python
>>> print("Fırat Özgül", file=f)

```

Bu komutlakişisel_bilgiler.txtadlı dosyaya ‘Fırat Özgül’ diye bir satır
eklemiş olduk.

Şimdi bilgisayarınızda oluşan bukişisel_bilgiler.txtdosyasını açın.
Gördüğünüz gibi dosyada hiçbir bilgi yok. Dosya şu anda boş görünüyor. Halbuki
biz biraz önce bu dosyaya ‘Fırat Özgül’ diye bir satır eklemiştik, değil mi?

Python bizim bu dosyaya eklemek istediğimiz satırı tampona kaydetti. Dosyaya
yazma işlemleri sona erdiğinde ise Python, tamponda bekleyen bütün bilgileri
standart çıktı konumuna (yani bizim durumumuzdafadlı değişkenin tuttuğukişisel_bilgiler.txtadlı dosyaya) boşaltacak.

Dosyaya başka bilgiler de yazalım:

```python
>>> print("Adana", file=f)
>>> print("Ubuntu", file=f)

```

Dosyaya yazacağımız şeyler bu kadar. Artık yazma işleminin sona erdiğini
Python’a bildirmek için şu komutu veriyoruz:

```python
>>> f.close()

```

Böylece dosyamızı kapatmış olduk. Şimdikişisel_bilgiler.txtadlı dosyaya çift
tıklayarak dosyayı tekrar açın. Orada ‘Fırat Özgül’, ‘Adana’ ve ‘Ubuntu’
satırlarını göreceksiniz.

Gördüğünüz gibi, gerçekten de Python dosyaya yazdırmak istediğimiz bütün
verileri önce tamponda bekletti, daha sonra dosya kapatılınca tamponda bekleyen
bütün verileri dosyaya boşalttı. İşteflushparametresi ile, bahsettiğimiz bu
boşaltma işlemini kontrol edebilirsiniz. Şimdi dikkatlice inceleyin:

```python
>>> f = open("kişisel_bilgiler.txt", "w")

```

Dosyamızı oluşturduk. Şimdi bu dosyaya bazı bilgiler ekleyelim:

```python
>>> print("Merhaba Dünya!", file=f, flush=True)

```

Gördüğünüz gibi, buradaflushadlı yeni bir parametre kullandık. Bu
parametreye verdiğimiz değerTrue. Şimdi dosyaya çift tıklayarak dosyayı açın.
Gördüğünüz gibi, henüz dosyayı kapatmadığımız halde bilgiler dosyaya yazıldı. Bu
durum, tahmin edebileceğiniz gibi,flushparametresineTruedeğeri vermemiz
sayesindedir. Bu parametre iki değer alabilir:TrueveFalse. Bu
parametrenin öntanımlı değeriFalse’tur. Yani eğer biz bu parametreye herhangi
bir değer belirtmezsek Python bu parametrenin değeriniFalseolarak kabul
edecek ve bilgilerin dosyaya yazılması için dosyanın kapatılmasını
bekleyecektir. Ancak bu parametreyeTruedeğerini verdiğimizde ise veriler
tamponda bekletilmeksizin standart çıktı konumuna gönderilecektir.

Yazdığınız bir programda, yapmak istediğiniz işin niteliğine göre, bir dosyaya
yazmak istediğiniz bilgilerin bir süre tamponda bekletilmesini veya hiç
bekletilmeden doğrudan dosyaya yazılmasını isteyebilirsiniz. İhtiyacınıza bağlı
olarak daflushparametresinin değeriniTrueveyaFalseolarak
belirleyebilirsiniz.

### Birkaç Pratik Bilgi

Buraya gelene kadarprint()fonksiyonu ve bu fonksiyonun parametreleri
hakkında epey söz söyledik. Dilerseniz şimdi de, programcılık maceranızda
işinize yarayacak, işlerinizi kolaylaştıracak bazı ipuçları verelim.

#### Yıldızlı Parametreler

Şimdi size şöyle bir soru sormama izin verin: Acaba aşağıdaki gibi bir çıktıyı
nasıl elde ederiz?

```python
L.i.n.u.x

```

Aklınıza hemen şöyle bir cevap gelmiş olabilir:

```python
>>> print("L", "i", "n", "u", "x", sep=".")

L.i.n.u.x

```

Yukarıdaki, gerçekten de doğru bir çözümdür. Ancak bu soruyu çözmenin çok daha
basit bir yolu var. Şimdi dikkatle bakın:

```python
>>> print(*"Linux", sep=".")

L.i.n.u.x

```

Konuyu açıklamaya geçmeden önce bir örnek daha verelim:

```python
>>> print(*"Galatasaray")

G a l a t a s a r a y

```

Burada neler döndüğünü az çok tahmin ettiğinizi zannediyorum. Son örnekte de
gördüğünüz gibi,“Galatasaray”karakter dizisinin başına eklediğimiz yıldız
işareti;“Galatasaray”karakter dizisinin her bir öğesini parçalarına
ayırarak, bunları tek tekprint()fonksiyonuna yolluyor. Yani sankiprint()fonksiyonunu şöyle yazmışız gibi oluyor:

```python
>>> print("G", "a", "l", "a", "t", "a", "s", "a", "r", "a", "y")

G a l a t a s a r a y

```

Dediğimiz gibi, bir fonksiyona parametre olarak verdiğimiz bir karakter
dizisinin başına eklediğimiz yıldız işareti, bu karakter dizisini tek tek
öğelerine ayırıp, bu öğeleri yine tek tek ve sanki her bir öğe ayrı bir
parametreymiş gibi o fonksiyona gönderdiği için doğal olarak yıldız işaretini
ancak, birden fazla parametre alabilen fonksiyonlara uygulayabiliriz.

Örneğinlen()fonksiyonu sadece tek bir parametre alabilir:

```python
>>> len("Galatasaray")

11

```

Bu fonksiyonu birden fazla parametre ile kullanamayız:

```python
>>> len("Galatasaray", "Fenerbahçe", "Beşiktaş")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: len() takes exactly one argument (3 given)

```

Hata mesajında da söylendiği gibi,len()fonksiyonu yalnızca tek bir
parametre alabilirken, biz3parametre vermeye çalışmışız…

Dolayısıyla yıldızlı parametrelerilen()fonksiyonuna uygulayamayız:

```python
>>> len(*"Galatasaray")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: len() takes exactly one argument (11 given)

```

Bir parametrenin başına yıldız eklediğimizde, o parametreyi oluşturan bütün
öğeler tek tek fonksiyona gönderildiği için, sankilen()fonksiyonuna1değil de,11ayrı parametre vermişiz gibi bir sonuç ortaya çıkıyor.

Yıldızlı parametreleri bir fonksiyona uygulayabilmemiz için o fonksiyonun birden
fazla parametre alabilmesinin yanısıra, yapısının da yıldızlı parametre almaya
uygun olması gerekir. Meselaopen(),type()ve biraz önce bahsettiğimizlen()fonksiyonlarının yapısı yıldızlı parametre almaya uygun değildir.
Dolayısıyla yıldızlı parametreleri her fonksiyonla birlikte kullanamayız, amaprint()fonksiyonu yıldızlı parametreler için son derece uygun bir
fonksiyondur:

```python
>>> print(*"Galatasaray")

G a l a t a s a r a y

>>> print(*"TBMM", sep=".")

T.B.M.M

>>> print(*"abcçdefgğh", sep="/")

a/b/c/ç/d/e/f/g/ğ/h

```

Bu örneklerden de gördüğünüz gibi,print()fonksiyonuna verdiğimiz bir
parametrenin başına yıldız eklediğimizde, o parametre tek tek parçalarına
ayrılıpprint()fonksiyonuna gönderildiği için, sonuç olaraksepparametresinin karakter dizisi öğelerine tek tek uygulanmasını sağlamış
oluyoruz.

Hatırlarsanızsepparametresinin öntanımlı değerinin bir adet boşluk karakteri
olduğunu söylemiştik. Yani aslında Python yukarıdaki ilk komutu şöyle görüyor:

```python
>>> print(*"Galatasaray", sep=" ")

```

Dolayısıyla, yıldız işareti sayesinde“Galatasaray”adlı karakter dizisinin
her bir öğesinin arasına bir adet boşluk karakteri yerleştiriliyor. Bir sonraki“TBMM”karakter dizisinde ise,sepparametresinin değerini nokta işareti
olarak değiştirdiğimiz için“TBMM”karakter dizisinin her bir öğesinin arasına
bir adet nokta işareti yerleştiriliyor. Aynı şekilde“abcçdefgğh”karakter
dizisinin her bir öğesini tek tekprint()fonksiyonuna yollayarak,sepparametresine verdiğimiz/işareti yardımıyla her öğenin arasına bu/işaretini yerleştirebiliyoruz.

Yıldızlı parametrelerle ilgili tek kısıtlama, bunların sayılarla birlikte
kullanılamayacak olmasıdır:

```python
>>> print(*2345)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: print() argument after * must be a sequence, not int

```

Çünkü yıldızlı parametreler ancak ve ancak dizi özelliği taşıyan veri tipleriyle
birlikte kullanılabilir. Mesela karakter dizileri bu türden bir veri tipidir.
İlerde dizi özelliği taşıyan ve bu sayede yıldızlı parametrelerle birlikte
kullanılabilecek başka veri tiplerini de öğreneceğiz.

Yukarıda verdiğimiz örnekler bize yıldızlı parametrelerin son derece kullanışlı
araçlar olduğunu gösteriyor. İleride de bu parametrelerden bol bol
yararlanacağız. Biz şimdi bu konuyu burada kapatıp başka bir şeyden söz edelim.

#### sys.stdout’u Kalıcı Olarak Değiştirmek

Önceki başlıklar altında verdiğimiz örneklerden de gördüğünüz gibi,print()fonksiyonununfileparametresi yardımıyla Python’ın standart çıktı konumunu
geçici olarak değiştirebiliyoruz. Ama bazı durumlarda, yazdığınız programlarda,
o programın işleyişi boyunca standart dışı bir çıktı konumu belirlemek
isteyebilirsiniz. Yani standart çıktı konumunu geçici olarak değil, kalıcı
olarak değiştirmeniz gerekebilir. Mesela yazdığınız programda bütün çıktıları
bir dosyaya yazdırmayı tercih edebilirsiniz. Elbette bu işlemi her defasındafileparametresini, çıktıları yazdırmak istediğiniz dosyanın adı olarak
belirleyerek yapabilirsiniz. Tıpkı şu örnekte olduğu gibi:

```python
>>> f = open("dosya.txt", "w")
>>> print("Fırat Özgül", file=f)
>>> print("Adana", file=f)
>>> print("Ubuntu", file=f)
>>> f.close()

```

Gördüğünüz gibi, her defasındafileparametresinefdeğerini vererek işimizi
hallettik. Ama bunu yapmanın daha pratik bir yöntemi var. Dilerseniz yazdığınız
programın tüm işleyişi boyunca çıktıları başka bir konuma yönlendirebilirsiniz.
Bunun için hem şimdiye kadar öğrendiğimiz, hem de henüz öğrenmediğimiz bazı
bilgileri kullanacağız.

İlk önce şöyle bir kod yazalım:

```python
>>> import sys

```

Bu kod yardımıylasysadlı özel bir ‘modülü’ programımıza dahil etmiş, yani
içe aktarmış olduk. Peki ‘modül’ nedir, ‘içe aktarmak’ ne demek?

Aslında biz bu ‘modül’ ve ‘içe aktarma’ kavramlarına hiç de yabancı değiliz.
Önceki derslerde, pek üzerinde durmamış da olsak, biz Python’daki birkaç modülle
zaten tanışmıştık. Meselaosadlı bir modül içindekigetcwd()adlı bir
fonksiyonu kullanarak, o anda hangi dizinde bulunduğumuzu öğrenebilmiştik:

```python
>>> import os
>>> os.getcwd()

```

Aynı şekildekeywordadlı başka bir modül içindekikwlistadlı değişkeni
kullanarak, hangi kelimelerin Python’da değişken adı olarak kullanılamayacağını
da listeleyebilmiştik:

```python
>>> import keyword
>>> keyword.kwlist

```

İşte şimdi de,osvekeywordmodüllerine ek olaraksysadlı bir modülden
söz ediyoruz. Gelin isterseniz öteki modülleri şimdilik bir kenara bırakıp, busysdenen modüle dikkatimizi verelim.

Dediğimiz gibi,sysmodülü içinde pek çok önemli değişken ve fonksiyon
bulunur. Ancak bir modül içindeki değişken ve fonksiyonları kullanabilmek için o
modülü öncelikle programımıza dahil etmemiz, yani içe aktarmamız gerekiyor. Bunuimportkomutuyla yapıyoruz:

```python
>>> import sys

```

Artıksysmodülü içindeki bütün fonksiyon ve değişkenlere ulaşabileceğiz.

sysmodülü içinde bulunan pek çok değişken ve fonksiyondan biri destdoutadlı değişkendir. Bu değişkenin değerine şöyle ulaşabilirsiniz:

```python
>>> sys.stdout

```

Bu komut şuna benzer bir çıktı verir:

```python
<_io.TextIOWrapper name='<stdout>' mode='w' encoding='cp1254'>

```

Bu çıktıdakiname=’<stdout>’kısmına dikkat edin. Bu ifadeye birazdan geri
döneceğiz. Biz şimdi başka bir şeyden söz edelim.

Hatırlarsanız etkileşimli kabuğu nasıl kapatabileceğimizi anlatırken,
etkileşimli kabuktan çıkmanın bir yolunun da şu komutları vermek olduğunu
söylemiştik:

```python
>>> import sys; sys.exit()

```

Bu komutu tek satırda yazmıştık, ama istersek şöyle de yazabiliriz elbette:

```python
>>> import sys
>>> sys.exit()

```

Dedik ya,sysmodülü içinde pek çok değişken ve fonksiyon bulunur. Nasılstdoutsysmodülü içindeki değişkenlerden biri ise,exit()desysmodülü içinde bulunan fonksiyonlardan biridir.

Biz ‘modüller’ konusunu ilerleyen derslerde ayrıntılı bir şekilde inceleyeceğiz.
Şimdilik modüllere ilişkin olarak yalnızca şunları bilelim yeter:

1. Python’da modüllerimportkomutu ile içe aktarılır. Örneğinsysadlı modülü içe aktarmak içinimportsyskomutunu veriyoruz.

2. Modüller içinde pek çok faydalı değişken ve fonksiyon bulunur. İşte bir
modülü içe aktardığımızda, o modül içindeki bu değişken ve fonksiyonları
kullanma imkanı elde ederiz.

3.sysmodülü içindeki değişkenlere bir örnekstdout; fonksiyonlara
örnek iseexit()fonksiyonudur. Bir modül içindeki bu değişken ve
fonksiyonlara ‘modül_adı.değişken_ya_da_fonksiyon’ formülünü kullanarak
erişebiliriz. Örneğin:

```python
>>> sys.stdout
>>> sys.exit()

```

4. Hatırlarsanız bundan önce de,open()fonksiyonu ile dosya oluşturmayı
anlatırken, oluşturulan dosyanın hangi dizinde olduğunu bulabilmek amacıyla, o
anda içinde bulunduğumuz dizini tespit edebilmek için şu kodları kullanmıştık:

```python
>>> import os
>>> os.getcwd()

```

Burada daosadlı başka bir modül görüyoruz. İşteosda tıpkısysgibi
bir modüldür ve tıpkısysmodülünde olduğu gibi,osmodülünün de içinde
pek çok yararlı değişken ve fonksiyon bulunur.getcwd()adlı fonksiyon
daosmodülü içinde yer alan ve o anda hangi dizin altında bulunduğumuzu
gösteren bir fonksiyondur. Elbette, yine tıpkısysmodülünde olduğu gibi,osmodülü içindeki bu yararlı değişken ve fonksiyonları kullanabilmek için
de öncelikle buosmodülünü içe aktarmamız, yani programımıza dahil
etmemiz gerekiyor.osmodülünüimportkomutu aracılığıyla uygun bir
şekilde içe aktardıktan sonra, modül içinde yer alangetcwd()adlı
fonksiyona yine ‘modül_adı.fonksiyon’ formülünü kullanarak erişebiliyoruz.

Modüllere ilişkin şimdilik bu kadar bilgi yeter. Modülleri bir kenara bırakıp
yolumuza devam edelim…

Eğersys.exit()komutunu verip etkileşimli kabuktan çıktıysanız, etkileşimli
kabuğa tekrar girin vesysmodülünü yeniden içe aktarın:

```python
>>> import sys

```

> **Not**
> Bir modülü aynı etkileşimli kabuk oturumu içinde bir kez içe aktarmak
yeterlidir. Bir modülü bir kez içe aktardıktan sonra, o oturum süresince bu
modül içindeki değişken ve fonksiyonları kullanmaya devam edebilirsiniz. Ama
tabii ki etkileşimli kabuğu kapatıp tekrar açtıktan sonra, bir modülü
kullanabilmek için o modülü tekrar içe aktarmanız gerekir.

Not

Bir modülü aynı etkileşimli kabuk oturumu içinde bir kez içe aktarmak
yeterlidir. Bir modülü bir kez içe aktardıktan sonra, o oturum süresince bu
modül içindeki değişken ve fonksiyonları kullanmaya devam edebilirsiniz. Ama
tabii ki etkileşimli kabuğu kapatıp tekrar açtıktan sonra, bir modülü
kullanabilmek için o modülü tekrar içe aktarmanız gerekir.

Şimdi şu kodu yazın:

```python
>>> f = open("dosya.txt", "w")

```

Bu kodun anlamını biliyorsunuz. Buradadosya.txtadlı bir dosyayı yazma
kipinde açmış olduk. Tahmin edebileceğiniz gibi, çıktılarımızı ekran yerine bu
dosyaya yönlendireceğiz.

Şimdi de şöyle bir kod yazalım:

```python
>>> sys.stdout = f

```

Bildiğiniz gibi,sys.stdoutdeğeri Python’ın çıktıları hangi konuma vereceğini
belirliyor. İşte biz buradasys.stdout’un değerini biraz önce oluşturduğumuzfadlı dosya ile değiştiriyoruz. Böylece Python bütün çıktılarıfdeğişkeni
içinde belirttiğimizdosya.txtadlı dosyaya gönderiyor.

Bu andan sonra yazacağınız her şeydosya.txtadlı dosyaya gidecektir:

```python
>>> print("deneme metni", flush=True)

```

Gördüğünüz gibi, buradafileparametresini kullanmadığımız halde çıktılarımız
ekrana değil,dosya.txtadlı bir dosyaya yazdırıldı. Peki ama bu nasıl oldu?
Aslında bunun cevabı çok basit: Biraz öncesys.stdout=fkomutuylasys.stdout’un değerinifdeğişkeninin tuttuğu dosya ile değiştirdik. Bu
işlemi yapmadan öncesys.stdout’un değeri şuydu hatırlarsanız:

```python
<_io.TextIOWrapper name='<stdout>' mode='w' encoding='cp1254'>

```

Amasys.stdout=fkomutundan sonra her şey değişti. Kontrol edelim:

```python
>>> print(sys.stdout, flush=True)

```

Elbette bu komuttan herhangi bir çıktı almadınız. Çıktının ne olduğunu görmek
içindosya.txtadlı dosyayı açın. Orada şu satırı göreceksiniz:

```python
<_io.TextIOWrapper name='dosya.txt' mode='w' encoding='cp1254'>

```

Gördüğünüz gibi, özgünstdoutçıktısındakiname=’<stdout>’değeriname=’dosya.txt’olmuş. Dolayısıyla artık bütün çıktılardosya.txtadlı
dosyaya gidiyor…

Bu arada, yukarıdaki çıktıda görünenname,modeveencodingdeğerlerine şu
şekilde ulaşabilirsiniz:

```python
>>> sys.stdout.name
>>> sys.stdout.mode
>>> sys.stdout.encoding

```

Buradasys.stdout.namekomutu standart çıktı konumunun o anki adını
verecektir.sys.stdout.modekomutu ise standart çıktı konumunun hangi kipe
sahip olduğunu gösterir. Standart çıktı konumu genellikle yazma kipinde (w)
bulunur.sys.stdout.encodingkodu ise standart çıktı konumunun sahip olduğu
kodlama biçimini gösterir. Kodlama biçimi, standart çıktı konumuna
yazdıracağınız karakterlerin hangi kodlama biçimi ile kodlanacağını belirler.
Kodlama biçimi Windows’ta genellikle ‘cp1254’, GNU/Linux’ta ise ‘utf-8’dir. Eğer
bu kodlama biçimi yanlış olursa, mesela dosyaya yazdıracağınız karakterler
içindeki Türkçe harfler düzgün görüntülenemez. Eğer burada söylediklerimiz size
şu anda anlaşılmaz geliyorsa, söylediklerimizi dikkate almadan yolunuza devam
edebilirsiniz. Birkaç bölüm sonra bu söylediklerimiz size daha fazla şey ifade
etmeye başlayacak nasıl olsa.

Peki standart çıktı konumunu eski haline döndürmek isterseniz ne yapacaksınız?
Bunun için etkileşimli kabuktan çıkıp tekrar girebilirsiniz. Etkileşimli kabuğu
tekrar açtığınızda her şeyin eski haline döndüğünü göreceksiniz. Aynı şekilde,
eğer bu kodları bir program dosyasına yazmış olsaydınız, programınız
kapandığında her şey eski haline dönecekti.

Peki standart çıktı konumunu, etkileşimli kabuktan çıkmadan veya programı
kapatmadan eski haline döndürmenin bir yolu var mı? Elbette var. Dikkatlice
bakın:

```python
>>> import sys
>>> f = open("dosya.txt", "w")
>>> sys.stdout, f = f, sys.stdout
>>> print("deneme", flush=True)
>>> f, sys.stdout = sys.stdout, f
>>> print("deneme")

deneme

```

> **Uyarı**
> Eğer yukarıdaki kodları çalıştıramıyorsanız, aynı etkileşimli kabuk
oturumunda önceden verdiğiniz kodlar bu kodların doğru çıktı vermesini
engelliyor olabilir. Bu sorunu aşmak için, etkileşimli kabuğu kapatıp tekrar
açın ve yukarıdaki komutları tekrar verin.

Uyarı

Eğer yukarıdaki kodları çalıştıramıyorsanız, aynı etkileşimli kabuk
oturumunda önceden verdiğiniz kodlar bu kodların doğru çıktı vermesini
engelliyor olabilir. Bu sorunu aşmak için, etkileşimli kabuğu kapatıp tekrar
açın ve yukarıdaki komutları tekrar verin.

Aslında burada anlayamayacağınız hiçbir şey yok. Burada yaptığımız şeyi geçen
bölümlerde değişkenlerin değerini nasıl takas edeceğimizi anlatırken de
yapmıştık. Hatırlayalım:

```python
>>> osman = "Araştırma Geliştirme Müdürü"
>>> mehmet = "Proje Sorumlusu"
>>> osman, mehmet = mehmet, osman

```

Bu kodlarla Osman ve Mehmet’in unvanlarını birbiriyle takas etmiştik. İşte
yukarıda yaptığımız şey de bununla aynıdır.sys.stdout,f=f,sys.stdoutdediğimizdefdeğerinisys.stdout’a,sys.stdout’un değerini isef’ye
vermiş oluyoruz.f,sys.stdout=sys.stdout,fdediğimizde ise, bu işlemin
tam tersini yaparak her şeyi eski haline getirmiş oluyoruz.

Python’ın bize sunduğu bu kolaylıktan faydalanarak değişkenlerin değerini
birbiriyle kolayca takas edebiliyoruz. Eğer böyle bir kolaylık olmasaydı
yukarıdaki kodları şöyle yazabilirdik:

```python
>>> import sys
>>> f = open("dosya.txt", "w")
>>> özgün_stdout = sys.stdout
>>> sys.stdout = f
>>> print("deneme", flush=True)
>>> sys.stdout = özgün_stdout
>>> print("deneme")

deneme

```

Gördüğünüz gibi,sys.stdout’un değerini kaybetmemek için,sys.stdoutdeğerinifadlı dosyaya göndermeden önce şu kod yardımıyla yedekliyoruz:

```python
>>> özgün_stdout = sys.stdout

```

sys.stdout’un özgün değeriniözgün_stdoutdeğişkenine atadığımız için, bu
değere sonradan tekrar ulaşabileceğiz. Zaten yukarıdaki kodlardan da gördüğünüz
gibi,sys.stdout’un özgün değerine dönmek istediğimizde şu kodu yazarak
isteğimizi gerçekleştirebiliyoruz:

```python
>>> sys.stdout = özgün_stdout

```

Böylecestdoutdeğeri eski haline dönmüş oluyor ve bundan sonra yazdırdığımız
her şey yeniden ekrana basılmaya başlıyor.

…ve böylece uzun bir bölümü daha geride bıraktık. Bu bölümde hemprint()fonksiyonunu bütün ayrıntılarıyla incelemiş olduk, hem de Python programlama
diline dair başka çok önemli kavramlardan söz ettik. Bu bakımdan bu bölüm bize
epey şey öğretti. Artık öğrendiğimiz bu bilgileri de küfemize koyarak başımız
dik bir şekilde yola devam edebiliriz.

## Kaçış Dizileri

Python’da karakter dizilerini tanımlayabilmek için tek, çift veya üç tırnak
işaretlerinden faydalandığımızı geçen bölümde öğrenmiştik. Python bir verinin
karakter dizisi olup olmadığına bu tırnak işaretlerine bakarak karar verdiği
için, tek, çift ve üç tırnak işaretleri Python açısından özel bir önem taşıyor.
Zira Python’ın gözünde bir başlangıç tırnağı ile bitiş tırnağı arasında yer alan
her şey bir karakter dizisidir.

Örneğin ilk olarak bir“işareti koyup ardından“elmaşeklinde devam
ettiğinizde, Python ilk tırnağı gördükten sonra karakter dizisini
tanımlayabilmek için ikinci bir tırnak işareti aramaya başlar. Siz“elma”şeklinde kodunuzu tamamladığınızda ise Python bellekte“elma”adlı bir
karakter dizisi oluşturur.

Bu noktada size şöyle bir soru sormama izin verin: Acaba tırnak işaretleri
herhangi bir metin içinde kaç farklı amaçla kullanılabilir?

İsterseniz bu sorunun cevabını örnekler üzerinde vermeye çalışalım:

Ahmet, “Bugün sinemaya gidiyorum,” dedi.

Burada tırnak işaretlerini, bir başkasının sözlerini aktarmak için kullandık.

‘book’ kelimesi Türkçede ‘kitap’ anlamına gelir.

Burada ise tırnak işaretlerini bazı kelimeleri vurgulamak için kullandık.

Bir de şuna bakalım:

Yarın Adana’ya gidiyorum.

Burada da tırnak işaretini, çekim eki olan ‘-(y)a’ ile özel isim olan ‘Adana’
kelimesini birbirinden ayırmak için kesme işareti görevinde kullandık.

Şimdi yukarıda verdiğimiz ilk cümleyi bir karakter dizisi olarak tanımlamaya
çalışalım:

```python
>>> 'Ahmet, "Bugün sinemaya gidiyorum," dedi.'

```

Burada karakter dizisini tanımlamaya tek tırnak işareti ile başladık. Böylece
Python bu karakter dizisini tanımlama işlemini bitirebilmek için ikinci bir tek
tırnak işareti daha aramaya koyuldu ve aradığı tek tırnak işaretini cümlenin
sonunda bularak, karakter dizisini düzgün bir şekilde oluşturabildi.

Dediğimiz gibi, Python’ın gözünde tırnak işaretleri bir karakter dizisini başka
veri tiplerinden ayırt etmeye yarayan bir ölçüttür. Ama biz insanlar, yukarıda
verdiğimiz örnek cümlelerden de göreceğiniz gibi, programlama dillerinden farklı
olarak, tırnak işaretlerini bir metin içinde daha farklı amaçlar için de
kullanabiliyoruz.

Şimdi yukarıdaki karakter dizisini şöyle tanımlamaya çalıştığımızı düşünün:

```python
>>> "Ahmet, "Bugün sinemaya gidiyorum," dedi."

```

İşte burada Python’ın çıkarları ile bizim çıkarlarımız birbiriyle çatıştı.
Python karakter dizisini başlatan ilk çift tırnak işaretini gördükten sonra,
karakter dizisini tanımlama işlemini bitirebilmek için ikinci bir tırnak işareti
daha aramaya koyuldu. Bu arayış sırasında da ‘Bugün’ kelimesinin başındaki çift
tırnak işaretini gördü ve karakter dizisinin şu olduğunu zannetti:

```python
>>> "Ahmet, "

```

Buraya kadar bir sorun yok. Bu karakter dizisi Python’ın sözdizimi kurallarına
uygun.

Karakter dizisi bu şekilde tanımlandıktan sonra Python cümlenin geri kalanını
okumaya devam ediyor ve herhangi bir tırnak işareti ile başlamayan ve
kendisinden önce gelen öğeden herhangi bir virgül işareti ile ayrılmamış ‘Bugün’
kelimesini görüyor. Eğer bir kelime tırnak işareti ile başlamıyorsa bu kelime ya
bir değişkendir ya da sayıdır. Ama ‘Bugün’ kelimesi ne bir değişken, ne de bir
sayı olduğu, üstelik önceki öğeden de virgülle ayrılmadığı için Python’ın hata
vermekten başka çaresi kalmıyor. Çünkü biz burada ‘Bugün’ kelimesinin baş
tarafındaki çift tırnak işaretini karakter dizisi tanımlamak için değil,
başkasının sözlerini aktarmak amacıyla kullandık. Ancak elbette bir programlama
dili bizim amacımızın ne olduğunu kestiremez ve hata mesajını suratımıza
yapıştırır:

```python
 File "<stdin>", line 1
 "Ahmet, "Bugün sinemaya gidiyorum," dedi."
 ^
SyntaxError: invalid syntax

```

Peki biz böyle bir durumda ne yapmalıyız?

Bu hatayı engellemek için karakter dizisini tanımlamaya çift tırnak yerine tek
tırnakla ya da üç tırnakla başlayabiliriz:

```python
>>> 'Ahmet, "Bugün sinemaya gidiyorum," dedi.'

```

… veya:

```python
>>> """Ahmet, "Bugün sinemaya gidiyorum," dedi."""

```

Böylece karakter dizisini başlatan işaret ‘Bugün sinemaya gidiyorum,’ cümlesinin
başındaki ve sonundaki işaretlerden farklı olduğu için, Python okuma esnasında
bu cümleye takılmaz ve doğru bir şekilde, karakter dizisini kapatan tırnak
işaretini bulabilir.

Bu yöntem tamamen geçerli ve mantıklıdır. Ama eğer istersek, aynı karakter
dizisini çift tırnakla tanımlayıp, yine de hata almayı engelleyebiliriz. Peki
ama nasıl?

İşte burada ‘kaçış dizileri’ adı verilen birtakım araçlardan faydalanacağız.

Peki nedir bu ‘kaçış dizisi’ denen şey?

Kaçış dizileri, Python’da özel anlam taşıyan işaret veya karakterleri, sahip
oldukları bu özel anlam dışında bir amaçla kullanmamızı sağlayan birtakım
araçlardır. Mesela yukarıda da örneklerini verdiğimiz gibi, tırnak işaretleri
Python açısından özel anlam taşıyan işaretlerdir. Normalde Python bu işaretleri
karakter dizilerini tanımlamak için kullanır. Ama eğer siz mesela bir metin
içinde bu tırnak işaretlerini farklı bir amaçla kullanacaksanız Python’ı bu
durumdan haberdar etmeniz gerekiyor. İşte kaçış dizileri, Python’ı böyle bir
durumdan haberdar etmemize yarayan araçlardır.

Python’da pek çok kaçış dizisi bulunur. Biz burada bu kaçış dizilerini tek tek
inceleyeceğiz. O halde hemen işe koyulalım.

### Ters Taksim (\)

Yukarıda verdiğimiz örneklerde, çift tırnakla gösterdiğimiz karakter dizilerinin
içinde de çift tırnak işareti kullanabilmek için birkaç farklı yöntemden
yararlanabildiğimizi öğrenmiştik. Buna göre, eğer bir karakter dizisi içinde
çift tırnak işareti geçiyorsa, o karakter dizisini tek tırnakla; eğer tek tırnak
geçiyorsa da o karakter dizisini çift tırnakla tanımlayarak bu sorunun
üstesinden gelebiliyorduk. Ama daha önce de söylediğimiz gibi, ‘kaçış dizileri’
adı verilen birtakım araçları kullanarak, mesela içinde çift tırnak geçen
karakter dizilerini yine çift tırnakla tanımlayabiliriz.

Dilerseniz, kaçış dizisi kavramını açıklamaya geçmeden önce bununla ilgili
birkaç örnek verelim. Bu sayede ne ile karşı karşıya olduğumuz, zihnimizde biraz
daha belirginleşebilir:

```python
>>> print('Yarın Adana\'ya gidiyorum.')

Yarın Adana'ya gidiyorum.

```

Bir örnek daha verelim:

```python
>>> print("\"book\" kelimesi Türkçede \"kitap\" anlamına gelir.")

"book" kelimesi Türkçede "kitap" anlamına gelir.

```

Burada da cümle içinde çift tırnak işaretlerini kullandığımız halde,\işaretleri sayesinde karakter dizilerini yine çift tırnakla tanımlayabildik.

Bir de şu örneğe bakalım:

```python
>>> print("Python programlama dilinin adı \"piton\" yılanından gelmez")

```

Bütün bu örneklerde, karakter dizisini hem çift tırnakla tanımlayıp hem de
karakter dizisi içinde çift tırnak işaretlerini kullandığımız halde, herhangi
bir hata almadığımızı görüyorsunuz. Yukarıdaki kodlarda hata almamızı önleyen
şeyin\işareti olduğu belli. Ama dilerseniz bu işaretin, hata almamızı nasıl
önlediğini anlatmadan önce son bir örnek daha verelim.

Hatırlarsanız önceki sayfalarda şöyle bir karakter dizisi ile karşılaşmıştık:

```python
>>> print('İstanbul'un 5 günlük hava durumu tahmini')

 File "<stdin>", line 1
 print('İstanbul'un 5 günlük hava durumu tahmini')
 ^
SyntaxError: invalid syntax

```

Burada da ‘İstanbul’un’ kelimesi içinde geçen tırnak işareti nedeniyle karakter
dizisini tek tırnak kullanarak tanımlayamıyorduk. Bu karakter dizisini hatasız
bir şekilde tanımlayabilmek için ya çift tırnak ya da üç tırnak kullanmamız
gerekiyordu:

```python
>>> print("İstanbul'un 5 günlük hava durumu tahmini")

İstanbul'un 5 günlük hava durumu tahmini

```

… veya:

```python
>>> print("""İstanbul'un 5 günlük hava durumu tahmini""")

İstanbul'un 5 günlük hava durumu tahmini

```

Tıpkı önceki örneklerde olduğu gibi, yukarıdaki karakter dizisini de aslında tek
tırnakla tanımlayıp hata oluşmasını önleyebiliriz. Hemen görelim:

```python
>>> print('İstanbul\'un 5 günlük hava durumu tahmini')

İstanbul'un 5 günlük hava durumu tahmini

```

Bütün örneklerde\işaretini kullandığımızı görüyorsunuz. İşte bu tür
işaretlere Python’da kaçış dizisi (escape sequence) adı verilir. Bu işaretler
karakter dizilerini tanımlarken oluşabilecek hatalardan kaçmamızı sağlar. Peki
bu\işareti nasıl oluyor da karakter dizisini tanımlarken hata almamızı
önlüyor? Gelin bu süreci adım adım tarif edelim:

Python bir karakter dizisi tanımladığımızda, karakter dizisini soldan sağa doğru
okumaya başlar. Mesela yukarıdaki örnekte ilk olarak karakter dizisini
tanımlamaya tek tırnakla başladığımızı görür.

Python karakter dizisini başlatan bu tek tırnak işaretini gördüğü zaman, soldan
sağa doğru ilerleyerek karakter dizisini bitirecek olan tek tırnak işaretini
aramaya başlar.

Soldan sağa doğru ilerlerken ‘İstanbul’un’ kelimesi içinde geçen kesme işaretini
görür ve karakter dizisinin burada sona erdiğini düşünür. Ancak karakter
dizisini sona erdiren işaret bu olmadığı için Python’ın hata vermekten başka
çaresi kalmaz.

İşte biz ‘İstanbul’un’ kelimesi içinde geçen bu kesme işaretinin sol tarafına
bir adet\işareti yerleştirerek Python’a, ‘Aradığın işaret bu değil. Sen
karakter dizisini okumaya devam et. Biraz sonra aradığın tırnağı bulacaksın!’
mesajı vermiş, yani orada tırnak işaretini farklı bir amaçla kullandığımız
konusunda Python’ı bilgilendirmiş oluruz.

Şurada da aynı durum sözkonusu:

```python
>>> print("Python programlama dilinin adı \"piton\" yılanından gelmez")

```

Tıpkı bir önceki örnekte olduğu gibi, burada da Python karakter dizisini soldan
sağa doğru okumaya başlıyor, karakter dizisini başlatan çift tırnak işaretini
görüyor ve bunun üzerine Python karakter dizisini bitirecek olan çift tırnak
işaretini aramaya koyuluyor.

Karakter dizisini soldan sağa doğru okuduğu sırada, karakter dizisi içinde geçen
‘piton’ kelimesini görüyor. Eğer burada bir önlem almazsak Python bu kelimenin
başındaki çift tırnak işaretini, karakter dizisini sona erdiren tırnak olarak
algılar ve durum aslında böyle olmadığı için de hata verir.

Bu hatayı önlemek için ‘piton’ kelimesinin başındaki çift tırnağın soluna bir
adet\işareti yerleştirerek Python’a, ‘Aradığın tırnak bu değil!’ mesajı
veriyoruz. Yani bir bakıma,\adlı kaçış dizisi kendisini tırnak işaretine
siper edip Python’ın bu tırnağı görmesine mani oluyor…

Bunun üzerine Python bu çift tırnak işaretini görmezden gelerek, soldan sağa
doğru okumaya devam eder ve yol üzerinde ‘piton’ kelimesinin sonundaki çift
tırnak işaretini görür. Eğer burada da bir önlem almazsak Python yine bir hata
verecektir.

Tıpkı biraz önce yaptığımız gibi, bu tırnak işaretinin de soluna bir adet\işareti yerleştirerek Python’a, ‘Aradığın tırnak bu da değil. Sen yine okumaya
devam et!’ mesajı veriyoruz.

Bu mesajı alan Python karakter dizisini soldan sağa doğru okumaya devam ediyor
ve sonunda karakter dizisini bitiren çift tırnak işaretini bularak bize hatasız
bir çıktı veriyor.

Böylece\işareti üzerinden hem kaçış dizilerinin ne olduğunu öğrenmiş, hem
de bu kaçış dizisinin nasıl kullanılacağına dair örnekler vermiş olduk. Ancak\kaçış dizisinin yetenekleri yukarıdakilerle sınırlı değildir. Bu kaçış
dizisini, uzun karakter dizilerini bölmek için de kullanabiliriz. Şimdi şu
örneği dikkatlice inceleyin:

```python
>>> print("Python 1990 yılında Guido Van Rossum \
... tarafından geliştirilmeye başlanmış, oldukça \
... güçlü ve yetenekli bir programlama dilidir.")

Python 1990 yılında Guido Van Rossum tarafından geliştirilmeye
başlanmış, oldukça güçlü ve yetenekli bir programlama dilidir.

```

Normal şartlar altında, bir karakter dizisini tanımlamaya tek veya çift tırnakla
başlamışsak, karakter dizisinin kapanış tırnağını koymadanEntertuşuna
bastığımızda Python bize bir hata mesajı gösterir:

```python
>>> print("Python 1990 yılında Guido Van Rossum

 File "<stdin>", line 1
 print("Python 1990 yılında Guido Van Rossum
 ^
SyntaxError: EOL while scanning string literal

```

İşte\kaçış dizisi bizim burada olası bir hatadan kaçmamızı sağlar. EğerEntertuşuna basmadan önce bu işareti kullanırsak Python tıpkı üç tırnak
işaretlerinde şahit olduğumuz gibi, hata vermeden bir alt satıra geçecektir. Bu
sırada, yani\kaçış dizisini koyupEntertuşuna bastığımızda>>>işaretinin…işaretine dönüştüğünü görüyorsunuz. Bu işaretin, Python’ın bize
verdiği bir ‘Yazmaya devam et!’ mesajı olduğunu biliyorsunuz.

### Satır Başı (\n)

Python’daki en temel kaçış dizisi biraz önce örneklerini verdiğimiz\işaretidir. Bu kaçış dizisi başka karakterlerle birleşerek, farklı işlevlere
sahip yeni kaçış dizileri de oluşturabilir. Aslında bu olguya yabancı değiliz.
Önceki sayfalarda bu duruma bir örnek vermiştik. Hatırlarsanızprint()fonksiyonunu anlatırkenendparametresinin ön tanımlı değerinin\n, yani
satır başı karakteri olduğunu söylemiştik.

> **Not**
> Satır başı karakterine ‘yeni satır karakteri’ dendiği de olur.

Not

Satır başı karakterine ‘yeni satır karakteri’ dendiği de olur.

Satır başı karakterini ilk öğrendiğimizde bu karakteri anlatırken bazı örnekler
de vermiştik:

```python
>>> print("birinci satır\nikinci satır\nüçüncü satır")

birinci satır
ikinci satır
üçüncü satır

```

Gördüğünüz gibi,\nadlı kaçış dizisi, bir alt satıra geçilmesini sağlıyor.
İşte aslında\nkaçış dizisi de,\ile ‘n’ harfinin birleşmesinden oluşmuş
bir kaçış dizisidir. Burada\işaretinin görevi, ‘n’ harfinin özel bir anlam
kazanmasını sağlamaktır.\işareti ile ‘n’ harfi birleştiğinde ‘satır başı
karakteri’ denen özel bir karakter dizisi ortaya çıkarıyor.

Gelin bu kaçış dizisi ile ilgili bir örnek verelim. Şimdi şu kodları dikkatlice
inceleyin:

```python
>>> başlık = "Türkiye'de Özgür Yazılımın Geçmişi"
>>> print(başlık, "\n", "-"*len(başlık), sep="")

Türkiye'de Özgür Yazılımın Geçmişi
----------------------------------

```

Burada,başlıkadlı değişkenin tuttuğu“Türkiye’de Özgür Yazılımın Geçmişi”adlı karakter dizisinin altını çizdik. Dikkat ederseniz, başlığın altına
koyduğumuz çizgiler başlığın uzunluğunu aşmıyor. Yazdığımız program, başlığın
uzunluğu kadar çizgiyi başlığın altına ekliyor. Bu programda başlık ne olursa
olsun, programımız çizgi uzunluğunu kendisi ayarlayacaktır. Örneğin:

```python
>>> başlık = "Python Programlama Dili"
>>> print(başlık, "\n", "-"*len(başlık), sep="")

Python Programlama Dili
-----------------------

>>> başlık = "Alışveriş Listesi"
>>> print(başlık, "\n", "-"*len(başlık), sep="")

Alışveriş Listesi
-----------------

```

Gelin isterseniz bu kodlardakiprint()satırını şöyle bir inceleyelim.
Kodumuz şu:

```python
>>> print(başlık, "\n", "-"*len(başlık), sep="")

```

Burada önceliklebaşlıkadlı değişkeniprint()fonksiyonunun parantezleri
içine yazdık. Böylecebaşlıkdeğişkeninin değeri ekrana yazdırılacak.

print()fonksiyonunun ikinci parametresinin\nadlı kaçış dizisi olduğunu
görüyoruz. Bu kaçış dizisini eklememiz sayesinde Python ilk parametreyi çıktı
olarak verdikten sonra bir alt satıra geçiyor. Bu parametrenin tam olarak ne işe
yaradığını anlamak için, yukarıdaki satırı bir de o parametre olmadan
çalıştırmayı deneyebilirsiniz:

```python
>>> print(başlık, "-"*len(başlık), sep="")

Alışveriş Listesi-----------------

```

print()fonksiyonunun üçüncü parametresinin ise şu olduğunu görüyoruz:"-"*len(başlık).

İştebaşlıkdeğişkeninin altına gerekli sayıda çizgiyi çizen kodlar bunlardır.
Buradalen()fonksiyonunu nasıl kullandığımıza çok dikkat edin. Bu kod
sayesindebaşlıkdeğişkeninin uzunluğu (len(başlık)) sayısınca-işaretini ekrana çıktı olarak verebiliyoruz.

Yukarıdaki kodlardaprint()fonksiyonunun son parametresi isesep=''. Peki
bu ne işe yarıyor? Her zaman olduğu gibi, bu kod parçasının ne işe yaradığını
anlamak için programı bir de o kodlar olmadan çalıştırmayı deneyebilirsiniz:

```python
>>> print(başlık, "\n", "-"*len(başlık))

Alışveriş Listesi
 -----------------

```

Gördüğünüz gibi,başlıkdeğişkeninin tam altına gelmesi gereken çizgi
işaretleri sağa kaymış. Bunun nedenisepparametresinin öntanımlı değerinin
bir adet boşluk karakteri olmasıdır.sepparametresinin öntanımlı değeri
nedeniyle çizgilerin baş tarafına bir adet boşluk karakteri ekleniyor çıktıda. O
yüzden bu çizgiler sağa kaymış görünüyor. İşte biz yukarıdaki kodlardasepparametresinin öntanımlı değerini değiştirip, boşluk karakteri yerine boş bir
karakter dizisi yerleştiriyoruz. Böylece çizgiler çıktıda sağa kaymıyor.

Satır başı karakteri, programlama maceramız sırasında en çok kullanacağımız
kaçış dizilerinden biri ve hatta belki de birincisidir. O yüzden bu kaçış
dizisini çok iyi öğrenmenizi tavsiye ederim.

Ayrıca bu kaçış dizisini (ve tabii öteki kaçış dizilerini) tanıyıp öğrenmeniz,
yazacağınız programların selameti açısından da büyük önem taşır. Eğer bir
karakter dizisi içinde geçen kaçış dizilerini ayırt edemezseniz Python size hiç
beklemediğiniz çıktılar verebilir. Hatta yazdığınız programlar kaçış dizilerini
tanımıyor olmanızdan ötürü bir anda hata verip çökebilir. Peki ama nasıl?

Şimdi şu örneğe dikkatlice bakın:

Diyelim ki bilgisayarınızın ‘C:\’ dizinindeki ‘nisan’ adlı bir klasörün içinde
yer alanmasraflar.txtadlı bir dosyayı yazdığınız bir program içinde
kullanmanız gerekiyor. Mesela bu dosyayı, tam adresiyle birlikte
kullanıcılarınıza göstermek istiyorsunuz.

İlk denememizi yapalım:

```python
>>> print("C:\nisan\masraflar.txt")

```

Buradan şöyle bir çıktı aldık:

```python
C:
isan\masraflar.txt

```

Gördüğünüz gibi, bu çıktıyı normal yollardan vermeye çalıştığımızda Python bize
hiç de beklemediğimiz bir çıktı veriyor. Peki ama neden?

Python’da karakter dizileri ile çalışırken asla aklımızdan çıkarmamamız gereken
bir şey var: Eğer yazdığımız herhangi bir karakter dizisinin herhangi bir
yerinde\işaretini kullanmışsak, bu işaretten hemen sonra gelen karakterin
ne olduğuna çok dikkat etmemiz gerekir. Çünkü eğer dikkat etmezsek, farkında
olmadan Python için özel anlam taşıyan bir karakter dizisi oluşturmuş
olabiliriz. Bu da kodlarımızın beklediğimiz gibi çalışmasını engeller.

Yukarıdaki sorunun kaynağını anlamak için"C:\nisan\masraflar.txt"adlı
karakter dizisine çok dikkatlice bakın. Python bu karakter dizisinde bizim
‘\nisan’ olarak belirttiğimiz kısmın başındaki\nkarakterlerini bir kaçış
dizisi olarak algıladı. Çünkü\nadlı karakter dizisi, ‘satır başı kaçış
dizisi’ adını verdiğimiz, Python açısından özel anlam taşıyan bir karakter
dizisine işaret ediyor. Zaten yukarıdaki tuhaf görünen çıktıya baktığınızda da,
bu kaçış dizisinin olduğu noktadan itibaren karakter dizisinin bölünüp yeni bir
satıra geçildiğini göreceksiniz. İşte biz yukarıdaki örnekte alelade bir dizin
adı belirttiğimizi zannederken aslında hiç farkında olmadan bir kaçış dizisi
üretmiş oluyoruz. Bu nedenle, daha önce de söylediğimiz gibi, karakter dizileri
içinde farkında olarak veya olmayarak kullandığımız kaçış dizilerine karşı her
zaman uyanık olmalıyız. Aksi takdirde, yukarıda olduğu gibi hiç beklemediğimiz
çıktılarla karşılaşabiliriz.

Esasen yukarıdaki problem bir dereceye kadar (ve yerine göre) ‘masum bir kusur’
olarak görülebilir. Çünkü bu hata programımızın çökmesine yol açmıyor. Ama bir
karakter dizisi içindeki gizli kaçış dizilerini gözden kaçırmak, bazı durumlarda
çok daha yıkıcı sonuçlara yol açabilir. Mesela yukarıdaki sorunlu dizin adını
ekrana yazdırmak yerineopen()fonksiyonunu kullanarak, bu karakter dizisi
içinde belirttiğimizmasraflar.txtadlı dosyayı açmaya çalıştığımızı düşünün:

```python
>>> open("C:\nisan\masraflar.txt")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
OSError: [Errno 22] Invalid argument: 'C:\nisan\\masraflar.txt'

```

Eğer sorunun gözden kaçan bir kaçış dizisinden kaynaklandığını farkedemezseniz,
bu sorunu çözebilmek için saatlerinizi ve hatta günlerinizi harcamak zorunda
kalabilirsiniz. Çünkü yukarıdaki hata mesajı sorunun nedenine dair hiçbir şey
söylemiyor. Ancak ve ancak yukarıdaki karakter dizisi içinde sinsice gizlenen
bir\nkaçış dizisi olduğu gözünüze çarparsa bu sorunu çözme yolunda bir adım
atabilirsiniz.

Diyelim ki sorunun ‘\nisan’ ifadesinin başındaki\nkarakterlerinin Python
tarafından bir kaçış dizisi olarak algılanmasından kaynaklandığını farkettiniz.
Peki bu sorunu nasıl çözeceksiniz?

Bu sorunun birkaç farklı çözüm yolu var. Biz şimdilik sadece ikisini göreceğiz.
Bu bölümün sonuna vardığınızda öteki çözüm yolunu da öğrenmiş olacaksınız.

Yukarıdaki problemi, ilgili kaçış dizisi içindeki ters taksim işaretini
çiftleyerek çözebilirsiniz:

```python
>>> open("C:\\nisan\masraflar")

```

Tabii tutarlılık açısından karakter dizisi içindeki bütün ters taksim
işaretlerini çiftlemek mantıklı olacaktır:

```python
>>> open("C:\\nisan\\masraflar")

```

Bunun dışında, bu örnek için, dizin adlarını ters taksim yerine düz taksim
işaretiyle ayırmayı tercih edebilirsiniz:

```python
>>> open("C:/nisan/masraflar")

```

Dediğimiz gibi, üçüncü (ve aslında daha kullanışlı olan) yöntemi biraz sonra
inceleyeceğiz. Biz şimdilik kaçış dizilerini anlatmaya devam edelim.

### Sekme (\t)

Python’da\işareti sadece ‘n’ harfiyle değil, başka harflerle de
birleşebilir. Örneğin\işaretini ‘t’ harfiyle birleştirerek yine özel bir
anlam ifade eden bir kaçış dizisi elde edebiliriz:

```python
>>> print("abc\tdef")

abc def

```

Burada\tadlı kaçış dizisi,“abc”ifadesinden sonra sankiTab(sekme)
tuşuna basılmış gibi bir etki oluşturarak“def”ifadesini sağa doğru itiyor.
Bir de şu örneğe bakalım:

```python
>>> print("bir", "iki", "üç", sep="\t")

bir iki üç

```

Bir örnek daha:

```python
>>> print(*"123456789", sep="\t")

1 2 3 4 5 6 7 8 9

```

Gördüğünüz gibi, parametreler arasında belli aralıkta bir boşluk bırakmak
istediğimizde\tadlı kaçış dizisinden yararlanabiliyoruz.

Tıpkı\nkaçış dizisinde olduğu gibi, karakter dizilerinde\tkaçış
dizisinin varlığına karşı da uyanık olmalıyız:

```python
>>> open("C:\nisan\masraflar\toplam_masraf.txt")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
OSError: [Errno 22] Invalid argument: 'C:\nisan\\masraflar\toplam_masraf.txt'

```

Burada da\nile yaşadığımız soruna benzer bir durum var. Biztoplam_masraf.txtadlı bir dosyaya atıfta bulunmaya çalışıyoruz, ama Python bu
ifadenin başındaki ‘t’ harfinin, kendisinden önce gelen\işareti ile
birleşmesinden ötürü, bunu\tkaçış dizisi olarak algılıyor ve ona göre
davranıyor.

Belki yukarıdaki kodları şöyle yazarsak durumu anlamak daha kolay olabilir:

```python
>>> print("C:\nisan\masraflar\toplam_masraf.txt")

C:
isan\masraflar oplam_masraf.txt

```

Gördüğünüz gibi, Python\nkaçış dizisini gördüğü noktada alt satırın başına
geçiyor ve\tkaçış dizisini gördüğü noktada da önceki ve sonraki öğeler
arasında bir sekme boşluğu bırakıyor. Bu durumu engellemek için ne yapmanız
gerektiğini biliyorsunuz: Ya ters taksim işaretlerini çiftleyeceksiniz:

```python
>>> print("C:\\nisan\\masraflar\\toplam_masraf.txt")

```

Ya da dizin adı ayracı olarak düz taksim işaretini kullanacaksınız:

```python
>>> print("C:/nisan/masraflar/toplam_masraf.txt")

```

Daha önce de söylediğimiz gibi, üçüncü ve daha pratik olan yolu biraz sonra
göreceğiz. Şimdilik sadece biraz sabır…

### Zil Sesi (\a)

\işaretinin birleştiğinde farklı bir anlam türettiği bir başka harf de ‘a’
harfidir.\işareti ‘a’ harfiyle birleşerek !bip! benzeri bir zil sesi
üretilmesini sağlayabilir:

```python
>>> print("\a")

!bip!

```

İsterseniz yukarıdaki komutu şu şekilde yazarak, kafa şişirme katsayısını
artırabilirsiniz:

```python
>>> print("\a" * 10)

```

Bu şekilde !bip! sesi10kez tekrar edilecektir. Ancak bu kaçış dizisi
çoğunlukla sadece Windows üzerinde çalışacaktır. Bu kaçış dizisinin GNU/Linux
üzerinde çalışma garantisi yoktur. Hatta bu kaçış dizisi bütün Windows
sistemlerinde dahi çalışmayabilir. Dolayısıyla bu kaçış dizisinin işlevine bel
bağlamak pek mantıklı bir iş değildir.

Tıpkı\nve\tkaçış dizilerinde olduğu gibi bu kaçış dizisinin varlığına
karşı da uyanık olmalıyız. Burada da mesela ‘C:\aylar’ gibi bir dizin adı
tanımlamaya çalışırken aslında\akaçış dizisini oluşturuyor olabilirsiniz
farkında olmadan.

### Aynı Satır Başı (\r)

Bu kaçış dizisi, bir karakter dizisinde aynı satırın en başına dönülmesini
sağlar. Bu kaçış dizisinin işlevini tanımına bakarak anlamak biraz zor olabilir.
O yüzden dilerseniz bu kaçış dizisinin ne işe yaradığını bir örnek üzerinde
göstermeye çalışalım:

```python
>>> print("Merhaba\rZalim Dünya!")

Zalim Dünya!

```

Burada olan şey şu: Normal şartlar altında,print()fonksiyonu içine
yazdığımız bir karakter dizisindeki bütün karakterler soldan sağa doğru tek tek
ekrana yazdırılır:

```python
>>> print("Merhaba Zalim Dünya!")

Merhaba Zalim Dünya!

```

Ancak eğer karakter dizisinin herhangi bir yerine\radlı kaçış dizisini
yerleştirirsek, bu kaçış dizisinin bulunduğu konumdan itibarenaynısatırın
başına dönülecek ve\rkaçış dizisinden sonra gelen bütün karakterler satır
başındaki karakterlerin üzerine yazacaktır. Şu örnek daha açıklayıcı olabilir:

```python
>>> print("Merhaba\rDünya")

Dünyaba

```

Burada,“Merhaba”karakter dizisi ekrana yazdırıldıktan sonra\rkaçış
dizisinin etkisiyle satır başına dönülüyor ve bu kaçış dizisinden sonra gelen“Dünya”karakter dizisi“Merhaba”karakter dizisinin üzerine yazıyor. Tabii“Dünya”karakter dizisi içinde5karakter,“Merhaba”karakter dizisi
içinde ise7karakter olduğu için,“Merhaba”karakter dizisinin son iki
karakteri (“ba”) dışarda kalıyor. Böylece ortaya“Dünyaba”gibi bir şey
çıkıyor.

Önceki kaçış dizilerinde olduğu gibi, bu kaçış dizisini de farkında olmadan
karakter dizisi içinde kullanırsanız beklemediğiniz çıktılar alırsınız:

```python
>>> print("C:\ülke\türkiye\iller\rize\nüfus.txt")

izeülke ürkiye\iller
üfus.txt

```

Burada farkında olmadan sadece bir değil, üç kaçış dizisi birden oluşturduk!

### Düşey Sekme (\v)

Eğer\işaretini ‘v’ harfiyle birlikte kullanırsak düşey sekme denen şeyi
elde ederiz. Hemen bir örnek verelim:

```python
>>> print("düşey\vsekme")

düşey
 sekme

```

Yalnız bu\vadlı kaçış dizisi her işletim sisteminde çalışmayabilir.
Dolayısıyla, birden fazla platform üzerinde çalışmak üzere tasarladığınız
programlarınızda bu kaçış dizisini kullanmanızı önermem.

### İmleç Kaydırma (\b)

\kaçış dizisinin, biraraya geldiğinde özel bir anlam kazandığı bir başka
harf de b’dir.\bkaçış dizisinin görevi, imleci o anki konumundan sola
kaydırmaktır. Bu tanım pek anlaşılır değil. O yüzden bir örnek verelim:

```python
>>> print("yahoo.com\b")

```

Bu kodu çalıştırdığınızda herhangi bir değişiklik görmeyeceksiniz. Ama aslında
en sonda gördüğümüz\bkaçış dizisi, imleci bir karakter sola kaydırdı.
Dikkatlice bakın:

```python
>>> print("yahoo.com\b.uk")

```

Gördüğünüz gibi,\bkaçış dizisinin etkisiyle imleç bir karakter sola kaydığı
için, ‘com’ kelimesinin son harfi silindi ve bunun yerine\bkaçış dizisinden
sonra gelen.ukkarakterleri yerleştirildi. Dolayısıyla biz de şu çıktıyı
aldık:

```python
yahoo.co.uk

```

Bir örnek daha verelim…

Bildiğiniz gibi,print()fonksiyonu, kendisine verilen parametreler arasına
birer boşluk yerleştirir:

```python
>>> print('istihza', '.', 'com')

istihza . com

```

Biz bu öğeleri birbirine bitiştirmek için şöyle bir yol izleyebileceğimizi
biliyoruz:

```python
>>> print('istihza', '.', 'com', sep='')

istihza.com

```

İşte aynı etkiyi\bkaçış dizisini kullanarak da elde edebiliriz:

```python
>>> print('istihza', '\b.', '\bcom')

istihza.com

```

Gördüğünüz gibi,\bkaçış dizisi, ‘.’ ve ‘com’ parametrelerinden önce imleci
birer karakter sola kaydırdığı için, parametreler arasındaki boşluk karakterleri
ortadan kalktı.

Bu kaçış dizisini kullanarak şöyle gereksiz işler peşinde de koşabilirsiniz:

```python
>>> print('istihza\b\b\bsn')

istisna

```

Burada\bkaçış dizisini üst üste birkaç kez kullanarak imleci birkaç
karakter sola kaydırdık ve ‘sn’ harflerini ‘hz’ harflerinin üzerine bindirdik.
Böylece ‘istihza’ kelimesi ‘istisna’ kelimesine dönüşmüş oldu…

Daha fazla uzatmadan, bu kaçış dizisinin Python’da çok nadir kullanıldığı
bilgisini vererek yolumuza devam edelim…

### Küçük Unicode (\u)

Tıpkı bundan önceki kaçış dizileri gibi, karakter dizileri içindeki varlığı
konusunda dikkatli olmamız gereken bir başka kaçış dizisi de\uadlı kaçış
dizisidir. Eğer bu kaçış dizisini tanımaz ve dikkatli kullanmazsak, yazdığımız
programlar tespit etmesi çok güç hatalar üretebilir.

Örneğin şöyle bir çıktı vermek istediğinizi düşünün:

Dosya konumu: C:\users\zeynep\gizli\dosya.txt

Bu çıktıyı normal yollardan vermeye çalışırsak Python bize bir hata mesajı
gösterecektir:

```python
>>> print("Dosya konumu: C:\users\zeynep\gizli\dosya.txt")

 File "<stdin>", line 1
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in
position 16-18: truncated \uXXXX escape

```

Belki sağda solda ‘UNICODE’ diye bir şey duymuşsunuzdur. Eğer şimdiye kadar
böyle bir şey duymadıysanız veya duyduysanız bile ne olduğunu bilmiyorsanız hiç
ziyanı yok. Birkaç bölüm sonra bunun ne anlama geldiğini bütün ayrıntılarıyla
anlatacağız. Biz şimdilik sadece şunu bilelim: UNICODE, karakterlerin,
harflerin, sayıların ve bilgisayar ekranında gördüğümüz öteki bütün işaretlerin
her biri için tek ve benzersiz bir numaranın tanımlandığı bir sistemdir. Bu
sistemde, ‘kod konumu’ (code point) adı verilen bu numaralar özel bir şekilde
gösterilir. Örneğin ‘ı’ harfi UNICODE sisteminde şu şekilde temsil edilir:

```python
u+0131

```

Aynı şekilde ‘a’ harfi bu sistemde şu kod konumu ile gösterilir:

```python
u+0061

```

Python programlama dilinde ise, yukarıdaki kod konumu düzeni şöyle gösterilir:

```python
\\u0131

```

Gördüğünüz gibi, Python UNICODE sistemindeki her bir kod konumunu gösterebilmek
için, önce\uşeklinde bir kaçış dizisi tanımlıyor, ardından UNICODE
sisteminde+işaretinden sonra gelen sayıyı bu kaçış dizisinin hemen
sağına ekliyor. Gelin kendi kendimize birkaç deneme çalışması yapalım:

```python
>>> '\u0130'

'İ'

>>> '\u0070'

'p'

>>> "\ufdsf"

 File "<stdin>", line 1
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in
position 0-4: truncated \uXXXX escape

```

Gördüğünüz gibi, eğer\ukaçış dizisinden sonra doğru bir kod konumu
belirtmezsek Python bize bir hata mesajı gösteriyor…

Bu hata mesajının, biraz önceprint("Dosyakonumu:C:\users\zeynep\gizli\dosya.txt")kodunu yazdıktan sonra aldığımız hata ile
aynı olduğuna dikkat edin. Tıpkı\ufdsförneğinde olduğu gibi,\usersifadesi de varolan bir UNICODE kod konumuna karşılık gelmediği için, Python’ın
hata vermekten başka çaresi kalmıyor.

Biz bu örnekte ‘users’ kelimesini kullanmaya çalışıyoruz, ama ‘u’ harfinden
hemen önce gelen\kaçış dizisi nedeniyle, hiç farkında olmadan Python
açısından önemli bir karakter dizisi (\u) meydana getirmiş oluyoruz. O
yüzden, böyle can sıkıcı hatalarla karşılaşmamak için olası kaçış dizilerine
karşı her zaman uyanık olmamız gerekiyor.

Peki biz bu kaçış dizisi yüzünden, yazdığımız programlardaDosya konumu:
C:\users\zeynep\gizli\dosya.txt”)gibi bir çıktı veremeyecek miyiz?

Verebileceğimizi ve bunun bir yolu yordamı olduğunu biliyorsunuz:

```python
>>> print("Dosya konumu: C:\\users\\zeynep\\gizli\\dosya.txt")

Dosya konumu: C:\users\zeynep\gizli\dosya.txt

```

Gördüğünüz gibi, karakter dizisi içinde geçen bütün\işaretlerini
çiftleyerek sorunumuzu çözdük. Buradaki gibi bir sorunla karşılaşmamak için,
dizin adlarını ayırırken ters taksim işareti yerine düz taksim işaretini
kullanmayı da tercih edebilirsiniz:

```python
>>> print("Dosya konumu: C:/users/zeynep/gizli/dosya.txt")

```

Biraz sonra bu sorunu halletmenin üçüncü ve daha kolay bir yönteminden daha söz
edeceğiz. Ama biz şimdilik bu kaçış dizisini bir kenara bırakıp başka bir kaçış
dizisini incelemeye geçelim.

### Büyük Unicode (\U)

Bu kaçış dizisi biraz önce gördüğümüz\uadlı kaçış dizisiyle hemen hemen
aynı anlama gelir. Bu kaçış dizisi de, tıpkı\ugibi, UNICODE kod konumlarını
temsil etmek için kullanılır. AncakUile gösterilen kod konumlarıuile
gösterilenlere göre biraz daha uzundur. Örneğin, hatırlarsanızukaçış
dizisini kullanarak ‘ı’ harfinin UNICODE kod konumunu şöyle temsil ediyorduk:

```python
>>> '\u0131'

'ı'

```

Eğer aynı kod konumunuUadlı kaçış dizisi ile göstermek istersek şöyle bir
şey yazmamız gerekir:

```python
>>> '\U00000131'

```

Gördüğünüz gibi, burada\Ukaçış dizisinden sonra gelen kısım toplam 8
haneli bir sayıdan oluşuyor.ukaçış dizisinde ise bu kısmı toplam 4 haneli
bir sayı olarak yazıyorduk. İşte\ukaçış dizisi ileUkaçış dizisi
arasındaki fark budur.ukaçış dizisi hakkında söylediğimiz öteki her şeyUkaçış dizisi için de geçerlidir.

### Uzun Ad (\N)

UNICODE sistemi ile ilgili bir başka kaçış dizisi de\Nadlı kaçış dizisidir.

Dediğimiz gibi, UNICODE sistemine ilişkin ayrıntılardan ilerleyen derslerde söz
edeceğiz, ama bu sistemle ilgili ufak bir bilgi daha verelim.

UNICODE sisteminde her karakterin tek ve benzersiz bir kod konumu olduğu gibi,
tek ve benzersiz bir de uzun adı vardır. Örneğin ‘a’ harfinin UNICODE
sistemindeki uzun adı şudur:

```python
LATIN SMALL LETTER A

```

Bir karakterin UNICODE sistemindeki uzun adını öğrenmek içinunicodedataadlı
bir modülden yararlanabilirsiniz:

```python
>>> import unicodedata
>>> unicodedata.name('a')

LATIN SMALL LETTER A

>>> unicodedata.name('Ş')

LATIN CAPITAL LETTER S WITH CEDILLA

```

Bu arada, daha önce de söylediğimiz gibi, bu ‘modül’ kavramına şimdilik
takılmayın. İlerde modülleri ayrıntılı olarak inceleyeceğiz. Şimdilikunicodedatadenen şeyin, (tıpkı daha önce örneklerini gördüğümüzos,sysvekeywordgibi) bir modül olduğunu ve bu modül içindekinameadlı bir
fonksiyonu kullanarak, parantez içinde belirttiğimiz herhangi bir karakterin
UNICODE sistemindeki uzun adını elde edebileceğimizi bilelim yeter.

İşte\Nkaçış dizisi bu uzun isimleri, Python programlarımızda kullanma
imkanı verir bize. Bu kaçış dizisini, karakterlerin UNICODE sistemindeki uzun
adları ile birlikte kullanarak asıl karakterleri elde edebiliriz. Dikkatlice
bakın:

```python
>>> print("\N{LATIN SMALL LETTER A}")

a

>>> print("\N{LATIN CAPITAL LETTER S WITH CEDILLA}")

Ş

>>> print("\Nisan")

 File "<stdin>", line 1
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in
position 0-1: malformed \N character escape

```

Gördüğünüz gibi, herhangi bir karşılığı olmayan bir uzun ad belirttiğimizde
Python bize bir hata mesajı gösteriyor. Çünkü Python\Nkaçış dizisinin hemen
ardından{işaretinin getirilmesini ve sonra da UNICODE sistemi dahilinde
geçerli bir uzun ad belirtilmesini bekliyor. Yukarıdaki örnekte\Nkaçış
dizisinden sonra{işareti yok. Zaten\Nkaçış dizisinin hemen ardından
gelen ‘isan’ ifadesi de doğru bir uzun ada işaret etmiyor. Dolayısıyla da
Python’ın bize hata mesajı göstermekten başka çaresi kalmıyor…

\u,\Uve\Nkaçış dizileri, UNICODE sistemi ile ilgili çalışmalar
yapmak isteyen programcılar için Python programlama dilinin sunduğu faydalı
araçlardan yalnızca birkaçıdır. Ancak bu araçların sizin işinize yaramayacağını
asla düşünmeyin. Zira\u,\Uve\Nkaçış dizileri ile ilgili yukarıdaki
durum hiç beklemediğiniz bir anda sizi de vurabilir. Çünkü bu kaçış dizilerinin
oluşturduğu risk hiç de öyle nadir karşılaşılacak bir sorun değildir.

Bildiğiniz gibi Windows 7’de kullanıcının dosyalarını içeren dizin adıC:\Users\kullanıcı_adışeklinde gösteriliyor. Dolayısıyla Windows
kullananlar UNICODE kaçış dizilerinden kaynaklanan bu tuzağa her an düşebilir.
Ya da eğer adınız ‘u’ veya ‘n’ harfi ile başlıyorsa yine bu tuzağa düşme
ihtimaliniz epey yüksek olacak,C:\Users\umutveyaC:\Users\Nihatgibi
bir dizin adı belirtirken çok dikkatli olmanız gerekecektir. Zira özellikle
dosyalar üzerinde işlem yaparken, bu tür dizin adlarını sık sık kullanmak
durumunda kalacaksınız. Bu yüzden, alelade bir kelime yazdığınızı zannederken
hiç farkında olmadan bir kaçış dizisi tanımlıyor olma ihtimalini her zaman göz
önünde bulundurmalı ve buna uygun önlemleri almış olmalısınız.

### Onaltılı Karakter (\x)

‘x’ harfi de\işareti ile birleştiğinde özel anlam kazanarak bir kaçış
dizisi meydana getirir.

\xkaçış dizisini kullanarak, onaltılı
(hexadecimal) sayma sistemindeki bir sayının karakter karşılığını
gösterebilirsiniz. Dikkatlice bakın:

```python
>>> "\x41"

'A'

```

Onaltılı sayma sistemindeki41sayısı ‘A’ harfine karşılık gelir. Eğer hangi
karakterlerin hangi sayılara karşılık geldiğini merak ediyorsanızhttps://ascii.cl/adresindeki tabloyu inceleyebilirsiniz. Bu tabloda ‘hex’
sütunu altında gösterilen sayılar onaltılı sayılar olup, ‘symbol’ sütununda
gösterilen karakterlere karşılık gelirler. Örneğin ‘hex’ sütunundaki4Esayısı
‘symbol’ sütunundaki ‘N’ harfine karşılık gelir. Bu durumu Python’la da teyit
edebilirsiniz:

```python
>>>"\x4E"

N

```

Eğer sayılarla karakterler arasındaki bağlantının tam olarak ne olduğunu
bilmiyorsanız hiç endişe etmeyin. Birkaç bölüm sonra sayılarla karakterler
arasında nasıl bir bağ olduğunu gayet ayrıntılı bir şekilde anlatacağız. Biz
şimdilik yalnızca\xkarakter dizisinin özel bir kaçış dizisine karşılık
geldiğini ve bu kaçış dizisini karakter dizileri içinde kullanırken dikkatli
olmamız gerektiğini bilelim yeter:

```python
>>> print("C:\Users\Ayşe\xp_dosyaları")

 File "<stdin>", line 1
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in
position 2-4: truncated \UXXXXXXXX escape

```

Gördüğünüz gibi, Python\xifadesinden sonra onaltılı bir sayı belirtmenizi
bekliyor. Halbuki biz burada\xifadesini ‘xp_dosyaları’ adlı dizini
gösterebilmek için kullanmıştık. Ama görünüşe göre yanlışlıkla Python için özel
bir anlam ifade eden bir karakter dizisi oluşturmuşuz…

### Etkisizleştirme (r)

Dediğimiz gibi, Python’daki en temel kaçış dizisi\işaretidir. Bu işaret
bazı başka harflerle birleşerek yeni kaçış dizileri de oluşturabilir.

Python’da\işaretinin dışında temel bir kaçış dizisi daha bulunur. Bu kaçış
dizisi ‘r’ harfidir. Şimdi bu kaçış dizisinin nasıl kullanılacağını ve ne işe
yaradığını inceleyelim:

Şöyle bir çıktı vermek istediğimizi düşünün:

```python
Kurulum dizini: C:\aylar\nisan\toplam masraf

```

Bildiğimiz yoldan bu çıktıyı vermeye çalışırsak neler olacağını adınız gibi
biliyorsunuz:

```python
>>> print("Kurulum dizini: C:\aylar\nisan\toplam masraf")

Kurulum dizini: C:ylar
isan oplam masraf

```

> **Not**
> Eğer Windows üzerinde çalışıyorsanız bu komutu verdikten sonra bir
!bip! sesi de duymuş olabilirsiniz…

Not

Eğer Windows üzerinde çalışıyorsanız bu komutu verdikten sonra bir
!bip! sesi de duymuş olabilirsiniz…

Python tabii ki, karakter dizisi içinde geçen ‘\aylar’, ‘\nisan’, ve
‘\toplam masraf’ ifadelerinin ilk karakterlerini yanlış anladı!\a,\nve\tgibi ifadeler Python’ın gözünde birer kaçış dizisi. Dolayısıyla Python\akarakterlerini görünce bir !bip! sesi çıkarıyor,\nkarakterlerini
görünce satır başına geçiyor ve\tkarakterlerini görünce deTabtuşuna
basılmış gibi bir tepki veriyor. Sonuç olarak da yukarıdaki gibi bir çıktı
üretiyor.

Daha önce bu durumu şöyle bir kod yazarak engellemiştik:

```python
>>> print("Kurulum dizini: C:\\aylar\\nisan\\toplam masraf")

Kurulum dizini: C:\aylar\nisan\toplam masraf

```

Burada,\işaretlerinin her birini çiftleyerek sorunun üstesinden geldik.
Yukarıdaki yöntem doğru ve kabul görmüş bir çözümdür. Ama bu sorunun üstesinden
gelmenin çok daha basit ve pratik bir yolu var. Bakalım:

```python
>>> print(r"Kurulum dizini: C:\aylar\nisan\toplam masraf")

Kurulum dizini: C:\aylar\nisan\toplam masraf

```

Gördüğünüz gibi, karakter dizisinin baş kısmının dış tarafına bir adetrharfi
yerleştirerek sorunun üstesinden geliyoruz. Bu kaçış dizisinin, kullanım
açısından öteki kaçış dizilerinden farklı olduğuna dikkat edin. Öteki kaçış
dizileri karakter dizisinin içinde yer alırken, bu kaçış dizisi karakter
dizisinin dışına yerleştiriliyor.

Bu kaçış dizisinin tam olarak nasıl işlediğini görmek için dilerseniz bir örnek
daha verelim:

```python
>>> print("Kaçış dizileri: \, \n, \t, \a, \\, r")

Kaçış dizileri: \,
, , , \, r

```

Burada da Python bizim yapmak istediğimiz şeyi anlayamadı ve karakter dizisi
içinde geçen kaçış dizilerini doğrudan ekrana yazdırmak yerine bu kaçış
dizilerinin işlevlerini yerine getirmesine izin verdi. Tıpkı biraz önceki
örnekte olduğu gibi, istersek kaçış dizilerini çiftleyerek bu sorunu
aşabiliriz:

```python
>>> print("Kaçış dizileri: \\, \\n, \\t, \\a, \\\, r")

Kaçış dizileri: \, \n, \t, \a, \\, r

```

Ama tabii ki bunun çok daha kolay bir yöntemi olduğunu biliyorsunuz:

```python
>>> print(r"Kaçış dizileri: \, \n, \t, \a, \\, r")

Kaçış dizileri: \, \n, \t, \a, \\, r

```

Gördüğünüz gibi, karakter dizisinin başına getirdiğimizrkaçış dizisi,
karakter dizisi içinde geçen kaçış dizilerinin işlevlerini yerine getirmesine
engel olarak, istediğimiz çıktıyı elde etmemizi sağlıyor.

Bu arada bu kaçış dizisini, daha önce öğrendiğimiz\radlı kaçış dizisi ile
karıştırmamaya dikkat ediyoruz.

Python’daki bütün kaçış dizilerinden söz ettiğimize göre, konuyu kapatmadan önce
önemli bir ayrıntıdan söz edelim.

Python’da karakter dizilerinin sonunda sadece çift sayıda\işareti
bulunabilir. Tek sayıda\işareti kullanıldığında karakter dizisini bitiren
tırnak işareti etkisizleşeceği için çakışma sorunu ortaya çıkar. Bu
etkisizleşmeyi, karakter dizisinin başına koyduğunuz ‘r’ kaçış dizisi de
engelleyemez. Yani:

```python
>>> print("Kaçış dizisi: \")

```

Bu şekilde bir tanımlama yaptığımızda Python bize bir hata mesajı gösterir.
Çünkü kapanış tırnağının hemen öncesine yerleştirdiğimiz\kaçış dizisi,
Python’ın karakter dizisini kapatan tırnak işaretini görmezden gelmesine yol
açarak bu tırnağı etkisizleştiriyor. Böylece sanki karakter dizisini tanımlarken
kapanış tırnağını hiç yazmamışız gibi bir sonuç ortaya çıkıyor:

```python
>>> print("Kaçış dizisi: \")
 File "<stdin>", line 1
 print("Kaçış dizisi: \")
 ^
SyntaxError: EOL while scanning string literal

```

Üstelik bu durumu,radlı kaçış dizisi de engelleyemiyor:

```python
>>> print(r"Kaçış dizisi: \")
 File "<stdin>", line 1
 print(r"Kaçış dizisi: \")
 ^
SyntaxError: EOL while scanning string literal

```

Çözüm olarak birkaç farklı yöntemden yararlanabilirsiniz. Mesela karakter
dizisini kapatmadan önce karakter dizisinin sonundaki\işaretinin sağına bir
adet boşluk karakteri yerleştirmeyi deneyebilirsiniz:

```python
>>> print("Kaçış dizisi: \ ")

```

Veya kaçış dizisini çiftleyebilirsiniz:

```python
>>> print("Kaçış dizisi: \\")

```

Ya da karakter dizisi birleştirme yöntemlerinden herhangi birini
kullanabilirsiniz:

```python
>>> print("Kaçış dizisi: " + "\\")
>>> print("Kaçış dizisi:", "\\")
>>> print("Kaçış dizisi: " "\\")

```

Böyle bir durumla ilk kez karşılaştığınızda bunun Python programlama dilinden
kaynaklanan bir hata olduğunu düşünebilirsiniz, ancak bu durum Python’ın resmi
internet sitesinde ‘Sıkça Sorulan Sorular’ bölümüne alınacak kadar önemli bir
tasarım tercihidir:https://docs.python.org/2/faq/design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash

### Sayfa Başı (\f)

\fartık günümüzde pek kullanılmayan bir kaçış dizisidir. Bu kaçış dizisinin
görevi, özellikle eski yazıcılarda, bir sayfanın sona erip yeni bir sayfanın
başladığını göstermektir. Dolayısıyla eski model yazıcılar, bu karakteri
gördükleri noktada mevcut sayfayı sona erdirip yeni bir sayfaya geçer.

Bu kaçış dizisinin tam olarak ne işe yaradığını test etmek için şu kodları
çalıştırın:

```python
>>> f = open("deneme.txt", "w")
>>> print("deneme\fdeneme", file=f)
>>> f.close()

```

Şimdi bu kodlarla oluşturduğunuzdeneme.txtadlı dosyayı LibreOffice veya
Microsoft Word gibi bir programla açın. ‘deneme’ satırlarının iki farklı sayfaya
yazdırıldığını göreceksiniz. Bu arada, eğer Microsoft Word dosyayı açarken bir
hata mesajı gösterirse, o hata mesajına birkaç kez ‘tamam’ diyerek hata
penceresini kapatın. Dosya normal bir şekilde açılacaktır.

Dediğimiz gibi, bu kaçış dizisi artık pek kullanılmıyor. Ama yine de bu kaçış
dizisine karşı da uyanık olmalısınız. Çünkü bu kaçış dizisi de beklemediğiniz
çıktılar almanıza yol açabilir. Mesela şu örneğe bir bakalım:

```python
>>> "\fırat"

'\x0cırat'

```

Gördüğünüz gibi, siz aslında ‘\fırat’ yazmak isterken, Python bu kelimenin baş
tarafındaki\fkarakter dizisini bir kaçış dizisi olarak değerlendirip ona
göre bir çıktı verdi.

Bütün bu anlattıklarımızın ardından, kaçış dizilerinin, birleştirildikleri
karakterlerin farklı bir anlam yüklenmesini sağlayan birtakım işaretler olduğunu
anlıyoruz. Örneğin\işareti‘(tek tırnak) işareti ile bir araya gelerek,
tek tırnak işaretinin karakter dizisi tanımlama dışında başka bir anlam
yüklenmesini sağlıyor. Aynı şekilde yine\işareti“(çift tırnak) işareti
ile birleşerek çift tırnak işaretinin de karakter dizisi tanımlama dışında bir
anlama kavuşmasını sağlıyor. Böylece tırnak işaretlerini karakter dizileri
içinde rahatlıkla kullanabiliyoruz.

Ya da yine\işareti ‘n’ harfi ile bir araya gelip, bu harfin satır başına
geçilmesini sağlayan bir kaçış dizisi oluşturmasını mümkün kılıyor. Veya aynı
işaret ‘t’ harfiyle birleşip, öğeler arasında sekme oluşturulmasını
sağlayabiliyor. Bu araçlar sayesinde ekrana yazdırdığımız bir metnin akışını
kontrol etme imkanına kavuşuyoruz.

### Kaçış Dizilerine Toplu Bakış

Biraz sonra bu önemli konuyu kapatacağız. Ama dilerseniz kapatmadan önce, bu
bölümde öğrendiğimiz kaçış dizilerini şöyle bir topluca görelim:
| Kaçış Dizisi | Anlamı |
| --- | --- |
| \’ | Karakter dizisi içinde tek tırnak işaretini
kullanabilmemizi sağlar. |
| \” | Karakter dizisi içinde çift tırnak işaretini
kullanabilmemizi sağlar. |
| \\ | Karakter dizisi içinde\işaretini
kullanabilmemizi sağlar. |
| \n | Yeni bir satıra geçmemizi sağlar. |
| \t | Karakterler arasında sekme boşluğu
bırakmamızı sağlar. |
| \u | UNICODE kod konumlarını gösterebilmemizi
sağlar. |
| \U | UNICODE kod konumlarını gösterebilmemizi
sağlar. |
| \N | Karakterleri UNICODE adlarına göre
kullanabilmemizi sağlar. |
| \x | Onaltılı sistemdeki bir sayının karakter
karşılığını gösterebilmemizi sağlar. |
| \a | Destekleyen sistemlerde, kasa hoparlöründen
bir ‘bip’ sesi verilmesini sağlar. |
| \r | Aynı satırın başına dönülmesini sağlar. |
| \v | Destekleyen sistemlerde düşey sekme
oluşturulmasını sağlar. |
| \b | İmlecin sola doğru kaydırılmasını sağlar |
| \f | Yeni bir sayfaya geçilmesini sağlar. |
| r | Karakter dizisi içinde kaçış dizilerini
kullanabilmemizi sağlar. |

Kaçış Dizisi

Anlamı

\’

Karakter dizisi içinde tek tırnak işaretini
kullanabilmemizi sağlar.

\”

Karakter dizisi içinde çift tırnak işaretini
kullanabilmemizi sağlar.

\\

Karakter dizisi içinde\işaretini
kullanabilmemizi sağlar.

\n

Yeni bir satıra geçmemizi sağlar.

\t

Karakterler arasında sekme boşluğu
bırakmamızı sağlar.

\u

UNICODE kod konumlarını gösterebilmemizi
sağlar.

\U

UNICODE kod konumlarını gösterebilmemizi
sağlar.

\N

Karakterleri UNICODE adlarına göre
kullanabilmemizi sağlar.

\x

Onaltılı sistemdeki bir sayının karakter
karşılığını gösterebilmemizi sağlar.

\a

Destekleyen sistemlerde, kasa hoparlöründen
bir ‘bip’ sesi verilmesini sağlar.

\r

Aynı satırın başına dönülmesini sağlar.

\v

Destekleyen sistemlerde düşey sekme
oluşturulmasını sağlar.

\b

İmlecin sola doğru kaydırılmasını sağlar

\f

Yeni bir sayfaya geçilmesini sağlar.

r

Karakter dizisi içinde kaçış dizilerini
kullanabilmemizi sağlar.

Kaçış dizileriyle ilgili son olarak şunu söyleyebiliriz: Kaçış dizileri,
görmezden gelebileceğiniz, ‘öğrenmesem de olur,’ diyebileceğiniz önemsiz
birtakım işaretler değildir. Bu konu boyunca verdiğimiz örneklerden de
gördüğünüz gibi, kaçış dizileri, kullanıcıya göstereceğiniz metinlerin biçimini
doğrudan etkiliyor. Bütün bu örnekler, bu kaçış dizilerinin yersiz veya yanlış
kullanılmasının ya da bunların bir metin içinde gözden kaçmasının, yazdığınız
programların hata verip çökmesine, yani programınızın durmasına sebep
olabileceğini de gösteriyor bize.

Böylece bir bölümü daha bitirmiş olduk. Artık Python’la ‘gerçek’ programlar
yazmamızın önünde hiçbir engel kalmadı.

## Programları Kaydetme ve Çalıştırma

Bu noktaya kadar bütün işlerimizi Python’ın etkileşimli kabuğu üzerinden
hallettik. Her ne kadar etkileşimli kabuk son derece kullanışlı bir ortam da
olsa, bizim asıl çalışma alanımız değildir. Daha önce de dediğimiz gibi,
etkileşimli kabuğu genellikle ufak tefek Python kodlarını test etmek için
kullanacağız. Ama asıl programlarımızı tabii ki etkileşimli kabuğa değil,
program dosyasına yazacağız.

Ne dedik? Özellikle küçük kod parçaları yazıp bunları denemek için etkileşimli
kabuk mükemmel bir ortamdır. Ancak kodlar çoğalıp büyümeye başlayınca bu ortam
yetersiz gelmeye başlayacaktır. Üstelik tabii ki yazdığınız kodları bir yere
kaydedip saklamak isteyeceksiniz. İşte burada metin düzenleyiciler devreye
girecek.

Python kodlarını yazmak için istediğiniz herhangi bir metin düzenleyiciyi
kullanabilirsiniz. Hatta Notepad bile olur. Ancak Python kodlarını ayırt edip
renklendirebilen bir metin düzenleyici ile yola çıkmak her bakımdan hayatınızı
kolaylaştıracaktır.

> **Not**
> Python kodlarınızı yazmak için Microsoft Word veya OpenOffice.Org
OOWriter gibi, belgeleri ikili (binary) düzende kaydeden programlar uygun
değildir. Kullanacağınız metin düzenleyici, belgelerinizi düz metin (plain
text) biçiminde kaydedebilmeli.

Not

Python kodlarınızı yazmak için Microsoft Word veya OpenOffice.Org
OOWriter gibi, belgeleri ikili (binary) düzende kaydeden programlar uygun
değildir. Kullanacağınız metin düzenleyici, belgelerinizi düz metin (plain
text) biçiminde kaydedebilmeli.

Biz bu bölümde farklı işletim sistemlerinde, metin düzenleyici kullanılarak
Python programlarının nasıl yazılacağını ve bunların nasıl çalıştırılacağını tek
tek inceleyeceğiz.

Daha önce de söylediğimiz gibi, hangi işletim sistemini kullanıyor olursanız
olun, hem Windows hem de GNU/Linux başlığı altında yazılanları okumalısınız.

Dilerseniz önce GNU/Linux ile başlayalım:

### GNU/Linux

Eğer kullandığınız sistem GNU/Linux’ta Unity veya GNOME masaüstü ortamı ise
başlangıç düzeyi için Gedit adlı metin düzenleyici yeterli olacaktır.

Eğer kullandığınız sistem GNU/Linux’ta KDE masaüstü ortamı ise Kwrite veya Kate
adlı metin düzenleyicilerden herhangi birini kullanabilirsiniz. Şu aşamada
kullanım kolaylığı ve sadeliği nedeniyle Kwrite önerilebilir.

İşe yeni bir Gedit belgesi açarak başlayalım. Yeni bir Gedit belgesi açmanın en
kolay yoluAlt+F2tuşlarına bastıktan sonra çıkan ekranda:

```python
gedit

```

yazıpEnterdüğmesine basmaktır.

Eğer Gedit yerine mesela Kwrite kullanıyorsanız, yeni bir Kwrite belgesi
oluşturmak içinAlt+F2tuşlarına bastıktan sonra:

```python
kwrite

```

komutunu vermelisiniz. Elbette kullanacağınız metin düzenleyiciye, komut vermek
yerine, dağıtımınızın menüleri aracılığıyla da ulaşabilirsiniz.

Python kodlarımızı, karşımıza çıkan bu boş metin dosyasına yazıp kaydedeceğiz.

Aslında kodları metin dosyasına yazmakla etkileşimli kabuğa yazmak arasında çok
fazla fark yoktur. Dilerseniz hemen bir örnek vererek ne demek istediğimizi
anlatmaya çalışalım:

1. Boş bir Gedit ya da Kwrite belgesi açıyoruz ve bu belgeye şu kodları
eksiksiz bir şekilde yazıyoruz:

```python
tarih = "02.01.2012"
gün = "Pazartesi"
vakit = "öğleden sonra"

print(tarih, gün, vakit, "buluşalım", end=".\n")

```

2. Bu kodları yazıp bitirdikten sonra dosyayı masaüstünerandevu.pyadıyla
kaydedelim.

3. Sonra işletim sistemimize uygun bir şekilde komut satırına ulaşalım.

4. Ardından komut satırı üzerinden masaüstüne gelelim. (Bunun nasıl
yapılacağını hatırlıyorsunuz, değil mi?)

5. Son olarak şu komutla programımızı çalıştıralım:

```python
python3 randevu.py

```

Şöyle bir çıktı almış olmalıyız:

```python
02.01.2012 Pazartesi öğleden sonra buluşalım.

```

Eğer bu çıktı yerine bir hata mesajı alıyorsanız bunun birkaç farklı sebebi
olabilir:
1. Kodlarda yazım hatası yapmış olabilirsiniz. Bu ihtimali bertaraf etmek için
yukarıdaki kodlarla kendi yazdığınız kodları dikkatlice karşılaştırın.
1. Kodlarınızı kaydettiğinizrandevu.pyadlı dosyanın adını yanlış yazmış
olabilirsiniz. Dolayısıylapython3randevu.pykomutu, var olmayan bir dosyaya
atıfta bulunuyor olabilir.
1. python3randevu.pykomutunu verdiğiniz dizin konumu ilerandevu.pydosyasının bulunduğu dizin konumu birbirinden farklı olabilir. Yani sizrandevu.pydosyasını masaüstüne kaydetmişsinizdir, amapython3randevu.pykomutunu yanlışlıkla başka bir dizin altında veriyor olabilirsiniz. Bu ihtimali
ortadan kaldırmak için, önceki derslerde öğrendiğimiz yöntemleri kullanarak
hangi dizin altında bulunduğunuzu kontrol edin. O anda içinde bulunduğunuz
dizinin içeriğini listeleyerek,randevu.pydosyasının orada görünüp
görünmediğini kontrol edebilirsiniz. Eğer program dosyanız bu listede
görünmüyorsa, elbettepython3randevu.pykomutu çalışmayacaktır.
1. Geçen derslerde anlattığımız şekilde Python3’ü kaynaktanroothaklarıyla
derlemenize rağmen, derleme sonrasında/usr/bin/dizini altınapython3adlı
bir sembolik bağ oluşturmadığınız içinpython3komutu çalışmıyor olabilir.
1. Eğer Python3’ü yetkisiz kullanıcı olarak derlediyseniz,$HOME/python/bin/dizini altında hempython3adlı bir sembolik bağ oluşturmuş, hem de$HOME/python/bin/dizinini YOL’a (PATH) eklemiş olmanız gerekirken bunları
yapmamış olabilirsiniz.
1. Asla unutmayın, Python’ın etkileşimli kabuğunu başlatmak için hangi komutu
kullanıyorsanız,randevu.pydosyasını çalıştırmak için de aynı komutu
kullanacaksınız. Yani eğer Python’ın etkileşimli kabuğunupython3.7gibi bir
komutla çalıştırıyorsanız, programınızı dapython3.7randevu.pyşeklinde
çalıştırmanız gerekir. Aynı şekilde, eğer etkileşimli kabuğu meselapython(veyapy3) gibi bir komutla çalıştırıyorsanız, programınızı dapythonrandevu.py(veyapy3randevu.py) şeklinde çalıştırmalısınız. Neticede
etkileşimli kabuğu çalıştırırken de, bir program dosyası çalıştırırken de
aslında temel olarak Python programlama dilini çalıştırmış oluyorsunuz. Python
programını çalıştırırken bir dosya adı belirtmezseniz, yani Python’ı başlatan
komutu tek başına kullanırsanız etkileşimli kabuk çalışmaya başlar. Ama eğer
Python’ı başlatan komutla birlikte bir program dosyası ismi de belirtirseniz, o
belirttiğiniz program dosyası çalışmaya başlar.

Kodlarda yazım hatası yapmış olabilirsiniz. Bu ihtimali bertaraf etmek için
yukarıdaki kodlarla kendi yazdığınız kodları dikkatlice karşılaştırın.

Kodlarınızı kaydettiğinizrandevu.pyadlı dosyanın adını yanlış yazmış
olabilirsiniz. Dolayısıylapython3randevu.pykomutu, var olmayan bir dosyaya
atıfta bulunuyor olabilir.

python3randevu.pykomutunu verdiğiniz dizin konumu ilerandevu.pydosyasının bulunduğu dizin konumu birbirinden farklı olabilir. Yani sizrandevu.pydosyasını masaüstüne kaydetmişsinizdir, amapython3randevu.pykomutunu yanlışlıkla başka bir dizin altında veriyor olabilirsiniz. Bu ihtimali
ortadan kaldırmak için, önceki derslerde öğrendiğimiz yöntemleri kullanarak
hangi dizin altında bulunduğunuzu kontrol edin. O anda içinde bulunduğunuz
dizinin içeriğini listeleyerek,randevu.pydosyasının orada görünüp
görünmediğini kontrol edebilirsiniz. Eğer program dosyanız bu listede
görünmüyorsa, elbettepython3randevu.pykomutu çalışmayacaktır.

Geçen derslerde anlattığımız şekilde Python3’ü kaynaktanroothaklarıyla
derlemenize rağmen, derleme sonrasında/usr/bin/dizini altınapython3adlı
bir sembolik bağ oluşturmadığınız içinpython3komutu çalışmıyor olabilir.

Eğer Python3’ü yetkisiz kullanıcı olarak derlediyseniz,$HOME/python/bin/dizini altında hempython3adlı bir sembolik bağ oluşturmuş, hem de$HOME/python/bin/dizinini YOL’a (PATH) eklemiş olmanız gerekirken bunları
yapmamış olabilirsiniz.

Asla unutmayın, Python’ın etkileşimli kabuğunu başlatmak için hangi komutu
kullanıyorsanız,randevu.pydosyasını çalıştırmak için de aynı komutu
kullanacaksınız. Yani eğer Python’ın etkileşimli kabuğunupython3.7gibi bir
komutla çalıştırıyorsanız, programınızı dapython3.7randevu.pyşeklinde
çalıştırmanız gerekir. Aynı şekilde, eğer etkileşimli kabuğu meselapython(veyapy3) gibi bir komutla çalıştırıyorsanız, programınızı dapythonrandevu.py(veyapy3randevu.py) şeklinde çalıştırmalısınız. Neticede
etkileşimli kabuğu çalıştırırken de, bir program dosyası çalıştırırken de
aslında temel olarak Python programlama dilini çalıştırmış oluyorsunuz. Python
programını çalıştırırken bir dosya adı belirtmezseniz, yani Python’ı başlatan
komutu tek başına kullanırsanız etkileşimli kabuk çalışmaya başlar. Ama eğer
Python’ı başlatan komutla birlikte bir program dosyası ismi de belirtirseniz, o
belirttiğiniz program dosyası çalışmaya başlar.

Kodlarınızı düzgün bir şekilde çalıştırabildiğinizi varsayarak yolumuza devam
edelim…

Gördüğünüz gibi, kod dosyamızı çalıştırmak içinpython3komutundan
yararlanıyoruz. Bu arada tekrar etmekte fayda var: Python’ın etkileşimli
kabuğunu çalıştırmak için hangi komutu kullanıyorsanız, dosyaya kaydettiğiniz
programlarınızı çalıştırmak için de aynı komutu kullanacaksınız.

Gelelim Windows kullanıcılarına…

### Windows

Daha önce de söylediğimiz gibi, Python kodlarımızı yazmak için istediğimiz bir
metin düzenleyiciyi kullanabiliriz. Hatta Notepad’i bile kullansak olur. Ancak
Notepad’den biraz daha gelişmiş bir metin düzenleyici ile başlamak işinizi
kolaylaştıracaktır.

Python programlama dilini öğrenmeye yeni başlayan Windows kullanıcıları için en
uygun metin düzenleyici IDLE’dır.Başlat > Tüm Programlar > Python3.7> IDLE (Python GUI)yolunu takip ederek IDLE’a
ulaşabilirsiniz.

IDLE’ı açtığınızda şöyle bir ekranla karşılaşacaksınız:

Aslında bu ekran size bir yerlerden tanıdık geliyor olmalı. Dikkat ederseniz
beyaz ekranın en sonunda bordo renkli bir>>>işareti var. Evet, tahmin
ettiğiniz gibi, burası aslında Python’ın etkileşimli kabuğudur. Yani o siyah
etkileşimli kabuk ekranında ne yapabilirseniz burada da aynı şeyi
yapabilirsiniz. Dilerseniz kendi kendinize bazı denemeler yapın. Ama şu anda biz
IDLE’ın bu özelliğini değil, metin düzenleyici olma özelliğini kullanacağız. O
yüzden yolumuza devam ediyoruz.

> **Not**
> Dediğimiz gibi, yukarıda görünen ekran aslında Python’ın
etkileşimli kabuğudur. Dolayısıyla biraz sonra göstereceğimiz kodları buraya
yazmayacağız. Python programlama diline yeni başlayanların en sık yaptığı
hatalardan biri de, kaydetmek istedikleri kodları yukarıda görünen ekrana
yazmaya çalışmalarıdır. Unutmayın, Python’ın etkileşimli kabuğunda ne
yapabiliyorsanız, IDLE’ı açtığınızda ilk karşınıza çıkan ekranda da onu
yapabilirsiniz. Python’ın etkileşimli kabuğunda yazdığınız kodlar etkileşimli
kabuğu kapattığınızda nasıl kayboluyorsa, yukarıdaki ekrana yazdığınız kodlar da
IDLE’ı kapattığınızda kaybolur…

Not

Dediğimiz gibi, yukarıda görünen ekran aslında Python’ın
etkileşimli kabuğudur. Dolayısıyla biraz sonra göstereceğimiz kodları buraya
yazmayacağız. Python programlama diline yeni başlayanların en sık yaptığı
hatalardan biri de, kaydetmek istedikleri kodları yukarıda görünen ekrana
yazmaya çalışmalarıdır. Unutmayın, Python’ın etkileşimli kabuğunda ne
yapabiliyorsanız, IDLE’ı açtığınızda ilk karşınıza çıkan ekranda da onu
yapabilirsiniz. Python’ın etkileşimli kabuğunda yazdığınız kodlar etkileşimli
kabuğu kapattığınızda nasıl kayboluyorsa, yukarıdaki ekrana yazdığınız kodlar da
IDLE’ı kapattığınızda kaybolur…

Bir önceki ekranda sol üst köşedeFile[Dosya] menüsü görüyorsunuz. Oraya
tıklayın ve menü içindekiNew Window[Yeni Pencere] düğmesine basın. Şöyle bir
ekranla karşılaşacaksınız:

İşte Python kodlarımızı bu beyaz ekrana yazacağız. Şimdi bu ekrana şu satırları
yazalım:

```python
tarih = "02.01.2012"
gün = "Pazartesi"
vakit = "öğleden sonra"

print(tarih, gün, vakit, "buluşalım", end=".\n")

```

Bu noktadan sonra yapmamız gereken şey dosyamızı kaydetmek olacak. Bunun içinFile > Save asyolunu takip ederek programımızı masaüstünerandevu.pyadıyla
kaydediyoruz.

Şu anda programımızı yazdık ve kaydettik. Artık programımızı çalıştırabiliriz.
Bunun için IDLE’daRun > Run Moduleyolunu takip etmeniz veya kısacaF5tuşuna basmanız yeterli olacaktır. Bu iki yöntemden birini kullanarak
programınızı çalıştırdığınızda şöyle bir çıktı elde edeceksiniz:

```python
02.01.2012 Pazartesi öğleden sonra buluşalım.

```

Tebrikler! İlk Python programınızı yazıp çalıştırdınız… Eğer
çalıştıramadıysanız veya yukarıdaki çıktı yerine bir hata mesajı aldıysanız
muhtemelen kodları yazarken yazım hatası yapmışsınızdır. Kendi yazdığınız
kodları buradaki kodlarla dikkatlice karşılaştırıp tekrar deneyin.

Şimdi gelin isterseniz yukarıda yazdığımız kodları şöyle bir kısaca inceleyelim.

Programımızda üç farklı değişken tanımladığımıza dikkat edin. Bu değişkenlertarih,günvevakitadlı değişkenlerdir. Daha sonra bu değişkenleri
birbiriyle birleştiriyoruz. Bunun içinprint()fonksiyonundan nasıl
yararlandığımızı görüyorsunuz. Ayrıcaprint()fonksiyonunu kullanış
biçimimize de dikkat edin. Buradakiendparametresinin anlamını ve bunun ne
işe yaradığını artık gayet iyi biliyorsunuz.endparametresi yardımıyla
cümlenin en sonuna bir adet nokta yerleştirip,\nadlı kaçış dizisi
yardımıyla da bir alt satıra geçiyoruz.

Böylece basit bir Python programının temel olarak nasıl yazılıp bir dosyaya
kaydedileceğini ve bu programın nasıl çalıştırılacağını öğrenmiş olduk.

## Çalışma Ortamı Tavsiyesi

Bu bölümde, Python programları geliştirirken rahat bir çalışma ortamı elde
edebilmek için yapmanız gerekenleri sıralayacağız. Öncelikle Windows
kullanıcılarından başlayalım.

### Windows Kullanıcıları

Windows’ta bir Python programı yazıp kaydettikten sonra bu programı komut
satırından çalıştırabilmek için, MS-DOS’u açıp, önceliklecdkomutuyla
programın bulunduğu dizine ulaşmamız gerekir. İlgili dizine ulaştıktan sonra
programımızıpythonprogram_adıkomutuyla çalıştırabiliriz. Ancak bir süre
sonra, programı çalıştırmak için her defasında programın bulunduğu dizine
ulaşmaya çalışmak sıkıcı bir hal alacaktır. Ama bu konuda çaresiz değiliz.

Windows 7, istediğimiz dizin altında bir MS-DOS ekranı açabilmemiz için bize çok
güzel bir kolaylık sunuyor. Normal şartlar altında mesela masaüstünde bir MS-DOS
ekranı açabilmek için şu yolu izlemeniz gerekiyor:
1. Windows logolu tuşa veRtuşuna birlikte bas,
1. Açılan pencereyecmdyazıpEnterdüğmesine bas,
1. Bu şekilde ulaştığın MS-DOS ekranındacdDesktopkomutunu ver.

Windows logolu tuşa veRtuşuna birlikte bas,

Açılan pencereyecmdyazıpEnterdüğmesine bas,

Bu şekilde ulaştığın MS-DOS ekranındacdDesktopkomutunu ver.

Bu üç adımla, MS-DOS ekranı üzerinden masaüstüne ulaşmış oluyoruz. Ama aslında
bunun çok daha kolay bir yolu var: Masaüstüne sağ tıklarkenShifttuşunu da
basılı tutarsanız, sağ-tık menüsünde ‘Komut penceresini burada aç’ adlı bir
satır görürsünüz. İşte bu satıra tıklayarak, MS-DOS komut satırını tek harekette
masaüstü konumunda çalıştırabilirsiniz. Elbette bu özellik sadece masaüstü için
değil, bütün konumlar için geçerlidir. Yani bilgisayarınızda herhangi bir yere
sağ tıklarkenShifttuşunu da basılı tutarak o konumda bir MS-DOS penceresi
açabilirsiniz.

Ayrıca, herhangi bir klasör açıkken dosya tarayıcısının adres çubuğunacmdyazıpEnterdüğmesine basarak da, o klasörün bulunduğu konumda bir komut
ekranı açabilirsiniz. Örneğin eğer o anda önünüzde ‘İndirilenler’ (veya
‘Karşıdan Yüklenenler’) dizini açıksa, adres çubuğuna (aşağıdaki resimde kırmızı
ile gösterilen bölge)cmdyazarakC:\Users\Kullanıcı\Downloads>konumunda bir komut ekranı açabilirsiniz.

İkinci olarak, çalışma kolaylığı açısından Windows’ta dosya uzantılarının her
zaman görünmesini sağlamanızı da tavsiye ederim. Windows ilk kurulduğunda hiçbir
dosyanın uzantısı görünmez. Yani meseladeneme.txtadlı bir dosya Windows ilk
kurulduğundadenemeşeklinde görünecektir. Bu durumda, bir dosyanın uzantısını
değiştirmek istediğinizde bazı sıkıntılar yaşarsınız. Örneğin, masaüstünde bir
metin dosyası oluşturduğunuzu varsayalım. Diyelim ki amacınız bu dosyanın içine
bir şeyler yazıp daha sonra mesela bu dosyanın uzantısını.batveya.pyyapmak olsun. Böyle bir durumda, dosya uzantılarını göremediğiniz için, metin
dosyasının uzantısını değiştirmeye çalıştığınızdadeneme.bat.txtgibi bir
dosya adı elde edebilirsiniz. Tabii ki bu dosya bir.batdosyası değil, bir.txt, yani metin dosyasıdır. Dolayısıyla aslında dosya uzantısını
değiştirememiş oluyorsunuz.

Yukarıdaki nedenlerden ötürü, ben size şu yolu takip ederek dosya uzantılarını
her zaman görünür hale getirmenizi öneririm:
1. Başlat > Denetim Masasıyolunu takip ederek denetim masasına ulaşın,
1. Denetim masasında ‘Görünüm ve Kişiselleştirme’ seçeneğine tıklayın,
1. Açılan menünün sağ tarafında ‘Klasör Seçenekleri’ satırına tıklayın,
1. Açılan pencerede ‘Görünüm’ sekmesine tıklayın,
1. ‘Gelişmiş Ayarlar’ listesinde ‘Bilinen dosya türleri için uzantıları gizle’
seçeneğinin yanındaki onay işaretini kaldırın,
1. UygulaveTamamdüğmelerine basarak bütün pencereleri kapatın,
1. Artık bütün dosyalarınızın uzantısı da görüneceği için, uzantı değiştirme
işlemlerini çok daha kolay bir şekilde halledebilirsiniz.

Başlat > Denetim Masasıyolunu takip ederek denetim masasına ulaşın,

Denetim masasında ‘Görünüm ve Kişiselleştirme’ seçeneğine tıklayın,

Açılan menünün sağ tarafında ‘Klasör Seçenekleri’ satırına tıklayın,

Açılan pencerede ‘Görünüm’ sekmesine tıklayın,

‘Gelişmiş Ayarlar’ listesinde ‘Bilinen dosya türleri için uzantıları gizle’
seçeneğinin yanındaki onay işaretini kaldırın,

UygulaveTamamdüğmelerine basarak bütün pencereleri kapatın,

Artık bütün dosyalarınızın uzantısı da görüneceği için, uzantı değiştirme
işlemlerini çok daha kolay bir şekilde halledebilirsiniz.

### GNU/Linux Kullanıcıları

Eğer KDE temelli bir GNU/Linux dağıtımı kullanıyorsanız, yazıp kaydettiğiniz
Python programını barındıran dizin açıkkenF4tuşuna bastığınızda, komut
satırı o dizin altında açılacaktır.

Unity ve GNOME kullanıcılarının ise benzer bir kolaylığa ulaşmak için
nautilus-open-terminal adlı betiği sistemlerine kurmaları gerekiyor. Eğer Ubuntu
kullanıyorsanız bu betiği şu komutla kurabilirsiniz:

```python
sudo apt-get install nautilus-open-terminal

```

Bu betiği kurduktan sonra bilgisayarınızı yeniden başlatın veya şu komutu
verin:

```python
killall nautilus

```

Artık komut satırını hangi dizin altında başlatmak istiyorsanız o dizine sağ
tıklayın. Menüler arasındaOpen in Terminal[Uçbirimde aç] adlı bir seçenek
göreceksiniz. Buna tıkladığınızda o dizin altında bir komut satırı penceresi
açılacaktır.

### Metin Düzenleyici Ayarları

Daha önce de söylediğimiz gibi, Python ile program yazmak için istediğiniz metin
düzenleyiciyi kullanabilirsiniz. Ama kodlarınızın kusursuz görünmesi ve hatasız
çalışması için kullandığınız metin düzenleyicide birtakım ayarlamalar yapmanız
gerekir. İşte bu bölümde bu ayarların neler olduğunu göstereceğiz.

Eğer programlarınızı IDLE ile yazıyorsanız aslında bir şey yapmanıza gerek yok.
IDLE Python ile program yazmak üzere tasarlanmış bir düzenleyici olduğu için bu
programın bütün ayarları Python ile uyumludur. Ama eğer IDLE dışında bir metin
düzenleyici kullanıyorsanız bu düzenleyicide temel olarak şu ayarları yapmanız
gerekir:
1. Sekme genişliğini [TAB width] 4 olarak ayarlayın.
1. Girinti genişliğini [Indent width] 4 olarak ayarlayın.
1. Girintilemede sekme yerine boşluk kullanmayı tercih edin [Use spaces instead
of tabs]
1. Tercih edilen kodlama biçimini [Preferred encoding] utf-8 olarak ayarlayın.

Sekme genişliğini [TAB width] 4 olarak ayarlayın.

Girinti genişliğini [Indent width] 4 olarak ayarlayın.

Girintilemede sekme yerine boşluk kullanmayı tercih edin [Use spaces instead
of tabs]

Tercih edilen kodlama biçimini [Preferred encoding] utf-8 olarak ayarlayın.

Özellikle son söylediğimiz ‘kodlama biçimi’ ayarı çok önemlidir. Bu ayarın
yanlış olması halinde, yazdığınız programı çalıştırmak istediğinizde şöyle bir
hata alabilirsiniz:

```python
SyntaxError: Non-UTF-8 code starting with '\xfe' in file deneme.py on line 1,
but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details

```

Eğer yazdığınız bir program böyle bir hata mesajı üretiyorsa, ilk olarak metin
düzenleyicinizin kodlama biçimi (encoding) ayarlarını kontrol edin. Metin
düzenleyiciler genellikle tercih edilen kodlama biçimini aşağıdaki örnek resimde
görüldüğü gibi, durum çubuğunda sürekli olarak gösterir.

Ancak kodlama biçimi doğru bir şekilde utf-8 olarak ayarlanmış metin
düzenleyicilerde, özellikle internet üzerinden kod kopyalanıp yapıştırılması
sırasında bu ayar siz farkında olmadan değişebilir. Böyle bir durumda da program
çalışırken yukarıda bahsedilen hatayı alabilirsiniz. Dolayısıyla, programınızı
yazdığınız metin düzenleyicinin kodlama ayarlarının siz farkında olmadan değişme
ihtimaline karşı uyanık olmanız gerekir.

Elbette piyasada yüzlerce metin düzenleyici olduğu için yukarıda bahsedilen
ayarların her metin düzenleyicide nasıl yapılacağını tek tek göstermemiz mümkün
değil. Ancak iyi bir metin düzenleyicide yukarıdaki ayarların hepsi bulunur. Tek
yapmanız gereken, bu ayarların, kullandığınız metin düzenleyicide nereden
yapıldığını bulmak. Eğer kullandığınız metin düzenleyiciyi ayarlamakta
zorlanıyorsanız, her zamanki gibiyazbeladresinde sıkıntınızı dile getirebilirsiniz.

‘Kodlama biçimi’ kavramından söz etmişken, Python’la ilgili önemli bir konuya
daha değinelim. En başta da söylediğimiz gibi, şu anda piyasada Python iki
farklı seri halinde geliştiriliyor. Bunlardan birinin 2.x serisi, öbürünün de
3.x serisi olduğunu biliyoruz. Python’ın 2.x serisinde Türkçe karakterlerin
gösterimi ile ilgili çok ciddi problemler vardı. Örneğin Python’ın 2.x serisinde
şöyle bir kod yazamıyorduk:

```python
print("Günaydın Şirin Baba!")

```

Bu kodu bir dosyaya kaydedip, Python’ın 2.x serisine ait bir sürümle çalıştırmak
istediğimizde Python bize şöyle bir hata mesajı veriyordu:

```python
SyntaxError: Non-ASCII character '\xc3' in file
test.py on line 1, but no encoding declared;
see http://www.python.org/peps/pep-0263.html for details

```

Bunun sebebi, Python’ın 2.x sürümlerindeASCIIadlı kodlama biçiminin
kullanılıyor olmasıdır. Zaten hata mesajına baktığımızda da, Python’ın ASCII
olmayan karakterlerin varlığından şikayet ettiğini görüyoruz.

Yukarıdaki kodların çalışabilmesi için programımıza şöyle bir ekleme yapmamız
gerekiyordu:

```python
# -*- coding: utf-8 -*-
print("Günaydın Şirin Baba!")

```

Buradaki ilk satıra dikkat edin. Bu kodlarla yaptığımız şey, Python’ınASCIIadlı kodlama biçimi yerineUTF-8adlı kodlama biçimini kullanmasını
sağlamaktır.ASCIIadlı kodlama biçimi Türkçe karakterleri gösteremez, amaUTF-8adlı kodlama biçimi Türkçe karakterleri çok rahat bir şekilde
gösterebilir.

> **Not**
> Kodlama biçimlerinden, ileride ayrıntılı bir şekilde söz edeceğiz. O
yüzden bu anlattıklarımızda eğer anlamadığınız yerler olursa bunlara takılmanıza
gerek yok.

Not

Kodlama biçimlerinden, ileride ayrıntılı bir şekilde söz edeceğiz. O
yüzden bu anlattıklarımızda eğer anlamadığınız yerler olursa bunlara takılmanıza
gerek yok.

Python’ın 3.x serisinin gelişi ile birlikte Python’da öntanımlı olarakASCIIyerineUTF-8kodlama biçimi kullanılmaya başlandı. Dolayısıyla yazdığımız
programlara#-*-coding:utf-8-*-satırını eklememize gerek kalmadı. Çünkü
zaten PythonUTF-8kodlama biçimini öntanımlı olarak kendisi kullanıyor. Ama
eğerUTF-8dışında başka bir kodlama biçimine ihtiyaç duyarsanız yine bu
satırdan yararlanabilirsiniz.

Örneğin GNU/Linux dağıtımlarının geleneksel olarak UTF-8 kodlama biçimi ile
arası iyidir. Dolayısıyla eğer GNU/Linux üzerinde Python programları
geliştiriyorsanız bu satırı hiç yazmadan bir ömür geçirebilirsiniz. Ama Windows
işletim sistemleriUTF-8’i desteklemekle birlikte, bu destek GNU/Linux’taki
kadar iyi değildir. Dolayısıyla zaman zaman Windows’taUTF-8dışında başka bir
kodlama biçimini kullanmanız gerekebilir. Örneğin yazdığınız bir programda
Türkçe karakterleri göremiyorsanız, programınızın ilk satırını şöyle
düzenleyebilirsiniz:

```python
# -*- coding: cp1254 -*-

```

BuradaUTF-8yerinecp1254adlı kodlama biçimini kullanmış oluyoruz. Windows
işletim sistemindecp1254adlı kodlama biçimiUTF-8’e kıyasla daha fazla
desteklenir.

### MS-DOS Komut Satırı Ayarları

Eğer yukarıda anlattığımız bütün ayarları doğru bir şekilde yapmanıza rağmen,
özellikle MS-DOS komut satırında hala Türkçe karakterleri düzgün
görüntüleyemiyorsanız, kullandığınız Windows sürümünün komut satırı, öntanımlı
olarak Türkçe karakterleri gösteremeyen bir yazı tipine ayarlanmış olabilir.
Dolayısıyla Türkçe karakterleri gösterebilmek için öncelikle uygun bir yazı tipi
seçmeniz gerekir. Bunun için şu basamakları takip ediyoruz:
1. Komut satırını açıyoruz,
1. Açılan pencerenin başlık çubuğuna sağ tıklayarak, ‘özellikler’ menüsüne
giriyoruz,
1. ‘Yazı tipi’ sekmesinde yazı tipi olarak ‘Lucida Console’u (veya varsa
‘Consolas’ı) seçiyoruz,
1. ‘Tamam’ düğmesine basıyoruz.
1. Eğer önünüze bir onay penceresi açılırsa, ‘Özellikleri aynı başlıkla ileride
oluşturulacak pencereler için kaydet’ seçeneğini işaretleyip ‘Tamam’a bastıktan
sonra çıkıyoruz.
1. Bu işlemin nasıl yapılacağını gösteren bir videoyuhttp://media.istihza.com/videos/ms-dos.swfadresinden izleyebilirsiniz.

Komut satırını açıyoruz,

Açılan pencerenin başlık çubuğuna sağ tıklayarak, ‘özellikler’ menüsüne
giriyoruz,

‘Yazı tipi’ sekmesinde yazı tipi olarak ‘Lucida Console’u (veya varsa
‘Consolas’ı) seçiyoruz,

‘Tamam’ düğmesine basıyoruz.

Eğer önünüze bir onay penceresi açılırsa, ‘Özellikleri aynı başlıkla ileride
oluşturulacak pencereler için kaydet’ seçeneğini işaretleyip ‘Tamam’a bastıktan
sonra çıkıyoruz.

Bu işlemin nasıl yapılacağını gösteren bir videoyuhttp://media.istihza.com/videos/ms-dos.swfadresinden izleyebilirsiniz.

Böylece MS-DOS komut satırı için Türkçe karakterleri gösterebilen bir yazı tipi
belirlemiş olduk. Ancak bu, Türkçe karakterleri düzgün görüntülemeye
yetmeyebilir. Eğer Türkçe karakterler hala düzgün görünmüyorsa, kullandığınız
sistemde MS-DOS’un dil kodlaması Türkçe karakterleri görüntülemeye uygun
olmayabilir. Türkçe karakterleri gösterebilen bir dil kodlaması belirlemek için
komut satırında şu komutu verin:

```python
chcp 1254

```

CP1254, Türkçe karakterleri de içeren bir dil kodlamasıdır. Bu komutu
verdikten sonra artık Türkçe karakterleri düzgün görüntüleyebiliyor olmanız
lazım.

### Program Örnekleri

Yukarıda Python ve programlamaya ilişkin pek çok teknik bilgi verdik. Bunları
öğrenmemiz, işlerimizi kuru kuruya ezberleyerek değil, anlayarak yapmamızı
sağlaması açısından büyük önem taşıyordu. Ancak yukarıda pratiğe yönelik pek bir
şey sunamadık. İşte bu bölümde pratik eksikliğimizi biraz olsun kapamaya dönük
örnekler yapacağız.

Hatırlarsanız Python’la tanışmamızı sağlayan ilk örneğimiz ekrana basit bir“Merhaba Zalim Dünya!”cümlesi yazdırmaktı. Bu ilk örneği etkileşimli kabukta
verdiğimizi hatırlıyorsunuz:

```python
>>> "Merhaba Zalim Dünya!"

```

Ama artık programlarımızı dosyaya kaydetmeyi öğrendiğimize göre bu kodları
etkileşimli kabuğa yazmak yerine bir dosyaya yazmayı tercih edebiliriz. Bu
sayede yazdığımız kodlar kalıcılık kazanacaktır.

Hemen bir deneme yapalım. Boş bir metin belgesi açıp oraya şu satırı yazalım:

```python
"Merhaba Zalim Dünya!"

```

Şimdi de bu dosyayı daha önce anlattığımız şekilde masaüstünedeneme.pyadıyla
kaydedip programımızı çalıştıralım.

Ne oldu? Programınız hiçbir çıktı vermeden kapandı, değil mi?

Hemen hatırlayacağınız gibi,print()fonksiyonu içine alınmayan ifadelerin
ekrana çıktı olarak verilebilmesi sadece etkileşimli kabuğa özgü bir durumdur.
Programlarımızı dosyadan çalıştırırken,print()fonksiyonu içine alınmayan
ifadeler ekranda görünmeyecektir. Yukarıdaki örnek bu durumun bir göstergesidir.
Dolayısıyla yukarıdaki ifadenin ekrana çıktı olarak verilebilmesi için o kodu
şöyle yazmamız gerekiyor:

```python
print("Merhaba Zalim Dünya!")

```

Programınızı bu şekilde tekrar çalıştırdığınızda şöyle bir çıktı alıyoruz:

```python
Merhaba Zalim Dünya!

```

Bu oldukça basit bir örnekti. Şimdi biraz daha karmaşık bir örnek verelim.

Yine hatırlayacağınız gibi, önceki bölümlerden birinde aylık yol masrafımızı
hesaplayan bir program yazmıştık.

Orada elimizdeki verilerin şunlar olduğunu varsaymıştık:
1. Cumartesi-Pazar günleri çalışmıyoruz.
1. Dolayısıyla ayda22gün çalışıyoruz.
1. Evden işe gitmek için kullandığımız vasıtanın ücreti1.5TL
1. İşten eve dönmek için kullandığımız vasıtanın ücreti1.4TL

Cumartesi-Pazar günleri çalışmıyoruz.

Dolayısıyla ayda22gün çalışıyoruz.

Evden işe gitmek için kullandığımız vasıtanın ücreti1.5TL

İşten eve dönmek için kullandığımız vasıtanın ücreti1.4TL

Elimizdeki bu bilgilere göre aylık yol masrafımızı hesaplamak için de şöyle bir
formül üretmiştik:

```python
masraf = gün sayısı x (gidiş ücreti + dönüş ücreti)

```

Gelin şimdi yukarıdaki bilgileri kullanarak programımızı dosyaya yazalım:

```python
gün = 22
gidiş_ücreti = 1.5
dönüş_ücreti = 1.4

masraf = gün * (gidiş_ücreti + dönüş_ücreti)

print(masraf)

```

Tıpkı öncekiler gibi, bu programı da masaüstünedeneme.pyadıyla kaydedelim ve
komut satırında masaüstünün bulunduğu konuma giderekpython3deneme.pykomutuyla programımızı çalıştıralım. Programı çalıştırdığımızda şöyle bir çıktı
alıyoruz:

```python
63.8

```

Programımız gayet düzgün çalışıyor. Ancak gördüğünüz gibi, elde ettiğimiz çıktı
çok yavan. Ama eğer isterseniz yukarıdaki programa daha profesyonel bir görünüm
de kazandırabilirsiniz. Dikkatlice inceleyin:

```python
gün = 22
gidiş_ücreti = 1.5
dönüş_ücreti = 1.4

masraf = gün * (gidiş_ücreti + dönüş_ücreti)

print("-"*30)
print("çalışılan gün sayısı\t:", gün)
print("işe gidiş ücreti\t:", gidiş_ücreti)
print("işten dönüş ücreti\t:", dönüş_ücreti)
print("-"*30)

print("AYLIK YOL MASRAFI\t:", masraf)

```

Bu defa programımız şöyle bir çıktı verdi:

```python
------------------------------
çalışılan gün sayısı : 22
işe gidiş ücreti : 1.5
işten dönüş ücreti : 1.4
------------------------------
AYLIK YOL MASRAFI : 63.8

```

Gördüğünüz gibi, bu kodlar sayesinde kullanıcıya daha ayrıntılı bilgi vermiş
olduk. Üstelik elde ettiğimiz çıktı daha şık görünüyor.

Yukarıdaki kodlarda şimdiye kadar öğrenmediğimiz hiçbir şey yok. Yukarıdaki
kodların tamamını anlayabilecek kadar Python bilgimiz var. Bu kodlarda çok basit
parçaları bir araya getirerek istediğimiz çıktıyı nasıl elde ettiğimizi
dikkatlice inceleyin. Mesela elde etmek istediğimiz çıktının görünüşünü
güzelleştirmek için iki yerde şu satırı kullandık:

```python
print("-"*30)

```

Böylece30adet-işaretini yan yana basmış olduk. Bu sayede elde ettiğimiz
çıktı daha derli toplu bir görünüme kavuştu. Ayrıca kodlarımız içinde\tadlı
kaçış dizisinden de yararlandık. Böylelikle ekrana basılan çıktılar alt alta
düzgün bir şekilde hizalanmış oldu.

Bu arada, yukarıdaki kodlar sayesinde değişken kullanımının işlerimizi ne kadar
kolaylaştırdığına da birebir tanık olduk. Eğer değişkenler olmasaydı yukarıdaki
kodları şöyle yazacaktık:

```python
print("-"*30)
print("çalışılan gün sayısı\t:", 22)
print("işe gidiş ücreti\t:", 1.5)
print("işten dönüş ücreti\t:", 1.4)
print("-"*30)

print("AYLIK YOL MASRAFI\t:", 22 * (1.5 + 1.4))

```

Eğer günün birinde mesela çalışılan gün sayısı değişirse yukarıdaki kodların iki
farklı yerinde değişiklik yapmamız gerekecekti. Bu kodların çok büyük bir
programın parçası olduğunu düşünün. Kodların içinde değer arayıp bunları tek tek
değiştirmeye kalkışmanın ne kadar hataya açık bir yöntem olduğunu tahmin
edebilirsiniz. Ama değişkenler sayesinde, sadece tek bir yerde değişiklik
yaparak kodlarımızı güncel tutabiliriz. Mesela çalışılan gün sayısı20’ye
düşmüş olsun:

```python
gün = 20
gidiş_ücreti = 1.5
dönüş_ücreti = 1.4

masraf = gün * (gidiş_ücreti + dönüş_ücreti)

print("-"*30)
print("çalışılan gün sayısı\t:", gün)
print("işe gidiş ücreti\t:", gidiş_ücreti)
print("işten dönüş ücreti\t:", dönüş_ücreti)
print("-"*30)

print("AYLIK YOL MASRAFI\t:", masraf)

```

Gördüğünüz gibi, sadece en baştakigünadlı değişkenin değerini değiştirerek
istediğimiz sonucu elde ettik.

Kendiniz isterseniz yukarıdaki örnekleri çeşitlendirebilirsiniz.

Gördüğünüz gibi, Python’da az da olsa işe yarar bir şeyler yazabilmek için çok
şey bilmemize gerek yok. Sırf şu ana kadar öğrendiklerimizi kullanarak bile ufak
tefek programlar yazabiliyoruz.

## Yorum ve Açıklama Cümleleri

Python’la ilgili şimdiye kadar öğrendiğimiz bilgileri kullanarak yazabileceğimiz
en karmaşık programlardan biri herhalde şöyle olacaktır:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"

print("isim : ", isim, "\n",
 "soyisim : ", soyisim, "\n",
 "işletim sistemi: ", işsis, "\n",
 "şehir : ", şehir, "\n",
 sep="")

```

Yukarıdaki kodları rahatlıkla anlayabildiğinizi zannediyorum. Ama isterseniz
yine de bu kodları satır satır inceleyelim:

İlk olarakisim,soyisim,işsisveşehiradında dört farklı değişken
tanımladık. Bu değişkenlerin değeri sırasıylaFırat,Özgül,Ubuntuveİstanbul.

Daha sonra da tanımladığımız bu değişkenleri belli bir düzen içinde
kullanıcılarımıza gösterdik, yani ekrana yazdırdık. Elbette bu iş içinprint()fonksiyonunu kullandık. Bildiğiniz gibi,print()birden fazla
parametre alabilen bir fonksiyondur. Yaniprint()fonksiyonunun parantezleri
içine istediğimiz sayıda öğe yazabiliriz.

Eğerprint()fonksiyonunun yukarıdaki kullanımı ilk bakışta gözünüze
anlaşılmaz göründüyse, fonksiyonda geçen ve ne işe yaradığını anlayamadığınız
öğeleri, bir de çıkartarak yazmayı deneyebilirsiniz bu fonksiyonu.

Python’la yazılmış herhangi bir programın tam olarak nasıl işlediğini anlamanın
en iyi yolu program içindeki kodlarda bazı değişiklikler yaparak ortaya çıkan
sonucu incelemektir. Örneğinprint()fonksiyonundasepparametresinin
değerini boş bir karakter dizisi yapmamızın nedenini anlamak için, fonksiyondaki
busepparametresini kaldırıp, programı bir de bu şekilde çalıştırmayı
deneyebilirsiniz.

Yukarıdaki örnekte bütün öğeleri tek birprint()fonksiyonu içine yazdık.
Ama tabii eğer isterseniz birden fazlaprint()fonksiyonu da
kullanabilirsiniz. Şöyle:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"

print("isim : ", isim)
print("soyisim : ", soyisim)
print("işletim sistemi: ", işsis)
print("şehir : ", şehir)

```

Yukarıdaki kodlarla ilgili birkaç noktaya daha dikkatinizi çekmek istiyorum:

Birincisi, gördüğünüz gibi kodları yazarken biraz şekil vererek yazdık. Bunun
sebebi kodların görünüş olarak anlaşılır olmasını sağlamak. Daha önce de
dediğimiz gibi, Python’da doğru kod yazmak kadar, yazdığınız kodların anlaşılır
olması da önemlidir. Bu sebepten, Python’la kod yazarken, mesela kodlarımızdaki
her bir satırın uzunluğunun 79 karakteri geçmemesine özen gösteriyoruz. Bunu
sağlamak için, kodlarımızı yukarıda görüldüğü şekilde belli noktalardan bölmemiz
gerekebilir.

Esasında yukarıdaki kodları şöyle de yazabilirdik:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"

print("isim: ", isim, "\n", "soyisim: ", soyisim, "\n",
"işletim sistemi: ", işsis, "\n", "şehir: ", şehir, "\n", sep="")

```

Ancak bu şekilde kod yapısı biraz karmaşık görünüyor. Ayrıca parantez içindeki
öğeleri yan yana yazdığımız için,isim:,soyisim:,işletim sistemi:veşehir:ifadelerini alt alta düzgün bir şekilde hizalamak da kolay
olmayacaktır.

Belki bu basit kodlarda çok fazla dikkati çekmiyordur, ama özellikle büyük
boyutlu programlarda kodlarımızı hem yapı hem de görüntü olarak olabildiğince
anlaşılır bir hale getirmek hem kodu okuyan başkaları için, hem de kendimiz için
büyük önem taşır. Unutmayın, bir programı yazdıktan 5-6 ay sonra geri dönüp
baktığınızda kendi yazdığınız kodlardan siz dahi hiçbir şey anlamadığınızı
farkedebilirsiniz!

Bir program yazarken kodların olabildiğince okunaklı olmasını sağlamanın bir kaç
yolu vardır. Biz bunlardan bazılarını yukarıda gördük. Ancak bir programı
okunaklı hale getirmenin en iyi yolu kodlar içine bazı yorum cümleleri ekleyerek
kodları açıklamaktır.

İşte bu bölümde, Python programlama dili ile yazdığımız kodlara nasıl yorum ve
açıklama cümleleri ekleyeceğimizi inceleyeceğiz.

### Yorum İşareti

Programcılıkta en zor şey başkasının yazdığı kodları okuyup anlamaktır. Hatta
yazılmış bir programı düzeltmeye çalışmak, bazen o programı sıfırdan yazmaktan
daha zor olabilir. Bunun nedeni, program içindeki kodların ne işe yaradığını
anlamanın zorluğudur. Programı yazan kişi kendi düşünüşüne göre bir yol izlemiş
ve programı geliştirirken karşılaştığı sorunları çözmek için kimi yerlerde
enteresan çözümler üretmiş olabilir. Ancak kodlara dışarıdan bakan birisi için o
programın mantık düzenini ve içindeki kodların tam olarak ne yaptığını anlamak
bir hayli zor olacaktır. Böyle durumlarda, kodları okuyan programcının en büyük
yardımcısı, programı geliştiren kişinin kodlar arasına eklediği notlar
olacaktır. Tabii programı geliştiren kişi kodlara yorum ekleme zahmetinde
bulunmuşsa…

Python’da yazdığımız kodları başkalarının da anlayabilmesini sağlamak için,
programımızın yorumlarla desteklenmesi tavsiye edilir. Elbette programınızı
yorumlarla desteklemeseniz de programınız sorunsuz bir şekilde çalışacaktır. Ama
programı yorumlarla desteklemek en azından nezaket gereğidir.

Ayrıca işin başka bir boyutu daha var. Sizin yazdığınız kodları nasıl başkaları
okurken zorlanıyorsa, kendi yazdığınız kodları okurken siz bile
zorlanabilirsiniz. Özellikle uzun süredir ilgilenmediğiniz eski programlarınızı
gözden geçirirken böyle bir sorunla karşılaşabilirsiniz. Programın içindeki bir
kod parçası, programın ilk yazılışının üzerinden 5-6 ay geçtikten sonra size
artık hiçbir şey ifade etmiyor olabilir. Kodlara bakıp, ‘Acaba burada ne yapmaya
çalışmışım?’ diye düşündüğünüz zamanlar da olacaktır. İşte bu tür sıkıntıları
ortadan kaldırmak veya en aza indirmek için kodlarımızın arasına açıklayıcı
notlar ekleyeceğiz.

Python’da yorumlar#işareti ile gösterilir. Mesela bu bölümün ilk başında
verdiğimiz kodları yorumlarla destekleyelim:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu" #işletim sistemi
şehir = "İstanbul"

#isim, soyisim, işsis ve şehir adlı değişkenleri
#alt alta, düzgün bir şekilde ekrana basıyoruz.
#Uygun yerlerde alt satıra geçebilmek için "\n"
#adlı kaçış dizisini kullanıyoruz.
print("isim : ", isim, "\n",
 "soyisim : ", soyisim, "\n",
 "işletim sistemi: ", işsis, "\n",
 "şehir : ", şehir, "\n",
 sep="") #parametreler arasında boşluk bırakmıyoruz.

```

Burada dikkat edeceğimiz nokta her yorum satırının başına#işaretini koymayı
unutmamaktır.

Yazdığımız yorumlar Python’a hiç bir şey ifade etmez. Python bu yorumları
tamamen görmezden gelecektir. Bu yorumlar bilgisayardan ziyade kodları okuyan
kişi için bir anlam taşır.

Elbette yazdığınız yorumların ne kadar faydalı olacağı, yazdığınız yorumların
kalitesine bağlıdır. Dediğimiz gibi, yerli yerinde kullanılmış yorumlar bir
programın okunaklılığını artırır, ama her tarafı yorumlarla kaplı bir programı
okumak da bazen hiç yorum girilmemiş bir programı okumaktan daha zor olabilir!
Dolayısıyla Python’da kodlarımıza yorum eklerken önemli olan şey, kaş yapmaya
çalışırken göz çıkarmamaktır. Yani yorumlarımızı, bir kodun okunaklılığını
artırmaya çalışırken daha da bozmayacak şekilde yerleştirmeye dikkat etmeliyiz.

### Yorum İşaretinin Farklı Kullanımları

Yukarıda yorum (#) işaretini kullanarak, yazdığımız Python kodlarını nasıl
açıklayacağımızı öğrendik. Python’da yorum işaretleri çoğunlukla bu amaç için
kullanılır. Yani kodları açıklamak, bu kodları hem kendimiz hem de kodları
okuyan başkaları için daha anlaşılır hale getirmek için… Ama Python’da#işareti asıl amacının dışında bazı başka amaçlara da hizmet edebilir.

#### Etkisizleştirme Amaçlı

Dediğimiz gibi, yorum işaretinin birincil görevi, tabii ki, kodlara açıklayıcı
notlar eklememizi sağlamaktır. Ama bu işaret başka amaçlar için de
kullanılabilir. Örneğin, diyelim ki yazdığımız programa bir özellik eklemeyi
düşünüyoruz, ama henüz bu özelliği yeni sürüme eklemek istemiyoruz. O zaman
şöyle bir şey yapabiliriz:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"
#uyruğu = "T.C"

print("isim : ", isim, "\n",
 "soyisim : ", soyisim, "\n",
 "işletim sistemi: ", işsis, "\n",
 "şehir : ", şehir, "\n",
 #"uyruğu : ", uyruğu, "\n",
 sep="")

```

Burada, programa henüz eklemek istemediğimiz bir özelliği, yorum içine alarak
şimdilik iptal ediyoruz yani etkisizleştiriyoruz (İngilizcede bu yorum içine
alma işleminecomment outdeniyor). Python yorum içinde bir kod bile yer alsa
o kodları çalıştırmayacaktır. Çünkü Python#işareti ile başlayan satırların
içeriğini görmez (#!/usr/bin/envpython3ve#-*-coding:utf-8-*-satırları hariç).

Peki eklemek istemediğimiz özelliği yorum içine almaktansa doğrudan silsek olmaz
mı? Elbette olur. Ama programın daha sonraki bir sürümüne ilave edeceğimiz bir
özelliği yorum içine almak yerine silecek olursak, vakti geldiğinde o özelliği
nasıl yaptığımızı hatırlamakta zorlanabiliriz! Hatta bir süre sonra programımıza
hangi özelliği ekleyeceğimizi dahi unutmuş olabiliriz. ‘Hayır, ben hafızama
güveniyorum!’ diyorsanız karar sizin.

Yorum içine alarak iptal ettiğiniz bu kodları programa ekleme vakti geldiğinde
yapacağınız tek şey, kodların başındaki#işaretlerini kaldırmak olacaktır.
Hatta bazı metin düzenleyiciler bu işlemi tek bir tuşa basarak da gerçekleştirme
yeteneğine sahiptir. Örneğin IDLE ile çalışıyorsanız, yorum içine almak
istediğiniz kodları fare ile seçtikten sonraAlt+3tuşlarına basarak ilgili
kodları yorum içine alabilirsiniz. Bu kodları yorumdan kurtarmak için ise ilgili
alanı seçtikten sonraAlt+4tuşlarına basmanız yeterli olacaktır (yorumdan
kurtarma işlemine İngilizcedeuncommentdiyorlar).

#### Süsleme Amaçlı

Bütün bunların dışında, isterseniz yorum işaretini kodlarınızı süslemek için
dahi kullanabilirsiniz:

```python
#######################################################
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
# FALANCA v.1 #
# Yazan: Keramet Su #
# Lisans: GPL v2 #
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#######################################################

isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"

print("isim : ", isim, "\n",
 "soyisim : ", soyisim, "\n",
 "işletim sistemi: ", işsis, "\n",
 "şehir : ", şehir, "\n",
 sep="")

```

Yani kısaca, Python’un görmesini, çalıştırmasını istemediğimiz her şeyi yorum
içine alabiliriz. Unutmamamız gereken tek şey, yorumların yazdığımız
programların önemli bir parçası olduğu ve bunları mantıklı, makul bir şekilde
kullanmamız gerektiğidir.

## Kullanıcıdan Bilgi Almak

Şimdiye kadar Python programlama dili ile ilgili epey bilgi edindik. Ama
muhtemelen buraya kadar öğrendiklerimiz sizi heyecanlandırmaktan bir hayli
uzaktı. Zira şu ana kadar hep tek yönlü bir programlama faaliyeti yürüttük.

Mesela şimdiye kadar öğrendiklerimizi kullanarak ancak şöyle bir program
yazabildik:

```python
isim = "Mübeccel"

print("Merhaba", isim, end="!\n")

```

Bu programı çalıştırdığımızda şöyle bir çıktı alacağımızı biliyorsunuz:

```python
Merhaba Mübeccel!

```

Bu programın ne kadar sıkıcı olduğunu herhalde söylemeye gerek yok. Bu programdaisimdeğişkenini doğrudan kendimiz yazdığımız için programımız hiçbir koşuldaMerhaba Mübecceldışında bir çıktı veremez. Çünkü bu program, tek yönlü bir
programlama faaliyetinin ürünüdür.

Halbuki bu değişkenin değerini kendimiz yazmasak, bu değeri kullanıcıdan alsak
ne hoş olurdu, değil mi?

Python’da kullanıcıdan herhangi bir veri alıp, yazdığımız programları tek
taraflı olmaktan kurtarmak içininput()adlı bir fonksiyondan
faydalanıyoruz.

İşte biz bu bölümde, programcılık maceramızı bir üst seviyeye taşıyacak çok
önemli bir araç olan buinput()fonksiyonunu derinlemesine inceleyeceğiz.
Ama bu bölümde sadece bu fonksiyonu ele almayacağız elbette. Burada kullanıcıdan
veri almanın yanısıra, aldığımız bu veriyi nasıl dönüştüreceğimizi ve bu veriyi,
yazdığımız programlarda nasıl kullanacağımızı da derin derin inceleyeceğiz.

İlkininput()fonksiyonunu anlatarak yola koyulalım.

### input() Fonksiyonu

input()da daha önce öğrendiğimiztype(),len()veprint()gibi
bir fonksiyondur. Esasında biz bu fonksiyonu ilk kez burada görmüyoruz. Windows
ve GNU/Linux kullanıcıları, yazdıkları bir programı çift tıklayarak
çalıştırabilmek için bu fonksiyonu kullandıklarını hatırlıyor olmalılar. Mesela
şu programı ele alalım:

```python
#!/usr/bin/env python3

kartvizit = """
İstihza Anonim Şirketi
Fırat Özgül
Tel: 0212 123 23 23
Faks: 0212 123 23 24
e.posta: kistihza@yahoo.com
"""

print(kartvizit)

```

Bu programı yazıp kaydettikten sonra bu programın simgesi üzerine çift
tıkladığımızda siyah bir komut ekranının çok hızlı bir şekilde açılıp
kapandığını görürüz. Aslında programımız çalışıyor, ama programımız yapması
gereken işi yaptıktan hemen sonra kapandığı için biz program penceresini
görmüyoruz.

Programımızın çalıştıktan sonra hemen kapanmamasını sağlamak için son satıra birinput()fonksiyonu yerleştirmemiz gerektiğini biliyoruz:

```python
#!/usr/bin/env python3

kartvizit = """
İstihza Anonim Şirketi
Fırat Özgül
Tel: 0212 123 23 23
Faks: 0212 123 23 24
e.posta: kistihza@yahoo.com
"""

print(kartvizit)

input()

```

Bu sayede programımız kullanıcıdan bir giriş bekleyecek ve o girişi alana kadar
da kapanmayacaktır. Programı kapatmak içinEnterdüğmesine basabiliriz.

input()bir fonksiyondur dedik. Henüz fonksiyon kavramının ayrıntılarını
öğrenmemiş olsak da, şimdiye kadar pek çok fonksiyon gördüğümüz için artık bir
fonksiyonla karşılaştığımızda bunun nasıl kullanılacağını az çok tahmin
edebiliyoruz. Tıpkı düşündüğünüz ve yukarıdaki örnekten de gördüğünüz gibi,
birer fonksiyon olantype(),print(),len()veopen()fonksiyonlarını nasıl kullanıyorsakinput()fonksiyonunu da öyle
kullanacağız.

Dilerseniz lafı daha fazla uzatmadan örnek bir program yazalım:

```python
isim = input("İsminiz nedir? ")

print("Merhaba", isim, end="!\n")

```

Bu programı kaydedip çalıştırdığınızda, sorulan soruya verdiğiniz cevaba göre
çıktı farklı olacaktır. Örneğin eğer bu soruya ‘Niyazi’ cevabını vermişseniz
çıktınızMerhaba Niyazi!şeklinde olacaktır.

Görüyorsunuz ya, tıpkı daha önce gördüğümüz fonksiyonlarda olduğu gibi,input()fonksiyonunda da parantez içine bir parametre yazıyoruz. Bu
fonksiyona verilen parametre, kullanıcıdan veri alınırken kullanıcıya sorulacak
soruyu gösteriyor. Gelin isterseniz bir örnek daha yapalım elimizin alışması
için:

```python
yaş = input("Yaşınız: ")

print("Demek", yaş, "yaşındasın.")
print("Genç mi yoksa yaşlı mı olduğuna karar veremedim.")

```

input()fonksiyonunun ne kadar kullanışlı bir araç olduğu ortada. Bu
fonksiyon sayesinde, şimdiye kadar tek sesli bir şekilde yürüttüğümüz
programcılık faaliyetlerimizi çok sesli bir hale getirebileceğiz. Mesela önceki
bölümlerden birinde yazdığımız, daire alanı hesaplayan programı hatırlarsınız. O
zaman henüz dosyalarımızı kaydetmeyi veinput()fonksiyonunu öğrenmediğimiz
için o programı etkileşimli kabukta şu şekilde yazmıştık:

```python
>>> çap = 16
>>> yarıçap = çap / 2
>>> pi = 3.14159
>>> alan = pi * (yarıçap * yarıçap)
>>> alan

201.06176

```

Ama artık hem dosyalarımızı kaydetmeyi biliyoruz, hem deinput()fonksiyonunu öğrendik. Dolayısıyla yukarıdaki programı şu şekilde yazabiliriz:

```python
#Kullanıcıdan dairenin çapını girmesini istiyoruz.
çap = input("Dairenin çapı: ")

#Kullanıcının verdiği çap bilgisini kullanarak
#yarıçapı hesaplayalım. Buradaki int() fonksiyonunu
#ilk kez görüyoruz. Biraz sonra bunu açıklayacağız
yarıçap = int(çap) / 2

#pi sayımız sabit
pi = 3.14159

#Yukarıdaki bilgileri kullanarak artık
#dairenin alanını hesaplayabiliriz
alan = pi * (yarıçap * yarıçap)

#Son olarak, hesapladığımız alanı yazdırıyoruz
print("Çapı", çap, "cm olan dairenin alanı: ", alan, "cm2'dir")

```

Gördüğünüz gibi,input()fonksiyonunu öğrenmemiz sayesinde artık yavaş yavaş
işe yarar programlar yazabiliyoruz.

Ancak burada, daha önce öğrenmediğimiz bir fonksiyon dikkatinizi çekmiş olmalı.
Bu fonksiyonun adıint(). Bu yeni fonksiyon dışında, yukarıdaki bütün
kodları anlayabilecek kadar Python bilgisine sahibiz.

int()fonksiyonunun ne işe yaradığını anlamak için isterseniz ilgili satırıyarıçap=çap/2şeklinde yazarak çalıştırmayı deneyin bu programı.

Dediğim gibi, eğer o satırdakiint()fonksiyonunu kaldırarak programı
çalıştırdıysanız şuna benzer bir hata mesajı almış olmalısınız:

```python
Traceback (most recent call last):
 File "deneme.py", line 8, in <module>
 yarıçap = çap / 2
TypeError: unsupported operand type(s) for /: 'str' and 'int'

```

Gördüğünüz gibi programımız bölme işlemini yapamadı. Buradan anlıyoruz ki, buint()fonksiyonu programımızdaki aritmetik işlemin düzgün bir şekilde
yapılabilmesini sağlıyor. Gelelim bu fonksiyonun bu işlevi nasıl yerine
getirdiğini incelemeye.

### Tip Dönüşümleri

Bir önceki bölümün sonunda verdiğimiz örnek programdaint()adlı bir
fonksiyon görmüş, bu fonksiyonu anlatmayı o zaman ertelemiştik. Çok gecikmeden,
bu önemli fonksiyonun ne işe yaradığını öğrenmemiz gerekiyor. İsterseniz bir
örnek üzerinden gidelim.

Diyelim ki kullanıcıdan aldığı sayının karesini hesaplayan bir program yazmak
istiyoruz. Öncelikle şöyle bir şey deneyelim:

```python
sayı = input("Lütfen bir sayı girin: ")

#Girilen sayının karesini bulmak için sayı değişkeninin 2.
#kuvvetini alıyoruz. Aynı şeyi pow() fonksiyonu ile de
#yapabileceğimizi biliyorsunuz. Örn.: pow(sayı, 2)
print("Girdiğiniz sayının karesi: ", sayı ** 2)

```

Bu kodları çalıştırdığımız zaman, programımız kullanıcıdan bir sayı girmesini
isteyecek, ancak kullanıcı bir sayı giripEntertuşuna bastığında şöyle bir
hata mesajıyla karşılaşacaktır:

```python
Traceback (most recent call last):
 File "test.py", line 5, in <module>
 print("Girdiğiniz sayının karesi: ", sayı ** 2)
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

```

Hata mesajına baktığınızda, ‘TypeError’ ifadesinden, bunun veri tipine ilişkin
bir hata olduğunu tahmin edebilirsiniz. Eğer İngilizce biliyorsanız yukarıdaki
hata mesajının anlamını rahatlıkla çıkarabilirsiniz. İngilizce bilmeseniz de en
sondaki ‘str’ ve ‘int’ kelimeleri size karakter dizisi ve sayı adlı veri
tiplerini hatırlatacaktır. Demek ki ortada veri tiplerini ilgilendiren bir sorun
var…

Peki burada tam olarak neler dönüyor?

Hatırlayacaksınız, geçen derslerden birindelen()fonksiyonunu anlatırken
şöyle bir şey söylemiştik:

Biz henüz kullanıcıdan nasıl veri alacağımızı bilmiyoruz. Ama şimdilik şunu
söyleyebiliriz: Python’da kullanıcıdan herhangi bir veri aldığımızda, bu
veri bize bir karakter dizisi olarak gelecektir.

Gelin isterseniz yukarıda anlattığımız durumu teyit eden bir program yazalım:

```python
#Kullanıcıdan herhangi bir veri girmesini istiyoruz
sayı = input("Herhangi bir veri girin: ")

#Kullanıcının girdiği verinin tipini bir
#değişkene atıyoruz
tip = type(sayı)

#Son olarak kullanıcının girdiği verinin tipini
#ekrana basıyoruz.
print("Girdiğiniz verinin tipi: ", tip)

```

Bu programı çalıştırdığımızda ne tür bir veri girersek girelim, girdiğimiz
verinin tipistr, yani karakter dizisi olacaktır. Demek ki gerçekten de,
kullanıcıdan veri almak için kullandığımızinput()fonksiyonu bize her
koşulda bir karakter dizisi veriyormuş.

Geçen derslerde şöyle bir şey daha söylemiştik:

Python’da, o anda elinizde bulunan bir verinin hangi tipte olduğunu bilmek
son derece önemlidir. Çünkü bir verinin ait olduğu tip, o veriyle neler
yapıp neler yapamayacağınızı belirler.

Şu anda karşı karşıya olduğumuz durum da buna çok güzel bir örnektir. Eğer o
anda elimizde bulunan verinin tipini bilmezsek tıpkı yukarıda olduğu gibi, o
veriyi programımızda kullanmaya çalışırken programımız hata verir ve çöker.

Her zaman üstüne basa basa söylediğimiz gibi, aritmetik işlemler yalnızca
sayılarla yapılır. Karakter dizileri ile herhangi bir aritmetik işlem yapılamaz.
Dolayısıyla,input()fonksiyonundan gelen veri bir karakter dizisi olduğu
için ve biz de programımızda girilen sayının karesini hesaplamak amacıyla bu
fonksiyondan gelen verinin2.kuvvetini, yani karesini hesaplamaya
çalıştığımız için programımız hata verecektir.

Yukarıdaki programda neler olup bittiğini daha iyi anlayabilmek için Python’ın
etkileşimli kabuğunda şu işlemleri yapabiliriz:

```python
>>> "23" ** 2

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

```

Gördüğünüz gibi, programımızdan aldığımız hata ile yukarıdaki hata tamamen aynı
(hata mesajlarında bizi ilgilendiren kısım en son satırdır). Tıpkı burada olduğu
gibi, hata veren programda da ‘Lütfen bir sayı girin: ‘ sorusuna örneğin23cevabını verdiğimizde programımız aslında"23"**2gibi bir işlem yapmaya
çalışıyor. Bir karakter dizisinin kuvvetini hesaplamak mümkün olmadığı, kuvvet
alma işlemi yalnızca sayılarla yapılabileceği için de hata vermekten başka
çaresi kalmıyor.

Ancak bazen öyle durumlarla karşılaşırsınız ki, programınız hiçbir hata vermez,
ama elde edilen sonuç aslında tamamen beklentinizin dışındadır. Mesela şu basit
örneği inceleyelim:

```python
sayı1 = input("Toplama işlemi için ilk sayıyı girin: ")
sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ")

print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Bu kodları çalıştırdığımızda şöyle bir manzarayla karşılaşırız:

input()fonksiyonunun alttan alta neler çevirdiğini bu örnek yardımıyla çok
daha iyi anladığınızı zannediyorum. Gördüğünüz gibi yukarıdaki program herhangi
bir hata vermedi. Ama beklediğimiz çıktıyı da vermedi. Zira biz programımızın
iki sayıyı toplamasını istiyorduk. O ise kullanıcının girdiği sayıları yan yana
yazmakla yetindi. Yani bir aritmetik işlem yapmak yerine, verileri birbiriyle
bitiştirdi. Çünkü, dediğim gibi,input()fonksiyonunun kullanıcıdan aldığı
şey bir karakter dizisidir. Dolayısıyla bu fonksiyon yukarıdaki gibi bir durumla
karşılaştığı zaman karakter dizileri arasında bir birleştirme işlemi
gerçekleştirir. Tıpkı ilk derslerimizde etkileşimli kabukta verdiğimiz şu
örnekte olduğu gibi:

```python
>>> "23" + "23"

2323

```

Bu son örnekten ayrıca şunu çıkarıyoruz: Yazdığınız bir programın herhangi bir
hata vermemesi o programın doğru çalıştığı anlamına gelmeyebilir. Dolayısıyla bu
tür durumlara karşı her zaman uyanık olmanızda fayda var.

Peki yukarıdaki gibi durumlarla karşılaşmamak için ne yapacağız?

İşte bu noktada devreye tip dönüştürücü adını verdiğimiz birtakım fonksiyonlar
girecek.

#### int()

Dediğimiz gibi,input()fonksiyonundan gelen veri her zaman bir karakter
dizisidir. Dolayısıyla bu fonksiyondan gelen veriyle herhangi bir aritmetik
işlem yapabilmek için öncelikle bu veriyi bir sayıya dönüştürmemiz gerekir. Bu
dönüştürme işlemi içinint()adlı özel bir dönüştürücü fonksiyondan
yararlanacağız. Gelin isterseniz Python’ın etkileşimli kabuğunda bu fonksiyonla
bir kaç deneme yaparak bu fonksiyonun ne işe yaradığını ve nasıl kullanıldığını
anlamaya çalışalım. Zira etkileşimli kabuk bu tür deneme işlemleri için biçilmiş
kaftandır:

```python
>>> karakter_dizisi = "23"
>>> sayı = int(karakter_dizisi)
>>> print(sayı)

23

```

Burada öncelikle“23”adlı bir karakter dizisi tanımladık. Ardından daint()fonksiyonunu kullanarak bu karakter dizisini bir tamsayıya (integer)
dönüştürdük. İsminden de anlayacağınız gibiint()fonksiyonu İngilizceinteger(tamsayı) kelimesinin kısaltmasıdır ve bu fonksiyonun görevi bir
veriyi tamsayıya dönüştürmektir.

Ancak burada dikkat etmemiz gereken bir şey var. Herhangi bir verinin sayıya
dönüştürülebilmesi için o verinin sayı değerli bir veri olması gerekir. Örneğin“23”, sayı değerli bir karakter dizisidir. Ama mesela“elma”sayı değerli
bir karakter dizisi değildir. Bu yüzden“elma”karakter dizisi sayıya
dönüştürülemez:

```python
>>> karakter_dizisi = "elma"
>>> sayı = int(karakter_dizisi)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'elma'

```

Gördüğünüz gibi, sayı değerli olmayan bir veriyi sayıya dönüştürmeye
çalıştırdığımızda Python bize bir hata mesajı gösteriyor. Yazdığımız
programlarda bu duruma özellikle dikkat etmemiz gerekiyor.

Şimdi bu bölümün başında yazdığımız ve hata veren programımıza dönelim yine:

```python
sayı = input("Lütfen bir sayı girin: ")

print("Girdiğiniz sayının karesi: ", sayı ** 2)

```

Bu kodların hata vereceğini biliyoruz. Ama artık, öğrendiğimizint()dönüştürücüsünü kullanarak programımızı hata vermeyecek şekilde yeniden
yazabiliriz:

```python
veri = input("Lütfen bir sayı girin: ")

#input() fonksiyonundan gelen karakter dizisini
#sayıya dönüştürüyoruz.
sayı = int(veri)

print("Girdiğiniz sayının karesi: ", sayı ** 2)

```

Artık programımız hatasız bir şekilde çalışıyor.

Bir de öteki örneğimizi ele alalım:

```python
sayı1 = input("Toplama işlemi için ilk sayıyı girin: ")
sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ")

print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Bu kodların beklediğimiz çıktıyı vermeyeceğini biliyoruz. Ama eğer bu kodları
şöyle yazarsak işler değişir:

```python
v1 = input("Toplama işlemi için ilk sayıyı girin: ")
v2 = input("Toplama işlemi için ikinci sayıyı girin: ")

sayı1 = int(v1) #v1 adlı karakter dizisini sayıya dönüştürüyoruz.
sayı2 = int(v2) #v2 adlı karakter dizisini sayıya dönüştürüyoruz.

print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Gördüğünüz gibi,input()fonksiyonundan gelen karakter dizilerini sayıya
dönüştürerek istediğimiz çıktıyı alabiliyoruz.

#### str()

Python’daki tip dönüştürücüleri elbette sadeceint()fonksiyonuyla sınırlı
değildir. Gördüğünüz gibi,int()fonksiyonu sayı değerli verileri (mesela
karakter dizilerini) tam sayıya dönüştürüyor. Bunun bir de tersi mümkündür. Yani
karakter dizisi olmayan verileri karakter dizisine dönüştürmemiz de mümkündür.
Bu işlem içinstr()adlı başka bir tip dönüştürücüden yararlanıyoruz:

```python
>>> sayı = 23
>>> kardiz = str(sayı)
>>> print(kardiz)

23

>>> print(type(kardiz))

<class 'str'>

```

Gördüğünüz gibi, bir tam sayı olan23’üstr()adlı bir fonksiyondan
yararlanarak karakter dizisi olan“23”ifadesine dönüştürdük. Son satırda da,
elde ettiğimiz şeyin bir karakter dizisi olduğundan emin olmak içintype()fonksiyonunu kullanarak verinin tipini denetledik.

Yukarıdaki örneklerden gördüğümüz gibi, aritmetik işlemler yapmak istediğimizde
karakter dizilerini sayıya çevirmemiz gerekiyor. Peki acaba hangi durumlarda
bunun tersini yapmamız, yani sayıları karakter dizilerine çevirmemiz gerekir?
Python bilginiz ve tecrübeniz arttıkça bunların hangi durumlar olduğunu kendiniz
de göreceksiniz. Mesela biz daha şimdiden, sayıları karakter dizisine çevirmemiz
gereken bir durumla karşılaştık. Hatırlarsanız,len()fonksiyonunu
anlatırken, bu fonksiyonun sayılarla birlikte kullanılamayacağını söylemiştik:

```python
>>> len(12343423432)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: object of type 'int' has no len()

```

Peki ya yazdığınız programda bir sayının kaç haneden oluştuğunu hesaplamanız
gerekirse ne yapacaksınız? Yani mesela yukarıdaki sayının 11 haneli olduğunu
bilmeniz gerekiyorsa ne olacak?

İşte böyle bir durumdastr()fonksiyonundan yararlanabilirsiniz:

```python
>>> sayı = 12343423432
>>> kardiz = str(sayı)
>>> len(kardiz)

11

```

Bildiğiniz gibi,len()fonksiyonu, şu ana kadar öğrendiğimiz veri tipleri
içinde sadece karakter dizileri üzerinde işlem yapabiliyor. Biz de bu yüzden,
sayımızın kaç haneli olduğunu öğrenebilmek için, öncelikle bu sayıyı bir
karakter dizisine çeviriyoruz. Daha sonra da elde ettiğimiz bu karakter dizisinilen()fonksiyonuna parametre olarak veriyoruz. Böylece sayının kaç haneli
olduğu bilgisini elde etmiş oluyoruz.

Bu arada elbette yukarıdaki işlemi tek satırda da halledebilirsiniz:

```python
>>> len(str(12343423432))

11

```

Bu şekilde iç içe geçmiş fonksiyonlar yazdığımızda, Python fonksiyonları içten
dışa doğru tek tek değerlendirecektir. Mesela yukarıdaki örnekte Python öncestr(12343423432)ifadesini değerlendirecek ve çıkan sonuculen()fonksiyonuna gönderecektir. İç içe geçmiş fonksiyonları yazarken dikkat etmemiz
gereken önemli bir nokta da, açtığımız her bir parantezi tek tek kapatmayı
unutmamaktır.

#### float()

Hatırlarsanız ilk bölümlerde sayılardan söz ederken tamsayıların (integer)
dışında kayan noktalı sayıların (float) da olduğundan söz etmiştik. İşte eğer
bir tamsayıyı veya sayı değerli bir karakter dizisini kayan noktalı sayıya
dönüştürmek istersekfloat()adlı başka bir dönüştürücüden yararlanacağız:

```python
>>> a = 23
>>> type(a)

<class 'int'>

>>> float(a)

23.0

```

Gördüğünüz gibi,23tamsayısı,float()fonksiyonu sayesinde23.0’a yani
bir kayan noktalı sayıya dönüştü.

Aynı şeyi, sayı değerli karakter dizileri üzerine uygulamak da mümkündür:

```python
>>> b = "23"
>>> type(b)

<class 'str'>

>>> float(b)

23.0

```

#### complex()

Sayılardan söz ederken, eğer matematikle çok fazla içli dışlı değilseniz pek
karşılaşmayacağınız, ‘karmaşık sayı’ adlı bir sayı türünden de bahsetmiştik.
Karmaşık sayılar Python’da ‘complex’ ifadesiyle gösteriliyor. Mesela şunun bir
karmaşık sayı olduğunu biliyoruz:

```python
>>> 12+0j

```

Kontrol edelim:

```python
>>> type(12+0j)

<class 'complex'>

```

İşte eğer herhangi bir sayıyı karmaşık sayıya dönüştürmeniz gerekirsecomplex()adlı bir fonksiyondan yararlanabilirsiniz. Örneğin:

```python
>>> complex(15)

(15+0j)

```

Böylece Python’daki bütün sayı dönüştürücüleri öğrenmiş olduk.

Gelin isterseniz, bu bölümde anlattığımız konuları şöyle bir tekrar ederek
bilgilerimizi sağlamlaştırmaya çalışalım.

```python
>>> a = 56

```

Bu sayı bir tamsayıdır. İngilizce olarak ifade etmek gerekirse,integer. Bunun
bir tamsayı olduğunu şu şekilde teyit edebileceğimizi gayet iyi biliyorsunuz:

```python
>>> type(a)

<class 'int'>

```

Burada aldığımız<class int>çıktısı, bizeadeğişkeninin tuttuğu sayının
bir tamsayı olduğunu söylüyor. ‘int’ ifadesi,integer(tamsayı) kelimesinin
kısaltmasıdır.

Bir de şu sayıya bakalım:

```python
>>> b = 34.5
>>> type(b)

<class 'float'>

```

Bu çıktı ise bize34.5sayısının bir kayan noktalı sayı olduğunu söylüyor.floatkelimesiFloatsveyaFloating Point Numberifadesinin kısaltmasıdır.
Yani ‘kayan noktalı sayı’ demektir.

Bu arada, butype()adlı fonksiyonu sadece sayılara değil, başka şeylere de
uygulayabileceğimizi biliyorsunuz. Mesela bir örnek vermek gerekirse:

```python
>>> meyve = "karpuz"
>>> type(meyve)

<class 'str'>

```

Gördüğünüz gibi,type()fonksiyonu bizemeyveadlı değişkenin değerinin
bir ‘str’ yanistringyani karakter dizisi olduğunu bildirdi.

Bu veri tipleri arasında, bazı özel fonksiyonları kullanarak dönüştürme işlemi
yapabileceğimizi öğrendik. Mesela:

```python
>>> sayı = 45

```

sayıadlı değişkenin tuttuğu verinin değeri bir tamsayıdır. Biz bu tamsayıyı
kayan noktalı sayıya dönüştürmek istiyoruz. Yapacağımız işlem çok basit:

```python
>>> float(sayı)

45.0

```

Gördüğünüz gibi,45adlı tamsayıyı,45.0adlı bir kayan noktalı sayıya
dönüştürdük. Şimditype(45.0)komutu bize<class ‘float’>çıktısını
verecektir.

Eğer kayan noktalı bir sayıyı tamsayıya çevirmek istersek şu komutu veriyoruz.
Mesela kayan noktalı sayımız,56.5olsun:

```python
>>> int(56.5)

56

```

Yukarıdaki örneği tabii ki şöyle de yazabiliriz:

```python
>>> a = 56.5
>>> int(a)

56

```

Dönüştürme işlemini sayılar arasında yapabileceğimiz gibi, sayılar ve karakter
dizileri arasında da yapabiliriz. Örneğin şu bir karakter dizisidir:

```python
>>> nesne = "45"

```

Yukarıdaki değeri tırnak içinde belirttiğimiz için bu değer bir karakter
dizisidir. Şimdi bunu bir tamsayıya çevireceğiz:

```python
>>> int(nesne)

45

```

Dilersek, aynı karakter dizisini kayan noktalı sayıya da çevirebiliriz:

```python
>>> float(nesne)

45.0

```

Hatta bir sayıyı karakter dizisine de çevirebiliriz. Bunun içinstring(karakter dizisi) kelimesinin kısaltması olanstrifadesini kullanacağız:

```python
>>> s = 6547
>>> str(s)

'6547'

```

Bir örnek de kayan noktalı sayılarla yapalım:

```python
>>> s = 65.7
>>> str(s)

'65.7'

```

Yalnız şunu unutmayın: Bir karakter dizisinin sayıya dönüştürülebilmesi için o
karakter dizisinin sayı değerli olması lazım. Yani“45”değerini sayıya
dönüştürebiliriz. Çünkü“45”değeri, tırnaklardan ötürü bir karakter dizisi de
olsa, neticede sayı değerli bir karakter dizisidir. Ama mesela“elma”karakter
dizisi böyle değildir. Dolayısıyla, şöyle bir maceraya girişmek bizi hüsrana
uğratacaktır:

```python
>>> nesne = "elma"
>>> int(nesne)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: 'elma'

```

Gördüğünüz gibi, Python böyle bir işlem denemesi karşısında hata veriyor…

Bu bölümde pek çok yeni şey öğrendik. Bu bölümün en önemli getirisiinput()fonksiyonunu öğrenmemiz oldu. Bu fonksiyon sayesinde kullanıcıyla iletişim
kurmayı başardık. Artık kullanıcıdan veri alıp, bu verileri programlarımız
içinde işleyebiliyoruz.

Yine bu bölümde dikkatinizi çektiğimiz başka bir konu da sayılar ve karakter
dizileri arasındaki ilişkiydi.input()fonksiyonuyla elde edilen çıktının
bir karakter dizisi olduğunu öğrendik. Bildiğimiz gibi, aritmetik işlemler ancak
sayılar arasında yapılabilir. Dolayısıylainput()fonksiyonuyla gelen
karakter dizisini bir sayıyla çarpmaya kalkarsak hata alıyoruz. Burada yapmamız
gereken şey, elimizdeki verileri dönüştürmek. Yaniinput()fonksiyonundan
gelen karakter dizisini bir sayıyla çarpmak istiyorsak, öncelikle aldığımız
karakter dizisini sayıya dönüştürmemiz gerekiyor. Dönüştürme işlemleri için
kullandığımız fonksiyonlar şunlardı:

Sayı değerli bir karakter dizisini veya kayan noktalı sayıyı tamsayıya
(integer) çevirir.

Sayı değerli bir karakter dizisini veya tamsayıyı kayan noktalı sayıya
(float) çevirir.

Bir tamsayı veya kayan noktalı sayıyı karakter dizisine (string) çevirir.

Herhangi bir sayıyı veya sayı değerli karakter dizisini karmaşık sayıya
(complex) çevirir.

Ayrıca bu bölümde öğrendiklerimiz, şöyle önemli bir tespitte bulunmamıza da
olanak tanıdı:

Her tamsayı ve/veya kayan noktalı sayı bir karakter dizisine
dönüştürülebilir. Ama her karakter dizisi tamsayıya ve/veya kayan noktalı
sayıya dönüştürülemez.

Örneğin,5654gibi bir tamsayıyı veya543.34gibi bir kayan noktalı sayıyıstr()fonksiyonu yardımıyla karakter dizisine dönüştürebiliriz:

```python
>>> str(5654)
>>> str(543.34)

```

“5654”karakter dizisiniint()fonksiyonu ile tamsayıya,float()fonksiyonu ile de
bir kayan noktalı sayıya dönüştürebiliriz:

```python
>>> int("5654")
>>> float("5654")

```

veya“543.34”gibi bir karakter dizisinifloat()fonksiyonu yardımıyla kayan noktalı sayıya dönüştürebiliriz:

```python
>>> float("543.34")

```

Ancak“543.34”karakter dizisiniint()fonksiyonu ile birlikte kullanırsak hata alırız, çünkü543.34bir tamsayı olamaz. Eğer amacımız“543.34”karakter dizisini sayısal değer gibi düşünüp
aşağı yuvarlamak olsaydı şöyle bir şey yapabilirdik:

```python
>>> x = float("543.34")
>>> x
543.34
>>> int(x)
543
>>>

```

Aşağı değil de yukarı yuvarlamak istersek en son elde ettiğimiz543değerine bir eklemek yeterli olurdu.

Ama“elma”gibi bir karakter dizisini neint()ne defloat()fonksiyonuyla tamsayıya veya kayan noktalı sayıya dönüştürebiliriz! Çünkü“elma”verisi sayı değerli değildir.

Bu bölümü kapatmadan önce, dilerseniz şimdiye kadar öğrendiklerimizi de içeren
örnek bir program yazalım. Bu program, Python maceramız açısından bize yeni
kapılar da açacak.

Önceki derslerimizin birinde verdiğimiz doğalgaz faturası hesaplayan programı
hatırlarsınız. İşte artıkinput()fonksiyonu sayesinde bu doğalgaz faturası
hesaplama programını da daha ilginç bir hale getirebiliriz:

```python
#Her bir ayın kaç gün çektiğini tanımlıyoruz
ocak = mart = mayıs = temmuz = ağustos = ekim = aralık = 31
nisan = haziran = eylül = kasım = 30
şubat = 28

#Doğalgazın vergiler dahil metreküp fiyatı
birimFiyat = 0.79

#Kullanıcı ayda ne kadar doğalgaz tüketmiş?
aylıkSarfiyat = input("Aylık doğalgaz sarfiyatınızı metreküp olarak giriniz: ")

#Kullanıcı hangi aya ait faturasını öğrenmek istiyor?
dönem = input("""Hangi aya ait faturayı hesaplamak istersiniz?
(Lütfen ay adını tamamı küçük harf olacak şekilde giriniz)\n""")

#Yukarıdaki input() fonksiyonundan gelen veriyi
#Python'ın anlayabileceği bir biçime dönüştürüyoruz
ay = eval(dönem)

#Kullanıcının günlük doğalgaz sarfiyatı
günlükSarfiyat = int(aylıkSarfiyat) / ay

#Fatura tutarı
fatura = birimFiyat * günlükSarfiyat * ay

print("günlük sarfiyatınız: \t", günlükSarfiyat, " metreküp\n",
"tahmini fatura tutarı: \t", fatura, " TL", sep="")

```

Burada yine bilmediğimiz bir fonksiyonla daha karşılaştık. Bu fonksiyonun adıeval(). Biraz sonraeval()fonksiyonunu derinlemesine inceleyeceğiz. Ama
bu fonksiyonu anlatmaya geçmeden önce dilerseniz yukarıdaki kodları biraz
didikleyelim.

İlk satırların ne işe yaradığını zaten biliyorsunuz. Bir yıl içindeki bütün
ayların kaç gün çektiğini gösteren değişkenlerimizi tanımladık. Burada her bir
değişkeni tek tek tanımlamak yerine değişkenleri topluca tanımladığımıza dikkat
edin. İsteseydik tabii ki yukarıdaki kodları şöyle de yazabilirdik:

```python
#Her bir ayın kaç gün çektiğini tanımlıyoruz
ocak = 31
şubat = 28
mart = 31
nisan = 30
mayıs = 31
haziran = 30
temmuz = 31
ağustos = 31
eylül = 30
ekim = 31
kasım = 30
aralık = 31

#Doğalgazın vergiler dahil m3 fiyatı
birimFiyat = 0.79

#Kullanıcı ayda ne kadar doğalgaz tüketmiş?
aylıkSarfiyat = input("Aylık doğalgaz sarfiyatınızı m3 olarak giriniz: ")

#Kullanıcı hangi aya ait faturasını öğrenmek istiyor?
dönem = input("""Hangi aya ait faturayı hesaplamak istersiniz?
(Lütfen ay adını tamamı küçük harf olacak şekilde giriniz)\n""")

#Yukarıdaki input() fonksiyonundan gelen veriyi
#Python'ın anlayabileceği bir biçime dönüştürüyoruz
ay = eval(dönem)

#Kullanıcının günlük doğalgaz sarfiyatı
günlükSarfiyat = int(aylıkSarfiyat) / ay

#Fatura tutarı
fatura = birimFiyat * günlükSarfiyat * ay

print("günlük sarfiyatınız: \t", günlükSarfiyat, " metreküp\n",
"tahmini fatura tutarı: \t", fatura, " TL", sep="")

```

Ama tabii ki, değişkenleri tek tek tanımlamak yerine topluca tanımlamak, daha az
kod yazmanızı sağlamasının yanısıra, programınızın çalışma performansı açısından
da daha iyidir. Yani değişkenleri bu şekilde tanımladığınızda programınız daha
hızlı çalışır.

Programımızı incelemeye devam edelim…

Değişkenleri tanımladıktan sonra doğalgazın vergiler dahil yaklaşık birim
fiyatını da bir değişken olarak tanımladık.0.79değerini zaten birkaç bölüm
önce hesaplayıp bulduğumuz için, aynı işlemleri tekrar programımıza eklememize
gerek yok. Doğrudan nihai değeri programımıza yazsak yeter…

Birim fiyatı belirledikten sonra kullanıcıya aylık doğalgaz sarfiyatını
soruyoruz. Kullanıcının bu değeri m3olarak girmesini bekliyoruz.
Elbette bu veriyi kullanıcıdan alabilmek içininput()fonksiyonunu
kullanıyoruz.

Daha sonra kullanıcıya hangi aya ait doğalgaz faturasını ödemek istediğini
soruyoruz. Bu bilgi, bir sonraki satırda günlük doğalgaz sarfiyatını hesaplarken
işimize yarayacak. Çünkü kullanıcının girdiği ayın çektiği gün sayısına bağlı
olarak günlük sarfiyat değişecektir. Günlük sarfiyatı hesaplamak için aylık
sarfiyatı, ilgili ayın çektiği gün sayısına bölüyoruz. Bu arada bir önceki
satırdadönemdeğişkeninieval()adlı bir fonksiyonla birlikte
kullandığımızı görüyorsunuz. Bunu biraz sonra inceleyeceğiz. O yüzden bu
satırları atlayıp son satıra gelelim.

Son satırdaprint()fonksiyonunu kullanarak, kullanıcıdan aldığımız verileri
düzgün bir şekilde kendisine gösteriyoruz. Programımız kullanıcıya günlük
doğalgaz sarfiyatını ve ay sonunda karşılaşacağı tahmini fatura tutarını
bildiriyor.print()fonksiyonu içinde kullandığımız kaçış dizilerine
özellikle dikkatinizi çekmek istiyorum. Burada düzgün bir çıktı elde etmek için\tve\nadlı kaçış dizilerinden nasıl yararlandığımızı görüyorsunuz. Bu
kaçış dizilerinin buradaki işlevini tam olarak anlayabilmek için, bu kodları bir
de bu kaçış dizileri olmadan yazmayı deneyebilirsiniz.

Bu bilgileri, önemlerinden ötürü aklımızda tutmaya çalışalım. Buraya kadar
anlatılan konular hakkında zihnimizde belirsizlikler varsa veya bazı noktaları
tam olarak kavrayamadıysak, şimdiye kadar öğrendiğimiz konuları tekrar gözden
geçirmemiz bizim için epey faydalı olacaktır. Zira bundan sonraki bölümlerde,
yeni bilgilerin yanısıra, buraya kadar öğrendiğimiz şeyleri de yoğun bir şekilde
pratiğe dökeceğiz. Bundan sonraki konuları takip edebilmemiz açısından, buraya
kadar verdiğimiz temel bilgileri iyice sindirmiş olmak işimizi bir hayli
kolaylaştıracaktır.

### eval() ve exec() Fonksiyonları

Bir önceki bölümün son örnek programındaeval()adlı bir fonksiyonla
karşılaşmıştık. İşte şimdi bu önemli fonksiyonun ne işe yaradığını anlamaya
çalışacağız. Ancakeval()fonksiyonunu anlatmaya başlamadan önce şu uyarıyı
yapalım:

Bunun neden böyle olduğunu hem biz anlatacağız, hem de zaten bu fonksiyonu
tanıdıkça nedeneval()’e karşı dikkatli olmanız gerektiğini kendiniz de
anlayacaksınız.

Dilerseniz işe basit bireval()örneği vererek başlayalım:

```python
print("""
Basit bir hesap makinesi uygulaması.

İşleçler:

 + toplama
 - çıkarma
 * çarpma
 / bölme

Yapmak istediğiniz işlemi yazıp ENTER
tuşuna basın. (Örneğin 23 ve 46 sayılarını
çarpmak için 23 * 46 yazdıktan sonra
ENTER tuşuna basın.)
""")

veri = input("İşleminiz: ")
hesap = eval(veri)

print(hesap)

```

İngilizcedeevaluatediye bir kelime bulunur. Bu kelime, ‘değerlendirmeye tabi
tutmak, işleme sokmak, işlemek’ gibi anlamlar taşır. İşteeval()fonksiyonundakievalkelimesi buevaluatekelimesinin kısaltmasıdır. Yani bu
fonksiyonun görevi, kendisine verilen karakter dizilerini değerlendirmeye tabi
tutmak ya da işlemektir. Peki bu tam olarak ne anlama geliyor?

Aslında yukarıdaki örnek programı çalıştırdığımızda bu sorunun yanıtını kendi
kendimize verebiliyoruz. Bu programı çalıştırarak,“İşleminiz: “ifadesinden
sonra, örneğin,45*76yazıpEntertuşuna basarsak programımız bize3420çıktısı verecektir. Yani programımız hesap makinesi işlevini yerine
getirip45sayısı ile76sayısını çarpacaktır. Dolayısıyla, yukarıdaki
programı kullanarak her türlü aritmetik işlemi yapabilirsiniz. Hatta bu program,
son derece karmaşık aritmetik işlemlerin yapılmasına dahi müsaade eder.

Peki programımız bu işlevi nasıl yerine getiriyor? İsterseniz kodların üzerinden
tek tek geçelim.

Öncelikle programımızın en başına kullanım kılavuzuna benzer bir metin
yerleştirdik ve bu metniprint()fonksiyonu yardımıyla ekrana bastık.

Daha sonra kullanıcıdan alacağımız komutlarıveriadlı bir değişkene atadık.
Tabii ki kullanıcıyla iletişimi her zaman olduğu gibiinput()fonksiyonu
yardımıyla sağlıyoruz.

Ardından, kullanıcıdan gelen veriyieval()fonksiyonu yardımıyla
değerlendirmeye tabi tutuyoruz. Yani kullanıcının girdiği komutları işleme
sokuyoruz. Örneğin, kullanıcı46/2gibi bir veri girdiyse, bizeval()fonksiyonu yardımıyla bu46/2komutunu işletiyoruz. Bu işlemin sonucunu dahesapadlı başka bir değişken içinde depoluyoruz.

Eğer buradaeval()fonksiyonunu kullanmazsak, programımız, kullanıcının
girdiği45*76komutunu hiçbir işleme sokmadan dümdüz ekrana basacaktır.
Yani:

```python
print("""
Basit bir hesap makinesi uygulaması.

İşleçler:

 + toplama
 - çıkarma
 * çarpma
 / bölme

Yapmak istediğiniz işlemi yazıp ENTER
tuşuna basın. (Örneğin 23 ve 46 sayılarını
çarpmak için 23 * 46 yazdıktan sonra
ENTER tuşuna basın.)
""")

veri = input("İşleminiz: ")

print(veri)

```

Eğer programımızı yukarıdaki gibi,eval()fonksiyonu olmadan yazarsak,
kullanıcımız45*76gibi bir komut girdiğinde alacağı cevap dümdüz bir45
* 76çıktısı olacaktır. İşteeval()fonksiyonu, kullanıcının girdiği her
veriyi bir Python komutu olarak algılar ve bu veriyi işleme sokar. Yani45*76gibi bir şey gördüğünde, bu şeyi doğrudan ekrana yazdırmak yerine, işlemin
sonucu olan3420sayısını verir.

eval()fonksiyonunun, yukarıda anlattığımız özelliklerini okuduktan sonra,
‘Ne güzel bir fonksiyon! Her işimi görür bu!’ dediğinizi duyar gibiyim. Ama
aslında durum hiç de öyle değil. Neden mi?

```python
print("""
Basit bir hesap makinesi uygulaması.

İşleçler:

 + toplama
 - çıkarma
 * çarpma
 / bölme

Yapmak istediğiniz işlemi yazıp ENTER
tuşuna basın. (Örneğin 23 ve 46 sayılarını
çarpmak için 23 * 46 yazdıktan sonra
ENTER tuşuna basın.)
""")

veri = input("İşleminiz: ")
hesap = eval(veri)

print(hesap)

```

Şimdi yukarıdaki programı tekrar çalıştırın ve“İşleminiz: “ifadesinden sonra
şu cevabı verin:

```python
print("Merhaba Python!")

```

Bu komut şöyle bir çıktı vermiş olmalı:

```python
Merhaba Python!
None

```

> **Not**
> BuradakiNonedeğerini görmezden gelin. Bunu fonksiyonlar konusunu
anlatırken inceleyeceğiz.

Not

BuradakiNonedeğerini görmezden gelin. Bunu fonksiyonlar konusunu
anlatırken inceleyeceğiz.

Gördüğünüz gibi, yazdığımız program, kullanıcının girdiği Python komutunun
işletilmesine sebep oldu. Bu noktada, ‘Eee, ne olmuş!’ demiş olabilirsiniz.
Gelin bir de şuna bakalım. Şimdi programı tekrar çalıştırıp şu cevabı verin:

```python
open("deneme.txt", "w")

```

Bu cevap, bilgisayarınızdadeneme.txtadlı bir dosya oluşturulmasına sebep
oldu. Belki farkındasınız, belki farkında değilsiniz, ama aslında şu anda kendi
yazdığınız program sizin kontrolünüzden tamamen çıktı. Siz aslında bir hesap
makinesi programı yazmıştınız. Amaeval()fonksiyonu nedeniyle kullanıcıya
rastgele Python komutlarını çalıştırma imkanı verdiğiniz için programınız sadece
aritmetik işlemleri hesaplamak için kullanılmayabilir. Böyle bir durumda kötü
niyetli (ve bilgili) bir kullanıcı size çok büyük zarar verebilir. Mesela
kullanıcının, yukarıdaki programa şöyle bir cevap verdiğini düşünün:

```python
__import__("os").system("dir")

```

Burada anlamadığınız şeyleri şimdilik bir kenara bırakıp, bu komutun sonuçlarına
odaklanın. Gördüğünüz gibi, yukarıdaki programa bu cevabı vererek mevcut dizin
altındaki bütün dosyaları listeleyebildik. Yani programımız bir anda amacını
aştı. Artık bu aşamadan sonra bu programı şeytani bir amaca yönelik olarak
kullanmak tamamen programı kullanan kişiye kalmış… Bu programın, bir web
sunucusu üzerinde çalışan bir uygulama olduğunu ve bu programı kullananların
yukarıdaki gibi masumane bir şekilde dizin içindeki dosyaları listeleyen bir
komut yerine, dizin içindeki dosyaları ve hatta sabit disk üzerindeki her şeyi
silen bir komut yazdığını düşünün… Yanlış yazılmış bir program yüzünden bütün
verilerinizi kaybetmeniz işten bile değildir. (Bahsettiğim o, ‘bütün sabit diski
silen komutu’ kendi sisteminizde vermemeniz gerektiğini söylememe gerek yok,
değil mi?)

EğerSQL Injectionkavramını biliyorsanız, yukarıdaki kodların yol açtığı
güvenlik açığını gayet iyi anlamış olmalısınız. Zaten internet üzerinde yaygın
bir şekilde kullanılan ve web sitelerini hedef alanSQL Injectiontarzı
saldırılar da aynı mantık üzerinden gerçekleştiriliyor.SQL Injectionmetoduyla bir web sitesine saldırancracker’lar, o web sitesini programlayan
kişinin (çoğunlukla farkında olmadan) kullanıcıya verdiği rastgele SQL komutu
işletme yetkisini kötüye kullanarak gizli ve özel bilgileri ele
geçirebiliyorlar. ÖrneğinSQL Injectionmetodu kullanılarak, bir web sitesine
ait veritabanının içeriği tamamen silinebilir. Aynı şekilde, yukarıdakieval()fonksiyonu da kullanıcılarınıza rastgele Python komutlarını
çalıştırma yetkisi verdiği için kötü niyetli bir kullanıcının programınıza
sızmasına yol açabilecek potansiyele sahiptir.

Pekieval()fonksiyonunu asla kullanmayacak mıyız? Elbette kullanacağız. Bu
fonksiyonun kullanımını gerektiren durumlarla da karşılaşabilirsiniz. Ama şunu
asla aklınızdan çıkarmayın:eval()fonksiyonu her ne kadar son derece
yetenekli ve güçlü bir araç da olsa yanlış ellerde yıkıcı sonuçlar doğurabilir.
Program yazarken, eğereval()kullanmanızı gerektiren bir durumla karşı
karşıya olduğunuzu düşünüyorsanız, bir kez daha düşünün.eval()ile elde
edeceğiniz etkiyi muhtemelen başka ve çok daha iyi yöntemlerle de elde
edebilirsiniz. Üstelik performans açısındaneval()pek iyi bir tercih
değildir, çünkü bu fonksiyon (çoğu durumda farketmeseniz de) aslında yavaş
çalışır. O yüzden,eval()fonksiyonunu kullanacağınız zaman, bunun artı ve
eksilerini çok iyi tartın: Bu fonksiyonu kullanmak size ne kazandırıyor, ne
kaybettiriyor?

Ayrıcaeval()fonksiyonu kullanılacağı zaman, kullanıcıdan gelen veri bu
fonksiyona parametre olarak verilmeden önce sıkı bir kontrolden geçirilir. Yani
kullanıcının girdiği verieval()aracılığıyla doğrudan değerlendirmeye tabi
tutulmaz. Araya bir kontrol mekanizması yerleştirilir. Örneğin, yukarıdaki hesap
makinesi programında kullanıcının gireceği verileri sadece sayılar ve işleçlerle
sınırlandırabilirsiniz. Yani kullanıcınızın, izin verilen değerler harici bir
değer girmesini engelleyebilirsiniz. Bu durumu somutlaştırmak için şöyle bir
diyagram çizebiliriz:

Yukarıdaki diyagrameval()fonksiyonunun yanlış uygulanış biçimini
gösteriyor. Gördüğünüz gibi, veri doğrudaneval()fonksiyonuna gidiyor ve
çıktı olarak veriliyor. Böyle bir durumda,eval()fonksiyonu kullanıcıdan
gelen verinin ne olduğuna bakmadan, veriyi doğrudan komut olarak değerlendirip
işleteceği için programınızı kullanıcının insafına terketmiş oluyorsunuz.

Aşağıdaki diyagram iseeval()fonksiyonunun doğru uygulanış biçimini
gösteriyor:

Burada ise, verieval()fonksiyonuna ulaşmadan önce kontrolden geçiriliyor.
Eğer veri ancak kontrol aşamasından geçerseeval()fonksiyona ulaşabilecek
ve oradan da çıktı olarak verilebilecektir. Böylece kullanıcıdan gelen komutları
süzme imkanına sahip oluyoruz.

Gördüğünüz gibi, Pythoneval()gibi bir fonksiyon yardımıyla karakter
dizileri içinde geçen Python kodlarını ayıklayıp bunları çalıştırabiliyor. Bu
sayede, mesela bizeinput()fonksiyonu aracılığıyla gelen bir karakter
dizisi içindeki Python kodlarını işletme imkanına sahip olabiliyoruz. Bu
özellik, dikkatli kullanıldığında, işlerinizi epey kolaylaştırabilir.

Python’daeval()fonksiyonuna çok benzeyenexec()adlı başka bir
fonksiyon daha bulunur.eval()ile yapamadığımız bazı şeyleriexec()ile
yapabiliriz. Bu fonksiyon yardımıyla, karakter dizileri içindeki çok kapsamlı
Python kodlarını işletebilirsiniz.

Örneğineval()fonksiyonu bir karakter dizisi içindeki değişken tanımlama
işlemini yerine getiremez. Yanieval()ile şöyle bir şey yapamazsınız:

```python
>>> eval("a = 45")

```

Amaexec()ile böyle bir işlem yapabilirsiniz:

```python
>>> exec("a = 45")

```

Böyleceaadlı bir değişken tanımlamış olduk. Kontrol edelim:

```python
>>> print(a)

45

```

eval()veexec()fonksiyonları özellikle kullanıcıdan alınan verilerle
doğrudan işlem yapmak gereken durumlarda işinize yarar. Örneğin bir hesap
makinesi yaparkeneval()fonksiyonundan yararlanabilirsiniz.

Aynı şekilde mesela insanlara Python programlama dilini öğreten bir program
yazıyorsanızexec()fonksiyonunu şöyle kullanabilirsiniz:

```python
d1 = """

Python'da ekrana çıktı verebilmek için print() adlı bir
fonksiyondan yararlanıyoruz. Bu fonksiyonu şöyle kullanabilirsiniz:

>>> print("Merhaba Dünya")

Şimdi de aynı kodu siz yazın!

>>> """

girdi = input(d1)

exec(girdi)

d2 = """

Gördüğünüz gibi print() fonksiyonu, kendisine
parametre olarak verilen değerleri ekrana basıyor.

Böylece ilk dersimizi tamamlamış olduk. Şimdi bir
sonraki dersimize geçebiliriz."""

print(d2)

```

Buradaexec()ile yaptığımız işieval()ile de yapabiliriz. Ama mesela
eğer bir sonraki derste ‘Python’da değişkenler’ konusunu öğretecekseniz,eval()yerineexec()fonksiyonunu kullanmak durumunda kalabilirsiniz.

eval()fonksiyonunu anlatırken güvenlik ile ilgili olarak söylediğimiz her
şeyexec()fonksiyonu için de geçerlidir. Dolayısıyla bu iki fonksiyonu çok
dikkatli bir şekilde kullanmanız ve bu fonksiyonların doğurduğu güvenlik
açığının bilincinde olmanız gerekiyor.

Henüz Python bilgilerimiz çok kısıtlı olduğu içineval()veexec()fonksiyonlarını bütün ayrıntılarıyla inceleyemiyoruz. Ama bilgimiz arttıkça bu
fonksiyonların ne kadar güçlü (ve tehlikeli) araçlar olduğunu siz de
göreceksiniz.

### format() Metodu

Python programlama dili içindeki çok temel bazı araçları incelediğimize göre, bu
noktada Python’daki küçük ama önemli bir konuya değinelim bu bölümü kapatmadan
önce.

İnternette dolaşırken mutlaka şuna benzer bir sayfayla karşılaşmış olmalısınız:

Burada belli ki adres çubuğunafdkgd.comdiye bir URL
yazmışız, ama böyle bir internet adresi olmadığı için, kullandığımız internet
tarayıcısı bize şöyle bir mesaj vermiş:

```python
Hata! Google Chrome fdkgd.com sitesini bulamadı

```

Şimdi dedadasdaf.comadresini arayalım…

Yine böyle bir adres olmadığı için, bu defa tarayıcımız bize şöyle bir uyarı
gösterecek:

```python
Hata! Google Chrome dadasdaf.com sitesini bulamadı

```

Gördüğünüz gibi, hata mesajlarında değişen tek yer, aradığımız sitenin adresi.
Yani internet tarayıcımız bu hata için şöyle bir taslağa sahip:

```python
Hata! Google Chrome ... sitesini bulamadı

```

Burada…ile gösterdiğimiz yere, bulunamayan URL yerleştiriliyor. Peki böyle
bir şeyi Python programlama dili ile nasıl yapabiliriz?

Çok basit:

```python
#Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz
url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ")

#Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz
print("Hata! Google Chrome", url, "sitesini bulamadı")

```

Gördüğünüz gibi, şimdiye kadar öğrendiğimiz bilgileri kullanarak böyle bir
programı rahatlıkla yazabiliyoruz.

Peki ya biz kullanıcının girdiği internet adresini mesela tırnak içinde
göstermek istersek ne olacak? Yani örneğin şöyle bir çıktı vermek istersek:

```python
Hata! Google Chrome 'fdsfd.com' sitesini bulamadı

```

Bunun için yine karakter dizisi birleştirme yönteminden yararlanabilirsiniz:

```python
#Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz
url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ")

#Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz
print("Hata! Google Chrome", "'" + url + "'", "sitesini bulamadı")

```

Burada,+işaretlerini kullanarak, kullanıcının girdiği adresin sağına ve
soluna birer tırnak işaretini nasıl yerleştirdiğimize dikkat edin.

Gördüğünüz gibi bu yöntem işe yarıyor, ama ortaya çıkan karakter dizisi de
oldukça karmaşık görünüyor. İşte bu tür ‘karakter dizisi biçimlendirme’
işlemleri için Python bize çok faydalı bir araç sunuyor. Bu aracın adıformat().

Bu aracı şöyle kullanıyoruz:

```python
#Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz
url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ")

#Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz
print("Hata! Google Chrome {} sitesini bulamadı".format(url))

```

Bir de bulunamayan internet adresini tırnak içine alalım:

```python
print("Hata! Google Chrome '{}' sitesini bulamadı".format(url))

```

Görüyorsunuz ya, biraz önce karakter dizisi birleştirme yöntemini kullanarak
gerçekleştirdiğimiz işlemi, çok daha basit bir yolla gerçekleştirme imkanı
sunuyor bize buformat()denen araç…

Pekiformat()nasıl çalışıyor?

Bunu anlamak için şu basit örneklere bir bakalım:

```python
>>> print("{} ve {} iyi bir ikilidir".format("Python", "Django"))

'Python ve Django iyi bir ikilidir'

>>> print("{} {}'yi seviyor!".format("Ali", "Ayşe"))

'Ali Ayşe'yi seviyor!'

>>> print("{} {} yaşında bir {}dur".format("Ahmet", "18", "futbolcu"))

'Ahmet 18 yaşında bir futbolcudur'

```

Elbette bu örnekleri şöyle de yazabilirdik:

```python
>>> metin = "{} ve {} iyi bir ikilidir"
>>> metin.format("Python", "Django")

'Python ve Django iyi bir ikilidir'

>>> metin = "{} {}'yi seviyor!"
>>> metin.format("Ali", "Ayşe")

'Ali Ayşe'yi seviyor!'

>>> metin = "{} {} yaşında bir {}dur"
>>> metin.format("Ahmet", "18", "futbolcu")

'Ahmet 18 yaşında bir futbolcudur'

```

Burada taslak metni doğrudanformat()metoduna parametre olarak vermeden
önce bir değişkene atadık. Böylece bu metni daha kolay bir şekilde
kullanabildik.

Bu örneklerin,format()denen aracı anlamak konusunda size epey fikir
verdiğini zannediyorum. Ama isterseniz bu aracın ne olduğunu ve nasıl
çalıştığını daha ayrıntılı olarak incelemeye geçmeden önce başka bir örnek daha
verelim.

Varsayalım ki kullanıcıdan aldığı bilgiler doğrultusunda, özel bir konu üzerine
dilekçe oluşturan bir program yazmak istiyorsunuz.

Dilekçe taslağımız şu şekilde olsun:

```python
 tarih:

T.C.
... ÜNİVERSİTESİ
... Fakültesi Dekanlığına

Fakülteniz ..........Bölümü ......... numaralı öğrencisiyim. Ekte sunduğum
belgede belirtilen mazeretim gereğince ....... Eğitim-Öğretim Yılı .........
yarıyılında öğrenime ara izni (kayıt dondurma) istiyorum.

 Bilgilerinizi ve gereğini arz ederim.

 İmza

Ad-Soyadı :
T.C. Kimlik No. :
Adres :
Tel. :
Ekler :

```

Amacınız bu dilekçedeki boşluklara gelmesi gereken bilgileri kullanıcıdan alıp,
eksiksiz bir dilekçe ortaya çıkarmak.

Kullanıcıdan bilgi alma kısmı kolay.input()fonksiyonunu kullanarak gerekli
bilgileri kullanıcıdan alabileceğimizi biliyorsunuz:

```python
tarih = input("tarih: ")
üniversite = input("üniversite adı: ")
fakülte = input("fakülte adı: ")
bölüm = input("bölüm adı: ")
öğrenci_no = input("öğrenci no. :")
öğretim_yılı = input("öğretim yılı: ")
yarıyıl = input("yarıyıl: ")
ad = input("öğrencinin adı: ")
soyad = input("öğrencinin soyadı: ")
tc_kimlik_no = input("TC Kimlik no. :")
adres = input("adres: ")
tel = input("telefon: ")
ekler = input("ekler: ")

```

Bilgileri kullanıcıdan aldık. Peki ama bu bilgileri dilekçe taslağı içindeki
boşluklara nasıl yerleştireceğiz?

Şu ana kadar öğrendiğimizprint()fonksiyonunu ve\tve\ngibi kaçış
dizilerini kullanarak istediğiniz çıktıyı elde etmeyi deneyebilirsiniz. Ama
denediğinizde siz de göreceksiniz ki, bu tür yöntemleri kullanarak yukarıdaki
dilekçe taslağını doldurmak inanılmaz zor ve vakit alıcı olacaktır. Halbuki
bunların hiçbirine gerek yok. Çünkü Python bize bu tür durumlarda kullanılmak
üzere çok pratik bir araç sunuyor. Şimdi çok dikkatlice inceleyin şu kodları:

```python
dilekçe = """
 tarih: {}

T.C.
{} ÜNİVERSİTESİ
{} Fakültesi Dekanlığına

Fakülteniz {} Bölümü {} numaralı öğrencisiyim. Ekte sunduğum belgede
belirtilen mazeretim gereğince {} Eğitim-Öğretim Yılı {}.
yarıyılında öğrenime ara izni (kayıt dondurma) istiyorum.

 Bilgilerinizi ve gereğini arz ederim.

 İmza

Ad : {}
Soyad : {}
T.C. Kimlik No. : {}
Adres : {}
Tel. : {}
Ekler : {}
"""

tarih = input("tarih: ")
üniversite = input("üniversite adı: ")
fakülte = input("fakülte adı: ")
bölüm = input("bölüm adı: ")
öğrenci_no = input("öğrenci no. :")
öğretim_yılı = input("öğretim yılı: ")
yarıyıl = input("yarıyıl: ")
ad = input("öğrencinin adı: ")
soyad = input("öğrencinin soyadı: ")
tc_kimlik_no = input("TC Kimlik no. :")
adres = input("adres: ")
tel = input("telefon: ")
ekler = input("ekler: ")

print(dilekçe.format(tarih, üniversite, fakülte, bölüm,
 öğrenci_no, öğretim_yılı, yarıyıl,
 ad, soyad, tc_kimlik_no,
 adres, tel, ekler))

```

Bu kodlara (ve bundan önceki örneklere) bakarak birkaç tespitte bulunalım:
1. Taslak metinde kullanıcıdan alınacak bilgilerin olduğu yerlere birer{}işareti yerleştirdik.
1. Taslaktaki eksiklikleri tamamlayacak verileriinput()fonksiyonu
yardımıyla kullanıcıdan tek tek aldık.
1. Son olarak,print()fonksiyonu yardımıyla metni tam bir şekilde ekrana
çıktı olarak verdik.

Taslak metinde kullanıcıdan alınacak bilgilerin olduğu yerlere birer{}işareti yerleştirdik.

Taslaktaki eksiklikleri tamamlayacak verileriinput()fonksiyonu
yardımıyla kullanıcıdan tek tek aldık.

Son olarak,print()fonksiyonu yardımıyla metni tam bir şekilde ekrana
çıktı olarak verdik.

Şimdi son tespitimizi biraz açıklayalım. Gördüğünüz gibi,print()fonksiyonu
içindedilekçe.format()gibi bir yapı var. Buradadilekçedeğişkenine
nokta işareti ile bağlanmışformat()adlı, fonksiyon benzeri bir araç
görüyoruz. Bu araca teknik dilde ‘metot’ adı verilir.format()metodunun
parantezleri içinde ise, kullanıcıdan alıp birer değişkene atadığımız veriler
yer alıyor.

Dilerseniz yukarıda olan biteni daha net anlayabilmek için bu konunun başına
verdiğimiz örneklere geri dönelim.

İlk olarak şöyle bir örnek vermiştik:

```python
#Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz
url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ")

#Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz
print("Hata! Google Chrome {} sitesini bulamadı".format(url))

```

Burada kullanıcının gireceği internet adresinin yerini tutması için{}işaretlerinden yararlanarak şöyle bir karakter dizisi oluşturduk:

```python
"Hata! Google Chrome {} sitesini bulamadı"

```

Gördüğünüz gibi,{}işareti karakter dizisi içinde URL’nin geleceği yeri
tutuyor. Bu{}işaretinin yerine neyin geleceğiniformat()metodunun
parantezleri içinde belirtiyoruz. Dikkatlice bakın:

```python
print("Hata! Google Chrome {} sitesini bulamadı".format(url))

```

Elbette eğer istersek yukarıdaki örneği şöyle de yazabilirdik:

```python
url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ")

#Kullanıcıya gösterilecek hata için bir taslak metin oluşturuyoruz
hata_taslağı = "Hata! Google Chrome {} sitesini bulamadı"

print(hata_taslağı.format(url))

```

Burada hata metnini içeren karakter dizisini doğrudanformat()metoduna
bağlamak yerine, bunu bir değişkene atayıp,format()metodunu bu değişkene
bağladık.

Bunun dışında şu örnekleri de vermiştik:

```python
>>> metin = "{} ve {} iyi bir ikilidir"
>>> metin.format("Python", "Django")

'Python ve Django iyi bir ikilidir

>>> metin = "{} {}'yi seviyor!"
>>> metin.format("Ali", "Ayşe")

'Ali Ayşe'yi seviyor!'

>>> metin = "{} {} yaşında bir {}dur"
>>> metin.format("Ahmet", "18", "futbolcu")

'Ahmet 18 yaşında bir futbolcudur'

```

Burada da, gördüğüz gibi, öncelikle bir karakter dizisi tanımlıyoruz. Bu
karakter dizisi içindeki değişken değerleri ise{}işaretleri ile
gösteriyoruz. Daha sonraformat()metodunu alıp bu karakter dizisine
bağlıyoruz. Karakter dizisi içindeki{}işaretleri ile gösterdiğimiz yerlere
gelecek değerleri deformat()metodunun parantezleri içinde gösteriyoruz.
Yalnız burada şuna dikkat etmemiz lazım: Karakter dizisi içinde kaç tane{}işareti varsa,format()metodunun parantezleri içinde de o sayıda değer
olması gerekiyor.

Bu yapının, yazdığımız programlarda işimizi ne kadar kolaylaştıracağını tahmin
edebilirsiniz. Kısa karakter dizilerinde pek belli olmayabilir, ama özellikle
çok uzun ve boşluklu karakter dizilerini biçimlendirirkenformat()metodunun
hayat kurtardığına kendiniz de şahit olacaksınız.

İlerleyen derslerimizdeformat()metodunu ve karakter dizisi biçimlendirme
konusunu çok daha ayrıntılı bir şekilde inceleyeceğiz. Ancak yukarıda verdiğimiz
bilgilerformat()metodunu verimli bir şekilde kullanabilmenizi sağlamaya
yetecek düzeydedir.

## Koşullu Durumlar

Artık Python programlama dilinde belli bir noktaya geldik sayılır. Ama eğer
farkettiyseniz, yine de elimizi kolumuzu bağlayan, istediğimiz şeyleri yapmamıza
engel olan bir şeyler var. İşte bu bölümde, Python programlama dilinde hareket
alanımızı bir hayli genişletecek araçları tanıyacağız.

Aslında sadece bu bölümde değil, bu bölümü takip eden her bölümde, hareket
alanımızı kısıtlayan duvarları tek tek yıktığımıza şahit olacaksınız. Özellikle
bu bölümde inceleyeceğimiz ‘koşullu durumlar’ konusu, tabir yerindeyse,
Python’da boyut atlamamızı sağlayacak.

O halde hiç vakit kaybetmeden yola koyulalım…

Şimdiye kadar öğrendiğimiz Python bilgilerini kullanarak şöyle bir program
yazabileceğimizi biliyorsunuz:

```python
yaş = 15

print("""Programa hoşgeldiniz!

Programımızı kullanabilmek için en az
13 yaşında olmalısınız.""")

print("Yaşınız: ", yaş)

```

Burada yaptığımız şey çok basit. Öncelikle, değeri15olan,yaşadlı bir
değişken tanımladık. Daha sonra, programımızı çalıştıran kullanıcılar için bir
hoşgeldin mesajı hazırladık. Son olarak dayaşdeğişkeninin değerini ekrana
yazdırdık.

Bu programın özelliği tek sesli bir uygulama olmasıdır. Yani bu programda
kullanıcıyla herhangi bir etkileşim yok. Burada bütün değerleri/değişkenleri
programcı olarak kendimiz belirliyoruz. Bu programın ne kadar yavan olduğunu
herhalde söylemeye gerek yok.

Ancak yine önceki derslerde öğrendiğimizinput()fonksiyonu yardımıyla
yukarıdaki programın üzerindeki yavanlığı bir nebze de olsa atabilir, bu
programı rahatlıkla çok sesli bir hale getirebilir, yani kullanıcıyla etkileşim
içine girebiliriz.

Yukarıdaki tek sesli uygulamayı,input()fonksiyonunu kullanarak çok sesli
bir hale nasıl getireceğimizi gayet iyi bildiğinize eminim:

```python
print("""Programa hoşgeldiniz!

Programımızı kullanabilmek için en az
13 yaşında olmalısınız.""")

print("Lütfen yaşınızı girin.\n")

yaş = input("Yaşınız: \t")

print("Yaşınız: ", yaş)

```

Tıpkı bir önceki uygulamada olduğu gibi, burada da yaptığımız şey çok basit. İlk
örnekteyaşdeğişkeninin değerini kendimiz elle yazmıştık. İkinci örnekte ise
buyaşdeğişkenini kullanıcıdan alıyoruz ve tıpkı ilk örnekte olduğu gibi, bu
değişkenin değerini ekrana yazdırıyoruz.

Bu arada, yukarıdaki uygulamada yer verdiğimiz\nve\tadlı kaçış
dizileri de artık sizin için oldukça tanıdık.\nkaçış dizisi yardımıyla bir
alt satıra geçtiğimizi,\tadlı kaçış dizisi yardımıyla da bir sekmelik
boşluk bıraktığımızı biliyorsunuz.

Gördüğünüz gibi, şu ana kadar öğrendiklerimizle ancak kullanıcıdan gelen yaş
bilgisini ekrana yazdırabiliyoruz. Öğrendiğimizinput()fonksiyonu bize
kullanıcıdan bilgi alma imkanı sağlıyor. Ama kullanıcıdan gelen bu bilgiyi
şimdilik ancak olduğu gibi kullanabiliyoruz. Yani mesela yukarıdaki örneği
dikkate alarak konuşacak olursak, kullanıcının yaşı eğer 13’ün üzerindeyse onu
programa kabul edecek, yok eğer 13 yaşın altındaysa da programdan atacak bir
mekanizma üretemiyoruz. Yapabildiğimiz tek şey, kullanıcının girdiği veriyi
ekrana yazdırmak.

Yukarıda verdiğimiz örneklerle nereye varmaya çalıştığımızı az çok tahmin
etmişsinizdir. Dikkat ederseniz yukarıda sözünü ettiğimiz şey koşullu bir durum.
Yani aslında yapmak istediğimiz şey, kullanıcının yaşını denetleyip, onun
programa kabul edilmesini 13 yaşından büyük olma koşuluna bağlamak.

İsterseniz tam olarak neden bahsettiğimizi anlayabilmek için, birkaç vaka örneği
verelim.

Diyelim ki Google’ın Gmail hizmeti aracılığıyla bir e.posta hesabı aldınız. Bu
hesaba gireceğiniz zaman Gmail size bir kullanıcı adı ve parola sorar. Siz de
kendinize ait kullanıcı adını ve parolayı sayfadaki kutucuklara yazarsınız. Eğer
yazdığınız kullanıcı adı ve parola doğruysa hesabınıza erişebilirsiniz. Ama eğer
kullanıcı adınız ve parolanız doğru değilse hesabınıza erişemezsiniz. Yani
e.posta hesabınıza erişmeniz, kullanıcı adı ve parolayı doğru girme koşuluna
bağlıdır.

Ya da şu vaka örneğini düşünelim: Diyelim ki Pardus’ta komut satırı aracılığıyla
güncelleme işlemi yapacaksınız.sudopisiupkomutunu verdiğiniz zaman
güncellemelerin listesi size bildirilecek, bu güncellemeleri yapmak isteyip
istemediğiniz sorulacaktır. Eğer evet cevabı verirseniz güncelleme işlemi
başlar. Ama eğer hayır cevabı verirseniz güncelleme işlemi başlamaz. Yani
güncelleme işleminin başlaması kullanıcının evet cevabı vermesi koşuluna
bağlıdır.

İşte bu bölümde biz bu tür koşullu durumlardan söz edeceğiz.

### Koşul Deyimleri

Hiç kuşkusuz, koşula bağlı durumlar Python’daki en önemli konulardan biridir.
Giriş bölümünde bahsettiğimiz koşullu işlemleri yapabilmek için ‘koşul
deyimleri’ adı verilen birtakım araçlardan yararlanacağız. Gelin şimdi bu
araçların neler olduğunu görelim.

#### if

Python programlama dilinde koşullu durumları belirtmek için üç adet deyimden
yararlanıyoruz:
- if
- elif
- else

if

elif

else

İsterseniz önceifdeyimi ile başlayalım…

Eğer daha önceden herhangi bir programlama dilini az da olsa kurcalama
fırsatınız olduysa, bir programlama dilindeifdeyimlerinin ne işe
yaradığını az çok biliyorsunuzdur. Daha önceden hiç programcılık deneyiminiz
olmamışsa da ziyanı yok. Zira bu bölümdeifdeyimlerinin ne işe yaradığını
ve nerelerde kullanıldığını enine boyuna tartışacağız.

İngilizce bir kelime olan ‘if’, Türkçede ‘eğer’ anlamına gelir. Anlamından da
çıkarabileceğimiz gibi, bu kelime bir koşul bildiriyor. Yani ‘eğer bir şey
falanca ise…’ ya da ‘eğer bir şey filanca ise…’ gibi… İşte biz
Python’da bir koşula bağlamak istediğimiz durumlarıifdeyimi aracılığıyla
göstereceğiz.

Gelin isterseniz bu deyimi nasıl kullanacağımıza dair ufacık bir örnek vererek
işe başlayalım:

Öncelikle elimizde şöyle bir değişken olsun:

```python
n = 255

```

Yukarıda verdiğimiz değişkenin değerinin bir karakter dizisi değil, aksine bir
sayı olduğunu görüyoruz. Şimdi bu değişkenin değerini sorgulayalım:

```python
if n > 10:

```

Burada sayının 10’dan büyük olup olmadığına bakıyoruz.

Burada gördüğümüz>işaretinin ne demek olduğunu açıklamaya gerek yok sanırım.
Hepimizin bildiği ‘büyüktür’ işareti Python’da da aynen bildiğimiz şekilde
kullanılıyor. Mesela ‘küçüktür’ demek isteseydik,<işaretini kullanacaktık.
İsterseniz hemen şurada araya girip bu işaretleri yeniden hatırlayalım:
| İşleç | Anlamı |
| --- | --- |
| > | büyüktür |
| < | küçüktür |
| >= | büyük eşittir |
| <= | küçük eşittir |
| == | eşittir |
| != | eşit değildir |

İşleç

Anlamı

>

büyüktür

<

küçüktür

>=

büyük eşittir

<=

küçük eşittir

==

eşittir

!=

eşit değildir

Gördüğünüz gibi hiçbiri bize yabancı gelecek gibi değil. Yalnızca en sondaki
‘eşittir’ (==) ve ‘eşit değildir’ (!=) işaretleri biraz değişik gelmiş
olabilir. Burada ‘eşittir’ işaretinin=olmadığına dikkat edin. Python’da=işaretini değer atama işlemleri için kullanıyoruz.==işaretini ise iki adet
değerin birbirine eşit olup olmadığını denetlemek için… Mesela:

```python
>>> a = 26

```

Burada değeri26olanaadlı bir değişken belirledik. Yaniadeğişkenine
değer olarak26sayısını atadık. Ayrıca burada, değer atama işleminin ardındanEntertuşuna bastıktan sonra Python hiçbir şey yapmadan bir alt satıra geçti.
Bir de şuna bakalım:

```python
>>> a == 26

True

```

Burada ise yaptığımız şeyadeğişkeninin değerinin26olup olmadığını
sorgulamaka==26komutunu verdikten sonra Python bizeTruediye bir
çıktı verdi. Bu çıktının anlamını biraz sonra öğreneceğiz. Ama şimdi isterseniz
konuyu daha fazla dağıtmayalım. Biz şimdilik sadece=ve==işaretlerinin
birbirinden tamamen farklı anlamlara geldiğini bilelim yeter.

Ne diyorduk?

```python
if n > 10:

```

Bu ifadeyle Python’a şöyle bir şey demiş oluyoruz:

Eğernsayısının değeri 10’dan büyükse…

Burada kullandığımız işaretlere dikkat edin. En sonda bir adet:işaretinin
olduğunu gözden kaçırmıyoruz. Bu tür işaretler Python için çok önemlidir.
Bunları yazmayı unutursak Python gözümüzün yaşına bakmayacaktır.

Dedik ki,ifn>10:ifadesi, ‘eğer n değişkeninin değeri 10’dan büyükse…’
anlamına gelir. Bu ifadenin eksik olduğu apaçık ortada. Yani belli ki bu
cümlenin bir de devamı olması gerekiyor. O halde biz de devamını getirelim:

```python
if n > 10:
 print("sayı 10'dan büyüktür!")

```

Burada çok önemli bir durumla karşı karşıyayız. Dikkat ederseniz, ikinci satırı
ilk satıra göre girintili yazdık. Elbette bunu şirinlik olsun diye yapmadık.
Python programlama dilinde girintiler çok büyük önem taşır. Hatta ne kadarlık
bir girinti verdiğiniz bile önemlidir. Eğer Python kodlarına duyarlı bir metin
düzenleyici kullanıyorsanız, kullandığınız metin düzenleyici çoğu durumda sizin
yerinize uygun bir şekilde girintilemeyi yapacaktır. Mesela IDLE adlı geliştirme
ortamını kullananlar, ilk satırdaki:işaretini koyupEntertuşuna
bastıklarında otomatik olarak girinti verildiğini farkedeceklerdir. Eğer
kullandığınız metin düzenleyici, satırları otomatik olarak girintilemiyorsa
sizin bu girintileme işlemini elle yapmanız gerekecektir. Yalnız elle
girintilerken, ne kadar girinti vereceğimize dikkat etmeliyiz. Genel kural
olarak4boşlukluk bir girintileme uygun olacaktır. Girintileme işlemini
klavyedeki sekme (Tab) tuşuna basarak da yapabilirsiniz. Ama aynı program
içinde sekmelerle boşlukları karıştırmayın. Yani eğer girintileme işlemini
klavyedeki boşluk (Space) tuşuna basarak yapıyorsanız, program boyunca aynı
şekilde yapın. (Ben size girinti verirkenTabtuşu yerineSpacetuşunu
kullanmanızı tavsiye ederim). Kısaca söylemek gerekirse; Python’da girintileme
ve girintilemede tutarlılık çok önemlidir. Özellikle büyük programlarda,
girintilemeler açısından tutarsızlık gösterilmesi programın çalışmamasına sebep
olabilir.

> **Not**
> Python’da girintileme konusuyla ilgili daha ayrıntılı bilgi için:http://www.istihza.com/blog/python-ve-metin-duzenleyiciler.html(arşiv linki)

Not

Python’da girintileme konusuyla ilgili daha ayrıntılı bilgi için:http://www.istihza.com/blog/python-ve-metin-duzenleyiciler.html(arşiv linki)

Eğer yukarıdakiifbloğunu bir metin düzenleyici içine değil de doğrudan
etkileşimli kabuğa yazmışsanız bazı şeyler dikkatinizi çekmiş olmalı.
Etkileşimli kabuktaifsayı>10:satırını yazıpEntertuşuna bastığınızda
şöyle bir görüntüyle karşılaşmış olmalısınız:

```python
>>> if n > 10:
...

```

Dikkat ederseniz,>>>işareti,…işaretine dönüştü. Eğer bu noktada
herhangi bir şey yazmadanEntertuşuna basacak olursanız Python size şöyle bir
hata mesajı verecektir:

```python
File "<stdin>", line 2
 ^
IndentationError: expected an indented block

```

Hata mesajında da söylendiği gibi, Python bizden girintilenmiş bir blok
beklerken, biz onun bu beklentisini karşılamamışız. Dolayısıyla bize yukarıdaki
hata mesajını göstermiş.…işaretini gördükten sonra yapmamız gereken şey,
dört kez boşluk (Space) tuşuna basarak girinti oluşturmak veifbloğunun
devamını yazmak olmalıydı. Yani şöyle:

```python
>>> if n > 10:
... print("sayı 10'dan büyüktür!")
...

```

Gördüğünüz gibi,print()fonksiyonunu yazıpEntertuşuna bastıktan sonra
yine…işaretini gördük. Python burada bizden yeni bir satır daha bekliyor.
Ama bizim yazacak başka bir kodumuz olmadığı için tekrarEntertuşuna
basıyoruz ve nihai olarak şöyle bir görüntü elde ediyoruz:

```python
>>> if n > 10:
... print("sayı 10'dan büyüktür!")
...
sayı 10'dan büyüktür!
>>>

```

Demek ki255sayısı10’dan büyükmüş! Ne büyük bir buluş! Merak etmeyin, daha
çok şey öğrendikçe daha mantıklı programlar yazacağız. Burada amacımız işin
temelini kavramak. Bunu da en iyi, (çok mantıklı olmasa bile) basit programlar
yazarak yapabiliriz.

Şimdi metin düzenleyicimizi açarak daha mantıklı şeyler yazmaya çalışalım. Zira
yukarıdaki örnekte değişkeni kendimiz belirlediğimiz için, bu değişkenin
değeriniifdeyimleri yardımıyla denetlemek pek akla yatkın görünmüyor. Ne
de olsa değişkenin değerinin ne olduğunu biliyoruz. Dolayısıyla bu değişkenin10sayısından büyük olduğunu da biliyoruz! Bunuifdeyimiyle kontrol etmek
çok gerekli değil. Ama şimdi daha makul bir iş yapacağız. Değişkeni biz
belirlemek yerine kullanıcıya belirleteceğiz:

```python
sayı = int(input("Bir sayı giriniz: "))

if sayı > 10:
 print("Girdiğiniz sayı 10'dan büyüktür!")

if sayı < 10:
 print("Girdiğiniz sayı 10'dan küçüktür!")

if sayı == 10:
 print("Girdiğiniz sayı 10'dur!")

```

Gördüğünüz gibi, art arda üç adetifbloğu kullandık. Bu kodlara göre, eğer
kullanıcının girdiği sayı10’dan büyükse, ilkifbloğu işletilecek; eğer
sayı10’dan küçükse ikinciifbloğu işletilecek; eğer sayı 10’a eşit ise
üçüncüifbloğu işletilecektir. Peki ya kullanıcı muziplik yapıp sayı yerine
harf yazarsa ne olacak? Böyle bir ihtimal için programımıza herhangi bir
denetleyici yerleştirmedik. Dolayısıyla eğer kullanıcı sayı yerine harf girerse
programımız hata verecek, yani çökecektir. Bu tür durumlara karşı nasıl önlem
alacağımızı ilerleyen derslerimizde göreceğiz. Biz şimdilik bildiğimiz yolda
yürüyelim.

Yukarıdaki örnekteinput()ile gelen karakter dizisini,int()fonksiyonu
yardımıyla bir sayıya dönüştürdüğümüze dikkat edin. Kullanıcıdan gelen veriyi
büyüklük-küçüklük ölçütüne göre inceleyeceğimiz için, gelen veriyi bir sayıya
dönüştürmemiz gerekiyor. Bunu daint()fonksiyonu ile yapabileceğimizi
biliyorsunuz.

Elbette yukarıdaki dönüştürme işlemini şöyle de yapabilirdik:

```python
sayı = input("Bir sayı giriniz: ")
sayı = int(sayı)

```

Burada önceinput()fonksiyonuyla veriyi aldık, daha sonra bu veriyi ayrı
bir yerde sayıya dönüştürüp tekrarsayıadlı değişkene atadık.

ifdeyimlerini kullanıcı adı veya parola denetlerken de kullanabiliriz.
Mesela şöyle bir program taslağı yazabiliriz:

```python
print("""
Dünyanın en gelişmiş e.posta hizmetine
hoşgeldiniz. Yalnız hizmetimizden
yararlanmak için önce sisteme giriş
yapmalısınız.
""")

parola = input("Parola: ")

if parola == "12345678":
 print("Sisteme Hoşgeldiniz!")

```

Gördüğünüz gibi, programın başında üç tırnak işaretlerinden yararlanarak uzun
bir metni kullanıcıya gösterdik. Bu bölümü, kendiniz göze hoş gelecek bir
şekilde süsleyebilirsiniz de. Eğer kullanıcı, kendisine parola sorulduğunda
cevap olarak“12345678”yazarsa kullanıcıyı sisteme alıyoruz.

Yukarıdaki örnekte, kullanıcının girdiği parola“12345678”ise kendisine“Sisteme Hoşgeldiniz!”mesajını gösteriyoruz. Mantık olarak bunun tersini
yapmak da mümkündür. Yani:

```python
if parola != "12345678":
 print("Ne yazık ki yanlış parola girdiniz!")

```

Burada ise bir önceki örneğin mantığını ters çevirdik. Önceki örnekteparoladeğişkeni“12345678”adlı karakter dizisine eşitse (ifparola=="12345678") bir işlem yapıyorduk. Yukarıdaki örnekte iseparoladeğişkeni“12345678”adlı karakter dizisine eşit değilse (ifparola!="12345678")
bir işlem yapıyoruz.

Bu iki örneğin de aslında aynı kapıya çıktığını görüyorsunuz. Tek değişiklik,
kullanıcıya gösterilen mesajlardadır.

Böylece Python’daki koşullu durumlar üzerindeki incelememizin ilk ve en önemli
aşamasını geride bırakmış olduk. Dikkat ettiysenizifdeyimi sayesinde
programlarımıza karar vermeyi öğrettik. Bu deyim yardımıyla, kullanıcıdan
aldığımız herhangi bir verinin niteliği üzerinde kapsamlı bir karar verme işlemi
yürütebiliyoruz. Yani artık programlarımız kullanıcıdan alınan veriyi olduğu
gibi kabul etmekle yetinmiyor. Kullanıcının girdiği verinin ne olduğuna bağlı
olarak programlarımızın farklı işlemler yapmasını da sağlayabiliyoruz.

Daha önce de söylediğimiz gibi,ifdeyimi dışında Python’da koşullu
durumları ifade etmek için kullandığımız,elifveelseadlı iki deyim
daha vardır. Bunlarifile birlikte kullanılırlar. Gelin isterseniz bu iki
deyimden, adıelifolana bakalım.

#### elif

Python’da,ifdeyimleriyle birlikte kullanılan ve yine koşul belirten bir
başka deyim deelifdeyimidir. Buna şöyle bir örnek verebiliriz:

```python
yaş = int(input("Yaşınız: "))

if yaş == 18:
 print("18 iyidir!")

elif yaş < 0:
 print("Yok canım, daha neler!...")

elif yaş < 18:
 print("Genç bir kardeşimizsin!")

elif yaş > 18:
 print("Eh, artık yaş yavaş yavaş kemale eriyor!")

```

Yukarıdaki örneği şöyle yazmayı da deneyebilirsiniz:

```python
yaş = int(input("Yaşınız: "))

if yaş == 18:
 print("18 iyidir!")

if yaş < 0:
 print("Yok canım, daha neler!...")

if yaş < 18:
 print("Genç bir kardeşimizsin!")

if yaş > 18:
 print("Eh, artık yaş yavaş yavaş kemale eriyor!")

```

Bu iki programın da aynı işlevi gördüğünü düşünebilirsiniz. Ancak ilk bakışta
pek belli olmasa da, aslında yukarıdaki iki program birbirinden farklı
davranacaktır. Örneğin ikinci programda eğer kullanıcı eksi değerli bir sayı
girerse hemifyaş<0bloğu, hem deifyaş<18bloğu çalışacaktır.
İsterseniz yukarıdaki programı çalıştırıp, cevap olarak eksi değerli bir sayı
verin. Ne demek istediğimiz gayet net anlaşılacaktır.

Bu durumifileelifarasındaki çok önemli bir farktan kaynaklanır. Buna
göreifbize olası bütün sonuçları listeler,elifise sadece doğru olan
ilk sonucu verir. Bu soyut tanımlamayı biraz daha somutlaştıralım:

```python
a = int(input("Bir sayı giriniz: "))

if a < 100:
 print("verdiğiniz sayı 100'den küçüktür.")

if a < 50:
 print("verdiğiniz sayı 50'den küçüktür.")

if a == 100:
 print("verdiğiniz sayı 100'dür.")

if a > 100:
 print("verdiğiniz sayı 100'den büyüktür.")

if a > 150:
 print("verdiğiniz sayı 150'den büyüktür.")

```

Yukarıdaki kodları çalıştırdığımızda, doğru olan bütün sonuçlar listelenecektir.
Yani mesela kullanıcı40sayısını girmişse, ekrana verilecek çıktı şöyle
olacaktır:

```python
verdiğiniz sayı 100'den küçüktür.
verdiğiniz sayı 50'den küçüktür.

```

Burada40sayısı hem100’den, hem de50’den küçük olduğu için iki sonuç da
çıktı olarak verilecektir. Ama eğer yukarıdaki kodları şöyle yazarsak:

```python
a = int(input("Bir sayı giriniz: "))

if a < 100:
 print("verdiğiniz sayı 100'den küçüktür.")

elif a < 50:
 print("verdiğiniz sayı 50'den küçüktür.")

elif a == 100:
 print("verdiğiniz sayı 100'dür.")

elif a > 150:
 print("verdiğiniz sayı 150'den büyüktür.")

elif a > 100:
 print("verdiğiniz sayı 100'den büyüktür.")

```

Kullanıcının40sayısını girdiğini varsaydığımızda, bu defa programımımız
yalnızca şu çıktıyı verecektir:

```python
verdiğiniz sayı 100'den küçüktür.

```

Gördüğünüz gibi,elifdeyimlerini kullandığımız zaman, ekrana yalnızca doğru
olan ilk sonuç veriliyor. Yukarıda40sayısı hem100’den hem de50’den
küçük olduğu halde, Python bu sayının100’den küçük olduğunu görür görmez
sonucu ekrana basıp, öteki koşul bloklarını incelemeyi bırakıyor.ifdeyimlerini arka arkaya sıraladığımızda ise, Python bütün olasılıkları tek tek
değerlendirip, geçerli olan bütün sonuçları ekrana döküyor.

Bir sonraki bölümdeelsedeyimini öğrendiğimiz zaman,elif’in tam olarak
ne işe yaradığını çok daha iyi anlamanızı sağlayacak bir örnek vereceğiz.

> **Not**
> Şimdiye kadar verdiğimiz örneklerden de rahatlıkla anlayabileceğiniz
gibi, ilk koşul bloğunda aslaelifdeyimi kullanılamaz. Bu deyimin
kullanılabilmesi için kendisinden önce en az bir adetifbloğu olmalıdır.
Yani Python’da koşullu durumları ifade ederken ilk koşul bloğumuz her zamanifdeyimi ile başlamalıdır.

Not

Şimdiye kadar verdiğimiz örneklerden de rahatlıkla anlayabileceğiniz
gibi, ilk koşul bloğunda aslaelifdeyimi kullanılamaz. Bu deyimin
kullanılabilmesi için kendisinden önce en az bir adetifbloğu olmalıdır.
Yani Python’da koşullu durumları ifade ederken ilk koşul bloğumuz her zamanifdeyimi ile başlamalıdır.

elif’i de incelediğimize göre, koşul bildiren deyimlerin sonuncusuna göz
atabiliriz:else

#### else

Şimdiye kadar Python’da koşul bildiren iki deyimi öğrendik. Bunlarifveelifidi. Bu bölümde ise koşul deyimlerinin sonuncusu olanelsedeyimini
göreceğiz. Öğrendiğimiz şeyleri şöyle bir gözden geçirecek olursak, temel olarak
şöyle bir durumla karşı karşıya olduğumuzu görürüz:

```python
if falanca:
 bu işlemi yap

if filanca:
 şu işlemi yap

```

Veya şöyle bir durum:

```python
if falanca:
 bu işlemi yap

elif filanca:
 şu işlemi yap

```

ifileelifarasındaki farkı biliyoruz. Eğerifdeyimlerini art arda
sıralayacak olursak, Python doğru olan bütün sonuçları listeleyecektir. Ama eğerifdeyiminden sonraelifdeyimini kullanırsak, Python doğru olan ilk
sonucu listelemekle yetinecektir.

Bu bölümde göreceğimizelsedeyimi, yukarıdaki tabloya bambaşka bir boyut
kazandırıyor. Dikkat ederseniz şimdiye kadar öğrendiğimiz deyimleri
kullanabilmek için ilgili bütün durumları tanımlamamız gerekiyordu. Yani:

```python
eğer böyle bir durum varsa:
 bunu yap

eğer şöyle bir durum varsa:
 şunu yap

eğer filancaysa:
 şöyle git

eğer falancaysa:
 böyle gel

```

gibi…

Ancak her durum için birifbloğu yazmak bir süre sonra yorucu ve sıkıcı
olacaktır. İşte bu noktada devreyeelsedeyimi girecek.else’in anlamı
kabaca şudur:

Eğer yukarıdaki koşulların hiçbiri gerçekleşmezse…

Gelin isterseniz bununla ilgili şöyle bir örnek verelim:

```python
soru = input("Bir meyve adı söyleyin bana:")

if soru == "elma":
 print("evet, elma bir meyvedir...")

elif soru == "karpuz":
 print("evet, karpuz bir meyvedir...")

elif soru == "armut":
 print("evet, armut bir meyvedir...")

else:
 print(soru, "gerçekten bir meyve midir?")

```

Eğer kullanıcı soruya ‘elma’, ‘karpuz’ veya ‘armut’ cevabı verirse,evet, …
bir meyvedirçıktısı verilecektir. Ama eğer kullanıcı bu üçü dışında bir cevap
verirse,… gerçekten bir meyve midir?çıktısını görürüz. Buradaelsedeyimi, programımıza şu anlamı katıyor:

Eğer kullanıcı yukarıda belirlenen meyve adlarından hiç birini girmez, bunların yerine bambaşka bir şey yazarsa, o zamanelsebloğu içinde belirtilen işlemi gerçekleştir.

Dikkat ederseniz yukarıdaki kodlardaifdeyimlerini art arda sıralamak
yerine ilkif’ten sonraelifile devam ettik. Peki şöyle bir şey
yazarsak ne olur?

```python
soru = input("Bir meyve adı söyleyin bana:")

if soru == "elma":
 print("evet, elma bir meyvedir...")

if soru == "karpuz":
 print("evet, karpuz bir meyvedir...")

if soru == "armut":
 print("evet, armut bir meyvedir...")

else:
 print(soru, "gerçekten bir meyve midir?")

```

Bu kodlar beklediğiniz sonucu vermeyecektir. İsterseniz yukarıdaki kodları
çalıştırıp ne demek istediğimizi daha iyi anlayabilirsiniz. Eğer yukarıda olduğu
gibiifdeyimlerini art arda sıralar ve son olarak da birelsebloğu
tanımlarsak, ekrana ilk bakışta anlamsız gibi görünen bir çıktı verilecektir:

```python
evet, elma bir meyvedir...
elma gerçekten bir meyve midir?

```

Burada olan şey şu:

Soruya ‘elma’ cevabını verdiğimizi düşünelim. Bu durumda, Python ilk olarak ilkifbloğunu değerlendirecek ve soruya verdiğimiz cevap ‘elma’ olduğu içinevet, elma bir meyvedir…çıktısını verecektir.

ifileelifarasındaki farkı anlatırken, hatırlarsanız art arda gelenifbloklarında Python’ın olası bütün sonuçları değerlendireceğini söylemiştik. İşte burada da böyle bir durum söz konusu. Gördüğünüz gibi, ilkifbloğundan sonra yine birifbloğu geliyor. Bu nedenle Python olası bütün sonuçları değerlendirebilmek için blokları okumaya devam edecek ve sorunun cevabı ‘karpuz’ olmadığı için ikinciifbloğunu atlayacaktır.

Sonraki blok yine birifbloğu olduğu için Python kodları okumaya devam
ediyor. Ancak sorunun cevabı ‘armut’ da olmadığı için, Python sonrakiifbloğunu da geçiyor ve böyleceelsebloğuna ulaşıyor.

Yukarıda verdiğimiz örnekteki gibi art ardaifdeyimlerinin sıralanıp en
sonaelsedeyiminin yerleştirildiği durumlardaelsedeyimi sadece bir
öncekiifdeyimini dikkate alarak işlem yapar. Yani yukarıdaki örnekte
kullanıcının verdiği cevap ‘armut’ olmadığı içinelsedeyiminin olduğu blok
çalışmaya başlar. Yukarıdaki örneğe ‘armut’ cevabını verirseniz ne demek
istediğimi biraz daha iyi anlayabilirsiniz. ‘armut’ cevabı verilmesi durumunda
sadeceifsoru=="armut"ifadesinin olduğu blok çalışır,elsebloğu ise
çalışmaz. Çünkü dediğim gibi, eğerelsebloğundan önce art arda gelenifblokları varsa,elsedeyimi yalnızca kendisinden önceki sonifbloğunu
dikkate alır ve sanki yukarıdaki örnek şöyleymiş gibi davranır:

```python
if soru == "armut":
 print("evet, armut bir meyvedir...")

else:
 print(soru, "gerçekten bir meyve midir?")

```

Bu tür durumlardaelsedeyimi bir öncekiifbloğundan önce gelen bütünifbloklarını görmezden gelir ve böylece şu anlamsız görünen çıktı elde
edilir:

```python
evet, elma bir meyvedir...
elma gerçekten bir meyve midir?

```

Sözün özü, kullanıcının cevabı ‘elma’ olduğu için, yukarıdaki çıktıda yer alan
ilk cümle ilkifbloğunun çalışması sonucu ekrana basılıyor. İkinci cümle
iseelsebloğundan bir öncekiifbloğu kullanıcının cevabıyla uyuşmadığı
için ekrana basılıyor.

Yalnız bu dediğimizden,elseifadesiifile birlikte kullanılmaz, anlamı
çıkarılmamalı. Mesela şöyle bir örnek yapılabilir:

```python
soru = input("Programdan çıkmak istediğinize emin misiniz? \
Eminseniz 'e' harfine basın : ")

if soru == "e":
 print("Güle güle!")

else:
 print("Peki, biraz daha sohbet edelim!")

```

Burada eğer kullanıcının cevabı ‘e’ iseifbloğu işletilecek, eğer cevap ‘e’
dışında herhangi bir şey iseelsebloğu çalışacaktır. Gayet mantıklı bir
süreç. Ama eğer yukarıdaki örneğe birifbloğu daha eklerseniz işler
beklediğiniz gibi gitmez:

```python
soru = input("Programdan çıkmak istediğinize emin misiniz? \
Eminseniz 'e' harfine basın : ")

if soru == "e":
 print("Güle güle!")

if soru == "b":
 print("Kararsız kaldım şimdi!")

else:
 print("Peki, biraz daha sohbet edelim!")

```

Bu soruya ‘e’ cevabı verdiğimizi düşünelim. Bu cevap ilkifbloğuyla
uyuşuyor ve böylece ekranaGüle güle!çıktısı veriliyor. İlkifbloğundan
sonra tekrar birifbloğu daha geldiği için Python bütün olasılıkları
değerlendirmek amacıyla blokları okumaya devam ediyor ve cevap ‘b’ olmadığı için
ikinciifbloğunu atlıyor ve böyleceelsebloğuna ulaşıyor. Bir önceki
örnekte de söylediğimiz gibi,elsebloğu art arda gelenifblokları
gördüğünde sadece bir öncekiifbloğunu dikkate aldığı ve kullanıcının
cevabı da ‘b’ olmadığı için ekranaPeki, biraz daha sohbet edelim!çıktısını
veriyor ve ilk bakışta tuhaf görünen şöyle bir çıktı üretiyor:

```python
Güle güle!
Peki, biraz daha sohbet edelim!

```

Dolayısıyla, eğer programınızda birelsebloğuna yer verecekseniz, ondan
önce gelen koşullu durumların ilkiniifile sonrakileri iseelifile
bağlayın. Yani:

```python
if koşul_1:
 sonuç_1

elif koşul_2:
 sonuç_2

elif koşul_3:
 sonuç_3

else:
 sonuç_4

```

Ama eğerelsebloğundan önce sadece tek bir koşul bloğu yer alacaksa bunuifile bağlayın. Yani:

```python
if koşul_1:
 sonuç_1

else:
 sonuç_2

```

Programlarımızın doğru çalışması ve istediğimiz sonucu verebilmesi için bu tür
ayrıntılara olabildiğince dikkat etmemiz gerekiyor. Neticede koşullu durumlar
mantıkla ilgilidir. Dolayısıyla koşullu durumlarla muhatap olurken mantığınızı
hiçbir zaman devre dışı bırakmamalısınız.

Bir önceki bölümdeelifdeyiminin tam olarak ne işe yaradığını anlamamızı
sağlayacak bir örnek vereceğimizi söylemiştik. Şimdi bu örneğe bakalım:

```python
boy = int(input("boyunuz kaç cm?"))

if boy < 170:
 print("boyunuz kısa")

elif boy < 180:
 print("boyunuz normal")

else:
 print("boyunuz uzun")

```

Yukarıda yedi satırla hallettiğimiz işi sadeceifdeyimleriyle yapmaya
çalışırsanız bunun ne kadar zor olduğunu göreceksiniz. Diyelim ki kullanıcı
‘165’ cevabını verdi. Python bu165sayısının170’ten küçük olduğunu görünceboyunuz kısacevabını verecek, öteki satırları değerlendirmeyecektir.165sayısı,elifile gösterdiğimiz koşullu duruma da uygun olduğu halde (165<180), koşul ilk blokta karşılandığı için ikinci blok değerlendirmeye
alınmayacaktır.

Kullanıcının ‘175’ cevabını verdiğini varsayalım: Python175sayısını görünce
önce ilk koşula bakacak, verilen175sayısının ilk koşulu karşılamadığını
görecektir (175>170). Bunun üzerine Python kodları incelemeye devam edecek
veelifbloğunu değerlendirmeye alacaktır.175sayısının180’den küçük
olduğunu görünce de çıktı olarakboyunuz normalcevabını verecektir.

Peki ya kullanıcı ‘190’ cevabını verirse ne olacak? Python yine önce ilkifbloğuna bakacak ve190cevabının bu bloğa uymadığını görecektir. Dolayısıyla
ilk bloğu bırakıp ikinci bloğa bakacaktır.190cevabının bu bloğa da
uymadığını görünce, bir sonraki bloğu değerlendirmeye alacaktır. Bir sonraki
blokta iseelsedeyimimiz var. Bu bölümde öğrendiğimiz gibi,elsedeyimi, ‘eğer kullanıcının cevabı yukarıdaki koşulların hiçbirine uymazsa bu
bloğu çalıştır,’ anlamına geliyor. Kullanıcının girdiği190cevabı ne birinci
ne de ikinci bloktaki koşula uyduğu için, normal bir şekildeelsebloğu
işletilecek, dolayısıyla da ekranaboyunuz uzunçıktısı verilecektir.

Böylece Python’daif,elifveelsedeyimlerini incelemiş olduk.
Ancak tabii ki bu deyimlerle işimiz henüz bitmedi. Elimizdeki bilgiler şimdilik
bu deyimleri ancak bu kadar incelememize yetiyor, ama ilerleyen sayfalarda bazı
başka araçları da bilgi dağarcığımıza kattıktan sonra bu deyimlerin daha farklı
yönlerini öğrenme imkanına kavuşacağız.

### Örnek Uygulama

Önceki derslerimizdelen()fonksiyonunu anlatırken şöyle bir program
tasarısından bahsetmiştik hatırlarsanız:

Diyelim ki sisteme kayıt için kullanıcı adı ve parola belirlenmesini isteyen
bir program yazıyorsunuz. Yazacağınız bu programda, belirlenebilecek
kullanıcı adı ve parolanın toplam uzunluğu40karakteri geçmeyecek.

O zaman henüz koşullu durumları öğrenmemiş olduğumuz için, yukarıda
bahsettiğimiz programın ancak şu kadarlık kısmını yazabilmiştik:

```python
kullanıcı_adı = input("Kullanıcı adınız: ")
parola = input("Parolanız : ")

toplam_uzunluk = len(kullanıcı_adı) + len(parola)

```

Burada yapabildiğimiz tek şey, kullanıcıdan kullanıcı adı ve parola bilgilerini
alıp, bu bilgilerin karakter uzunluğunu ölçebilmekti. Ama artık koşullu
durumları öğrendiğimize göre bu programı eksiksiz olarak yazabiliriz. Şu kodları
dikkatlice inceleyin:

```python
kullanıcı_adı = input("Kullanıcı adınız: ")
parola = input("Parolanız : ")

toplam_uzunluk = len(kullanıcı_adı) + len(parola)

mesaj = "Kullanıcı adı ve parolanız toplam {} karakterden oluşuyor!"

print(mesaj.format(toplam_uzunluk))

if toplam_uzunluk > 40:
 print("Kullanıcı adınız ile parolanızın ",
 "toplam uzunluğu 40 karakteri geçmemeli!")
else:
 print("Sisteme hoşgeldiniz!")

```

Burada öncelikle kullanıcıdan kullanıcı adı ve parola bilgilerini alıyoruz. Daha
sonra da kullanıcıdan gelen bu bilgilerin toplam karakter uzunluğunu
hesaplıyoruz. Bunun içinlen()fonksiyonundan yararlanmamız gerektiğini
hatırlıyor olmalısınız.

Eğer toplam uzunluk 40 karakterden fazla ise,ifbloğunda verilen mesajı
gösteriyoruz. Bunun dışındaki bütün durumlarda iseelsebloğunu devreye
sokuyoruz.

## İşleçler

Bu bölümde, aslında pek de yabancısı olmadığımız ve hatta önceki derslerimizde
üstünkörü de olsa değindiğimiz bir konuyu çok daha ayrıntılı bir şekilde ele
alacağız. Burada anlatacağımız konu size yer yer sıkıcı gelebilir. Ancak bu
konuyu hakkıyla öğrenmenizin, programcılık maceranız açısından hayati önemde
olduğunu rahatlıkla söyleyebilirim.

Gelelim konumuza…

Bu bölümün konusu işleçler. Peki nedir bu ‘işleç’ denen şey?

İngilizce’deoperatoradı verilen işleçler, sağında ve solunda bulunan
değerler arasında bir ilişki kuran işaretlerdir. Bir işlecin sağında ve solunda
bulunan değerlere ise işlenen (operand) adı veriyoruz.

> **Not**
> Türkçede işleç yerine operatör, işlenen yerine de operant dendiğine
tanık olabilirsiniz.

Not

Türkçede işleç yerine operatör, işlenen yerine de operant dendiğine
tanık olabilirsiniz.

Biz bu bölümde işleçleri altı başlık altında inceleyeceğiz:
1. Aritmetik İşleçler
1. Karşılaştırma İşleçleri
1. Bool İşleçleri
1. Değer Atama İşleçleri
1. Bitwise (Bitsel) İşleçleri
1. Aitlik İşleçleri
1. Kimlik İşleçleri

Aritmetik İşleçler

Karşılaştırma İşleçleri

Bool İşleçleri

Değer Atama İşleçleri

Bitwise (Bitsel) İşleçleri

Aitlik İşleçleri

Kimlik İşleçleri

Gördüğünüz gibi, işlememiz gereken konu çok, gitmemiz gereken yol uzun. O halde
hiç vakit kaybetmeden, aritmetik işleçlerle yolculuğumuza başlayalım.

### Aritmetik İşleçler

Dedik ki, sağında ve solunda bulunan değerler arasında bir ilişki kuran
işaretlere işleç (operator) adı verilir. Önceki derslerimizde temel işleçlerin
bazılarını öğrenmiştik. İsterseniz bunları şöyle bir hatırlayalım:
| + | toplama |
| --- | --- |
| - | çıkarma |
| * | çarpma |
| / | bölme |
| ** | kuvvet |

+

toplama

-

çıkarma

*

çarpma

/

bölme

**

kuvvet

Bu işleçlere aritmetik işleçler adı verilir. Aritmetik işleçler; matematikte
kullanılan ve sayılarla aritmetik işlemler yapmamızı sağlayan yardımcı
araçlardır.

Dilerseniz bu tanımı bir örnekle somutlaştıralım:

```python
>>> 45 + 33

78

```

Burada45ve33değerlerine işlenen (operand) adı verilir. Bu iki değer
arasında yer alan+işareti ise bir işleçtir (operator). Dikkat ederseniz+işleci45ve33adlı işlenenler arasında bir toplama ilişkisi kuruyor.

Bir örnek daha verelim:

```python
>>> 23 * 46

1058

```

Burada da23ve46değerleri birer işlenendir. Bu iki değer arasında yer
alan*işareti ise, işlenenler arasında bir çarpma ilişkisi kuran bir
işleçtir.

Ancak bir noktaya özellikle dikkatinizi çekmek istiyorum. Daha önceki
derslerimizde de değindiğimiz gibi,+ve*işleçleri Python’da birden fazla
anlama gelir. Örneğin yukarıdaki örnekte+işleci, işlenenler arasında bir
toplama ilişkisi kuruyor. Ama aşağıdaki durum biraz farklıdır:

```python
>>> "istihza" + ".com"

'istihza.com'

```

Burada+işleci işlenenler (“istihza”ve“.com”) arasında bir birleştirme
ilişkisi kuruyor.

Tıpkı+işlecinde olduğu gibi,*işleci de Python’da birden fazla anlama
gelir. Bu işlecin, çarpma ilişkisi kurma işlevi dışında tekrar etme ilişkisi
kurma işlevi de vardır. Yani:

```python
>>> "hızlı " * 2

'hızlı hızlı '

```

…veya:

```python
>>> "-" * 30

'------------------------------'

```

Burada*işlecinin, sayılar arasında çarpma işlemi yapmak dışında bir görev
üstlendiğini görüyoruz.

Python’da bu tür farklar, yazacağınız programın sağlıklı çalışabilmesi açısından
büyük önem taşır. O yüzden bu tür farklara karşı her zaman uyanık olmamız
gerekiyor.

+ve*işleçlerinin aksine/ve-işleçleri ise işlenenler arasında
sadece bölme ve çıkarma ilişkisi kurar. Bu işleçler tek işlevlidir:

```python
>>> 25 / 4

6.25

>>> 10 - 5

5

```

Önceki derslerde gördüğümüz ve yukarıda da tekrar ettiğimiz dört adet temel
aritmetik işlece şu iki aritmetik işleci de ekleyelim:
| % | modülüs |
| --- | --- |
| // | taban bölme |

%

modülüs

//

taban bölme

İlk önce modülüsün ne olduğunu ve ne işe yaradığını anlamaya çalışalım.

Şu bölme işlemine bir bakın:

Burada02sayısı bölme işleminin kalanıdır. İşte modülüs denen işleç de bölme
işleminden kalan bu değeri gösterir. Yani:

```python
>>> 30 % 4

2

```

Gördüğünüz gibi modülüs işleci (%) gerçekten de bölme işleminden kalan sayıyı
gösteriyor… Peki bu bilgi ne işimize yarar?

Mesela bu bilgiyi kullanarak bir sayının tek mi yoksa çift mi olduğunu tespit
edebiliriz:

```python
sayı = int(input("Bir sayı girin: "))

if sayı % 2 == 0:
 print("Girdiğiniz sayı bir çift sayıdır.")
else:
 print("Girdiğiniz sayı bir tek sayıdır.")

```

Eğer bir sayı2’ye bölündüğünde kalan değer0ise o sayı çifttir. Aksi halde
o sayı tektir. Mesela:

```python
>>> 14 % 2

0

```

Gördüğünüz gibi, bir çift sayı olan14’ü2’ye böldüğümüzde kalan sayı0oluyor. Çünkü çift sayılar2’ye tam bölünürler.

Bir de şuna bakalım:

```python
>>> 15 % 2

1

```

Bir tek sayı olan15ise2’ye bölündüğünde kalan sayı1oluyor. Yani15sayısı2’ye tam bölünmüyor. Bu bilgiden yola çıkarak 15 sayısının bir tek sayı
olduğunu söyleyebiliyoruz.

Bir sayının tek mi yoksa çift mi olduğunu tespit etme işlemini küçümsememenizi
tavsiye ederim. Bir sayının tek mi yoksa çift mi olduğu bilgisinin, arayüz
geliştirirken dahi işinize yarayacağından emin olabilirsiniz.

Elbette modülüs işlecini bir sayının yalnızca2’ye tam bölünüp bölünmediğini
denetlemek için kullanmıyoruz. Bu işleci kullanarak herhangi bir sayının
herhangi bir sayıya tam bölünüp bölünmediğini de denetleyebilirsiniz. Örneğin:

```python
>>> 45 % 4

1

>>> 36 % 9

0

```

Bu bilgiyi kullanarak mesela şöyle bir program yazabilirsiniz:

```python
bölünen = int(input("Bir sayı girin: "))
bölen = int(input("Bir sayı daha girin: "))

şablon = "{} sayısı {} sayısına tam".format(bölünen, bölen)

if bölünen % bölen == 0:
 print(şablon, "bölünüyor!")
else:
 print(şablon, "bölünmüyor!")

```

Programımız, kullanıcının girdiği ilk sayının ikinci sayıya tam bölünüp
bölünmediğini hesaplıyor ve sonuca göre kullanıcıyı bilgilendiriyor. Bu kodlarda
özellikle şu satıra dikkat edin:

```python
if bölünen % bölen == 0:
 ...

```

Programımızın temelini bu kod oluşturuyor. Çünkü bir sayının bir sayıya tam
bölünüp bölünmediğini bu kodla belirliyoruz. Eğer bir sayı başka bir sayıya
bölündüğünde kalan değer, yani modülüs0ise, o sayı öbür sayıya tam bölünüyor
demektir.

Ayrıca bir sayının son basamağını elde etmek için de modülüsten
yararlanabilirsiniz. Herhangi bir tamsayı10’a bölündüğünde kalan (yani
modülüs), bölünen sayının son basamağı olacaktır:

```python
>>> 65 % 10

5

>>> 543 % 10

3

```

Programlama tecrübeniz arttıkça, aslında modülüsün ne kadar faydalı bir araç
olduğunu kendi gözlerinizle göreceksiniz.

Modülüs işlecini örnekler eşliğinde ayrıntılı bir şekilde incelediğimize göre
sıra geldi taban bölme işlecini açıklamaya…

Öncelikle şu örneği inceleyelim:

```python
>>> 5 / 2

2.5

```

Burada, bildiğimiz bölme işlecini (/) kullanarak basit bir bölme işlemi
yaptık. Elde ettiğimiz sonuç doğal olarak2.5.

Matematikte bölme işleminin sonucunun kesirli olması durumuna ‘kesirli bölme’
adı verilir. Bunun tersi ise tamsayılı bölme veya taban bölmedir. Eğer herhangi
bir sebeple kesirli bölme işlemi değil de taban bölme işlemi yapmanız gerekirse//işlecinden yararlanabilirsiniz:

```python
>>> 5 // 2

2

```

Gördüğünüz gibi,//işleci sayesinde bölme işleminin sonucu kesirli değil,
tamsayı olarak elde ediliyor.

Yukarıda yaptığımız taban bölme işlemi şununla aynı anlama gelir:

```python
>>> int(5 / 2)

2

```

Daha açık ifade etmemiz gerekirse:

```python
>>> a = 5 / 2
>>> a

2.5

>>> int(a)

2

```

Burada olan şu:5/2işleminin sonucu bir kayan noktalı sayıdır (2.5).
Bunu şu şekilde teyit edebiliriz:

```python
>>> a = 5 / 2
>>> type(a)

<class 'float'>

```

Buradakifloatçıktısınınfloating point number, yani kayan noktalı sayı
anlamına geldiğini biliyorsunuz.

Bu kayan noktalı sayının sadece tabanını elde etmek için bu sayıyı tamsayıya
(integer) çevirmemiz yeterli olacaktır. Yani:

```python
>>> int(a)

2

```

Bu arada yeri gelmişkenround()adlı bir gömülü fonksiyondan bahsetmeden
geçmeyelim. Eğer bir sayının değerini yuvarlamanız gerekirseround()fonksiyonundan yararlanabilirsiniz. Bu fonksiyon şöyle kullanılır:

```python
>>> round(2.55)

3

```

Gördüğünüz gibi,round()fonksiyonuna parametre olarak bir sayı veriyoruz.
Bu fonksiyon da bize o sayının yuvarlanmış halini döndürüyor. Bu fonksiyonu
kullanarak yuvarlanacak sayının noktadan sonraki hassasiyetini de
belirleyebilirsiniz. Örneğin:

```python
>>> round(2.55, 1)

2.5

```

Burada ikinci parametre olarak1sayısını verdiğimiz için, noktadan sonraki
bir basamak görüntüleniyor. Bir de şuna bakalım:

```python
>>> round(2.68, 1)

2.7

```

Burada da yuvarlama işlemi yapılırken noktadan sonra bir basamak korunuyor. Eğer1sayısı yerine2sayısını kullanırsanız, yukarıdaki örnek şu çıktıyı
verir:

```python
>>> round(2.68, 2)

2.68

```

round()fonksiyonunun çalışma prensibini anlamak için kendi kendinize
örnekler yapabilirsiniz.

Şimdiye kadar öğrendiğimiz ve yukarıdaki tabloda andığımız bir başka aritmetik
işleç de kuvvet işleci (**) idi. Mesela bu işleci kullanarak bir sayının
karesini hesaplayabileceğimizi biliyorsunuz:

```python
>>> 25 ** 2

625

```

Bir sayının2.kuvveti o sayının karesidir. Bir sayının0.5.kuvveti ise o
sayının kareköküdür:

```python
>>> 625 ** 0.5

25.0

```

Bu arada, eğer karekökün kayan noktalı sayı cinsinden olması hoşunuza
gitmediyse, bu sayıyıint()fonksiyonu ile tam sayıya çevirebileceğinizi
biliyorsunuz:

```python
>>> int(625 ** 0.5)

25

```

Kuvvet hesaplamaları için**işlecinin yanısırapow()adlı bir
fonksiyondan da yararlanabileceğimizi öğrenmiştik:

```python
>>> pow(25, 2)

625

```

Bildiğiniz gibipow()fonksiyonu aslında toplam üç parametre alabiliyor:

```python
>>> pow(25, 2, 5)

0

```

Bu işlemin şununla aynı anlama geliyor:

```python
>>> (25 ** 2) % 5

0

```

Yanipow(25,2,5)gibi bir komut verdiğimizde,25sayısının2.kuvvetini alıp, elde ettiğimiz sayının5’e bölünmesinden kalan sayıyı
hesaplamış oluyoruz.

Böylece aritmetik işleçleri tamamlamış olduk. Artık karşılaştırma işleçlerini
inceleyebiliriz.

### Karşılaştırma İşleçleri

Adından da anlaşılacağı gibi, karşılaştırma işleçleri, işlenenler (operands)
arasında bir karşılaştırma ilişkisi kuran işleçlerdir. Bu işleçleri şöyle
sıralayabiliriz:
| == | eşittir |
| --- | --- |
| != | eşit değildir |
| > | büyüktür |
| < | küçüktür |
| >= | büyük eşittir |
| <= | küçük eşittir |

==

eşittir

!=

eşit değildir

>

büyüktür

<

küçüktür

>=

büyük eşittir

<=

küçük eşittir

Bu işleçlerin hiçbiri size yabancı değil, zira bunların hepsini aslında daha
önceki derslerde verdiğimiz örneklerde kullanmıştık. Burada da bunlarla ilgili
basit bir örnek vererek yolumuza devam edelim:

```python
parola = "xyz05"

soru = input("parolanız: ")

if soru == parola:
 print("doğru parola!")

elif soru != parola:
 print("yanlış parola!")

```

Buradasorudeğişkeniyle kullanıcıdan alınan verinin, programın başında
tanımladığımızparoladeğişkeninin değerine eşit olup olmadığını sorguluyoruz.
Buna göre, eğer kullanıcıdan gelen veri parolayla eşleşiyorsa (ifsoru==parola), kullanıcıyı parolanın doğru olduğu konusunda bilgilendiriyoruz
(print("doğruparola!")). Ama eğer kullanıcıdan gelen veri parolayla
eşleşmiyorsa (elifsoru!=parola), o zaman da kullanıcıya parolanın yanlış
olduğunu bildiriyoruz (print("yanlışparola!")).

Yukarıdaki örnekte==(eşittir) ve!=(eşit değildir) işleçlerinin
kullanımını örneklendirdik. Öteki karşılaştırma işleçlerinin de nasıl
kullanıldığını biliyorsunuz. Basit bir örnek verelim:

```python
sayı = input("sayı: ")

if int(sayı) <= 100:
 print("sayı 100 veya 100'den küçük")

elif int(sayı) >= 100:
 print("sayı 100 veya 100'den büyük")

```

Böylece karşılaştırma işleçlerini de incelemiş olduk. O halde gelelim bool
işleçlerine…

### Bool İşleçleri

Bu bölümde bool işleçlerinden söz edeceğiz, ancak bool işleçlerine geçmeden önce
biraz bool kavramından bahsetmemiz yerinde olacaktır.

Nedir bu bool denen şey?

Bilgisayar bilimi iki adet değer üzerine kuruludur:1ve0. Yani sırasıylaTrueveFalse. Bilgisayar biliminde herhangi bir şeyin değeri yaTrue, ya
daFalse’tur. İşte buTrueveFalseolarak ifade edilen değerlere bool
değerleri adı verilir (George Boole adlı İngiliz matematikçi ve filozofun
adından). Türkçe olarak söylemek gerekirse,Truedeğerinin karşılığıDoğru,Falsedeğerinin karşılığı iseYanlış’tır.

Örneğin:

```python
>>> a = 1

```

Buradaaadlı bir değişken tanımladık. Bu değişkenin değeri1. Şimdi bu
değişkenin değerini sorgulayalım:

```python
>>> a == 1 #a değeri 1'e eşit mi?

True

```

Gördüğünüz gibi,a == 1sorgusuTrue(Doğru) çıktısı veriyor. Çünküadeğişkeninin değeri gerçekten de1. Bir de şunu deneyelim:

```python
>>> a == 2

False

```

Burada daadeğişkeninin değerinin2sayısına eşdeğer olup olmadığını
sorguladık.adeğişkeninin değeri2olmadığı için de Python bizeFalse(Yanlış) çıktısı verdi.

Gördüğünüz gibi, bool işleçleri herhangi bir ifadenin doğruluğunu veya
yanlışlığını sorgulamak için kullanılabiliyor. Buna göre, eğer bir sorgulamanın
sonucu doğru iseTrue, eğer yanlış iseFalseçıktısı alıyoruz.

Bool işleçleri sadece yukarıda verdiğimiz örneklerdeki gibi, salt bir
doğruluk-yanlışlık sorgulamaya yarayan araçlar değildir. Bilgisayar biliminde
her şeyin bir bool değeri vardır. Bununla ilgili genel kuralımız şu:0değeri
ve boş veri tipleriFalse’tur. Bunlar dışında kalan her şey iseTrue’dur.

Bu durumubool()adlı özel bir fonksiyondan yararlanarak teyit edebiliriz:

```python
>>> bool(3)

True

>>> bool("elma")

True

>>> bool(" ")

True

>>> bool(" ")

True

>>> bool("fdsdfsdg")

True

>>> bool("0")

True

>>> bool(0)

False

>>> bool("")

False

```

Gördüğünüz gibi, gerçekten de0sayısının ve boş karakter dizilerinin bool
değeriFalse’tur. Geri kalan her şey iseTrue’dur.

> **Not**
> 0’ın bir sayı,“0”’ın ise bir karakter dizisi olduğunu unutmayın.
Sayı olan0’ın bool değeriFalse’tur, ama karakter dizisi olan“0”’ın
değeriTrue’dur.

Not

0’ın bir sayı,“0”’ın ise bir karakter dizisi olduğunu unutmayın.
Sayı olan0’ın bool değeriFalse’tur, ama karakter dizisi olan“0”’ın
değeriTrue’dur.

Yukarıdaki örneklere göre, içinde herhangi bir değer barındıran karakter
dizileri (0hariç)Trueçıktısı veriyor. Burada söylediğimiz şey bütün veri
tipleri için geçerlidir. Eğer herhangi bir veri tipi herhangi bir değer
içermiyorsa o veri tipiFalseçıktısı verir.

Peki bu bilgi bizim ne işimize yarar? Yani mesela boş veri tiplerininFalse,
içinde bir veri barındıran veri tiplerinin iseTrueolması bizim için neden bu
kadar önemli? Bunu birazdan açıklayacağız. Ama önce isterseniz, bool değerleri
ile ilgili çok önemli bir konuya değinelim.

Belki kendiniz de farketmişsinizdir; bool değerleri Python’da koşul belirtenif,elifveelsedeyimlerinin de temelini oluşturur. Şu örneği ele
alalım mesela:

```python
isim = input("İsminiz: ")

if isim == "Ferhat":
 print("Ne güzel bir isim bu!")
else:
 print(isim, "ismini pek sevmem!")

```

Buradaifisim=="Ferhat"dediğimizde, aslında Python’a şu emri vermiş
oluyoruz:

Eğerisim=="Ferhat"ifadesiTrueise…

Bunu teyit etmek için şöyle bir kod yazabilirsiniz:

```python
isim = input("İsminiz: ")

print(isim == "Ferhat")

```

Eğer burada kullanıcı ‘Ferhat’ ismini girecek olursa programımızTrueçıktısı
verir. Ama eğer kullanıcı başka bir isim girerse bu kezFalseçıktısını
alırız. İşte koşul bildiren deyimler, karar verme görevini, kendilerine verilen
ifadelerin bool değerlerine bakarak yerine getirir. Dolayısıyla yukarıdaki
örneği şu şekilde Türkçeye çevirebiliriz:

Eğerisim=="Ferhat"ifadesinin bool değeriTrueise,Ne güzel bir
isim bu!çıktısı ver! Ama eğerisim=="Ferhat"ifadesinin bool değeriTruedışında herhangi bir şey ise (yaniFalseise),… ismini pek
sevmem!çıktısı ver!

Koşul bildiren deyimlerle bool değerleri arasındaki ilişkiyi daha iyi anlamak
için bir örnek daha verelim:

Hatırlarsanız içi boş veri tiplerinin bool değerinin her zamanFalseolacağını
söylemiştik. Yani:

```python
>>> a = ""

>>> bool(a)

False

```

Herhangi bir değere sahip veri tiplerinin bool değeri ise her zamanTrueolur
(0hariç):

```python
>>> a = "gdfg"

>>> bool(a)

True

```

İçi boş veri tiplerinin bool değerinin her zamanFalseolacağı bilgisini
kullanarak şöyle bir uygulama yazabiliriz:

```python
kullanıcı = input("Kullanıcı adınız: ")

if bool(kullanıcı) == True:
 print("Teşekkürler!")
else:
 print("Kullanıcı adı alanı boş bırakılamaz!")

```

Burada şöyle bir emir verdik:

“Eğerkullanıcıdeğişkeninin bool değeriTrueiseTeşekkürler!çıktısı
ver! DeğilseKullanıcı adı alanı boş bırakılamaz!uyarısını göster!

Eğer kullanıcı, kullanıcı adına herhangi bir şey yazdıktan sonraEntertuşuna
basarsakullanıcıdeğişkeni, kullanıcının girdiği değeri gösterecek ve böylecebool(kullanıcı)komutuTrueçıktısı verecektir. Bu sayede de kodlarımızın
içindekiifbloğu çalışmaya başlayacaktır.

Ama eğer kullanıcı, kullanıcı adını yazmadanEntertuşuna basarsa,kullanıcıdeğişkeni boş kalacağı için (yanikullanıcı=""gibi bir durum ortaya
çıkacağı için)bool(kullanıcı)komutuFalseçıktısı verecek ve böyleceelsebloğu çalışacaktır.

Yalnız bu noktada şöyle bir uyarı yapalım. Yukarıdaki komutlar sözdizimi
açısından tamamen doğru olsa da, etrafta yukarıdakine benzer bir kullanımı pek
görmezsiniz. Aynı iş için genellikle şöyle bir şeyler yazılır:

```python
kullanıcı = input("Kullanıcı adınız: ")

if kullanıcı:
 print("Teşekkürler!")

```

Gördüğünüz gibi,ifbool(kullanıcı)==True:kodunuifkullanıcı:şeklinde kısaltabiliyoruz. Bu ikisi tamamen aynı anlama gelir. Yani ikisi de
‘kullanıcı değişkeninin bool değeriTrueise…’ demektir.

Bool kavramına aşinalık kazandığımıza göre şimdi bool işleçlerini incelemeye
başlayabiliriz.

Bool işleçleri, bool değerlerinden birini elde etmemizi sağlayan işleçlerdir. Bu
işleçler şunlardır:

and

or

not

Eğer mantık dersleri aldıysanız bu işleçler size hiç yabancı gelmeyecektir. Eğer
lisede mantık dersleri almadıysanız veya aldığınız derslerden hiçbir şey
hatırlamıyorsanız, yine de ziyanı yok. Biz burada bu işleçleri bütün
ayrıntılarıyla inceleyeceğiz.

Önceandile başlayalım…

Türkçe söylemek gerekirseand‘ve’ anlamına gelir. Peki buandne işimize
yarar? Çok basit bir örnek verelim:

Hatırlarsanız geçen bölümde koşullu durumlara örnek verirken şöyle bir durumdan
bahsetmiştik:

Diyelim ki Google’ın Gmail hizmeti aracılığıyla bir e.posta hesabı aldınız.
Bu hesaba gireceğiniz zaman Gmail size bir kullanıcı adı ve parola sorar.
Siz de kendinize ait kullanıcı adını ve parolayı sayfadaki kutucuklara
yazarsınız. Eğer yazdığınız kullanıcı adı ve parola doğruysa hesabınıza
erişebilirsiniz. Ama eğer kullanıcı adınız ve parolanız doğru değilse
hesabınıza erişemezsiniz. Yani e.posta hesabınıza erişmeniz, kullanıcı adı
ve parolayı doğru girme koşuluna bağlıdır.

Burada çok önemli bir nokta var. Kullanıcının Gmail sistemine girebilmesi için
hem kullanıcı adını hem de parolayı doğru yazması gerekiyor. Yani kullanıcı adı
veya paroladan herhangi biri yanlış ise sisteme giriş mümkün olmayacaktır.

Yukarıdaki durumu taklit eden bir programı, şu ana kadar olan bilgilerimizi
kullanarak şöyle yazabiliyoruz:

```python
kullanıcı_adı = input("Kullanıcı adınız: ")
parola = input("Parolanız: ")

if kullanıcı_adı == "aliveli":
 if parola == "12345678":
 print("Programa hoşgeldiniz")
 else:
 print("Yanlış kullanıcı adı veya parola!")

else:
 print("Yanlış kullanıcı adı veya parola!")

```

Burada yeni bir bilgiyle daha karşılaşıyoruz. Gördüğünüz gibi, buradaifdeyimlerini iç içe kullandık. Python’da istediğiniz kadar iç içe geçmişifdeyimi kullanabilirsiniz. Ancak yazdığınız bir programda eğer üçten fazla iç içeifdeyimi kullandıysanız, benimsediğiniz yöntemi yeniden gözden geçirmenizi
tavsiye ederim. Çünkü iç içe geçmişifdeyimleri bir süre sonra anlaşılması
güç bir kod yapısı ortaya çıkarabilir. Neyse… Biz konumuza dönelim.

Yukarıdaki yazdığımız programda kullanıcının sisteme giriş yapabilmesi için hem
kullanıcı adını hem de parolayı doğru girmesi gerekiyor. Kullanıcı adı ve
paroladan herhangi biri yanlışsa sisteme girişe izin verilmiyor. Ancak
yukarıdaki yöntem dolambaçlıdır. Halbuki aynı işlevi yerine getirmenin,
Python’da çok daha kolay bir yolu var. Bakalım:

```python
kullanıcı_adı = input("Kullanıcı adınız: ")
parola = input("Parolanız: ")

if kullanıcı_adı == "aliveli" and parola == "12345678":
 print("Programa hoşgeldiniz")

else:
 print("Yanlış kullanıcı adı veya parola!")

```

Buradaandişlecini nasıl kullandığımızı görüyorsunuz. Bu işleci kullanarak
iki farklı ifadeyi birbirine bağladık. Böylece kullanıcının sisteme girişini hem
kullanıcı adının hem de parolanın doğru olması koşuluna dayandırdık.

Pekiandişlecinin çalışma mantığı nedir? Dediğim gibi,andTürkçede ‘ve’
anlamına geliyor. Bu işleci daha iyi anlayabilmek için şu cümleler arasındaki
farkı düşünün:
1. Toplantıya Ali ve Veli katılacak.
1. Toplantıya Ali veya Veli katılacak.

Toplantıya Ali ve Veli katılacak.

Toplantıya Ali veya Veli katılacak.

İlk cümlede ‘ve’ bağlacı kullanıldığı için, bu cümlenin gereğinin yerine
getirilebilmesi, hem Ali’nin hem de Veli’nin toplantıya katılmasına bağlıdır.
Sadece Ali veya sadece Veli’nin toplantıya katılması durumunda bu cümlenin
gereği yerine getirilememiş olacaktır.

İkinci cümlede ise toplantıya Ali ve Veli’den herhangi birisinin katılması
yeterlidir. Toplantıya sadece Ali’nin katılması, sadece Veli’nin katılması veya
her ikisinin birden katılması, bu cümlenin gereğinin yerine getirilebilmesi
açısından yeterlidir.

İşte Python’dakiandişleci de aynı bu şekilde işler. Şu örneklere bir
bakalım:

```python
>>> a = 23
>>> b = 10
>>> a == 23

True

>>> b == 10

True

>>> a == 23 and b == 10

True

```

Burada değeri23olan bir adetadeğişkeni ve değeri10olan bir adetbdeğişkeni tanımladık. Daha sonra bu iki değişkenin değerini tek tek sorguladık
ve bunların gerçekten de sırasıyla 23 ve 10 sayısına eşit olduğunu gördük. Son
olarak da bunlarıandişleci ile birbirine bağlayarak sorguladık.adeğişkeninin değeri 23,bdeğişkeninin değeri de 10 olduğu için, yaniandile bağlanan her iki önerme deTrueçıktısı verdiği içina==23andb==10ifadesiTruedeğeri verdi.

Bir de şuna bakalım:

```python
>>> a = 23
>>> b = 10
>>> a == 23

True

>>> b == 54

False

>>> a == 23 and b == 54

False

```

Burada iseadeğişkenin değeri23’tür. Dolayısıylaa==23ifadesiTrueçıktısı verir. Ancakbdeğişkeninin değeri54değildir. O yüzden deb==54komutuFalseçıktısı verir. Gördüğünüz gibi,andişleci ile
bağlanan önermelerden herhangi biriFalseolduğunda çıktımız daFalseoluyor. Unutmayın:andişlecininTrueçıktısı verebilmesi için bu işleç
tarafından bağlanan her iki önermenin deTrueolması gerekir. Eğer
önermelerden biri bileTruedeğilse çıktı daTrueolmayacaktır.

Tahmin edebileceğiniz gibi,andişleci en yaygınifdeyimleriyle birlikte
kullanılır. Mesela yukarıda kullanıcıdan kullanıcı adı ve parola alırken de buandişlecinden yararlanmıştık.

Gelelimorişlecine…

Tıpkıandgibi bir bool işleci olanor’un Türkçede karşılığı ‘veya’dır.
Yukarıda ‘Toplantıya Ali veya Veli katılacak.’ cümlesini tartışırken aslında buorkelimesinin anlamını açıklamıştık. HatırlarsanızandişlecininTrueçıktısı verebilmesi için bu işleçle bağlanan bütün önermelerinTruedeğerine
sahip olması gerekiyordu.orişlecininTrueçıktısı verebilmesi için iseorişleciyle bağlanan önermelerden herhangi birininTrueçıktısı vermesi
yeterli olacaktır. Söylediğimiz bu şeyleri birkaç örnek üzerinde
somutlaştıralım:

```python
>>> a = 23
>>> b = 10
>>> a == 23

True

>>> b == 10

True

>>> a == 11

False

>>> a == 11 or b == 10

True

```

Gördüğünüz gibi,a==11ifadesinin bool değeriFalseolduğu halde,b==10ifadesinin bool değeriTrueolduğu içina==11orb==10ifadesiTruedeğerini veriyor.

andveorişleçlerini öğrendiğimize göre, bir sınavdan alınan notların harf
karşılıklarını gösteren bir uygulama yazabiliriz:

```python
x = int(input("Notunuz: "))

if x > 100 or x < 0:
 print("Böyle bir not yok")

elif x >= 90 and x <= 100:
 print("A aldınız.")

elif x >= 80 and x <= 89:
 print("B aldınız.")

elif x >= 70 and x <= 79:
 print("C aldınız.")

elif x >= 60 and x <= 69:
 print("D aldınız.")

elif x >= 0 and x <= 59:
 print("F aldınız.")

```

Bu programda eğer kullanıcı100’den büyük ya da0’dan küçük bir sayı girerseBöyle bir not yokuyarısı alacaktır. 0-100 arası notlarda ise, her bir not
aralığına karşılık gelen harf görüntülenecektir. Eğer isterseniz yukarıdaki
kodları şu şekilde de kısaltabilirsiniz:

```python
x = int(input("Notunuz: "))

if x > 100 or x < 0:
 print("Böyle bir not yok")

elif x >= 90 <= 100:
 print("A aldınız.")

elif x >= 80 <= 89:
 print("B aldınız.")

elif x >= 70 <= 79:
 print("C aldınız.")

elif x >= 60 <= 69:
 print("D aldınız.")

elif x >= 0 <= 59:
 print("F aldınız.")

```

Gördüğünüz gibi,andxkısımlarını çıkardığımızda da bir önceki kodlarla
aynı anlamı yakalayabiliyoruz.

Hatta yukarıdaki kodları şöyle de yazabilirsiniz:

```python
x = int(input("Notunuz: "))

if x > 100 or x < 0:
 print("Böyle bir not yok")

#90 sayısı x'ten küçük veya x'e eşit,
#x sayısı 100'den küçük veya 100'e eşit ise,
#Yani x, 90 ile 100 arasında bir sayı ise
elif 90 <= x <= 100:
 print("A aldınız.")

#80 sayısı x'ten küçük veya x'e eşit,
#x sayısı 89'dan küçük veya 89'a eşit ise,
#Yani x, 80 ile 89 arasında bir sayı ise
elif 80 <= x <= 89:
 print("B aldınız.")

elif 70 <= x <= 79:
 print("C aldınız.")

elif 60 <= x <= 69:
 print("D aldınız.")

elif 0 <= x <= 59:
 print("F aldınız.")

```

Bu kodlar bir öncekiyle aynı işi yapar. Yorumlardan da göreceğiniz gibi, bu iki
kod arasında sadece mantık farkı var.

Hatta, daha da ileri giderek aynı kodu çok daha basit hale getirmek isterseniz,
aşağıdaki koda bakabilirsiniz.

```python
x = int(input("Notunuz: "))

if x > 100 or x < 0:
 print("Böyle bir not yok")

elif x >= 90:
 print("A aldınız.")

elif x >= 80:
 print("B aldınız.")

elif x >= 70:
 print("C aldınız.")

elif x >= 60:
 print("D aldınız.")

elif x >= 0:
 print("F aldınız.")

```

Son bool işlecimiznot. Bu kelimenin İngilizce’deki anlamı ‘değil’dir. Bu
işleci şöyle kullanıyoruz:

```python
>>> a = 23
>>> not a

False

>>> a = ""
>>> not a

True

```

Bu işleç, özellikle kullanıcı tarafından bir değişkene veri girilip
girilmediğini denetlemek için kullanılabilir. Örneğin:

```python
parola = input("parola: ")

if not parola:
 print("Parola boş bırakılamaz!")

```

Eğer kullanıcı herhangi bir parola belirlemeden doğrudanEntertuşuna basacak
olursaparoladeğişkeninin değeri boş bir karakter dizisi olacaktır. Yaniparola="". Boş veri tiplerinin bool değerininFalseolacağını biliyoruz.
Dolayısıyla, yukarıdaki gibi bir örnekte, kullanıcı parolayı boş geçtiğindenotparolakoduTrueverecek ve böylece ekrana“Parola boş bırakılamaz!”karakter dizisi yazdırılacaktır. Eğer yukarıdaki örneğin mantığını kavramakta
zorluk çekiyorsanız şu örnekleri incelemenizi de öneririm:

```python
>>> parola = ""
>>> bool(parola)

False

>>> bool(not parola)

True

>>> parola = "1243"
>>> bool(parola)

True

>>> bool(not parola)

False

```

Aslında yukarıdaki örneklerde şuna benzer sorular sormuş gibi oluyoruz:

```python
>>> parola = ""
>>> bool(parola) #parola boş bırakılmamış, değil mi?

>>> False #Hayır, parola boş bırakılmış.

>>> bool(not parola) #parola boş bırakılmış, değil mi?

>>> True #Evet, parola boş bırakılmış

```

Kendi kendinize pratik yaparak bu işlecin görevini daha iyi anlayabilirsiniz.

Böylece kısmen çetrefilli bir konu olan bool işleçlerini de geride bırakmış
olduk. Sırada değer atama işleçleri var.

### Değer Atama İşleçleri

Bu noktaya kadar yaptığımız çalışmalarda sadece tek bir değer atama işleci
gördük. Bu işleç=işlecidir. Adından da anlaşılacağı gibi, bu işlecin görevi
bir değişkene değer atamaktır. Mesela:

```python
>>> a = 23

```

Burada=işleciadeğişkenine23değerini atama işlevi görüyor.

Python’daki tek değer atama işleci elbette=değildir. Bunun dışında başka
değer atama işleçleri de bulunur. Tek tek inceleyelim:

+= işleci

Bu işlecin ne işe yaradığını anlamak için şöyle bir örnek düşünün:

```python
>>> a = 23

```

adeğerine mesela5ekleyip bu değeri28’e eşitlemek için ne yapmamız
lazım? Tabii ki şunu:

```python
>>> a = a + 5
>>> print(a)

28

```

Burada yaptığımız şey çok basit:adeğişkeninin taşıdığı değere5ilave
ediyoruz ve daha sonra bu değeri tekraradeğişkenine atıyoruz. Aynı işlemi
çok daha kolay bir şekilde de yapabiliriz:

```python
>>> a += 5
>>> print(a)

28

```

Bu kod, yukarıdakiyle tamamen aynı anlama gelir. Ama bir önceki koda göre çok
daha verimlidir. Çünküa+=5kodunda Pythonadeğişkeninin değerini
sadece bir kez kontrol ettiği için, işlemia=a+5koduna göre daha hızlı
yapacaktır.

-= işleci

Bir önceki+=işleci toplama işlemi yapıp, ortaya çıkan değeri tekrar aynı
değişkene atıyordu.-=işleci de buna benzer bir işlem gerçekleştirir:

```python
>>> a = 23
>>> a -= 5
>>> print(a)

18

```

Yukarıdaki kullanım şununla tamamen aynıdır:

```python
>>> a = 23
>>> a = a - 5
>>> print(a)

18

```

Ancak tıpkı+=işlecinde olduğu gibi,-=işleci de alternatifine göre daha
hızlı çalışan bir araçtır.

/= işleci

Bu işlecin çalışma mantığı da yukarıdaki işleçlerle aynıdır:

```python
>>> a = 30
>>> a /= 3
>>> print(a)

10

```

Yukarıdaki işlem de şununla tamamen aynıdır:

```python
>>> a = 30
>>> a = a / 3
>>> print(a)

10

```

*= işleci

Bu da ötekiler gibi, çarpma işlemi yapıp, bu işlemin sonucunu aynı değişkene atar:

```python
>>> a = 20
>>> a *= 2
>>> print(a)

40

```

Bu işlecin eşdeğeri de şudur:

```python
>>> a = 20
>>> a = a * 2
>>> print(a)

40

```

%= işleci

Bu işlecimiz ise bölme işleminden kalan sayıyı aynı değişkene atar:

```python
>>> a = 40
>>> a %= 3
>>> print(a)

1

```

Bu işleç de şuna eşdeğerdir:

```python
>>> a = 40
>>> a = a % 3
>>> print(a)

1

```

**= işleci

Bu işlecin ne yaptığını tahmin etmek zor değil. Bu işlecimiz, bir sayının
kuvvetini hesapladıktan sonra çıkan değeri aynı değişkene atıyor:

```python
>>> a = 12
>>> a **= 2
>>> print(a)

144

```

Eşdeğeri:

```python
>>> a = 12
>>> a = a ** 2
>>> print(a)

144

```

//= işleci

Değer atama işleçlerinin sonuncusu olan//=işlecinin görevi ise taban bölme
işleminin sonucunu aynı değişkene atamaktır:

```python
>>> a = 5
>>> a //= 2
>>> print(a)

2

```

Eşdeğeri:

```python
>>> a = 5
>>> a = a // 2
>>> print(a)

2

```

Bu işleçler arasından, özellikle+=ve-=işleçleri işinize bir hayli yarayacak.

Bu arada eğer bu işleçleri kullanırken mesela+=mi yoksa=+mı yazacağınızı
karıştırıyorsanız, şöyle düşünebilirsiniz:

```python
>>> a = 5
>>> a += 5
>>> print(a)

10

```

Burada, değeri5olan biradeğişkenine5daha ekleyip, çıkan sonucu
tekraradeğişkenine atadık. Böylece değeri10olan biradeğişkeni elde
ettik.+=işlecinin doğru kullanımı yukarıdaki gibidir. Bir de yukarıdaki
örneği şöyle yazmayı deneyelim:

```python
>>> a = 5
>>> a =+ 5
>>> print(a)

5

```

Burada+işleci ile=işlecinin yerini değiştirdik.

a=+5satırına dikkatlice bakın. Aslında burada yaptığımız şeyina=+5işlemi olduğunu, yaniadeğişkenine+5gibi bir değer verdiğimizi
göreceksiniz. Durum şu örnekte daha net görünecektir:

```python
>>> a = 5
>>> a =- 5
>>> print(a)
>>> -5

```

Gördüğünüz gibi,a=-5yazdığımızda, aslında yaptığımız şeyadeğişkenine-5değerini vermekten ibarettir. Yania=-5.

:= işleci

> **Not**
> Walrus operatörü olarak da bilinen bu işleç, Python’un 3.8 versiyonu ile
eklenmiştir. Bundan önceki versiyonlarda bulunmamaktadır ve çalışmayacaktır.SyntaxErrorhatası verecektir.

Not

Walrus operatörü olarak da bilinen bu işleç, Python’un 3.8 versiyonu ile
eklenmiştir. Bundan önceki versiyonlarda bulunmamaktadır ve çalışmayacaktır.SyntaxErrorhatası verecektir.

Bu işleç biraz garip gözüküyor olabilir. Ne yaptığını bakarak kestirmek de biraz
zor. En iyisi bir örnekle başlayalım:

```python
giriş = len(input("Adın ne? "))

if giriş < 4:
 print("Adın kısaymış.")
elif giriş < 6:
 print("Adın biraz uzunmuş.")
else:
 print("Çok uzun bir adın var.")

```

Gördüğünüz gibi girilen karakter dizisinin uzunluğuna göre ekrana bir çıktı yazdırmaktayız.
Python3.8’e sahipseniz vereceğimiz örnekleri kendiniz de deneyebilirsiniz.
Bir de:=işleci ile bu kodu nasıl yazabileceğimize bakalım:

```python
if ( giriş := len(input("Adın ne? ")) ) < 4:
 print("Adın kısaymış.")
elif giriş < 6:
 print("Adın biraz uzunmuş.")
else:
 print("Çok uzun bir adın var.")

```

Buradagirişdeğişkenine değer atamayıififadesinin içinde yaptık.
Normalde böyle bir işlemi=ile yapamazdık:

```python
>>> if ( giriş = len(input("Adın ne? ")) ) < 4:

SyntaxError: invalid syntax

```

Fark edebileceğiniz gibi walrus operatörü bizi bir satır fazladan yazmaktan
kurtardı. Kullanıcıdan alınan bilginin giriş değişkenine nasıl atandığına dikkat
edin.girişdeğişkeninden sonra:=işlecini kullanıyoruz ve aynı zamanda
değişken atamasını yaptığımız bölümün tamamını parantez içine alıyoruz. Peki bu
parantezi koymaz isek ne olur? Gelin bir örnek ile de onu deneyelim:

```python
if giriş := len(input("Adın ne? ")) < 4:
 print(giriş)

```

Eğer bu kodu çalıştırsanız ekranaTrueyazıldığını veya hiçbir şey yazılmadığını
görebilirsiniz. Oysa önceki parantez kullandığımız koddagirişdeğişkeni birint’di. Bu örneğimizde ise ilk öncelen(input("Adınne?"))<4kısmı
çalışıyor ve bunun sonucu daha sonragirişdeğişkenimize atanıyor. Bu yüzdengirişdeğişkenimizTrueveyaFalse, yani birboololuyor. EğergirişdeğişkeniTrueolursa ekrana yazılıyor, ancak eğerFalseolursa ekrana yazılmıyor. Çünküififadesinin değeri deFalseoluyor.ififadesinin kontrol ettiği yerlen(input("Adınne?"))<4kısmı olduğu içinifdeyiminin içine girilmiyor.

Çok önemli bir işleç olmayabilir ama bazen aynı fonksiyonu iki defa çağırmak yerine
bir defa çağırmak gibi kolaylıklar sağlamaktadır. Bu konu ile alakalı daha fazla örnek içinburayabakabilirsiniz

### Bitwise (Bitsel) İşleçleri

Bu bölümde bitwise işleçlerinden söz edeceğiz, ancak bitwise işleçlerini anlayabilmek
için öncelikle ikili sayı sistemi hakkında bilgi sahibi olmanız gerekecek. Görüldüğü üzere,
bitwise işleçleri ikili sayılar temelinde işlemler yapmamıza yarar sağlar.

Peki, nedir bu ikili sayma sistemi?

İkili sayı sistemi, bilgisayarların verileri temsil etmek için kullandığı temel sayı sistemidir.
Her yerde duyduğunuz gibi, ekrandaki her şey size ne kadar karmaşık gelse de,
bilgisayarlarımız bunları ikili (binary) tabanda temsil eder. Örneğin, “10” sayısının ikili
tabanda gösterimi “1010” şeklindedir. İkili sayma sisteminde, bir sayıyı oluşturan rakamlar
2’nin kuvvetleri olarak hesaplanır. Bu sayıyı 2’nin kuvvetlerini kullanarak şu şekilde hesaplayabiliriz:

```python
>>> (0 * (2 ** 0)) + (1 * (2 ** 1)) + (0 * (2 ** 2)) + (1 * (2 ** 3))

10

```

Tabii, daha fazlasını dokümanınileribölümlerinde anlatacağız. Şimdilik bunları bilseniz yeterli.
| & | Mantıksal And |
| --- | --- |
| | | Mantıksal Or |
| >> | Kaydırma |
| << | Kaydırma |
| ^ | Mantıksal XOR |
| ~ | Tümleme |

&

Mantıksal And

|

Mantıksal Or

>>

Kaydırma

<<

Kaydırma

^

Mantıksal XOR

~

Tümleme

Şunu da söylemeden geçmeyelim, yukarıda gördüğünüz bu işleçler çoğumuzun lise matematik
derslerinde gördüğü veya göreceği sembolik mantık (namıdeğer matematiksel mantık) ilkelerine
dayandığından, her işleçte sembolik mantık derslerindeki karşılıklarını da göstereceğiz.
Tabii, daha önce sembolik mantıktan haberdar olmayanlar için başlamadan önce ilerde
işimize yarayacak olan önermelerin ne olduğuna bir bakalım. Eğer daha detaylı olarak öğrenmek
isterseniz, Wikipedia’ya bakmanız yeterli.

Önermeler

Siz hiç farketmemiş olsanız da Python’da birçok kez önerme kullandınız. Hemen birini gösterelim:

```python
a = 10

if a == 10:
 ...

```

Yukarıda gördüğünüz koddaa == 10bir önermedir. Peki önerme dediğimiz şeyi tanımlasak
nasıl olur? Mantıkta doğrulanabilir ya da yanlışlanabilir olmak zorunda olan ifadelereönermedenir. Bayağı hiçbir şey ifade etmeyen kelimeler grubu gibi duran bu cümleyi biraz
açıklayalım. Demek istediğimiz şey şu: Herhangi bir cümlemiz olsun, doğru ya da yanlış
olması umrumuzda bile değil ama yanlış ya da doğru olabilmesi onun bize bir önerme
olabileceğini gösteriyor. Mesela Mertcan adında bir arkadaşımız olsun. Bu arkadaş Keloğlan
izlemeyi seviyor olsun. Mertcan’ın bir arkadaşına şöyle bir şey diyelim:

Mertcan Keloğlan izlemeyi sevmiyor.

Bu cümle bir önermedir ancak bu önerme doğru değildir. Sembolik olarak değerini göstermek istersek,0ile göstermemiz gerekecektir.

```python
if a == 10:
 ...

```

O zaman ilk örneğimize dönersek, gerçekten dea = 10olduğu için önerme doğrudur, yani if bloğumuz güzelce çalışır.
Son olarak, neyin önerme olduğunu söylediğimiz gibi, neyin önerme olmadığını da belirtelim. Mesela:

Bugün hava çok güzel.

Bence en güzel şehir Erzincan’dır.

Bu iki cümleyi inceleyelim. Bugün hava sana göre güzel olabilir ama bana göre olmayabilir.
Ya da bir başkası en güzel şehrin İstanbul olduğunu düşünüyor olabilir. Yani bu cümlelerin
doğruluğunu ya da yanlışlığını kesin olarak belirleyemeyiz. Demek ki bu iki örnekteki gibi öznel
cümlelerden önerme olmaz.

Bence önermeleri herkes anladı. Meraklısı için internet emrinize amade.

Mantiksal AND (ve) İşleci (&)

Bu işleç her iki tarafındaki değişkenin bitleri üzerinde mantıksalandişlemi uygular.
Aslında önceki bölümde gördüğünüzandişleci ile aynı işlemi karşılıklı bitler üzerinde
yapar. Mesela buna bir örnek verelim.

```python
if (True and False): # 1 = True, 0 = False
 ...

```

Daha önceki örneklerimizde anlatıldığı üzere bu ifade False olacağından if bloğumuz
çalışmayacaktır. Mantıksal And işlecimiz de aynı işlemi karşılıklı bitler üzerinde yapacak.
| 1 & 1 | = 1 |
| --- | --- |
| 1 & 0 | = 0 |
| 0 & 1 | = 0 |
| 0 & 0 | = 0 |

1 & 1

= 1

1 & 0

= 0

0 & 1

= 0

0 & 0

= 0

Örnek üzerinden anlatmak bu tarz işleçlerin işlevini anlayabilmek için daha uygun olacaktır.

```python
a = 10 # 0000 1010 = 10
b = 20 # 0001 0100 = 20

print(a & b) # 0000 0000 = 0

0

```

```python
c = 10 # 0000 1010 = 10
d = 22 # 0001 0110 = 22

print(c & d) # 0000 0010 = 2

2

```

Örneklerde de gördüğünüz gibi mantıksal And işleci karşılıklı bitlerde işlem yapar.
And işlemi ile karşılaştırılmış iki bitten biri bile0olsa;0sonucunu alırsınız.1sonucu
alabilmek için her iki bitin de1olması gerek.

Mantıksal OR (veya) İşleci (|)

Bu işleç, her iki tarafındaki değişkenin bitleri üzerinde mantıksalor(veya) işlemi yapar. Bu işleç,
önceki bölümde gördüğünüzorişleci ile aynı işlemi karşılıklı bitler üzerinde yapar.

```python
if (True or False): # 1 = True, 0 = False
 ...

```

Bu örneğimizde parantez içi ifademiz True değerine eşit olacağından if bloğumuz çalışacaktır.
Mantıksal or da aynı prensibe dayalıdır.
| 1 | 1 | = 1 |
| --- | --- |
| 1 | 0 | = 1 |
| 0 | 1 | = 1 |
| 0 | 0 | = 0 |

1 | 1

= 1

1 | 0

= 1

0 | 1

= 1

0 | 0

= 0

Hemen güzide örneğimizi getirelim.

```python
a = 10 # 0000 1010 = 10
b = 20 # 0001 0100 = 20

print(a | b) # 0001 1110 = 30

30

```

```python
a = 10 # 0000 1010 = 10
b = 22 # 0001 0110 = 22

print(a | b) # 0001 1110 = 30

30

```

Örneğimizi inceleyelim, alt alta bitlerde eğer sadece bir tane ‘1’ varsa, o bit karşılaştırma
sonrasında1’e eşit olur. Zaten yukarıdaki tablomuzda belirtilmiş. Eğer karşılaştırma
sonucunun0olmasını istiyor isek her iki bitinde0değerini alması lazım.

Mantıksal XOR (ya da) İşleci (^)

Bu işleçten önceki bütün işleçlerin adı sembolik mantıktaki karşılığı ile aynıydı ancak burada
durum biraz farklı. Sembolik mantık derslerinde biz XOR işlecine ‘ya da’ deriz. Bu işleç de
her iki tarafındaki değişkenin bitleri üzerinde ‘XOR’ işlemi yapar. Tabii bu derslerde “ya da”nın
işlevini daha önce görmedik. O zaman “ya da”yı gösterelim
| 1 ^ 1 | = 0 |
| --- | --- |
| 1 ^ 0 | = 1 |
| 0 ^ 1 | = 1 |
| 0 ^ 0 | = 0 |

1 ^ 1

= 0

1 ^ 0

= 1

0 ^ 1

= 1

0 ^ 0

= 0

XOR (ya da) ile bağlanan iki basit önermenin doğru olabilmesi için iki önermenin de değerinin
birbirinden farklı olması gerekmektedir. Yani XOR (ya da) ile karşılaştırma işleminin1(doğru)
olabilmesi için önermelerin birbirinden farklı doğruluk değerlerine sahip olması gerekmektedir.
Tabloyu güzelce incelerseniz aklınıza kazınacaktır.

Örneğimiz üzerinden de bir görelim isterseniz.

```python
a = 10 # 0000 1010 = 10
b = 20 # 0001 0100 = 20

print(a^b) # 0001 1110 = 30

30

```

```python
a = 10 # 0000 1010 = 10
b = 22 # 0001 0110 = 22

print(a^b) # 0001 1100 = 28

28

```

Örnekte de görüldüğü gibi alt alta olan bitlerde eğer bit değeri aynı ise karşılaştırma
sonrası o bitin değeri 0 olacaktır. Eğer bu durum gerçekleşmezse bitimizin değeri1olacaktır.

Tümleme (Invert) İşleci (~)

Tümleme işleci diğer işleçlerden farklı olarak 2 değer arasında karşılaştırma yapmaz.
Bu işlece sembolik mantıkta “Değil” denir. Bu işlecin görevi aldığı değeri tersine çevirmektir.
| ~1 | = 0 |
| --- | --- |
| ~0 | = 1 |

~1

= 0

~0

= 1

Tablodan da anlaşılacağı gibi tümleme işleci aldığını tersine çevirip bize veriyor.
Bu işlevin aynısını verdiğimiz değere de yapacak.

Hemen bir örnek getirelim:

```python
a = 1 # 0000 0001 = 1

print(~a) # 1111 1110 = -2

-2

```

```python
b = 19 # 0001 0011 = 19

print(~b) # 1110 1100 = -20

-20

```

Hay aksi sanki buradaki çıktılarda bir garipilik var değil mi? Evet var. Hemen
açıklayalım. Şöyle ki bir bit dizisinde son bit karakterin (ya da sayının) işaretini
temsil eder. Geçmiş örneklerimizde son bit hep0olduğu için sayımız pozitif değerdeydi.
Bu örneğimizde ise ‘~’ işaretinin etkisiyle bu değerimiz1oldu yani negatif değerli
tam sayıyı temsil etti. Ama iş burası ile de kalmıyor. Biz tümleme işlemi yaptığımız
zaman aslında bitlerin değerini başka şekilde hesaplıyoruz. Bir kere1ile0değerlerinin
işlevelemini değiştirmiş oluyoruz. Yani ikilinin katlarını artık0’a göre yazıyoruz.
Bu değerleri en sonunda toplayıp -1’den çıkarıyoruz. İşte böylece tümleme işlemimiz
sonucu çıkan bitin değerini hesaplayabiliriz. Ama bu kısım o kadar da önemli değil
sadece formüle etmek de yeter.

n - (2n + 1)

İşte size tümleme işleminin sonucunu gösteren güzide formül.

Shifting (kaydırma) İşleçleri (`>>` `<<`)

Kaydırma işleçlerinin sembolik mantıkta bir karşılığı yoktur. Bunlar tamamen
programlamaya özgüdür. Bu işleçler için bir tabloya da ihtiyaç duymayacağız. Hemen
bir örnek verelim ve açıklamasını yapalım.

```python
 a = 64 # 0100 0000 = 64

 print(a >> 3) # 0000 1000 = 8

8

```

```python
b = 16 # 0001 0000 = 16

print(b << 2) # 0100 0000 = 64

64

```

Zaten az çok örneklerden ne olduğu ortaya çıkıyor. Okların solundaki sayının
bitlerini okların sağındaki sayı kadar okların yönünde kaydırıyoruz. Ancak bu
işleçte bazı püf noktalarımız var, onu hemen gösterelim.

```python
a = 64

print(a << 1) # ... 1000 0000 = 128

```

Evet, burada önceki işleçte gösterdiğimiz negatif-pozitif olayını yaşamadık.
Peki neden? Şu ana kadar ki örneklerimizde hep 8 bit üzerinden örnekler yaptık
ancak Python’da bu genellikle böyle olmuyor. Bunu şöyle kontrol edebiliriz.

```python
import sys

a = 1
sys.getsizeof(a) # 28

28

```

Yukarıdaki kodda anlamadığınız yerler varsa takılmayın. Sadece şunu bilmeniz yeterli.
Bu kod parçası size elinizdeki değişkenin boyutunu söyler. Gördüğünüz gibi ‘a’
değişkenin boyutu 28miş. Demek ki bu değişken 28 bitten oluşuyormuş. Peki şöyle
birşey yapsaydık.

```python
import sys

a = 1
a <<= 30

sys.getsizeof(a) # 32

32

```

Gördüğünüz gibi değişkenimiz boyut değişikliğine uğradı. Yani bit kaydırma işleminde
sola giderken değişkenimizin gidebileceği başka yeri kalmayınca boyutunu
değiştirebiliyor. Ancak bunu tümeleme işleminde yapmıyor çünkü tümeleme işleminin
amacına uygun değil. Bir başka püf nokta ise şöyle:

> **Not**
> Değer atama işleçleri bölümünde gördüğünüz “+=”, “-=” gibi ifadeleri bitsel
işleçler ile de kullanabilirsiniz. (Yukarıda gördüğünüz gibi)

Not

Değer atama işleçleri bölümünde gördüğünüz “+=”, “-=” gibi ifadeleri bitsel
işleçler ile de kullanabilirsiniz. (Yukarıda gördüğünüz gibi)

```python
a = 15 # 0000 1111 = 15

print(a >> 3) # 0000 0001 = 1

1

```

Gördüğünüz gibi bit kaydırma işleminde eğer sağda yer yoksa o değer atılır. Çünkü
bitlerde değer artırımı sol tarafa ekleme yaparak olur ki zaten mantıklısı da bu.

> **Not**
> Bu kısım eğer programlamaya yeni başlıyorsanız biraz zor gelebilir. Anlayamadığınız
kısım olursa telaşlanmayın ve ilerlemeye devam edin. Biraz daha temelinizi sağlamlaştırınca
tekrar buraya dönebilirsiniz. Emin olun, o zaman her şey daha güzelce oturur.

Not

Bu kısım eğer programlamaya yeni başlıyorsanız biraz zor gelebilir. Anlayamadığınız
kısım olursa telaşlanmayın ve ilerlemeye devam edin. Biraz daha temelinizi sağlamlaştırınca
tekrar buraya dönebilirsiniz. Emin olun, o zaman her şey daha güzelce oturur.

Bitsel İşleçleri Kullanmanın Avantajları ve Dezavantajları

Şimdi bitsel işleçlerimizin avantajlarını ve dezavantajlarını görelim.

Avantajlar:
1. Performans:Bitsel işlemler genellikle daha hızlıdır çünkü bilgisayarlar üzerinde doğrudan
donanım seviyesinde gerçekleştirilirler. Özellikle büyük veri setleri üzerinde çalışırken
performansı artırabilirler.
1. Bellek Kullanımı:Bitsel işlemler genellikle daha az bellek kullanır. Bu, özellikle çok
büyük veri yapıları üzerinde işlem yaparken bellek kullanımını azaltmaya yardımcı olabilir.

Performans:Bitsel işlemler genellikle daha hızlıdır çünkü bilgisayarlar üzerinde doğrudan
donanım seviyesinde gerçekleştirilirler. Özellikle büyük veri setleri üzerinde çalışırken
performansı artırabilirler.

Bellek Kullanımı:Bitsel işlemler genellikle daha az bellek kullanır. Bu, özellikle çok
büyük veri yapıları üzerinde işlem yaparken bellek kullanımını azaltmaya yardımcı olabilir.

Dezavantajlar:
1. Okunabilirlik:Bitsel işlemler, genellikle kodun okunabilirliğini azaltabilir. Bit
seviyesinde yapılan işlemler, kodun ne yaptığını anlamak için daha fazla çaba gerektirebilir.
1. Hata Yapma Olasılığı:Bitsel işlemlerle çalışırken, yanlış operatörler veya yanlış bit işlemleri
yapma olasılığı daha yüksektir. Bu, hataların bulunması ve düzeltilmesi için daha fazla zaman
harcanmasına neden olabilir.

Okunabilirlik:Bitsel işlemler, genellikle kodun okunabilirliğini azaltabilir. Bit
seviyesinde yapılan işlemler, kodun ne yaptığını anlamak için daha fazla çaba gerektirebilir.

Hata Yapma Olasılığı:Bitsel işlemlerle çalışırken, yanlış operatörler veya yanlış bit işlemleri
yapma olasılığı daha yüksektir. Bu, hataların bulunması ve düzeltilmesi için daha fazla zaman
harcanmasına neden olabilir.

> **Not**
> Asıl dezavantajı görünür kılmak için buraya koydum. Bitwise ile yapılan işlemler Python
dilinin amacına uygun değildir. Python yazılım dilinin amacı kullanıcı kolaylığıdır.
Pythonda performans ve bellek kullanımı çok önemsenmez. Eğer böyle ihtiyaçlarınız
varsa başka dillerle ilgilenmeniz daha doğru olacaktır. Ama bu söylediklerimden
“Şimdi ben bu bölümü boşuna mı okudum?” diye bir sonuç çıkarmayın. Burada gösterdiğimiz
şeyler neredeyse bütün programlama dillerinde mevcut. Ayrıca yaptığınız bütün işlemler
dayanağını bu işleçlerden alıyor. Bu kısma özellikle dikkat etmenizi rica ediyorum.
Emin olun bu yolculukta öğrendiğiniz hiçbir şey boşuna olmayacak.

Not

Asıl dezavantajı görünür kılmak için buraya koydum. Bitwise ile yapılan işlemler Python
dilinin amacına uygun değildir. Python yazılım dilinin amacı kullanıcı kolaylığıdır.
Pythonda performans ve bellek kullanımı çok önemsenmez. Eğer böyle ihtiyaçlarınız
varsa başka dillerle ilgilenmeniz daha doğru olacaktır. Ama bu söylediklerimden
“Şimdi ben bu bölümü boşuna mı okudum?” diye bir sonuç çıkarmayın. Burada gösterdiğimiz
şeyler neredeyse bütün programlama dillerinde mevcut. Ayrıca yaptığınız bütün işlemler
dayanağını bu işleçlerden alıyor. Bu kısma özellikle dikkat etmenizi rica ediyorum.
Emin olun bu yolculukta öğrendiğiniz hiçbir şey boşuna olmayacak.

### Aitlik İşleçleri

Aitlik işleçleri, bir karakter dizisi ya da sayının, herhangi bir veri tipi
içinde bulunup bulunmadığını sorgulamamızı sağlayan işleçlerdir.

Python’da bir tane aitlik işleci bulunur. Bu işleç deinişlecidir. Bu işleci
şöyle kullanıyoruz:

```python
>>> a = "abcd"
>>> "a" in a

True

>>> "f" in a

False

```

Gördüğünüz gibi,inadlı bu işleç, bir öğenin, veri tipi içinde bulunup
bulunmadığını sorguluyor. Eğer bahsedilen öğe, veri tipi içinde geçiyorsaTrueçıktısı, eğer geçmiyorsaFalseçıktısı alıyoruz.

Henüz buinişlecini verimli bir şekilde kullanmamızı sağlayacak araçlardan
yoksunuz. Ancak birkaç sayfa sonra öğreneceğimiz yeni araçlarla birlikte bu
işleci çok daha düzgün ve verimli bir şekilde kullanabilecek duruma geleceğiz.

### Kimlik İşleçleri

Python’da her şeyin (ya da başka bir deyişle her nesnenin) bir kimlik numarası
(identity) vardır. Kabaca söylemek gerekirse, bu kimlik numarası denen şey
esasında o nesnenin bellekteki adresini gösterir.

Peki bir nesnenin kimlik numarasına nasıl ulaşırız?

Python’da bu işi yapmamızı sağlayacakid()adlı bir fonksiyon bulunur
(İngilizcedekiidentity(kimlik) kelimesinin kısaltması). Şimdi bir örnek
üzerinde buid()fonksiyonunu nasıl kullanacağımıza bakalım:

```python
>>> a = 100
>>> id(a)

137990748

```

Çıktıda gördüğümüz137990748sayısıadeğişkeninin tuttuğu100sayısının
kimlik numarasını gösteriyor.

Bir de şu örneklere bakalım:

```python
>>> a = 50
>>> id(a)

505494576

>>> kardiz = "Elveda Zalim Dünya!"
>>> id(kardiz)

14461728

```

Gördüğünüz gibi, Python’daki her nesnenin kimliği eşşiz, tek ve benzersizdir.

Yukarıda verdiğimiz ilk örnekte biradeğişkeni tanımlayıp bunun değerini100olarak belirlemiş veid(a)komutuyla da bu nesnenin kimlik numarasına
ulaşmıştık. Yani:

```python
>>> a = 100
>>> id(a)
137990748

```

Bir de şu örneğe bakalım:

```python
>>> b = 100
>>> id(b)

137990748

```

Gördüğünüz gibi, Pythonavebdeğişkenlerinin değeri için aynı kimlik
numarasını gösterdi. Bu demek oluyor ki, Python iki adet100sayısı için
bellekte iki farklı nesne oluşturmuyor. İlk kullanımda önbelleğine aldığı
sayıyı, ikinci kez ihtiyaç olduğunda bellekten alıp kullanıyor. Bu tür bir
önbellekleme mekanizmasının gerekçesi performansı artırmaktır.

Ama bir de şu örneklere bakalım:

```python
>>> a = 1000
>>> id(a)

15163440

>>> b = 1000
>>> id(b)

14447040

>>> id(1000)

15163632

```

Bu defa Pythonadeğişkeninin tuttuğu1000sayısı,bdeğişkeninin tuttuğu
1000 sayısı ve tek başına yazdığımız1000sayısı için farklı kimlik numaraları
gösterdi. Bu demek oluyor ki, Pythonadeğişkeninin tuttuğu1000sayısı
için,bdeğişkeninin tuttuğu1000sayısı için ve doğrudan girdiğimiz1000sayısı için bellekte üç farklı nesne oluşturuyor. Yani bu üç adet1000sayısı
Python açısından birbirinden farklı…

Yukarıdaki durumu görebileceğimiz başka bir yöntem de Python’dakiisadlı
kimlik işlecini kullanmaktır. Deneyelim:

```python
>>> a is 1000

False

>>> b is 1000

False

```

Gördüğünüz gibi, PythonFalse(Yanlış) çıktısını suratımıza bir tokat gibi
çarptı… Peki bu ne anlama geliyor?

Bu şu anlama geliyor: Demek ki görünüşte aynı olan iki nesne aslında birbirinin
aynı olmayabiliyor. Bunun neden bu kadar önemli olduğunu ilerleyen derslerde çok
daha iyi anlayacağız.

Yukarıdaki durumun bir başka yansıması daha vardır. Özellikle Python’a yeni
başlayıp da bu dilde yer alanisişlecini öğrenenler, bu işlecin==işleciyle aynı işleve sahip olduğu yanılgısına kapılabiliyor veisişlecini
kullanarak iki nesne arasında karşılaştırma işlemi yapmaya kalkışabiliyor.

Ancak Python’daisişlecini kullanarak iki nesne arasında karşılaştırma yapmak
güvenli değildir. Yaniisve==işleçleri birbirleriyle aynı işlevi görmez.
Bu iki işleç nesnelerin farklı yönlerini sorgular:isişleci nesnelerin
kimliklerine bakıp o nesnelerin aynı nesneler olup olmadığını kontrol ederken,==işleci nesnelerin içeriğine bakarak o nesnelerin aynı değere sahip olup
olmadıklarını sorgular. Bu iki tanım arasındaki ince farka dikkat edin.

Yani:

```python
>>> a is 1000

False

```

Ama:

```python
>>> a == 1000

True

```

Buradaisişleciadeğişkeninin tuttuğu veri ile1000sayısının aynı
kimlik numarasına sahip olup olmadığını sorgularken,==işleciadeğişkeninin tuttuğu verinin1000olup olmadığını denetliyor. Yaniisişlecinin yaptığı şey kabaca şu oluyor:

```python
>>> id(a) == id(1000)

False

```

Şimdiye kadar denediğimiz örnekler hep sayıydı. Şimdi isterseniz bir de karakter
dizilerinin durumuna bakalım:

```python
>>> a = "python"
>>> a is "python"

True

```

BuradaTrueçıktısını aldık. Bir de==işleci ile bir karşılaştırma
yapalım:

```python
>>> a == "python"

True

```

Bu da normal olarakTrueçıktısı veriyor. Ama şu örneğe bakarsak:

```python
>>> a = "python güçlü ve kolay bir programlama dilidir"
>>> a is "python güçlü ve kolay bir programlama dilidir"

False

```

Ama:

```python
>>> a == "python güçlü ve kolay bir programlama dilidir"

True

```

isve==işleçlerinin nasıl da farklı sonuçlar verdiğini görüyorsunuz. Çünkü
bunlardan biri nesnelerin kimliğini sorgularken, öbürü nesnelerin içeriğini
sorguluyor. Ayrıca burada dikkatimizi çekmesi gereken başka bir nokta da“python”karakter dizisinin önbelleğe alınıp gerektiğinde tekrar tekrar
kullanılıyorken,“python güçlü ve kolay bir programlama dilidir”karakter
dizisinin ise önbelleğe alınmıyor olmasıdır. Aynı karakter dizisinin tekrar
kullanılması gerektiğinde Python bunun için bellekte yeni bir nesne daha
oluşturuyor.

Peki neden Python, örneğin,100sayısını ve“python”karakter dizisini
önbelleklerken1000sayısını ve“python güçlü ve kolay bir programlama
dilidir”karakter dizisini önbelleğe almıyor. Sebebi şu: Python kendi iç
mekanizmasının işleyişi gereğince ‘ufak’ nesneleri önbelleğe alırken ‘büyük’
nesneler için her defasında yeni bir depolama işlemi yapıyor. Peki ufak ve büyük
kavramlarının ölçütü nedir? İsterseniz Python açısından ufak kavramının
sınırının ne olabileceğini şöyle bir kod yardımıyla sorgulayabiliriz:

```python
>>> for k in range(-1000, 1000):
... for v in range(-1000, 1000):
... if k is v:
... print(k)

```

> **Not**
> Burada henüz öğrenmediğimiz şeyler var. Bunları birkaç bölüm sonra
ayrıntılı bir şekilde inceleyeceğiz.

Not

Burada henüz öğrenmediğimiz şeyler var. Bunları birkaç bölüm sonra
ayrıntılı bir şekilde inceleyeceğiz.

Bu kod-1000ve1000aralığındaki iki sayı grubunu karşılaştırıp, kimlikleri
aynı olan sayıları ekrana döküyor. Yani bir bakıma Python’un hangi sayıya kadar
önbellekleme yaptığını gösteriyor. Buna göre-5ile257arasında kalan
sayılar Python tarafından ufak olarak değerlendiriliyor ve önbelleğe alınıyor.
Bu aralığın dışında kalan sayılar için ise bellekte her defasında ayrı bir nesne
oluşturuluyor.

Burada aldığımız sonuca göre şöyle bir denetleme işlemi yapalım:

```python
>>> a = 256
>>> a is 256

True

>>> a = 257
>>> a is 257

False

>>> a = -5
>>> a is -5

True

>>> a = -6
>>> a is -6

False

```

Böylece Python’daki kimlik işleçlerini de incelemiş olduk. Belki programcılık
maceranız boyuncaid()fonksiyonunu hiç kullanmayacaksınız, ancak bu
fonksiyonun arkasındaki mantığı anlamak, Python’ın kimi yerlerde alttan alta
neler çevirdiğini çok daha kolay kavramanızı sağlayacaktır.

> **Not**
> https://web.archive.org/web/20161121150306/http://forum.ceviz.net/t/sozluklerin-dinamik-olarak-kopyalanmasi-ve-clear-isleci.81605/adresindeki tartışmaya
bakınız.

Not

https://web.archive.org/web/20161121150306/http://forum.ceviz.net/t/sozluklerin-dinamik-olarak-kopyalanmasi-ve-clear-isleci.81605/adresindeki tartışmaya
bakınız.

Böylece Python’daki bütün işleçleri ayrıntılı bir şekilde incelemiş olduk.
Dilerseniz şimdi bu konuyla ilgili birkaç uygulama örneği yapalım.

### Uygulama Örnekleri

#### Basit Bir Hesap Makinesi

Şu ana kadar Python’da pek çok şey öğrendik. Bu öğrendiğimiz şeylerle artık
kısmen yararlı bazı programlar yazabiliriz. Elbette henüz yazacağımız programlar
pek yetenekli olamayacak olsa da, en azından bize öğrendiklerimizle pratik yapma
imkanı sağlayacak. Bu bölümde,if,elif,elseyapılarını ve
öğrendiğimiz temel aritmetik işleçleri kullanarak çok basit bir hesap makinesi
yapmayı deneyeceğiz. Bu arada, bu derste yeni şeyler öğrenerek ufkumuzu ve
bilgimizi genişletmeyi de ihmal etmeyeceğiz.

İsterseniz önce kullanıcıya bazı seçenekler sunarak işe başlayalım:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) kare kök hesapla
"""

print(giriş)

```

Burada kullanıcıya bazı seçenekler sunduk. Bu seçenekleri ekrana yazdırmak için
üç tırnak işaretlerinden yararlandığımıza dikkat edin. Birden fazla satıra
yayılmış bu tür ifadeleri en kolay üç tırnak işaretleri yardımıyla
yazdırabileceğimizi biliyorsunuz artık.

Biz burada bütün seçenekleri tek bir değişken içine yerleştirdik. Esasında her
bir seçenek için ayrı bir değişken tanımlamak da mümkündür. Yani aslında
yukarıdaki kodları şöyle de yazabiliriz:

```python
seçenek1 = "(1) topla"
seçenek2 = "(2) çıkar"
seçenek3 = "(3) çarp"
seçenek4 = "(4) böl"
seçenek5 = "(5) karesini hesapla"
seçenek6 = "(6) karekök hesapla"

print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5)

```

Yalnız burada dikkat ederseniz, seçenekler hep yan yana diziliyor. Eğer
programınızda yukarıdaki şekli kullanmak isterseniz, bu seçeneklerin yan yana
değil de, alt alta görünmesini sağlamak için, önceki derslerimizde öğrendiğimizsepparametresini kullanabilirsiniz:

```python
seçenek1 = "(1) topla"
seçenek2 = "(2) çıkar"
seçenek3 = "(3) çarp"
seçenek4 = "(4) böl"
seçenek5 = "(5) karesini hesapla"
seçenek6 = "(6) karekök hesapla"

print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5, seçenek6, sep="\n")

```

Buradasepparametresinin değeri olarak\nkaçış dizisini belirlediğimize
dikkat edin.\nkaçış dizisinin ne işe yaradığını hatırlıyorsunuz. Bu dizi,
satır başına geçmemizi sağlıyordu. Burada, ayraç olarak satır başı kaçış
dizisini belirlediğimiz için her bir seçenek yan yana değil, alt alta
görünecektir. Elbettesepparametresi için istediğiniz değeri
belirleyebilirsiniz. Mesela her bir seçeneği satır başı işaretiyle ayırmak
yerine, çift tire gibi bir işaretle ayırmayı da tercih edebilirsiniz:

```python
print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5, sep="--")

```

Programınızda nasıl bir giriş paragrafı belirleyeceğiniz konusunda özgürsünüz.
Gelin isterseniz biz birinci şekille yolumuza devam edelim:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

```

Buradagirişadlı bir değişken oluşturduk. Bu değişkenin içinde barındırdığı
değeri kullanıcıların görebilmesi içinprint()fonksiyonu yardımıyla bu
değişkeni ekrana yazdırıyoruz. Devam edelim:

```python
soru = input("Yapmak istediğiniz işlemin numarasını girin: ")

```

Bu kod yardımıyla kullanıcıya bir soru soruyoruz. Kullanıcıdan yapmasını
istediğimiz şey, yukarıda belirlediğimiz giriş seçenekleri içinden bir sayı
seçmesi. Kullanıcı1,2,3,4,5veya6seçeneklerinden herhangi
birini seçebilir. Kullanıcıyı, seçtiği numaranın karşısında yazan işleme
yönlendireceğiz. Yani mesela eğer kullanıcı klavyedeki1tuşuna basarsa hesap
makinemiz toplama işlemi yapacaktır.2tuşu ise kullanıcıyı çıkarma işlemine
yönlendirir…

input()fonksiyonunu işlediğimiz bölümde, bu fonksiyonun değer olarak her
zaman bir karakter dizisi (string) verdiğini söylemiştik. Yukarıdaki kodun
çıktısı da doğal olarak bir karakter dizisi olacaktır. Bizim şu aşamada
kullanıcıdan karakter dizisi almamızın bir sakıncası yok. Çünkü kullanıcının
gireceği1,2,3,4,5veya6değerleriyle herhangi bir aritmetik
işlem yapmayacağız. Kullanıcının gireceği bu değerler, yalnızca bize onun hangi
işlemi yapmak istediğini belirtecek. Dolayısıylainput()fonksiyonunu
yukarıdaki şekilde kullanıyoruz.

İsterseniz şimdiye kadar gördüğümüz kısma topluca bakalım:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

soru = input("Yapmak istediğiniz işlemin numarasını girin: ")

```

Bu kodları çalıştırdığımızda, ekranda giriş paragrafımız görünecek ve
kullanıcıya, yapmak istediği işlemin ne olduğu sorulacaktır. Henüz kodlarımız
eksik olduğu için, kullanıcı hangi sayıyı girerse girsin, programımız hiç bir iş
yapmadan kapanacaktır. O halde yolumuza devam edelim:

```python
if soru == "1":

```

Böylece ilkifdeyimimizi tanımlamış olduk. Buradaki yazım şekline çok
dikkat edin. Bu kodlarla Python’a şu emri vermiş oluyoruz:

Eğersoruadlı değişkenin değeri1ise, yani eğer kullanıcı klavyede1tuşuna basarsa…

ifdeyimlerinin en sonuna:işaretini koymayı unutmuyoruz. Python’a yeni
başlayanların en çok yaptığı hatalardan birisi, sondaki bu:işaretini koymayı
unutmalarıdır. Bu işaret bize çok ufak bir ayrıntıymış gibi görünse de Python
için manevi değeri çok büyüktür! Python’un bize öfkeli mesajlar göstermesini
istemiyorsak bu işareti koymayı unutmayacağız. Bu arada, burada==işaretini
kullandığımıza da dikkat edin. Bunun ne anlama geldiğini önceki derslerimizde
öğrenmiştik. Bu işaret, iki şeyin aynı değere sahip olup olmadığını
sorgulamamızı sağlıyor. Biz buradasoruadlı değişkenin değerinin1olup
olmadığını sorguladık.sorudeğişkeninin değeri kullanıcı tarafından
belirleneceği için henüz bu değişkenin değerinin ne olduğunu bilmiyoruz. Bizim
programımızda kullanıcı klavyeden1,2,3,4,5veya6değerlerinden
herhangi birini seçebilir. Biz yukarıdaki kod yardımıyla, eğer kullanıcı
klavyede1tuşuna basarsa ne yapılacağını belirleyeceğiz. O halde devam
edelim:

```python
if soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))
 print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Böylece ilkifbloğumuzu tanımlamış olduk.

ifdeyimimizi yazdıktan sonra ne yaptığımız çok önemli. Buradaki
girintileri, programımız güzel görünsün diye yapmıyoruz. Bu girintilerin Python
için bir anlamı var. Eğer bu girintileri vermezsek programımız çalışmayacaktır.
Eğer Python kodlarına duyarlı bir metin düzenleyici kullanıyorsanız,:işaretini koyupEntertuşuna bastıktan sonra otomatik olarak girinti
verilecektir. Eğer kullandığınız metin düzenleyici size böyle bir kolaylık
sunmuyorsaEntertuşuna bastıktan sonra klavyedeki boşluk (SPACE) tuşunu
kullanarak dört vuruşluk bir girinti oluşturabilirsiniz. Bu girintiler, ilk
satırda belirlediğimizifdeyimiyle gösterilecek işlemlere işaret ediyor.
Dolayısıyla burada yazılan kodları Pythoncadan Türkçeye çevirecek olursak şöyle
bir şey elde ederiz:

```python
eğer sorunun değeri '1' ise:
 Toplama işlemi için ilk sayı girilsin. Bu değere 'sayı1' diyelim.
 Sonra ikinci sayı girilsin. Bu değere de 'sayı2' diyelim.
 En son, 'sayı1', '+' işleci, 'sayı2', '=' işleci ve 'sayı1 + sayı2'
 ekrana yazdırılsın...

```

Gelin isterseniz buraya kadar olan bölümü yine topluca görelim:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

soru = input("Yapmak istediğiniz işlemin numarasını girin: ")

if soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))
 print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Bu kodları çalıştırıp, klavyede1tuşuna bastığımızda, bizden bir sayı
girmemiz istenecektir. İlk sayımızı girdikten sonra bize tekrar bir sayı
girmemiz söylenecek. Bu emre de uyupEntertuşuna basınca, girdiğimiz bu iki
sayının toplandığını göreceğiz. Fena sayılmaz, değil mi?

Şimdi programımızın geri kalan kısmını yazıyoruz. İşin temelini kavradığımıza
göre birden fazla kod bloğunu aynı anda yazabiliriz:

```python
elif soru == "2":
 sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: "))
 sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: "))
 print(sayı3, "-", sayı4, "=", sayı3 - sayı4)

elif soru == "3":
 sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: "))
 sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: "))
 print(sayı5, "x", sayı6, "=", sayı5 * sayı6)

elif soru == "4":
 sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: "))
 sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: "))
 print(sayı7, "/", sayı8, "=", sayı7 / sayı8)

elif soru == "5":
 sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: "))
 print(sayı9, "sayısının karesi =", sayı9 ** 2)

elif soru == "6":
 sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: "))
 print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5)

```

Bunlarla birlikte kodlarımızın büyük bölümünü tamamlamış oluyoruz. Bu bölümdeki
tek fark, ilkifbloğunun aksine, buradaelifbloklarını kullanmış
olmamız. Eğer burada bütün bloklarıifkullanarak yazarsanız, biraz sonra
kullanacağımızelsebloğu her koşulda çalışacağı için beklentinizin dışında
sonuçlar elde edersiniz.

Yukarıdaki kodlarda az da olsa farklılık gösteren tek yer son ikielifbloğumuz. Esasında buradaki fark da pek büyük bir fark sayılmaz. Neticede tek
bir sayının karesini ve karekökünü hesaplayacağımız için, kullanıcıdan yalnızca
tek bir giriş istiyoruz.

Şimdi de son bloğumuzu yazalım. Az evvel çıtlattığımız gibi, bu son blok birelsebloğu olacak:

```python
else:
 print("Yanlış giriş.")
 print("Aşağıdaki seçeneklerden birini giriniz:", giriş)

```

Çok basit birelsebloğu ile işimizi bitirdik. Bu bloğun ne işe yaradığını
biliyorsunuz:

Eğer kullanıcının girdiği değer yukarıdaki bloklardan hiç birine uymuyorsa
buelsebloğunu işlet!

gibi bir emir vermiş oluyoruz buelsebloğu yardımıyla. Mesela kullanıcımız1,2,3,4,5veya6seçeneklerini girmek yerine7yazarsa, bu
blok işletilecek.

Gelin isterseniz son kez kodlarımızı topluca bir görelim:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

soru = input("Yapmak istediğiniz işlemin numarasını girin: ")

if soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))
 print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

elif soru == "2":
 sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: "))
 sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: "))
 print(sayı3, "-", sayı4, "=", sayı3 - sayı4)

elif soru == "3":
 sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: "))
 sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: "))
 print(sayı5, "x", sayı6, "=", sayı5 * sayı6)

elif soru == "4":
 sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: "))
 sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: "))
 print(sayı7, "/", sayı8, "=", sayı7 / sayı8)

elif soru == "5":
 sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: "))
 print(sayı9, "sayısının karesi =", sayı9 ** 2)

elif soru == "6":
 sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: "))
 print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5)

else:
 print("Yanlış giriş.")
 print("Aşağıdaki seçeneklerden birini giriniz:", giriş)

```

Genel olarak baktığımızda, bütün programın aslında basit bir ‘if, elif, else’
yapısından ibaret olduğunu görüyoruz. Ayrıca bu kodlardaki simetriye de
dikkatinizi çekmek isterim. Gördüğünüz gibi her ‘paragraf’ birif,elifveyaelsebloğundan oluşuyor ve her blok kendi içinde girintili bir yapı
sergiliyor. Temel olarak şöyle bir şeyle karşı karşıyayız:

```python
Eğer böyle bir durum varsa:
 şöyle bir işlem yap

Yok eğer şöyle bir durum varsa:
 böyle bir işlem yap

Eğer bambaşka bir durum varsa:
 şöyle bir şey yap

```

Böylelikle şirin bir hesap makinesine sahip olmuş olduk! Hesap makinemiz pek
yetenekli değil, ama olsun… Henüz bildiklerimiz bunu yapmamıza müsaade ediyor.
Yine de başlangıçtan bu noktaya kadar epey yol katettiğimizi görüyorsunuz.

Şimdi bu programı çalıştırın ve neler yapabildiğine göz atın. Bu arada kodları
da iyice inceleyin. Programı yeterince anladıktan sonra, program üzerinde
kendinize göre bazı değişiklikler yapın, yeni özellikler ekleyin.
Eksikliklerini, zayıf yönlerini bulmaya çalışın. Böylece bu dersten azami
faydayı sağlamış olacaksınız.

#### Sürüme Göre İşlem Yapan Program

Bildiğiniz gibi, şu anda piyasada iki farklı Python serisi bulunuyor: Python2 ve
Python3. Daha önce de söylediğimiz gibi, Python’ın 2.x serisi ile çalışan bir
program Python’ın 3.x serisi ile muhtemelen çalışmayacaktır. Aynı şekilde bunun
tersi de geçerlidir. Yani 3.x ile çalışan bir program 2.x ile büyük ihtimalle
çalışmayacaktır.

Bu durum, yazdığınız programların farklı Python sürümleri ile çalıştırılma
ihtimaline karşı bazı önlemler almanızı gerektirebilir. Örneğin yazdığınız bir
programda kullanıcılarınızdan beklentiniz, programınızı Python’ın 3.x
sürümlerinden biri ile çalıştırmaları olabilir. Eğer programınız Python’ın 2.x
sürümlerinden biri ile çalıştırılırsa kullanıcıya bir uyarı mesajı göstermek
isteyebilirsiniz.

Hatta yazdığınız bir program, aynı serinin farklı sürümlerinde dahi çalışmayı
engelleyecek özellikler içeriyor olabilir. Örneğinprint()fonksiyonununflushadlı parametresi dile3.3sürümü ile birlikte eklendi. Dolayısıyla bu
parametreyi kullanan bir program, kullanıcının3.3veya daha yüksek bir Python
sürümü kullanmasını gerektirir. Böyle bir durumda, programınızı çalıştıran
Python sürümünün en düşük3.3olmasını temin etmeniz gerekir.

Peki bunu nasıl yapacaksınız?

Burada aklınızda ilk olarak, kodlarınıza#!/usr/bin/env python3.3veya#!
python3.3gibi bir satır eklemek gelmiş olabilir. Ama unutmayın, bu çözüm ancak
kısıtlı bir işlevsellik sunabilir. Programımıza böyle bir satır eklediğimizde,
programımızın Python’ın3.3sürümü ile çalıştırılması gerektiğini belirtiyoruz.
Ama3.3dışı bir sürümle çalıştırıldığında ne olacağını belirtmiyoruz. Böyle
bir durumda, eğer programımız3.3dışı bir sürümle çalıştırılırsa çökecektir.
Bizim burada daha kapsamlı ve esnek bir çözüm bulmamız gerekiyor.

Hatırlarsanız önceki derslerden birindesysadlı bir modülden söz etmiştik.
Bildiğiniz gibi, bu modül içinde pek çok yararlı değişken ve fonksiyon
bulunuyor. Önceki derslerimizde, bu modül içinde bulunanexit()fonksiyonu
ilestdoutveversiondeğişkenlerini gördüğümüzü hatırlıyor olmalısınız.sysmodülü içinde bulunanexit()fonksiyonunun programdan çıkmamızı
sağladığını,stdoutdeğişkeninin standart çıktı konumu bilgisini tuttuğunu veversiondeğişkeninin de kullandığımız Python sürümü hakkında bilgi verdiğini
biliyoruz. İşte yukarıda bahsettiğimiz programda da busysmodülünden
yararlanacağız.

Bu iş için,versiondeğişkenine çok benzeyenversion_infoadlı bir
değişkeni kullanacağız.

Bu değişkenin nasıl kullanıldığına etkileşimli kabukta beraberce bakalım…

sysmodülü içindeki araçları kullanabilmek için öncelikle bu modülü içe
aktarmamız gerektiğini biliyorsunuz:

```python
>>> import sys

```

Şimdi de bu modül içindekiversion_infoadlı değişkene erişelim:

```python
>>> sys.version_info

```

Bu komut bize şöyle bir çıktı verir:

```python
sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel='final', serial=0)
```

Gördüğünüz gibi, bu değişken de bize tıpkıversionadlı değişken gibi,
kullandığımız Python sürümü hakkında bilgi veriyor.

Ben yukarıdaki komutu Python3’te verdiğinizi varsaydım. Eğer yukarıdaki komutu
Python3 yerine Python2’de verseydik şöyle bir çıktı alacaktık:

```python
sys.version_info(major=|major2|, minor=|minor2|, micro=|micro2|, releaselevel='final', serial=0)
```

version_infoveversiondeğişkenlerinin verdikleri çıktının birbirlerinden
farklı yapıda olduğuna dikkat edin.versiondeğişkeni,version_infodeğişkeninden farklı olarak şöyle bir çıktı verir:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

version_infodeğişkeninin verdiği çıktı bizim şu anda yazmak istediğimiz
programa daha uygun. Bunun neden böyle olduğunu biraz sonra siz de
anlayacaksınız.

Gördüğünüz gibi,version_infodeğişkeninin çıktısındamajorveminorgibi
bazı değerler var. Çıktıdan da rahatlıkla anlayabileceğiniz gibi,major,
kullanılan Python serisinin ana sürüm numarasını;minorise alt sürüm
numarasını verir. Çıktıda bir demicroadlı bir değer var. Bu da kullanılan
Python serisinin en alt sürüm numarasını verir.

Bu değere şu şekilde erişiyoruz:

```python
>>> sys.version_info.major

```

Öteki değerlere de aynı şekilde ulaşıyoruz:

```python
>>> sys.version_info.minor
>>> sys.version_info.micro

```

İşte bu çıktılardakimajor(ve yerine göre bununla birlikteminorvemicro) değerini kullanarak, programımızın hangi Python sürümü ile
çalıştırılması gerektiğini kontrol edebiliriz. Şimdi programımızı yazalım:

```python
import sys

_2x_metni = """
Python'ın 2.x sürümlerinden birini kullanıyorsunuz.
Programı çalıştırabilmek için sisteminizde Python'ın
3.x sürümlerinden biri kurulu olmalı."""

_3x_metni = "Programa hoşgeldiniz."

if sys.version_info.major < 3:
 print(_2x_metni)
else:
 print(_3x_metni)

```

Gelin isterseniz öncelikle bu kodları biraz inceleyelim.

İlk olarak modülümüzü içe aktarıyoruz. Bu modül içindeki araçları
kullanabilmemiz için bunu yapmamız şart:

```python
import sys

```

Ardından Python’ın 2.x sürümlerinden herhangi birini kullananlar için bir uyarı
metni oluşturuyoruz:

```python
_2x_metni = """
Python'ın 2.x sürümlerinden birini kullanıyorsunuz.
Programı çalıştırabilmek için sisteminizde Python'ın
3.x sürümlerinden biri kurulu olmalı."""

```

Bildiğiniz gibi Python’da değişken adları bir sayıyla başlamaz. O yüzden
değişken isminin başına bir tane alt çizgi işareti koyduğumuza dikkat edin.

Bu da Python3 kullanıcıları için:

```python
_3x_metni = "Programa hoşgeldiniz."

```

Artık sürüm kontrolü kısmına geçebiliriz. Eğer major parametresinin değeri 3’ten
küçükse _2x_metnini yazdırıyoruz. Bunun dışındaki bütün durumlar için ise
_3x_metnini basıyoruz:

```python
if sys.version_info.major < 3:
 print(_2x_metni)
else:
 print(_3x_metni)

```

Gördüğünüz gibi, kullanılan Python sürümünü kontrol etmek ve eğer program
istenmeyen bir Python sürümüyle çalıştırılıyorsa ne yapılacağını belirlemek son
derece kolay.

Yukarıdaki çok basit bir kod parçası olsa da bize Python programlama diline ve bu
dilin farklı sürümlerine dair son derece önemli bazı bilgiler veriyor.

Eğer bu programı Python’ın 3.x sürümlerinden biri ile çalıştırdıysanız şu
çıktıyı alacaksınız:

```python
Programa hoşgeldiniz.

```

Ama eğer bu programı Python’ın 2.x sürümlerinden biri ile çalıştırdıysanız,
beklentinizin aksine, şöyle bir hata mesajı alacaksınız:

```python
 File "test.py", line 5
SyntaxError: Non-ASCII character '\xc4' in file test.py on line 6, but no
encoding declared; see http://www.python.org/peps/pep-0263.html for details

```

Biz_2x_metniadlı değişkenin ekrana basılmasını beklerken Python bize bir
hata mesajı gösterdi. Aslında siz bu hata mesajına hiç yabancı değilsiniz. Bunu
daha önce de görmüştünüz. Hatırlarsanız önceki derslerimizde karakter
kodlamalarından bahsederken, Python’ın 2.x sürümlerinde öntanımlı karakter
kodlamasının ASCII olduğundan söz etmiştik. Bu yüzden programlarımızda Türkçe
karakterleri kullanırken bazı ilave işlemler yapmamız gerekiyordu.

Burada ilk olarak karakter kodlamasınıUTF-8olarak değiştirmemiz gerekiyor.
Bunun nasıl yapılacağını biliyorsunuz. Programımızın ilk satırına şu kodu
ekliyoruz:

```python
# -*- coding: utf-8 -*-

```

Bu satır Python3 için gerekli değil. Çünkü Python3’te öntanımlı karakter
kodlaması zatenUTF-8. Ama Python2’de öntanımlı karakter kodlamasıASCII. O
yüzden Python2 kullanıcılarını da düşünerekUTF-8kodlamasını açıkça
belirtiyoruz. Böylece programımızın Python’ın 2.x sürümlerinde Türkçe
karakterler yüzünden çökmesini önlüyoruz.

Ama burada bir problem daha var. Programımız Türkçe karakterler yüzünden
çökmüyor çökmemesine ama, bu defa da Türkçe karakterleri düzgün göstermiyor:

```python
Python'Ä±n 2.x sÃ¼rÃ¼mlerinden birini kullanÄ±yorsunuz.
ProgramÄ± Ã§alÄ±ÅŸtÄ±rabilmek iÃ§in sisteminizde Python'Ä±n
3.x sÃ¼rÃ¼mlerinden biri kurulu olmalÄ±.

```

Programımızı Python’ın 2.x sürümlerinden biri ile çalıştıranların uyarı mesajını
düzgün bir şekilde görüntüleyebilmesini istiyorsanız, Türkçe karakterler içeren
karakter dizilerinin en başına bir ‘u’ harfi eklemelisiniz. Yani_2x_metniadlı değişkeni şöyle yazmalısınız:

```python
_2x_metni = u"""
Python'ın 2.x sürümlerinden birini kullanıyorsunuz.
Programı çalıştırabilmek için sisteminizde Python'ın
3.x sürümlerinden biri kurulu olmalı."""

```

Bu karakter dizisinin en başına bir ‘u’ harfi ekleyerek bu karakter dizisini
‘unicode’ olarak tanımlamış olduk. Eğer ‘unicode’ kavramını bilmiyorsanız endişe
etmeyin. İlerde bu kavramdan bolca söz edeceğiz. Biz şimdilik, içinde Türkçe
karakterler geçen karakter dizilerinin Python2 kullanıcıları tarafından düzgün
görüntülenebilmesi için başlarına bir ‘u’ harfi eklenmesi gerektiğini bilelim
yeter.

Eğer siz bir Windows kullanıcısıysanız ve bütün bu işlemlerden sonra bile Türkçe
karakterleri düzgün görüntüleyemiyorsanız, bu durum muhtemelen MS-DOS komut
satırının kullandığı yazı tipinin Türkçe karakterleri gösterememesinden
kaynaklanıyordur. Bu problemi çözmek için MS-DOS komut satırının başlık çubuğuna
sağ tıklayıp ‘özellikler’ seçeneğini seçerek yazı tipini ‘Lucida Console’ olarak
değiştirin. Bu işlemin ardından da komut satırında şu komutu verin:

```python
chcp 1254

```

Böylece Türkçe karakterleri düzgün görüntüleyebilirsiniz.

> **Not**
> MS-DOS’taki Türkçe karakter problemi hakkında daha ayrıntılı bilgi
içinhttps://web.archive.org/web/20150516030259/http://www.istihza.com/py2/python-programlarini-kaydetmek.html#ms-dos-ta-turkce-karakter-problemiadresindeki makalemizi inceleyebilirsiniz.

Not

MS-DOS’taki Türkçe karakter problemi hakkında daha ayrıntılı bilgi
içinhttps://web.archive.org/web/20150516030259/http://www.istihza.com/py2/python-programlarini-kaydetmek.html#ms-dos-ta-turkce-karakter-problemiadresindeki makalemizi inceleyebilirsiniz.

Şimdiye kadar anlattıklarımızdan öğrendiğiniz gibi,sysmodülü içinde sürüm
denetlemeye yarayan iki farklı değişken var. Bunlardan biriversion, öbürü iseversion_info.

Python3’te bu değişkenlerin şu çıktıları verdiğiniz biliyoruz:

version:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

version_info:

```python
sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel='final', serial=0)
```

Gördüğünüz gibi, çıktıların hem yapıları birbirinden farklı, hem de verdikleri
bilgiler arasında bazı farklar da var. Meselaversiondeğişkeni, kullandığımız
Python sürümünün hangi tarih ve saatte, hangi işletim sistemi üzerinde
derlendiği bilgisini de veriyor. Ancak kullanılan Python sürümünün ne olduğunu
tespit etmek konusundaversion_infobiraz daha pratik görünüyor. Bu değişkenin
bizemajor,minorvemicrogibi parametreler aracılığıyla sunduğu sayı
değerli verileri işleçlerle birlikte kullanarak bu sayılar üzerinde aritmetik
işlemler yapıp, kullanılan Python sürümünü kontrol edebiliyoruz.

versiondeğişkeni bize bir karakter dizisi verdiği için, bu değişkenin
değerini kullanarak herhangi bir aritmetik işlem yapamıyoruz. Meselaversion_infodeğişkeniyle yukarıda yaptığımız büyüktür-küçüktür sorgulamasınıversiondeğişkeniyle tabii ki yapamayız.

Yukarıdaki örnekte seriler arası sürüm kontrolünü nasıl yapacağımızı gördük.
Bunun için kullandığımız kod şuydu:

```python
if sys.version_info.major < 3:
 ...

```

Burada kullanılan Python serisinin3.x’ten düşük olduğu durumları sorguladık.
Peki aynı serinin farklı sürümlerini denetlemek istersek ne yapacağız? Mesela
Python’ın3.2sürümünü sorgulamak istersek nasıl bir kod kullanacağız?

Bunun için şöyle bir şey yazabiliriz:

```python
if sys.version_info.major == 3 and sys.version_info.minor == 2:
 ...

```

Gördüğünüz gibi buradaversion_infodeğişkeninin hemmajorhem deminorparametrelerini kullandık. Ayrıca hem ana sürüm, hem de alt sürüm için belli bir
koşul talep ettiğimizden ötürüandadlı Bool işlecinden de yararlandık. Çünkü
koşulun gerçekleşmesi, ana sürümün3vealt sürümün2olmasına bağlı.

Yukarıdaki işlem içinversiondeğişkenini de kullanabilirdik. Dikkatlice
bakın:

```python
if "3.2" in sys.version:
 ...

```

Bildiğiniz gibi,versiondeğişkeni Python’ın3.xsürümlerinde şuna benzer
bir çıktı veriyor:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

İşte biz buradainişlecini kullanarak,versiondeğişkeninin verdiği
karakter dizisi içinde ‘3.2’ diye bir ifade aradık.

Bu konuyu daha iyi anlamak için kendi kendinize bazı denemeler yapmanızı tavsiye
ederim. Ne kadar çok örnek kod yazarsanız, o kadar çok tecrübe kazanırsınız.

## Döngüler (Loops)

Şimdiye kadar öğrendiklerimiz sayesinde Python’la ufak tefek programlar
yazabilecek düzeye geldik. Mesela öğrendiğimiz bilgiler yardımıyla bir önceki
bölümde çok basit bir hesap makinesi yazabilmiştik. Yalnız o hesap makinesinde
farkettiyseniz çok önemli bir eksiklik vardı. Hesap makinemizle hesap yaptıktan
sonra programımız kapanıyor, yeni hesap yapabilmek için programı yeniden
başlatmamız gerekiyordu.

Hesap makinesi programındaki sorun, örneğin, aşağıdaki program için de
geçerlidir:

```python
tuttuğum_sayı = 23

bilbakalım = int(input("Aklımdan bir sayı tuttum. Bil bakalım kaç tuttum? "))

if bilbakalım == tuttuğum_sayı:
 print("Tebrikler! Bildiniz...")

else:
 print("Ne yazık ki tuttuğum sayı bu değildi...")

```

Buradatuttuğum_sayıadlı bir değişken belirledik. Bu değişkenin değeri23.
Kullanıcıdan tuttuğumuz sayıyı tahmin etmesini istiyoruz. Eğer kullanıcının
verdiği cevaptuttuğum_sayıdeğişkeninin değeriyle aynıysa (yani23ise),
ekrana ‘Tebrikler!…’ yazısı dökülecektir. Aksi halde ‘Ne yazık ki…’ cümlesi
ekrana dökülecektir.

Bu program iyi, hoş, ama çok önemli bir eksiği var. Bu programı yalnızca bir kez
kullanabiliyoruz. Yani kullanıcı yalnızca bir kez tahminde bulunabiliyor. Eğer
kullanıcı bir kez daha tahminde bulunmak isterse programı yeniden çalıştırması
gerekecek. Bunun hiç iyi bir yöntem olmadığı ortada. Halbuki yazdığımız bir
program, ilk çalışmanın ardından kapanmasa, biz bu programı tekrar tekrar
çalıştırabilsek, programımız sürekli olarak başa dönse ve program ancak biz
istediğimizde kapansa ne iyi olurdu değil mi? Yani mesela yukarıdaki örnekte
kullanıcı bir sayı tahmin ettikten sonra, eğer bu sayı bizim tuttuğumuz sayıyla
aynı değilse, kullanıcıya tekrar tahmin etme fırsatı verebilsek çok hoş
olurdu…

Yukarıda açıklamaya çalıştığımız süreç, yani bir sürecin tekrar tekrar devam
etmesi Python’da ‘döngü’ (loop) olarak adlandırılır.

İşte bu bölümde, programlarımızın sürekli olarak çalışmasını nasıl
sağlayabileceğimizi, yani programlarımızı bir döngü içine nasıl sokabileceğimizi
öğreneceğiz.

Python’da programlarımızı tekrar tekrar çalıştırabilmek için döngü adı verilen
bazı ifadelerden yararlanacağız.

Python’da iki tane döngü bulunur:whilevefor

Dilerseniz işewhiledöngüsü ile başlayalım.

### while Döngüsü

İngilizce bir kelime olanwhile, Türkçede ‘… iken, … olduğu sürece’ gibi
anlamlara gelir. Python’dawhilebir döngüdür. Bir önceki bölümde
söylediğimiz gibi, döngüler sayesinde programlarımızın sürekli olarak
çalışmasını sağlayabiliriz.

Bu bölümde Python’dawhiledöngüsünün ne olduğunu ve ne işe yaradığını
anlamaya çalışacağız. Önceliklewhiledöngüsünün temellerini kavrayarak işe
başlayalım.

Basit birwhiledöngüsü kabaca şuna benzer:

```python
a = 1

while a == 1:

```

Buradaaadlı bir değişken oluşturduk. Bu değişkenin değeri1. Bir sonraki
satırda isewhilea==1:gibi bir ifade yazdık. En başta da söylediğimiz
gibiwhilekelimesi, ‘… iken, olduğu sürece’ gibi anlamlar taşıyor. Python
programlama dilindeki anlamı da buna oldukça yakındır. Buradawhilea==1ifadesi programımıza şöyle bir anlam katıyor:

adeğişkeninin değeri1olduğu sürece…

Gördüğünüz gibi cümlemiz henüz eksik. Yani belli ki bunun bir de devamı olacak.
Ayrıcawhileifadesinin sonundaki:işaretinden anladığımız gibi, bundan
sonra gelecek satır girintili yazılacak. Devam edelim:

```python
a = 1

while a == 1:
 print("bilgisayar çıldırdı!")

```

Burada Python’a şu emri vermiş olduk:

adeğişkeninin değeri1olduğu sürece, ekrana ‘bilgisayar çıldırdı!’
yazısını dök!

Bu programı çalıştırdığımızda Python verdiğimiz emre sadakatle uyacak veadeğişkeninin değeri1olduğu müddetçe de bilgisayarımızın ekranına ‘bilgisayar
çıldırdı!’ yazısını dökecektir. Programımızın içindeadeğişkeninin değeri1olduğu ve bu değişkenin değerini değiştirecek herhangi bir şey bulunmadığı için
Python hiç sıkılmadan ekrana ‘bilgisayar çıldırdı!’ yazısını basmaya devam
edecektir. Eğer siz durdurmazsanız bu durum sonsuza kadar devam edebilir. Bu
çılgınlığa bir son vermek için klavyenizdeCtrl+CveyaCtrl+Ztuşlarına
basarak programı durmaya zorlayabilirsiniz.

Burada programımızı sonsuz bir döngüye sokmuş olduk (infinite loop). Esasında
sonsuz döngüler genellikle bir program hatasına işaret eder. Yani çoğu durumda
programcının arzu ettiği şey bu değildir. O yüzden doğru yaklaşım, döngüye
soktuğumuz programlarımızı durduracak bir ölçüt belirlemektir. Yani öyle bir kod
yazmalıyız ki,adeğişkeninin1olan değeri bir noktadan sonra artık1olmasın ve böylece o noktaya ulaşıldığında programımız dursun. KullanıcınınCtrl+Ctuşlarına basarak programı durdurmak zorunda kalması pek hoş olmuyor.
Gelin isterseniz bu soyut ifadeleri biraz somutlaştıralım.

Öncelikle şu satırı yazarak işe başlıyoruz:

```python
a = 1

```

Burada normal bir şekildeadeğişkenine1değerini atadık. Şimdi devam
ediyoruz:

```python
a = 1

while a < 10:

```

whileile verdiğimiz ilk örnektewhilea==1gibi bir ifade
kullanmıştık. Bu ifade;

a’nın değeri1olduğu müddetçe…

gibi bir anlama geliyordu.

whilea<10ifadesi ise;

a’nın değeri10’dan küçük olduğu müddetçe…

anlamına gelir. İşte burada programımızın sonsuz döngüye girmesini engelleyecek
bir ölçüt koymuş olduk. Buna göre,adeğişkeninin şimdiki değeri1’dir. Biz,a’nın değeri10’dan küçük olduğu müddetçe bir işlem yapacağız. Devam
edelim:

```python
a = 1

while a < 10:
 print("bilgisayar yine çıldırdı!")

```

Ne oldu? İstediğimizi elde edemedik, değil mi? Programımız yine sonsuz döngüye
girdi. Bu sonsuz döngüyü kırmak içinCtrl+C(veyaCtrl+Z)’ye basmamız
gerekecek yine…

Sizce buradaki hata nereden kaynaklandı? Yani neyi eksik yaptık da programımız
sonsuz döngüye girmekten kurtulamadı? Aslında bunun cevabı çok basit. Biz
yukarıdaki kodları yazarak Python’a şu emri vermiş olduk:

a’nın değeri10’dan küçük olduğu müddetçe ekrana ‘bilgisayar yine
çıldırdı!’ yazısını bas!

adeğişkeninin değeri1. Yani10’dan küçük. Dolayısıyla Python’ın ekrana o
çıktıyı basmasını engelleyecek herhangi bir şey yok…

Şimdi bu problemi nasıl aşacağımızı görelim:

```python
a = 1

while a < 10:
 a += 1
 print("bilgisayar yine çıldırdı!")

```

Buradaa+=1satırını ekledik kodlarımızın arasına.+=işlecini
anlatırken söylediğimiz gibi, bu satır,adeğişkeninin değerine her defasında1ekliyor ve elde edilen sonucu tekraradeğişkenine atıyor. En sonundaa’nın değeri10’a ulaşınca da, Python ekrana ‘bilgisayar yine çıldırdı!’
cümlesini yazmayı bırakıyor. Çünküwhiledöngüsü içinde belirttiğimiz ölçüte
göre, programımızın devam edebilmesi içinadeğişkeninin değerinin10’dan
küçük olması gerekiyor.a’nın değeri10’a ulaştığı anda bu ölçüt
bozulacaktır. Gelin isterseniz bu kodları Python’ın nasıl algıladığına bir
bakalım:
1. Python önceliklea=1satırını görüyor vea’nın değerini1yapıyor.
1. Daha sonraa’nın değeri10’dan küçük olduğu müddetçe…
(whilea<10) satırını görüyor.
1. Ardındana’nın değerini,1artırıyor (a+=1) vea’nın değeri2oluyor.
1. a’nın değeri (yani2)10’dan küçük olduğu için Python ekrana ilgili
çıktıyı veriyor.
1. İlk döngüyü bitiren Python başa dönüyor vea’nın değerinin2olduğunu
görüyor.
1. a’nın değerini yine1artırıyor vea’yı3yapıyor.
1. a’nın değeri hâlâ10’dan küçük olduğu için ekrana yine ilgili çıktıyı
veriyor.
1. İkinci döngüyü de bitiren Python yine başa dönüyor vea’nın
değerinin3olduğunu görüyor.
1. Yukarıdaki adımları tekrar eden Python,a’nın değeri9olana kadar
ilerlemeye devam ediyor.
1. a’nın değeri9’a ulaştığında Pythona’nın değerini bir kez daha
artırınca bu değer10’a ulaşıyor.
1. Pythona’nın değerinin artık10’dan küçük olmadığını görüyor ve
programdan çıkıyor.

Python önceliklea=1satırını görüyor vea’nın değerini1yapıyor.

Daha sonraa’nın değeri10’dan küçük olduğu müddetçe…
(whilea<10) satırını görüyor.

Ardındana’nın değerini,1artırıyor (a+=1) vea’nın değeri2oluyor.

a’nın değeri (yani2)10’dan küçük olduğu için Python ekrana ilgili
çıktıyı veriyor.

İlk döngüyü bitiren Python başa dönüyor vea’nın değerinin2olduğunu
görüyor.

a’nın değerini yine1artırıyor vea’yı3yapıyor.

a’nın değeri hâlâ10’dan küçük olduğu için ekrana yine ilgili çıktıyı
veriyor.

İkinci döngüyü de bitiren Python yine başa dönüyor vea’nın
değerinin3olduğunu görüyor.

Yukarıdaki adımları tekrar eden Python,a’nın değeri9olana kadar
ilerlemeye devam ediyor.

a’nın değeri9’a ulaştığında Pythona’nın değerini bir kez daha
artırınca bu değer10’a ulaşıyor.

Pythona’nın değerinin artık10’dan küçük olmadığını görüyor ve
programdan çıkıyor.

Yukarıdaki kodları şöyle yazarsak belki durum daha anlaşılır olabilir:

```python
a = 1

while a < 10:
 a += 1
 print(a)

```

Burada Python’un arkada ne işler çevirdiğini daha net görebiliyoruz. Kodlarımız
içine eklediğimizwhiledöngüsü sayesinde Python her defasındaadeğişkeninin değerini kontrol ediyor ve bu değer10’dan küçük olduğu müddetçeadeğişkeninin değerini1artırıp, yeni değeri ekrana basıyor. Bu değişkenin
değeri10’a ulaştığında ise, bu değerin artık10’dan küçük olmadığını
anlayıp bütün işlemleri durduruyor.

Gelin isterseniz buwhiledöngüsünü daha önce yazdığımız hesap makinemize
uygulayalım:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

anahtar = 1

while anahtar == 1:
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 anahtar = 0

 elif soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))
 print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

 elif soru == "2":
 sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: "))
 sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: "))
 print(sayı3, "-", sayı4, "=", sayı3 - sayı4)

 elif soru == "3":
 sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: "))
 sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: "))
 print(sayı5, "x", sayı6, "=", sayı5 * sayı6)

 elif soru == "4":
 sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: "))
 sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: "))
 print(sayı7, "/", sayı8, "=", sayı7 / sayı8)

 elif soru == "5":
 sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: "))
 print(sayı9, "sayısının karesi =", sayı9 ** 2)

 elif soru == "6":
 sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: "))
 print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5)

 else:
 print("Yanlış giriş.")
 print("Aşağıdaki seçeneklerden birini giriniz:", giriş)

```

Burada ilave olarak şu satırları görüyorsunuz:

```python
anahtar = 1

while anahtar == 1:
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 anahtar = 0

```

Bu kodlarda yaptığımız şey aslında çok basit. Öncelikle değeri1olananahtaradlı bir değişken tanımladık. Bir alt satırda ise, programımızın
sürekli olarak çalışmasını sağlayacak olanwhiledöngümüzü yazıyoruz.
Programımız,anahtardeğişkeninin değeri1olduğu müddetçe çalışmaya devam
edecek. Daha önce de dediğimiz gibi, eğer buanahtardeğişkeninin değerini
programın bir noktasında değiştirmezsek programımız sonsuza kadar çalışmaya
devam edecektir. Çünkü biz programımızıanahtardeğişkeninin değeri1olduğu
sürece çalışmaya ayarladık. İşte programımızın bu tür bir sonsuz döngüye
girmesini önlemek için birifbloğu oluşturuyoruz. Buna göre, eğer kullanıcı
klavyedeqtuşuna basarsa programımız önceçıkılıyor…çıktısı verecek,
ardından daanahtardeğişkeninin1olan değerini0yapacaktır. Böylece
artıkanahtar’ın değeri1olmayacağı için programımız çalışmaya son
verecektir.

Buradaki mantığın ne kadar basit olduğunu görmenizi isterim. Önce bir değişken
tanımlıyoruz, ardından bu değişkenin değeri aynı kaldığı müddetçe programımızı
çalışmaya ayarlıyoruz. Bu döngüyü kırmak için de başta tanımladığımız o
değişkene başka bir değer atıyoruz. Buradaanahtardeğişkenine atadığımız1ve0değerleri tamamen tesadüfidir. Yani siz bu değerleri istediğiniz gibi
değiştirebilirsiniz. Mesela yukarıdaki kodları şöyle de yazabilirsiniz:

```python
anahtar = "hoyda bre!"

#anahtar'ın değeri 'hoyda bre!' olduğu müddetçe aşağıdaki bloğu
#çalıştırmaya devam et.
while anahtar == "hoyda bre!":
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 anahtar = "dur yolcu!"
 #anahtar'ın değeri artık 'hoyda bre!' değil, 'dur yolcu'
 #olduğu için döngüden çık ve böylece programı sona erdirmiş ol.

```

Gördüğünüz gibi, amaç herhangi bir değişkene herhangi bir değer atamak ve o
değer aynı kaldığı müddetçe programın çalışmaya devam etmesini sağlamak.
Kurduğumuz bu döngüyü kırmak için de o değişkene herhangi başka bir değer
atamak…

Yukarıda verdiğimiz son örnekte önceanahtaradlı bir değişken atayıp,whiledöngüsünün işleyişini bu değişkenin değerine göre yapılandırdık. Ama
aslında yukarıdaki kodları çok daha basit bir şekilde de yazabiliriz. Dikkatlice
bakın:

```python
while True:
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 break

```

Bu yapıyı hesap makinemize uygulayalım:

```python
giriş = """
(1) topla
(2) çıkar
(3) çarp
(4) böl
(5) karesini hesapla
(6) karekök hesapla
"""

print(giriş)

while True:
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 break

 elif soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))
 print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

 elif soru == "2":
 sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: "))
 sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: "))
 print(sayı3, "-", sayı4, "=", sayı3 - sayı4)

 elif soru == "3":
 sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: "))
 sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: "))
 print(sayı5, "x", sayı6, "=", sayı5 * sayı6)

 elif soru == "4":
 sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: "))
 sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: "))
 print(sayı7, "/", sayı8, "=", sayı7 / sayı8)

 elif soru == "5":
 sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: "))
 print(sayı9, "sayısının karesi =", sayı9 ** 2)

 elif soru == "6":
 sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: "))
 print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5)

 else:
 print("Yanlış giriş.")
 print("Aşağıdaki seçeneklerden birini giriniz:", giriş)

```

Bu yapı sayesindeanahtargibi bir değişken atama zorunluluğundan kurtulmuş
olduk. Yukarıdaki kodların nasıl çalıştığını açıklayalım:

while Trueifadesi şöyle bir anlama gelir:

Trueolduğu müddetçe…

Peki neTrueolduğu müddetçe? Burada neyinTrueolması gerektiğini
belirtmediğimiz için, aslında bu kod parçası şu anlama geliyor:

Aksi belirtilmediği sürece çalışmaya devam et!

Eğer yukarıdaki açıklamayı biraz bulanık bulduysanız şu örneği
inceleyebilirsiniz:

```python
while True:
 print("Bilgisayar çıldırdı!")

```

Bu kodları çalıştırdığınızda ekrana sürekli olarakBilgisayar çıldırdı!çıktısı verilecektir. Bu döngüden çıkabilmek içinCtrl+Ctuşlarına basmanız
gerekiyor. Yukarıdaki kodların sonsuz döngüye girmesinin sorumlusuwhile Truesatırıdır. Çünkü burada biz Python’a;

Aksi belirtilmediği sürece çalışmaya devam et!

emri veriyoruz. Python da bu emrimizi sadakatle yerine getiriyor. Böyle bir
durumda sonsuz döngüyü engellemek için programımızın bir yerinde Python’a bu
döngüden çıkmasını sağlayacak bir emir vermemiz gerekiyor. Biz hesap makinesi
programımızda bu döngüyü şu şekilde kırdık:

```python
if soru == "q":
 print("çıkılıyor...")
 break

```

Dikkat ederseniz buradabreakadlı yeni bir araç görüyoruz. Bu aracın tam
olarak ne işe yaradığını ilerleyen sayfalarda inceleyeceğiz. Şimdilik yalnızca
şunu bilelim:breakkelimesi İngilizce’de ‘kırmak, koparmak, bozmak’ gibi
anlamlara gelir. Bu aracın yukarıdaki görevi döngüyü ‘kırmak’tır. Dolayısıyla
kullanıcı klavyedeqtuşuna bastığında,whileTrueifadesi ile çalışmaya
başlayan döngü kırılacak ve programımız sona erecektir.

Bu yapıyı daha iyi anlayabilmek için şöyle basit bir örnek daha verelim:

```python
#Aksi belirtilmediği sürece kullanıcıya
#aşağıdaki soruyu sormaya devam et!
while True:
 soru = input("Nasılsınız, iyi misiniz?")

 #Eğer kullanıcı 'q' tuşuna basarsa...
 if soru == "q":
 break #döngüyü kır ve programdan çık.

```

Görüyorsunuz, aslında mantık gayet basit:

Bir döngü oluştur ve bu döngüden çıkmak istediğinde, programın bir yerinde
bu döngüyü sona erdirecek bir koşul meydan getir.

Bu mantığı yukarıdaki örneğe şu şekilde uyguladık:

while True:ifadesi yardımıyla bir döngü oluştur ve kullanıcı bu döngüden
çıkmak istediğinde (yaniqtuşuna bastığında), döngüyü kır ve programı
sona erdir.

Gelin isterseniz bu konuyu daha net kavramak için bir örnek daha verelim:

```python
tekrar = 1

while tekrar <= 3:
 tekrar += 1
 input("Nasılsınız, iyi misiniz?")

```

Burada programımız kullanıcıya üç kez ‘Nasılsınız, iyi misiniz?’ sorusunu
soracak ve ardından kapanacaktır. Bu kodlardawhiledöngüsünü nasıl
kullandığımıza dikkat edin. Aslında programın mantığı çok basit:
1. Öncelikle değeri1olantekraradlı bir değişken tanımlıyoruz.
1. Bu değişkenin değeri3’e eşit veya3’ten küçük olduğu müddetçe (whiletekrar<=3) değişkenin değerine1ekliyoruz (tekrar+=1).
1. Başka bir deyişlebool(tekrar<=3)ifadesiTrueolduğu müddetçe
değişkenin değerine1ekliyoruz.
1. tekrardeğişkenine her1ekleyişimizde kullanıcıya ‘Nasılsınız, iyi
misiniz?’ sorusunu soruyoruz (input("Nasılsınız,iyimisiniz?")).
1. tekrardeğişkeninin değeri3’ü aştığındabool(tekrar<=3)ifadesi
artıkFalsedeğeri verdiği için programımız sona eriyor.

Öncelikle değeri1olantekraradlı bir değişken tanımlıyoruz.

Bu değişkenin değeri3’e eşit veya3’ten küçük olduğu müddetçe (whiletekrar<=3) değişkenin değerine1ekliyoruz (tekrar+=1).

Başka bir deyişlebool(tekrar<=3)ifadesiTrueolduğu müddetçe
değişkenin değerine1ekliyoruz.

tekrardeğişkenine her1ekleyişimizde kullanıcıya ‘Nasılsınız, iyi
misiniz?’ sorusunu soruyoruz (input("Nasılsınız,iyimisiniz?")).

tekrardeğişkeninin değeri3’ü aştığındabool(tekrar<=3)ifadesi
artıkFalsedeğeri verdiği için programımız sona eriyor.

Yukarıdaki uygulamada Python’ın alttan alta neler çevirdiğini daha iyi görmek
için bu uygulamayı şöyle yazmayı deneyin:

```python
tekrar = 1

while tekrar <= 3:
 print("tekrar: ", tekrar)
 tekrar += 1
 input("Nasılsınız, iyi misiniz?")
 print("bool değeri: ", bool(tekrar <= 3))

```

Daha önce de dediğimiz gibi, bir Python programının nasıl çalıştığını anlamanın
en iyi yolu, program içinde uygun yerlereprint()fonksiyonları
yerleştirerek arka planda hangi kodların hangi çıktıları verdiğini izlemektir.
İşte yukarıda da bu yöntemi kullandık. Yanitekrardeğişkenininin değerini vebool(tekrar<=3)ifadesinin çıktısını ekrana yazdırarak arka tarafta neler
olup bittiğini canlı canlı görme imkanına kavuştuk.

Yukarıdaki programı çalıştırdığımızda şuna benzer çıktılar görüyoruz:

```python
tekrar: 1
Nasılsınız, iyi misiniz? evet
bool değeri: True
tekrar: 2
Nasılsınız, iyi misiniz? evet
bool değeri: True
tekrar: 3
Nasılsınız, iyi misiniz? evet
bool değeri: False

```

Gördüğünüz gibi,tekrardeğişkeninin değeri her döngüde1artıyor.tekrar<=3ifadesinin bool değeri,tekraradlı değişkenin değeri3’ü aşana kadar
hepTrueolacaktır. Bu değişkenin değeri3’ü aştığı andatekrar<=3ifadesinin bool değeriFalse’a dönüyor ve böylecewhiledöngüsü sona
eriyor.

Peki size şöyle bir soru sorsam: Acabawhiledöngüsünü kullanarak1’den100’e kadar olan aralıktaki çift sayıları nasıl bulursunuz?

Çok basit:

```python
a = 0

while a < 100:
 a += 1
 if a % 2 == 0:
 print(a)

```

Gördüğünüz gibi,whiledöngüsünün içine bir adetifbloğu yerleştirdik.

Yukarıdaki kodları şu şekilde Türkçeye çevirebiliriz:

adeğişkeninin değeri100’den küçük olduğu müddetçeadeğişkeninin
değerini1artır. Bu değişkenin değerini her artırışında yeni değerin2’ye tam bölünüp bölünmediğini kontrol et. Eğeramodülüs2değeri0ise (ifa%2==0), yania’nın değeri bir çift sayı ise, bu değeri
ekrana yazdır.

Gördüğünüz gibi,whiledöngüsü son derece kullanışlı bir araçtır. Üstelik
kullanımı da son derece kolaydır. Bu döngüyle bol bol pratik yaparak bu döngüyü
rahatça kullanabilecek duruma gelebilirsiniz.

En başta da söylediğimiz gibi, Python’dawhiledışında bir defordöngüsü vardır. En azwhilekadar önemli bir döngü olanfordöngüsünün
nasıl kullanıldığını anlamaya çalışalım şimdi de.

### for Döngüsü

Etrafta yazılmış Python programlarının kaynak kodlarını incelediğinizde, içindefordöngüsü geçmeyen bir program kolay kolay bulamazsınız. Belkiwhiledöngüsünün kullanılmadığı programlar vardır. Ancakfordöngüsü Python’da o
kadar yaygındır ve o kadar geniş bir kullanım alanına sahiptir ki, hemen hemen
bütün Python programları bufordöngüsünden en az bir kez yararlanır.

Peki nedir bufordöngüsü denen şey?

forda tıpkıwhilegibi bir döngüdür. Yani tıpkıwhiledöngüsünde
olduğu gibi, programlarımızın birden fazla sayıda çalışmasını sağlar. Ancakfordöngüsüwhiledöngüsüne göre biraz daha yeteneklidir.whiledöngüsü ile yapamayacağınız veya yaparken çok zorlanacağınız şeylerifordöngüsü yardımıyla çok kolay bir şekilde halledebilirsiniz.

Yalnız, söylediğimiz bu cümleden,fordöngüsününwhiledöngüsüne bir
alternatif olduğu sonucunu çıkarmayın. Evet,whileile yapabildiğiniz bir
işlemiforile de yapabilirsiniz çoğu zaman, ama bu döngülerin, belli
vakalar için tek seçenek olduğu durumlar da vardır. Zira bu iki döngünün çalışma
mantığı birbirinden farklıdır.

Şimdi gelelimfordöngüsünün nasıl kullanılacağına…

Dikkatlice bakın:

```python
tr_harfler = "şçöğüİı"

for harf in tr_harfler:
 print(harf)

```

Burada öncelikletr_harfleradlı bir değişken tanımladık. Bu değişken Türkçeye
özgü harfleri tutuyor. Daha sonra birfordöngüsü kurarak,tr_harfleradlı
değişkenin her bir öğesini tek tek ekrana yazdırdık.

Peki bufordöngüsünü nasıl kurduk?

fordöngülerinin söz dizimi şöyledir:

```python
for değişken_adı in değişken:
 yapılacak_işlem

```

Bu söz dizimini Türkçe olarak şöyle ifade edebiliriz:

```python
değişken içindeki her bir öğeyi değişken_adı olarak adlandır:
 ve bu öğelerle bir işlem yap.

```

Bu soyut yapıları kendi örneğimize uygulayarak durumu daha net anlamaya
çalışalım:

```python
tr_harfler adlı değişken içindeki her bir öğeyi harf olarak adlandır:
 ve harf olarak adlandırılan bu öğeleri ekrana yazdır.

```

Yukarıdaki örnekte birfordöngüsü yardımıylatr_harfleradlı değişken
içindeki her bir öğeyi ekrana yazdırdık. Esasındafordöngüsünün
yeteneklerini düşündüğümüzde bu örnek pek heyecan verici değil. Zira aynı işi
aslındaprint()fonksiyonu ile de yapabilirdik:

```python
tr_harfler = "şçöğüİı"
print(*tr_harfler, sep="\n")

```

Aslında bu işlemiwhileile de yapmak mümkün (Bu kodlardaki, henüz
öğrenmediğimiz kısmı şimdilik görmezden gelin):

```python
tr_harfler = "şçöğüİı"
a = 0

while a < len(tr_harfler):
 print(tr_harfler[a], sep="\n")
 a += 1

```

whiledöngüsü kullanıldığında işi uzattığımızı görüyorsunuz. Dediğimiz gibi,fordöngüsüwhiledöngüsüne göre biraz daha yeteneklidir vewhileile yapması daha zor (veya uzun) olan işlemlerifordöngüsü ile çok daha
kolay bir şekilde yapabiliriz. Ayrıcafordöngüsü ilewhiledöngüsünün
çalışma mantıkları birbirinden farklıdır.fordöngüsü, üzerinde döngü
kurulabilecek veri tiplerinin her bir öğesinin üzerinden tek tek geçer ve bu
öğelerin her biri üzerinde bir işlem yapar.whiledöngüsü ise herhangi bir
ifadenin bool değerini kontrol eder ve bu değerin bool değeriFalseolana
kadar, belirlenen işlemi yapmayı sürdürür.

Bu arada, biraz önce ‘üzerinde döngü kurulabilecek veri tipleri’ diye bir
kavramdan söz ettik. Örneğin karakter dizileri, üzerinde döngü kurulabilecek bir
veri tipidir. Ama sayılar öyle değildir. Yani sayılar üzerinde döngü kuramayız.
Mesela:

```python
>>> sayılar = 123456789
>>> for sayı in sayılar:
... print(sayı)
...
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'int' object is not iterable

```

Buradaki hata mesajından da göreceğiniz gibiint(tam sayı) türündeki nesneler
üzerinde döngü kuramıyoruz. Hata mesajında görünennot iterable(üzerinde
döngü kurulamaz) ifadesiyle kastedilen de budur.

Gelin istersenizfordöngüsü ile bir örnek daha vererek durumu iyice
anlamaya çalışalım:

```python
sayılar = "123456789"

for sayı in sayılar:
 print(int(sayı) * 2)

```

Buradasayılaradlı değişkenin her bir öğesinisayıolarak adlandırdıktan
sonra,int()fonksiyonu yardımıyla bu öğeleri tek tek sayıya çevirdik ve
her bir öğeyi2ile çarptık.

fordöngüsünün mantığını az çok anlamış olmalısınız. Bu döngü bir değişken
içindeki her bir öğeyi tek tek ele alıp, iki nokta üst üste işaretinden sonra
yazdığımız kod bloğunu bu öğelere tek tek uyguluyor.

forkelimesi İngilizcede ‘için’ anlamına gelir. Döngünün yapısı içinde geçeninifadesini de tanıyorsunuz. Biz bu ifadeyi ‘Aitlik İşleçleri’ konusunu
işlerken de görmüştük. Hatırlarsanızinişleci bir öğenin bir veri tipi içinde
bulunup bulunmadığını sorguluyordu. Mesela:

```python
>>> a = "istihza.com"
>>> "h" in a

True

```

“h”öğesi“istihza.com”adlı karakter dizisi içinde geçtiği için"h"inakoduTrueçıktısı veriyor. Bir de şuna bakın:

```python
>>> "b" in a

False

```

“b”öğesi“istihza.com”karakter dizisi içinde bulunmuyor. Dolayısıyla"b"inasorgulamasıFalseçıktısı veriyor.

inkelimesi İngilizcede ‘içinde’ anlamına geliyor. Dolayısıylaforfalancainfilanca:yazdığımızda aslında şöyle bir şey demiş oluyoruz:

filancaiçindefalancaadını verdiğimiz her bir öğe için…

Yani şu kod:

```python
for s in "istihza":
 print(s)

```

Şu anlama geliyor:

söğesini ekrana basma işlemi gerçekleştir!

Ya da şu kod:

```python
sayılar = "123456789"

for i in sayılar:
 if int(i) > 3:
 print(i)

```

Şu anlama geliyor:

iöğesini ekrana basma işlemi gerçekleştir!

Yukarıdaki temsili kodların Türkçesi bozuk olsa dafordöngüsünün çalışma
mantığını anlamaya yardımcı olacağını zannediyorum. Ama yine de, eğer bu
döngünün mantığını henüz kavrayamadıysanız hiç endişe etmeyin. Zira bu döngüyü
oldukça sık bir biçimde kullanacağımız için, siz istemeseniz de bu döngü
kafanızda yer etmiş olacak.

Bufordöngüsünü biraz daha iyi anlayabilmek için son bir örnek yapalım:

```python
tr_harfler = "şçöğüİı"

parola = input("Parolanız: ")

for karakter in parola:
 if karakter in tr_harfler:
 print("parolada Türkçe karakter kullanılamaz")

```

Bu program, kullanıcıya bir parola soruyor. Eğer kullanıcının girdiği parola
içinde Türkçe karakterlerden herhangi biri varsa kullanıcıyı Türkçe karakter
kullanmaması konusunda uyarıyor. Buradakifordöngüsünü nasıl kurduğumuzu
görüyorsunuz. Aslında burada şu Türkçe cümleyi Pythonca’ya çevirmiş olduk:

‘parolada Türkçe karakter kullanılamaz’ uyarısını göster!

Burada kullandığımızfordöngüsü sayesinde kullanıcının girdiğiparolaadlı değişken içindeki bütün karakterlere tek tek bakıp, eğer bakılan karaktertr_harfleradlı değişken içinde geçiyorsa kullanıcıyı uyarıyoruz.

Aslındafordöngüsüyle ilgili söyleyeceklerimiz bu kadar değil. Ama henüz bu
döngüyle kullanılan önemli araçları tanımıyoruz. Gerçi zaten bu döngüyü bundan
sonra sık sık kullandığımızı göreceksiniz.

Gelin isterseniz yeni bir konuya geçmeden önce döngülerle ilgili ufak bir örnek
verelim:

Örneğin kullanıcıya bir parola belirletirken, belirlenecek parolanın8karakterden uzun,3karakterden kısa olmamasını sağlayalım:

```python
while True:
 parola = input("Bir parola belirleyin: ")

 if not parola:
 print("parola bölümü boş geçilemez!")

 elif len(parola) > 8 or len(parola) < 3:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

 else:
 print("Yeni parolanız", parola)
 break

```

Burada öncelikle, programınızın sürekli olarak çalışmasını sağlamak için birwhiledöngüsü oluşturduk. Buna göre, aksi belirtilmedikçe (whileTrue)
programımız çalışmaya devam edecek.

whiledöngüsünü kurduktan sonra kullanıcıya bir parola soruyoruz (parola=input("Birparolabelirleyin:"))

Eğer kullanıcı herhangi bir parola belirlemeden doğrudanEntertuşuna basarsa,
yaniparoladeğişkeninin bool değeriFalseolursa (ifnotparola),
kullanıcıya ‘parola bölümü boş geçilemez!’ uyarısı veriyoruz.

Eğer kullanıcı tarafından belirlenen parolanın uzunluğu8karakterden fazlaysa
ya da3karakterden kısaysa, ‘parola 8 karakterden uzun 3 karakterden kısa
olmamalı’ uyarısı veriyoruz.

Yukarıdaki koşullar harici durumlar için ise (else), belirlenen yeni
parolayı kullanıcıya gösterip döngüden çıkıyoruz (break).

Bu arada, hatırlarsanızeval()fonksiyonunu anlatırken şöyle bir örnek
vermiştik:

```python
print("""
Basit bir hesap makinesi uygulaması.

İşleçler:

 + toplama
 - çıkarma
 * çarpma
 / bölme

Yapmak istediğiniz işlemi yazıp ENTER
tuşuna basın. (Örneğin 23 ve 46 sayılarını
çarpmak için 23 * 46 yazdıktan sonra
ENTER tuşuna basın.)
""")

veri = input("İşleminiz: ")
hesap = eval(veri)

print(hesap)

```

Bu programdaki eksiklikleri ve riskleri biliyorsunuz. Böyle bir program
yazdığınızda,eval()fonksiyonunu kontrolsüz bir şekilde kullandığınız için
önemli bir güvenlik açığına sebep olmuş oluyorsunuz. Gelin isterseniz bu derste
öğrendiğimiz bilgileri de kullanarak yukarıdakieval()fonksiyonu için basit
bir kontrol mekanizması kuralım:

```python
izinli_karakterler = "0123456789+-/*= "

print("""
Basit bir hesap makinesi uygulaması.

İşleçler:

 + toplama
 - çıkarma
 * çarpma
 / bölme

Yapmak istediğiniz işlemi yazıp ENTER
tuşuna basın. (Örneğin 23 ve 46 sayılarını
çarpmak için 23 * 46 yazdıktan sonra
ENTER tuşuna basın.)
""")

while True:
 veri = input("İşleminiz: ")
 if veri == "q":
 print("çıkılıyor...")
 break

 for s in veri:
 if s not in izinli_karakterler:
 print("Neyin peşindesin?!")
 quit()

 hesap = eval(veri)

 print(hesap)

```

Burada öncelikle programımızı birwhiledöngüsü içine aldık. Böylece
programımızın ne zaman sona ereceğini kendimiz belirleyebileceğiz. Buna göre
eğer kullanıcı klavyede ‘q’ tuşuna basarsawhiledöngüsü sona erecek.

Bu programda bizi özellikle ilgilendiren kısım şu:

```python
izinli_karakterler = "0123456789+-/*= "

for s in veri:
 if s not in izinli_karakterler:
 print("Neyin peşindesin?!")
 quit()

hesap = eval(veri)

```

Gördüğünüz gibi, ilk olarakizinli_karakterleradlı bir değişken tanımladık.
Program içinde kullanılmasına izin verdiğimiz karakterleri bu değişken içine
yazıyoruz. Buna göre kullanıcı yalnızca0,1,2,3,4,5,6,7,8ve9sayılarını,+,-,/,*ve=işleçlerini, ayrıca boşluk
karakterini (’ ‘) kullanabilecek.

Kullanıcının girdiği veri üzerinde birfordöngüsü kurarak, veri içindeki
her bir karakterinizinli_karakterlerdeğişkeni içinde yer alıp almadığını
denetliyoruz. İzin verilen karakterler dışında herhangi bir karakterin girilmesiNeyin peşindesin?!çıktısının verilip programdan tamamen çıkılmasına
(quit()) yol açacaktır.

Eğer kullanıcı izinli karakterleri kullanarak bir işlem gerçekleştirmişsehesap=eval(veri)kodu aracılığıyla, kullanıcının yaptığı işlemieval()fonksiyonuna gönderiyoruz.

Böyleceeval()fonksiyonunu daha güvenli bir hale getirebilmek için basit
bir kontrol mekanizmasının nasıl kurulabileceğini görmüş olduk. Kurduğumuz
kontrol mekanizmasının esası, kullanıcının girebileceği veri türlerini
sınırlamaya dayanıyor. Böylece kullanıcı mesela şöyle tehlikeli bir komut
giremiyor:

```python
__import__("os").system("dir")

```

Çünkü bu komutu yazabilmesi için gereken karakterlerizinli_karakterlerdeğişkeni içinde tanımlı değil. Kullanıcı yalnızca basit bir hesap makinesinde
kullanılabilecek olan sayıları ve işleçleri girebiliyor.

### İlgili Araçlar

Elbette döngüler tek başlarına bir şey ifade etmezler. Döngülerle işe yarar
kodlar yazabilmemiz için bazı araçlara ihtiyacımız var. İşte bu bölümde
döngüleri daha verimli kullanmamızı sağlayacak bazı fonksiyon ve deyimlerden söz
edeceğiz. İlk olarakrange()adlı bir fonksiyondan bahsedelim.

#### range Fonksiyonu

rangekelimesi İngilizcede ‘aralık’ anlamına gelir. Biz Python’darange()fonksiyonunu belli bir aralıkta bulunan sayıları göstermek için kullanıyoruz.
Örneğin:

```python
>>> for i in range(0, 10):
... print(i)
...
0
1
2
3
4
5
6
7
8
9

```

Gördüğünüz gibi,range(0,10)kodu sayesinde vefordöngüsünü de
kullanarak,0ile10(10hariç) aralığındaki sayıları ekrana yazdırdık.

Yukarıdaki koddarange()fonksiyonuna0ve10olmak üzere iki adet
parametre verdiğimizi görüyorsunuz. Burada0sayısı, aralıktaki ilk sayıyı,10sayısı ise aralıktaki son sayıyı gösteriyor. Yanirange()fonksiyonunun
formülü şöyledir:

```python
range(ilk_sayı, son_sayı)

```

Bu arada,range(ilk_sayı,son_sayı)kodunun verdiği çıktıya ilk_sayının
dahil olduğuna, ama son_sayının dahil olmadığına dikkat edin.

Eğerrange()fonksiyonunun ilk parametresi0olacaksa, bu parametreyi
belirtmesek de olur. Yani mesela0’dan10’a kadar olan sayıları
listeleyeceksekrange()fonksiyonunu şöyle yazmamız yeterli olacaktır:

```python
>>> for i in range(10):
... print(i)

```

range()fonksiyonununilk_sayıparametresi verilmediğinde Python ilk
parametreyi0olarak alır. Yanirange(10)gibi bir kodu Pythonrange(0,10)olarak algılar. Elbette, eğer aralıktaki ilk sayı0’dan farklı olacaksa
bu sayıyı açık açık belirtmek gerekir:

```python
>>> for i in range(3, 20):
... print(i)

```

Burada3’ten itibaren20’ye kadar olan sayılar ekrana dökülecektir.

Hatırlarsanız, biraz önce, kullanıcının3karakterden kısa,8karakterden
uzun parola belirlemesini engelleyen bir uygulama yazmıştık. O uygulamayırange()fonksiyonunu kullanarak da yazabiliriz:

```python
while True:
 parola = input("parola belirleyin: ")

 if not parola:
 print("parola bölümü boş geçilemez!")

 elif len(parola) in range(3, 9): #eğer parolanın uzunluğu 3 ile 8 karakter
 #aralığında ise...
 print("Yeni parolanız", parola)
 break

 else:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

```

Bu fonksiyonu kullanarak bir döngünün kaç kez çalışacağını da
belirleyebilirsiniz. Aşağıdaki kodları dikkatlice inceleyin:

```python
for i in range(3):
 parola = input("parola belirleyin: ")
 if not parola:
 print("parola bölümü boş geçilemez!")

 elif len(parola) in range(3, 8):
 print("Yeni parolanız", parola)
 break

 elif i == 2:
 print("parolayı 3 kez yanlış girdiniz.",
 "Lütfen 30 dakika sonra tekrar deneyin!")

 else:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

```

Buradaifi==2kodu sayesindefordöngüsü içinde belirttiğimiziadlı değişkenin değeri2olduğu anda ‘parolayı 3 kez yanlış girdiniz…’
uyarısı gösterilecektir. Daha önce de birkaç yerde ifade ettiğimiz gibi, eğer
yukarıdaki kodların çalışma mantığını anlamakta zorlanıyorsanız, programın uygun
yerlerineprint()fonksiyonu yerleştirerek arka planda Python’ın neler
çevirdiğini daha net görebilirsiniz. Örneğin:

```python
for i in range(3):
 print(i)
 parola = input("parola belirleyin: ")
 if not parola:
 print("parola bölümü boş geçilemez!")

 elif len(parola) in range(3, 8):
 print("Yeni parolanız", parola)
 break

 elif i == 2:
 print("parolayı 3 kez yanlış girdiniz.",
 "Lütfen 30 dakika sonra tekrar deneyin!")

 else:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

```

Gördüğünüz gibi,ideğişkeninin başlangıçtaki değeri0. Bu değer her döngüde1artıyor ve bu değişkenin değeri2olduğu andaifi==2bloğu devreye
giriyor.

range()fonksiyonunun yetenekleri yukarıda anlattıklarımızla sınırlı
değildir. Bu fonksiyonun bazı başka maharetleri de bulunur. Hatırlarsanız
yukarıda bu fonksiyonun formülünü şöyle vermiştik:

```python
range(ilk_sayı, son_sayı)

```

Buna görerange()fonksiyonu iki parametre alıyor. Ama aslında bu
fonksiyonun üçüncü bir parametresi daha vardır. Buna göre formülümüzü
güncelleyelim:

```python
range(ilk_sayı, son_sayı, atlama_değeri)

```

Formüldeki son parametre olanatlama_değeri, aralıktaki sayıların kaçar kaçar
ilerleyeceğini gösterir. Yani:

```python
>>> for i in range(0, 10, 2):
... print(i)
...

0
2
4
6
8

```

Gördüğünüz gibi, son parametre olarak verdiğimiz2sayısı sayesinde0’dan10’a kadar olan sayılar ikişer ikişer atlayarak ekrana dökülüyor.

Bu arada, bir şey dikkatinizi çekmiş olmalı:

range()fonksiyonu üç farklı parametre alan bir fonksiyon. Eğer ilk
parametre0olacaksa bu parametreyi belirtmek zorunda olmadığımızı biliyoruz.
Yani:

```python
>>> range(10)

```

Python bu kodurange(0,10)olarak algılayıp buna göre değerlendiriyor.
Ancak eğerrange()fonksiyonunda üçüncü parametreyi de kullanacaksak, yanirange(0,10,2)gibi bir komut vereceksek, üç parametrenin tamamını da
belirtmemiz gerekiyor. Eğer burada bütün parametreleri belirtmezsek Python hangi
sayının hangi parametreye karşılık geldiğini anlayamaz. Yani mesela0’dan10’a kadar olan sayıları ikişer ikişer atlayarak ekrana dökmek için şöyle bir
şey yazmaya çalıştığımızı düşünün:

```python
>>> for i in range(10, 2):
... print(i)

```

Burada Python ne yapmaya çalıştığınızı anlayamaz. Parantez içinde ilk değer
olarak10, ikinci değer olarak ise2yazdığınız için, Python bu10sayısını başlangıç değeri;2sayısını ise bitiş değeri olarak algılayacaktır.
Dolayısıyla da Python bu durumda sizin10’dan2’ye kadar olan sayıları
listelemek istediğinizi zannedecek,range()fonksiyonuyla bu şekilde geriye
doğru sayamayacağımız için de boş bir çıktı verecektir. Bu yüzden, Python’un
şaşırmaması için yukarıdaki örneği şu şekilde yazmalıyız:

```python
>>> for i in range(0, 10, 2):
... print(i)

```

Kısacası, eğerrange()fonksiyonunun kaçar kaçar sayacağını da belirtmek
istiyorsak, parantez içinde, gerekli bütün parametreleri belirtmeliyiz.

Gördüğünüz gibi,range()fonksiyonunu kullanarak belirli bir aralıktaki
sayıları alabiliyoruz. Peki bu sayıları tersten alabilir miyiz? Elbette:

```python
>>> for i in range(10, 0, -1):
... print(i)
...
10
9
8
7
6
5
4
3
2
1

```

Buradarange()fonksiyonunu nasıl yazdığımıza çok dikkat edin. Sayıları
tersten alacağımız için, ilk parametre 10, ikinci parametre ise0. Üçüncü
parametre olarak ise eksi değerli bir sayı veriyoruz. Eğer sayıları hem tersten,
hem de mesela 3’er 3’er atlayarak yazmak isterseniz şöyle bir komut
verebilirsiniz:

```python
>>> for i in range(10, 0, -3):
... print(i)
...
10
7
4
1

```

Bu arada, etkileşimli kabuktarange(10)gibi bir komut verdiğinizderange(0, 10)çıktısı aldığınızı görüyorsunuz. Bu çıktı, verdiğimiz komutun0ile10arası sayıları elde etmemizi sağlayacağını belirtiyor, ama bu sayıları
o anda bize göstermiyor. Daha önce verdiğimiz örneklerden de anlaşılacağı gibi,0-10aralığındaki sayıları görebilmek içinrange(10)ifadesi üzerinde
birfordöngüsü kurmamız gerekiyor.range(10)ifadesinin taşıdığı
sayıları görebilmek içinfordöngüsü kurmak tek seçenek değildir. Bu işlem
için yıldızlı parametrelerden de yararlanabiliriz.print()fonksiyonunu
incelediğimiz derste yıldızlı parametrelerin nasıl kullanıldığını göstermiştik.
Dilerseniz şimdi bu parametre tipinirange()fonksiyonuna nasıl
uygulayabileceğimizi görelim:

```python
>>> print(*range(10))

0 1 2 3 4 5 6 7 8 9

```

print()fonksiyonununsepparametresi yardımıyla bu çıktıyı istediğiniz
gibi düzenleyebileceğinizi biliyorsunuz. Mesela çıktıdaki sayıları
birbirlerinden virgülle ayırmak için şöyle bir komut verebiliyoruz:

```python
>>> print(*range(10), sep=", ")

0, 1, 2, 3, 4, 5, 6, 7, 8, 9

```

Böylecerange()fonksiyonunu enine boyuna incelemiş ve bu fonksiyonun ne işe
yaradığını, nasıl kullanılacağını anlamamızı sağlayan örnekler vermiş olduk.
Artık başka bir konuyu geçebiliriz.

#### pass Deyimi

passkelimesi İngilizcede ‘geçmek, pas geçmek’ gibi anlamlara gelir.
Python’daki kullanımı da bu anlama oldukça yakındır. Biz bu deyimi Pyhon’da
‘görmezden gel, hiçbir şey yapma’ anlamında kullanacağız.

Dilersenizpassdeyimini tarif etmeye çalışmak yerine bu deyimi bir örnek
üzerinde açıklamaya çalışalım.

Hatırlarsanız yukarıda şöyle bir örnek vermiştik:

```python
while True:
 parola = input("parola belirleyin: ")

 if not parola:
 print("parola bölümü boş geçilemez!")

 elif len(parola) in range(3, 8): #eğer parolanın uzunluğu 3 ile 8 karakter
 #aralığında ise...
 print("Yeni parolanız", parola)
 break

 else:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

```

Burada mesela eğer kullanıcı parolayı boş bırakırsa ‘parola bölümü boş
geçilemez!’ uyarısı gösteriyoruz. Şimdi oifbloğunu şöyle yazdığımızı
düşünün:

```python
while True:
 parola = input("parola belirleyin: ")

 if not parola:
 pass

 elif len(parola) in range(3, 8): #eğer parolanın uzunluğu 3 ile 8 karakter
 #aralığında ise...
 print("Yeni parolanız", parola)
 break

 else:
 print("parola 8 karakterden uzun 3 karakterden kısa olmamalı")

```

Burada, eğer kullanıcı parolayı boş bırakırsa programımız hiçbir şey yapmadan
yoluna devam edecektir. Yani buradapassdeyimi yardımıyla programımıza şu
emri vermiş oluyoruz:

Eğer kullanıcı parolayı boş geçerse görmezden gel. Hiçbir şey yapmadan
yoluna devam et!

Başka bir örnek daha verelim:

```python
while True:
 sayı = int(input("Bir sayı girin: "))

 if sayı == 0:
 break

 elif sayı < 0:
 pass

 else:
 print(sayı)

```

Burada eğer kullanıcı0sayısını girerse programımız sona erer (breakdeyimini biraz sonra inceleyeceğiz). Eğer kullanıcı0’dan küçük bir sayı
girerse, yani kullanıcının girdiği sayı eksi değerli ise,passdeyimininin
etkisiyle programımız hiçbir şey yapmadan yoluna devam eder. Bu koşulların
dışındaki durumlarda ise programımız kullanıcının girdiği sayıları ekrana
yazdıracaktır.

Yukarıda anlatılan durumların dışında,passdeyimini kodlarınız henüz taslak
aşamasında olduğu zaman da kullanabilirsiniz. Örneğin, diyelim ki bir kod
yazıyorsunuz. Programın gidişatına göre, bir noktada yapmanız gereken bir işlem
var, ama henüz ne yapacağınıza karar vermediniz. Böyle bir durumdapassdeyiminden yararlanabilirsiniz. Mesela birtakımifdeyimleri yazmayı
düşünüyor olun:

```python
if .....:
 böyle yap

elif .....:
 şöyle yap

else:
 pass

```

Burada henüzelsebloğunda ne yapılacağına karar vermemiş olduğunuz için,
oraya birpasskoyarak durumu şimdilik geçiştiriyorsunuz. Program son haline
gelene kadar oraya bir şeyler yazmış olacaksınız.

Sözün özü,passdeyimlerini, herhangi bir işlem yapılmasının gerekli
olmadığı durumlar için kullanıyoruz. İlerde işe yarar programlar yazdığınızda,
bupassdeyiminin göründüğünden daha faydalı bir araç olduğunu
anlayacaksınız.

#### break Deyimi

Python’dabreaközel bir deyimdir. Bu deyim yardımıyla, devam eden bir
süreci kesintiye uğratabiliriz. Bu deyimin kullanıldığı basit bir örnek
verelim:

```python
>>> while True:
... parola = input("Lütfen bir parola belirleyiniz:")
... if len(parola) < 5:
... print("Parola 5 karakterden az olmamalı!")
... else:
... print("Parolanız belirlendi!")
... break

```

Burada, eğer kullanıcının girdiği parolanın uzunluğu5karakterden azsa,Parola 5 karakterden az olmamalı!uyarısı gösterilecektir. Eğer kullanıcı5karakterden uzun bir parola belirlemişse, kendisine ‘Parolanız belirlendi!’
mesajını gösterip,breakdeyimi yardımıyla programdan çıkıyoruz.

Gördüğünüz gibi,breakifadesinin temel görevi bir döngüyü sona erdirmek.
Buradan anlayacağımız gibi,breakifadesinin her zaman bir döngü içinde yer
alması gerekiyor. Aksi halde Python bize şöyle bir hata verecektir:

```python
SyntaxError: 'break' outside loop

```

Yani:

```python
SözDizimiHatası: ``break`` döngü dışında ..

```

#### continue Deyimi

continueilginç bir deyimdir. İstersenizcontinuedeyimini anlatmaya
çalışmak yerine bununla ilgili bir örnek verelim:

```python
while True:
 s = input("Bir sayı girin: ")
 if s == "iptal":
 break

 if len(s) <= 3:
 continue

 print("En fazla üç haneli bir sayı girebilirsiniz.")

```

Burada eğer kullanıcı klavyedeiptalyazarsa programdan çıkılacaktır. Bunu;

```python
if s == "iptal":
 break

```

satırıyla sağlamayı başardık.

Eğer kullanıcı tarafından girilen sayı üç haneli veya daha az haneli bir sayı
ise,continueifadesinin etkisiyle:

```python
>>> print("En fazla üç haneli bir sayı girebilirsiniz.")

```

satırı es geçilecek ve döngünün en başına gidilecektir.

Eğer kullanıcının girdiği sayıdaki hane üçten fazlaysa ekrana:

```python
En fazla üç haneli bir sayı girebilirsiniz.

```

cümlesi yazdırılacaktır.

Dolayısıyla buradan anladığımıza göre,continuedeyiminin görevi kendisinden
sonra gelen her şeyin es geçilip döngünün başına dönülmesini sağlamaktır. Bu
bilgiye göre, yukarıdaki programda eğer kullanıcı, uzunluğu üç karakterden az
bir sayı girersecontinuedeyiminin etkisiyle programımız döngünün en başına
geri gidiyor. Ama eğer kullanıcı, uzunluğu üç karakterden fazla bir sayı
girerse, ekrana ‘En fazla üç haneli bir sayı girebilirsiniz,’ cümlesinin
yazdırıldığını görüyoruz.

#### else Deyimi

Bizelsedeyimini koşullu durumlarda da görmüştük, ancakelsedeyimi
döngüler ile de kullanılabilmektedir. Tabii döngüler ile kullanıldığında
farklı bir işi üstlenmektedir.elsedeyimi döngüler ile birlikte
kullanılırkenbreakdeyimi ile birlikte bir anlam kazanır.
Şöyle bir kodumuz olduğunu varsayalım:

```python
for i in range(5):
 print(i)
else:
 print("else çalıştı.")

```

Kodumuzu kaydedip çalıştırdığımızda bu çıktıyı alıyoruz:

```python
1
2
3
4
else çalıştı.
>>>

```

Peki şimdielseifadesi ne işe yaradı? Aslında pek de işe yaramadı,elseifadesini yazmadan da aynı çıktıları alabilirdik.
Dediğimiz gibi Python’daelseifadesi döngüler ile birlikte kullanılacaksabreakifadesi ile birlikte bir anlam kazanır. Eğer döngübreakifadesi kullanılarak sonlandırıldı iseelseçalışmaz, döngübreakifadesi ile sonlandırılmadı iseelsebölümü çalışır.
Yukarıdaki örneğimizde zatenbreakdeyimi bulunmadığı
içinelsebölümü çalıştı. Şimdi çalışmayacağı bir örnek verelim:

```python
a = 0
while True:
 a += 1
 print(a)
 if a==3:
 break
else:
 print("else çalıştı.")

```

Şimdi programımızı çalıştırdığımızda şu sonucu almaktayız:

```python
1
2
3

```

Gördüğünüz gibiadeğişkenimiz3olduğunda döngümüzbreakifadesi
ile kırılıyor ve bu yüzdenelseçalışmıyor.elseifadesini
hemforhem dewhiledöngüsü ile kullanabileceğimizi unutmayalım.

Şimdi bu konu ile ilgili işe yarar bir örnek verelim. Bir karakter dizimiz
var ve'a'harfinin bu dizide bulunup bulunmadığını kontrol
etmek istiyoruz. Eğer bulunuyorsa ekrana bunu belirten bir
yazı yazacağız:

```python
karater_dizisi = "Merhaba Dünya"
for harf in karater_dizisi:
 if harf == 'a':
 print("a harfi bulundu.")

```

Ancak bu programı çalıştırdığımızda şöyle bir sonuçla karşılaşıyoruz:

```python
a harfi bulundu.
a harfi bulundu.
a harfi bulundu.
>>>

```

Gördüğünüz gibi her'a'harfi için bir defaaharfibulundu.yazılıyor.
Eğer biz bir defa'a'harfine rastladığımızda döngüden çıkmak istiyorsak
bunu şu şekilde yazabiliriz:

```python
karater_dizisi = "Merhaba Dünya"
for harf in karater_dizisi:
 if harf == 'a':
 print("a harfi bulundu.")
 break

```

Kodumuzu çalıştırıyoruz:

```python
a harfi bulundu.
>>>

```

Peki şimdi'a'harfinin bulunmadığı durumda daaharfibulunmadı.yazmak istersek bunu nasıl yaparız? Bazı değişkenler oluşturupififadesi ile bunu yapmak mümkündür ancakelseifadesi ile de
bu işi hemen halledebiliyoruz:

```python
karater_dizisi = "Bu yAzıdA küçük A yok."
for harf in karater_dizisi:
 if harf == 'a':
 print("a harfi bulundu.")
 break
else:
 print("a harfi bulunmadı.")

```

Kodumuzu çalıştırdığımızdabreakifadesi hiç çalışmadığı içinelseifadesinin
çalıştığını görebiliriz:

```python
a harfi bulunmadı.
>>>

```

Evet,elseifadesi de Python’da döngüler ile bu şekilde kullanılabiliyor.
Peki olmasa da olur muydu? Olurdu.elseifadesinin bu kullanım şekli de
Python’daki çoğu kolaylıklardan biri sadece…

Konu ile alakalı daha çok örnek içinburayabakabilirsiniz.

### Örnek Uygulamalar

Python programlama dilinde döngülerin neye benzediğini öğrendik. Bu bölümde
ayrıca döngülerle birlikte kullanabileceğimiz başka araçları da tanıdık. Şimdi
dilerseniz bu öğrendiklerimizi pekiştirmek için birkaç ufak çalışma yapalım.

#### Karakter Dizilerinin İçeriğini Karşılaştırma

Diyelim ki elinizde şöyle iki farklı metin var:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

```

Siz burada,ilk_metinadlı değişken içinde bulunan, amaikinci_metinadlı
değişken içinde bulunmayan öğeleri ayıklamak istiyorsunuz. Yani bu iki metnin
içeriğini karşılaştırıp, farklı öğeleri bulmayı amaçlıyorsunuz. Bu işlem için,
bu bölümde öğrendiğimiz döngülerden ve daha önce öğrendiğimiz başka araçlardan
yararlanabilirsiniz. Şimdi dikkatlice bakın:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

for s in ilk_metin:
 if not s in ikinci_metin:
 print(s)

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda şu çıktıyı alıyoruz:

```python
a
a
ş
ş
a

```

Demek kiilk_metinadlı değişkende olup daikinci_metinadlı değişkende
olmayan öğeler bunlarmış…

Bu kodlarda anlayamayacağınız hiçbir şey yok. Ama dilerseniz biz yine de bu
kodları tek tek inceleyelim.

İlk olarak değişkenlerimizi tanımladık:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

```

Amacımızilk_metin’de olan, amaikinci_metin’de olmayan öğeleri görmek.
Bunun içinilk_metin’deki öğeleritek tekikinci_metin’deki öğelerle
karşılaştırmamız gerekiyor. Tahmin edebileceğiniz gibi, bir metnin bütün
öğelerine tek tek bakabilmenin en iyi yolufordöngülerini kullanmaktır. O
halde döngümüzü yazalım:

```python
for s in ilk_metin: #ilk_metin'deki, 's' adını verdiğimiz bütün öğeler için
 if not s in ikinci_metin: #eğer 's' adlı bu öğe ikinci_metin'de yoksa
 print(s) #'s' adlı öğeyi ekrana bas

```

Gördüğünüz gibi, döngüleri (for), bool işleçlerini (not) ve aitlik
işleçlerini (in) kullanarak, istediğimiz şeyi rahatlıkla yapabiliyoruz. Burada
kullandığımızifdeyimi, bir önceki satırdafordöngüsü ile üzerinden
geçtiğimiz öğeleri süzmemizi sağlıyor. Burada temel olarak şu üç işlemi
yapıyoruz:
1. ilk_metiniçindeki bütün öğelerin üzerinden geçiyoruz,
1. Bu öğeleri belli bir ölçüte göre süzüyoruz,
1. Ölçüte uyan öğeleri ekrana basıyoruz.

ilk_metiniçindeki bütün öğelerin üzerinden geçiyoruz,

Bu öğeleri belli bir ölçüte göre süzüyoruz,

Ölçüte uyan öğeleri ekrana basıyoruz.

Elbette yukarıda yaptığımız işlemin tersini yapmak da mümkündür. Biz yukarıdaki
kodlardailk_metin’de olan, amaikinci_metin’de olmayan öğeleri süzdük. Eğer
istersekikinci_metin’de olan, amailk_metin’de olmayan öğeleri de
süzebiliriz. Mantığımız yine aynı:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

for s in ikinci_metin: #ikinci_metin'deki, 's' adını verdiğimiz bütün öğeler için
 if not s in ilk_metin: #eğer 's' adlı bu öğe ilk_metin'de yoksa
 print(s) #'s' adlı öğeyi ekrana bas

```

Bu da bize şu çıktıyı veriyor:

```python
u
ı
o
r
y
e
u
ı
r
u
e
e
e
u

```

Gördüğünüz gibi, yaptığımız tek şey,ilk_metinileikinci_metin’in yerlerini
değiştirmek oldu. Kullandığımız mantık ise değişmedi.

Bu arada, yukarıdaki çıktıda bizi rahatsız eden bir durum var. Çıktıda bazı
harfler birbirini tekrar ediyor. Aslında temel olarak sadece şu harfler var:

```python
u
ı
o
r
y
e

```

Ama metin içinde bazı harfler birden fazla sayıda geçtiği için, doğal olarak
çıktıda da bu harfler birden fazla sayıda görünüyor. Ama tabii ki, eğer biz
istersek farklı olan her harften yalnızca bir tanesini çıktıda görmeyi de tercih
edebiliriz. Bunun için şöyle bir kod yazabiliriz:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

fark = ""

for s in ikinci_metin:
 if not s in ilk_metin:
 if not s in fark:
 fark += s
print(fark)

```

Burada da anlayamayacağımız hiçbir şey yok. Bu kodlardaki bütün parçaları
tanıyoruz. Her zamanki gibi öncelikle değişkenlerimizi tanımladık:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

```

Daha sonrafarkadlı boş bir karakter dizisi tanımlıyoruz. Metinler içindeki
farklı karakter dizilerinifarkadlı bu karakter dizisi içinde depolayacağız.

Ardından dafordöngümüzü yazıyoruz:

```python
for s in ikinci_metin: # ikinci_metin'de 's' dediğimiz bütün öğeler için
 if not s in ilk_metin: # eğer 's' ilk_metin'de yoksa
 if not s in fark: # eğer 's' fark'ta da yoksa
 fark += s # bu öğeyi fark değişkenine ekle
print(fark) # fark değişkenini ekrana bas

```

Uyguladığımız mantığın ne kadar basit olduğunu görüyorsunuz. Bu kodlarda basitçe
şu işlemleri yapıyoruz:
1. ikinci_metindeğişkeni içindeki bütün öğelerin üzerinden tek tek geç,
1. Eğer bu değişkendeki herhangi bir öğeilk_metin’de vefark’ta yoksa o
öğeyifark’a ekle.
1. Son olarak dafark’ı ekrana bas.

ikinci_metindeğişkeni içindeki bütün öğelerin üzerinden tek tek geç,

Eğer bu değişkendeki herhangi bir öğeilk_metin’de vefark’ta yoksa o
öğeyifark’a ekle.

Son olarak dafark’ı ekrana bas.

Bu kodlarda dikkatimizi çeken ve üzerinde durmamız gereken bazı noktalar var.
Burada özelliklefarkdeğişkenine öğe ekleme işlemini nasıl yaptığımıza dikkat
edin.

Python programlama dilinde önceden oluşturduğumuz bir karakter dizisini başka
bir karakter dizisi ile birleştirdiğimizde bu işlem ilk oluşturduğumuz karakter
dizisini etkilemez. Yani:

```python
>>> a = 'istihza'
>>> a + '.com'

'istihza.com'

```

Burada sankiaadlı özgün karakter dizisini değiştirmişiz ve ‘istihza.com’
değerini elde etmişiz gibi görünüyor. Ama aslındaa’nın durumunda hiçbir
değişiklik yok:

```python
>>> a

'istihza'

```

Gördüğünüz gibi,adeğişkeninin değeri hâlâ‘istihza’. Bu durumun nedeni,
birleştirme işlemlerinin bir değiştirme işlemi olmamasıdır. Yani mesela iki
karakter dizisini birleştirdiğinizde birleşen karakter dizileri üzerinde
herhangi bir değişiklik olmaz. Bu durumda yapabileceğimiz tek şey, karakter
dizisine eklemek istediğimiz öğeyi de içeren yeni bir karakter dizisi
oluşturmaktır. Yani:

```python
>>> a = 'istihza'
>>> a = a + '.com'
>>> print(a)

istihza.com

```

Burada sanki değeri‘istihza’olanaadlı bir değişkene‘.com’değerini
eklemişiz gibi görünüyor, ama aslında biz buradaadeğişkenini yok edip,‘istihza.com’değerini içeren,aadlı başka bir değişken tanımladık. Bu
durumu nasıl teyit edeceğinizi biliyorsunuz:

```python
>>> a = 'istihza'
>>> id(a)

15063200

>>> a = a + '.com'
>>> id(a)

15067960

```

Buradaid()fonksiyonunu kullanarak karakter dizilerinin kimliklerini
sorguladık. Gördüğünüz gibi, isimleri aynı da olsa, aslında ortada iki farklıadeğişkeni var. Kimlik numaralarının farklı olmasından anladığımıza göre, ilk
başta tanımladığımızadeğişkeni ilea=a+'.com'satırıyla
oluşturduğumuzadeğişkeni birbirinden farklı.

Bu arada, eğer istersek yukarıdaki değer atama işlemini, önceki bölümlerde
öğrendiğimiz değer atama işleçleri yardımıyla kısaltabileceğimizi de
biliyorsunuz:

```python
>>> a += '.com'

```

İşteilk_metinileikinci_metindeğişkenleri arasındaki farklı harfleri
yalnızca birer kez yazdırmak için kullandığımız kodlarda da yukarıdaki işlemi
yaptık:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

fark = ''

for s in ikinci_metin:
 if not s in ilk_metin:
 if not s in fark:
 fark += s
print(fark)

```

Gördüğünüz gibi, önce boş birfarkdeğişkeni oluşturduk. Daha sonra bu
değişkenefordöngüsü içinde yeni değerler atayabilmek (daha doğrusu
atarmış gibi yapmak) içinfark+=sgibi bir kod kullandık. Böylecefordöngüsünün her dönüşündesadını verdiğimiz her bir öğeyi tek tekfarkdeğişkenine yolladık. Böylece program sonunda elimizde, farklı öğeleri yalnızca
birer kez içerenfarkadlı bir değişken olmuş oldu. Dediğimiz gibi, ilk başta
tanımladığımız boşfarkdeğişkeni ile, program sonunda farklı değerleri içerenfarkdeğişkeni aslında aynı değil. Yani biz ilkfarkdeğişkenine döngünün
her dönüşünde yeni bir öğe eklemek yerine, döngünün her dönüşünde yeni birfarkdeğişkeni oluşturmuş oluyoruz. Ama programın sonunda sankifarkdeğişkenine her defasında yeni bir değer atamışız gibi görünüyor ve bu da bizim
işimizi görmemize yetiyor…

Programın başındaki ve sonundakifarkdeğişkenlerinin aslında birbirinden
farklı olduğunu teyit etmek için şu kodları kullanabilirsiniz:

```python
ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh"
ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf"

fark = ""
print("fark'ın ilk tanımlandığı zamanki kimlik numarası: ", id(fark))

for s in ikinci_metin:
 if not s in ilk_metin:
 if not s in fark:
 fark += s

print("fark'ın program sonundaki kimlik numarası: ", id(fark))

```

Gördüğünüz gibi, gerçekten de ortada iki farklıfarkdeğişkeni var. Bu durumuid()fonksiyonu yardımıyla doğrulayabiliyoruz.

Peki bu bilginin bize ne faydası var?

Şimdilik şu kadarını söyleyelim: Eğer o anda muhatap olduğunuz bir veri tipinin
mizacını, huyunu-suyunu bilmezseniz yazdığınız programlarda çok kötü
sürprizlerle karşılaşabilirsiniz. Birkaç bölüm sonra başka veri tiplerini de
öğrendikten sonra bu durumu daha ayrıntılı bir şekilde inceleyeceğiz.

Bu arada, tahmin edebileceğiniz gibi yukarıdakifordöngüsünü şöyle de
yazabilirdik:

```python
for s in ikinci_metin:
 if not s in ilk_metin and not s in fark:
 fark += s

```

Burada iki farklıifdeyimini iki farklı satırda yazmak yerine, bu deyimleriandişleci ile birbirine bağladık.

Bu örnek ile ilgili söyleyeceklerimiz şimdilik bu kadar. Gelin biz şimdi
isterseniz bilgilerimizi pekiştirmek için başka bir örnek daha yapalım.

#### Dosyaların İçeriğini Karşılaştırma

Bir önceki örnekte karakter dizilerinin içeriğini nasıl karşılaştırabileceğimizi
gösteren bir örnek vermiştik. Şimdi de, gerçek hayatta karşınıza çıkması daha
olası bir durum olması bakımından, dosyaların içeriğini nasıl
karşılaştıracağımıza dair bir örnek verelim.

Esasında karakter dizilerinin içeriğini birbirleriyle nasıl karşılaştırıyorsak,
dosyaların içeriğini de benzer şekilde karşılaştırabiliriz. Mesela içeriği şu
olanisimler1.txtadlı bir dosyamız olduğunu varsayalım:

```python
Ahmet
Mehmet
Sevgi
Sinan
Deniz
Ege
Efe
Ferhat
Fırat
Zeynep
Hazan
Mahmut
Celal
Cemal
Özhan
Özkan

```

Yine içeriği şu olan bir deisimler2.txtadlı başka bir dosya daha olduğunu
düşünelim:

```python
Gürsel
Mehmet
Sevgi
Sami
Deniz
Ege
Efe
Ferhat
Fırat
Tülay
Derya
Hazan
Mahmut
Tezcan
Cemal
Özhan
Özkan
Özcan
Dilek

```

Amacımız bu iki dosyanın içeriğini karşılaştırıp, farklı öğeleri ortaya sermek.
Dediğimiz gibi, bir önceki örnekte izlediğimiz yolu burada da takip edebiliriz.
Dikkatlice bakın:

```python
d1 = open("isimler1.txt") # dosyayı açıyoruz
d1_satırlar = d1.readlines() # satırları okuyoruz

d2 = open("isimler2.txt")
d2_satırlar = d2.readlines()

for i in d2_satırlar:
 if not i in d1_satırlar:
 print(i)

d1.close()
d2.close()

```

Gerçekten de mantığın bir önceki örnekle tamamen aynı olduğunu görüyorsunuz. Biz
henüz Python’da dosyaların nasıl işleneceğini öğrenmedik, ama daha önce
gördüğümüzopen()fonksiyonu yardımıyla en azından dosyaları açabilecek
kadar biliyoruz dosya işlemlerinin nasıl yürütüleceğini…

Burada farklı olarakreadlines()adlı bir metot görüyoruz. Biz burada bu
metodun ayrıntılarına inmeyeceğiz, ama şimdilik dosya içeriğinin satırlar
halinde okunmasını sağladığını bilelim yeter.

Bu arada, eğer çıktıda Türkçe karakterleri düzgün görüntüleyemiyorsanızopen()fonksiyonununencodingadlı bir parametresi vasıtasıyla içeriğiUTF-8olarak kodlayabilirsiniz:

```python
d1 = open("isimler1.txt", encoding="utf-8") # dosyayı açıyoruz
d1_satırlar = d1.readlines() # satırları okuyoruz

d2 = open("isimler2.txt", encoding="utf-8")
d2_satırlar = d2.readlines()

for i in d2_satırlar:
 if not i in d1_satırlar:
 print(i)

d1.close()
d2.close()

```

Bu şekilde Türkçe karakterleri düzgün bir şekilde görüntüleyebiliyor olmanız
lazım. Eğer Windows’ta Türkçe karakterleri hala düzgün görüntüleyemiyorsanızencodingparametresinde ‘utf-8’ yerine ‘cp1254’ adlı dil kodlamasını
kullanmayı deneyebilirsiniz:

```python
encoding = "cp1254"

```

Yukarıdaki örneklerde bir içerik karşılaştırması yapıp,farklıöğeleri
ayıkladık. Aynı şekildebenzeröğeleri ayıklamak da mümkündür. Bu işlemin
nasıl yapılacağını az çok tahmin ettiğinizi zannediyorum:

```python
d1 = open("isimler1.txt")
d1_satırlar = d1.readlines()

d2 = open("isimler1.txt")
d2_satırlar = d2.readlines()

for i in d2_satırlar:
 if i in d1_satırlar:
 print(i)

d1.close()
d2.close()

```

Burada bir öncekinden farklı olarakifnotiind1_satırlarkodu yerine,
doğal olarak,ifiind1_satırlarkodunu kullandığımıza dikkat edin.

Dosyalar üzerinde yaptığımız işlemleri tamamladıktan sonraclose()metodu
ile bunları kapatmayı unutmuyoruz:

```python
d1.close()
d2.close()

```

#### Karakter Dizisindeki Karakterleri Sayma

Yukarıdaki örneklerde içerik karşılaştırmaya ilişkin birkaç örnek verdik. Şimdi
yine bilgilerimizi pekiştirmek için başka bir konuya ilişkin örnekler verelim.

Mesela elimizde şöyle bir metin olduğunu varsayalım:

```python
Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin Python olmasına aldanarak, bu programlama dilinin, adını piton
yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama
dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini,
The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying
Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar
gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan
figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır.

```

Yapmamız gereken bir istatistik çalışması gereğince bu metinde her harfin kaç
kez geçtiğini hesaplamanız gerekiyor.

Bunun için şöyle bir program yazabiliriz:

```python
metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin Python olmasına aldanarak, bu programlama dilinin, adını piton
yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin
adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty
Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı
gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa
da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil
edilmesi neredeyse bir gelenek halini almıştır."""

harf = input("Sorgulamak istediğiniz harf: ")

sayı = ''

for s in metin:
 if harf == s:
 sayı += harf

print(len(sayı))

```

Burada öncelikle metnimizi bir değişken olarak tanımladık. Ardından da
kullanıcıya hangi harfi sorgulamak istediğini sorduk.

Bu kodlarda tanımladığımızsayıadlı değişken, sorgulanan harfi, metinde
geçtiği sayıda içinde barındıracaktır. Yani mesela metin5taneaharfi
varsasayıdeğişkeninin değeriaaaaaolacaktır.

Sonraki satırlardafordöngümüzü tanımlıyoruz:

```python
for s in metin: # metin içinde 's' adını verdiğimiz her bir öğe için
 if harf == s: # eğer kullanıcıdan gelen harf 's' ile aynıysa
 sayı += harf # kullanıcıdan gelen bu harfi sayı değişkenine yolla

```

Dediğimiz gibi,sayıdeğişkeni, sorgulanan harfi, metinde geçtiği sayıda
barındırıyor. Dolayısıyla bir harfin metinde kaç kez geçtiğini bulmak içinsayıdeğişkeninin uzunluğunu yazdırmamız yeterli olacaktır:

```python
print(len(sayı))

```

Dilerseniz yukarıdaki programı yazmak için daha farklı bir mantık da
kullanabilirsiniz. Dikkatlice bakın:

```python
metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin Python olmasına aldanarak, bu programlama dilinin, adını piton
yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin
adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty
Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı
gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa
da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil
edilmesi neredeyse bir gelenek halini almıştır."""

harf = input("Sorgulamak istediğiniz harf: ")

sayı = 0

for s in metin:
 if harf == s:
 sayı += 1

print(sayı)

```

Buradasayıdeğişkeninin ilk değeri0olarak belirledik. Döngü içinde de,
sorgulanan harfin metin içinde her geçişindesayıdeğişkeninin değerini1sayı artırdık. Dolayısıyla sorgulanan harfin metinde kaç kez geçtiğini bulmak
içinsayıdeğişkeninin son değerini yazdırmamız yeterli oldu.

#### Dosya içindeki Karakterleri Sayma

Dilerseniz bir önceki örnekte kullandığımız metnin program içinde bir değişken
değil de, mesela bir dosyadan okunan bir metin olduğunu varsayalım şimdi:

```python
hakkında = open("hakkında.txt", encoding="utf-8")

harf = input("Sorgulamak istediğiniz harf: ")

sayı = 0

for karakter_dizisi in hakkında:
 for karakter in karakter_dizisi:
 if harf == karakter:
 sayı += 1
print(sayı)

hakkında.close()

```

Burada yaptığımız ilk iş elbette dosyamızı açmak oldu:

```python
hakkında = open("hakkında.txt", encoding="utf-8")

```

Bu komutla,hakkında.txtadlı dosyayıUTF-8kodlaması ile açtık. Daha sonra
kullanıcıya, sorgulamak istediği harfi soruyoruz:

```python
harf = input("Sorgulamak istediğiniz harf: ")

```

Ardından da sorgulanan harfin dosyada kaç kez geçtiği bilgisini tutacak olansayıadlı bir değişken tanımlıyoruz:

```python
sayı = 0

```

Sıra geldifordöngümüzü tanımlamaya:

```python
for karakter_dizisi in hakkında:
 for karakter in karakter_dizisi:
 if harf == karakter:
 sayı += 1

```

Bu döngüyü anlamakta bir miktar zorlanmış olabilirsiniz. Her zaman söylediğimiz
gibi, Python’da bir kod parçasını anlamanın en iyi yöntemi, gerekli yerlereprint()fonksiyonları yerleştirerek, programın verdiği çıktıları
incelemektir:

```python
for karakter_dizisi in hakkında:
 print(karakter_dizisi)
 #for karakter in karakter_dizisi:
 # if harf == karakter:
 # sayı += 1

```

Gördüğünüz gibi, ilkfordöngüsünün hemen sonrasına birprint()fonksiyonu
yerleştirerek bu döngünün verdiği çıktıları inceliyoruz. Bu arada, amacımıza
hizmet etmeyen satırları da yorum içine alarak etkisizleştirdiğimize dikkat
edin.

Çıktıya baktığımız zaman, şöyle bir durumla karşılaşıyoruz:

```python
Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı

tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,

isminin Python olmasına aldanarak, bu programlama dilinin, adını piton

yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin

adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty

Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı

gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa

da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil

edilmesi neredeyse bir gelenek halini almıştır.

```

Burada her bir satır ayrı bir karakter dizisidir. Eğer her bir satırın ayrı bir
karakter dizisi olduğunu daha net bir şekilde görmek istiyorsanızrepr()adlı özel bir fonksiyondan yararlanabilirsiniz:

```python
for karakter_dizisi in hakkında:
 print(repr(karakter_dizisi))
 #for karakter in karakter_dizisi:
 # if harf == karakter:
 # sayı += 1

```

Bu kodlar bu kez şöyle bir çıktı verir:

```python
'Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı\n'
'tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,\n'
'isminin Python olmasına aldanarak, bu programlama dilinin, adını piton\n'
'yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin\n'
'adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty\n'
'Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı\n'
'gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa\n'
'da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil\n'
'edilmesi neredeyse bir gelenek halini almıştır.'

```

Bu çıktıya çok dikkatlice bakın.repr()fonksiyonu sayesinde Python’ın
alttan alta neler çevirdiğini bariz bir biçimde görüyoruz. Karakter dizisinin
başlangıç ve bitişini gösteren tırnak işaretleri ve\nkaçış dizilerinin
görünür vaziyette olması sayesinde her bir satırın ayrı bir karakter dizisi
olduğunu daha net bir şekilde görebiliyoruz.

Biz yazdığımız kodlarda, kullanıcıdan bir harf girmesini istiyoruz.
Kullandığımız algoritma gereğince bu harfi metindeki karakter dizileri içinde
geçen her bir karakterle tek tek karşılaştırmamız gerekiyor.input()metodu
aracılığıyla kullanıcıdan tek bir karakter alıyoruz. Kullandığımızfordöngüsü
ise bize bir karakter yerine her satırda bir karakter dizisi veriyor.
Dolayısıyla mesela kullanıcı ‘a’ harfini sorgulamışsa, ilkfordöngüsü bu
harfin karşısına‘Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcın’adlı karakter dizisini çıkaracaktır. Dolayısıyla bizim bir seviye
daha alta inerek, ilkfordöngüsünden elde edilen değişken üzerinde başka birfordöngüsü daha kurmamız gerekiyor. Bu yüzden şöyle bir kod yazıyoruz:

```python
for karakter_dizisi in hakkında:
 for karakter in karakter_dizisi:
 ...

```

Böylece iç içe ikifordöngüsü oluşturmuş oluyoruz. İsterseniz bu anlattığımız
şeyleri daha net görmek için yineprint()fonksiyonundan
yararlanabilirsiniz:

```python
hakkında = open("hakkında.txt", encoding="utf-8")

harf = input("Sorgulamak istediğiniz harf: ")

sayı = 0

for karakter_dizisi in hakkında:
 for karakter in karakter_dizisi:
 print(karakter)
# if harf == karakter:
# sayı += 1
#print(sayı)

```

karakterdeğişkenin değerini ekrana yazdırarak Python’ın alttan alta neler
çevirdiğini daha net görebiliyoruz.

Kodların geri kalanında ise, kullanıcının sorguladığı harfin,fordöngüsü
ile üzerinden geçtiğimizkarakter_dizisiadlı değişken içindeki karakterlerle
eşleşip eşleşmediğini denetliyoruz. Eğer eşleşiyorsa, her eşleşmedesayıdeğişkeninin değerini1sayı artırıyoruz. Böylece en elimizde sorgulanan
harfin metin içinde kaç kez geçtiği bilgisi olmuş oluyor.

Son olarak da, ilk başta açtığımız dosyayı kapatıyoruz:

```python
hakkında.close()

```

Nihayet bir konunun daha sonuna ulaştık. Döngüler ve döngülerle ilişkili
araçları da epey ayrıntılı bir şekilde incelediğimize göre gönül rahatlığıyla
bir sonraki konuya geçebiliriz.

## Hata Yakalama

Şimdiye kadar yazdığımız bütün programlar, dikkat ettiyseniz tek bir ortak
varsayım üzerine kurulu. Buna göre biz, yazdığımız programın kullanıcı
tarafından nasıl kullanılmasını istiyorsak, her zaman o şekilde kullanılacağını
varsayıyoruz. Örneğin sayıları toplayan bir program yazdığımızda, kullanıcının
her zaman sayı değerli bir veri gireceğini düşünüyoruz. Ancak bütün iyi
niyetimize rağmen, yazdığımız programlarda işler her zaman beklediğimiz gibi
gitmeyebilir. Örneğin, dediğimiz gibi, yazdığımız programı, kullanıcının bir
sayı girmesi temeli üzerine kurgulamışsak, kullanıcının her zaman sayı değerli
bir veri gireceğinden emin olamayız.

Mesela şöyle bir program yazdığımızı düşünün:

```python
veri1 = input("Karekökünü hesaplamak istediğiniz sayı: ")
karekök = int(veri1) ** 0.5

print(veri1, "sayısının karekökü: ", karekök)

veri2 = input("Karesini hesaplamak istediğiniz sayı: ")
kare = int(veri2) ** 2

print(veri2, "sayısının karesi: ", kare)

```

Bu kodlardaki sorunu anlamaya çalışmadan önce dilerseniz kodları şöyle bir
inceleyelim.

Gördüğünüz gibi, burada kullanıcının gireceği sayılara göre karekök ve kare alma
işlemleri yapıyoruz. Bu kodlarda gördüğümüz**işleci yardımıyla bir sayının
herhangi bir kuvvetini hesaplayabileceğimizi biliyorsunuz. Mesela 217’nin kaç ettiğini hesaplamak için**işlecini kullanabiliyoruz:

```python
>>> 21 ** 7

1801088541

```

Yine bildiğiniz gibi, bu işleçten, bir sayının karesini hesaplamak için de
yararlanabiliyoruz. Çünkü neticede bir sayının karesi, o sayının 2. kuvvetidir:

```python
>>> 12 ** 2

144

```

Aynı şekilde, eğer bir sayının, 0.5’inci kuvvetini hesaplarsak o sayının
karekökünü bulmuş oluyoruz. (Bu bilgileri önceki konulardan hatırlıyor
olmalısınız):

```python
>>> 144 ** 0.5

12

```

Kodlarımızı incelediğimize göre, bu programdaki aksaklıkları irdelemeye
başlayabiliriz.

Bu program, kullanıcı sayı değerli bir veri girdiği müddetçe sorunsuz bir
şekilde çalışacaktır. Peki ya kullanıcı sayı değerli bir veri yerine başka bir
şey girerse ne olur?

Örneğin kullanıcı yukarıdaki programa bir sayı yerine, (bilerek veya bilmeyerek)
içinde harf barındıran bir veri girerse şuna benzer bir hata alır:

```python
Traceback (most recent call last):
 File "deneme.py", line 2, in <module>
 karekök = int(veri1) ** 0.5
ValueError: invalid literal for int() with base 10: 'fds'

```

Yazdığınız programların bu tür hatalar vermesi normaldir. Ancak son kullanıcı
açısından düşündüğümüzde, kullanıcının yukarıdaki gibi bir hata mesajı görmesi
yerine, hatanın neden kaynaklandığını ya da neyi yanlış yaptığını daha açık bir
şekilde ifade eden bir mesaj alması çok daha mantıklı olacaktır. Zira yukarıdaki
hata mesajı programcılar açısından anlamlı olabilir, ancak son kullanıcı
açısından büsbütün anlaşılmazdır!

Dediğimiz gibi, programınızın çalışma esnasında bu tür hatalar vermesi normal.
Çünkü yapmaya çalıştığınız işlem, kullanıcının belli tipte bir veri girmesine
bağlı. Burada sizin bir programcı olarak göreviniz, yazdığınız programın çalışma
esnasında vermesi muhtemel hataları önceden kestirip, programınızda buna göre
bazı önlemler almanızdır. İşte biz de bu bölümde bu önlemleri nasıl alacağımızı
anlamaya çalışacağız.

### Hata Türleri

Biz bu bölümde hatalardan bahsedeceğimizi söylemiştik. Ancak her şeyden önce
‘hata’ kavramının çok boyutlu olduğunu hatırlatmakta fayda var. Özellikle
programcılık açısından hata kavramının ne anlama geldiğini biraz incelememiz
gerekiyor.

Biz bu bölümde hataları üç farklı başlık altında ele alacağız:
1. Programcı Hataları (Error)
1. Program Kusurları (Bug)
1. İstisnalar (Exception)

Programcı Hataları (Error)

Program Kusurları (Bug)

İstisnalar (Exception)

Öncelikle programcı hatalarından bahsedelim.

Programcıdan kaynaklanan hatalar doğrudan doğruya programı yazan kişinin
dikkatsizliğinden ötürü ortaya çıkan bariz hatalardır. Örneğin şu kod bir
programcı hatası içerir:

```python
>>> print "Merhaba Python!"

```

Bu kodu çalıştırdığınızda şöyle bir hata mesajı görürsünüz:

```python
>>> print "Merhaba Python!"

File "<stdin>", line 1
 print "Merhaba Python!"
 ^
SyntaxError: invalid syntax

```

Bu hata mesajında bizi ilgilendiren kısım son cümlede yer alıyor:SyntaxError, yani Söz dizimi hatası.

Bu hatalar, programlama diline ilişkin bir özelliğin yanlış kullanımından veya
en basit şekilde programcının yaptığı yazım hatalarından kaynaklanır.
Programcının hataları genellikleSyntaxErrorşeklinde ortaya çıkar. Bu
hatalar çoğunlukla programcı tarafından farkedilir ve program kullanıcıya
ulaşmadan önce programcı tarafından düzeltilir. Bu tür hataların tespiti diğer
hatalara kıyasla kolaydır. Çünkü bu tür hatalar programınızın çalışmasını
engellediği için bunları farketmemek pek mümkün değildir…

Program kusurları, başka bir deyişlebug’lar ise çok daha karmaşıktır. Kusurlu
programlar çoğu zaman herhangi bir hata vermeden çalışır. Ancak programın
ürettiği çıktılar beklediğiniz gibi değildir. Örneğin yazdığınız programda bir
formül hatası yapmış olabilirsiniz. Bu durumda programınız hiçbir şey yokmuş
gibi çalışır, ancak formül hatalı olduğu için hesaplamaların sonuçları
yanlıştır. Örneğin daha önceki derslerimizde yazdığımız şu program yukarıdaki
gibi bir kusur içerir:

```python
sayı1 = input("Toplama işlemi için ilk sayıyı girin: ")
sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ")

print(sayı1, "+", sayı2, "=", sayı1 + sayı2)

```

Bu programda kullanıcı veri girdiği zaman, programımız toplama işlemi değil
karakter dizisi birleştirme işlemi yapacaktır. Böyle bir program çalışma
sırasında hata vermeyeceği için buradaki sorunu tespit etmek, özellikle büyük
programlarda çok güçtür. Yani sizin düzgün çalıştığını zannettiğiniz program
aslında gizliden gizliye birbugbarındırıyor olabilir.

Aynı şekilde, meselaeval()fonksiyonunun dikkatsizce kullanıldığı
programlar da güvenlik açısından kusurludur. Yani bu tür programlar bir güvenlik
kusuru (security bugveyasecurity flaw) barındırır.

Dediğimiz gibi, program kusurları çok boyutlu olup, burada anlattığımızdan çok
daha karmaşıktır.

Gelelim üçüncü kategori olan istisnalara (exceptions)…

İstisnalar, adından da az çok anlaşılacağı gibi, bir programın çalışması
sırasında ortaya çıkan, normalden farklı, istisnai durumlardır. Örneğin şu
programa bakalım:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

ilk_sayı = int(ilk_sayı)
ikinci_sayı = int(ikinci_sayı)

print(ilk_sayı, "/", ikinci_sayı, "=", ilk_sayı / ikinci_sayı)

```

Burada ilk sayıyı ikinci sayıya bölen bir program yazdık. Bu program her türlü
bölme işlemini yapabilir. Ama burada hesaba katmamız gereken iki şey var:
1. Kullanıcı sayı yerine, sayı değerli olmayan bir veri tipi girebilir. Mesela
ilk sayıya karşılık23, ikinci sayıya karşılık ‘fdsfd’ gibi bir şey yazabilir.
1. Kullanıcı bir sayıyı0’a bölmeye çalışabilir. Mesela ilk sayıya karşılık23, ikinci sayıya karşılık0yazabilir.

Kullanıcı sayı yerine, sayı değerli olmayan bir veri tipi girebilir. Mesela
ilk sayıya karşılık23, ikinci sayıya karşılık ‘fdsfd’ gibi bir şey yazabilir.

Kullanıcı bir sayıyı0’a bölmeye çalışabilir. Mesela ilk sayıya karşılık23, ikinci sayıya karşılık0yazabilir.

İlk durumda programımız şöyle bir hata verir:

```python
ilk sayı: 23
ikinci sayı: fdsfd
Traceback (most recent call last):
 File "deneme.py", line 5, in <module>
 ikinci_sayı = int(ikinci_sayı)
ValueError: invalid literal for int() with base 10: 'fdsfd'

```

Buradaki sorun, sayı değerli olmayan bir verinin,int()fonksiyonu
aracılığıyla sayıya çevrilmeye çalışılıyor olması.

İkinci durumda ise programımız şöyle bir hata verir:

```python
ilk sayı: 23
ikinci sayı: 0
Traceback (most recent call last):
 File "deneme.py", line 7, in <module>
 print(ilk_sayı, "/", ikinci_sayı, "=", ilk_sayı / ikinci_sayı)
ZeroDivisionError: division by zero

```

Buradaki sorun ise, bir sayının0’a bölünmeye çalışılıyor olması. Matematikte
sayılar0’a bölünemez…

İşte bu iki örnekte gördüğümüzValueErrorveZeroDivisionErrorbirer
istisnadır. Yani kullanıcıların, kendilerinden sayı beklenirken sayı değerli
olmayan veri girmesi veya bir sayıyı 0’a bölmeye çalışması istisnai birer
durumdur ve yazdığımız programlarınexception(istisna) üretmesine yol açar.

Böylece hata (error), kusur (bug) ve istisna (exception) arasındaki
farkları şöyle bir gözden geçirmiş olduk. Yalnız burada şunu söylemekte yarar
var: Bu üç kavram arasındaki fark belli belirsizdir. Yani bu kavramların çoğu
yerde birbirlerinin yerine kullanıldığını da görebilirsiniz. Örneğinexceptionkavramı için Türkçe’de çoğu zaman ‘hata’ kelimesini kullanıyoruz. Zaten dikkat
ederseniz bu bölümün başlığı da ‘İstisna Yakalama’ değil, ‘Hata Yakalama’dır.
Aynı şekilde, İngilizcede de bu kavramların çoğu yerde birbirlerinin yerine
kullanıldığını görebilirsiniz. Dolayısıyla, konuya karşı özel bir ilginiz yoksa,
hata, kusur ve istisna kavramlarını birbirinden ayırmak için kendinizi
zorlamanıza gerek yok. Bu üç kavram çoğu zaman birbirinin yerine kullanılıyor da
olsa, aslında aralarında bazı farklar olduğunu öğrenmişseniz bu bölüm amacına
ulaşmış demektir.

Konuyla ilgili temel bilgileri edindiğimize göre asıl meseleye geçebiliriz…

### try… except…

Bir önceki bölümde hatalardan ve hataları yakalamaktan söz ettik. Peki bu
hataları nasıl yakalayacağız?

Python’da hata yakalama işlemleri içintry...except...bloklarından
yararlanılır. Hemen bir örnek verelim:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except ValueError:
 print("Lütfen sadece sayı girin!")

```

Biliyoruz ki, bir veriyi sayıya dönüştürmek istediğimizde eğer kullanıcı sayı
değerli bir veri yerine harf değerli bir veri girerse programımız çöker.
Dolayısıylaint(ilk_sayı)veint(ikinci_sayı)kodları, kullanıcının
gireceği veri türüne göre hata üretme potansiyeline sahiptir. O yüzden, burada
hata vereceğini bildiğimiz o kodlarıtrybloğu içine aldık.

Yine bildiğimiz gibi, veri dönüştürme işlemi sırasında kullanıcının uygun
olmayan bir veri girmesi halinde üretilecek hata birValueError’dır.
Dolayısıylaexceptbloğu içine yazacağımız hata türünün adı daValueErrorolacaktır. O yüzdenValueErroradlı hatayı yakalayabilmek
için şu satırları yazdık:

```python
except ValueError:
 print("Lütfen sadece sayı girin!")

```

Burada bu kodlarla Python’a şu emri vermiş olduk:

Eğertrybloğu içinde belirtilen işlemler sırasında birValueErrorile karşılaşırsan bunu görmezden gel ve normal şartlar altında kullanıcıya
göstereceğin hata mesajını gösterme. Onun yerine kullanıcıyaLütfensadecesayıgirin!uyarısını göster.

Yukarıda Türkçeye çevirdiğimiz emri Pythoncada nasıl ifade ettiğimize dikkat
edin. Temel olarak şöyle bir yapıyla karşı karşıyayız:

```python
try:
 hata verebileceğini bildiğimiz kodlar
except HataAdı:
 hata durumunda yapılacak işlem

```

Gelin isterseniz bir örnek daha verelim.

Hatırlarsanız bir sayının0’a bölünmesinin mümkün olmadığını, böyle bir
durumda programımızın hata vereceğini söylemiştik. Bu durumu teyit etmek için
etkileşimli kabukta şu kodu deneyebilirsiniz:

```python
>>> 2 / 0

```

Bu kod şöyle bir hata mesajı verecektir:

```python
>>> 2 / 0

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero

```

Daha önce de söylediğimiz gibi, bu hata mesajında bizi ilgilendiren kısımZeroDivisionError. Demek ki bir sayı0’a bölündüğünde PythonZeroDivisionErrorveriyormuş. O halde şöyle bir kod yazabiliriz:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except ZeroDivisionError:
 print("Bir sayıyı 0'a bölemezsiniz!")

```

Gördüğünüz gibi, Python’ınZeroDivisionErrorvereceğini bildiğimiz durumlara
karşı bu hata türünü yakalama yoluna gidiyoruz. Böylece kullanıcıya anlamsız ve
karmaşık hata mesajları göstermek ve daha da kötüsü, programımızın çökmesine
sebep olmak yerine daha anlaşılır mesajlar üretiyoruz.

Yukarıdaki kodlarda özellikle bir nokta dikkatinizi çekmiş olmalı: Dikkat
ederseniz yukarıdaki kodlar aslında bir değil iki farklı hata üretme
potansiyeline sahip. Eğer kullanıcı sayı değerli veri yerine harf değerli bir
veri girerseValueError, eğer bir sayıyı0’a bölmeye çalışırsa daZeroDivisionErrorhatası alıyoruz. Peki aynı kodlarda iki farklı hata türünü
nasıl yakalayacağız?

Çok basit:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except ZeroDivisionError:
 print("Bir sayıyı 0'a bölemezsiniz!")
except ValueError:
 print("Lütfen sadece sayı girin!")

```

Gördüğünüz gibi çözüm gayet mantıklı. Birden fazla hata türü üreteceğini
bildiğimiz kodları yine tek birtrybloğu içine alıyoruz. Hata türlerini ise
ayrıexceptblokları içinde ele alıyoruz.

Bir program yazarken, en iyi yaklaşım, yukarıda yaptığımız gibi, her hata türü
için kullanıcıya ayrı bir uyarı mesajı göstermektir. Böylece kullanıcılarımız
bir hatayla karşılaştıklarında sorunu nasıl çözebilecekleri konusunda en azından
bir fikir sahibi olabilirler.

Dediğimiz gibi, her hata için ayrı bir mesaj göstermek en iyisidir. Ama tabii
dilerseniz hata türlerini gruplayıp hepsi için tek bir hata mesajı göstermeyi de
tercih edebilirsiniz. Bunu nasıl yapacağımızı görelim:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except (ValueError, ZeroDivisionError):
 print("Bir hata oluştu!")

```

Gördüğünüz gibi, buradaValueErrorveZeroDivisionErroradlı hata
türlerini tek bir parantez içinde topladık. Burada dikkat edeceğimiz nokta, bu
hata türlerini gruplarken bunları parantez içine almak ve birbirlerinden
virgülle ayırmaktır.

Bu arada, gördüğünüz gibi yukarıdaki programlar sadece bir kez çalışıp
kapanıyor. Ama biz bu programları tekrar tekrar nasıl çalıştırabileceğimizi
gayet iyi biliyoruz:

```python
while True:
 ilk_sayı = input("ilk sayı (Programdan çıkmak için q tuşuna basın): ")

 if ilk_sayı == "q":
 break

 ikinci_sayı = input("ikinci sayı: ")

 try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
 except (ValueError, ZeroDivisionError):
 print("Bir hata oluştu!")
 print("Lütfen tekrar deneyin!")

```

Python’da hata yakalamanın en yaygın yolu yukarıda gösterdiğimiz gibi kodlarıtry...exceptblokları içine almaktır. Programcılık maceranızın büyük
bölümünde bu yapıyı kullanacaksınız. Ama bazen, karşı karşıya olduğunuz duruma
veya ihtiyacınıza göretry...exceptbloklarının farklı varyasyonlarını
kullanmanız gerekebilir. İşte şimdi biz de bu farklı varyasyonların neler
olduğunu incelemeye çalışacağız.

### try… except… as…

Bildiğiniz gibi, Python bir programın çalışması esnasında hata üretirken çıktıda
hata türünün adıyla birlikte kısa bir hata açıklaması veriyor. Yani mesela şöyle
bir çıktı üretiyor:

```python
ValueError: invalid literal for int() with base 10: 'f'

```

Burada ‘ValueError’ hata türünün adı, ‘invalid literal for int() with base 10:
‘f’’ ise hatanın açıklamasıdır. Eğer istersek, yazdığımız programda bu hata
açıklamasına erişebiliriz. Dikkatlice bakın:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except ValueError as hata:
 print(hata)

```

Bu programı çalıştırıp sayı değerli olmayan bir veri girersek hata çıktısı şöyle
olacaktır:

```python
invalid literal for int() with base 10: 'f'

```

Gördüğünüz gibi, bu defa çıktıda hata türünün adı (ValueError) görünmüyor.
Onun yerine sadece hata açıklaması var.

Diyelim ki kullanıcıya olası bir hata durumunda hem kendi yazdığınız hata
mesajını, hem de özgün hata mesajını göstermek istiyorsunuz. İşte yukarıdaki
yapı böyle durumlarda işe yarayabilir:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except ValueError as hata:
 print("Sadece sayı girin!")
 print("orijinal hata mesajı: ", hata)

```

Bu arada, biraz önce yaptığımız gibi, hata türlerini grupladığınızda da bu
yöntemi kullanabilirsiniz:

```python
ilk_sayı = input("ilk sayı: ")
ikinci_sayı = input("ikinci sayı: ")

try:
 sayı1 = int(ilk_sayı)
 sayı2 = int(ikinci_sayı)
 print(sayı1, "/", sayı2, "=", sayı1 / sayı2)
except (ValueError, ZeroDivisionError) as hata:
 print("Bir hata oluştu!")
 print("orijinal hata mesajı: ", hata)

```

BuradaexceptfalancaHataasfilancayapısını kullanarakfalancaHata’yıfilancaolarak isimlendiriyor ve daha sonra bu ismi istediğimiz gibi
kullanabiliyoruz. Böylece bütün hata türleri için hem kendi yazdığınız mesajı
görüntüleyebiliyor, hem de özgün hata mesajını da çıktıya eklediğimiz için,
kullanıcıya hata hakkında en azından bir fikir sahibi olma imkanı vermiş
oluyoruz.

### try… except… else…

Daha önce de dediğimiz gibi, Python’da hata yakalama işlemleri için çoğunluklatry...except...bloklarını bilmek yeterli olacaktır. İşlerimizin büyük
kısmını sadece bu blokları kullanarak halledebiliriz. Ancak Python bize bu
konuda, zaman zaman işimize yarayabilecek başka araçlar da sunmaktadır. İştetry...except...else...blokları da bu araçlardan biridir. Bu bölümde
kısaca bu blokların ne işe yaradığından söz edeceğiz.

Öncelikletry...except...else...bloğunun ne işe yaradığına bakalım.
Esasında biz buelsedeyimini daha önce de ‘koşullu ifadeler’ konusunu
işlerken görmüştük. Buradaki kullanımı da zaten hemen hemen aynıdır. Diyelim ki
elimizde şöyle bir şey var:

```python
try:
 bölünen = int(input("bölünecek sayı: "))
 bölen = int(input("bölen sayı: "))
 print(bölünen/bölen)
except ValueError:
 print("hata!")

```

Burada eğer kullanıcı sayı yerine harf girerseValueErrorhatası alırız. Bu
hatayıexceptValueError:ifadesiyle yakalıyoruz ve hata verildiğinde
kullanıcıya bir mesaj göstererek programımızın çökmesini engelliyoruz. Ama
biliyoruz ki, bu kodları çalıştırdığımızda Python’ın verebileceği tek hataValueErrordeğildir. Eğer kullanıcı bir sayıyı 0’a bölmeye çalışırsa PythonZeroDivisionErroradlı hatayı verecektir. Dolayısıyla bu hatayı da yakalamak
için şöyle bir şey yazabiliriz:

```python
try:
 bölünen = int(input("bölünecek sayı: "))
 bölen = int(input("bölen sayı: "))
 print(bölünen/bölen)
except ValueError:
 print("Lütfen sadece sayı girin!")
except ZeroDivisionError:
 print("Bir sayıyı 0'a bölemezsiniz!")

```

Bu şekilde hemValueErrorhatasını hem deZeroDivisionErrorhatasını
yakalamış oluruz. Bu kodların özelliği,except...bloklarının tek birtry...bloğunu temel almasıdır. Yani biz burada bütün kodlarımızı tek birtry...bloğu içine tıkıştırıyoruz. Bu blok içinde gerçekleşen hataları da
daha sonra tek tekexcept...blokları yardımıyla yakalıyoruz. Ama eğer biz
istersek bu kodlarda verilebilecek hataları gruplamayı da tercih edebiliriz:

```python
try:
 bölünen = int(input("bölünecek sayı: "))
 bölen = int(input("bölen sayı: "))
except ValueError:
 print("Lütfen sadece sayı girin!")
else:
 try:
 print(bölünen/bölen)
 except ZeroDivisionError:
 print("Bir sayıyı 0'a bölemezsiniz!")

```

Burada yaptığımız şey şu: İlktry...except...bloğu yardımıyla öncelikleint(input())fonksiyonu ile kullanıcıdan gelecek verinin sayı olup
olmadığını denetliyoruz. Ardından birelse...bloğu açarak, bunun içinde
ikincitry...except...bloğumuzu devreye sokuyoruz. Burada da bölme
işlemini gerçekleştiriyoruz. Kullanıcının bölme işlemi sırasında0sayısını
girmesi ihtimaline karşı daexceptZeroDivisionErrorifadesi yardımıyla
olası hatayı göğüslüyoruz. Bu şekilde bir kodlamanın bize getireceği avantaj,
hatalar üzerinde belli bir kontrol sağlamamıza yardımcı olmasıdır. Yukarıdaki
kodlar sayesinde hatalara bir nevi ‘teker teker gelin!’ mesajı vermiş oluyoruz.
Böylelikle her blok içinde sadece almayı beklediğimiz hatayı karşılıyoruz.
Mesela yukarıda ilktry...bloğu içindeki dönüştürme işlemi yalnızcaValueErrorhatası verebilir.else:bloğundan sonrakitry...bloğunda
yer alan işlem ise ancakZeroDivisionErrorverecektir. Biz yukarıda
kullandığımız yapı sayesinde her bir hatayı tek tek ve yeri geldiğinde
karşılıyoruz. Bu durumun aksine, bölümün ilk başında verdiğimiztry...exceptbloğunda hemValueErrorhem deZeroDivisionErrorhatalarının
gerçekleşme ihtimali bulunuyor. Dolayısıyla biz orada bütün hataları tek birtry...bloğu içine sıkıştırmış oluyoruz. İşteelse:bloğu bu sıkışıklığı
gidermiş oluyor. Ancak sizi bir konuda uyarmak isterim: Bu yapı, her akla
geldiğinde kullanılacak bir yapı değildir. Büyük programlarda bu tarz bir
kullanım kodlarınızın darmadağın olmasına, kodlarınız üzerindeki denetimi
tamamen kaybetmenize de yol açabilir. Sonunda da elinizde bölük pörçük bir kod
yığını kalabilir. Zaten açıkça söylemek gerekirsetry...except...else...yapısının çok geniş bir kullanım alanı yoktur. Bu yapı ancak çok nadir
durumlarda kullanılmayı gerektirebilir. Dolayısıyla bu üçlü yapıyı hiç
kullanmadan bir ömrü rahatlıkla geçirebilirsiniz.

### try… except… finally…

try...except...else...yapılarının dışında, Python’ın bize sunduğu bir
başka yapı datry...except...finally...yapılarıdır. Bunu şöyle
kullanıyoruz:

```python
try:
 ...bir takım işler...
except birHata:
 ...hata alınınca yapılacak işlemler...
finally:
 ...hata olsa da olmasa da yapılması gerekenler...

```

finally..bloğunun en önemli özelliği, programın çalışması sırasında
herhangi bir hata gerçekleşse de gerçekleşmese de işletilecek olmasıdır. Eğer
yazdığınız programda mutlaka ama mutlaka işletilmesi gereken bir kısım varsa, o
kısmıfinally...bloğu içine yazabilirsiniz.

finally...bloğu özellikle dosya işlemlerinde işimize yarayabilir. Henüz
Python’da dosyalarla nasıl çalışacağımızı öğrenmedik, ama ben şimdilik size en
azından dosyalarla çalışma prensibi hakkında bir şeyler söyleyeyim.

Genel olarak Python’da dosyalarla çalışabilmek için öncelikle bilgisayarda
bulunan bir dosyayı okuma veya yazma kipinde açarız. Dosyayı açtıktan sonra bu
dosyayla ihtiyacımız olan birtakım işlemler gerçekleştiririz. Dosyayla işimiz
bittikten sonra ise dosyamızı mutlaka kapatmamız gerekir. Ancak eğer dosya
üzerinde işlem yapılırken bir hata ile karşılaşılırsa dosyamızı kapatma işlemini
gerçekleştirdiğimiz bölüme hiç ulaşılamayabilir. İştefinally...bloğu böyle
bir durumda işimize yarayacaktır:

```python
try:
 dosya = open("dosyaadı", "r")
 ...burada dosyayla bazı işlemler yapıyoruz...
 ...ve ansızın bir hata oluşuyor...
except IOError:
 print("bir hata oluştu!")
finally:
 dosya.close()

```

Buradafinally...bloğu içine yazdığımızdosya.close()ifadesi dosyamızı
güvenli bir şekilde kapatmaya yarıyor. Bu blok, yazdığımız program hata verse de
vermese de işletilecektir.

### raise

Bazen, yazdığımız bir programda, kullanıcının yaptığı bir işlem normal şartlar
altında hata vermeyecek olsa bile biz ona ‘Python tarzı’ bir hata mesajı
göstermek isteyebiliriz. Böyle bir durumda ihtiyacımız olan şey Python’ın bize
sunduğuraiseadlı deyimdir. Bu deyim yardımıyla duruma özgü hata mesajları
üretebiliriz. Bir örnek verelim:

```python
bölünen = int(input("bölünecek sayı: "))

if bölünen == 23:
 raise Exception("Bu programda 23 sayısını görmek istemiyorum!")

bölen = int(input("bölen sayı: "))
print(bölünen/bölen)

```

Burada eğer kullanıcı23sayısını girerse, kullanıcıya bir hata mesajı
gösterilip programdan çıkılacaktır. Biz bu kodlardaExceptionadlı genel
hata mesajını kullandık. BuradaExceptionyerine her istediğimizi yazamayız.
Yazabileceklerimiz ancak Python’da tanımlı hata mesajları olabilir. ÖrneğinNameError,TypeError,ZeroDivisionError,IOError, vb…

Bir örnek verelim:

```python
tr_karakter = "şçğüöıİ"

parola = input("Parolanız: ")

for i in parola:
 if i in tr_karakter:
 raise TypeError("Parolada Türkçe karakter kullanılamaz!")
 else:
 pass

print("Parola kabul edildi!")

```

Bu kodlar çalıştırıldığında, eğer kullanıcı, içinde Türkçe karakter geçen bir
parola yazarsa kendisineTypeErrortipinde bir hata mesajı gösteriyoruz.
Eğer kullanıcının parolası Türkçe karakter içermiyorsa hiçbir şey yapmadan
geçiyoruz ve bir sonraki satırda kendisine ‘Parola kabul edildi!’ mesajını
gösteriyoruz.

raisedeyimini, bir hata mesajına ek olarak bir işlem yapmak istediğimizde
de kullanabiliriz. Örneğin:

```python
try:
 bölünen = int(input("bölünecek sayı: "))
 bölen = int(input("bölen sayı: "))
 print(bölünen/bölen)
except ZeroDivisionError:
 print("bir sayıyı 0'a bölemezsiniz")
 raise

```

Burada, eğer kullanıcı bir sayıyı0’a bölmeye çalışırsa, normal bir şekildeZeroDivisionErrorhatası verilecek ve programdan çıkılacaktır. Ama bu hata
mesajıyla birlikte kullanıcıya ‘bir sayıyı 0’a bölemezsiniz,’ uyarısını da
gösterme imkanını elde edeceğiz. Yani buradaexceptZeroDivisionErrorbloğunu herhangi bir hatayı engellemek için değil, hataya ilave bilgi eklemek
için kullanıyoruz. Bunu yapmamızı sağlayan şey tabii ki bu kodlar içinde görünenraiseadlı deyimdir…

### assert

Bazen programımızda bir hata yaptığımızda bu hatayı bulmakta zorlanabiliriz.printfonksiyonunu kullanarak bu hatamızı bulmaya çalışabiliriz ancak
bu da programımız ekrana çok fazla yazdırma işlemi yapıyorsa gözden kaçabilir.
Böyle durumlardaassertifadesini kullanabiliriz.assertifadesi
aynı zamanda hata yükseltmenin kısa bir yoludur. Ancakassertifadesini
kullanarak sadeceAssertionErrortüründe bir hata yükseltebiliriz. Normalderaisekullanmamız daha doğru olacaktır. Dediğimiz gibiassertifadesi
hızlı bir şekilde kodumuzdaki hataları belirlemek için kullanılır.
Şimdi şöyle bir kodumuz olduğunu düşünelim:

```python
giriş = input("Merhaba! Adın ne? ")
if len(giriş) == 0:
 raise AssertionError("İsim bölümü boş.")
print("Hoşgeldiniz.")

```

Bu koduassertkullanarak şu şekilde de yazabilirdik:

```python
giriş = input("Merhaba! Adın ne? ")
assert len(giriş) != 0 , "İsim bölümü boş."
print("Hoşgeldiniz.")

```

Dikkat edersenizassertifadesinin şu şekilde kullanıldığını görebilirsiniz:

```python
assert ifade , mesaj

```

BuradaifadebirboolyaniTrueveyaFalseolabileceği gibi, (aynıif’deki gibi)boolfonksiyonu ile birlikte kullanılabilecek bir nesne de olabilir. Sonuç olarak
eğerifade’nin değeriTrueiseassertifademiz çalışmayacak,Falseise
çalışacaktır. Yaniassertifademizin içine doğru olmasını istediğimiz durumu yazmalıyız ki
eğer yanlış olursa hata yükseltsin. Zatenassertkelimesi“iddia etmek”anlamına gelir. Yani bizassertifadesini kullanarak bir ifadenin doğru olduğunu iddia ediyoruz, bu iddiamız yanlış ise Python bir hata yükseltiyor. Ayrıcaassertifademiz çalıştığında bir hata yükseleceği için program da sonlanacaktır, yani bu özelliği istemediğimiz bir durum gerçekleştiğinde
programı sonlandırmak için de kullanabiliriz.mesajise hata verildiğinde ekrana yazılmasını
istediğimiz mesajdır. Tabii kiraiseifadesinde olduğu gibi burada da bir mesaj vermek zorunda
değiliz. Yaniassertifadesini şu şekilde de kullanabiliriz:

```python
assert ifade

```

Şimdi baştaki örneğimize geri dönersek:

```python
giriş = input("Merhaba! Adın ne? ")
assert len(giriş) != 0 , "İsim bölümü boş."
print("Hoşgeldiniz.")

```

Bu kodumuzu çalıştırdığımızda:

```python
Merhaba! Adın ne? Ali
Hoşgeldiniz.
>>>

```

girişdeğişkenimizin uzunluğu0olmadığı için bir hata verilmedi. Şimdi
aynı kodu çalıştırıp hiçbir şey yazmadanentertuşuna basalım:

```python
.. code-block:: pycon

```

```python
>>> Merhaba! Adın ne?
Traceback (most recent call last):
 File "C:\Users\Kullanıcı\Desktop\assert_ifadesi.py", line 2, in <module>
 assert len(giriş) != 0 , "İsim bölümü boş."
AssertionError: İsim bölümü boş.

```

Gördüğünüz gibiassertifadesini de bu şeklide kullanıyoruz. Burada bir şeye
dikkat etmek lazım kiassertbir fonksiyon değildir, bu yüzden parantezler
ile şu şekildekullanılmamalıdır:

```python
assert(ifade)

```

Bu kullanım hata vermeyecek olsa da farkında olmadan -ileride öğreneceğimiz
bir konu- bir demet oluşturmuş oluyoruz.

Son olarak büyük bir proje yazdığımızda, şu örnekteki gibi:

```python
giriş = input("Merhaba! Adın ne? ")
if len(giriş) == 0:
 raise AssertionError("İsim bölümü boş.")
print("Hoşgeldiniz.")

```

ifveraiseifadesi kullanmak yerineassertkullanmamızın iki avantajından bahsedelim. Öncelikle istediğiniz zaman geliştirme arayüzünüzün“Bul (Find)”özelliğini kullanarak bu anahtar kelimeleri
bulup silebilir veya yorum satırı haline getirebilirsiniz. Bu özellik uzun bir kod yazdığımızda zaman kazanmamızı sağlar.
İkinci olarak da python yorumlayıcısını komut satırından-Oparametresi (optimizeanlamına gelir) ile şu şekilde çağırdığımızda:

```python
C:\Users\User> python -O kod_dosyası

```

kod_dosyasıprogramımızdaki bütünassertifadeleri python yorumlayıcısı tarafından yok sayılır ve hiçbiri çalıştırılmaz. Yaniassertifadelerinin hepsini yorum satırı haline getirmek istediğimizde bunun ile uğraşmak yerine bu özelliği kullanabiliriz.

Konu ile alakalı daha çok örnek içinburayabakabilirsiniz.

### Bütün Hataları Yakalamak

Şimdiye kadar yaptığımız bütün örneklerdeexcept...bloğunu bir hata mesajı
adıyla birlikte kullandık. Yani örneklerimiz şuna benziyordu:

```python
try:
 ....birtakım işler...
except ZeroDivisionError:
 ...hata mesajı...

```

Yukarıdaki kod yardımıyla sadeceZeroDivisionErroradlı hatayı
yakalayabiliriz. Eğer yazdığımız program başka bir hata daha veriyorsa, o hata
mesajı yukarıdaki blokların kapsamı dışında kalacaktır. Ama eğer istersek
yukarıdaki kodu şu şekilde yazarak olası bütün hataları yakalayabiliriz:

```python
try:
 ....birtakım işler...
except:
 ...hata mesajı...

```

Gördüğünüz gibi, burada herhangi bir hata adı belirtmedik. Böylece Python,
yazdığımız programda hangi hata oluşursa oluşsun hepsini yakalayabilecektir.

Bu yöntem gözünüze çok pratik görünmüş olabilir, ama aslında hiç de öyle
sayılmaz. Hatta oldukça kötü bir yöntem olduğunu söyleyebiliriz bunun. Çünkü bu
tarz bir kod yazımının bazı dezavantajları vardır. Örneğin bu şekilde bütün hata
mesajlarını aynı kefeye koyarsak, programımızda ne tür bir hata oluşursa
oluşsun, kullanıcıya hep aynı mesajı göstermek zorunda kalacağız. Bu da,
herhangi bir hata durumunda kullanıcıyı ne yapması gerektiği konusunda doğru
düzgün bilgilendiremeyeceğimiz anlamına geliyor. Yani kullanıcı bir hataya sebep
olduğunda tersliğin nereden kaynaklandığını tam olarak kestiremeyecektir.

Ayrıca, eğer kendimiz bir program geliştirirken sürekli olarak bu tarz bir
yazımı benimsersek, kendi kodlarımızdaki hataları da maskelemiş oluruz.
Dolayısıyla, Python yukarıdaki geniş kapsamlıexcept...bloğu nedeniyle
programımızdaki bütün hataları gizleyeceği için, programımızdaki potansiyel
aksaklıkları görme imkanımız olmaz. Dolayısıyla bu tür bir yapıdan olabildiğince
kaçınmakta fayda var. Ancak elbette böyle bir kod yazmanızı gerektiren bir
durumla da karşılaşabilirsiniz. Örneğin:

```python
try:
 birtakım kodlar
except ValueError:
 print("Yanlış değer")
except ZeroDivisionError:
 print("Sıfıra bölme hatası")
except:
 print("Beklenmeyen bir hata oluştu!")

```

Burada olası bütün hata türlerini yakaladıktan sonra, bunların dışında bizim o
anda öngöremediğimiz bir hatanın oluşması ihtimaline karşıexcept:kodunu
kullanarak kullanıcıya genel bir hata mesajı göstermeyi tercih edebiliriz.
Böylece beklenmeyen bir hata meydana gelmesi durumunda da programımız çökmek
yerine çalışmaya devam edebilecektir.

### Örnek Uygulama

Hata yakalama konusunu bütün ayrıntılarıyla inceledik. Gelin şimdi isterseniz
ufak bir örnek yapalım.

Hatırlarsanız bir kaç bölüm önce şöyle bir uygulama yazmıştık:

```python
import sys

_2x_metni = """
Python'ın 2.x sürümlerinden birini kullanıyorsunuz.
Programı çalıştırabilmek için sisteminizde Python'ın
3.x sürümlerinden biri kurulu olmalı."""

_3x_metni = "Programa hoşgeldiniz."

if sys.version_info.major < 3:
 print(_2x_metni)
else:
 print(_3x_metni)

```

Bu programın ne iş yaptığını biliyorsunuz. Bu program yardımıyla,
kullanıcılarımızın bilgisayarlarındaki Python sürümünü kontrol edip,
programımızın kullanılan sürüme göre tepki vermesini sağlıyoruz.

Ancak burada çok ciddi bir problem var. Python’ın 2.7 öncesi sürümlerindesysmodülününversion_info()metodu farklı çıktılar verir. Mesela Python’ın 2.7
öncesi sürümlerindeversion_info()metodununmajor,minorveyamicrogibi nitelikleri bulunmaz. Bu nitelikler Python programlama diline 2.7 sürümüyle
birlikte geldi. Dolayısıyla yukarıdaki programı Python’ın 2.7 öncesi
sürümlerinden biriyle çalıştıran kullanıcılarınız istediğiniz çıktıyı
alamayacak, Python bu kullanıcalara şuna benzer bir hata mesajı göstererek
programın çökmesine sebep olacaktır:

```python
AttributeError: 'tuple' object has no attribute 'major'

```

Python’ın 2.7 öncesi sürümlerinin kurulu olduğu bilgisayarlarda da programınızın
en azından çökmemesi ve makul bir çıktı verebilmesi için yukarıdaki kodlar şöyle
yazabilirsiniz:

```python
import sys

_2x_metni = """
Python'ın 2.x sürümlerinden birini kullanıyorsunuz.
Programı çalıştırabilmek için sisteminizde Python'ın
3.x sürümlerinden biri kurulu olmalı."""

_3x_metni = "Programa hoşgeldiniz."

try:
 if sys.version_info.major < 3:
 print(_2x_metni)
 else:
 print(_3x_metni)
except AttributeError:
 print(_2x_metni)

```

Gördüğünüz gibi,AttributeErroradlı hatayı vereceğini bildiğimiz kısmı birtry...exceptbloğu içine aldık. Eğer programımızAttributeErrorhatasını veriyorsa, programımızın çalıştırıldığı sistem Python’ın 2.7 sürümünden
daha düşük bir sürümü kullanıyor demektir. O yüzden kullanıcıya_2x_metni’ni
gösteriyoruz.

Elbette yukarıdaki programı yazmanın çok daha düzgün yolları vardır. Ama biz
hata yakalama yöntemlerinin buna benzer durumlarda da bir alternatif olarak
kullanılabileceğini bilelim. Ayrıca, dediğimiz gibi,try...exceptblokları
yukarıdaki sorunun çözümü için en uygun araçlar olmasa da, bazı durumlarda
hatayı önlemenin makul tek yoludur.

## Karakter Dizileri

Buraya gelene kadar Python programlama diline ilişkin epey bilgi edindik. Artık
yazdığımız programlardainput()fonksiyonu sayesinde kullanıcıyla iletişim
kurabiliyor;if,elif,elsedeyimleri yardımıyla programlarımızın
karar vermesini sağlayabiliyor; işleçler ve döngüler yoluyla programlarımızı
istediğimiz sayıda çalıştırabiliyoruz. Eğer buraya kadar olan bölümleri
dikkatlice takip ettiyseniz, şu ana kadar öğrendiklerinize dayanarak, Python’ı
giriş düzeyinde bildiğinizi rahatlıkla iddia edebilirsiniz. Zira şimdiye kadar
öğrendiklerinizi kullanarak ufak tefek de olsa işe yarar programlar yazabilecek
durumdasınız.

Buraya kadar öğrendiğimiz bilgiler Python programlama dilinin temellerini
oluşturuyordu. Temel Python bilgilerini edindiğimize göre, artık başlangıç-orta
düzey arası konuları incelemeye başlayabileceğiz.

Bu bölümde, önceki derslerde üstünkörü bakıp geçtiğimiz bir konu olan karakter
dizilerini çok daha derinlemesine ele alacağız. Python programlama dili içindeki
önemi nedeniyle bu bölüm epey uzun olacak.

Aslında biz karakter dizisi kavramının ne olduğunu biliyoruz. Çok kaba bir
şekilde ifade etmek gerekirse, karakter dizileri, adından da anlaşılacağı gibi,
karakterlerin bir araya gelmesiyle oluşan bir dizidir. Karakter dizileri; tek,
çift veya üç tırnak içinde gösterilen, öteki veri tiplerinden de bu tırnaklar
aracılığıyla ayırt edilen özel bir veri tipidir. Teknik olarak ifade etmek
gerekirse, bir nesneyitype()fonksiyonu yardımıyla sorguladığımızda, eğer<class ‘str’>çıktısı alıyorsak bu nesne bir karakter dizisidir.

Her ne kadar ayrıntılarına girmemiş de olsak, dediğimiz gibi, biz karakter
dizilerini daha ilk bölümlerden bu yana her fırsatta kullanıyoruz. Dolayısıyla
bu veri tipinin ne olduğu konusunda bir sıkıntımız yok. Bu bölümde, şimdiye
kadar karakter dizileri ile ilgili öğrendiğimiz şeylere ek olarak, karakter
dizilerin metotlarından da söz edeceğiz.

Peki bu ‘metot’ denen şey de ne oluyor?

Kabaca ifade etmek gerekirse, metotlar Python’da nesnelerin niteliklerini
değiştirmemizi, sorgulamamızı veya bu nesnelere yeni özellikler katmamızı
sağlayan araçlardır. Metotlar sayesinde karakter dizilerini istediğimiz gibi
eğip bükebileceğiz.

Elbette bu bölümde bahsedeceğimiz tek şey karakter dizilerinin metotları
olmayacak. Bu bölümde aynı zamanda karakter dizilerinin yapısı ve özelliklerine
dair söyleyeceklerimiz de olacak.

Python’da şimdiye kadar yapabildiğimiz şeylerin sizi tatmin etmekten uzak
olduğunu, daha fazlasını yapabilmek için sabırsızlandığınızı tahmin
edebiliyorum. O halde ne duruyoruz, hiç vakit kaybetmeden yola koyulalım.

### Karakter Dizilerinin Öğelerine Erişmek

Python ile programlama yaparken karakter dizileri ile iki şekilde
karşılaşabilirsiniz: Birincisi, bir karakter dizisini doğrudan kendiniz
tanımlamış olabilirsiniz. İkincisi, karakter dizisi size başka bir kaynak
aracılığıyla gelmiş olabilir (meselainput()fonksiyonu yardımıyla
kullanıcıdan aldığınız bir veri).

Python’da kendi tanımladığınız ya da herhangi başka bir kaynaktan gelen karakter
dizilerine erişmenin birkaç farklı yolu vardır. Örneğin:

```python
>>> nesne = "karakter dizisi"

```

Burada değeri“karakter dizisi”olannesneadlı bir değişken tanımladık.
Yazdığımız programlarda bu değişkene erişmek için, değişkenin adını kullanmamız
yeterlidir. Örneğin:

```python
>>> print(nesne)

```

Bu komut bize karakter dizisinin tamamını verecektir.

Bir karakter dizisini yukarıda gördüğümüz gibi kendimiz tanımlayabiliriz. Bunun
dışında, meselainput()fonksiyonuyla kullanıcıdan aldığımız verilerin de
birer karakter dizisi olacağını biliyoruz:

```python
veri = input("Herhangi bir şey: ")

```

Tıpkı kendi tanımladığımız karakter dizilerinde olduğu gibi, kullanıcıdan gelen
karakter dizilerini de aşağıdaki komut yardımıyla ekranda görüntüleyebiliriz:

```python
print(veri)

```

Bu komut da bizeverideğişkeninin tuttuğu karakter dizisinin tamamını
verecektir.

Ayrıca istersek bu karakter dizilerini birfordöngüsü içine alabilir,
böylece bu dizinin öğelerine tek tek de erişebiliriz:

```python
for karakter in nesne:
 print(karakter)

```

fordöngüsüyle elde ettiğimiz bu etkiyi şu kodlar yardımıyla da elde
edebileceğimizi gayet iyi biliyor olmalısınız:

```python
print(*nesne, sep="\n")

```

Önceki derslerde verdiğimiz örneklerden de bildiğiniz gibi, karakter dizilerinin
öğelerine yukarıdaki yöntemlerle tek tek erişebilmemiz sayesinde herhangi bir
işlemi karakter dizilerinin bütün öğelerine bir çırpıda uygulayabiliyoruz.
Mesela:

```python
nesne = "123456789"

for n in nesne:
 print(int(n) * 2)

```

Buradanesnedeğişkeni içindeki sayı değerli karakter dizilerininolarak
adlandırdıktan sonra,ndeğişkenlerinin her birini tek tek2sayısı ile
çarptık. Yani çarpma işlemini karakter dizisinin bütün öğelerine tek seferde
uygulayabildik. Bu arada, yukarıdaki örnektenesnedeğişkeninin her bir
öğesinifordöngüsü içindeint()fonksiyonu yardımıyla tam sayıya
çevirdiğimizi görüyorsunuz. Daha önce de defalarca söylediğimiz gibi, Python’da
o anda elinizde olan verinin tipini bilmeniz çok önemlidir. Eğer kendi
yazdığınız veya meselainput()fonksiyonundan gelen bir verinin karakter
dizisi olduğunu bilmezseniz yukarıdaki kodları şu şekilde yazma gafletine
düşebilirsiniz:

```python
nesne = "123456789"

for n in nesne:
 print(n * 2)

```

Bu kodlar çalıştırıldıktan sonra hiç beklemediğiniz sonuçlar verecektir:

```python
11
22
33
44
55
66
77
88
99

```

Gördüğünüz gibi, aslındanesneiçindeki öğeleri2ile çarpmak isterken, biz
her bir öğeyi iki kez ekrana yazdırmış olduk. Çünkü bildiğiniz gibi karakter
dizileri ile aritmetik işlemler yapamıyoruz. Eğer sayı değerli karakter dizileri
arasında aritmetik işlem yapacaksak öncelikle bu karakter dizilerini sayıya
çevirmemiz gerekir. Ayrıca gerçek bir program içinde yukarıdaki gibi bir durumun
ne kadar yıkıcı sonuçlar doğuracabileceğini düşünün. Yukarıdaki program çalışma
sırasında hiçbir hata vermeyeceği için, siz programınızın düzgün çalıştığını
zannederek hayatınıza devam edeceksiniz. Ama belki de yukarıdaki sinsi hata
yüzünden, programınızı kullanan bir şirket veri, zaman ve para kaybına
uğrayacak.

Yukarıdaki örneklerde bir şey daha dikkatinizi çekmiş olmalı: Gördüğünüz gibi,
karakter dizisinin öğelerine erişirken bu öğelerin tamamını elde ediyoruz.
Meselaprint(nesne)komutunu verdiğimizde veyanesnedeğişkenini bir döngü
içine aldığımızda sonuç olarak elde ettiğimiz şey, ilgili karakter dizisinin
tamamıdır. Yani aslında karakter dizisinin hangi öğesine erişeceğimizi
seçemiyoruz. Peki ya biz bir karakter dizisinin öğelerinin tamamına değil de,
sadece tek bir öğesine erişmek istersek ne yapacağız? Mesela yukarıdaki örnektenesneadlı değişken içindeki sayıların tamamını değil de sadece tek bir
öğesini (veya belli bir ölçüte göre yalnızca bazı öğelerini)2ile çarpmak
istersek nasıl bir yol izleyeceğiz?

Python’da karakter dizilerinin içindeki öğelerin bir sırası vardır. Örneğin“Python”dediğimizde, bu karakter dizisinin ilk öğesi olan“P”karakterinin
sırası0’dır.“y”karakteri ise1.sıradadır. Aynı şekilde devam edersek,“t”karakteri2.,“h”karakteri3.,“o”karakteri4.,“n”karakteri ise5.sırada yer alır.

Bu anlattığımız soyut durumu bir örnekle somutlaştırmaya çalışalım:

Dedik ki,“Python”gibi bir karakter dizisinin her bir öğesinin belli bir
sırası vardır. İşte eğer biz bu karakter dizisinin bütün öğelerini değil de,
sadece belli karakterlerini almak istersek, karakter dizisindeki öğelerin sahip
olduğu bu sıradan yararlanacağız.

Diyelim ki“Python”karakter dizisinin ilk karakterini almak istiyoruz. Yani
biz bu karakter dizisinin sadece“P”harfine ulaşmayı amaçlıyoruz.

Bu isteğimizi nasıl yerine getirebileceğimizi basit bir örnek üzerinde
göstermeye çalışalım:

```python
>>> kardiz = "Python"

```

Burada değeri“Python”olankardizadlı bir değişken tanımladık. Şimdi bu
karakter dizisinin ilk öğesine erişeceğiz:

```python
>>> kardiz[0]

'P'

```

Burada yaptığımız işleme çok dikkat edin. Karakter dizisinin istediğimiz bir
öğesine ulaşmak için, ilgili öğenin sırasını köşeli parantezler içinde
belirttik. Biz bu örnekte karakter dizisinin ilk öğesine ulaşmak istediğimiz
için köşeli parantez içinde0sayısını kullandık.

Şimdi de, ilk verdiğimiz örnektekinesnedeğişkeni içinde yer alan sayılar
arasından sadece birini2ile çarpmak istediğimizi düşünelim:

```python
>>> nesne = "123456789"
>>> int(nesne[1]) * 2

4

```

Burada da önceliklenesnedeğişkeninin birinci sırasında yer alan öğeyi
(dikkat: sıfırıncı sırada yer alan öğeyi değil!) elde etmek için köşeli
parantezler içinde1sayısını kullandık. Daha sonraint()fonksiyonu
yardımıyla bu karakter dizisini tam sayıya çevirdik, ki bununla aritmetik işlem
yapabilelim… Son olarak da elimizdeki tam sayıyı2ile çarparak istediğimiz
sonuca ulaştık.

Elbette yukarıdaki kodları şöyle de yazabilirdik:

```python
>>> nesne = "123456789"
>>> sayı = int(nesne[1])
>>> sayı * 2

4

```

Belki farkındasınız, belki de değilsiniz, ama aslında şu noktada karakter
dizilerinin çok önemli bir özelliği ile karşı karşıyayız. Gördüğünüz gibi,
yukarıda bahsettiğimiz sıra kavramı sayesinde Python’da karakter dizilerinin
bütün öğelerine tek tek ve herhangi bir sıra gözetmeksizin erişmemiz mümkün.
Mesela yukarıdaki ilk örnektekardiz[0]gibi bir yapı kullanarak karakter
dizisinin sıfırıncı (yani ilk) öğesini,nesne[1]gibi bir yapı kullanarak da
karakter dizisinin birinci (yani aslında ikinci) öğesini alabildik.

Bu yapının mantığını kavramak için şu örnekleri dikkatlice inceleyin:

```python
>>> kardiz = "Python"

>>> kardiz[0]

'P'

>>> kardiz[1]

'y'

>>> kardiz[3]

'h'

>>> kardiz[5]

'n'

>>> kardiz[2]

't'

>>> kardiz[4]

'o'

>>> nesne = "123456789"

>>> nesne[0]

'1'

>>> nesne[1]

'2'

>>> nesne[2]

'3'

>>> nesne[3]

'4'

>>> nesne[4]

'5'

>>> nesne[5]

'6'

>>> nesne[6]

'7'

>>> nesne[7]

'8'

>>> nesne[8]

'9'

```

Burada şöyle bir formül yazabiliriz:

```python
karakter_dizisi[öğe_sırası]

```

Bu formülü uygulayarak karakter dizilerinin her bir öğesine tek tek erişmemiz
mümkün. Burada çok önemli bir noktaya daha dikkatinizi çekmek isterim.
Yukarıdaki örneklerden de gördüğünüz gibi, Python’da öğe sıralaması0’dan
başlıyor. Yani bir karakter dizisinin ilk öğesinin sırası0oluyor. Python
programlama dilini özellikle yeni öğrenenlerin en sık yaptığı hatalardan biri de
bir karakter dizisinin ilk öğesine ulaşmak için1sayısını kullanmalarıdır.
Asla unutmayın, Python saymaya her zaman0’dan başlar. Dolayısıyla bir
karakter dizisinin ilk öğesinin sırası0’dır. Eğer ilk öğeye ulaşayım derken1sayısını kullanırsanız ulaştığınız öğe ilk öğe değil, ikinci öğe olacaktır.
Bu ayrıntıyı gözden kaçırmamaya dikkat etmelisiniz.

Karakter dizilerinin öğelerine tek tek erişirken dikkat etmemiz gereken önemli
noktalardan biri de, öğe sırası belirtirken, karakter dizisinin toplam uzunluğu
dışına çıkmamaktır. Yani mesela7karakterlik bir karakter dizimiz varsa, bu
karakter dizisinin son öğesinin sırası6olacaktır. Çünkü biliyorsunuz, Python
saymaya0’dan başlıyor. Dolayısıyla ilk karakterin sırası0olacağı için,7karakterlik bir karakter dizisinde son öğenin sırası6olacaktır.
Örneğin:

```python
>>> kardiz = "istihza"
>>> len(kardiz)

7

```

Gördüğünüz gibi,“istihza”adlı karakter dizisinin uzunluğu7. Yani bu
karakter dizisi içinde7adet karakter var. Bu karakter dizisini incelemeye
devam edelim:

```python
>>> kardiz[0]

'i'

```

Dediğimiz gibi, karakter dizisinin ilk öğesinin sırası0. Dolayısıyla son
öğenin sırası6olacaktır:

```python
>>> kardiz[6]

'a'

```

Bu durumu şöyle formüle edebiliriz:

```python
>>> kardiz[len(kardiz)-1]

```

Yani;

Bir karakter dizisinin uzunluğunun1eksiği, o karakter dizisinin son
öğesini verir.

Yukarıdaki formülü eğer şöyle yazsaydık hata alırdık:

```python
>>> kardiz[len(kardiz)]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: string index out of range

```

Çünkülen(kardiz)kodu bize karakter dizisinin uzunluğunu veriyor. Yani
yukarıdaki“istihza”karakter dizisini göz önüne alırsak,len(kardiz)çıktısı7olacaktır. Dolayısıyla“istihza”karakter dizisinin son öğesine
ulaşmak istersek bu değerin 1 eksiğini almamız gerekiyor. Yanilen(kardiz)-1.

Şu ana kadar öğe sırası olarak hep artı değerli sayılar kullandık. Ancak
istersek öğe sırası olarak eksi değerli sayıları da kullanabiliriz. Eğer bir
karakter dizisine öğe sırası olarak eksi değerli bir sayı verirsek Python o
karakter dizisini sondan başa doğru okumaya başlayacaktır. Yani:

```python
>>> kardiz[-1]

'a'

```

Gördüğünüz gibi-1sayısı karakter dizisini tersten okuyup, sondan başa doğru
ilk öğeyi veriyor. Dolayısıyla, yukarıda anlattığımızlen(kardiz)-1yönteminin yanısıra,-1sayısını kullanarak da karakter dizilerinin son
karakterini elde edebiliyoruz. Bir de şuna bakalım:

```python
>>> kardiz[-2]

'z'

```

Dediğimiz gibi, eksi değerli sayılar karakter dizisindeki karakterleri sondan
başa doğru elde etmemizi sağlar. Dolayısıyla-2sayısı, karakter dizisinde
sondan bir önceki karakteri verecektir.

Karakter dizilerinin öğelerine tek tek erişmek amacıyla öğe sırası belirtirken,
karakter dizisinin toplam uzunluğu dışına çıkmamamız gerektiğini söylemiştik.
Peki karakter dizisinin uzunluğunu aşan bir sayı verirsek ne olur? Ne olacağını
yukarıdaki örneklerden birinde görmüştük aslında. Ama konunun öneminden dolayı
bir kez daha tekrar edelim.

```python
>>> kardiz = "istihza"
>>> kardiz[7]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: string index out of range

```

…veya:

```python
>>> kardiz[-8]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: string index out of range

```

Eğer karakter dizisinin uzunluğunu aşan bir sayı belirtirsek Python bizeIndexErrortüründe bir hata mesajı verecektir.

Gördüğünüz gibi,kardiz[0],kardiz[1],kardiz[2], vb. komutlarla
karakter dizisinin öğelerine erişebiliyoruz. Burada öğe sıralarını tek tek
yazmak yerinerange()fonksiyonunu kullanarak da öğelere tek tek
erişebilirsiniz:

```python
for i in range(7):
 print(kardiz[i])

```

Bu kodlarda,kardiz[0],kardiz[1],kardiz[2]şeklinde öğe sıralarını
tek tek elle yazmak yerine,range(7)aralığındaki sayıları birfordöngüsüne alıyoruz. Böylece Pythonkardiz[öğe_sırası]gibi bir yapı içindeöğe_sırasıyerinerange(7)aralığındaki bütün sayıları (yani0,1,2,3,4,5,6sayılarını) tek tek uyguluyor.

Burada aklınıza hemen şöyle bir soru gelmiş olabilir:

Biz kendi tanımladığımız karakter dizisinin uzunluğunun toplam7karakter
olduğunu bildiğimiz için yukarıdaki örnekterange()fonksiyonunurange(7)şeklinde kullanabildik. Ama başka kaynaktan gelen bir karakter
dizisinin uzunluğunu nasıl bileceğiz?

Aslında bu sorunun cevabı çok basit. Uzunluğunu bilmediğiniz karakter dizileri
içinrange()fonksiyonuyla birliktelen()fonksiyonundan
yararlanabilirsiniz. Nasıl mı? Hemen bir örnek verelim:

```python
for karakter in range(len(kardiz)):
 print(kardiz[karakter])

```

Buradarange()fonksiyonuna verdiğimizlen(kardiz)parametresine
dikkatlice bakın. Bizkardizadlı değişkenin tuttuğu karakter dizisinin7karakterden oluştuğunu biliyoruz. Ama eğer bu karakter dizisini biz
belirlememişsek, karakter dizisinin tam olarak kaç karakterden oluşacağını
bilemeyiz. Bu kodlardalen(kardiz)ifadesini kullanarak, sabit bir değer
belirlemekten kaçınmış oluyoruz. Böylece, mesela kullanıcıdan aldığımız bir
karakter dizisinin kaç karakterden oluştuğunu belirleme görevini Python’a
bırakmış oluyoruz. Karakter dizisinin uzunluğu ne ise (len(kardiz)), Pythonrange()fonksiyonuna o sayıyı parametre olarak kendisi atayacaktır.

Yukarıdaki durumu daha iyi anlayabilmek için bir örnek daha verelim. Diyelim ki
kullanıcıya ismini sorup, kendisine şöyle bir çıktı vermek istiyorsunuz:

```python
isminizin 1. harfi ...
isminizin 2. harfi ...
isminizin 3. harfi ...
...

```

Bunu yapabilmek için şöyle bir uygulama yazabilirsiniz:

```python
isim = input("isminiz: ")

for i in range(len(isim)):
 print("isminizin {}. harfi: {}".format(i, isim[i]))

```

Gördüğünüz gibi, kullanıcının girdiği kelimenin uzunluğu kaç ise o sayı otomatik
olarakrange()fonksiyonuna atanıyor. Diyelim ki kullanıcı Ferhat ismini
girmiş olsun. Bu kelimede toplam6karakter var. Dolayısıyla Pythonforsatırını şöyle yorumlayacaktır:

```python
for i in range(6):
 ...

```

Pythonfordöngüsünün ilk turunda şöyle bir işlem gerçekleştirir:

```python
print("isminizin {}. harfi: {}".format(0, isim[0]))

```

İkinci turda ise şöyle bir işlem:

```python
print("isminizin {}. harfi: {}".format(1, isim[1]))

```

Annenizin kızlık soyadının 0. harfi [kaynak]¶

Bu döngü6sayısına gelene kadar devam eder. Buradaiadlı değişkenin
değerinin her döngüde nasıl değiştiğine dikkat edin. Pythoniadını verdiğimiz
değişkene,fordöngüsünün her turunda sırasıya0,1,2,3,4ve5sayılarını atayacağı içinisimadlı değişkenin öğeleriisim[öğe_sırası]formülü sayesinde tek tek ekrana dökülecektir.

Yalnız bu kodların çıktısında iki nokta dikkatinizi çekmiş olmalı. Birincisi,isminizin 0. harfi fgibi bir çıktıyı kullanıcılarınız yadırgayabilir. Çünkü
‘0.harf’ çok yapay duran bir ifade. Onun yerine ilk harfi ‘1. harf’ olarak
adlandırmamız çok daha mantıklı olacaktır. Bunun için kodlarınıza şu basit
eklemeyi yapabilirsiniz:

```python
isim = input("isminiz: ")

for i in range(len(isim)):
 print("isminizin {}. harfi: {}".format(i+1, isim[i]))

```

Burada ilkideğişkeninin değerini1sayı artırdık. Böylece0sayısı1’e,1sayısı2’ye,2sayısı3’e… dönüşmüş oldu. Bu şekilde
kullanıcılarınıza çok daha doğal görünen bir çıktı verebilmiş oluyorsunuz. Eğer
bu işlemi yapmazsanız, kullanıcılarınızın ‘doğal görünmeyen’ bir çıktı
almalarının yanısıra, programınızın verdiği çıktı kimi durumlarda epey yanıltıcı
da olabilir…

### Karakter Dizilerini Dilimlemek

Bir önceki bölümde bir karakter dizisinin istediğimiz öğesini, o öğenin sırasını
belirterek nasıl elde edebileceğimizi gördük. Bu bölümde de benzer bir şey
yapacağız. Ama burada yapacağımız şey, bir önceki bölümde yaptığımız işleme göre
biraz daha kapsamlı bir işlem olacak.

Bu bölümde karakter dizilerini ‘dilimlemekten’ söz edeceğiz. Peki ‘dilimlemek’
derken neyi kastediyoruz? Aslında burada gerçek anlamda ‘karpuz gibi
dilimlemekten’ söz ediyoruz… Şu örnek, ne demek istediğimizi daha net ortaya
koyacaktır:

```python
>>> site = "www.istihza.com"
>>> site[4:11]

'istihza'

>>> site[12:15]

'com'

>>> site[0:3]

'www'

```

Gördüğünüz gibi, karakter dizisine köşeli parantez içinde bazı değerler vererek
bu karakter dizisini dilim dilim ayırdık. Peki bunu nasıl yaptık? Yukarıdaki
örneklerde şöyle bir yapı gözümüze çarpıyor:

```python
karakter_dizisi[alınacak_ilk_öğenin_sırası:alınacak_son_öğenin_sırasının_bir_fazlası]

```

Bu formülü çok basit bir örneğe uygulayalım:

```python
>>> karakter_dizisi = "istanbul"
>>> karakter_dizisi[0:3]

'ist'

```

Burada alacağımız ilk öğenin sıra numarası0. Yani“istanbul”karakter
dizisindeki ‘i’ harfi. Alacağımız son öğenin sıra numarasının 1 fazlası ise3.
Yani2.sıradaki ‘t’ harfi. İştekarakter_dizisi[0:3]dediğimizde, Python0.öğe ile3.öğe arasında kalan bütün öğeleri bize verecektir. Bizim
örneğimizde bu aralıktaki öğeler ‘i’, ‘s’ ve ‘t’ harfleri. Dolayısıyla Python
bize ‘istanbul’ kelimesindeki ‘ist’ kısmını dilimleyip veriyor.

Bu bilgileri kullanarak şöyle bir uygulama yazalım:

```python
site1 = "www.google.com"
site2 = "www.istihza.com"
site3 = "www.yahoo.com"
site4 = "www.gnu.org"

for isim in site1, site2, site3, site4:
 print("site: ", isim[4:-4])

```

Bu örnek Python’da dilimleme işlemlerinin yapısı ve özellikleri hakkında bize
epey bilgi veriyor. Gördüğünüz gibi, hem artı hem de eksi değerli sayıları
kullanabiliyoruz. Önceki bölümden hatırlayacağınız gibi, eğer verilen sayı eksi
değerliyse Python karakter dizisini sağdan sola (yani sondan başa doğru)
okuyacaktır. Yukarıdaki örnekteisim[4:-4]yapısını kullanarak,site1,site2,site3,site4adlı karakter dizilerini, ilk dört ve son dört
karakterler hariç olacak şekilde dilimledik. Böylece elimizde ilk dört ve son
dört karakter arasındaki bütün karakterler kalmış oldu. Yani“google”,“istihza”,“yahoo”ve“gnu”.

Bütün bu anlattıklarımızı daha iyi anlayabilmek için bir örnek daha verelim:

```python
ata1 = "Akıllı bizi arayıp sormaz deli bacadan akar!"
ata2 = "Ağa güçlü olunca kul suçlu olur!"
ata3 = "Avcı ne kadar hile bilirse ayı da o kadar yol bilir!"
ata4 = "Lafla pilav pişse deniz kadar yağ benden!"
ata5 = "Zenginin gönlü oluncaya kadar fukaranın canı çıkar!"

```

Burada beş adet atasözü verdik. Bizim görevimiz, bu atasözlerinin sonunda
bulunan ünlem işaretlerini ortadan kaldırmak:

```python
for ata in ata1, ata2, ata3, ata4, ata5:
 print(ata[0:-1])

```

Burada yaptığımız şey şu:ata1,ata2,ata3,ata4veata5adlı
değişkenlerin her biriniataolarak adlandırdıktan sonraataadlı değişkenin
en başından en sonuna kadar olan kısmı dilimleyip aldık. Yaniata[0]ileata[-1]arasında kalan bütün karakterleri elde etmiş olduk. Peki bu ünlem
işaretlerini kaldırdıktan sonra bunların yerine birer nokta koymak istersek ne
yapacağız?

O da çok basit bir işlem:

```python
for ata in ata1, ata2, ata3, ata4, ata5:
 print(ata[0:-1] + ".")

```

Gördüğünüz gibi, son karakter olan ünlem işaretini attıktan sonra onun yerine
bir nokta işareti koymak için yaptığımız tek şey, dilimlediğimiz karakter
dizisine, artı işareti (+) yardımıyla bir.karakteri eklemekten ibarettir.

Böylece karakter dizilerini nasıl dilimleyeceğimizi öğrenmiş olduk. Bu konuyu
kapatmadan önce dilimlemeye ilişkin bazı ayrıntılardan söz edelim. Diyelim ki
elimizde şöyle bir karakter dizisi var:

```python
>>> kardiz = "Sana Gül Bahçesi Vadetmedim"

```

Bu karakter dizisi içinden sadece ‘Sana’ kısmını dilimlemek için şöyle bir şey
yazabileceğimizi biliyorsunuz:

```python
>>> kardiz[0:4]

'Sana'

```

Burada0.karakterden4.karaktere kadar olan kısmı dilimlemiş oluyoruz.
Python bize bu tür durumlarda şöyle bir kolaylık sağlar: Eğer karakter dizisi
içinden alınan ilk karakterin sırasını gösteren sayı0ise, bu sayıyı
belirtmesek de olur. Yanikardiz[0:4]kodunu şöyle de yazabiliriz:

```python
>>> kardiz[:4]

'Sana'

```

Gördüğünüz gibi, ilk sıra sayısını yazmazsak Python ilk sayıyı0kabul ediyor.

Şimdi de aynı karakter dizisi içindeki ‘Vadetmedim’ kısmını dilimlemeye
çalışalım:

```python
>>> kardiz[17:27]

'Vadetmedim'

```

Burada da17.karakter ile27.karakter arasında kalan bütün karakterleri
dilimledik. Tıpkı, alacağımız ilk karakterin sırası0olduğunda bu sayıyı
belirtmemize gerek olmadığı gibi, alacağımız son karakterin sırası karakter
dizisinin sonuncu karakterine denk geliyorsa o sayıyı da yazmamıza gerek yok.
Yani yukarıdakikardiz[17:27]kodunu şöyle de yazabiliriz:

```python
>>> kardiz[17:]

'Vadetmedim'

```

Python’daki bu dilimleme özelliğini kullanarak karakter dizilerini istediğiniz
gibi eğip bükebilir, evirip çevirebilirsiniz.

Python’daki bu dilimleme yapısı ilk bakışta gözünüze biraz karmaşıkmış gibi
görünebilir. Ama aslında hiç de öyle değildir. Bu yapının mantığını bir kez
kavradıktan sonra kodlarınızı hatasız bir şekilde yazabilirsiniz.

Dilimleme yapısını daha iyi anlayabilmek için kendi kendinize bazı denemeler
yapmanızı tavsiye ederim. Bu yapının nasıl çalıştığını anlamanın en iyi yolu bol
bol örnek kod yazmaktır.

### Karakter Dizilerini Ters Çevirmek

Eğer amacınız bir karakter dizisini ters çevirmek, yani karakter dizisi içindeki
her bir öğeyi tersten yazdırmaksa biraz önce öğrendiğimiz dilimleme yöntemini
kullanabilirsiniz. Dikkatlice bakın:

```python
>>> kardiz[::-1]

'midemtedaV iseçhaB lüG anaS'

```

Gördüğünüz gibi,“Sana Gül Bahçesi Vadetmedim”adlı karakter dizisi içindeki
bütün karakterler sondan başa doğru ekrana dizildi.

Aslında bu komutla Python’a şöyle bir emir vermiş oluyoruz:

kardizdeğişkeni içindeki bütün karakterleri, en son karakterden ilk
karaktere kadar sondan başa doğru tek tek ekrana yazdır!

Bildiğiniz gibi, eğer almak istediğimiz karakter, dizi içindeki ilk karakterse
bu karakterin dizi içindeki sırasını belirtmemize gerek yok. Aynı şekilde, eğer
almak istediğimiz karakter, dizi içindeki son karakterse, bu karakterin de dizi
içindeki sırasını belirtmemize gerek yok. İşte yukarıdaki örnekte bu kuraldan
yararlandık.

Eğer bir karakter dizisinin tamamının değil de, sadece belli bir kısmının ters
çevrilmiş halini elde etmek istiyorsanız elbette yapmanız gereken şey, almak
istediğiniz ilk ve son karakterlerin sırasını parantez içinde belirtmek
olacaktır. Mesela yukarıdaki karakter dizisinde sadece ‘Gül’ kelimesini ters
çevirmek istersek şöyle bir şey yazabiliriz:

```python
>>> kardiz[7:4:-1]

'lüG'

```

Yukarıdaki örnek, karakter dizisi dilimlemeye ilişkin olarak bize bazı başka
ipuçları da veriyor. Gördüğünüz gibi, köşeli parantez içinde toplam üç adet
parametre kullanabiliyoruz. Yani formülümüz şöyle:

```python
kardiz[ilk_karakter:son_karakter:atlama_sayısı]

```

Bir örnek verelim:

```python
>>> kardiz = "istanbul"
>>> kardiz[0:8:1]

'istanbul'

```

Burada“istanbul”adlı karakter dizisinin bütün öğelerini birer birer ekrana
döktük. Bir de şuna bakalım:

```python
>>> kardiz[0:8:2]

'itnu'

```

Burada ise“istanbul”adlı karakter dizisinin bütün öğelerini ikişer ikişer
atlayarak ekrana döktük. Yani bir karakter yazıp bir karakter atladık (istanbul).

Python’ın kuralları gereğince yukarıdaki kodu şöyle yazabileceğimizi de
biliyorsunuz:

```python
>>> kardiz[::2]

'itnu'

```

Eğer karakter dizisini ters çevirmek istiyorsak, yukarıdaki örneği eksi değerli
bir atlama sayısı ile yazmamız gerekir:

```python
>>> kardiz = "istanbul"
>>> kardiz[::-1]

'lubnatsi'

>>> kardiz[::-2]

'lbas'

```

Dediğimiz gibi, yukarıdaki yöntemi kullanarak karakter dizilerini ters
çevirebilirsiniz. Ama eğer istersenizreversed()adlı bir fonksiyondan da
yararlanabiliriz.

Gelelim bu fonksiyonun nasıl kullanılacağına… Önce şöyle bir deneme yapalım:

```python
>>> reversed("Sana Gül Bahçesi Vadetmedim")

<reversed object at 0x00E8E250>

```

Gördüğünüz gibi, bu fonksiyonu düz bir şekilde kullandığımızda bize bir
‘reversed’ nesnesi vermekle yetiniyor. Buna benzer bir olguylarange()fonksiyonunda da karşılaşmıştık:

```python
>>> range(10)

range(0, 10)

```

Hatırlarsanız,range(10)gibi bir komutun içeriğini görebilmek için bu komut
üzerinde birfordöngüsü kurmamız gerekiyordu:

```python
for i in range(10):
 print(i)

```

…veya:

```python
print(*range(10))

```

Aynı durumreversed()fonksiyonu için de geçerlidir:

```python
for i in reversed("Sana Gül Bahçesi Vadetmedim"):
 print(i, end="")

```

…veya:

```python
print(*reversed("Sana Gül Bahçesi Vadetmedim"), sep="")

```

Dilimleme veyareversed()fonksiyonunu kullanma yöntemlerinden hangisi
kolayınıza geliyorsa onu tercih edebilirsiniz.

### Karakter Dizilerini Alfabe Sırasına Dizmek

Python’da karakter dizilerinin öğelerine tek tek ulaşma, öğeleri dilimleme ve
ters çevirmenin yanısıra, bu öğeleri alfabe sırasına dizmek de mümkündür. Bunun
içinsorted()adlı bir fonksiyondan yararlanacağız:

```python
>>> sorted("kitap")

['a', 'i', 'k', 'p', 't']

```

Nasılinput()fonksiyonu çıktı olarak bir karakter dizisi velen()fonksiyonu bir sayı veriyorsa,sorted()fonksiyonu da bize çıktı olarak,
birkaç bölüm sonra inceleyeceğimiz ‘liste’ adlı bir veri tipi verir.

Ama tabii eğer isterseniz bu çıktıyı alıştığınız biçimde alabilirsiniz:

```python
print(*sorted("kitap"), sep="")

```

…veya:

```python
for i in sorted("kitap"):
 print(i, end="")

```

Bir örnek daha verelim:

```python
>>> sorted("elma")

['a', 'e', 'l', 'm']

```

Gördüğünüz gibi,sorted()fonksiyonunu kullanmak çok kolay, ama aslında bu
fonksiyonun önemli bir problemi var. Dikkatlice bakın:

```python
>>> sorted("çiçek")

['e', 'i', 'k', 'ç', 'ç']

```

Burada Türkçe bir karakter olan ‘ç’ harfinin düzgün sıralanamadığını görüyoruz.
Bu sorun bütün Türkçe karakterler için geçerlidir.

Bu sorunu aşmak için şöyle bir yöntem deneyebilirsiniz:

```python
>>> import locale
>>> locale.setlocale(locale.LC_ALL, "Turkish_Turkey.1254") #Windows için
>>> locale.setlocale(locale.LC_ALL, "tr_TR") #GNU/Linux için
>>> sorted("çiçek", key=locale.strxfrm)

['ç', 'ç', 'e', 'i', 'k']

```

Buradalocaleadlı bir modülden yararlandık.localede tıpkısys,osvekeywordgibi bir modül olup, içinde pek çok değişken ve fonksiyon
barındırır.

localemodülü bize belli bir dilin kendine has özelliklerine göre
programlama yapma imkanı verir. Örneğin bu modülünün içinde yer alan
fonksiyonlardan biri olansetlocale()fonksiyonunu kullanarak, programımızda
öntanımlı dil ayarlarına uygun bir şekilde programlama yapma olanağı sağlarız.

Bu modülü ilerleyen derslerde daha ayrıntılı bir şekilde inceleyeceğiz. O yüzdenlocalemodülünü bir kenara bırakıp yolumuza devam edelim.

Yukarıdaki örnekte Türkçe karakterleri doğru sıralayabilmek içinsorted()fonksiyonunu nasıl kullandığımıza dikkat edin:

```python
>>> sorted("çiçek", key=locale.strxfrm)

```

Buradasorted()metodununkeyadlı özel bir parametresinelocale.strxfrmdeğerini vererek Türkçeye duyarlı bir sıralama yapılmasını sağladık. Yukarıdaki
yöntem pek çok durumda işinize yarar. Ancak bu yöntem tek bir yerde işe yaramaz.
Dikkatlice bakın:

```python
>>> sorted("afgdhkıi", key=locale.strxfrm)

['a', 'd', 'f', 'g', 'h', 'i', 'ı', 'k']

```

Gördüğünüz gibi, bu yöntem ‘i’ harfini ‘ı’ harfinden önce getiriyor. Halbuki
Türk alfabesine göre bunun tersi olmalıydı. Buna benzer problemlerle İngiliz
alfabesi dışındaki pek çok alfabede karşılaşırsınız. Dolayısıyla bu sadece
Türkçeye özgü bir sorun değil.

Bu soruna karşı şöyle bir kod da yazabilirsiniz:

```python
>>> harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
>>> çevrim = {i: harfler.index(i) for i in harfler}
>>> sorted("afgdhkıi", key=çevrim.get)

['a', 'd', 'f', 'g', 'h', 'ı', 'i', 'k']

```

Gördüğünüz gibi burada ilk iş olarak Türk alfabesindeki bütün harfleriharfleradlı bir değişkene atadık. Daha sonra ise şöyle bir kod yazdık:

```python
>>> çevrim = {i: harfler.index(i) for i in harfler}

```

Burada henüz öğrenmediğimiz bir yapı var, ama ne olup bittiğini daha iyi anlamak
için buçevrimdeğişkeninin içeriğini kontrol etmeyi deneyebilirsiniz:

```python
>>> print(çevrim)

{'ğ': 8, 'ı': 10, 'v': 26, 'g': 7, 'ş': 22, 'a': 0, 'c': 2, 'b': 1, 'e': 5,
'd': 4, 'ç': 3, 'f': 6, 'i': 11, 'h': 9, 'k': 13, 'j': 12, 'm': 15, 'l': 14,
'o': 17, 'n': 16, 'p': 19, 's': 21, 'r': 20, 'u': 24, 't': 23, 'ö': 18,
'y': 27, 'z': 28, 'ü': 25}

```

Bu çıktıya dikkatlice bakarsanız, her bir harfin bir sayıya karşılık gelecek
şekilde birbiriyle eşleştirildiğini göreceksiniz. Mesela ‘ğ’ harfi8ile, ‘f’
harfi6ile eşleşmiş. Yine dikkatlice bakarsanız, biraz önce bize sorun
çıkaran ‘ı’ harfinin10, ‘i’ harfinin ise11ile eşleştiğini göreceksiniz.
Evet, doğru tahmin ettiniz. Harfleri sayılarla eşleştirerek, Python’ın harfler
yerine sayıları sıralamasını sağlayacağız. Bunu da yinekeyparametresini
kullanarak yapıyoruz:

```python
>>> sorted("afgdhkıi", key=çevrim.get)

```

Bu yapıyı daha iyi anlayabilmek için kendi kendinize bazı denemeler yapın. Eğer
burada olan biteni anlamakta zorlanıyorsanız hiç endişe etmeyin. Bir-iki bölüm
sonra bunları da kolayca anlayabilecek duruma geleceksiniz. Bizim burada bu
bilgileri vermekteki amacımız, Python’ın Türkçe harflerle sıralama işlemini
sorunsuz bir şekilde yapabileceğini göstermektir. Bu esnada bir-iki yeni bilgi
kırıntısı da kapmanızı sağlayabildiysek kendimizi başarılı sayacağız.

### Karakter Dizileri Üzerinde Değişiklik Yapmak

Bu kısımda karakter dizilerinin çok önemli bir özelliğinden söz edeceğiz.
Konumuz karakter dizileri üzerinde değişiklik yapmak. İsterseniz neyle karşı
karşıya olduğumuzu anlayabilmek için çok basit bir örnek verelim.

Elimizde şöyle bir karakter dizisi olduğunu düşünün:

```python
>>> meyve = "elma"

```

Amacımız bu karakter dizisinin ilk harfini büyütmek olsun.

Bunun için dilimleme yönteminden yararlanabileceğimizi biliyorsunuz:

```python
>>> "E" + meyve[1:]

'Elma'

```

Burada “E” harfi ile,meyvedeğişkeninin ilk harfi dışında kalan bütün
harfleri birleştirdik.

Bir örnek daha verelim.

Elimizde şöyle dört adet internet sitesi adresi olsun:

```python
site1 = "www.google.com"
site2 = "www.istihza.com"
site3 = "www.yahoo.com"
site4 = "www.gnu.org"

```

Bizim amacımız bu adreslerin her birinin baş tarafınahttp://ifadesini
eklemek. Bunun için de yine karakter dizisi birleştirme işlemlerinden
yararlanabiliriz. Dikkatlice inceleyin:

```python
site1 = "www.google.com"
site2 = "www.istihza.com"
site3 = "www.yahoo.com"
site4 = "www.gnu.org"

for i in site1, site2, site3, site4:
 print("http://", i, sep="")

```

Eğerwww.kısımlarını atmak isterseniz karakter dizisi birleştirme işlemleri
ile birlikte dilimleme yöntemini de kullanmanız gerekir:

```python
for i in site1, site2, site3, site4:
 print("http://", i[4:], sep="")

```

Belki farkındayız, belki de değiliz, ama aslında yukarıdaki örnekler karakter
dizileri hakkında bize çok önemli bir bilgi veriyor. Dikkat ettiyseniz
yukarıdaki örneklerde karakter dizileri üzerinde bir değişiklik yapmışız gibi
görünüyor. Esasında öyle de denebilir. Ancak burada önemli bir ayrıntı var.
Yukarıdaki örneklerde gördüğümüz değişiklikler kalıcı değildir. Yani aslında bu
değişikliklerin orijinal karakter dizisi üzerinde hiçbir etkisi yoktur. Gelin
isterseniz bunu teyit edelim:

```python
>>> kardiz = "istihza"
>>> "İ" + kardiz[1:]

'İstihza'

```

Dediğimiz gibi, sanki burada“istihza”karakter dizisini“İstihza”karakter
dizisine çevirmişiz gibi duruyor. Ama aslında öyle değil:

```python
>>> print(kardiz)

istihza

```

Gördüğünüz gibi,kardizdeğişkeninin orijinalinde hiçbir değişiklik yok.
Ayrıca burada"İ"+kardiz[1:]satırı ile elde ettiğiniz sonuca tekrar
ulaşmanızın imkanı yok. Bu değişiklik kaybolmuş durumda. Peki bunun sebebi
nedir?

Bunun nedeni, karakter dizilerinin değiştirilemeyen (immutable) bir veri tipi
olmasıdır. Python’da iki tür veri tipi bulunur: değiştirilemeyen veri tipleri
(immutable datatypes) ve değiştirilebilen veri tipleri (mutable datatypes).
Bizim şimdiye kadar gördüğümüz veri tipleri (sayılar ve karakter dizileri),
değiştirilemeyen veri tipleridir. Henüz değiştirilebilen bir veri tipi görmedik.
Ama birkaç bölüm sonra değiştirilebilen veri tiplerini de inceleyeceğiz.

Neyse… Dediğimiz gibi, karakter dizileri üzerinde yaptığımız değişikliklerin
kalıcı olmamasının nedeni, karakter dizilerinin değiştirilemeyen bir veri tipi
olmasıdır. Python’da bir karakter dizisini bir kez tanımladıktan sonra bu
karakter dizisi üzerinde artık değişiklik yapamazsınız. Eğer bir karakter dizisi
üzerinde değişiklik yapmanız gerekiyorsa, yapabileceğiniz tek şey o karakter
dizisini yeniden tanımlamaktır. Mesela yukarıdaki örnektekardizdeğişkeninin
tuttuğu karakter dizisini değiştirmek isterseniz şöyle bir kod yazabilirsiniz:

```python
>>> kardiz = "İ" + kardiz[1:]
>>> print(kardiz)

İstihza

```

Burada yaptığımız şeykardizdeğişkeninin değerini değiştirmek değildir. Biz
burada aslında bambaşka birkardizdeğişkeni daha tanımlıyoruz. Yani ilkkardizdeğişkeni ile sonrakikardizdeğişkeni aynı şeyler değil. Bunu teyit
etmek için önceki derslerimizde gördüğümüzid()fonksiyonundan
yararlanabilirsiniz:

```python
>>> kardiz = "istihza"
>>> id(kardiz)

3075853248

>>> kardiz = "İ" + kardiz[1:]
>>> id(kardiz)

3075853280

```

Gördüğünüz gibi, ilkkardizdeğişkeni ile sonrakikardizdeğişkeni farklı
kimlik numaralarına sahip. Yani bu iki değişken bellek içinde farklı adreslerde
tutuluyor. Daha doğrusu, ikincikardiz, ilkkardiz’i silip üzerine yazıyor.

Her ne kadarkardiz="İ"+kardiz[1:]kodukardiz’in değerini aslında
değiştirmiyor olsa da, sankikardizdeğişkeninin tuttuğu karakter dizisi
değişiyormuş gibi bir etki elde ediyoruz. Bu da bizi memnun etmeye yetiyor…

Yukarıdaki örnekte karakter dizisinin baş kısmı üzerinde değişiklik yaptık. Eğer
karakter dizisinin ortasında kalan bir kısmı değiştirmek isterseniz de şöyle bir
şey yazabilirsiniz:

```python
>>> kardiz = "istihza"
>>> kardiz = kardiz[:3] + "İH" + kardiz[5:]
>>> kardiz

'istİHza'

```

Gördüğünüz gibi, yukarıdaki kodlarda karakter dizilerini dilimleyip
birleştirerek, yani bir bakıma kesip biçerek istediğimiz çıktıyı elde ettik.

Mesela ilk örnektekardizdeğişkeninin ilk karakteri dışında kalan kısmını
(kardiz[1:]) “İ” harfi ile birleştirdik ("İ"+kardiz[1:]").

İkinci örnekte isekardizdeğişkeninin ilk üç karakterine “İH” ifadesini
ekledik ve sonra bunakardizdeğişkeninin5.karakterinden sonraki kısmını
ilave ettik.

Karakter dizileri üzerinde değişiklik yapmanızın hangi durumlarda gerekli
olacağını gösteren bir örnek daha verip bu konuyu kapatalım.

Diyelim ki, bir kelime içindeki sesli ve sessiz harfleri birbirinden ayırmanız
gereken bir program yazıyorsunuz. Yani mesela amacınız ‘istanbul’ kelimesi
içinde geçen ‘i’, ‘a’ ve ‘u’ harflerini bir yerde, ‘s’, ‘t’, ‘n’, ‘b’ ve ‘l’
harflerini ise ayrı bir yerde toplamak. Bunun için şöyle bir program
yazabilirsiniz:

```python
sesli_harfler = "aeıioöuü"
sessiz_harfler = "bcçdfgğhjklmnprsştvyz"

sesliler = ""
sessizler = ""

kelime = "istanbul"

for i in kelime:
 if i in sesli_harfler:
 sesliler += i
 else:
 sessizler += i

print("sesli harfler: ", sesliler)
print("sessiz harfler: ", sessizler)

```

Burada öncelikle şu kodlar yardımıyla Türkçedeki sesli ve sessiz harfleri
belirliyoruz:

```python
sesli_harfler = "aeıioöuü"
sessiz_harfler = "bcçdfgğhjklmnprsştvyz"

```

Ardından da, sesli ve sessiz harflerini ayıklayacağımız kelimedeki sesli harfler
ve sessiz harfler için boş birer karakter dizisi tanımlıyoruz:

```python
sesliler = ""
sessizler = ""

```

Programımız içinde ilgili harfleri, o harfin ait olduğu değişkene atayacağız.

Kelimemiz“istanbul”:

```python
kelime = "istanbul"

```

Şimdi bu kelime üzerinde birfordöngüsü kuruyoruz ve kelime içinde geçen
herbir harfe tek tek bakıyoruz. Kelime içinde geçen harflerden,sesli_harflerdeğişkeninde tanımlı karakter dizisinde geçenleriseslileradlı değişkene
atıyoruz. Aksi durumda ise, yani kelime içinde geçen harflerden,sessiz_harflerdeğişkeninde tanımlı karakter dizisinde geçenleri,sessizleradlı değişkene gönderiyoruz:

```python
for i in kelime:
 if i in sesli_harfler:
 sesliler += i
 else:
 sessizler += i

```

Bunun içinfordöngüsü içinde basit bir ‘if-else’ bloğu tanımladığımızı
görüyorsunuz. Ayrıca bunu yaparken,seslilervesessizleradlı değişkenlere,fordöngüsünün her bir dönüşünde yeni bir harf gönderip, bu değişkenleri,
döngünün her dönüşünde yeni baştan tanımladığımıza dikkat edin. Çünkü, dediğimiz
gibi, karakter dizileri değiştirilemeyen veri tipleridir. Bir karakter dizisi
üzerinde değişiklik yapmak istiyorsak, o karakter dizisini baştan tanımlamamız
gerekir.

### Üç Önemli Fonksiyon

Karakter dizilerinin temel özellikleri hakkında söyleyeceklerimizin sonuna
geldik sayılır. Biraz sonra karakter dizilerinin çok önemli bir parçası olan
metotlardan söz edeceğiz. Ama isterseniz metotlara geçmeden önce, çok önemli üç
fonksiyondan söz edelim. Bu fonksiyonlar sadece karakter dizileri ile değil,
başka veri tipleri ile çalışırken de işlerimizi bir hayli kolaylaştıracak.

#### dir()

İlk olarakdir()adlı özel bir fonksiyondan söz edeceğiz. Bu metot bize
Python’daki bir nesnenin özellikleri hakkında bilgi edinme imkanı verecek.
Mesela karakter dizilerinin bize hangi metotları sunduğunu görmek için bu
fonksiyonu şöyle kullanabiliriz:

```python
>>> dir(str)

['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__',
'__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',
'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
'__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', 'capitalize', 'center', 'count', 'encode', 'endswith',
'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha',
'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',
'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']

```

İngilizcede ‘karakter dizisi’nin karşılığınınstring, bu kelimenin
kısaltmasının da ‘str’ olduğunu hatırlıyor olmalısınız. İştedir()fonksiyonuna parametre olarak bu ‘str’ kelimesini verdiğimizde, Python bize
karakter dizilerinin bütün metotlarını listeliyor.

Karakter dizileri dışında, şimdiye kadar öğrendiğimiz başka bir veri tipi de
sayılar. Biz Python’da sayıların tam sayılar (integer), kayan noktalı sayılar
(float) ve karmaşık sayılar (complex) olarak üçe ayrıldığını da biliyoruz.
Örnek olması açısındandir()fonksiyonunu bir de sırasıyla, tam sayılar,
kayan noktalı sayılar ve karmaşık sayılar üzerinde de uygulayalım:

```python
>>> dir(int)

>>> dir(float)

>>> dir(complex)

```

Gördüğünüz gibi,dir()fonksiyonunu kullanmak için, metotlarını listelemek
istediğimiz nesneyi alıpdir()fonksiyonuna parametre olarak veriyoruz.
Örneğin yukarıda karakter dizileri içinstr; tam sayılar içinint; kayan
noktalı sayılar içinfloat; karmaşık sayılar için isecomplexparametrelerini kullandık.

dir()fonksiyonunu kullanabilmek için tek yöntemimiz, sorgulamak istediğimiz
nesnenin adını kullanmak değil. Mesela karakter dizilerinin metotlarını
sorgulamak için ‘str’ kelimesini kullanabileceğimiz gibi, herhangi bir karakter
dizisini de kullanabiliriz. Yani:

```python
>>> dir("")

```

Buradadir()fonksiyonuna parametre olarak boş bir karakter dizisi verdik.
Bu kodundir(str)kodundan hiçbir farkı yoktur. Bu komut da bize karakter
dizilerinin metotlarını listeler.

Aynı etkiyi dilersek şöyle de elde edebiliriz:

```python
>>> a = "karakter"
>>> dir(a)

```

Karakter dizilerinin metotlarını listelemek için, siz hangi yöntem kolayınıza
geliyorsa onu kullanabilirsiniz. Bu satırların yazarı genellikle şu yöntemi
kullanıyor:

```python
>>> dir("")

```

dir("")komutunun çıktısından da göreceğiniz gibi, karakter dizilerinin epey
metodu var. Metot listesi içinde bizi ilgilendirenler başında veya sonunda_işareti olmayanlar. Yani şunlar:

```python
>>> for i in dir(""):
... if "_" not in i[0]:
... print(i)
...

```

Bu arada bu metotları listelemek için nasıl bir kod kullandığımıza dikkat edin:

```python
for i in dir(""):
 if "_" not in i[0]:
 print(i)

```

Buradadir("")komutunun içerdiği her bir metoda tek tek bakıyoruz. Bu
metotlar içinde, ilk harfi_karakteri olmayan bütün metotları listeliyoruz.
Böylece istediğimiz listeyi elde etmiş oluyoruz. İsterseniz ilgilendiğimiz
metotların sayısını da çıktıya ekleyebiliriz:

```python
sayaç = 0

for i in dir(""):
 if "_" not in i[0]:
 sayaç += 1
 print(i)

print("Toplam {} adet metot ile ilgileniyoruz.".format(sayaç))

```

Burada da, ilk karakteri_olmayan her bir metot içinsayaçdeğişkeninin
değerini1artırıyoruz. Böylece programın sonundasayaçdeğişkeni
ilgilendiğimiz metot sayısını göstermiş oluyor.

Eğer her metodun soluna, sıra numarasını da eklemek isterseniz elbette şöyle bir
kod da yazabilirsiniz:

```python
sayaç = 0

for i in dir(""):
 if "_" not in i[0]:
 sayaç += 1
 print(sayaç, i)

print("Toplam {} adet metot ile ilgileniyoruz.".format(sayaç))

```

Bu noktada bir parantez açalım. Yukarıdaki yöntemi kullanarak metotları
numaralandırabilirsiniz. Ama aslında Python bize numaralandırma işlemleri için
özel bir fonksiyon sunar. Şimdi isterseniz bu özel fonksiyonu inceleyelim.

#### enumerate()

Eğer yazdığınız bir programda numaralandırmaya ilişkin işlemler yapmanız
gerekiyorsa Python’ın size sunduğu çok özel bir fonksiyondan
yararlanabilirsiniz. Bu fonksiyonun adıenumerate().

Gelelim bu fonksiyonun nasıl kullanılacağına… Önce şöyle bir deneme yapalım:

```python
>>> enumerate("istihza")

<enumerate object at 0x00E3BC88>

```

Tıpkıreversed()fonksiyonunun bir ‘reversed’ nesnesi vermesi gibi, bu
fonksiyonun da bize yalnızca bir ‘enumerate’ nesnesi verdiğini görüyorsunuz.

reversed()fonksiyonunu kullanabilmek için şöyle bir kod yazmıştık:

```python
>>> print(*reversed("istihza"))

```

enumerate()için de benzer bir şeyi deneyebiliriz:

```python
>>> print(*enumerate("istihza"))

```

Burada şu çıktıyı aldık:

```python
(0, 'i') (1, 's') (2, 't') (3, 'i') (4, 'h') (5, 'z') (6, 'a')

```

Enumeratekelimesi İngilizcede ‘numaralamak, numaralandırmak’ gibi anlamlara
gelir. Dolayısıylaenumerate()fonksiyonu, kendisine parametre olarak
verilen değer hakkında bize iki farklı bilgi verir: Bir öğe ve bu öğeye ait bir
sıra numarası. Yukarıdaki çıktıda gördüğünüz şey de işte her bir öğenin kendisi
ve o öğeye ait bir sıra numarasıdır.

Yukarıdaki çıktıyı daha iyi anlayabilmek için birfordöngüsü kullanmak daha
açıklayıcı olabilir:

```python
>>> for i in enumerate("istihza"):
... print(i)
...
(0, 'i')
(1, 's')
(2, 't')
(3, 'i')
(4, 'h')
(5, 'z')
(6, 'a')

```

Gördüğünüz gibi, gerçekten de bu fonksiyon bize bir öğe (mesela ‘i’ harfi) ve bu
öğeye ait bir sıra numarası (mesela0) veriyor.

Hatırlarsanız,enumerate()fonksiyonunu öğrenmeden önce,dir("")komutundan elde ettiğimiz çıktıları şu şekilde numaralandırabileceğimizi
söylemiştik:

```python
sayaç = 0

for i in dir(""):
 if "_" not in i[0]:
 sayaç += 1
 print(sayaç, i)

```

Ama artıkenumerate()fonksiyonunu öğrendiğimize göre, aynı işi çok daha
verimli bir şekilde gerçekleştirebiliriz:

```python
for sıra, metot in enumerate(dir("")):
 print(sıra, metot)

```

enumerate()metodunun verdiği her bir çıktının iki öğeli olduğunu biliyoruz
(öğenin kendisi ve o öğenin sıra numarası). Yukarıdaki kodlar yardımıyla, bu
öğelerin her birini ayrı bir değişkene (sıravemetot) atamış oluyoruz.
Böylece bu çıktıyı manipüle etmek bizim için daha kolay oluyor. Mesela bu
özelliği kullanarak metot ve sıra numarasının yerlerini değiştirebiliriz:

```python
>>> for sıra, metot in enumerate(dir("")):
... print(metot, sıra)
...
__add__ 0
__class__ 1
__contains__ 2
__delattr__ 3
__doc__ 4
__eq__ 5
__format__ 6
__ge__ 7

(...)

```

Pratik olması açısından şöyle bir örnek daha verelim:

```python
>>> for sıra, metot in enumerate(dir("")):
... print(sıra, metot, len(metot))
...
0 __add__ 7
1 __class__ 9
2 __contains__ 12
3 __delattr__ 11
4 __doc__ 7
5 __eq__ 6

(...)

```

Burada,dir("")ile elde ettiğimiz metotların sırasını (sıra), bu
metotların adlarını (metot) ve her bir metodun kaç karakterden oluştuğunu
(len(metot)) gösteren bir çıktı elde ettik.

Bu arada, gördüğünüz gibi,enumerate()fonksiyonu numaralandırmaya0’dan
başlıyor. Elbette eğer isterseniz bu fonksiyonun numaralandırmaya kaçtan
başlayacağını kendiniz de belirleyebilirsiniz. Dikkatlice bakın:

```python
>>> for sıra, harf in enumerate("istihza", 1):
... print(sıra, harf)
...
1 i
2 s
3 t
4 i
5 h
6 z
7 a

```

Burada ‘istihza’ kelimesi içindeki harfleri numaralandırdık. Bunu yaparken de
numaralandırmaya1’den başladık. Bunun içinenumerate()fonksiyonuna
ikinci bir parametre verdiğimize dikkat edin.

enumerate()fonksiyonunu da incelediğimize göre önemli bir başka
fonksiyondan daha söz edebiliriz.

#### help()

Python’la ilgili herhangi bir konuda yardıma ihtiyacınız olduğunda, internetten
araştırma yaparak pek çok ayrıntılı belgeye ulaşabilirsiniz. Ama eğer herhangi
bir nesne hakkında hızlı bir şekilde ve İngilizce olarak yardım almak istersenizhelp()adlı özel bir fonksiyondan yararlanabilirsiniz.

Bu fonksiyonu iki farklı şekilde kullanıyoruz. Birinci yöntemde, etkileşimli
kabuğahelp()yazıpEnterdüğmesine basıyoruz:

```python
>>> help()

Welcome to Python 3.3! This is the interactive help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/3.3/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules. To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics". Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".

help>

```

Gördüğünüz gibi, Python bu komutu verdiğimizde özel bir yardım ekranı açıyor
bize. Bu ekranda>>>yerinehelp>ifadesinin olduğuna dikkat edin. Meseladir()fonksiyonu hakkında bilgi almak içinhelp>ifadesinden hemen sonra,
hiç boşluk bırakmadan, şu komutu verebiliriz:

```python
help> dir

```

Bu komut bize şu çıktıyı veriyor:

```python
Help on built-in function dir in module builtins:

dir(...)
 dir([object]) -> list of strings

 If called without an argument, return the names in the current scope.
 Else, return an alphabetized list of names comprising (some of) the attributes
 of the given object, and of attributes reachable from it.
 If the object supplies a method named __dir__, it will be used; otherwise
 the default dir() logic is used and returns:
 for a module object: the module's attributes.
 for a class object: its attributes, and recursively the attributes of its bases.
 for any other object: its attributes, its class's attributes, and
 recursively the attributes of its class's base classes.

```

Gördüğünüz gibi,dir()fonksiyonunun ne işe yaradığı ve nasıl kullanıldığı
konusunda ayrıntılı bir bilgi ediniyoruz. Bu arada, hakkında bilgi almak
istediğimiz fonksiyonu parantezsiz yazdığımıza dikkat edin.

Örnek olması açısından mesela bir delen()fonksiyonu hakkında bilgi
edinelim:

```python
help> len

Help on built-in function len in module builtins:

len(...)
 len(object) -> integer

 Return the number of items of a sequence or mapping.

```

‘help’ ekranından çıkmak içinEnterdüğmesine basabilir veyaquitkomutu
verebilirsiniz.

En başta da dediğimiz gibi Python’da etkileşimli kabuk üzerinde İngilizce yardım
almak için iki farklı yöntem kullanabiliyoruz. Bu yöntemlerden ilkini yukarıda
anlattık. İkincisi ise doğrudan etkileşimli kabukta şu komutu kullanmaktır:
(Meseladir()fonksiyonu hakkında yardım alalım…)

```python
>>> help(dir)

Help on built-in function dir in module builtins:

dir(...)
 dir([object]) -> list of strings

 If called without an argument, return the names in the current scope.
 Else, return an alphabetized list of names comprising (some of) the attributes
 of the given object, and of attributes reachable from it.
 If the object supplies a method named __dir__, it will be used; otherwise
 the default dir() logic is used and returns:
 for a module object: the module's attributes.
 for a class object: its attributes, and recursively the attributes of its bases.
 for any other object: its attributes, its class's attributes, and
 recursively the attributes of its class's base classes.

```

Gördüğünüz gibi, ‘help’ ekranını açmadan, doğrudan etkileşimli kabuk üzerinden
dehelp()fonksiyonunu herhangi bir fonksiyon gibi kullanıp, hakkında yardım
almak istediğimiz nesneyihelp()fonksiyonunun parantezleri içine parametre
olarak yazabiliyoruz.

Böylecedir(),enumerate()vehelp()adlı üç önemli fonksiyonu da
geride bırakmış olduk. Dilerseniz şimdi karakter dizilerine dair birkaç ufak not
düşelim.

### Notlar

Hatırlarsanız döngüleri anlatırken şöyle bir örnek vermiştik:

```python
tr_harfler = "şçöğüİı"
a = 0

while a < len(tr_harfler):
 print(tr_harfler[a], sep="\n")
 a += 1

```

Bu kodlarınfordöngüsü ile yazılabilecek olan şu kodlara alternatif
olduğundan söz etmiştik:

```python
tr_harfler = "şçöğüİı"

for tr_harf in tr_harfler:
 print(tr_harf)

```

Yukarıdakiwhileörneğini verirken, henüz karakter dizilerinin öğelerine tek
tek nasıl erişebileceğimizi öğrenmemiştik. Ama artık bu konuyu da öğrendiğimiz
için yukarıdakiwhiledöngüsünü rahatlıkla anlayabiliyoruz:

```python
while a < len(tr_harfler):
 print(tr_harfler[a], sep="\n")
 a += 1

```

Burada yaptığımız şey şu:adeğişkeninin değeritr_harflerdeğişkeninin
uzunluğundan (len(tr_harfler)) küçük olduğu müddetçeadeğişkeninin
değerini1sayı artırıp yineadeğişkenine gönderiyoruz (a+=1).

whiledöngüsünün her dönüşünde de,adeğişkeninin yeni değeri yardımıylatr_harfleradlı karakter dizisinin öğelerine tek tek ve sırayla erişiyoruz
(print(tr_hafler[a])).

Yine hatırlarsanız, önceki derslerimizdesysadlı bir modül içindekiversionadlı bir değişkenden söz etmiştik. Bu değişken bize kullandığımız Python’ın
sürümünü bir karakter dizisi olarak veriyordu:

```python
>>> import sys
>>> sys.version

```

Buradan şu çıktıyı alıyoruz:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

Bu çıktıda, kullandığımız Python sürümünün dışında başka birtakım bilgiler de
var. İşte biz eğer istersek, bu bölümde öğrendiğimiz bilgileri kullanarak bu
karakter dizisinin istediğimiz kısmını, mesela sadece sürüm bilgisini karakter
dizisinin içinden dilimleyip alabiliriz:

```python
>>> sys.version[:5]

```

```python
3.7.0
```

Elbette, yukarıdaki karakter dizisini elde etmek için, kullanması ve yönetmesi
daha kolay bir araç olanversion_infodeğişkeninden de yararlanabilirdiniz:

```python
>>> '{}.{}.{}'.format(sys.version_info.major, sys.version_info.minor, sys.version_info.micro)

```

```python
3.7.0
```

Ancak burada şöyle bir sorun olduğunu biliyorsunuz: Python’ın 2.7 öncesi
sürümlerindeversion_info’nunmajor,minorvemicrogibi nitelikleri
yok. Dolayısıyla 2.7 öncesi sürümlerdeversion_info’yu kullanırken hata
almamak içintry...exceptbloklarından yararlanabileceğimizi görmüştük.
Ancakversion_info’yu bütün Python sürümlerinde güvenli bir şekilde
kullanmanın başka bir yöntemi daha var. Dikkatlice bakın:

```python
>>> major = sys.version_info[0]
>>> minor = sys.version_info[1]
>>> micro = sys.version_info[2]

>>> print(major, minor, micro, sep=".")

```

```python
3.7.0
```

Bu yöntem bütün Python sürümlerinde çalışır. Dolayısıyla, farklı Python
sürümlerinde çalışmasını tasarladığınız programlarınızda sürüm kontrolünüsys.version_info’nunmajor,minorveyamicronitelikleri ile yapmak
yerine yukarıdaki yöntemle yapabilirsiniz:

```python
if sys.version_info[1] < 3:
 print("Kullandığınız Python sürümü eski!")

```

Gördüğünüz gibi, karakter dizisi dilimleme işlemleri pek çok farklı kullanım
alanına sahip. Programlama maceranız boyunca karakter dizilerinin bu
özelliğinden bol bol yararlanacağınızdan hiç kuşkunuz olmasın.

## Karakter Dizilerinin Metotları

Geçen bölümde karakter dizilerinin genel özelliklerinden söz ettik. Bu ikinci
bölümde ise karakter dizilerini biraz daha ayrıntılı bir şekilde incelemeye ve
karakter dizilerinin yepyeni özelliklerini görmeye başlayacağız.

Hatırlarsanız, geçen bölümün en başında, metot diye bir şeyden söz edeceğimizi
söylemiştik. Orada da kabaca tarif ettiğimiz gibi, metotlar Python’da nesnelerin
niteliklerini değiştirmemizi, sorgulamamızı veya bu nesnelere yeni özellikler
katmamızı sağlayan araçlardır. Metotlar sayesinde karakter dizilerini
istediğimiz gibi eğip bükebileceğiz.

Geçen bölümün sonlarına doğru, bir karakter dizisinin hangi metotlara sahip
olduğunu şu komut yardımıyla listeleyebileceğimizi öğrenmiştik:

```python
>>> dir("")

```

Bu komutu verdiğinizde aldığınız çıktıdan da gördüğünüz gibi, karakter
dizilerinin40’ın üzerinde metodu var. Dolayısıyla metot sayısının çokluğu
gözünüzü korkutmuş olabilir. Ama aslında buna hiç lüzum yok. Çünkü programcılık
maceranızda bu metotların bazılarını ya çok nadiren kullanacaksınız, ya da hiç
kullanmayacaksınız. Çok kullanılan metotlar belli başlıdır. Elbette bütün
metotlar hakkında fikir sahibi olmak gerekir. Zaten siz de göreceksiniz ki, bu
metotlar kullandıkça aklınızda kalacak. Doğal olarak çok kullandığınız metotları
daha kolay öğreneceksiniz. Eğer bir program yazarken hangi metodu kullanmanız
gerektiğini veya kullanacağınız metodun ismini hatırlayamazsanız etkileşimli
kabuktadir("")gibi bir komut verip çıkan sonucu incelemek pek zor olmasa
gerek. Ayrıca hatırlayamadığınız bir metot olması durumunda dönüp bu sayfaları
tekrar gözden geçirme imkanına da sahipsiniz. Unutmayın, bütün metotları ve bu
metotların nasıl kullanıldığını ezbere bilmeniz zaten beklenmiyor. Metotları
hatırlayamamanız gayet normal. Böyle bir durumda referans kitaplarına bakmak en
doğal hakkınız.

### replace()

Karakter dizisi metotları arasında inceleyeceğimiz ilk metotreplace()metodu olacak.replacekelimesi Türkçede ‘değiştirmek, yerine koymak’ gibi
anlamlar taşır. İşte bu metodun yerine getirdiği görev de tam olarak budur. Yani
bu metodu kullanarak bir karakter dizisi içindeki karakterleri başka
karakterlerle değiştirebileceğiz.

Peki bu metodu nasıl kullanacağız? Hemen bir örnek verelim:

```python
>>> kardiz = "elma"

```

Burada“elma”değerini taşıyankardizadlı bir karakter dizisi tanımladık.
Şimdi bu karakter dizisinin içinde geçen“e”harfini“E”ile değiştirelim.
Dikkatlice bakın:

```python
>>> kardiz.replace("e", "E")

'Elma'

```

Gördüğünüz gibi,replace()son derece yararlı ve kullanımı oldukça kolay bir
metot. Bu arada bu ilk metodumuz sayesinde Python’daki metotların nasıl
kullanılacağı konusunda da bilgi edinmiş olduk. Yukarıdaki örneklerin bize
gösterdiği gibi şöyle bir formülle karşı karşıyayız:

```python
karakter_dizisi.metot(parametre)

```

Metotlar karakter dizilerinden nokta ile ayrılır. Python’da bu yönteme ‘noktalı
gösterim’ (dot notation) adı verilir.

Bu arada metotların görünüş ve kullanım olarak fonksiyonlara ne kadar
benzediğine dikkat edin. Tıpkı fonksiyonlarda olduğu gibi, metotlar da birtakım
parametreler alabiliyor.

Yukarıdaki örnekte,replace()metodunun iki farklı parametre aldığını
görüyoruz. Bu metoda verdiğimiz ilk parametre değiştirmek istediğimiz karakter
dizisini gösteriyor. İkinci parametre ise birinci parametrede belirlediğimiz
karakter dizisinin yerine ne koyacağımızı belirtiyor. Yanireplace()metodu
şöyle bir formüle sahiptir:

```python
karakter_dizisi.replace(eski_karakter_dizisi, yeni_karakter_dizisi)

```

Gelin isterseniz elimizin alışması içinreplace()metoduyla birkaç örnek
daha verelim:

```python
>>> kardiz = "memleket"
>>> kardiz.replace("ket", "KET")

'memleKET'

```

Burada gördüğünüz gibi,replace()metodu aynı anda birden fazla karakteri
değiştirme yeteneğine de sahip.

replace()metodunun iki parametreden oluştuğunu, ilk parametrenin
değiştirilecek karakter dizisini, ikinci parametrenin ise ilk karakter dizisinin
yerine geçecek yeni karakter dizisini gösterdiğini söylemiştik. Aslındareplace()metodu üçüncü bir parametre daha alır. Bu parametre ise bir
karakter dizisi içindeki karakterlerin kaç tanesinin değiştirileceğini gösterir.
Eğer bu parametreyi belirtmezsekreplace()metodu ilgili karakterlerin
tamamını değiştirir. Yani:

```python
>>> kardiz = "memleket"

>>> kardiz.replace("e", "")

'mmlkt'

```

Gördüğünüz gibi,replace()metodunu iki parametre ile kullanıp üçüncü
parametreyi belirtmediğimizde,“memleket”kelimesi içindeki bütün“e”harfleri boş karakter dizisi ile değiştiriliyor (yani bir anlamda siliniyor).

Şimdi şu örneğe bakalım:

```python
>>> kardiz.replace("e", "", 1)

'mmleket'

```

Buradareplace()metodunu üçüncü bir parametre ile birlikte kullandık.
Üçüncü parametre olarak1sayısını verdiğimiz içinreplace()metodu sadece
tek bir“e”harfini sildi.

Bu üçüncü parametreyi, silmek istediğiniz harf sayısı kadar artırabilirsiniz.
Mesela:

```python
>>> kardiz.replace("e", "", 2)

'mmlket'

>>> kardiz.replace("e", "", 3)

'mmlkt'

```

Burada ilk örnekte üçüncü parametre olarak2sayısını kullandığımız için,
‘replace’ işleminden karakter dizisi içindeki2adet“e”harfi etkilendi.
Üçüncü örnekte ise“memleket”adlı karakter dizisi içinde geçen üç adet“e”harfi değişiklikten etkilendi.

Karakter dizileri konusunun ilk bölümünde ‘değiştirilebilirlik’ (mutability)
üzerine söylediğimiz şeylerin burada da geçerli olduğunu unutmayın. Orada da
söylediğimiz gibi, karakter dizileri değiştirilemeyen veri tipleridir.
Dolayısıyla eğer bir karakter dizisi üzerinde değişiklik yapmak istiyorsanız, o
karakter dizisini baştan tanımlamalısınız. Örneğin:

```python
>>> meyve = "elma"
>>> meyve = meyve.replace("e", "E")
>>> meyve

'Elma'

```

Böylecereplace()metodunu incelemiş olduk. Sırada üç önemli metot var.

### split(), rsplit(), splitlines()

Şimdi size şöyle bir soru sorduğumu düşünün: Acaba aşağıdaki karakter dizisinde
yer alan bütün kelimelerin ilk harfini nasıl alırız?

```python
>>> kardiz = "İstanbul Büyükşehir Belediyesi"

```

Yani diyorum ki burada“İBB”gibi bir çıktıyı nasıl elde ederiz?

Sadece bu karakter dizisi söz konusu ise, elbette karakter dizilerinin
dilimlenme özelliğinden yararlanarak,kardizdeğişkeni içindeki“İ”,“B”,
ve“B”harflerini tek tek alabiliriz:

```python
>>> print(kardiz[0], kardiz[9], kardiz[20], sep="")

İBB

```

Ancak bu yöntemin ne kadar kullanışsız olduğu ortada. Çünkü bu metot yalnızca“İstanbul Büyükşehir Belediyesi”adlı karakter dizisi için geçerlidir. Eğer
karakter dizisi değişirse bu yöntem de çöpe gider. Bu soruna genel bir çözüm
üretebilsek ne güzel olurdu, değil mi?

İşte Python’da bu sorunu çözmemizi sağlayacak çok güzel bir metot bulunur. Bu
metodun adısplit().

Bu metodun görevi karakter dizilerini belli noktalardan bölmektir. Zatensplitkelimesi Türkçede ‘bölmek, ayırmak’ gibi anlamlara gelir. İşte bu metot, üzerine
uygulandığı karakter dizilerini parçalarına ayırır. Örneğin:

```python
>>> kardiz = "İstanbul Büyükşehir Belediyesi"
>>> kardiz.split()

['İstanbul', 'Büyükşehir', 'Belediyesi']

```

Gördüğünüz gibi bu metot sayesinde“İstanbul Büyükşehir Belediyesi”adlı
karakter dizisini kelimelere bölmeyi başardık. Eğer bu çıktı üzerine birfordöngüsü uygularsak şöyle bir sonuç elde ederiz:

```python
>>> for i in kardiz.split():
... print(i)
...
İstanbul
Büyükşehir
Belediyesi

```

Artık bu bilgiyi kullanarak şöyle bir program yazabiliriz:

```python
kardiz = input("Kısaltmasını öğrenmek istediğiniz kurum adını girin: ")

for i in kardiz.split():
 print(i[0], end="")

```

Burada kullanıcı hangi kurum adını girerse girsin, bu kurum adının her
kelimesinin ilk harfi ekrana dökülecektir. Örneğin kullanıcı burada“Türkiye
Büyük Millet Meclisi”ifadesini girmişsesplit()metodu öncelikle bu
ifadeyi alıp şu şekle dönüştürür:

```python
['Türkiye', 'Büyük', 'Millet', 'Meclisi']

```

Daha sonra biz bu çıktı üzerinde birfordöngüsü kurarsak bu kelime grubunun
her bir öğesine tek tek müdahale etme imkanına erişiriz. Örneğin yukarıdaki
programda bu kelime grubunun her bir öğesinin ilk harfini tek tek ekrana döktük
ve“TBMM”çıktısını elde ettik.

Yukarıdaki örneklerdesplit()metodunu herhangi bir parametre içermeyecek
şekilde kullandık. Yani metodun parantezleri içine herhangi bir şey eklemedik.split()metodunu bu şekilde parametresiz olarak kullandığımızda bu metot
karakter dizilerini bölerken boşluk karakterini ölçüt alacaktır. Yani karakter
dizisi içinde karşılaştığı her boşluk karakterinde bir bölme işlemi
uygulayacaktır. Ama bazen istediğimiz şey, bir karakter dizisini boşluklardan
bölmek değildir. Mesela şu örneğe bakalım:

```python
>>> kardiz = "Bolvadin, Kilis, Siverek, İskenderun, İstanbul"

```

Eğer bu karakter dizisi üzerinesplit()metodunu parametresiz olarak
uygularsak şöyle bir çıktı elde ederiz:

```python
['Bolvadin,', 'Kilis,', 'Siverek,', 'İskenderun,', 'İstanbul']

```

split()metoduna herhangi bir parametre vermediğimiz için bu metot karakter
dizisi içindeki kelimeleri boşluklardan böldü. Bu yüzden karakter dizisi
içindeki virgül işaretleri de bölünen kelimeler içinde görünüyor:

```python
>>> kardiz = kardiz.split()
>>> for i in kardiz:
... print(i)
...
Bolvadin,
Kilis,
Siverek,
İskenderun,
İstanbul

```

Bu arada tıpkıreplace()metodunu anlatırken gösterdiğimiz gibi,kardiz.split()ifadesini de yinekardizadını taşıyan bir değişkene
atadık. Böylecekardiz.split()komutu ile elde ettiğimiz değişiklik
kaybolmamış oldu. Karakter dizilerinin değiştirilemeyen bir veri tipi olduğunu
biliyorsunuz. Dolayısıyla yukarıdaki karakter dizisi üzerinesplit()metodunu uyguladığımızda aslında orijinal karakter dizisi üzerinde herhangi bir
değişiklik yapmış olmuyoruz. Çıktıda görünen değişikliğin orijinal karakter
dizisini etkileyebilmesi için eski karakter dizisini silip, yerine yeni
değerleri yazmamız gerekiyor. Bunu dakardiz=kardiz.split()gibi bir
komutla hallediyoruz.

Nerede kalmıştık? Gördüğünüz gibisplit()metodu parametresiz olarak
kullanıldığında karakter dizisini boşluklardan bölüyor. Ama yukarıdaki örnekte
karakter dizisini boşluklardan değil de virgüllerden bölsek çok daha anlamlı bir
çıktı elde edebiliriz.

Dikkatlice inceleyin:

```python
>>> kardiz = "Bolvadin, Kilis, Siverek, İskenderun, İstanbul"
>>> kardiz = kardiz.split(",")
>>> print(kardiz)

['Bolvadin', ' Kilis', ' Siverek', ' İskenderun', ' İstanbul']

>>> for i in kardiz:
... print(i)
...
Bolvadin
Kilis
Siverek
İskenderun
İstanbul

```

Gördüğünüz gibi,split()metodu tam da istediğimiz gibi, karakter dizisini
bu kez boşluklardan değil virgüllerden böldü. Peki bunu nasıl başardı? Aslında
bu sorunun cevabı gayet net bir şekilde görünüyor. Dikkat ederseniz yukarıdaki
örnektesplit()metoduna parametre olarak virgül karakter dizisini verdik.
Yani şöyle bir şey yazdık:

```python
kardiz.split(",")

```

Bu sayedesplit()metodu karakter dizisini virgüllerden bölmeyi başardı.
Tahmin edebileceğiniz gibi,split()metoduna hangi parametreyi verirseniz bu
metot ilgili karakter dizisini o karakterin geçtiği yerlerden bölecektir. Yani
mesela siz bu metoda“l”parametresini verirseniz, bu metot da ‘l’ harfi geçen
yerden karakter dizisini bölecektir:

```python
>>> kardiz.split("l")

['Bo', 'vadin, Ki', 'is, Siverek, İskenderun, İstanbu', '']

>>> for i in kardiz.split("l"):
... print(i)
...
Bo
vadin, Ki
is, Siverek, İskenderun, İstanbu

```

Eğer parametre olarak verdiğiniz değer karakter dizisi içinde hiç geçmiyorsa
karakter dizisi üzerinde herhangi bir değişiklik yapılmaz:

```python
>>> kardiz.split("z")

['Bolvadin, Kilis, Siverek, İskenderun, İstanbul']

```

Aynı şey,split()metodundan önce öğrendiğimizreplace()metodu için de
geçerlidir. Yani eğer değiştirilmek istenen karakter, karakter dizisi içinde yer
almıyorsa herhangi bir işlem yapılmaz.

split()metodu çoğunlukla, yukarıda anlattığımız şekilde parametresiz olarak
veya tek parametre ile kullanılır. Ama aslında bu metot ikinci bir parametre
daha alır. Bu ikinci parametre, karakter dizisinin kaç kez bölüneceğini
belirler:

```python
>>> kardiz = "Ankara Büyükşehir Belediyesi"

>>> kardiz.split(" ", 1)

['Ankara', 'Büyükşehir Belediyesi']

>>> kardiz.split(" ", 2)

['Ankara', 'Büyükşehir', 'Belediyesi']

```

Gördüğünüz gibi, ilk örnekte kullandığımız1sayısı sayesinde bölme işlemi
karakter dizisi üzerine bir kez uygulandı. İkinci örnekte ise2sayısının
etkisiyle karakter dizimiz iki kez bölme işlemine maruz kaldı.

Elbette,split()metodunun ikinci parametresini kullanabilmek için ilk
parametreyi de mutlaka yazmanız gerekir. Aksi halde Python ne yapmaya
çalıştığınızı anlayamaz:

```python
>>> kardiz.split(2)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly

```

Gördüğünüz gibi, ilk parametreyi es geçip doğrudan ikinci parametreyi yazmaya
çalıştığımızda Python parametre olarak verdiğimiz2sayısının bölme ölçütü
olduğunu zannediyor. Yukarıdaki hatayı engellemek için bölme ölçütünü de açıkça
belirtmemiz gerekir. Yukarıdaki örnekte bölme ölçütümüz bir adet boşluk
karakteri idi. Bildiğiniz gibi, bölme ölçütü herhangi bir şey olabilir. Mesela
virgül.

```python
>>> arkadaşlar = "Ahmet, Mehmet, Kezban, Mualla, Süreyya, Veli"
>>> arkadaşlar.split(",", 3)

['Ahmet', ' Mehmet', ' Kezban', ' Mualla, Süreyya, Veli']

```

Burada da bölme ölçütü olarak virgül karakterini kullandık vearkadaşlaradlı
karakter dizisi üzerine3kez bölme işlemi uyguladık. İlk bölme işlemi“Ahmet”karakter dizisini; ikinci bölme işlemi“Mehmet”karakter dizisini;
üçüncü bölme işlemi ise“Kezban”karakter dizisini ayırdı.arkadaşlaradlı
karakter dizisinin geri kalanını oluşturan“Mualla, Süreyya, Veli”kısmı ise
herhangi bir bölme işlemine tabi tutulmadan tek parça olarak kaldı.

split()metoduyla son bir örnek verip yolumuza devam edelim.

Bildiğiniz gibisysmodülününversiondeğişkeni bize bir karakter dizisi
veriyor:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

Bu karakter dizisi içinden yalnızca sürüm kısmını ayıklamak için karakter
dizilerinin dilimlenme özelliğinden yararlanabiliyoruz:

```python
>>> sürüm = sys.version
>>> print(sürüm[:5])

3.7.0
```

Bu işlemin bir benzerinisplit()metoduyla da yapabiliriz. Dikkatlice
inceleyin:

```python
>>> sürüm = sys.version
>>> sürüm.split()

['3.3.0', '(v3.3.0:bd8afb90ebf2,', 'Sep', '29', '2012,', '10:55:48)',
 '[MSC', 'v.1600', '32', 'bit', '(Intel)]']

```

Gördüğünüz gibi,sys.versionkomutunasplit()metodunu uyguladığımızda,
üzerinde işlem yapması çok daha kolay olan bir veri tipi elde ediyoruz. Bu veri
tipinin adı ‘liste’. Önceki derslerimizde öğrendiğimizdir()fonksiyonunun
da liste adlı bu veri tipini verdiğini hatırlıyor olmalısınız. İlerleyen
derslerde, tıpkı karakter dizileri ve sayılar adlı veri tipleri gibi, liste adlı
veri tipini de bütün ayrıntılarıyla inceleyeceğiz. Şimdilik biz sadecebazı
durumlardaliste veri tipinin karakter dizilerine kıyasla daha kullanışlı bir
veri tipi olduğunu bilelim yeter.

Yukarıdaki örnekten de gördüğünüz gibi,sys.versionkomutunun çıktısınısplit()metodu yardımıyla boşluklardan bölerek bir liste elde ettik. Bu
listenin ilk öğesi, kullandığımız Python serisinin sürüm numarasını verecektir:

```python
>>> print(sürüm.split()[0])

3.7.0
```

Böylecesplit()metodunu öğrenmiş olduk. Gelelimrsplit()metoduna…

rsplit()metodu her yönüylesplit()metoduna benzer.split()ilersplit()arasındaki tek fark,split()metodunun karakter dizisini soldan
sağa,rsplit()metodunun ise sağdan sola doğru okumasıdır. Şu örnekleri
dikkatlice inceleyerek bu iki metot arasındaki farkı bariz bir şekilde
görebilirsiniz:

```python
>>> kardiz.split(" ", 1)

['Ankara', 'Büyükşehir Belediyesi']

>>> kardiz.rsplit(" ", 1)

['Ankara Büyükşehir', 'Belediyesi']

```

Gördüğünüz gibi,split()metodu karakter dizisini soldan sağa doğru okuduğu
için bölme işlemini“Ankara”karakter dizisine uyguladı.rsplit()metodu
ise karakter dizisini sağdan sola soğru okuduğu için bölme işlemini“Belediyesi”adlı karakter dizisine uyguladı.

rsplit()metodunun pek yaygın kullanılan bir metot olmadığını belirtereksplitlines()metoduna geçelim.

Bildiğiniz gibi,split()metodunu bir karakter dizisini kelime kelime
ayırabilmek için kullanabiliyoruz.splitlines()metodunu ise bir karakter
dizisini satır satır ayırmak için kullanabiliriz. Mesela elinizde uzun bir metin
olduğunu ve amacınızın bu metin içindeki herbir satırı ayrı ayrı almak olduğunu
düşünün. İştesplitlines()metoduyla bu amacınızı gerçekleştirebilirsiniz.
Hemen bir örnek verelim:

```python
metin = """Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin
Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını
düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından
gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz
komedi grubunun, Monty Python's Flying Circus adlı gösterisinden esinlenerek
adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama
dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek
halini almıştır diyebiliriz."""

print(metin.splitlines())

```

Bu programı çalıştırdığınızda şöyle bir çıktı alırsınız:

```python
['Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı ',
"tarafından 90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin", 'Python olmasına bakarak, bu programlama dilinin, adını piton
yılanından aldığını ', 'düşünür. Ancak zannedildiğinin aksine bu programlama
dilinin adı piton yılanından ', 'gelmez. Guido Van Rossum bu programlama
dilini, The Monty Python adlı bir İngiliz ', "komedi grubunun, Monty Python's
Flying Circus adlı gösterisinden esinlenerek ", 'adlandırmıştır. Ancak her ne
kadar gerçek böyle olsa da, Python programlama ', 'dilinin pek çok yerde bir
yılan figürü ile temsil edilmesi neredeyse bir gelenek ', 'halini almıştır
diyebiliriz.']

```

Gördüğünüz gibi, metnimizEntertuşuna bastığımız noktalardan bölündü. Biz
henüz bu çıktıyı nasıl değerlendireceğimizi ve bu çıktıdan nasıl
yararlanacağımızı bilmiyoruz. Ayrıca şu anda bu çıktı gözünüze çok anlamlı
görünmemiş olabilir. Ama ‘Listeler’ adlı konuyu öğrendiğimizde bu çıktı size çok
daha anlamlı görünecek.

splitlines()metodu yukarıdaki gibi parametresiz olarak kullanılabileceği
gibi, bir adet parametre ile de kullanılabilir. Bunu bir örnek üzerinde
gösterelim:

```python
metin = """Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin
Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını
düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından
gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz
komedi grubunun, Monty Python's Flying Circus adlı gösterisinden esinlenerek
adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama
dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek
halini almıştır diyebiliriz."""

print(metin.splitlines(True))

```

Bu programı çalıştırdığımızda şuna benzer bir sonuç elde ederiz:

```python
['Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı \n',
"tarafından 90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin \n", 'Python olmasına bakarak, bu programlama dilinin, adını piton
yılanından aldığını \n', 'düşünür. Ancak zannedildiğinin aksine bu programlama
dilinin adı piton yılanından \n', 'gelmez. Guido Van Rossum bu programlama
dilini, The Monty Python adlı bir İngiliz \n', "komedi grubunun, Monty
Python's Flying Circus adlı gösterisinden esinlenerek \n", 'adlandırmıştır.
Ancak her ne kadar gerçek böyle olsa da, Python programlama \n', 'dilinin pek
çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek \n',
'halini almıştır diyebiliriz.']

```

Gördüğünüz gibi, parametresiz kullanımda, program çıktısında satır başı
karakterleri (\n) görünmüyor. Ama eğersplitlines()metoduna parametre
olarakTrueverirsek program çıktısında satır başı karakterleri de
görünüyor. Yazdığınız programlarda ihtiyacınıza göresplitlines()metodunu
parametreli olarak veya parametresiz bir şekilde kullanabilirsiniz.

### lower()

Mutlaka karşılaşmışsınızdır. Bazı programlarda kullanıcıdan istenen veriler
büyük-küçük harfe duyarlıdır. Yani mesela kullanıcıdan bir parola isteniyorsa,
kullanıcının bu parolayı büyük-küçük harfe dikkat ederek yazması gerekir. Bu
programlar açısından, örneğin ‘parola’ ve ‘Parola’ aynı kelimeler değildir.
Mesela kullanıcının parolası ‘parola’ ise, bu kullanıcı programa ‘Parola’
yazarak giremez.

Bazı başka programlarda ise bu durumun tam tersi söz konusudur. Yani büyük-küçük
harfe duyarlı programların aksine bazı programlar da kullanıcıdan gelen verinin
büyük harfli mi yoksa küçük harfli mi olduğunu önemsemez. Kullanıcı doğru
kelimeyi büyük harfle de yazsa, küçük harfle de yazsa program istenen işlemi
gerçekleştirir. Mesela Google’da yapılan aramalar bu mantık üzerine çalışır.
Örneğin ‘kitap’ kelimesini Google’da aratıyorsanız, bu kelimeyi büyük harfle de
yazsanız, küçük harfle de yazsanız Google size aynı sonuçları gösterecektir.
Google açısından, aradığınız kelimeyi büyük ya da küçük harfle yazmanızın bir
önemi yoktur.

Şimdi şöyle bir program yazdığımızı düşünün:

```python
kişi = input("Aradığınız kişinin adı ve soyadı: ")

if kişi == "Ahmet Öz":
 print("email: aoz@hmail.com")
 print("tel : 02121231212")
 print("şehir: istanbul")

elif kişi == "Mehmet Söz":
 print("email: msoz@zmail.com")
 print("tel : 03121231212")
 print("şehir: ankara")

elif kişi == "Mahmut Göz":
 print("email: mgoz@jmail.com")
 print("tel : 02161231212")
 print("şehir: istanbul")

else:
 print("Aradığınız kişi veritabanında yok!")

```

Bu programın doğru çalışabilmesi için kullanıcının, örneğin, Ahmet Öz adlı
kişiyi ararken büyük-küçük harfe dikkat etmesi gerekir. Eğer kullanıcı Ahmet Öz
yazarsa o kişiyle ilgili bilgileri alabilir, ama eğer mesela Ahmet öz yazarsa
bilgileri alamaz. Peki acaba biz bu sorunun üstesinden nasıl gelebiliriz? Yani
programımızın büyük-küçük harfe duyarlı olmamasını nasıl sağlayabiliriz?

Bu işi yapmanın iki yolu var: Birincisiifbloklarını her türlü ihtimali
düşünerek yazabiliriz. Mesela:

```python
if kişi == "Ahmet Öz" or kişi == "Ahmet öz" or kişi == "ahmet öz":
 ...

```

Ama burada bazı problemler var. Birincisi, kullanıcının kaç türlü veri
girebileceğini kestiremeyebilirsiniz. İkincisi, kestirebilseniz bile, her kişi
için olasılıkları girmeye çalışmak eziyetten başka bir şey değildir…

İşte burada imdadımızalower()metodu yetişecek. Dikkatlice inceleyin:

```python
kişi = input("Aradığınız kişinin adı ve soyadı: ")
kişi = kişi.lower()

if kişi == "ahmet öz":
 print("email: aoz@hmail.com")
 print("tel : 02121231212")
 print("şehir: istanbul")

elif kişi == "mehmet söz":
 print("email: msoz@zmail.com")
 print("tel : 03121231212")
 print("şehir: ankara")

elif kişi == "mahmut göz":
 print("email: mgoz@jmail.com")
 print("tel : 02161231212")
 print("şehir: istanbul")

else:
 print("Aradığınız kişi veritabanında yok!")

```

Artık kullanıcı ‘ahmet öz’ de yazsa, ‘Ahmet Öz’ de yazsa, hatta ‘AhMeT öZ’ de
yazsa programımız doğru çalışacaktır. Peki bu nasıl oluyor? Elbettelower()metodu sayesinde…

Yukarıdaki örneklerin de bize gösterdiği gibi,lower()metodu, karakter
dizisindeki bütün harfleri küçük harfe çeviriyor. Örneğin:

```python
>>> kardiz = "ELMA"
>>> kardiz.lower()

'elma'

>>> kardiz = "arMuT"
>>> kardiz.lower()

'armut'

>>> kardiz = "PYTHON PROGRAMLAMA"
>>> kardiz.lower()

'python programlama'

```

Eğer karakter dizisi zaten tamamen küçük harflerden oluşuyorsa bu metot hiçbir
işlem yapmaz:

```python
>>> kardiz = "elma"
>>> kardiz.lower()

'elma'

```

İşte verdiğimiz örnek programda dalower()metodunun bu özelliğinden
yararlandık. Bu metot sayesinde, kullanıcı ne tür bir kelime girerse girsin, bu
kelimeler her halükarda küçük harfe çevrileceği için,ifblokları
kullanıcıdan gelen veriyi yakalayabilecektir.

Gördüğünüz gibi, son derece kolay ve kullanışlı bir metot bu. Ama bu metodun bir
problemi var. Şu örneği dikkatlice inceleyin:

```python
>>> il = "İSTANBUL"
>>> print(il.lower())

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "C:\Python33\lib\encodings\cp857.py", line 19, in encode
 return codecs.charmap_encode(input,self.errors,encoding_map)[0]
UnicodeEncodeError: 'charmap' codec can't encode character '\u0307' in position
1: character maps to <undefined>

```

Buradaki problem ‘İ’ harfinden kaynaklanıyor. Python programlama dili bu harfi
Türkçeye uygun bir şekilde küçültemediği için yukarıdaki hatayı alıyoruz.
Yukarıdaki hatanın tam olarak ne anlama geldiğini birkaç bölüm sonra
anlayacaksınız. Biz şimdilik sadece Python’ın ‘İ’ harfini Türkçeye uygun olarak
küçültemediğini bilelim yeter.

Bir de şu örneğe bakalım:

```python
>>> il = "ADIYAMAN"
>>> print(il.lower())

adiyaman

```

Gördüğünüz gibi, Python programlama dili ‘I’ harfini de düzgün küçültemiyor. ‘I’
harfinin küçük biçimi ‘ı’ olması gerekirken, bu metot ‘I’ harfini ‘i’ diye
küçültüyor. Yani:

```python
>>> "I".lower()

'i'

```

Peki bu durumda ne yapacağız? Elimiz kolumuz bağlı oturacak mıyız? Elbette
hayır! Biz bu tür küçük sorunları aşabilecek kadar Python bilgisine sahibiz. ‘İ’
ve ‘I’ harfleri ile ilgili problemi, yalnızca mevcut bilgilerimizi kullanarak
rahatlıkla çözebiliriz:

```python
iller = "ISPARTA, ADIYAMAN, DİYARBAKIR, AYDIN, BALIKESİR, AĞRI"

iller = iller.replace("I", "ı").replace("İ", "i").lower()
print(iller)

```

Bu kodlarla yaptığımız şey çok basit:
1. İlkreplace()metoduyla karakter dizisi içinde geçen bütün ‘I’
harflerini, ‘ı’ ile değiştiriyoruz.
1. İkincireplace()metoduyla karakter dizisi içinde geçen bütün ‘İ’
harflerini ‘i’ ile değiştiriyoruz.
1. Bu iki işlemin ardından karakter dizisi içinde geçen ‘I’ ve ‘İ’
harflerini küçültmüş olduk. Ancak öteki harfler henüz küçülmedi. O yüzden de
karakter dizimiz üzerine bir delower()metodunu uyguluyoruz. Böylece
bütün harfler düzgün bir şekilde küçülmüş oluyor.
1. Bu kodlarda farklı metotları uç uca nasıl eklediğimize dikkat edin.

İlkreplace()metoduyla karakter dizisi içinde geçen bütün ‘I’
harflerini, ‘ı’ ile değiştiriyoruz.

İkincireplace()metoduyla karakter dizisi içinde geçen bütün ‘İ’
harflerini ‘i’ ile değiştiriyoruz.

Bu iki işlemin ardından karakter dizisi içinde geçen ‘I’ ve ‘İ’
harflerini küçültmüş olduk. Ancak öteki harfler henüz küçülmedi. O yüzden de
karakter dizimiz üzerine bir delower()metodunu uyguluyoruz. Böylece
bütün harfler düzgün bir şekilde küçülmüş oluyor.

Bu kodlarda farklı metotları uç uca nasıl eklediğimize dikkat edin.

Bu örnek size şunu göstermiş olmalı: Aslında programlama dediğimiz şey gerçekten
de çok basit parçaların uygun bir şekilde birleştirilmesinden ibaret. Tıpkı bir
yap-bozun parçalarını birleştirmek gibi…

Ayrıca bu örnek sizi bir gerçekle daha tanıştırıyor: Gördüğünüz gibi, artık
Python’da o kadar ilerlediniz ki Python’ın problemlerini tespit edip bu
problemlere çözüm dahi üretebiliyorsunuz!

### upper()

Bu metot biraz önce öğrendiğimizlower()metodunun yaptığı işin tam tersini
yapar. Hatırlarsanızlower()metodu yardımıyla karakter dizileri içindeki
harfleri küçültüyorduk.upper()metodu ise bu harfleri büyütmemizi sağlar.

Örneğin:

```python
>>> kardiz = "kalem"
>>> kardiz.upper()

'KALEM'

```

lower()metodunu anlatırken, kullanıcıdan gelen verileri belli bir düzene
sokmak konusunda bu metodun oldukça faydalı olduğunu söylemiştik. Kullanıcıdan
gelen verilerinlower()metodu yardımıyla standart bir hale getirilmesi
sayesinde, kullanıcının girdiği kelimelerin büyük-küçük harfli olmasının önemli
olmadığı programlar yazabiliyoruz. Elbette eğer isterseniz kullanıcıdan gelen
bütün verilerilower()metoduyla küçük harfe çevirmek yerine,upper()metoduyla büyük harfe çevirmeyi de tercih edebilirsiniz. Python programcıları
genellikle kullanıcı verilerini standart bir hale getirmek için bütün harfleri
küçültmeyi tercih eder, ama tabii ki sizin bunun tersini yapmak istemenizin
önünde hiçbir engel yok.

Diyelim ki, şehirlere göre hava durumu bilgisi veren bir program yazmak
istiyorsunuz. Bunun için şöyle bir kod yazarak işe başlayabilirsiniz:

```python
şehir = input("Hava durumunu öğrenmek için bir şehir adı girin: ")

if şehir == "ADANA":
 print("parçalı bulutlu")

elif şehir == "ERZURUM":
 print("karla karışık yağmurlu")

elif şehir == "ANTAKYA":
 print("açık ve güneşli")

else:
 print("Girdiğiniz şehir veritabanında yok!")

```

Burada programımızın doğru çalışabilmesi, kullanıcının şehir adlarını büyük
harfle girmesine bağlıdır. Örneğin programımız ‘ADANA’ cevabını kabul edecek,
ama mesela ‘Adana’ cevabını kabul etmeyecektir. Bunu engellemek içinlower()metodunu kullanabileceğimizi biliyoruz. Bu sorunu çözmek için aynı şekildeupper()metodunu da kullanabiliriz:

```python
şehir = input("Hava durumunu öğrenmek için bir şehir adı girin: ")

şehir = şehir.upper()

if şehir == "ADANA":
 print("parçalı bulutlu")

elif şehir == "ERZURUM":
 print("karla karışık yağmurlu")

elif şehir == "ANTAKYA":
 print("açık ve güneşli")

else:
 print("Girdiğiniz şehir veritabanında yok!")

```

Burada yazdığımızşehir=şehir.upper()kodu sayesinde artık kullanıcı şehir
adını büyük harfle de girse, küçük harfle de girse programımız düzgün
çalışacaktır.

Hatırlarsanızlower()metodunu anlatırken bu metodun bazı Türkçe
karakterlerle problemi olduğunu söylemiştik. Aynı sorun, tahmin edebileceğiniz
gibi,upper()metodu için de geçerlidir.

Dikkatlice inceleyin:

```python
>>> kardiz = "istanbul"
>>> kardiz.upper()

'ISTANBUL'

```

lower()metodu Türkçe’deki ‘I’ harfini ‘i’ şeklinde küçültüyordu.upper()metodu ise ‘i’ harfini yanlış olarak ‘I’ şeklinde büyütüyor. Elbette
bu sorun da çözülemeyecek gibi değil. Burada dalower()metodu için
uyguladığımız yöntemin bir benzerini uygulayacağız:

```python
iller = "istanbul, izmir, siirt, mersin"

iller = iller.replace("i", "İ").upper()
print(iller)

```

Bu kodlarla, önce karakter dizisi içinde geçen ‘i’ harflerini ‘İ’ ile
değiştiriyoruz. Böylece şöyle bir şey elde etmiş oluyoruz:

```python
İstanbul, İzmİr, sİİrt, mersİn

```

Gördüğünüz gibi öteki harfler eski hallerinde kaldı. Öteki harfleri de
büyütebilmek için karakter dizisineupper()metodunu uygulamamız yeterli
olacaktır.

Bir sorunun daha üstesinden geldiğimize göre kendimizden emin bir şekilde bir
sonraki metodumuzu incelemeye geçebiliriz.

### islower(), isupper()

Yukarıda öğrendiğimizlower()veupper()adlı metotlar karakter dizileri
üzerinde bazı değişiklikler yapmamıza yardımcı oluyor. Karakter dizileri
üzerinde birtakım değişiklikler yapmamızı sağlayan bu tür metotlara ‘değiştirici
metotlar’ adı verilir. Bu tür metotların dışında bir de ‘sorgulayıcı
metotlar’dan söz edebiliriz. Sorgulayıcı metotlar, değiştirici metotların
aksine, bir karakter dizisi üzerinde değişiklik yapmamızı sağlamaz. Bu tür
metotların görevi karakter dizilerinin durumunu sorgulamaktır. Sorgulayıcı
metotlara örnek olarakislower()veisupper()metotlarını verebiliriz.

Bildiğiniz gibi,lower()metodu bir karakter dizisini tamamen küçük
harflerden oluşacak şekle getiriyordu.islower()metodu ise bir karakter
dizisinin tamamen küçük harflerden oluşup oluşmadığını sorguluyor.

Hemen bir örnek verelim:

```python
>>> kardiz = "istihza"
>>> kardiz.islower()

True

```

“istihza”tamamen küçük harflerden oluşan bir karakter dizisi olduğu içinislower()sorgusuTrueçıktısı veriyor. Bir de şuna bakalım:

```python
>>> kardiz = "Ankara"
>>> kardiz.islower()

False

```

“Ankara”ise içinde bir adet büyük harf barındırdığı içinislower()sorgusunaFalsecevabı veriyor.

Yazdığınız programlarda, örneğin, kullanıcıdan gelen verinin sadece küçük
harflerden oluşmasını istiyorsanız bu metottan yararlanarak kullanıcıdan gelen
verinin gerçekten tamamen küçük harflerden oluşup oluşmadığını
denetleyebilirsiniz:

```python
veri = input("Adınız: ")

if not veri.islower():
 print("Lütfen isminizi sadece küçük harflerle yazın")

```

isupper()metodu daislower()metodunun yaptığı işin tam tersini yapar.
Bildiğiniz gibi,upper()metodu bir karakter dizisini tamamen büyük
harflerden oluşacak şekle getiriyordu.isupper()metodu ise bir karakter
dizisinin tamamen büyük harflerden oluşup oluşmadığını sorguluyor:

```python
>>> kardiz = "İSTİHZA"
>>> kardiz.isupper()

True

>>> kardiz = "python"
>>> kardiz.isupper()

False

```

Tıpkıislower()metodunda olduğu gibi,isupper()metodunu da
kullanıcıdan gelen verinin büyük harfli mi yoksa küçük harfli mi olduğunu
denetlemek için kullanabilirsiniz.

Örneğin, internet kültüründe kullanıcıların forum ve e.posta listesi gibi
yerlerde tamamı büyük harflerden oluşan kelimelerle yazması kaba bir davranış
olarak kabul edilir. Kullanıcıların tamamı büyük harflerden oluşan kelimeler
kullanmasını engellemek için yukarıdaki metotlardan yararlanabilirsiniz:

```python
veri = input("mesajınız: ")
böl = veri.split()

for i in böl:
 if i.isupper():
 print("Tamamı büyük harflerden oluşan kelimeler kullanmayın!")

```

Burada kullanıcının girdiği mesaj içindeki her kelimeyi tek tek sorgulayabilmek
için önceliklesplit()metodu yardımıyla karakter dizisini parçalarına
ayırdığımıza dikkat edin.böl=veri.split()satırının tam olarak ne işe
yaradığını anlamak için bu programı bir de o satır olmadan çalıştırmayı
deneyebilirsiniz.

islower()veisupper()metotları programlamada sıklıkla kullanılan
karakter dizisi metotlarından ikisidir. Dolayısıyla bu iki metodu iyi öğrenmek
programlama maceranız sırasında işlerinizi epey kolaylaştıracaktır.

### endswith()

Tıpkıisupper()veislower()metotları gibi,endswith()metodu da
sorgulayıcı metotlardan biridir.endswith()metodu karakter dizileri
üzerinde herhangi bir değişiklik yapmamızı sağlamaz. Bu metodun görevi karakter
dizisinin durumunu sorgulamaktır.

Bu metot yardımıyla bir karakter dizisinin hangi karakter dizisi ile bittiğini
sorgulayabiliyoruz. Yani örneğin:

```python
>>> kardiz = "istihza"
>>> kardiz.endswith("a")

True

```

Burada, değeri“istihza”olankardizadlı bir karakter dizisi tanımladık.
Daha sonra dakardiz.endswith("a")ifadesiyle bu karakter dizisinin“a”karakteri ile bitip bitmediğini sorguladık. Gerçekten de“istihza”karakter
dizisinin sonunda“a”karakteri bulunduğu için Python bizeTruecevabı
verdi. Bir de şuna bakalım:

```python
>>> kardiz.endswith("z")

False

```

Bu defa daFalseçıktısı aldık. Çünkü karakter dizimiz ‘z’ harfiyle bitmiyor.

Gelin isterseniz elimizi alıştırmak için bu metotla birkaç örnek daha yapalım:

```python
d1 = "python.ogg"
d2 = "tkinter.mp3"
d3 = "pygtk.ogg"
d4 = "movie.avi"
d5 = "sarki.mp3"
d6 = "filanca.ogg"
d7 = "falanca.mp3"
d8 = "dosya.avi"
d9 = "perl.ogg"
d10 = "c.avi"
d11 = "c++.mp3"

for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i.endswith(".mp3"):
 print(i)

```

Bu örnekte, elimizde farklı uzantılara sahip bazı dosyalar olduğunu varsaydık ve
bu dosya adlarının herbirini ayrı birer değişken içinde depoladık. Gördüğünüz
gibi, dosya uzantıları.ogg,.mp3veya.avi. Bizim burada amacımız
elimizdeki mp3 dosyalarını listelemek. Bu işlem içinendswith()metodundan
yararlanabiliyoruz. Burada yaptığımız şey şu:

Öncelikled1,d2,d3,d4,d5,d6,d7,d8,d9,d10ved11adlı değişkenleri birfordöngüsü içine alıyoruz ve bu değişkenlerinin
herbirinin içeriğini tek tek kontrol ediyoruz (foriind1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11:). Ardından, eğer baktığımız bu değişkenlerin
değerleri “.mp3” ifadesi ile bitiyorsa (ifi.endswith(".mp3"):), ölçüte uyan
bütün karakter dizilerini ekrana döküyoruz (print(i)).

Yukarıdaki örneği, dilerseniz,endswith()metodunu kullanmadan şöyle de
yazabilirsiniz:

```python
for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i[-4:len(i)] == ".mp3":
 print(i)

```

Burada karakter dizilerinin dilimlenebilme özelliğinden yararlandık. Ancak
gördüğünüz gibi, dilimlenecek kısmı ayarlamaya uğraşmak yerineendswith()metodunu kullanmak çok daha mantıklı ve kolay bir yöntemdir.

Yukarıdaki örnekte de gördüğünüz gibi,endswith()metodu özellikle dosya
uzantılarına göre dosya türlerini tespit etmede oldukça işe yarar bir metottur.

### startswith()

Bu metot, biraz önce gördüğümüzendswith()metodunun yaptığı işin tam
tersini yapar. Hatırlarsanızendswith()metodu bir karakter dizisinin hangi
karakter veya karakterlerle bittiğini denetliyordu.startswith()metodu ise
bir karakter dizisinin hangi karakter veya karakterlerle başladığını denetler:

```python
>>> kardiz = "python"
>>> kardiz.startswith("p")

True

>>> kardiz.startswith("a")

False

```

Gördüğünüz gibi, eğer karakter dizisi gerçekten belirtilen karakterle başlıyorsa
PythonTrueçıktısı, yok eğer belirtilen karakterle başlamıyorsaFalseçıktısı veriyor.

Bu metodun gerçek hayatta nasıl kullanılabileceğine dair bir örnek verelim:

```python
d1 = "python.ogg"
d2 = "tkinter.mp3"
d3 = "pygtk.ogg"
d4 = "movie.avi"
d5 = "sarki.mp3"
d6 = "filanca.ogg"
d7 = "falanca.mp3"
d8 = "dosya.avi"
d9 = "perl.ogg"
d10 = "c.avi"
d11 = "c++.mp3"

for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i.startswith("p"):
 print(i)

```

Burada ‘p’ harfiyle başlayan bütün dosyaları listeledik. Elbette aynı etkiyi şu
şekilde de elde edebilirsiniz:

```python
for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i[0] == "p":
 print(i)

```

Sadece tek bir harfi sorguluyorsanız yukarıdaki yöntem de en azstartswith()metodunu kullanmak kadar pratiktir. Ama birden fazla karakteri sorguladığınız
durumlarda elbettestartswith()çok daha mantıklı bir tercih olacaktır:

```python
for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i.startswith("py"):
 print(i)

```

Yukarıda yazdığımız kodu dilimleme tekniğinden yararlanarak yeniden yazmak
isterseniz şöyle bir şeyler yapmanız gerekiyor:

```python
for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:
 if i[:2] == "py":
 print(i)

```

Dediğim gibi, birden fazla karakteri sorguladığınız durumlarda, dilimlemek
istediğiniz kısmın karakter dizisi içinde hangi aralığa denk geldiğini
hesaplamaya uğraşmak yerine, daha kolay bir yöntem olanstartswith()metodundan yararlanmayı tercih edebilirsiniz.

Böylece karakter dizilerinin 2. bölümünü de bitirmiş olduk. Sonraki bölümde yine
karakter dizilerinin metotlarından söz etmeye devam edeceğiz.

## Karakter Dizilerinin Metotları (Devamı)

Karakter dizileri konusunun en başında söylediğimiz gibi, karakter dizileri
metot yönünden bir hayli zengin bir veri tipidir. Bir önceki bölümde karakter
dizileri metotlarının bir kısmını incelemiştik. Bu bölümde yine metotları
incelemeye devam edeceğiz.

### capitalize()

Hatırlarsanız, bir önceki bölümde öğrendiğimizstartswith()veendswith()metotları karakter dizileri üzerinde herhangi bir değişiklik
yapmıyordu. Bu iki metodun görevi, karakter dizilerini sorgulamamızı sağlamaktı.
Şimdi göreceğimizcapitalize()metodu ise karakter dizileri üzerinde
değişiklik yapmamızı sağlayacak. Dolayısıyla bucapitalize()metodu da
‘değiştirici metotlar’dan biridir diyebiliriz.

Hatırlarsanız,upper()velower()metotları bir karakter dizisi içindeki
bütün karakterleri etkiliyordu. Yani meselaupper()metodunu bir karakter
dizisine uygularsak, o karakter dizisi içindeki bütün karakterler büyük harfe
dönecektir. Aynı şekildelower()metodu da bir karakter dizisi içindeki
bütün karakterleri küçük harfe çevirir.

Şimdi göreceğimizcapitalize()metodu daupper()velower()metotlarına benzemekle birlikte onlardan biraz daha farklı davranır:capitalize()metodunun görevi karakter dizilerinin yalnızca ilk harfini
büyütmektir. Örneğin:

```python
>>> a = "python"
>>> a.capitalize()

'Python'

```

Bu metodu kullanırken dikkat etmemiz gereken bir nokta var: Bu metot bir
karakter dizisinin yalnızca ilk harfini büyütür. Yani birden fazla kelimeden
oluşan karakter dizilerine bu metodu uyguladığımızda bütün kelimelerin ilk harfi
büyümez. Yalnızca ilk kelimenin ilk harfi büyür. Yani:

```python
>>> a = "python programlama dili"
>>> a.capitalize()

'Python programlama dili'

```

“python programlama dili”üç kelimeden oluşan bir karakter dizisidir. Bu
karakter dizisi üzerinecapitalize()metodunu uyguladığımızda bu üç
kelimenin tamamının ilk harfleri büyümüyor. Yalnızca ilk ‘python’ kelimesinin
ilk harfi bu metottan etkileniyor.

Bu aradacapitalize()metodunu kullanırken bir şey dikkatinizi çekmiş
olmalı. Bu metodun da, tıpkıupper()velower()metotlarında olduğu
gibi, Türkçe karakterlerden bazıları ile ufak bir problemi var. Mesela şu örneğe
bir bakın:

```python
>>> kardiz = "istanbul"
>>> kardiz.capitalize()

'Istanbul'

```

‘istanbul’ kelimesinin ilk harfi büyütüldüğünde ‘İ’ olması gerekirken ‘I’ oldu.
Bildiğiniz gibi bu problem ‘ş’, ‘ç’, ‘ö’, ‘ğ’ ve ‘ü’ gibi öteki Türkçe
karakterlerde karşımıza çıkmaz. Sadece ‘i’ ve ‘İ’ harfleri karakter dizisi
metotlarında bize problem çıkaracaktır. Ama endişe etmemize hiç gerek yok. Bu
sorunu da basit bir ‘if-else’ yapısıyla çözebilecek kadar Python bilgisine
sahibiz:

```python
kardiz = "istanbul büyükşehir belediyesi"

if kardiz.startswith("i"):
 kardiz = "İ" + kardiz[1:]

kardiz = kardiz.capitalize()

print(kardiz)

```

Burada yaptığımız şey şu: Eğer değişkenin tuttuğu karakter dizisi ‘i’ harfi ile
başlıyorsa,"İ"+kardiz[1:]kodunu kullanarak karakter dizisinin ilk harfi
dışında kalan kısmıyla ‘İ’ harfini birleştiriyoruz. Bu yapıyı daha iyi
anlayabilmek için etkileşimli kabukta şu denemeleri yapabilirsiniz:

```python
>>> kardiz = "istanbul"
>>> kardiz[1:]

'stanbul'

```

Gördüğünüz gibi,kardiz[1:]kodu bize karakter dizisinin ilk harfi hariç
geri kalan kısmını veriyor. Bu yapıyı dilimleme konusundan hatırlıyor
olmalısınız. İşte biz dilimleme tekniğinin bu özelliğinden yararlanarak,
karakter dizisinin ilk harfini kesip, baş tarafa bir adet ‘İ’ harfi ekliyoruz:

```python
>>> "İ" + kardiz[1:]

'İstanbul'

```

Hatırlarsanız karakter dizilerinin değiştirilemeyen bir veri tipi olduğunu
söylemiştik. O yüzden, karakter dizisinin“stanbul”kısmını ‘İ’ harfiyle
birleştirdikten sonra, bu değişikliğin kalıcı olabilmesi içinkardiz="İ"+kardiz[1:]kodu yardımıyla, yaptığımız değişikliği tekrarkardizadlı bir
değişkene atıyoruz.

Böylece;

```python
if kardiz.startswith("i"):
 kardiz = "İ" + kardiz[1:]

```

kodlarının ne yaptığını anlamış olduk. Kodların geri kalanında ise şöyle bir kod
bloğu görüyoruz:

```python
kardiz = kardiz.capitalize()

```

Buna göre, hangi harfle başlarsa başlasın Python’ın standartcapitalize()metodunu bu karakter dizisi üzerine uyguluyoruz.

Son olarak daprint(kardiz)kodunu kullanarak yeni karakter dizisini ekrana
yazdırıyoruz ve böylececapitalize()metodundaki Türkçe karakter sorununu
kıvrak bir çalımla aşmış oluyoruz.

### title()

Bu metot biraz önce öğrendiğimizcapitalize()metoduna benzer. Bildiğiniz
gibicapitalize()metodu bir karakter dizisinin yalnızca ilk harfini
büyütüyordu.title()metodu da karakter dizilerinin ilk harfini büyütür. Amacapitalize()metodundan farklı olarak bu metot, birden fazla kelimeden
oluşan karakter dizilerinin her kelimesinin ilk harflerini büyütür.

Bunu bir örnek üzerinde anlatsak sanırım daha iyi olacak:

```python
>>> a = "python programlama dili"
>>> a.capitalize()

'Python programlama dili'

>>> a.title()

'Python Programlama Dili'

```

capitalize()metodu iletitle()metodu arasındaki fark bariz bir biçimde
görünüyor. Dediğimiz gibi,capitalize()metodu yalnızca ilk kelimenin ilk
harfini büyütmekle yetinirken,title()metodu karakter dizisi içindeki bütün
kelimelerin ilk harflerini büyütüyor.

Tahmin edebileceğiniz gibi,capitalize()metodundaki Türkçe karakter
problemititle()metodu için de geçerlidir. Yani:

```python
>>> kardiz = "istanbul"
>>> kardiz.title()

'Istanbul'

>>> kardiz = "istanbul büyükşehir belediyesi"
>>> kardiz.title()

'Istanbul Büyükşehir Belediyesi'

```

Gördüğünüz gibi, burada da Python ‘i’ harfini düzgün büyütemedi. Ama tabii ki bu
bizi durduramaz! Çözümümüz hazır:

```python
kardiz = "istanbul"

if kardiz.startswith("i"):
 kardiz = "İ" + kardiz[1:]
 kardiz = kardiz.title()
else:
 kardiz = kardiz.title()

print(kardiz)

```

Bu kodlarıncapitalize()metodunu anlatırken verdiğimiz koda ne kadar
benzediğini görüyorsunuz. Bu iki kod hemen hemen birbirinin aynısı. Tek fark, en
sondakikardiz.capitalize()kodunun buradakardiz.title()olması veifbloğu içine ek olarakkardiz=kardiz.title()satırını yazmış
olmamız.kardiz.capitalize()kodunun nedenkardiz.title()koduna
dönüştüğünü açıklamaya gerek yok. Ama eğerkardiz=kardiz.title()kodunun
ne işe yaradığını tam olarak anlamadıysanız o satırı silin vekardizdeğişkeninin değerini“istanbul büyükşehir belediyesi”yapın. Yani:

```python
kardiz = "istanbul büyükşehir belediyesi"

if kardiz.startswith("i"):
 kardiz = "İ" + kardiz[1:]
else:
 kardiz = kardiz.title()

print(kardiz)

```

Bu kodları bu şekilde çalıştırırsanız şu çıktıyı alırsınız:

```python
İstanbul büyükşehir belediyesi

```

Burada yalnızca ilk kelimenin ilk harfi büyüdü. Halbukititle()metodunun
işleyişi gereğince karakter dizisi içindeki bütün kelimelerin ilk harflerinin
büyümesi gerekiyordu. İşte o satır bütün kelimelerin ilk harflerinin büyümesini
sağlıyor. Eğer bir kelimenin ilk harfi zaten büyüksetitle()metodu bu harfe
dokunmaz, ama karakter dizisi içindeki öbür kelimelerin ilk harflerini yine de
büyütür.

İşte yukarıdatitle()metodunun bu özelliğinden faydalanıyoruz.kardiz="İ"+kardiz[1:]komutu karakter dizisinin ilk kelimesinin ilk harfini düzgün
bir şekilde büyütüyor, ama geri kalan kelimelere hiçbir şey yapmıyor.kardiz=kardiz.title()komutu ise karakter dizisi içindeki geri kalan kelimelerin ilk
harflerini büyütüyor. Böylece istediğimiz çıktıyı elde edebilmiş oluyoruz.
Yalnız bu kodlarda bir şey dikkatinizi çekmiş olmalı.kardiz=kardiz.title()komutunu program içinde iki yerde kullandık. Programcılıktaki
en önemli ilkelerden biri de mümkün olduğunca tekrardan kaçınmaktır. Eğer
yazdığınız bir programda aynı kodları program boyunca tekrar tekrar yazıyorsanız
muhtemelen bir yerde hata yapıyorsunuzdur. Öyle bir durumda yapmanız gereken şey
kodlarınızı tekrar gözden geçirip, tekrar eden kodları nasıl azaltabileceğinizi
düşünmektir. İşte burada da böyle bir tekrar söz konusu. Biz tekrara düşmekten
kurtulmak için yukarıdaki kodları şöyle de yazabiliriz:

```python
kardiz = "istanbul büyükşehir belediyesi"

if kardiz.startswith("i"):
 kardiz = "İ" + kardiz[1:]

kardiz = kardiz.title()

print(kardiz)

```

kardiz=kardiz.title()komutunu hemifbloğunda, hem deelsebloğunda kullandığımız için, programımız her koşulda bu kodu zaten çalıştıracak.
O yüzden bu satırıifbloğuna yazdıktan sonra bir de aynı şeyielsebloğu içine yazmak gereksiz. Onun yerineelsebloğunu tamamen kaldırıp, o
satırıifbloğunun çıkışına yerleştirebiliriz.

Eski kodlardaki mantık işleyişi şöyle idi:
1. kardizadlı bir değişken tanımla
1. Eğerkardiz‘i’ harfi ile başlıyorsa (if),kardiz’in ilk harfi
hariç geri kalan kısmı ile ‘İ’ harfini birleştir.
1. Daha sonrakardizdeğişkeninetitle()metodunu uygula.
1. Eğerkardiz‘i’ harfi ile değil de başka bir harfle başlıyorsa (else),kardizdeğişkeninetitle()metodunu uygula.
1. Son olarakkardizdeğişkenini yazdır.

kardizadlı bir değişken tanımla

Eğerkardiz‘i’ harfi ile başlıyorsa (if),kardiz’in ilk harfi
hariç geri kalan kısmı ile ‘İ’ harfini birleştir.

Daha sonrakardizdeğişkeninetitle()metodunu uygula.

Eğerkardiz‘i’ harfi ile değil de başka bir harfle başlıyorsa (else),kardizdeğişkeninetitle()metodunu uygula.

Son olarakkardizdeğişkenini yazdır.

Tekrar eden kodları çıkardıktan sonra ise kodlarımızın mantık işleyişi şöyle
oldu:
1. kardizadlı bir değişken tanımla
1. Eğerkardiz‘i’ harfi ile başlıyorsa (if),kardiz’in ilk harfi
hariç geri kalan kısmı ile ‘İ’ harfini birleştir.
1. Daha sonrakardizdeğişkeninetitle()metodunu uygula.
1. Son olarakkardizdeğişkenini yazdır.

kardizadlı bir değişken tanımla

Eğerkardiz‘i’ harfi ile başlıyorsa (if),kardiz’in ilk harfi
hariç geri kalan kısmı ile ‘İ’ harfini birleştir.

Daha sonrakardizdeğişkeninetitle()metodunu uygula.

Son olarakkardizdeğişkenini yazdır.

Gördüğünüz gibi, aynı sonuca daha kısa bir yoldan ulaşabiliyoruz.

Ama bir dakika! Burada bir sorun var!

Bu kodlar ‘i’ harfinin karakter dizisinin yalnızca en başında yer aldığı
durumlarda düzgün çalışacaktır. Bu kodlar mesela şu karakter dizisini düzgün
büyütemez:

```python
on iki ada

```

Aynı şekilde bu kodlar şu karakter dizisini de büyütemez:

```python
hükümet istifa!

```

Çünkü bu karakter dizilerinde ‘i’ harfi karakter dizisini oluşturan kelimelerin
ilkinde yer almıyor. Bizim yazdığımız kod ise yalnızca ilk kelime düşünülerek
yazılmış. Peki bu sorunun üstesinden nasıl geleceğiz?

Evet, doğru tahmin ettiniz. Bizi kurtaracak şeysplit()metodu ve basit birfordöngüsü. Dikkatlice bakın:

```python
kardiz = "on iki ada"

for kelime in kardiz.split():
 if kelime.startswith("i"):
 kelime = "İ" + kelime[1:]

 kelime = kelime.title()

 print(kelime, end=" ")

```

Bu defa istediğimizi gerçekleştiren bir kod yazabildik. Bu kodlar, ‘i’ harfi
karakter dizisini oluşturan kelimelerin hangisinde bulunursa bulunsun, karakter
dizisini Türkçeye uygun bir şekilde büyütebilecektir.

Bir önceki kodlara göre, bu son kodlardaki tek farkınsplit()metodu vefordöngüsü olduğuna dikkat edin.

Bu kodları daha iyi anlayabilmek için etkileşimli kabukta kendi kendinize bazı
deneme çalışmaları yapabilirsiniz:

```python
>>> kardiz = "on iki ada"
>>> kardiz.split()

['on', 'iki', 'ada']

>>> for kelime in kardiz.split():
... print(kelime[0])
...
o
i
a

```

Gördüğünüz gibi,split()metodu"onikiada"adlı karakter dizisini
kelimelerine ayırıyor. İşte biz de kelimelerine ayrılmış bu yapı üzerinde birfordöngüsü kurarak herbir öğenin ilk harfinin ‘i’ olup olmadığını kontrol
edebiliyoruz.

### swapcase()

swapcase()metodu da büyük-küçük harfle ilgili bir metottur. Bu metot bir
karakter dizisi içindeki büyük harfleri küçük harfe; küçük harfleri de büyük
harfe dönüştürür. Örneğin:

```python
>>> kardiz = "python"
>>> kardiz.swapcase()

'PYTHON'

>>> kardiz = "PYTHON"
>>> kardiz.swapcase()

'python'

>>> kardiz = "Python"
>>> kardiz.swapcase()

'pYTHON'

```

Gördüğünüz gibi, bu metot aynen dediğimiz gibi işliyor. Yani küçük harfleri
büyük harfe; büyük harfleri de küçük harfe dönüştürüyor.

Yine tahmin edebileceğiniz gibi, bu metodun da bazı Türkçe karakterlerle
problemi var:

```python
>>> kardiz = "istihza"
>>> kardiz.swapcase()

'ISTIHZA'

```

Bu sorunu da aşmak tabii ki bizim elimizde:

```python
kardiz = "istanbul"

for i in kardiz:
 if i == 'İ':
 kardiz = kardiz.replace('İ', 'i')
 elif i == 'i':
 kardiz = kardiz.replace('i', 'İ')
 else:
 kardiz = kardiz.replace(i, i.swapcase())

print(kardiz)

```

Daha önceki örneklerde de olduğu gibi, bu kodlarda da ‘i’ ve ‘I’ harflerini tek
tek kontrolden geçiriyoruz. Eğer bir karakter dizisi içinde bu iki harften biri
varsa, bunların büyük harf veya küçük harf karşılıklarını elle yerine koyuyoruz.
Bu karakterler dışında kalan karakterlere ise doğrudanswapcase()metodunu
uygulayarak istediğimiz sonucu elde ediyoruz. Bu kodlarda kafanıza yatmayan
yerler varsa, kodlar içinde kendinize göre bazı eklemeler çıkarmalar yaparak
neyin ne işe yaradığını daha kolay anlayabilirsiniz.

### casefold()

Bu metot işlev olaraklower()metoduna çok benzer. Hatta Türkçe açısından,
bu metodunlower()metodundan hiçbir farkı yoktur. Ancak bazı başka
dillerde, bu metot bazı harfler içinlower()metodunun verdiğinden farklı
bir çıktı verir. Örneğin Almancadaki ‘ß’ harfi bu duruma bir örnek olabilir:

```python
>>> "ß".lower()
'ß'

>>> "ß".casefold()
'ss'

```

Gördüğünüz gibi,lower()vecasefold()metotları bu harfe farklı
davranıyor.

Türkçedeki İ-i sorunu bu metot için de aynen geçerlidir.

### strip(), lstrip(), rstrip()

Bu başlıkta birbiriyle bağlantılı üç adet karakter dizisi metodunu
inceleyeceğiz. Bu metotlarstrip(),lstrip()verstrip(). İlk olarakstrip()metoduyla başlayalım.

Zaman zaman, içinde anlamsız ya da gereksiz karakterler barındıran metinleri bu
anlamsız ve gereksiz karakterlerden temizlemeniz gereken durumlarla
karşılaşabilirsiniz. Örneğin arkadaşınızdan gelen bir e.postada her satırın
başında ve/veya sonunda>gibi bir karakter olabilir. Arkadaşınızdan gelen bu
e.postayı kullanabilmek için öncelikle metin içindeki o>karakterlerini
silmeniz gerekebilir. Hepimizin bildiği gibi, bu tür karakterleri elle
temizlemeye kalkışmak son derece sıkıcı ve zaman alıcı bir yöntemdir. Ama artık
siz bir Python programcısı olduğunuza göre bu tür angaryaları Python’a
devredebilirsiniz.

Yukarıda bahsettiğimiz duruma yönelik bir örnek vermeden önce dilersenizstrip()metoduyla ilgili çok basit örnekler vererek başlayalım işe:

```python
>>> kardiz = " istihza "

```

Burada değeri“ istihza “olankardizadlı bir karakter dizisi tanımladık.
Dikkat ederseniz bu karakter dizisinin sağında ve solunda birer boşluk karakteri
var. Bazı durumlarda kullanıcıdan ya da başka kaynaktan gelen karakter
dizilerinde bu tür istenmeyen boşluklar olabilir. Ama sizin kullanıcıdan veya
başka bir kaynaktan gelen o karakter dizisini düzgün kullanabilmeniz için
öncelikle o karakter dizisinin sağında ve solunda bulunan boşluk
karakterlerinden kurtulmanız gerekebilir. İşte böyle anlardastrip()metodu
yardımınıza yetişecektir. Dikkatlice inceleyin:

```python
>>> kardiz = " istihza "
>>> print(kardiz)

' istihza '

>>> kardiz.strip()

'istihza'

```

Gördüğünüz gibi,strip()metodunu kullanarak, karakter dizisinin
orijinalinde bulunan sağlı sollu boşluk karakterlerini bir çırpıda ortadan
kaldırdık.

strip()metodu yukarıdaki örnekte olduğu gibi parametresiz olarak
kullanıldığında, bir karakter dizisinin sağında veya solunda bulunan belli başlı
karakterleri kırpar.strip()metodunun öntanımlı olarak kırptığı karakterler
şunlardır:
| ‘ ‘ | boşluk karakteri |
| --- | --- |
| \t | sekme (TAB) oluşturan kaçış dizisi |
| \n | satır başına geçiren kaçış dizisi |
| \r | imleci aynı satırın başına döndüren kaçış dizisi |
| \v | düşey sekme oluşturan kaçış dizisi |
| \f | yeni bir sayfaya geçiren kaçış dizisi |

‘ ‘

boşluk karakteri

\t

sekme (TAB) oluşturan kaçış dizisi

\n

satır başına geçiren kaçış dizisi

\r

imleci aynı satırın başına döndüren kaçış dizisi

\v

düşey sekme oluşturan kaçış dizisi

\f

yeni bir sayfaya geçiren kaçış dizisi

Yani eğerstrip()metoduna herhangi bir parametre vermezsek bu metot
otomatik olarak karakter dizilerinin sağında ve solunda bulunan yukarıdaki
karakterleri kırpacaktır. Ancak eğer biz istersekstrip()metoduna bir
parametre vererek bu metodun istediğimiz herhangi başka bir karakteri kırpmasını
da sağlayabiliriz. Örneğin:

```python
>>> kardiz = "python"
>>> kardiz.strip("p")

'ython'

```

Buradastrip()metoduna parametre olarak“p”karakter dizisini vererek,strip()metodunun, karakter dizisinin başında bulunan“p”karakterini
ortadan kaldırmasını sağladık. Yalnızstrip()metodunu kullanırken bir
noktaya dikkat etmelisiniz. Bu metot bir karakter dizisinin hem başında, hem de
sonunda bulunan karakterlerle ilgilenir. Mesela şu örneğe bakalım:

```python
>>> kardiz = "kazak"
>>> kardiz.strip("k")

'aza'

```

Gördüğünüz gibi,strip()metoduna“k”parametresini vererek,“kazak”adlı karakter dizisinin hem başındaki hem de sonundaki“k”harflerini kırpmayı
başardık. Eğer bu metoda verdiğiniz parametre karakter dizisinde geçmiyorsa, bu
durumdastrip()metodu herhangi bir işlem yapmaz. Ya da aradığınız karakter,
karakter dizisinin yalnızca tek bir tarafında (mesela sadece başında veya sadece
sonunda) geçiyorsa,strip()metodu, ilgili karakter hangi taraftaysa onu
siler. Aranan karakterin bulunmadığı tarafla ilgilenmez.

strip()metodunu anlatmaya başlarken, içinde gereksiz yere>işaretlerinin
geçtiği e.postalardan söz etmiş ve bu e.postalardaki o gereksiz karakterleri
elle silmenin ne kadar da sıkıcı bir iş olduğunu söylemiştik. Eğer
e.postalarınızda bu tip durumlarla sık sık karşılaşıyorsanız, gereksiz
karakterleri silme görevini sizin yerinize Python yerine getirebilir. Şimdi şu
kodları dikkatlice inceleyin:

```python
metin = """
> Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından
> 90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python
> olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür.
> Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez.
> Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi
> grubunun, Monty Python's Flying Circus adlı gösterisinden esinlenerek adlandırmıştır.
> Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
> bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.
"""

for i in metin.split():
 print(i.strip("> "), end=" ")

```

Bu programı çalıştırdığınızda şöyle bir çıktı elde edeceksiniz:

```python
Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından
90'lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python
olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür.
Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez.
Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi
grubunun, Monty Python's Flying Circus adlı gösterisinden esinlenerek adlandırmıştır.
Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.

```

Gördüğünüz gibi, her satırın başında bulunan‘> ‘karakterlerini ufacık birkaç
kod yardımıyla rahatlıkla temizledik. Buradastrip()metoduyla birliktesplit()metodunu da kullandığımızı görüyorsunuz.split()metodu ile öncemetinadlı karakter dizisini parçaladık. Daha sonra dastrip()metodu
yardımıyla baş taraftaki istenmeyen karakterleri temizledik.

Yukarıdaki örnekte verdiğimiz metin, istenmeyen karakterleri yalnızca tek bir
tarafta içeriyor. Ama elbette istenmeyen karakterler, karakter dizisinin ne
tarafında olursa olsunstrip()metodu bu karakterleri başarıyla kırpacaktır.

Bu bölümün başlığındastrip()metodu ile birliktelstrip()verstrip()adlı iki metodun daha adı geçiyordu.strip()metodunun ne işe
yaradığını öğrendik. Peki bulstrip()verstrip()metotları ne işe
yarıyor?

lstrip()metodundan başlayalım anlatmaya…

strip()metodunu anlatırken, bu metodun bir karakter dizisinin sağında ve
solunda bulunan istenmeyen karakterleri kırptığını söylemiştik. Ancak bazen,
istediğimiz şey bu olmayabilir. Yani biz bir karakter dizisinin hem sağında, hem
de solunda bulunan gereksiz karakterleri değil, yalnızca sağında veya yalnızca
solunda bulunan gereksiz karakterleri kırpmak isteyebiliriz. Örneğinstrip()metodunu anlatırken verdiğimiz“kazak”örneğini ele alalım. Şöyle bir komutun
ne yapacağını biliyorsunuz:

```python
>>> "kazak".strip("k")

```

Bu komut hem sol, hem de sağ taraftaki“k”karakterlerini kırpacaktır. Ama
peki ya biz sadece sol taraftaki“k”karakterini atmak istersek ne olacak?
İşte böyle bir durumdastrip()metodundan değil,lstrip()metodundan
faydalanacağız.

lstrip()metodu bir karakter dizisinin sol tarafındaki gereksiz
karakterlerden kurtulmamızı sağlar. Mesela bu bilgiyi yukarıdaki örneğe
uygulayalım:

```python
>>> "kazak".lstrip("k")

'azak'

```

Gördüğünüz gibi,lstrip()metodu yalnızca sol baştaki“k”harfiyle
ilgilendi. Sağ taraftaki“k”harfine ise dokunmadı. Eğer sol taraftaki
karakteri değil de yalnızca sağ taraftaki karakteri uçurmak istemeniz halinde
iserstrip()metodundan yararlanacaksınız:

```python
>>> "kazak".rstrip("k")

'kaza'

```

Bu arada, yukarıdaki metotları doğrudan karakter dizileri üzerine
uygulayabildiğimize de dikkat edin. Yani şu iki yöntem de uygun ve doğrudur:

```python
>>> kardiz = "karakter dizisi"
>>> kardiz.metot_adı()

```

veya:

```python
>>> "karakter dizisi".metot_adı()

```

### join()

Hatırlarsanız şimdiye kadar öğrendiğimiz metotlar arasındasplit()adlı bir
metot vardı. Bu metodun ne işe yaradığını ve nasıl kullanıldığını biliyorsunuz:

```python
>>> kardiz = "Beşiktaş Jimnastik Kulübü"
>>> bölünmüş = kardiz.split()
>>> print(bölünmüş)

['Beşiktaş', 'Jimnastik', 'Kulübü']

```

Gördüğünüz gibisplit()metodu bir karakter dizisini belli yerlerden bölerek
parçalara ayırıyor. Bu noktada insanın aklına şöyle bir soru geliyor: Diyelim ki
elimizde böyle bölünmüş bir karakter dizisi grubu var. Biz bu grup içindeki
karakter dizilerini tekrar birleştirmek istersek ne yapacağız?

Şimdi şu kodlara çok dikkatlice bakın:

```python
>>> " ".join(bölünmüş)

'Beşiktaş Jimnastik Kulübü'

```

Gördüğünüz gibi,“Beşiktaş Jimnastik Kulübü”adlı karakter dizisinin ilk
halini tekrar elde ettik. Yani bu karakter dizisine ait, bölünmüş parçaları
tekrar bir araya getirdik. Ancak bu işi yapan kod gözünüzüne biraz tuhaf ve
anlaşılmaz görünmüş olabilir.

İlk başta dikkatimizi çeken şey, bu metodun öbür metotlara göre biraz daha
farklı bir yapıya sahipmiş gibi görünmesi. Ama belki yukarıdaki örneği şöyle
yazarsak bu örnek biraz daha anlaşılır gelebilir gözünüze:

```python
>>> birleştirme_karakteri = " "
>>> birleştirme_karakteri.join(bölünmüş)

```

Burada da tıpkı öteki metotlarda olduğu gibi,join()metodunu bir karakter
dizisi üzerine uyguladık. Bu karakter dizisi bir adet boşluk karakteri. Ayrıca
gördüğünüz gibijoin()metodu bir adet de parametre alıyor. Bu örnektejoin()metoduna verdiğimiz parametrebölünmüşadlı değişken. Aslında şöyle
bir düşününce yukarıdaki kodların sanki şöyle yazılması gerekiyormuş gibi
gelebilir size:

```python
>>> bölünmüş.join(birleştirme_karakteri)

```

Ama bu kullanım yanlıştır. Üstelik kodunuzu böyle yazarsanız Python size bir
hata mesajı gösterecektir:

```python
>>> bölünmüş.join(birleştirme_karakteri)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'join'

```

Buradaki hata mesajı bize şöyle diyor: ‘liste nesnesininjoinadlı bir
niteliği yoktur!’. Bu cümledeki ‘liste nesnesi’ ifadesine özellikle dikkatinizi
çekmek istiyorum. Biz şimdiye kadar iki tür nesne (ya da başka bir ifadeyle veri
tipi) görmüştük. Bunlar karakter dizileri ve sayılardı. Burada karşımıza üçüncü
bir nesne çıkıyor. Gördüğümüz kadarıyla bu yeni nesnenin adı ‘liste’. (Liste
adlı veri tipini birkaç bölüm sonra en ince ayrıntısına kadar inceleyeceğiz.
Python’da böyle bir veri tipi olduğunu bilmemiz bizim için şimdilik yeterli.)

İşte yukarıdaki hatayı almamızın nedeni, aslında karakter dizilerine ait bir
metot olanjoin()metodunu bir liste üzerinde uygulamaya çalışmamız. Böyle
bir durumda da Python doğal olarak bizi ‘liste nesnelerininjoinadlı bir
niteliği olmadığı’ konusunda uyarıyor. Bütün bu anlattıklarımız bizi şu sonuca
ulaştırıyor: Bir veri tipine ait metotlar doğal olarak yalnızca o veri tipi
üzerinde kullanılabilir. Mesela yukarıdaki örnekte gördüğümüz gibi, bir karakter
dizisi metodu olanjoin()’i başka bir veri tipine uygulamaya çalışırsak hata
alırız.

Sonuç olarak,join()adlı metodubölünmüşadlı değişkene
uygulayamayacağımızı anlamış bulunuyoruz. O halde bu metotla birlikte
kullanılmak üzere bir karakter dizisi bulmamız gerekiyor.

En başta da söylediğimiz gibi,join()metodunun görevi bölünmüş karakter
dizisi gruplarını birleştirmektir. Bu metot görevini yerine getirirken, yani
karakter dizisi gruplarını birleştirirken bir birleştirme karakterine ihtiyaç
duyar. Bizim örneğimizde bu birleştirme karakteri bir adet boşluktur. Durumu
daha iyi anlayabilmek için örneğimizi tekrar gözümünün önüne getirelim:

```python
>>> kardiz = "Beşiktaş Jimnastik Kulübü"
>>> bölünmüş = kardiz.split()
>>> print(bölünmüş)

['Beşiktaş', 'Jimnastik', 'Kulübü']

>>> kardiz = " ".join(bölünmüş)
>>> print(kardiz)

Beşiktaş Jimnastik Kulübü

```

Gördüğünüz gibi, orijinal karakter dizisinin bölünmüş parçalarını, her bir
parçanın arasında bir adet boşluk olacak şekilde yeniden birleştirdik. Elbette
sadece boşluk karakteri kullanabileceğiz diye bir kaide yok. Mesela şu örneklere
bakın:

```python
>>> kardiz = "-".join(bölünmüş)

Beşiktaş-Jimnastik-Kulübü

>>> kardiz = "".join(bölünmüş)

BeşiktaşJimnastikKulübü

```

İlk örnekte, bölünmüş karakter dizilerini-işareti ile birleştirdik. İkinci
örnekte ise bu karakter dizilerini birleştirmek için boş bir karakter dizisi
kullandık. Yani parçaları birleştirirken arada boşluk olmamasını sağladık.

join()metodu ile bol bol pratik yaparak bu metodu hakkıyla öğrenmenizi
tavsiye ederim. Zira programcılık maceranız boyunca en sık kullanacağınız
karakter dizisi metotları listesinin en başlarında bu metot yer alır.

### count()

Tıpkı daha önce öğrendiğimiz sorgulayıcı metotlar gibi,count()metodu da
bir karakter dizisi üzerinde herhangi bir değişiklik yapmamızı sağlamaz. Bu
metodun görevi bir karakter dizisi içinde belli bir karakterin kaç kez geçtiğini
sorgulamaktır. Bununla ilgili hemen bir örnek verelim:

```python
>>> şehir = "Kahramanmaraş"
>>> şehir.count("a")

5

```

Buradan anlıyoruz ki,“Kahramanmaraş”adlı karakter dizisi içinde toplam5adet“a”karakteri geçiyor.

count()metodu yaygın olarak yukarıdaki örnekte görüldüğü şekilde sadece tek
bir parametre ile kullanılır. Ama aslında bu metot toplam 3 parametre alır.
Şimdi şu örnekleri dikkatlice inceleyin:

```python
>>> şehir = "adana"
>>> şehir.count("a")

3

>>> şehir.count("a", 1)

2

>>> şehir.count("a", 2)

2

>>> şehir.count("a", 3)

1

>>> şehir.count("a", 4)

1

```

İlk örnektecount()metodunu tek bir parametre ile birlikte kullandığımız
için“adana”adlı karakter dizisi içindeki bütün“a”harflerinin toplam
sayısı çıktı olarak verildi.

İkinci örnekte isecount()metoduna ikinci bir parametre daha verdik. Bu
ikinci parametre,count()metodunun bir karakteri saymaya başlarken karakter
dizisinin kaçıncı sırasından başlayacağını gösteriyor. Bu örnekte ikinci
parametre olarak1sayısını verdiğimiz için, Python saymaya“adana”karakter
dizisinin1.sırasından başlayacak. Dolayısıyla0.sıradaki“a”harfi
sayım işleminin dışında kalacağı için toplam“a”sayısı3değil2olarak
görünecek. Gördüğünüz gibi, sonraki örneklerde de aynı mantığı takip ettiğimiz
için aradığımız karakterin toplam sayısı örnekten örneğe farklılık gösteriyor.

Peki bu metodu gerçek programlarda ne amaçla kullanabilirsiniz? Bu metodu
kullanarak, örneğin, kullanıcıyı aynı karakterden yalnızca bir adet girmeye
zorlayabilirsiniz. Bunun için mesela şöyle bir yapı kullanabilirsiniz:

```python
parola = input("parolanız: ")

kontrol = True

for i in parola:
 if parola.count(i) > 1:
 kontrol = False

if kontrol:
 print('Parolanız onaylandı!')
else:
 print('Parolanızda aynı harfi bir kez kullanabilirsiniz!')

```

Buradakontroldeğişkeninin değeriniTrueolarak belirledik. Eğerparolaiçindeki harflerden herhangi biri 1’den fazla geçiyorsa bu durumdakontroldeğişkeninin değeriniFalseyapıyoruz:

```python
for i in parola:
 if parola.count(i) > 1:
 kontrol = False

```

Daha sonra dakontroldeğişkeninin durumuna göre kullanıcıya parolanın
onaylandığı veya onaylanmadığı bilgisini veriyoruz. Buna göre eğerkontroldeğişkeninin değeriTrueise şu çıktıyı veriyoruz:

```python
Parolanız onaylandı!

```

Aksi halde şu çıktıyı veriyoruz:

```python
Parolanızda aynı harfi bir kez kullanabilirsiniz!

```

Yukarıdakine benzer durumların dışındacount()metodunu şöyle durumlarda da
kullanabilirsiniz:

```python
kelime = input("Herhangi bir kelime: ")

for harf in kelime:
 print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf,
 kelime,
 kelime.count(harf)))

```

Burada amacımız kullanıcının girdiği bir kelime içindeki bütün harflerin o
kelime içinde kaç kez geçtiğini bulmak.count()metodunu kullanarak bu işi
çok kolay bir şekilde halledebiliyoruz. Kullanıcının mesela ‘adana’ kelimesini
girdiğini varsayarsak yukarıdaki program şöyle bir çıktı verecektir:

```python
a harfi adana kelimesinde 3 kez geçiyor!
d harfi adana kelimesinde 1 kez geçiyor!
a harfi adana kelimesinde 3 kez geçiyor!
n harfi adana kelimesinde 1 kez geçiyor!
a harfi adana kelimesinde 3 kez geçiyor!

```

Ancak burada şöyle bir problem var: ‘adana’ kelimesi içinde birden fazla geçen
harfler (mesela ‘a’ harfi) çıktıda birkaç kez tekrarlanıyor. Yani mesela ‘a’
harfinin geçtiği her yerde programımız ‘a’ harfinin kelime içinde kaç kez
geçtiğini rapor ediyor. İstediğiniz davranış bu olabilir. Ama bazı durumlarda
her harfin kelime içinde kaç kez geçtiği bilgisinin yalnızca bir kez
raporlanmasını isteyebilirsiniz. Yani siz yukarıdaki gibi bir çıktı yerine şöyle
bir çıktı elde etmek istiyor olabilirsiniz:

```python
a harfi adana kelimesinde 3 kez geçiyor!
d harfi adana kelimesinde 1 kez geçiyor!
n harfi adana kelimesinde 1 kez geçiyor!

```

Böyle bir çıktı elde edebilmek için şöyle bir program yazabilirsiniz:

```python
kelime = input("Herhangi bir kelime: ")
sayaç = ""

for harf in kelime:
 if harf not in sayaç:
 sayaç += harf

for harf in sayaç:
 print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf,
 kelime,
 kelime.count(harf)))

```

Gelin isterseniz bu kodları şöyle bir inceleyelim.

Bu kodlarda öncelikle kullanıcıdan herhangi bir kelime girmesini istiyoruz.

Daha sonrasayaçadlı bir değişken tanımlıyoruz. Bu değişken, kullanıcının
girdiği kelime içindeki harfleri tutacak. Bu değişken,kelimedeğişkeninden
farklı olarak, kullanıcının girdiği sözcük içinde birden fazla geçen harflerden
yalnızca tek bir örnek içerecek.

Değişkenimizi tanımladıktan sonra birfordöngüsü kuruyoruz. Bu döngüye
dikkatlice bakın. Kullanıcının girdiği kelime içinde geçen harflerden her birini
yalnızca bir kez alıpsayaçdeğişkenine gönderiyoruz. Böylece elimizde her
harften sadece bir adet olmuş oluyor. Burada Python’ın arka planda neler
çevirdiğini daha iyi anlayabilmek için isterseniz döngüden sonra şöyle bir satır
ekleyereksayaçdeğişkeninin içeriğini inceleyebilir, böylece burada
kullandığımızfordöngüsünün nasıl çalıştığını daha iyi görebilirsiniz:

```python
print("sayaç içeriği: ", sayaç)

```

İlk döngümüz sayesinde, kullanıcının girdiği kelime içindeki her harfi teke
indirerek, bu harflerisayaçdeğişkeni içinde topladık. Şimdi yapmamız gereken
şey,sayaçdeğişkenine gönderilen her bir harfin,kelimeadlı değişken
içinde kaç kez geçtiğini hesaplamak olmalı. Bunu da yine birfordöngüsü ile
yapabiliriz:

```python
for harf in sayaç:
 print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf,
 kelime,
 kelime.count(harf)))

```

Burada yaptığımız şey şu:count()metodunu kullanarak,sayaçdeğişkeninin
içindeki her bir harfin,kelimedeğişkeninin içinde kaç kez geçtiğini
buluyoruz. Bu döngünün nasıl çalıştığını daha iyi anlayabilmek için, isterseniz
bu döngüyü şu şekilde sadeleştirebilirsiniz:

```python
for harf in sayaç:
 print(harf, kelime, kelime.count(harf))

```

Gördüğünüz gibi,sayaçdeğişkeni içindeki herbir harfinkelimeadlı karakter
dizisi içinde kaç kez geçtiğini tek tek sorguladık.

Yukarıdaki örneklerdecount()metodunun iki farklı parametre aldığını
gördük. Bu metot bunların dışında üçüncü bir parametre daha alır. Bu üçüncü
parametre ikinci parametreyle ilişkilidir. Dilerseniz bu ilişkiyi bir örnek
üzerinde görelim:

```python
>>> kardiz = "python programlama dili"
>>> kardiz.count("a")

3

>>> kardiz.count("a", 15)

2

```

Bu örneklerden anladığımıza göre,“python programlama dili”adlı karakter
dizisi içinde toplam3adet ‘a’ harfi var. Eğer bu karakter dizisi içindeki
‘a’ harflerini karakter dizisinin en başından itibaren değil de,15.karakterden itibaren saymaya başlarsak bu durumda2adet ‘a’ harfi buluyoruz.
Şimdi de şu örneğe bakalım:

```python
>>> kardiz.count("a", 15, 17)

1

```

Burada,15.karakter ile17.karakter arasında kalan ‘a’ harflerini saymış
olduk.15.karakter ile17.karakter arasında toplam1adet ‘a’ harfi
olduğu için de Python bize1sonucunu verdi. Bütün bu örneklerden sonracount()metoduna ilişkin olarak şöyle bir tespitte bulunabiliriz:

count()metodu bir karakter dizisi içinde belli bir karakterin kaç kez
geçtiğini sorgulamamızı sağlar. Örneğin bu metoducount("a")şeklinde
kullanırsak Python bize karakter dizisi içindeki bütün “a” harflerinin
sayısını verecektir. Eğer bu metoda 2. ve 3. parametreleri de verirsek,
sorgulama işlemi karakter dizisinin belli bir kısmında
gerçekleştirilecektir. Örneğincount("a",4,7)gibi bir kullanım, bize
karakter dizisinin 4. ve 7. karakterleri arasında kalan “a” harflerinin
sayısını verecektir.

Böylece bir metodu daha ayrıntılı bir şekilde incelemiş olduk. Artık başka bir
metot incelemeye geçebiliriz.

### index(), rindex()

Bu bölümün başında karakter dizilerinin dilimlenme özelliğinden söz ederken,
karakter dizisi içindeki her harfin bir sırası olduğunu söylemiştik. Örneğin“python”adlı karakter dizisinde ‘p’ harfinin sırası0’dır. Aynı şekilde ‘n’
harfinin sırası ise5’tir. Karakterlerin, bir karakter dizisi içinde hangi
sırada bulunduğunu öğrenmek içinindex()adlı bir metottan yararlanabiliriz.
Örneğin:

```python
>>> kardiz = "python"
>>> kardiz.index("p")

0

>>> kardiz.index("n")

5

```

Eğer sırasını sorguladığımız karakter, o karakter dizisi içinde bulunmuyorsa, bu
durumda Python bize bir hata mesajı gösterir:

```python
>>> kardiz.index("z")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: substring not found

```

Bu metodun özelliği, sorguladığımız karakterin, karakter dizisi içinde geçtiği
ilk konumu vermesidir. Yani örneğin:

```python
>>> kardiz = "adana"
>>> kardiz.index("a")

0

```

“adana”adlı karakter dizisi içinde3adet ‘a’ harfi var. Ancak bizindex()metodu yardımıyla“adana”karakter dizisi içindeki ‘a’ harfinin
konumunu sorgularsak, Python bize ‘a’ harfinin geçtiği ilk konumu, yani0.konumu, bildirecektir. Halbuki“adana”karakter dizisi içinde2.ve4.sıralarda da birer ‘a’ harfi var. Ancakindex()metodu0.konumdaki ‘a’
harfini gördükten sonra karakter dizisinin geri kalanına bakmaz.

index()metodunu biz yukarıda tek bir parametre ile birlikte kullandık. Bu
parametre, karakter dizisi içinde konumunu öğrenmek istediğimiz karakteri
gösteriyor. Ama bu metot aslında toplam3parametre alır. Şu örnekleri
dikkatlice inceleyelim:

```python
>>> kardiz = "adana"
>>> kardiz.index("a")

0

```

Burada normal bir şekildeindex()metodunu tek bir parametre ile birlikte
kullandık. Böylece Python bize ‘a’ harfinin karakter dizisi içinde ilk olarak
hangi sırada bulunduğunu gösterdi. Bir de şu örneğe bakalım:

```python
>>> kardiz.index("a", 1)

2

```

Gördüğünüz gibi, bu defaindex()metoduna ikinci bir parametre daha verdik.index()metodunun ikinci parametresi, Python’ın aramaya kaçıncı sıradan
itibaren başlayacağını gösteriyor. Biz yukarıdaki örnekte Python’ın aramaya 1.
sıradan itibaren başlamasını istedik. Bu yüzden Python 0. sıradaki “a”
karakterini es geçti ve 2. sırada bulunan “a” karakterini gördü. Bir de şuna
bakalım:

```python
>>> kardiz.index("a", 3)

```

Bu defa Python’ın aramaya3.sıradan başlamasını istedik. Dolayısıyla Python0.ve2.sıralardaki ‘a’ harflerini görmezden gelip bize4.sıradaki ‘a’
harfinin sırasını bildirdi.

Gelelimindex()metodunun3.parametresine… Dilerseniz3.parametrenin
ne işe yaradığını bir örnek üzerinde gösterelim:

```python
>>> kardiz = "adana"
>>> kardiz.index("a", 1, 3)

2

```

Hatırlarsanız, bundan öncecount()adlı bir metot öğrenmiştik. O metot da
toplam3parametre alıyordu.count()metodunda kullandığımız2.ve3.parametrelerin görevlerini hatırlıyor olmalısınız. İşteindex()metodunun2.ve3.parametreleri de aynencount()metodundaki gibi çalışır. Yani
Python’ın sorgulama işlemini hangi sıra aralıklarından gerçekleştireceğini
gösterir. Mesela yukarıdaki örnekte biz “adana” karakter dizisinin1.ve3.sıraları arasındaki ‘a’ harflerini sorguladık. Yani yukarıdaki örnekte Python
‘a’ harfini aramaya1.konumdan başladı ve aramayı3.konumda kesti. Böylece“adana”karakter dizisinin2.sırasındaki ‘a’ harfinin konumunu bize
bildirdi.

Gördüğünüz gibi,index()metodu bize aradığımız karakterin yalnızca ilk
konumunu bildiriyor. Peki biz mesela“adana”karakter dizisi içindeki bütün
‘a’ harflerinin sırasını öğrenmek istersek ne yapacağız?

Bu isteğimizi yerine getirmek için karakter dizisinin her bir sırasını tek tek
kontrol etmemiz yeterli olacaktır. Yani şöyle bir şey yazmamız gerekiyor:

```python
kardiz = "adana"

print(kardiz.index("a", 0))
print(kardiz.index("a", 1))
print(kardiz.index("a", 2))
print(kardiz.index("a", 3))
print(kardiz.index("a", 4))

```

Buradaki mantığı anladığınızı sanıyorum. Bildiğiniz gibi,index()metodunun
ikinci parametresi sayesinde karakter dizisi içinde aradığımız bir karakteri
hangi konumdan itibaren arayacağımızı belirleyebiliyoruz. Örneğin yukarıdaki
kodlarda gördüğünüz ilkprint()satırı ‘a’ karakterini0.konumdan
itibaren arıyor ve gördüğü ilk ‘a’ harfinin konumunu raporluyor. İkinciprint()satırı ‘a’ karakterini1.konumdan itibaren arıyor ve gördüğü ilk
‘a’ harfinin konumunu raporluyor. Bu süreç karakter dizisinin sonuna
ulaşılıncaya kadar devam ediyor. Böylece karakter dizisi içinde geçen bütün ‘a’
harflerinin konumunu elde etmiş oluyoruz.

Elbette yukarıdaki kodları, sadece işin mantığını anlamanızı sağlamak için bu
şekilde verdik. Tahmin edebileceğiniz gibi, yukarıdaki kod yazımı son derece
verimsiz bir yoldur. Ayrıca gördüğünüz gibi, yukarıdaki kodlar sadece5karakter uzunluğundaki karakter dizileri için geçerlidir. Halbuki programlamada
esas alınması gereken yöntem, kodlarınızı olabildiğince genel amaçlı tutup,
farklı durumlarda da çalışabilmesini sağlamaktır. Dolayısıyla yukarıdaki mantığı
şu şekilde kodlara dökmek çok daha akıllıca bir yol olacaktır:

```python
kardiz = "adana"

for i in range(len(kardiz)):
 print(kardiz.index("a", i))

```

Gördüğünüz gibi, yukarıdaki kodlar yardımıyla, bir önceki verimsiz kodları hem
kısalttık, hem de daha geniş kapsamlı bir hale getirdik. Hatta yukarıdaki
kodları şöyle yazarsanız karakter dizisi ve bu karakter dizisi içinde aranacak
karakteri kullanıcıdan da alabilirsiniz:

```python
kardiz = input("Metin girin: ")
aranacak = input("Aradığınız harf: ")

for i in range(len(kardiz)):
 print(kardiz.index(aranacak, i))

```

Bu kodlarda bazı problemler dikkatinizi çekmiş olmalı. Mesela, aranan karakter
dizisinin bulunduğu konumlar çıktıda tekrar ediyor. Örneğin, kullanıcının“adana”karakter dizisi içinde ‘a’ harfini aramak istediğini varsayarsak
programımız şöyle bir çıktı veriyor:

```python
0
2
2
4
4

```

Burada2ve4sayılarının birden fazla geçtiğini görüyoruz. Bunu engellemek
için şöyle bir kod yazabiliriz:

```python
kardiz = input("Metin girin: ")
aranacak = input("Aradığınız harf: ")

for i in range(len(kardiz)):
 if i == kardiz.index(aranacak, i):
 print(i)

```

Bu kodlarla yaptığımız şey şu: Öncelikle karakter dizisinin uzunluğunu gösteren
sayı aralığı üzerinde birfordöngüsü kuruyoruz. Kullanıcının burada yine“adana”karakter dizisini girdiğini varsayarsak,“adana”karakter dizisinin
uzunluğu5olduğu içinfordöngümüz şöyle görünecektir:

```python
for i in range(5):
 ...

```

Daha sonrafordöngüsü içinde tanımladığımızideğişkeninin değerinin,
karakter dizisi içinde aradığımız karakterin konumu ile eşleşip eşleşmediğini
kontrol ediyoruz ve değeri eşleşen sayılarıprint()fonksiyonunu kullanarak
ekrana döküyoruz.

Eğer bu kodlar ilk bakışta gözünüze anlaşılmaz göründüyse bu kodları bir de şu
şekilde yazarak arka planda neler olup bittiğini daha net görebilirsiniz:

```python
kardiz = input("Metin girin: ")
aranacak = input("Aradığınız harf: ")

for i in range(len(kardiz)):
 print("i'nin değeri: ", i)
 if i == kardiz.index(aranacak, i):
 print("%s. sırada 1 adet %s harfi bulunuyor" %(i, aranacak))
 else:
 print("%s. sırada %s harfi bulunmuyor" %(i, aranacak))

```

Gördüğünüz gibiindex()metodu bir karakter dizisi içindeki karakterleri
ararken karakter dizisini soldan sağa doğru okuyor. Python’da bu işlemin tersi
de mümkündür. Yani isterseniz Python’ın, karakter dizisini soldan sağa doğru
değil de, sağdan sola doğru okumasını da sağlayabilirsiniz. Bu iş içinrindex()adlı bir metottan yararlanacağız. Bu metot her yöndenindex()metoduyla aynıdır.index()verindex()metotlarının birbirinden tek
farkı,index()metodunun karakter dizilerini soldan sağa,rindex()metodunun ise sağdan sola doğru okumasıdır. Hemen bir örnekle durumu açıklamaya
çalışalım:

```python
>>> kardiz = "adana"
>>> kardiz.index("a")

0

>>> kardiz.rindex("a")

4

```

Bu iki örnek,index()verindex()metotları arasındaki farkı gayet net
bir şekilde ortaya koyuyor.index()metodu, karakter dizisini soldan sağa
doğru okuduğu için“adana”karakter dizisinin 0. sırasındaki ‘a’ harfini
yakaladı.rindex()metodu ise karakter dizisini sağdan sola doğru okuduğu
için“adana”karakter dizisinin4.sırasındaki ‘a’ harfini yakaladı…

### find, rfind()

find()verfind()metotları tamamenindex()verindex()metotlarına benzer.find()verfind()metotlarının görevi de bir
karakter dizisi içindeki bir karakterin konumunu sorgulamaktır:

```python
>>> kardiz = "adana"
>>> kardiz.find("a")

0

>>> kardiz.rfind("a")

4

```

Pekiindex()/rindex()vefind()/rfind()metotları arasında ne
fark var?

index()verindex()metotları karakter dizisi içindeki karakteri
sorgularken, eğer o karakteri bulamazsa birValueErrorhatası verir:

```python
>>> kardiz = "adana"
>>> kardiz.index("z")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: substring not found

```

Amafind()verfind()metotları böyle bir durumda -1 çıktısı verir:

```python
>>> kardiz = "adana"
>>> kardiz.find("z")

-1

```

Bu iki metot çifti arasındaki tek fark budur.

### center()

Centerkelimesi İngilizce’de ‘orta, merkez, ortalamak’ gibi anlamlara gelir.
Bu anlama uygun olarak,center()metodunu karakter dizilerini ortalamak için
kullanabilirsiniz. Örneğin:

```python
for metot in dir(""):
 print(metot.center(15))

```

Gördüğünüz gibicenter()metodu bir adet parametre alıyor. Bu parametre,
karakter dizisine uygulanacak ortalama işleminin genişliğini gösteriyor. Bu
parametrenin nasıl bir etki ortaya çıkardığını daha iyi anlayabilmek için
isterseniz bir iki basit örnek verelim:

```python
>>> kardiz = "python"

```

Burada6karakterlik bir karakter dizisi tanımladık. Şimdi dikkatlice bakın:

```python
>>> kardiz.center(1)

'python'

```

Burada isecenter()metoduna parametre olarak1sayısını verdik. Ancak bu
parametre karakter dizimizinin uzunluğundan az olduğu için çıktı üzerinde
herhangi bir etkisi olmadı. Bir de şuna bakalım:

```python
>>> kardiz.center(10)

' python '

```

Çıktıdaki tırnak işaretlerine bakarak, ‘python’ kelimesinin ortalandığını
görebilirsiniz. Buradan şu sonucu çıkarıyoruz:center()metoduna verilen
genişlik parametresi aslında bir karakter dizisinin toplam kaç karakterlik bir
yer kaplayacağını gösteriyor. Mesela yukarıdaki örnekte bu metoda verdiğimiz10sayısı"python"adlı karakter dizisinin toplam10karakterlik bir yer
kaplayacağını gösteriyor. Kaplanacak yere karakter dizisinin kendisi de
dahildir. Yani10olarak belirttiğimiz boşluk adedinin6’sı ‘python’
kelimesinin kendisi tarafından işgal ediliyor. Geriye kalan4boşlukluk mesafe
ise karakter dizisinin sol ve sağ tarafına paylaştırılıyor.

center()metodunun karakter dizileri üzerindeki etkisini daha net olarak
görmek için şöyle bir döngü kurabilirsiniz:

```python
>>> for i in range(1, 20):
... kardiz.center(i)
...
'python'
'python'
'python'
'python'
'python'
'python'
' python'
' python '
' python '
' python '
' python '
' python '
' python '
' python '
' python '
' python '
' python '
' python '
' python '

```

Bu örnekte, karakter dizisinin her adımda nasıl ortaya doğru kaydığı açıkça
görülüyor. Dikkat ederseniz çıktının ilk altı satırında karakter dizisinin
konumu değişmiyor. Ancakcenter()metoduna verilen parametrenin değeri
karakter dizisinin uzunluğunu aştığı anda karakter dizisi ortaya doğru
ilerlemeye başlıyor.

center()metodu genellikle yukarıdaki gösterdiğimiz şekilde tek bir
parametre ile birlikte kullanılır. Ancak bu metot aslında bir parametre daha
alır. Şu örneği inceleyelim:

```python
>>> kardiz = "elma"
>>> kardiz.center(10, "-")

'---elma---'

```

Gördüğünüz gibi,center()metoduna verdiğimiz“-”değeri sayesinde“elma”karakteri ortalanırken, sağ ve sol taraftaki boşluklara da“-”karakteri eklenmiş oldu.

### rjust(), ljust()

Bu metotlar da tıpkı bir öncekicenter()metodu gibi karakter dizilerini
hizalama vazifesi görür.rjust()metodu bir karakter dizisini sağa
yaslarken,ljust()metodu karakter dizisini sola yaslar. Mesela şu iki kod
parçasının çıktılarını inceleyin:

```python
>>> for i in dir(""):
... print(i.ljust(20))

>>> for i in dir(""):
... print(i.rjust(20))

```

ljust()metodu bize özellikle karakter dizilerinin hizalama işlemlerinde
yardımcı oluyor. Bu metot yardımıyla karakter dizilerimizi sola yaslayıp, sağ
tarafına da istediğimiz karakterleri yerleştirebiliyoruz. Hemen bir örnek
verelim:

```python
>>> kardiz = "tel no"
>>> kardiz.ljust(10, ".")

'tel no....'

```

Burada olan şey şu:ljust()metodu, kendisine verilen10parametresinin
etkisiyle10karakterlik bir alan oluşturuyor. Bu 10 karakterlik alanın içine
önce6karakterlik yer kaplayan“tel no”ifadesini, geri kalan4karakterlik boşluğa ise“.”karakterini yerleştiriyor. Eğerljust()metoduna verilen sayı karakter dizisinin uzunluğundan az yer tutarsa, karakter
dizisinin görünüşünde herhangi bir değişiklik olmayacaktır. Örneğin yukarıdaki
örnekte karakter dizimizin uzunluğu6. Dolayısıyla kodumuzu şu şekilde
yazarsak bir sonuç elde edemeyiz:

```python
>>> kardiz.ljust(5, ".")

'tel no'

```

Gördüğünüz gibi, karakter dizisinde herhangi bir değişiklik olmadı.ljust()metoduna verdiğimiz“.”karakterini görebilmemiz için, verdiğimiz sayı cinsli
parametrenin en az karakter dizisinin boyunun bir fazlası olması gerekir:

```python
>>> kardiz.ljust(7, ".")

'tel no.'

```

ljust()metoduyla ilgili basit bir örnek daha verelim:

```python
>>> for i in "elma", "armut", "patlıcan":
... i.ljust(10, ".")
...
'elma......'
'armut.....'
'patlıcan..'

```

Gördüğünüz gibi, bu metot karakter dizilerini şık bir biçimde sola hizalamamıza
yardımcı oluyor.

rjust()metodu ise,ljust()metodunun yaptığı işin tam tersini yapar.
Yani karakter dizilerini sola değil sağa yaslar:

```python
>>> for i in "elma", "armut", "patlıcan":
... i.rjust(10, ".")
...
'......elma'
'.....armut'
'..patlıcan'

```

ljust()verjust()metotları, kullanıcılarınıza göstereceğiniz
çıktıların düzgün görünmesini sağlamak açısından oldukça faydalıdır.

### zfill()

Bu metot kimi yerlerde işimizi epey kolaylaştırabilir.zfill()metodu
yardımıyla karakter dizilerinin sol tarafına istediğimiz sayıda sıfır
ekleyebiliriz:

```python
>>> a = "12"
>>> a.zfill(3)

'012'

```

Bu metodu şöyle bir iş için kullanabilirsiniz:

```python
>>> for i in range(11):
... print(str(i).zfill(2))
00
01
02
03
04
05
06
07
08
09
10

```

Buradastr()fonksiyonunu kullanarak,range()fonksiyonundan elde
ettiğimiz sayıları birer karakter dizisine çevirdiğimize dikkat edin. Çünküzfill()karakter dizilerinin bir metodudur. Sayıların değil…

### partition(), rpartition()

Bu metot yardımıyla bir karakter dizisini belli bir ölçüte göre üçe bölüyoruz.
Örneğin:

```python
>>> a = "istanbul"
>>> a.partition("an")

('ist', 'an', 'bul')

```

Eğerpartition()metoduna parantez içinde verdiğimiz ölçüt karakter dizisi
içinde bulunmuyorsa şu sonuçla karşılaşırız:

```python
>>> a = "istanbul"
>>> a.partition("h")

('istanbul', '', '')

```

Gelelimrpartition()metoduna… Bu metot dapartition()metodu ile aynı
işi yapar, ama yöntemi biraz farklıdır.partition()metodu karakter
dizilerini soldan sağa doğru okur.rpartition()metodu ise sağdan sola
doğru. Peki bu durumun ne gibi bir sonucu vardır? Hemen görelim:

```python
>>> b = "istihza"
>>> b.partition("i")

('', 'i', 'stihza')

```

Gördüğünüz gibi,partition()metodu karakter dizisini ilk ‘i’ harfinden
böldü. Şimdi aynı işlemirpartition()metodu ile yapalım:

```python
>>> b.rpartition("i")

('ist', 'i', 'hza')

```

rpartition()metodu ise, karakter dizisini sağdan sola doğru okuduğu için
ilk ‘i’ harfinden değil, son ‘i’ harfinden böldü karakter dizisini.

partition()verpartition()metotları, ölçütün karakter dizisi içinde
bulunmadığı durumlarda da farklı tepkiler verir:

```python
>>> b.partition("g")

('istihza', '', '')

>>> b.rpartition("g")

('', '', 'istihza')

```

Gördüğünüz gibi,partition()metodu boş karakter dizilerini sağa doğru
yaslarken,rpartition()metodu sola doğru yasladı.

### encode()

Bu metot yardımıyla karakter dizilerimizi istediğimiz kodlama sistemine göre
kodlayabiliriz. Python 3.x’te varsayılan karakter kodlamasıutf-8’dir. Eğer
istersek şu karakter dizisiniutf-8yerinecp1254ile kodlayabiliriz:

```python
>>> "çilek".encode("cp1254")

```

### expandtabs()

Bu metot yardımıyla bir karakter dizisi içindeki sekme boşluklarını
genişletebiliyoruz. Örneğin:

```python
>>> a = "elma\tbir\tmeyvedir"
>>> a.expandtabs(10)

'elma bir meyvedir'

```

Böylece bir metot grubunu daha geride bırakmış olduk. Gördüğünüz gibi bazı
metotlar sıklıkla kullanılabilme potansiyeli taşırken, bazı metotlar pek öyle
sık kullanılacakmış gibi görünmüyor…

Sonraki bölümde metotları incelemeye devam edeceğiz.

## Karakter Dizilerinin Metotları (Devamı)

Karakter dizileri konusunun 4. bölümüne geldik. Bu bölümde de karakter
dizilerinin metotlarını incelemeye devam edeceğiz.

### str.maketrans(), translate()

Bu iki metot birbiriyle bağlantılı olduğu ve genellikle birlikte kullanıldığı
için, bunları bir arada göreceğiz.

Dilerseniz bu iki metodun ne işe yaradığını anlatmaya çalışmak yerine bir örnek
üzerinden bu metotların görevini anlamayı deneyelim.

Şöyle bir vaka hayal edin: Bildiğiniz gibi, internet üzerinde bazen Türkçe
karakterleri kullanamıyoruz. Böyle durumlarda, elimizdeki bir metni, cümleyi
veya kelimeyi Türkçe karakter içermeyecek bir hale getirmemiz gerekebiliyor.
Örneğin şu cümleyi ele alalım:

Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamıyoruz.

İşte buna benzer bir cümleyi kimi zaman Türkçe karakterlerinden arındırmak
zorunda kalabiliyoruz. Eğer elinizde Türkçe yazılmış bir metin varsa ve sizin
amacınız bu metin içinde geçen Türkçeye özgü karakterleri noktasız benzerleriyle
değiştirmek isestr.maketrans()vetranslate()metotlarından
yararlanabilirsiniz.

Örneğimiz şu cümle idi:

Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamıyoruz.

Amacımız bu cümleyi şu şekilde değiştirmek:

Bildiginiz gibi, internet uzerinde bazen Turkce karakterleri kullanamiyoruz.

Bunun için şöyle bir kod yazabilirsiniz:

```python
kaynak = "şçöğüıŞÇÖĞÜİ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

metin = "Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamıyoruz."

print(metin.translate(çeviri_tablosu))

```

Bu kodları çalıştırdığımızda şöyle bir çıktı elde ederiz:

```python
Bildiginiz gibi, internet uzerinde bazen Turkce karakterleri kullanamiyoruz.

```

Gördüğünüz gibi,“kaynak”adlı karakter dizisi içinde belirttiğimiz bütün
harfler“hedef”adlı karakter dizisi içindeki harflerle tek tek değiştirildi.
Böylece Türkçeye özgü karakterleri (‘şçöğüıŞÇÖĞÜİ’) en yakın noktasız
benzerleriyle (‘scoguiSCOGUI’) değiştirmiş olduk.

Peki yukarıda nasıl bir süreç işledi de biz istediğimiz sonucu elde edebildik.
Dilerseniz yukarıdaki kodlara biraz daha yakından bakalım. Meselaçeviri_tablosuadlı değişkenin çıktısına bakarakstr.maketrans()metodunun
alttan alta neler karıştırdığını görelim:

```python
kaynak = "şçöğüıŞÇÖĞÜİ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

print(çeviri_tablosu)

```

Bu kodları çalıştırdığımızda şöyle bir çıktı alıyoruz:

```python
{214: 79, 231: 99, 220: 85, 199: 67, 304: 73, 305: 105,
286: 71, 246: 111, 351: 115, 252: 117, 350: 83, 287: 103}

```

Bu çıktı size tamamen anlamsız görünmüş olabilir. Ama aslında son derece anlamlı
ve bir o kadar da önemli bir çıktıdır bu. Gelin isterseniz bu çıktının yapısını
biraz inceleyelim. (Buna benzer bir çıktıyısorted()metodunu incelerken de
görmüştük)

Gördüğünüz gibi, tamamen sayılardan oluşan bir çıktı bu. Burada birbirlerinden
virgül ile ayrılmış sayı çiftleri görüyoruz. Bu sayı çiftlerini daha net
görebilmek için bu çıktıyı derli toplu bir hale getirelim:

```python
{214: 79,
 231: 99,
 220: 85,
 199: 67,
 304: 73,
 305: 105,
 286: 71,
 246: 111,
 351: 115,
 252: 117,
 350: 83,
 287: 103}

```

Bu şekilde sanırım çıktımız biraz daha anlam kazandı. Gördüğünüz gibi, iki nokta
üst üste işaretinin solunda ve sağında bazı sayılar var. Tahmin edebileceğiniz
gibi, soldaki sayılar sağdaki sayılarla ilişkili.

Peki bütün bu sayılar ne anlama geliyor ve bu sayılar arasında ne tür bir ilişki
var?

Teknik olarak, bilgisayarların temelinde sayılar olduğunu duymuşsunuzdur.
Bilgisayarınızda gördüğünüz her karakter aslında bir sayıya karşılık gelir.
Zaten bilgisayarlar ‘a’, ‘b’, ‘c’, vb. kavramları anlayamaz. Bilgisayarların
anlayabildiği tek şey sayılardır. Mesela siz klavyeden ‘a’ harfini girdiğinizde
bilgisayar bunu97olarak algılar. Ya da siz ‘i’ harfi girdiğinizde,
bilgisayarın gördüğü tek şey105sayısıdır… Bu durumu Python’dakichr()adlı özel bir fonksiyon yardımıyla teyit edebiliriz. Dikkatlice inceleyin:

```python
>>> chr(97)

'a'

>>> chr(105)

'i'

>>> chr(65)

'A'

```

Gördüğünüz gibi, gerçekten de her sayı bir karaktere karşılık geliyor.
İsterseniz bir de yukarıdaki sayı grubundaki sayıları denetleyelim:

```python
for i in 214, 231, 220, 199, 304, 305, 286, 246, 351, 252, 350, 287:
 print(i, chr(i))

```

Bu kodları çalıştırdığımızda şu çıktıyı elde ediyoruz:

```python
214 Ö
231 ç
220 Ü
199 Ç
304 İ
305 ı
286 Ğ
246 ö
351 ş
252 ü
350 Ş
287 ğ

```

Bu çıktı sayesinde bazı şeyler zihninizde yavaş yavaş açıklığa kavuşuyor olmalı.
Bu çıktı mesela214sayısının ‘Ö’ harfine,220sayısının ‘Ü’ harfine,305sayısının da ‘ı’ harfine karşılık geldiğini gösteriyor.

Burada iki nokta işaretinin sol tarafında kalan sayıların karakter
karşılıklarını gördük. Bir de iki nokta işaretinin sağ tarafında kalan sayılara
bakalım:

```python
for i in 79, 99, 85, 67, 73, 105, 71, 111, 115, 117, 83, 103:
 print(i, chr(i))

```

Bu da şu çıktıyı verdi:

```python
79 O
99 c
85 U
67 C
73 I
105 i
71 G
111 o
115 s
117 u
83 S
103 g

```

Burada da mesela79sayısının ‘O’ harfine,85sayısının ‘U’ harfine,105sayısının da ‘i’ harfine karşılık geldiğini görüyoruz.

Yukarıdaki ve yukarıdan bir önceki kodların çıktılarını bir araya getirirseniz
şöyle bir durumla karşı karşıya olduğunuzu görürsünüz:

```python
Ö O
ç c
Ü U
Ç C
İ I
ı i
Ğ G
ö o
ş s
ü u
Ş S
ğ g

```

Bütün bu söylediklerimizden şu sonuç çıkıyor:

çeviri_tablosu=str.maketrans(kaynak,hedef)satırı,kaynakvehedefolarak adlandırdığımız karakter dizilerini birleştirip, bu değişkenler içindeki
herbir karakteri birbiriyle eşleştiriyor. Yani aşağıdaki gibi bir işlem
yapıyor:

```python
çeviri_tablosu = {"Ö": "O",
 "ç": "c",
 "Ü": "U",
 "Ç": "C",
 "İ": "I",
 "ı": "i",
 "Ğ": "G",
 "ö": "o",
 "ş": "s",
 "ü": "u",
 "Ş": "S",
 "ğ": "g"}

```

Buradaçeviri_tablosudeğişkeni içinde gösterdiğimiz biçimin Python’daki adı
‘sözlük’tür. Sözlükler de tıpkı karakter dizileri gibi bir veri tipidir. Bunları
da birkaç bölüm sonra ayrıntılı bir biçimde inceleyeceğiz. Biz burada, bazı
şeyleri anlamamızı kolaylaştıracağı için sözlük adlı veri tipini oldukça genel
bir biçimde sizlere tanıttık. Dediğim gibi, bu veri tipinin ayrıntılarını daha
sonra inceleyeceğiz, ama yine de şu noktada sözlükleri kenarından köşesinden de
olsa tanımamız bizim için faydalı olacaktır.

Dediğim gibi, yukarıdaçeviri_tablosuadıyla gösterdiğimiz şey bir sözlüktür.
Bu sözlüğün nasıl çalıştığını görmek için şöyle bir kod yazalım:

```python
çeviri_tablosu = {"Ö": "O",
 "ç": "c",
 "Ü": "U",
 "Ç": "C",
 "İ": "I",
 "ı": "i",
 "Ğ": "G",
 "ö": "o",
 "ş": "s",
 "ü": "u",
 "Ş": "S",
 "ğ": "g"}

print(çeviri_tablosu["Ö"])

```

Bu kodları bir dosyaya kaydedip çalıştırırsanız şöyle bir çıktı alırsınız:

```python
O

```

Gördüğünüz gibi, sözlük içinde geçen“Ö”adlı öğeyi parantez içinde
belirttiğimiz zaman, Python bize bu öğenin karşısındaki değeri veriyor. Sözlük
içinde“Ö”öğesinin karşılığı“O”harfi olduğu için de çıktımız“O”oluyor. Bir de şunlara bakalım:

```python
çeviri_tablosu = {"Ö": "O",
 "ç": "c",
 "Ü": "U",
 "Ç": "C",
 "İ": "I",
 "ı": "i",
 "Ğ": "G",
 "ö": "o",
 "ş": "s",
 "ü": "u",
 "Ş": "S",
 "ğ": "g"}

print(çeviri_tablosu["Ö"])
print(çeviri_tablosu["ç"])
print(çeviri_tablosu["Ü"])
print(çeviri_tablosu["Ç"])
print(çeviri_tablosu["İ"])
print(çeviri_tablosu["ı"])
print(çeviri_tablosu["Ğ"])
print(çeviri_tablosu["ö"])
print(çeviri_tablosu["Ş"])
print(çeviri_tablosu["ğ"])

```

Bu kodları çalıştırdığımızda ise şöyle bir çıktı alıyoruz:

```python
O
c
U
C
I
i
G
o
S
g

```

Gördüğünüz gibi, sözlük içinde iki nokta üst üste işaretinin sol tarafında
görünen öğeleri parantez içinde yazarak, iki nokta üst üste işaretinin sağ
tarafındaki değerleri elde edebiliyoruz.

Bütün bu anlattıklarımızdan sonra şu satırları gayet iyi anlamış olmalısınız:

```python
kaynak = "şçöğüıŞÇÖĞÜİ"
hedef = "scoguiSCOGUI"

çeviri_tablosu = str.maketrans(kaynak, hedef)

```

Burada Python,kaynakvehedefadlı değişkenler içindeki karakter dizilerini
birer birer eşleştirerek bize bir sözlük veriyor. Bu sözlükte:

```python
"ş" harfi "s" harfine;
"ç" harfi "c" harfine;
"ö" harfi "o" harfine;
"ğ" harfi "g" harfine;
"ü" harfi "u" harfine;
"ı" harfi "i" harfine;
"Ş" harfi "S" harfine;
"Ç" harfi "C" harfine;
"Ö" harfi "O" harfine;
"Ğ" harfi "G" harfine;
"Ü" harfi "U" harfine;
"İ" harfi "I" harfine

```

karşılık geliyor…

Kodların geri kalanında ise şu satırları görmüştük:

```python
metin = "Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamıyoruz."

print(metin.translate(çeviri_tablosu))

```

Burada da orijinal metnimizi tanımladıktan sonratranslate()adlı metot
yardımıyla, çeviri tablosundaki öğe eşleşmesi doğrultusunda metnimizi tercüme
ediyoruz. Bu kodlardametin.translate(çeviri_tablosu)satırının yaptığı tek
şeyçeviri_tablosuadlı sözlükteki eşleşme kriterlerinimetinadlı karakter
dizisine uygulamaktan ibarettir.

Karakter dizilerinin bumaketrans()adlı metodu kullanım olarak gözünüze
öteki metotlardan farklı görünmüş olabilir. Daha açık bir dille ifade etmek
gerekirse, bu metodu bir karakter dizisi üzerine değil destrüzerine
uyguluyor olmamız, yanistr.maketrans()yazıyor olmamız sizi şaşırtmış
olabilir. Eğer anlamanızı kolaylaştıracaksa;

```python
çeviri_tablosu = str.maketrans(kaynak, hedef)

```

satırını şu şekilde de yazabilirsiniz:

```python
çeviri_tablosu = ''.maketrans(kaynak, hedef)

```

Yanimaketrans()metodunu boş bir karakter dizisi üzerine de
uygulayabilirsiniz. Neticedemaketrans()karakter dizilerinin bir metodudur.
Bu metot hangi karakter dizisi üzerine uygulandığıyla değil, parametre olarak
hangi değerleri aldığıyla (bizim örneğimizdekaynakvehedef) ilgilenir.
Dolayısıyla bu metodu ilgili-ilgisiz her türlü karakter dizisine
uygulayabilirsiniz:

```python
çeviri_tablosu = 'mahmut'.maketrans(kaynak, hedef)
çeviri_tablosu = 'zalim dünya!'.maketrans(kaynak, hedef)

```

Ama tabii dikkat dağıtmamak açısından en uygun hareket, bu karakter dizisinistrüzerine uygulamak olacaktır:

```python
çeviri_tablosu = str.maketrans(kaynak, hedef)

```

Bu küçük ayrıntıya da dikkati çektiğimize göre yolumuza devam edebiliriz…

Yukarıda verdiğimiz örnek vasıtasıylastr.maketrans()vetranslate()adlı metotları epey ayrıntılı bir şekilde incelemiş olduk. Dilerseniz pratik
olması açısından bir örnek daha verelim:

> **Not**
> istihza.com sitemizin forum üyelerinden Barbaros Akkurthttp://www.istihza.com/forum/viewtopic.php?f=25&t=63(arşiv linki)
adresinde şöyle bir problemden bahsediyor:
> “Ben on parmak Türkçe F klavye kullanıyorum. Bunun için, bazı tuş
kombinasyonları ile veya sistem tepsisi üzerindeki klavye simgesine
tıklayarak Türkçe Q - Türkçe F değişimi yapıyorum. Bazen bunu yapmayı
unutuyorum ve bir metne bakarak yazıyorsam gözüm ekranda olmuyor. Bir
paragrafı yazıp bitirdikten sonra ekranda bir karakter salatası görünce çok
bozuluyorum.”

Not

istihza.com sitemizin forum üyelerinden Barbaros Akkurthttp://www.istihza.com/forum/viewtopic.php?f=25&t=63(arşiv linki)
adresinde şöyle bir problemden bahsediyor:

“Ben on parmak Türkçe F klavye kullanıyorum. Bunun için, bazı tuş
kombinasyonları ile veya sistem tepsisi üzerindeki klavye simgesine
tıklayarak Türkçe Q - Türkçe F değişimi yapıyorum. Bazen bunu yapmayı
unutuyorum ve bir metne bakarak yazıyorsam gözüm ekranda olmuyor. Bir
paragrafı yazıp bitirdikten sonra ekranda bir karakter salatası görünce çok
bozuluyorum.”

İşte böyle bir durumda yukarıdaki iki metodu kullanarak o karakter salatasını
düzeltebilirsiniz. Karakter salatamız şu olsun:

Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?

Buna göre kodlarımızı yazmaya başlayabiliriz. Öncelikle metnimizi tanımlayalım:

```python
metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?"

```

Şimdi de sırasıyla q ve f klavye düzenlerini birer karakter dizisi haline getirelim:

```python
q_klavye_düzeni = "qwertyuıopğüasdfghjklşi,zxcvbnmöç."
f_klavye_düzeni = "fgğıodrnhpqwuieaütkmlyşxjövcçzsb.,"

```

Burada amacımız yanlışlıkla q klavye düzeninde yazıldığı için karman çorman bir
hale gelmiş metni düzgün bir şekilde f klavye düzenine dönüştürmek. Yani burada
çıkış noktamız (kaynağımız)q_klavye_düzeniiken, varış noktamız (hedefimiz)f_klavye_düzeni. Buna göre çeviri tablomuzu oluşturabiliriz:

```python
çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni)

```

Tıpkı bir önceki örnekte olduğu gibi, burada daçeviri_tablosuadlı değişkeniprint()fonksiyonunu kullanarak yazdırırsanız şöyle bir çıktıyla
karşılaşırsınız:

```python
{231: 46,
 287: 113,
 44 : 120,
 46 : 44,
 305: 110,
 246: 98,
 351: 121,
 97 : 117,
 98 : 231,
 99 : 118,
 100: 101,
 101: 287,
 102: 97,
 103: 252,
 104: 116,
 105: 351,
 106: 107,
 107: 109,
 108: 108,
 109: 115,
 110: 122,
 111: 104,
 112: 112,
 113: 102,
 114: 305,
 115: 105,
 116: 111,
 117: 114,
 118: 99,
 119: 103,
 120: 246,
 121: 100,
 122: 106,
 252: 119}

```

Tahmin edebileceğiniz gibi, bu sözlükte iki nokta üst üste işaretinin solundaki
sayılarq_klavye_düzeniadlı değişken içindeki karakterleri; sağındaki sayılar
isef_klavye_düzeniadlı değişken içindeki karakterleri temsil ediyor.

Son olaraktranslate()metodu yardımıyla sözlükteki öğe eşleşmesinimetinadlı değişkenin üzerine uyguluyoruz:

```python
print(metin.translate(çeviri_tablosu))

```

Kodları topluca görelim:

```python
metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?"

q_klavye_düzeni = "qwertyuıopğüasdfghjklşi,zxcvbnmöç."
f_klavye_düzeni = "fgğıodrnhpqwuieaütkmlyşxjövcçzsb.,"

çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni)

print(metin.translate(çeviri_tablosu))

```

Ne elde ettiniz?

Yukarıdaki iki örnekte de gördüğümüz gibi,str.maketrans()metodu kaynak ve
hedef karakter dizilerini alıp bunları birleştirerek bize bir sözlük veri
tipinde bir nesne veriyor. Yani tıpkıinput()fonksiyonunun bize bir
karakter dizisi verdiği gibi,str.maketrans()metodu da bize bir sözlük
veriyor.

Eğer isterseniz, sözlüğüstr.maketrans()metoduna oluşturtmak yerine,
kendiniz de bir sözlük oluşturarakstr.maketrans()metoduna parametre olarak
atayabilirsiniz. Örneğin:

```python
metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?"

sözlük = {"q": "f",
 "w": "g",
 "e": "ğ",
 "r": "ı",
 "t": "o",
 "y": "d",
 "u": "r",
 "ı": "n",
 "o": "h",
 "p": "p",
 "ğ": "q",
 "ü": "w",
 "a": "u",
 "s": "i",
 "d": "e",
 "f": "a",
 "g": "ü",
 "h": "t",
 "j": "k",
 "k": "m",
 "l": "l",
 "ş": "y",
 "i": "ş",
 ",": "x",
 "z": "j",
 "x": "ö",
 "c": "v",
 "v": "c",
 "b": "ç",
 "n": "z",
 "m": "s",
 "ö": "b",
 "ç": ".",
 ".": ","}

çeviri_tablosu = str.maketrans(sözlük)
print(metin.translate(çeviri_tablosu))

```

Burada birbiriyle eşleşecek karakterleri kendimiz yazıp bir sözlük oluşturduk ve
bunu parametre olarak doğrudanstr.maketrans()metoduna verdik. Bu kodlarda
kaynak ve hedef diye iki ayrı karakter dizisi tanımlamak yerine tek bir sözlük
oluşturduğumuz için,str.maketrans()metodunu iki parametreyle değil, tek
parametreyle kullandığımıza dikkat edin. Ayrıca sözlüğü nasıl oluşturduğumuzu da
dikkatlice inceleyin.

Sözlükteki öğe çiftlerini böyle alt alta yazmamızın nedeni zorunluluk değil, bir
tercihtir. İstersek bu sözlüğü şöyle de tanımlayabilirdik:

```python
sözlük = {"q": "f", "w": "g", "e": "ğ", "r": "ı", "t": "o", "y": "d", "u": "r",
 "ı": "n", "o": "h", "p": "p", "ğ": "q", "ü": "w", "a": "u", "s": "i",
 "d": "e", "f": "a", "g": "ü", "h": "t", "j": "k", "k": "m", "l": "l",
 "ş": "y", "i": "ş", ",": "x", "z": "j", "x": "ö", "c": "v", "v": "c",
 "b": "ç", "n": "z", "m": "s", "ö": "b", "ç": ".", ".": ","}

```

Burada da öğe çiftlerini yan yana yazdık. Bu iki yöntemden hangisi size daha
okunaklı geliyorsa onu tercih edebilirsiniz.

Şimdi size bir soru sormama izin verin. Acaba aşağıdaki metin içinde geçen bütün
sesli harfleri silin desem, nasıl bir kod yazarsınız?

Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı
tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,
isminin Python olmasına bakarak, bu programlama dilinin, adını piton
yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama
dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini,
The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying
Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar
gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan
figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır
diyebiliriz.

Aklınıza ilk olarak şöyle bir kod yazmak gelebilir:

```python
metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcı tarafından 90'lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını
piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu
programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty
Python's Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır
diyebiliriz."""

sesli_harfler = "aeıioöuüAEIİOÖUÜ"

yeni_metin = ""

for i in metin:
 if not i in sesli_harfler:
 yeni_metin += i

print(yeni_metin)

```

Burada önceliklemetinadlı bir değişken tanımlayarak metnimizi bu değişken
içine yerleştirdik. Ardından da Türkçedeki sesli harfleri içeren bir karakter
dizisi tanımladık.

Daha sonra dayeni_metinadlı boş bir karakter dizisi oluşturduk. Bu karakter
dizisi, orijinal metnin, sesli harfler ayıklandıktan sonraki halini
barındıracak. Biliyorsunuz, karakter dizileri değiştirilemeyen (immutable) bir
veri tipidir. Dolayısıyla bir karakter dizisi içinde yaptığımız değişiklikleri
koruyabilmek için bu değişiklikleri başka bir değişken içinde tutmamız
gerekiyor.

Bu kodların ardından birfordöngüsü tanımlıyoruz. Buna göre, metin içinde
geçen her bir karaktere tek tek bakıyoruz (foriinmetin:) ve bu
karakterler arasında,sesli_harflerdeğişkeni içinde geçmeyenleri, yani bütün
sessiz harfleri (ifnotiinsesli_harfler:) tek tekyeni_metinadlı
değişkene yolluyoruz (yeni_metin+=i).

Son olarak dayeni_metinadlı karakter dizisini ekrana basıyoruz. Böylece
orijinal metin içindeki bütün sesli harfleri ayıklamış oluyoruz.

Yukarıdaki, gayet doğru ve geçerli bir yöntemdir. Böyle bir kod yazmanızın
hiçbir sakıncası yok. Ama eğer isterseniz aynı işistr.maketrans()vetranslate()metotları yardımıyla da halledebilirsiniz:

```python
metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcı tarafından 90'lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını
piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu
programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty
Python's Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır
diyebiliriz."""

silinecek = "aeıioöuüAEIİOÖUÜ"

çeviri_tablosu = str.maketrans('', '', silinecek)

print(metin.translate(çeviri_tablosu))

```

Burada da öncelikle metnimizi bir karakter dizisi içine yerleştirdik. Daha sonra
da şu kodu yazdık:

```python
silinecek = "aeıioöuüAEIİOÖUÜ"

```

Bu kodlar yardımıyla, metin içinden çıkarmak istediğimiz harfleri tek tek
belirledik.

Ardındanstr.maketrans()fonksiyonumuzu yazarak çeviri tablosunu oluşturduk.
Burada ilk iki parametrenin boş birer karakter dizisi olduğuna dikkat ediyoruz.
İlk iki parametreyi bu şekilde yazmamızın nedeni şu: Biz orijinal metin içindeki
herhangi bir şeyi değiştirmek istemiyoruz. Bizim amacımız orijinal metin
içindeki sesli harfleri silmek. Tabii o iki parametreyi yazmasak da olmaz. O
yüzden o iki parametrenin yerine birer tane boş karakter dizisi yerleştiriyoruz.

Bu noktadaçeviri_tablosuadlı değişkeni yazdırarak neler olup bittiğini daha
net görebilirsiniz:

```python
{214: None,
 97 : None,
 101: None,
 65 : None,
 105: None,
 111: None,
 304: None,
 305: None,
 220: None,
 117: None,
 246: None,
 73 : None,
 79 : None,
 252: None,
 85 : None,
 69 : None}

```

Gördüğünüz gibi,silinecekadlı değişken içindeki bütün karakterlerNonedeğeriyle eşleşiyor…None‘hiç, sıfır, yokluk’ gibi anlamlara gelir.
Dolayısıyla Python, iki nokta üst üste işaretinin sol tarafındaki karakterlerle
karşılaştığında bunların yerine birer adet ‘yokluk’ koyuyor! Yani sonuç olarak
bu karakterleri metinden silmiş oluyor…

Bu kodlarda iki nokta üst üste işaretinin solundaki karakterlerinNoneile
eşleşmesini sağlayan şey,str.maketrans()metoduna verdiğimiz üçüncü
parametredir. Eğer o parametreyi yazmazsak, yani kodlarımızı şu şekle getirirsekçeviri_tablosudeğişkeninin çıktısı farklı olacaktır:

```python
metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcı tarafından 90'lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını
piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu
programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu
programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty
Python's Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak
her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde
bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır
diyebiliriz."""

silinecek = "aeıioöuüAEIİOÖUÜ"

çeviri_tablosu = str.maketrans('', '')

print(çeviri_tablosu)

```

Bu kodları çalıştırdığımızda şöyle bir çıktı alırız:

```python
{}

```

Gördüğünüz gibi, elde ettiğimiz şey boş bir sözlüktür. Sözlük boş olduğu, yani
değiştirilecek herhangi bir karakter olmadığı için bu kodlar orijinal metin
üzerinde herhangi bir değişiklik yapmaz.

İsterseniz üçüncü parametrenin ne işe yaradığını ve nasıl çalıştığını daha iyi
anlayabilmek için daha basit bir örnek verelim:

```python
metin = "Cem Yılmaz"

kaynak = "CY"
hedef = "cy"
silinecek = "eıa "

çeviri_tablosu = str.maketrans(kaynak, hedef, silinecek)

print(metin.translate(çeviri_tablosu))

```

Burada ‘C’ ve ‘Y’ harflerini sırasıyla ‘c’ ve ‘y’ harfleriyle eşleştirdik. Bu
nedenle orijinal metin içindeki ‘C’ ve ‘Y’ harfleri yerlerini sırasıyla ‘c’ ve
‘y’ harflerine bıraktı. Silinecek karakterler olarak ise ‘e’, ‘ı’, ‘a’ ve boşluk
karakterlerini seçtik. Böylece ‘Cem Yılmaz’ adlı orijinal metin içindeki boşluk
karakteri de silinerek, bu metin ‘cmylmz’ karakter dizisine dönüştü.

### isalpha()

Bu metot yardımıyla bir karakter dizisinin ‘alfabetik’ olup olmadığını
denetleyeceğiz. Peki ‘alfabetik’ ne demek?

Eğer bir karakter dizisi içinde yalnızca alfabe harfleri (‘a’, ‘b’, ‘c’ gibi…)
varsa o karakter dizisi için ‘alfabetik’ diyoruz. Bir örnekle bunu
doğrulayalım:

```python
>>> a = "kezban"
>>> a.isalpha()

True

```

Ama:

```python
>>> b = "k3zb6n"
>>> b.isalpha()

False

```

### isdigit()

Bu metot daisalpha()metoduna benzer. Bunun yardımıyla bir karakter
dizisinin sayısal olup olmadığını denetleyebiliriz. Sayılardan oluşan karakter
dizilerine ‘sayı değerli karakter dizileri’ adı verilir. Örneğin şu bir ‘sayı
değerli karakter dizisi’dir:

```python
>>> a = "12345"

```

Metodumuz yardımıyla bunu doğrulayabiliriz:

```python
>>> a.isdigit()

True

```

Ama şu karakter dizisi sayısal değildir:

```python
>>> b = "123445b"

```

Hemen kontrol edelim:

```python
>>> b.isdigit()

False

```

### isalnum()

Bu metot, bir karakter dizisinin ‘alfanümerik’ olup olmadığını denetlememizi
sağlar. Peki ‘alfanümerik’ nedir?

Daha önce bahsettiğimiz metotlardan hatırlayacaksınız:

Alfabetik karakter dizileri, alfabe harflerinden oluşan karakter dizileridir.

Sayısal karakter dizileri, sayılardan oluşan karakter dizileridir.

Alfanümerik karakter dizileri ise bunun birleşimidir. Yani sayı ve/veya harflerden
oluşan karakter dizilerine alfanümerik karakter dizileri adı verilir. Örneğin şu
karakter dizisi alfanümerik bir karakter dizisidir:

```python
>>> a = "123abc"

```

İsterseniz hemen bu yeni metodumuz yardımıyla bunu doğrulayalım:

```python
>>> a.isalnum()

True

```

Eğer denetleme sonucundaTruealıyorsak, o karakter dizisi alfanümeriktir. Bir
de şuna bakalım:

```python
>>> b = "123abc>"
>>> b.isalnum()

False

```

bdeğişkeninin tuttuğu karakter dizisinde alfanümerik karakterlerin yanısıra
(“123abc”), alfanümerik olmayan bir karakter dizisi de bulunduğu için (“>”),b.isalnum()şeklinde gösterdiğimiz denetlemenin sonucuFalse(yanlış)
olarak görünecektir.

Dolayısıyla, bir karakter dizisi içinde en az bir adet alfanümerik olmayan bir
karakter dizisi bulunursa (bizim örneğimizde">"), o karakter dizisi
alfanümerik olmayacaktır.

### isdecimal()

Bu metot yardımıyla bir karakter dizisinin ondalık sayı cinsinden olup
olmadığını denetliyoruz. Mesela aşağıdaki örnek ondalık sayı cinsinden bir
karakter dizisidir:

```python
>>> a = "123"
>>> a.isdecimal()

True

```

Ama şu ise kayan noktalı (floating-point) sayı cinsinden bir karakter dizisidir:

```python
>>> a = "123.3"
>>> a.isdecimal()

False

```

Dolayısıylaa.isdecimal()komutuFalseçıktısı verir…

### isidentifier()

Identifierkelimesi Türkçede ‘tanımlayıcı’ anlamına gelir. Python’da
değişkenler, fonksiyon ve modül adlarına ‘tanımlayıcı’ denir. İşte başlıkta
gördüğümüzisidentifier()metodu, neyin tanımlayıcı olup neyin tanımlayıcı
olamayacağını denetlememizi sağlar. Hatırlarsanız değişkenler konusundan
bahsederken, değişken adı belirlemenin bazı kuralları olduğunu söylemiştik. Buna
göre, örneğin, değişken adları bir sayı ile başlayamıyordu. Dolayısıyla şöyle
bir değişken adı belirleyemiyoruz:

```python
>>> 1a = 12

```

Dediğimiz gibi, değişkenler birer tanımlayıcıdır. Dolayısıyla bir değişken
adının geçerli olup olmadığınıisidentifier()metodu yardımıyla
denetleyebiliriz:

```python
>>> "1a".isidentifier()

False

```

Demek ki"1a"ifadesini herhangi bir tanımlayıcı adı olarak kullanamıyoruz.
Yani bu ada sahip bir değişken, fonksiyon adı veya modül adı oluşturamıyoruz.
Ama mesela"liste1"ifadesi geçerli bir tanımlayıcıdır. Hemen denetleyelim:

```python
>>> "liste1".isidentifier()

True

```

### isnumeric()

Bu metot bir karakter dizisinin nümerik olup olmadığını denetler. Yani bu metot
yardımıyla bir karakter dizisinin sayı değerli olup olmadığını
denetleyebiliriz:

```python
>>> "12".isnumeric()

True

>>> "dasd".isnumeric()

False

```

### isspace()

Bu metot yardımıyla bir karakter dizisinin tamamen boşluklardan oluşup
oluşmadığını denetleyebiliriz. Eğer karakter dizimiz boşluklardan oluşuyorsa bu
metotTrueçıktısı verecek, ama eğer karakter dizimizin içinde bir tane bile
boşluk harici karakter varsa bu metotFalseçıktısı verecektir:

```python
>>> a = " "
>>> a.isspace()

True

>>> a = " "
>>> a.isspace()

True

>>> a = "" #karakter dizimiz tamamen boş. İçinde boşluk karakteri bile yok...
>>> a.isspace()

False

>>> a = "fd"
>>> a.isspace()

False

```

### isprintable()

Hatırlarsanız önceki derslerimizde\n,\t,\rve buna benzer
karakterlerden söz etmiştik. Örneğin\nkarakterinin ‘satır başı’ anlamına
geldiğini ve bu karakterin görevinin karakter dizisini bir alt satıra almak
olduğunu söylemiştik. Örnek verelim:

```python
>>> print("birinci satır\nikinci satır")

birinci satır
ikinci satır

```

Bu örnekte\nkarakterinin öteki karakterlerden farklı olduğunu görüyorsunuz.
Mesela“b”karakteri komut çıktısında görünüyor. Ama\nkarakteri çıktıda
görünmüyor.\nkarakteri elbette yukarıdaki kodlar içinde belli bir işleve
sahip. Ancak karakter dizisindeki öteki karakterlerden farklı olarak\nkarakteri ekranda görünmüyor. İşte Python’da bunun gibi, ekranda görünmeyen
karakterlere ‘basılmayan karakterler’ (non-printing characters) adı verilir.
‘b’, ‘c’, ‘z’, ‘x’, ‘=’, ‘?’, ‘!’ ve benzeri karakterler ise ‘basılabilen
karakterler’ (printable characters) olarak adlandırılır. İşte başlıkta
gördüğünüzisprintable()metodu da karakterlerin bu yönünü sorgular. Yani
bir karakterin basılabilen bir karakter mi yoksa basılmayan bir karakter mi
olduğunu söyler bize. Örneğin:

```python
>>> karakter = "a"
>>> karakter.isprintable()

True

```

Demek ki“a”karakteri basılabilen bir karaktermiş. Bir de şuna bakalım:

```python
>>> karakter = "\n"
>>> karakter.isprintable()

False

```

Demek ki\nkarakteri gerçekten de basılamayan bir karaktermiş.

Basılamayan karakterlerin listesini görmek içinhttps://www.asciitable.com/adresini ziyaret edebilirsiniz. Listedeki ilk32karakter (0’dan başlayarak32’ye kadar olan karakterler) ve listedeki127.karakter basılamayan
karakterlerdir.

## Karakter Dizilerini Biçimlendirmek

Bu bölüme gelinceye kadar, Python’da karakter dizilerinin biçimlendirilmesine
ilişkin epey söz söyledik. Ancak bu konu ile ilgili bilgilerimiz hem çok
dağınık, hem de çok yüzeysel. İşte bu bölümde amacımız, daha önce farklı
yerlerde dile getirdiğimiz bu önemli konuya ait bilgi kırıntılarını bir araya
toplayıp, karakter dizisi biçimlendirme konusunu, Python bilgimiz elverdiği
ölçüde ayrıntılı bir şekilde ele almak olacak.

Şu ana kadar yaptığımız örneklere bakarak, programlama maceranız boyunca
karakter dizileriyle bol bol haşır neşir olacağınızı anlamış olmalısınız. Bundan
sonra yazdığınız programlarda da karakter dizilerinin size pek çok farklı
biçimlerde geldiğine tanık olacaksınız. Farklı farklı biçimlerde elinize ulaşan
bu karakter dizilerini, muhtemelen, sadece alt alta ve rastgele bir şekilde
ekrana yazdırmakla yetinmeyeceksiniz. Bu karakter dizilerini, yazdığınız
programlarda kullanabilmek için, programınıza uygun şekillerde biçimlendirmeniz
gerekecek. Dilerseniz neden bahsettiğimizi daha net bir şekilde anlatabilmek
için çok basit bir örnek verelim.

Diyelim ki, yazdığınız bir programda kullanmak üzere, kullanıcıdan isim bilgisi
almanız gerekiyor. Programınızın işleyişi gereğince, eğer isim5karakterse
veya bundan küçükse ismin tamamı görüntülenecek, ama eğer isim5karakterden
büyükse5karakteri aşan kısım yerine üç nokta işareti koyulacak. Yani eğer
isimFıratise bu ismin tamamı görüntülenecek. Ama eğer isim meselaAbdullahise, o zaman bu isimAbdul…şeklinde görüntülenecek.

Bu amaca ulaşmak için ilk denememizi yapalım:

```python
isim = input("isminiz: ")

if len(isim) <= 5:
 print(isim[:5])
else:
 print(isim[:5], "...")

```

Buradan elde ettiğimiz çıktı ihtiyacımızı kısmen karşılıyor. Ama çıktı tam
istediğimiz gibi değil. Çünkü normalde isme bitişik olması gereken üç nokta
işareti, isimden bir boşluk ile ayrılmış. Yani biz şöyle bir çıktı isterken:

```python
Abdul...

```

Şöyle bir çıktı elde ediyoruz:

```python
Abdul ...

```

Bu sorunu şu şekilde halledebiliriz:

```python
isim = input("isminiz: ")

if len(isim) <= 5:
 print(isim[:5])
else:
 print(isim[:5] + "...")

```

veya:

```python
isim = input("isminiz: ")

if len(isim) <= 5:
 print(isim[:5])
else:
 print(isim[:5], "...", sep="")

```

Yukarıdaki gibi basit durumlarda klasik karakter dizisi birleştirme yöntemlerini
kullanarak işinizi halledebilirsiniz. Ama daha karmaşık durumlarda, farklı
kaynaklardan gelen karakter dizilerini ihtiyaçlarınıza göre bir araya getirmek,
karakter dizisi birleştirme yöntemleri ile pek mümkün olmayacak veya çok zor
olacaktır.

Mesela şöyle bir durum düşünün:

Yazdığınız programda kullanıcıya bir parola soruyorsunuz. Amacınız bu parolanın,
programınızda belirlediğiniz ölçütlere uyup uymadığını tespit etmek. Eğer
kullanıcı tarafından belirlenen parola uygunsa ona şu çıktıyı göstermek
istiyorsunuz (parolanınb5tY6golduğunu varsayalım):

```python
.. code-block:: pycon

```

Girdiğiniz parola (b5tY6g) kurallara uygun bir paroladır!

Bu çıktıyı elde etmek için şöyle bir kod yazabilirsiniz:

```python
parola = input("parola: ")

print("Girdiğiniz parola (" + parola + ") kurallara uygun bir paroladır!")

```

Gördüğünüz gibi, sadece karakter dizisi birleştirme yöntemlerini kullanarak
istediğimiz çıktıyı elde ettik, ama farkettiyseniz bu defa işler biraz da olsa
zorlaştı.

Bir de uzun ve karmaşık bir metnin içine dışarıdan değerler yerleştirmeniz
gereken şöyle bir metinle karşı karşıya olduğunuzu düşünün:

```python
Sayın .........

.... tarihinde yapmış olduğunuz, ........ hakkındaki başvurunuz incelemeye alınmıştır.

Size .... işgünü içinde cevap verilecektir.

Saygılarımızla,

......

```

Böyle bir metin içine dışarıdan değer yerleştirmek için karakter dizisi
birleştirme yöntemlerine başvurmak işinizi epey zorlaştıracaktır.

İşte klasik karakter dizisi birleştirme işlemlerinin yetersiz kaldığı veya
işleri büsbütün zorlaştırdığı bu tür durumlarda Python’ın size sunduğu ‘karakter
dizisi biçimlendirme’ araçlarından yararlanabilirsiniz.

Bunun için biz bu bölümde iki farklı yöntemden söz edeceğiz:
1. %işareti ile biçimlendirme
1. format()metodu ile biçimlendirme.

%işareti ile biçimlendirme

format()metodu ile biçimlendirme.

%işareti ile biçimlendirme, karakter dizisi biçimlendirmenin eski yöntemidir.
Bu yöntem ağırlıklı olarak Python’ın 3.x sürümlerinden önce kullanılıyordu. Ama
Python’ın 3.x sürümlerinde de bu yöntemi kullanma imkanımız var. Her ne kadar bu
yöntem Python3’te geçerliliğini korusa da muhtemelen ileride dilden tamamen
kaldırılacak. Ancak hem etrafta bu yöntemle yazılmış eski programlar olması, hem
de bu yöntemin halen geçerliliğini koruması nedeniyle bu yöntemi (kendimiz
kullanmayacak bile olsak) mutlaka öğrenmemiz gerekiyor.

format()metodu ise Python’ın 3.x sürümleri ile dile dahil olan bir
özelliktir. Python’ın 2.x sürümlerinde bu metodu kullanamazsınız. Dilin
geleceğinde bu metot olduğu için, yeni yazılan kodlardaformat()metodunu
kullanmak daha akıllıca olacaktır.

Biz bu sayfalarda yukarıda adını andığımız her iki yöntemi de inceleyeceğiz. İlk
olarak%işareti ile biçimlendirmeden söz edelim.

### % İşareti ile Biçimlendirme (Eski Yöntem)

Daha önce de söylediğimiz gibi, Python programlama dilinin 3.x sürümlerinden
önce, bir karakter dizisini biçimlendirebilmek için%işaretinden
yararlanıyorduk. Bununla ilgili basit bir örnek verelim:

```python
parola = input("parola: ")

print("Girdiğiniz parola (%s) kurallara uygun bir paroladır!" %parola)

```

Bu programı çalıştırıp parola girdiğinizde, yazdığınız parola çıktıda parantez
içinde görünecektir.

Yukarıdaki yapıyı incelediğimizde iki nokta gözümüze çarpıyor:
1. İlk olarak, karakter dizisinin içinde bir%işareti ve buna bitişik
olarak yazılmış birsharfi görüyoruz.
1. İkincisi, karakter dizisinin dışında%parolagibi bir ifade daha var.

İlk olarak, karakter dizisinin içinde bir%işareti ve buna bitişik
olarak yazılmış birsharfi görüyoruz.

İkincisi, karakter dizisinin dışında%parolagibi bir ifade daha var.

Rahatlıkla tahmin edebileceğiniz gibi, bu ifadeler birbiriyle doğrudan
bağlantılıdır. Dilerseniz bu yapıyı açıklamaya geçmeden önce bir örnek daha
verelim. Bu örnek sayesinde benim açıklamama gerek kalmadan karakter dizisi
biçimlendirme mantığını derhal kavrayacağınızı zannediyorum:

```python
print("%s ve %s iyi bir ikilidir!" %("Python", "Django"))

```

Dediğim gibi, bu basit örnek karakter dizilerinin nasıl biçimlendirildiğini
gayet açık bir şekilde gösteriyor. Dilerseniz yapıyı şöyle bir inceleyelim:
1. Python’da%syapısı, karakter dizisi içinde bir yer tutma vazifesi görür.
1. %syapısı bir anlamda değişkenlere benzer. Tıpkı değişkenlerde olduğu
gibi,%syapısının değeri değişebilir.
1. Bir karakter dizisi içindeki her%sifadesi için, karakter dizisi
dışında bu ifadeye karşılık gelen bir değer olmalıdır. Python, karakter
dizisi içinde geçen her%sifadesinin yerine, karakter dizisi dışındaki
her bir değeri tek tek yerleştirir. Bizim örneğimizde karakter dizisi
içindeki ilk%sifadesinin karakter dizisi dışındaki karşılığı“Python”;
karakter dizisi içindeki ikinci%sifadesinin karakter dizisi dışındaki
karşılığı ise“Django”’dur.
1. Eğer karakter dizisi içindeki%sişaretlerinin sayısı ile karakter
dizisi dışında bu işaretlere karşılık gelen değerlerin sayısı birbirini
tutmazsa Python bize bir hata mesajı gösterecektir. Mesela:>>>print("Benim adım%s, soyadım%s"%"istihza")Traceback (most recent call last):File"<stdin>",line1,in<module>TypeError:not enough arguments for format string

Python’da%syapısı, karakter dizisi içinde bir yer tutma vazifesi görür.

%syapısı bir anlamda değişkenlere benzer. Tıpkı değişkenlerde olduğu
gibi,%syapısının değeri değişebilir.

Bir karakter dizisi içindeki her%sifadesi için, karakter dizisi
dışında bu ifadeye karşılık gelen bir değer olmalıdır. Python, karakter
dizisi içinde geçen her%sifadesinin yerine, karakter dizisi dışındaki
her bir değeri tek tek yerleştirir. Bizim örneğimizde karakter dizisi
içindeki ilk%sifadesinin karakter dizisi dışındaki karşılığı“Python”;
karakter dizisi içindeki ikinci%sifadesinin karakter dizisi dışındaki
karşılığı ise“Django”’dur.

Eğer karakter dizisi içindeki%sişaretlerinin sayısı ile karakter
dizisi dışında bu işaretlere karşılık gelen değerlerin sayısı birbirini
tutmazsa Python bize bir hata mesajı gösterecektir. Mesela:

```python
>>> print("Benim adım %s, soyadım %s" %"istihza")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: not enough arguments for format string

```

Gördüğünüz gibi bu kodlar hata verdi. Çünkü karakter dizisi içindeki iki adet%sifadesine karşılık, karakter dizisinin dışında tek bir değer var
(“istihza”). Halbuki bizim şöyle bir kod yazmamız gerekiyordu:

```python
>>> isim = "istihza"
>>> print("%s adlı kişinin mekanı www.%s.com adresidir." %(isim, isim))

```

Bu defa herhangi bir hata mesajı almadık. Çünkü bu kodlarda, olması gerektiği
gibi, karakter dizisi içindeki iki adet%sifadesine karşılık, dışarıda da iki
adet değer var.

Eğer karakter dizisi içinde tek bir%sifadesi varsa, karakter dizisi dışında
buna karşılık gelen değeri gösterirken, bu değeri parantez içine almamıza gerek
yok. Ama eğer karakter dizisi içinde birden fazla%sişareti varsa, bunlara
karşılık gelen değerleri parantez içinde gösteriyoruz. Mesela yukarıdaki parola
örneğinde, karakter dizisinin içinde tek bir%sifadesi var. Dolayısıyla
karakter dizisi dışında bu ifadeye karşılık gelenparoladeğişkenini parantez
içine almıyoruz. Ama“Python”ve“Django”örneğinde karakter dizisi içinde
iki adet%sifadesi yer aldığı için, karakter dizisi dışında bu ifadelere
karşılık gelen“Python”ve“Django”kelimelerini parantez içinde
gösteriyoruz.

Bütün bu anlattıklarımızı sindirebilmek için dilerseniz bir örnek verelim:

```python
kardiz = "istihza"

for sıra, karakter in enumerate(kardiz, 1):
 print("%s. karakter: '%s'" %(sıra, karakter))

```

Gördüğünüz gibi,“istihza”adlı karakter dizisi içindeki her bir harfin
sırasını ve harfin kendisini uygun bir düzen içinde ekrana yazdırdık. Karakter
sırasının ve karakterin kendisinin cümle içinde geleceği yerleri%sişaretleri
ile gösteriyoruz. Python da her bir değeri, ilgili konumlara tek tek
yerleştiriyor.

Hatırlarsanız önceki derslerimizde basit bir hesap makinesi örneği vermiştik.
İşte şimdi öğrendiklerimizi o programa uygularsak karakter dizisi
biçimlendiricileri üzerine epey pratik yapmış oluruz:

```python
giriş = """
 (1) topla
 (2) çıkar
 (3) çarp
 (4) böl
 (5) karesini hesapla
 (6) karekök hesapla
 """
print(giriş)

a = 1

while a == 1:
 soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ")

 if soru == "q":
 print("çıkılıyor...")
 a = 0

 elif soru == "1":
 sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: "))
 sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: "))

 #İlk %s'ye karşılık gelen değer : sayı1
 #İkinci %s'ye karşılık gelen değer: sayı2
 #Üçüncü %s'ye karşılık gelen değer: sayı1 + sayı2
 print("%s + %s = %s" %(sayı1, sayı2, sayı1 + sayı2))

 elif soru == "2":
 sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: "))
 sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: "))
 print("%s - %s = %s" %(sayı3, sayı4, sayı3 - sayı4))

 elif soru == "3":
 sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: "))
 sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: "))
 print("%s x %s = %s" %(sayı5, sayı6, sayı5 * sayı6))

 elif soru == "4":
 sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: "))
 sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: "))
 print("%s / %s = %s" %(sayı7, sayı8, sayı7 / sayı8))

 elif soru == "5":
 sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: "))

 #İlk %s'ye karşılık gelen değer : sayı9
 #İkinci %s'ye karşılık gelen değer: sayı9 ** 2
 print("%s sayısının karesi = %s" %(sayı9, sayı9 ** 2))

 elif soru == "6":
 sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: "))
 print("%s sayısının karekökü = %s" %(sayı10, sayı10 ** 0.5))

 else:
 print("Yanlış giriş.")
 print("Aşağıdaki seçeneklerden birini giriniz:", giriş)

```

Bu arada, gördüğünüz gibi, Python’da biçim düzenleyici olarak kullanılan simge
aynı zamanda ‘yüzde’ (%) anlamına da geliyor. O halde size şöyle bir soru
sorayım: Acaba0’dan100’e kadar olan sayıların başına birer yüzde işareti
koyarak bu sayıları nasıl gösterirsiniz?%0,%1,%10,%15gibi… Önce
şöyle bir şey deneyelim:

```python
>>> for i in range(100):
... print("%s" %i)
...

```

Bu kodlar tabii ki sadece0’dan100’e kadar olan sayıları ekrana dökmekle
yetinecektir. Sayıların başında%işaretini göremeyeceğiz.

Bir de şöyle bir şey deneyelim:

```python
>>> for i in range(100):
... print("%%s" %i)
...
Traceback (most recent call last):
 File "<stdin>", line 2, in <module>
TypeError: not all arguments converted during string formatting

```

Bu defa da hata mesajı aldık. Halbuki doğru cevap şu olmalıydı:

```python
>>> for i in range(100):
... print("%%%s" %i)
...

```

Burada%işaretini arka arkaya iki kez kullanarak bir adet%işareti elde
ettik. Daha sonra da normal bir şekilde%sbiçimini kullandık. Yani üç adet
‘%’ işaretini yan yana getirmiş olduk.

Bütün bu örneklerden sonra, karakter dizisi biçimlendiricilerinin işimizi ne
kadar kolaylaştırdığını görmüş olmalısınız. İstediğimiz etkiyi elde etmek için
karakter dizisi biçimlendiricilerini kullanmak, karakter dizilerini birleştirme
işlemlerinden yararlanmaya göre çok daha esnek bir yöntemdir. Hatta bazı
durumlarda karakter dizisi biçimlendiricilerini kullanmak makul tek yöntemdir.

Yukarıda verdiğimiz örnekler,%sile biçimlendirme konusunun en temel
yönlerini gösteriyor. Ama aslında bu aracı kullanarak çok daha karmaşık
biçimlendirme işlemleri de yapabiliriz.

Yani yukarıdaki örneklerde%syapısını en basit şekilde mesela şöyle
kullandık:

```python
>>> print("Karakter dizilerinin toplam %s adet metodu vardır" %len(dir(str)))

```

Ama eğer istersek bundan daha karmaşık biçimlendirme işlemleri de
gerçekleştirebiliriz. Şu örneğe bakın:

```python
>>> for i in dir(str):
... print("%15s" %i)

```

Gördüğünüz gibi%ilesişaretleri arasına bir sayı yerleştirdik. Bu sayı,
biçimlendirilecek karakter dizisinin toplam kaç karakterlik yer kaplayacağını
gösteriyor. Durumu daha net görebilmeniz için şöyle bir örnek verelim:

```python
>>> print("|%15s|" %"istihza")

| istihza|

```

Karakter dizisinin başına ve sonuna eklediğimiz ‘|’ işaretleri sayesinde
karakter dizisinin nasıl ve ne şekilde hizalandığını daha belirgin bir şekilde
görebiliyoruz. Aslında yukarıdaki örneğin yaptığı iş size hiç yabancı değil.
Aynı etkiyi, karakter dizisi metotlarındanrjust()ile de yapabileceğimizi
biliyorsunuz:

```python
>>> print("istihza".rjust(15))

```

Aynen yukarıdaki çıktıyırjust()metodunu kullanarak elde etmek için ise
şöyle bir şey yazabilirsiniz:

```python
>>> print("|%s|" %"istihza".rjust(15))

| istihza|

```

Yukarıdaki örnekte“istihza”karakter dizisini sağa doğru yasladık. Sola
yaslamak için ise negatif sayılardan yararlanabilirsiniz:

```python
>>> print("|%-15s|" %"istihza")

|istihza |

```

Tıpkı biraz önce verdiğimiz örnekteki gibi, aynı etkiyiljust()metoduyla da
elde edebilirsiniz:

```python
>>> print("|%s|" %"istihza".ljust(15))

|istihza |

```

Gördüğünüz gibi,%syapısını farklı şekillerde kullanarak epey karmaşık
çıktılar elde edebiliyoruz. Ama aslında karakter dizisi biçimlendiricilerini
kullanarak yapabileceklerimiz bunlarla da sınırlı değildir. Mesela size şöyle
bir soru sorduğumu düşünün: Acaba aşağıdaki içeriğe sahip birHTMLşablonunu
nasıl elde edebiliriz?

```python
<html>
 <head>
 <title> {{ sayfa başlığı }} </title>
 </head>

 <body>
 <h1> {{ birinci seviye başlık }} </h1>
 <p>Web sitemize hoşgeldiniz! Konumuz: {{ konu }}</p>
 </body>
</html>

```

Burada bütün değişkenler tek bir değere sahip olacak. Örneğin değişkenimizPython Programlama Diliise yukarıdaki şablon şöyle birHTMLsayfası
üretecek:

```python
<html>
 <head>
 <title> Python Programlama Dili </title>
 </head>

 <body>
 <h1> Python Programlama Dili </h1>
 <p>Web sitemize hoşgeldiniz! Konumuz: Python Programlama Dili</p>
 </body>
</html>

```

Aklınıza ilk olarak şöyle bir çözüm gelmiş olabilir:

```python
sayfa = """
<html>
 <head>
 <title> %s </title>
 </head>

 <body>
 <h1> %s </h1>
 <p>Web sitemize hoşgeldiniz! Konumuz: %s</p>
 </body>
</html>
"""

print(sayfa % ("Python Programlama Dili",
 "Python Programlama Dili",
 "Python Programlama Dili"))

```

Bu gayet makul ve doğru bir çözümdür. Ancak gördüğünüz gibi yukarıdaki kodlarda
bizi rahatsız eden bir nokta var. Bu kodlarda aynı karakter dizisini (“Python
Programlama Dili”) üç kez tekrar ediyoruz. En baştan beri söylediğimiz gibi,
kod yazarken tekrarlardan olabildiğince kaçınmaya çalışmamız programımızın
performansını artıracaktır. Burada da tekrardan kaçınmak amacıyla şöyle bir kod
yazmayı tercih edebiliriz. Dikkatlice inceleyin:

```python
sayfa = """
<html>
 <head>
 <title> %(dil)s </title>
 </head>

 <body>
 <h1> %(dil)s </h1>
 <p>Web sitemize hoşgeldiniz! Konumuz: %(dil)s</p>
 </body>
</html>
"""

print(sayfa % {"dil": "Python Programlama Dili"})

```

Gördüğünüz gibi, yukarıdaki kodlar bizi aynı karakter dizisini tekrar tekrar
yazma zahmetinden kurtardı. Peki ama nasıl? Gelin isterseniz bu yapıyı daha iyi
anlayabilmek için daha basit bir örnek verelim:

```python
print("depoda %(miktar)s kilo %(ürün)s kaldı" %{"miktar": 25,
 "ürün": "elma"})

```

Burada şöyle bir yapıyla karşı karşıyayız:

```python
"%(değişken_adı)s" % {"değişken_adı": "değişken_değeri"}

```

{“değişken_adı”: “değişken_değeri”}yapısıyla önceki derslerimizde
karşılaşmıştınız. Dolayısıyla bu yapının temel olarak ne işe yaradığını
biliyorsunuz. Hatta bu yapının adının ‘sözlük’ olduğunu da öğrenmiştiniz. İşte
burada, sözlük adlı veri tipinden yararlanarak değişken adları ile değişken
değerlerini eşleştirdik. Böylece aynı şeyleri tekrar tekrar yazmamıza gerek
kalmadı. Ayrıca yukarıdaki örnekte değerleri sırasına göre değil, ismine göre
çağırdığımız için, karakter dizisi içindeki değerlerin sırasını takip etme
zahmetinden de kurtulmuş olduk.

Böylece%yapısının tüm temel ayrıntılarını öğrenmiş olduk. Artık%işaretinin başka yönlerini incelemeye başlayabiliriz.

#### Biçimlendirme Karakterleri

Biraz önce, Python’da eski usul karakter dizisi biçimlendirme yöntemi olan%işareti üzerine en temel bilgileri edindik. Buraya kadar öğrendiklerimiz,
yazdığımız programlarda genellikle yolumuzu yordamımızı bulmamıza yetecektir.
Ama isterseniz şimdi karakter dizisi biçimlendirme konusunu biraz daha
derinlemesine ele alalım. Mesela Python’daki biçimlendirme karakterlerinin neler
olduğunu inceleyelim.

##### s

Önceki örneklerden de gördüğünüz gibi, Python’da biçim düzenleme işlemleri için%sadlı bir yapıdan faydalanıyoruz. Bu yapıyı şöyle bir masaya yatırdığımızda
aslında bu yapının iki parçadan oluştuğunu görebiliriz. Bu parçalar%veskarakterleridir. Burada gördüğümüz parçalardan%sabit,sise değişkendir.
Yani%sabit değerini bazı harflerle birlikte kullanarak, farklı karakter
dizisi biçimlendirme işlemleri gerçekleştirebiliriz.

Biz önceki sayfalarda verdiğimiz örneklerde bu simgeyisharfiyle birlikte
kullandık. Örneğin:

```python
>>> print("Benim adım %s" %"istihza")

```

Bu kodlardakiskarakteri İngilizcestring, yani ‘karakter dizisi’
ifadesinin kısaltmasıdır. Esasında en yaygın çift de budur. Yani etraftaki
Python programlarında yaygın olarak%syapısını görürüz. Ancak Python’da%biçim düzenleyicisiyle birlikte kullanılabilecek tek karaktersdeğildir. Daha
önce de dediğimiz gibi,skarakteristring, yani ‘karakter dizisi’
ifadesinin kısaltmasıdır. Yani aslında%syapısı Python’da özel olarak
karakter dizilerini temsil eder.

Peki bu ne demek oluyor?

Bir karakter dizisi içinde%syapısını kullandığımızda, dışarıda buna karşılık
gelen değerin de bir karakter dizisi veya karakter dizisine çevrilebilecek bir
değer olması gerekir. Python’da her şey bir karakter dizisi olarak temsil
edilebilir. Dolayısıyla bütün işlemlerinizde%işaretiniskarakteri ile
birlikte kullanabilirsiniz. Ama bazı özel durumlarda%işaretinisdışında
başka harflerle birlikte kullanmanız da gerekebilir.

Biz%yapısı ile ilgili verdiğimiz ilk örneklerde bu yapınınskarakteri ile
birlikte kullanılışını gösteren pek çok örnek verdiğimiz için%ilesbirlikteliği üzerinde daha fazla durmayacağız. Bunun yerine,%ile birlikte
kullanılan öteki karakterleri inceleyeceğiz. O halde yola koyulalım.

##### d

Bir önceki başlıkta gördüğümüzsharfi nasıl karakter dizilerini temsil
ediyorsa,dharfi de sayıları temsil eder. İsterseniz küçük bir örnekle
açıklamaya çalışalım durumu:

```python
>>> print("Şubat ayı bu yıl %d gün çekiyor" %28)

Şubat ayı bu yıl 28 gün çekiyor.

```

Gördüğünüz gibi,%işaretiyle birlikte bu defasyerinedharfini
kullandık. Buna uygun olarak da dış tarafta28sayısını kullandık. Peki
yukarıdaki ifadeyi şöyle de yazamaz mıydık?

```python
>>> print("Şubat ayı bu yıl %s gün çekiyor" %28)

```

Elbette yazabilirdik. Bu kod da bize doğru çıktı verecektir. Çünkü daha önce de
dediğimiz gibi,sharfi karakter dizilerini ve karakter dizisine çevrilebilen
değerleri temsil eder. Python’da sayılar karakter dizisine çevrilebildiği için%sgibi bir yapıyı hata almadan kullanabiliyoruz. Ama mesela şöyle bir şey
yazamayız:

```python
>>> print("Şubat ayı bu yıl %d gün çekiyor" %"yirmi sekiz")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: %d format: a number is required, not str

```

Gördüğünüz gibi bu defa hata aldık. Çünküdharfi yalnızca sayı değerleri
temsil edebilir. Bu harfle birlikte karakter dizilerini kullanamayız.

Doğrusunu söylemek gerekirse,dharfi aslında tam sayı (integer) değerleri
temsil eder. Eğer bu harfin kullanıldığı bir karakter dizisinde değer olarak
mesela bir kayan noktalı sayı (float) verirsek, bu değer tamsayıya
çevrilecektir. Bunun ne demek olduğunu hemen bir örnekle görelim:

```python
>>> print("%d" %13.5)

13

```

Gördüğünüz gibi,%difadesi,13.5sayısının ondalık kısmını çıktıda
göstermiyor. Çünküdharfi sadece tamsayıları temsil etme işlevi görüyor.

Burada şöyle bir soru aklınıza gelmiş olabilir: ‘Acaba%difadesi ile hiç
uğraşmasak, bunun yerine her yerde%sifadesini kullansak olmaz mı?’.

Çoğu zaman olur, ama mesela şöyle bir durum düşünün: Yazdığınız programda
kullanıcıdan sadece tam sayı girmesini istiyor olabilirsiniz. Yani mesela
kullanıcının ondalık sayı girmesi halinde, siz bu sayının sadece tam sayı
kısmını almak istiyor olabilirsiniz. Örneğin kullanıcı23.8gibi bir sayı
girmişse, siz bu sayıda ihtiyacınız olan23kısmını almak isteyebilirsiniz.
İşte bu%dişaretinden yararlanarak, kullanıcının girdiği ondalık sayının
sadece tam sayı kısmını çekebilirsiniz:

```python
sayı = input("sayı: ")

print("%d" %float(sayı))

```

Elbette Python’da bir ondalık sayının sadece taban kısmını almanın başka
yöntemleri de vardır. Ama yukarıda verdiğimiz örnek bir ondalık sayının sadece
tabanını almanın gayet basit ve etkili bir yoludur.

%syapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme tekniklerini%dile de kullanabilirsiniz. Örneğin:

```python
>>> print("|%7d|" %23)

| 23|

>>> print("|%-7d|" %23)

|23 |

```

veya:

```python
>>> print("%(sayı)d" % {"sayı": 23})

23

```

%syapısına ek olarak, sayının kaplayacağı alandaki boşluklara birer0da
yerleştirebilirsiniz:

```python
>>> print("%05d" %23)

00023

```

…veya:

```python
>>> print("%.5d" %23)

00023

```

Hatta hem sayının kaplayacağı boşluk miktarını hem de bu boşlukların ne
kadarının0ile doldurulacağını da belirleyebilirsiniz:

```python
>>> print("%10.5d" %23)

 00023

```

Burada23sayısının toplam10boşlukluk bir yer kaplamasını ve bu10adet
boşluğun5tanesinin içine0sayılarının ve23sayısının sığdırılmasını
istedik.

Bir de şuna bakalım:

```python
>>> print("%010.d" %23)

0000000023

```

Burada ise23sayısının toplam10boşlukluk bir yer kaplamasını ve bu10adet boşluğa23sayısı yerleştirildikten sonra arta kalan kısmın0sayıları
ile doldurulmasını istedik.

Bu arada, son örnekte yaptığımız şeyi, daha önce öğrendiğimizzfill()metoduyla da yapabileceğimizi biliyorsunuz:

```python
>>> "23".zfill(10)

'0000000023'

```

Yukarıdaki kullanımlar ilk bakışta gözünüze karışık görünmüş olabilir. Ama eğer
yeterince pratik yaparsanız, aslında bu biçimlerin hiç de o kadar karmaşık
olmadığını anlarsınız. İsterseniz bu biçimlerle neler yapabileceğimizi şöyle bir
kısaca tarif edelim:

dharfi,%işaretiyle birlikte kullanıldığında sayıları temsil eder. Bu iki
karakterin en temel kullanımı şöyledir:

```python
>>> "%d" %10

'10'

```

dharfi ile%işareti arasına bir pozitif veya negatif sayı getirerek,
temsil edilecek sayının toplam kaç boşluktan oluşan bir alan içine
yerleştirileceğini belirleyebiliyoruz:

```python
>>> "%5d" %10

' 10'

```

Burada10sayısını toplam5boşlukluk bir alan içine yerleştirdik.
Gördüğünüz gibi, bir pozitif sayı kullandığımızda, sayımız kendisine ayrılan
alan içinde sağa yaslanıyor. Eğer bu sayıyı sola yaslamak istersek negatif
sayılardan yararlanabiliriz:

```python
>>> "%-5d" %10

'10 '

```

Eğer sağa yasladığımız bir sayının sol tarafını sıfırla doldurmak istersek,
hizalama miktarını belirtmek için kullandığımız sayının soluna bir sıfır
ekleyebiliriz:

```python
>>> "%05d" %10

'00010'

```

Aynı etkiyi şu şekilde de elde edebilirsiniz:

```python
>>> "%.5d" %10

'00010'

```

Eğer nokta işaretinden önce bir sayı belirtirseniz, karakter dizisi o
belirttiğiniz sayı kadar sağa yaslanacaktır. Yani:

```python
>>> "%10.5d" %10

' 00010'

```

… veya sola:

```python
>>> "%-10.5d" %10

'00010 '

```

Her iki şekilde de, karakter dizisini toplam10boşluktan oluşan bir alan
içine yerleştirmiş olduk. Bu toplam alanın5boşlukluk kısmı sayının kendisi
ve sayının soluna gelecek0’lar arasında paylaştırıldı.

Gördüğünüz gibi, biçimlendirme mantığının aslında o kadar da korkulacak bir yanı
yok. Kendi kendinize yukarıdakilere benzer örnekler yaparak bu yapıyı daha iyi
bir şekilde anlamaya çalışabilirsiniz.

##### i

Bu harf deinteger, yani ‘tam sayı’ kelimesinin kısaltmasıdır. Kullanım ve
işlev olarak,dharfinden hiç bir farkı yoktur.

##### o

Bu harfoctal(sekizli) kelimesinin kısaltmasıdır. Adından da anlaşılacağı
gibi, sekizli düzendeki sayıları temsil eder. Dolayısıyla bu harfi kullanarak
onlu düzendeki bir sayıyı sekizli düzendeki karşılığına dönüştürebilirsiniz.
Örneğin:

```python
>>> print("%i sayısının sekizli düzendeki karşılığı %o sayısıdır." %(10, 10))

10 sayısının sekizli düzendeki karşılığı 12 sayısıdır.

```

> **Not**
> %dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%oile de kullanabilirsiniz.

Not

%dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%oile de kullanabilirsiniz.

##### x

Bu harfhexadecimal, yani onaltılı düzendeki sayıları temsil eder.
Dolayısıyla bu harfi kullanarak onlu düzendeki bir sayıyı onaltılı düzendeki
karşılığına çevirebilirsiniz:

```python
>>> print("%i sayısının onaltılı düzendeki karşılığı %x sayısıdır." %(20, 20))

20 sayısının onaltılı düzendeki karşılığı 14 sayısıdır.

```

Buradaki ‘x’ küçük harf olarak kullanıldığında, onaltılı düzende harfle
gösterilen sayılar da küçük harfle temsil edilecektir:

```python
>>> print("%i sayısının onaltılı düzendeki karşılığı %x sayısıdır." %(10, 10))

10 sayısının onaltılı düzendeki karşılığı a sayısıdır.

```

> **Not**
> %dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%xile de kullanabilirsiniz.

Not

%dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%xile de kullanabilirsiniz.

##### X

Bu da tıpkıxharfinde olduğu gibi, onaltılı düzendeki sayıları temsil eder.
Ancak bunun farkı, harfle gösterilen onaltılı sayıları büyük harfle temsil
etmesidir:

```python
>>> print("%i sayısının onaltılı düzendeki karşılığı %X sayısıdır." %(10, 10))

10 sayısının onaltılı düzendeki karşılığı A sayısıdır.

```

> **Not**
> %dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%Xile de kullanabilirsiniz.

Not

%dyapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%Xile de kullanabilirsiniz.

##### f

Python’da karakter dizilerini biçimlendirirkensharfinden sonra en çok
kullanılan harffharfidir. Bu harf İngilizce’dekifloat, yani ‘kayan
noktalı sayı’ kelimesinin kısaltmasıdır. Adından da anlaşılacağı gibi, karakter
dizileri içindeki kayan noktalı sayıları temsil etmek için kullanılır.

```python
>>> print("Dolar %f TL olmuş..." %1.4710)

Dolar 1.471000 TL olmuş...

```

Bu çıktı sizi biraz şaşırtmış olabilir. Çünkü gördüğünüz gibi, çıktıda bizim
eklemediğimiz haneler var.

Python’da bir karakter dizisi içindeki sayıyı%fyapısı ile kayan noktalı
sayıya çevirdiğimizde noktadan sonra öntanımlı olarak6hane yer alacaktır.
Yani mesela:

```python
>>> print("%f" %10)

10.000000

```

Gördüğünüz gibi, gerçekten de10tam sayısı%fyapısı ile kayan noktalı
sayıya dönüştürüldüğünde noktadan sonra6adet sıfıra sahip oluyor.

Başka bir örnek daha verelim:

```python
>>> print("%f"%23.6)

23.600000

```

Bu örnek,%fyapısının, kayan noktalı sayıların noktadan sonraki hane sayısını
da6’ya tamamladığını gösteriyor. Ama elbette biz istersek, daha önce
öğrendiğimiz teknikleri kullanarak, noktadan sonra kaç hane olacağını
belirleyebiliriz:

```python
>>> print("%.2f" % 10)

10.00

```

%fyapısında,%ilefarasına.2gibi bir ifade yerleştirerek noktadan
sonra2hane olmasını sağladık.

> **Not**
> Daha önce gösterdiğimiz ileri düzey biçimlendirme tekniklerini%file de kullanabilirsiniz.

Not

Daha önce gösterdiğimiz ileri düzey biçimlendirme tekniklerini%file de kullanabilirsiniz.

##### c

Bu harf de Python’daki önemli karakter dizisi biçimlendiricilerinden biridir. Bu
harf tek bir karakteri temsil eder:

```python
>>> print("%c" %"a")

a

```

Ama:

```python
>>> print("%c" %"istihza")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: %c requires int or char

```

Gördüğünüz gibi,charfi sadece tek bir karakteri kabul ediyor. Karakter
sayısı birden fazla olduğunda bu komut hata veriyor.

charfinin bir başka özelliği de ASCII tablosunda sayılara karşılık gelen
karakterleri de gösterebilmesidir:

```python
>>> print("%c" %65)

A

```

ASCII tablosunda 65 sayısı ‘A’ harfine karşılık geldiği için yukarıdaki komutun
çıktısı ‘A’ harfini gösteriyor. Eğer istersenizcharfini kullanarak bütün
ASCII tablosunu ekrana dökebilirsiniz:

```python
>>> for i in range(128):
... print("%s ==> %c" %(i, i))

```

> **Not**
> %syapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%cile de kullanabilirsiniz.

Not

%syapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme
tekniklerinin tamamını%cile de kullanabilirsiniz.

Böylece Python’da%işareti kullanarak nasıl biçimlendirme yapabileceğimizi
öğrenmiş olduk. Dilerseniz pratik olması açısından, karakter dizisi
biçimlendiricilerinin kullanımını gösteren bir örnek vererek bu bölümü
noktalayalım.

Dikkatlice inceleyin:

```python
for sıra, karakter in enumerate(dir(str)):
 if sıra % 3 == 0:
 print("\n", end="")
 print("%-20s" %karakter, end="")

```

Burada, gördüğünüz gibi, karakter dizisi metotlarını bir tablo görünümü içinde
ekrana yazdırdık. Şu satırlar yardımıyla tablodaki sütun sayısını3olarak
belirledik:

```python
if sıra % 3 == 0:
 print("\n", end="")

```

Burada modülüs işlecini nasıl kullandığımıza çok dikkat edin.sıradeğişkeninin değerini3’e böldüğümüzde kalan değerin0olduğu her sayıda
satır başına geçiyoruz. Böylece her3.sütunda bir satır aşağı geçilmiş
oluyor.

Bununla ilgili bir örnek daha verelim:

```python
for i in range(20):
 print("%5d%5o%5x" %(i, i, i))

```

Burada0’dan20’ye kadar olan sayıların onlu, sekizli ve onaltılı düzendeki
karşılıklarını bir tablo görünümü içinde ekrana çıktı verdik. Bu arada, eğer
isterseniz yukarıdaki kodları şöyle de yazabileceğinizi biliyorsunuz:

```python
for i in range(20):
 print("%(deger)5d%(deger)5o%(deger)5x" %({"deger": i}))

```

Burada da, tablomuzu biçimlendirmek için ‘sözlük’ adını verdiğimiz yapıdan
yararlandık.

### format() Metodu ile Biçimlendirme (Yeni Yöntem)

En başta da söylediğimiz gibi,%işaretini kullanarak karakter dizisi
biçimlendirme eskide kalmış bir yöntemdir. Bu yöntem ağırlıklı olarak Python’ın
2.x sürümlerinde kullanılıyordu. Her ne kadar bu yöntemi Python’ın 3.x
sürümlerinde de kullanmak mümkün olsa da yeni yazılan kodlarda bu yöntem yerine
biraz sonra göreceğimizformat()metodunu kullanmak çok daha akıllıca
olacaktır. Çünkü muhtemelen%ile biçimlendirme yöntemi, ileriki bir Python
sürümünde dilden tamamen kaldırılacak. Bu yüzden bu eski metoda fazla bel
bağlamamak gerekiyor.

Daha önceki derslerimizde verdiğimiz örnekler sayesindeformat()metodunun
temel olarak nasıl kullanılacağını biliyoruz. Ama isterseniz biz yine de
bütünlük açısındanformat()metodunun temel kullanımını burada tekrar ele
alalım.

format()metodunu en basit şekilde şöyle kullanıyoruz:

```python
>>> print("{} ve {} iyi bir ikilidir!".format("Django", "Python"))

Django ve Python iyi bir ikilidir!

```

Gördüğünüz gibi, eski yöntemdeki%işaretine karşılık, yeni yöntemde{}işaretini kullanıyoruz.

Çok basit bir örnek daha verelim:

```python
isim = input("İsminiz: ")
print("Merhaba {}. Nasılsın?".format(isim))

```

Elbette bu örneği şu şekilde de yazabilirdik:

```python
isim = input("İsminiz: ")
print("Merhaba", isim + ".", "Nasılsın?")

```

Buradaformat()metodunu ve biçim düzenleyicileri hiç kullanmadan, sadece
karakter dizilerini birleştirerek istediğimiz çıktıyı elde ettik. Ama siz de
görüyorsunuz; karakter dizilerini birleştirmekle uğraşacağımızaformat()metodunu kullanmak hem daha pratiktir, hem de bu şekilde yazdığımız kodlar daha
okunaklı olur.

Yukarıdaki örnekteformat()metodunu tek bir parametre ile birlikte
kullandık (isim). Bu parametre (tıpkı eski%işaretinde olduğu gibi),
karakter dizisi içindeki{}işaretine karşılık geliyor.

Bu konuyu daha iyi anlayabilmek için bir örnek daha verelim:

```python
kalkış = input("Kalkış yeri: ")
varış = input("Varış yeri: ")
isim_soyisim = input("İsim ve soyisim: ")
bilet_sayısı = input("Bilet sayısı: ")

print("""{} noktasından {} noktasına, 14:30 hareket saatli
sefer için {} adına {} adet bilet ayrılmıştır!""".format(kalkış,
 varış,
 isim_soyisim,
 bilet_sayısı))

```

Gördüğünüz gibi,{}işaretleri karakter dizisi içinde bir ‘yer tutma’ görevi
görüyor. Tutulan bu yerlere nelerin geleceğiniformat()metodunun
parametreleri vasıtasıyla belirliyoruz.

Elbette eğer isterseniz yukarıdaki örneği şu şekilde de yazabilirsiniz:

```python
kalkış = input("Kalkış yeri: ")
varış = input("Varış yeri: ")
isim_soyisim = input("İsim ve soyisim: ")
bilet_sayısı = input("Bilet sayısı: ")

metin = "{} noktasından {} noktasına, 14:30 hareket saatli \
sefer için {} adına {} adet bilet ayrılmıştır!"

print(metin.format(kalkış, varış, isim_soyisim, bilet_sayısı))

```

Ancak yaygın olarak kullanılan yöntem, karakter dizisini herhangi bir değişkene
atamadan, doğrudanformat()metoduna bağlamaktır. Elbette hangi yöntem
kolayınıza geliyorsa onu tercih etmekte özgürsünüz. Ama özellikle
biçimlendirilecek karakter dizisinin çok uzun olduğu durumlarda, yukarıdaki
gibi, karakter dizisini önce bir değişkene atayıp, sonra da bu değişken üzerineformat()metodunu uygulamak daha mantıklı olabilir.

Verdiğimiz bu örneği, her zaman olduğu gibi,format()metoduna başvurmadan
yazmak da mümkündür:

```python
kalkış = input("Kalkış yeri: ")
varış = input("Varış yeri: ")
isim_soyisim = input("İsim ve soyisim: ")
bilet_sayısı = input("Bilet sayısı: ")

print(kalkış, "noktasından", varış, "noktasına, 14:30 hareket saatli \
sefer için", isim_soyisim, "adına", bilet_sayısı, "adet bilet ayrılmıştır!")

```

Tıpkı daha önce verdiğimiz örnekte olduğu gibi, burada daformat()metodunu
kullanmak karakter dizilerini birleştirme yöntemine göre daha mantıklı ve kolay
görünüyor. Ayrıca bir karakter dizisi karmaşıklaştıkça bu karakter dizisini
sadece karakter dizisi birleştirme yöntemleriyle biçimlendirmeye çalışmak bir
süre sonra tam bir eziyet halini alabilir. O yüzden, ‘Benformat()metodunu
öğrenmesem de olur,’ diye düşünmeyin sakın. Mesela şöyle bir programıformat()metodu kullanmadan yazmaya çalışmak hiç akıl kârı değildir:

```python
kodlama = "utf-8"
site_adı = "Python Programlama Dili"
dosya = open("deneme.html", "w", encoding=kodlama)
içerik = """
<html>

<head>
 <meta http-equiv="Content-Type" content="text/html; charset={}" />
 <title>{}</title>
</head>

<body>
 <h1>istihza.com web sitesine hoş geldiniz!</h1>
 <p><b>{}</b> için bir Türkçe belgelendirme projesi...</p>
</body>

</html>
"""

print(içerik.format(kodlama, site_adı, site_adı), file=dosya)

dosya.close()

```

Burada şu satırın bir kısmı hariç bütün kodları anlayabilecek düzeydesiniz:

```python
dosya = open("deneme.html", "w", encoding=kodlama)

```

Bu kodlarla,deneme.htmladlı bir dosya oluşturduğumuzu biliyorsunuz. Daha
önceki derslerimizde birkaç kez gördüğümüzopen()fonksiyonu Python’da dosya
oluşturmamıza imkan veriyor. Bu fonksiyon içinde kullandığımız üç parametrenin
ilk ikisi size tanıdık gelecektir. İlk parametre dosyanın adını, ikinci
parametre ise bu dosyanın hangi kipte açılacağını gösteriyor. Burada
kullandığımız“w”parametresideneme.htmladlı dosyanın yazma kipinde
açılacağını gösteriyor. Bu fonksiyona atadığımızencodingparametresi ise
oluşturulacak dosyanın kodlama biçimini gösteriyor. Bu da Türkçe karakterlerin
dosyada düzgün görüntülenebilmesi açısından önem taşıyor.

Küme parantezlerini, yukarıdaki örneklerde görüldüğü şekilde içi boş olarak
kullanabilirsiniz. Böyle bir durumda Python, karakter dizisi içindeki küme
parantezleriyle, karakter dizisi dışındaki değerleri teker teker ve sırasıyla
eşleştirecektir. Ama isterseniz küme parantezleri içine birer sayı yazarak,
karakter dizisi dışındaki değerlerin hangi sırayla kullanılacağını
belirleyebilirsiniz. Örneğin:

```python
>>> "{0} {1}".format("Fırat", "Özgül")

'Fırat Özgül'

```

Küme parantezleri içinde sayı kullanabilme imkanı sayesinde değerlerin sırasını
istediğiniz gibi düzenleyebilirsiniz:

```python
>>> "{1} {0}".format("Fırat", "Özgül")

'Özgül Fırat'

```

Hatta bu özellik sayesinde değerleri bir kez yazıp, birden fazla sayıda tekrar
edebilirsiniz:

```python
>>> "{0} {1} ({1} {0})".format("Fırat", "Özgül")

'Fırat Özgül (Özgül Fırat)'

```

Dolayısıyla,{}işaretleri içinde öğelerin sırasını da belirterek, biraz önce
verdiğimizHTMLsayfası örneğini şu şekilde yazabilirsiniz:

```python
kodlama = "utf-8"
site_adı = "Python Programlama Dili"
dosya = open("deneme.html", "w", encoding=kodlama)
içerik = """
<html>

<head>
 <meta http-equiv="Content-Type" content="text/html; charset={0}" />
 <title>{1}</title>
</head>

<body>
 <h1>istihza.com web sitesine hoş geldiniz!</h1>
 <p><b>{1}</b> için bir Türkçe belgelendirme projesi...</p>
</body>

</html>
"""

print(içerik.format(kodlama, site_adı), file=dosya)

dosya.close()

```

Gördüğünüz gibi, öğelerin sıra numarasını belirtmemiz sayesinde, karakter dizisi
içinde iki kez ihtiyaç duyduğumuzsite_adıadlı değişkeniformat()metodu
içinde iki kez yazmak zorunda kalmadık.

Yukarıdaki örnekler bize,format()metodunun parametrelerine sıra numarasına
göre erişebileceğimizi gösteriyor. Biz aynı zamanda bu metodun parametrelerine
isme göre de erişebiliriz. Çok basit bir örnek:

```python
print("{dil} dersleri".format(dil="python"))

```

Bu yöntemi kullanarak, aynı değişkeni birkaç farklı yerde kullanabilirsiniz:

```python
sayfa = """
<html>

<head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
 <title>{konu}</title>
</head>

<body>
 <h1>istihza.com web sitesine hoş geldiniz!</h1>
 <p><b>{konu}</b> için bir Türkçe belgelendirme projesi...</p>
</body>

</html>
"""

print(sayfa.format(konu="Python Programlama Dili"))

```

format()metodunun yetenekleri yukarıda gösterdiğimiz şeylerle sınırlı
değildir. Tıpkı eski biçimlendirme yönteminde olduğu gibi,{}işaretleri
arasında bazı sayılar kullanarak, karakter dizileri üzerinde hizalama işlemleri
de yapabiliriz.

Dikkatlice bakın:

```python
>>> print("{:>15}".format("istihza"))

 istihza

```

Bu gösterim gözünüze oldukça yabancı ve karışık gelmiş olabilir. Ama aslında hiç
de öyle anlaşılmaz bir yanı yoktur bu kodların. Gördüğünüz gibi, burada
öncelikle:adlı bir işaretten yararlanıyoruz. Bu işaretin ardından>adlı
başka bir işaret görüyoruz. Son olarak da15sayısını kullanıyoruz.

:işareti, bir biçimlendirme işlemi yapacağımızı gösteriyor.>işareti ise
bu biçimlendirmenin bir hizalama işlemi olacağını haber veriyor. En sondaki15sayısı ise bu hizalama işleminin 15 karakterlik bir alan ile ilgili olduğunu
söylüyor. Bu şekilde karakter dizisini15karakterlik bir alan içine
yerleştirip karakter dizisini sağa yasladık. Yukarıdaki çıktıyı daha iyi
anlayabilmek için kodları şöyle de yazabilirsiniz:

```python
>>> print("|{:>15}|".format("istihza"))

| istihza|

```

Gördüğünüz gibi, karakter dizimiz, kendisine ayrılan15karakterlik alan
içinde sağa yaslanmış vaziyette duruyor.

Eğer aynı karakter dizisini sola yaslamak isterseniz şöyle bir şey
yazabilirsiniz:

```python
>>> print("|{:<15}|".format("istihza"))

|istihza |

```

Bu defa<adlı işaretten yararlandığımıza dikkat edin.

Yukarıdaki yöntemi kullanarak, karakter dizilerini sola veya sağa yaslamanın
yanısıra, kendilerine ayrılan alan içinde ortalayabilirsiniz de:

```python
>>> print("|{:^15}|".format("istihza"))

| istihza |

```

Gördüğünüz gibi, python3 ile gelenformat()metodunu hizalama işlemleri için
kullanırken üç farklı işaretten yararlanıyoruz:
| > | sağa yaslama |
| --- | --- |
| < | sola yaslama |
| ^ | ortalama |

>

sağa yaslama

<

sola yaslama

^

ortalama

Yukarıdaki işaretler, yaptıkları işi çağrıştırdıkları için, bunları akılda
tutmak çok zor olmasa gerek. Mesela örnek olması açısından, eski biçimlendirme
yönteminin son kısmında verdiğimiz şu örneği:

```python
for sıra, karakter in enumerate(dir(str)):
 if sıra % 3 == 0:
 print("\n", end="")
 print("%-20s" %karakter, end="")

```

… bir de yeniformat()metoduyla yazalım:

```python
for sıra, karakter in enumerate(dir(str)):
 if sıra % 3 == 0:
 print("\n", end="")
 print("{:<20}".format(karakter), end="")

```

Bu örneği inceleyerek, eski ile yeni yöntem arasında nelerin değiştiğini, neyin
neye karşılık geldiğini görebilirsiniz.

#### Biçimlendirme Karakterleri

Hatırlarsanız Python2’de geçerli olan eski biçimlendirme yönteminde%karakteri ile bazı harfleri birlikte kullanarak karakter dizileri üzerinde
biçimlendirme ve dönüştürme işlemleri yapabiliyorduk. Aynı şey Python3 ile
birlikte gelen buformat()metodu için de geçerlidir. Yani benzer harfleri
kullanarakformat()metodu ile de karakter dizileri üzerinde biçimlendirme
ve dönüştürme işlemleri yapabiliriz.

format()metodu ile birlikte şu harfleri kullanabiliyoruz:

##### s

Bu harf karakter dizilerini temsil eder.

Yalnız bu biçimlendirici karakterlerin{}işaretleri içindeki kullanımı ilk
bakışta gözünüze biraz karışık gelebilir:

```python
>>> print("{:s}".format("karakter dizisi"))

karakter dizisi

```

Bu arada, harfleri{}yapısının içinde nasıl kullandığımıza dikkat edin.
Gördüğünüz gibi biçimlendirme karakterini kullanırken, karakterin sol tarafına
bir adet:işareti de yerleştiriyoruz. Bir örnek verelim:

```python
print("{:s} ve {:s} iyi bir ikilidir!".format("Python", "Django"))

```

Yalnız,sharfi karakter dizilerini temsil ettiği için,{}işaretleri
arasında bu harfi kullandığımızda,format()metodunun alabileceği
parametreyi karakter dizisiyle sınırlandırmış oluruz. Dolayısıyla bu harfi
kullandıktan sonraformat()metodu içinde sadece karakter dizilerini
kullanabiliriz. Eğer sayı kullanırsak Python bize bir hata mesajı
gösterecektir:

```python
>>> print("{:s}".format(12))

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: Unknown format code 's' for object of type 'int'

```

Bu yüzden, eğer amacınızformat()metoduna parametre olarak karakter dizisi
vermekse,{}işaretleri içinde herhangi bir harf kullanmamak daha akıllıca
olabilir:

```python
print("{} ve {} iyi bir ikilidir!".format("Python", "Django"))

```

##### c

Bu harf0ile256arası sayıların ASCII tablosundaki karşılıklarını temsil
eder:

```python
>>> print("{:c}".format(65))

A

```

##### d

Bu harf sayıları temsil eder:

```python
>>> print("{:d}".format(65))

65

```

Eğer sayı dışında bir değer kullanırsanız Python size bir hata mesajı gösterir:

```python
>>> print("{:d}".format("65"))

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: Unknown format code 'd' for object of type 'str'

```

##### o

Bu harf onlu düzendeki sayıları sekizli düzendeki karşılıklarına çevirir:

```python
>>> print("{:o}".format(65))

101

```

##### x

Bu harf onlu düzendeki sayıları onaltılı düzendeki karşılıklarına çevirir:

```python
>>> print("{:x}".format(65))

41

```

##### X

Tıpkıxharfinde olduğu gibi, bu harf de onlu düzendeki sayıları onaltılı
düzendeki karşılıklarına çevirir:

```python
>>> "{:X}".format(65)

'41'

```

PekixileXharfi arasında ne fark var? Fark şudur:x; onaltılı düzende
harfle gösterilen sayıları küçük harf şeklinde temsil eder.Xişareti bu
sayıları büyük harf şeklinde temsil eder. Bu ikisi arasındaki farkı daha net
görmek için şöyle bir kod yazabilirsiniz:

```python
>>> for i in range(20):
... print("{:x}{:10X}".format(i, i))
...
0 0
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
a A
b B
c C
d D
e E
f F
10 10
11 11
12 12
13 13

```

Gördüğünüz gibi gerçekten dexharfi onaltılı düzende harflerle gösterilen
sayıları küçük harf olarak;Xharfi ise büyük harf olarak temsil ediyor.

##### b

Bu işaret, onlu düzendeki sayıları ikili düzendeki karşılıklarına çevirir:

```python
>>> "{:b}".format(2)

'10'

```

##### f

Bu işaret, eski biçimlendirme yöntemini anlatırken gösterdiğimizfişaretiyle
benzer bir işleve sahiptir:

```python
print("{:.2f}".format(50))

50.00

```

##### ,

:işaretini,işareti (basamak ayracı) ile birlikte kullanarak, sayıları
basamaklarına ayırabilirsiniz:

```python
>>> "{:,}".format(1234567890)

'1,234,567,890'

```

Böylece Python’da karakter dizisi biçimlendirmenin hem eski hem de yeni
yöntemini, şu ana kadarki Python bilgimiz elverdiği ölçüde ayrıntılı bir şekilde
incelemiş olduk. Buradaki bilgileri kullanarak bol bol örnek yapmak bu konuyu
daha iyi anlamanıza yardımcı olacaktır.

## f-string

Daha önceki bölümlerdeformat()fonksiyonuyla karakter dizilerini nasıl biçimlendirebileceğimizi görmüştük. 3.6 sürümü ile Python’a eklenen f-string yapısı da buna benzer bir şekilde çalışıyor. Öncelikle format() fonksiyonunu nasıl kullandığımızı hatırlayalım:

```python
isim = 'Buğra'
print('Selam {kime}!'.format(kime=isim))

```

Burada öncelikleisimadında bir değişken tanımladık ve bu değişkeneBuğradeğerini atadık. Daha sonra da‘Selam {isim}!’diye bir karakter dizisini ekrana yazdırdık. format() fonksiyonunu kullanarak Python’a yazdırma işlemini yapmadan önce karakter dizimizdekikimekısımınıisimdeğişkeninin değeri ile değiştirmesi gerektiğini söyledik.

format() fonksiyonumuz kendisine verdiğimiz değerleri kapsama alanı içerisinde uygun yerlere yerleştirir. Hatırlarsanız format() fonksiyonunu ilgilendiren kısımları süslü parantezlerin içine yazıyorduk. Yukarıdaki örneği şu şekilde de yapabiliriz:

```python
isim = 'Buğra'
print('Selam {}!'.format(isim))

```

Bu sefer format() fonksiyonuna belirli bir yer göstermediğimiz için sırasıyla ilgili alanlara verdiğimiz parametreleri dolduracak. Zaten bir parametre ve bir alan olduğu için yukarıdaki örnekle aynı çıktıyı alacağız. format() fonksiyonunu bu kadar hatırlamak yeter, hadi f-string’lere geçelim!

### Kullanım

String nedir hepimiz biliyoruz, Türkçeye karakter dizisi olarak çeviriyoruz. Bu yapıya da f-string diyoruz çünkü bu yapıyı kullanmak istediğimiz stringin (karakter dizisinin) başınafveyaFekliyoruz. Yani bir ön ek ekleyerek Python’a artık onun normal, sıradan bir karakter dizisi olmadığını ve bir ön işlemden geçmesi gerektiğini belirtiyoruz:

```python
"Selam Dünya!" # Normal bir karakter dizisi
f"Selam Dünya!" # Bu artık bir f-string

```

> **Not**
> f-string’leri kullanabilmeniz için Python 3.6 ya da daha yeni bir sürüm kullanmamız gerektiğini unutmayalım!

Not

f-string’leri kullanabilmeniz için Python 3.6 ya da daha yeni bir sürüm kullanmamız gerektiğini unutmayalım!

Bu örnekte f-string’imizin normal bir karakter dizisinden farkı yok gibi görünüyor. Aslında şuanlık bir farkı yok. Çünkü bizf-string’in özelliklerini henüz kullanmadık. Yukarıda format() fonksiyonu için yazdığımız örneği bir de f-string için yazalım:

```python
>>> isim = 'Buğra'
>>> print(f'Selam {isim}!')

```

Bu örneği de çalıştırdığınızda yukarıdaki örneklerin çıktılarıyla aynı çıktıyı verdiğini göreceksiniz. Ama çok daha düzenli bir görünümle elde ettik bu sefer aynı çıktıyı. format() fonksiyonuna ilgileneceği kısımları, işlem yapacağı kısımları, süslü parantezler ile belirttiğimizi biliyoruz. f-string için de aynı şey geçerli ancak ufak bir farkla. Artık harici bir işlem yapılıp karakter dizimiz düzenlenmiyor, işlemler doğrudan karakter dizimiz içinde gerçekleştirilip yerini kendi alıyor!

Bir örnek daha hazırlayalım ve üzerinde konuşalım:

```python
>>> isim = 'Buğra'
>>> yas = 18
>>> f'Onun adı {isim} ve o {yas} yaşında.'
'Onun adı Buğra ve o 18 yaşında.'

```

Aynı örneği format() fonksiyonu ile de yazıp arasındaki farka bakalım:

```python
>>> isim = 'Buğra'
>>> yas = 18
>>> "Onun adı {} ve o {} yaşında.".format(isim, yas)
'Onun adı Buğra ve o 18 yaşında.'

```

Yukarıdaki kodu en basit haliyle değişken isimleri kullanmadan yazdım, yani değişkenleri sırasıyla ilgili yerlere yerleştirecek. Buna rağmen f-string örneğimizdekinden çok daha uzun oldu ve okunabilirlik azaldı.

Aynı zamanda f-string’lerin içinde Python işlemleri de yapabiliriz:

```python
>>> birinci_rakam = 5
>>> ikinci_rakam = 3
>>> f'Rakamların toplamı {birinci_rakam + ikinci_rakam} eder.'
'Rakamların toplamı 8 eder.'

```

Hadi sadece toplama işlemi yapan bir hesap makinesi yapalım:

```python
birinci_sayi = int(input('Birinci sayıyı girin: '))
ikinci_sayi = int(input('İkinci sayıyı girin: '))

print(f'Sayıların toplamı {birinci_sayi + ikinci_sayi} eder.')

```

Kullanıcının girdiği sayıları toplayan bir hesap makinesi yaptık. Az önce f-string’lerin içinde Python kodu yazabildiğimizi öğrenmiştik. Bu bilgimizi de kullanıp bu basit programı daha güncel hale getirelim:

```python
>>> f'Sayıların toplamı { int(input("Birinci sayıyı girin: ")) + int(input("İkinci sayıyı girin: ")) } eder.'
Birinci sayıyı girin: 10
İkinci sayıyı girin: 7
'Sayıların toplamı 17 eder.'

```

Kullanıcıdan girdileri f-string’in içinde alarak tek satırlık bir hesap makinesi yazmış olduk.

> **Not**
> f-string’in içinde Python kodu yazmak her zaman en iyi yol olmayabilir.

Not

f-string’in içinde Python kodu yazmak her zaman en iyi yol olmayabilir.

### f-string Formatlama Özellikleri

f-string ifadelerinde süslü parantezler ({}) yazılan ifadenin bir operatörüdür.
f-string içerisinde süslü parantez yazabilmek için genel kaçış karakteri olan ters eğik çizgi (\) yerine{veya}parantezi 2 defa eklenir:

```python
>>> fstring = "f-string"
>>> f"{{ {fstring}: f'{{ifade}}' şeklinde kullanılır. }}"
"{ f-string: f'{ifade}' şeklinde kullanılır. }"

```

Formatlanacak ifadeden sonra=işareti eklenerek değişken adı ile birlikte sahip olduğu değerinreprhali elde edilebilir.printile debug edildiği durumlarda pratik bir şekilde kullanılabilir:

```python
>>> kaynak = "Python İstihza"
>>> yıl = "2022"
>>> f"{kaynak=} {yıl=}"
kaynak='Python İstihza' yıl='2022'

```

f-stringile formatlama yapılırken yazılan ifadeden sonra eklenen:’dan sonra ek formatlama işlemleri gerçekleştirilebilir.

stringmetodlarında anlatılancenter,ljust,rjust,zfillmetodlarının f-string içerisinde:işaretinden sonra karakter uzunluğu yazılarak, belirtilen karakter alanında hizalama yapılabilir:

```python
>>> istihza = "Python Istihza"
>>> f"{istihza:^30}" # "istihza".center(30)
' Python Istihza '
>>> f"{istihza:-^30}" # "istihza".center(30, '-')
'--------Python Istihza--------'
>>> f"{istihza:30}" # "istihza".ljust(30)
'Python Istihza '
>>> f"{istihza:>30}" # "istihza".just(30)
' Python Istihza'
>>> f"{istihza:>030}" # "istihza".zfill(30)
'0000000000000000Python Istihza'

```

> **Not**
> Etkileşimli kabuk (interactive shell) içinde çıktıları elde etmek için print kullanımasına ihtiyaç yoktur.

Not

Etkileşimli kabuk (interactive shell) içinde çıktıları elde etmek için print kullanımasına ihtiyaç yoktur.

f-stringve.formatiçin genel notasyon şu şekildedir:

```python
[[dolgu_karakteri]hizalama][işaret][#][0][genişlik][grup_karakteri][.ondalık][veri_tıpı]

dolgu_karakteri : <her hangi bir karakter>
hizalama : "<" | ">" | "^" | "="
işaret : "+" | "-" | " " (yalnızca sayı tipi)
genişlik : pozitif sayı
grup_karakteri : "_" | "," (yalnızca sayı tipi)
ondalık : pozitif sayı (yalnızca sayı tipi)
veri_tıpı : "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"

```

Yukarıda verilen örneklerden birini kısaca açıklamak gerekirse:

```python
f"{istihza:-^30}"
dolgu_karakteri : -
hizalama : ^
genişlik : 30

```

Sayı formatlama örnekleri

```python
>>> sayı = 123
>>> f"{sayı:>6}"
' 123'
>>> f"{sayı:0>+6}"
'00+123'
>>> f"{sayı:0=+6}"
'+00123'
>>> f"Binary: {sayı:b} | Octal: {sayı:o} | Hexadecimal: {sayı:x}"
'Binary: 1111011 | Octal: 173 | Hexadecimal: 7b'
>>> f"Binary: {sayı:#b} | Octal: {sayı:#o} | Hexadecimal: {sayı:#x}"
'Binary: 0b1111011 | Octal: 0o173 | Hexadecimal: 0x7b'

>>> ondalık = 0.123
>>> f"{ondalık:.2f}" # f | F ondalık formatlama
'0.12'
>>> f"{ondalık:.5f}"
'0.12300'
>>> f"{ondalık:.5g}" # g | G fazla sıfırlar dahil edilmez
'0.123'

>>> sayı = 123456
>>> f"{sayı:_}"
'123_456'
>>> f"{sayı:-^15_}"
'----123_456----'
>>> f"{sayı:,}"
'123,456'

>>> işlem = 1 / 12
>>> f"{işlem:.2%}" # Sonucun 100 ile çarpılmış halini yüzde olarak çıktı verir
'8.33%'

```

Formatlama için kullanılan operatörler değişken ile kullanılması durumunda değişkenlerin{}içine yazılması gerekmektedir.

```python
>>> selam = "Hello, World!"
>>> hizalama = {"Sol": "<", "Orta": "^", "Sağ": ">"}
>>> genişlik = 25
>>> for hiza, operatör in hizalama.items():
... print(f"{hiza:>5}: '{selam:{operatör}{genişlik}}'")
...
 Sol: 'Hello, World! '
Orta: ' Hello, World! '
 Sağ: ' Hello, World!'

```

## Listeler ve Demetler

Bu bölüme gelene kadar yalnızca iki farklı veri tipi görmüştük. Bunlardan biri
karakter dizileri, öteki ise sayılardı. Ancak tabii ki Python’daki veri tipleri
yalnızca bu ikisiyle sınırlı değildir. Python’da karakter dizileri ve sayıların
dışında, başka amaçlara hizmet eden, başka veri tipleri de vardır. İşte biz bu
bölümde iki farklı veri tipi daha öğreneceğiz. Bu bölümde ele alacağımız veri
tiplerinin adı ‘liste’ (list) ve ‘demet’ (tuple).

Bu bölümde birer veri tipi olarak listeler ve demetlerden söz etmenin yanısıra
liste ve demetlerin metotlarından da bahsedeceğiz. Listelerle demetleri
öğrendikten sonra Python’daki hareket imkanınızın bir hayli genişlediğine tanık
olacaksınız.

Python programlama diline yeni başlayan biri, karakter dizilerini öğrendikten
sonra bu dilde her şeyi karakter dizileri yardımıyla halledebileceğini
zannedebilir. O yüzden yeni bir veri tipi ile karşılaştığında (örneğin listeler
veya demetler), bu yeni veri tipi ona anlamsız ve gereksizmiş gibi görünebilir.
Aslında daha önce de söylediğimiz gibi, bir programlama dilini yeni öğrenenlerin
genel sorunudur bu. Öğrenci, bir programlama dilini oluşturan minik parçaları
öğrenirken, öğrencinin zihni bu parçaların ne işine yarayacağı konusunda
şüpheyle dolar. Sanki gereksiz şeylerle vakit kaybediyormuş gibi hissedebilir.
En önemli ve en büyük programların, bu minik parçaların sistematik bir şekilde
birleştirilmesiyle ortaya çıkacak olması öğrencinin kafasına yatmayabilir.
Halbuki en karmaşık programların bile kaynak kodlarını incelediğinizde
görecekleriniz karakter dizileri, listeler, demetler, sayılar ve buna benzer
başka veri tiplerinden ibarettir. Nasıl en lezzetli yemekler birkaç basit
malzemenin bir araya gelmesi ile ortaya çıkıyorsa, en abidevi programlar da ilk
bakışta birbiriyle ilgisiz görünen çok basit parçaların incelikli bir şekilde
birleştirilmesinden oluşur.

O halde bu noktada, Python programlama diline yeni başlayan hemen herkesin
sorduğu o soruyu soralım kendimize: ‘Neden farklı veri tipleri var? Bu veri
tiplerinin hepsine gerçekten ihtiyacım olacak mı?’

Bu soruyu başka bir soruyla cevaplamaya çalışalım: ‘Acaba neden farklı giysi
tipleri var? Neden kot pantolon, kumaş pantolon, tişört, gömlek ve buna benzer
ayrımlara ihtiyaç duyuyoruz?’ Bu sorunun cevabı çok basit: ‘Çünkü farklı
durumlara farklı giysi türleri uygundur!’

Örneğin ev taşıyacaksanız, herhalde kumaş pantolon ve gömlek giymezsiniz
üzerinize. Buna benzer bir şekilde iş görüşmesine giderken de kot pantolon ve
tişört doğru bir tercih olmayabilir. İşte buna benzer sebeplerden, programlama
dillerinde de belli durumlarda belli veri tiplerini kullanmanız gerekir. Örneğin
bir durumda karakter dizilerini kullanmak uygunken, başka bir durumda listeleri
veya demetleri kullanmak daha mantıklı olabilir. Zira her veri tipinin kendine
has güçlü ve zayıf yanları vardır. Veri tiplerini ve bunların ayrıntılarını
öğrendikçe, hangi veri tipinin hangi sorun için daha kullanışlı olduğunu
kestirebilecek duruma geleceğinizden hiç kuşkunuz olmasın.

Biz bu bölümde listeleri ve demetleri olabildiğince ayrıntılı bir şekilde
inceleyeceğiz. O yüzden bu veri tiplerini incelerken konuyu birkaç farklı bölüme
ayıracağız.

Listeleri ve demetleri incelemeye listelerden başlayalım…

### Listeler

Giriş bölümünde de değindiğimiz gibi, listeler Python’daki veri tiplerinden
biridir. Tıpkı karakter dizileri ve sayılar gibi…

#### Liste Tanımlamak

Listeleri tanımaya, bu veri tipini nasıl tanımlayacağımızı öğrenerek başlayalım.

Hatırlarsanız bir karakter dizisi tanımlayabilmek için şöyle bir yol
izliyorduk:

```python
>>> kardiz = "karakter dizisi"

```

Yani herhangi bir öğeyi karakter dizisi olarak tanımlayabilmek için yapmamız
gereken tek şey o öğeyi tırnak içine almaktı. Herhangi bir öğeyi (tek, çift veya
üç) tırnak içine aldığımızda karakter dizimizi tanımlamış oluyoruz. Liste
tanımlamak için de buna benzer bir şey yapıyoruz. Dikkatlice bakın:

```python
>>> liste = ["öğe1", "öğe2", "öğe3"]

```

Gördüğünüz gibi, liste tanımlamak da son derece kolay. Bir liste elde etmek
için, öğeleri birbirinden virgülle ayırıp, bunların hepsini köşeli parantezler
içine alıyoruz.

Karakter dizilerini anlatırken, herhangi bir nesnenin karakter dizisi olup
olmadığından emin olmak içintype()fonksiyonundan yararlanabileceğimizi
söylemiştik. Eğer bir nesnetype()fonksiyonuna<class ‘str’>cevabı
veriyorsa o nesne bir karakter dizisidir. Listeler için de buna benzer bir
sorgulama yapabiliriz:

```python
>>> liste = ["öğe1", "öğe2", "öğe3"]
>>> type(liste)

<class 'list'>

```

Bu çıktıdan anlıyoruz ki, liste veri tipitype()fonksiyonuna<class
‘list’>cevabı veriyor. Dolayısıyla, eğer bir nesnetype()fonksiyonuna<class ‘list’>cevabı veriyorsa o nesnenin bir liste olduğunu rahatlıkla
söyleyebiliriz.

Yukarıda tanımladığımızlisteadlı listeye baktığımızda dikkatimizi bir şey
çekiyor olmalı. Bu listeye şöyle bir baktığımızda, aslında bu listenin, içinde
üç adet karakter dizisi barındırdığını görüyoruz. Gerçekten de listeler, bir
veya daha fazla veri tipini içinde barındıran kapsayıcı bir veri tipidir. Mesela
şu listeye bir bakalım:

```python
>>> liste = ["Ahmet", "Mehmet", 23, 65, 3.2]

```

Gördüğünüz gibi, liste içinde hem karakter dizileri (“Ahmet”,“Mehmet”), hem
de sayılar (23,65,3.2) var.

Dahası, listelerin içinde başka listeler de bulunabilir:

```python
>>> liste = ["Ali", "Veli", ["Ayşe", "Nazan", "Zeynep"], 34, 65, 33, 5.6]

```

Bulisteadlı değişkenin tipini sorgularsak şöyle bir çıktı alacağımızı
biliyorsunuz:

```python
>>> type(liste)

<class 'list'>

```

Bir de şunu deneyelim:

```python
for öğe in liste:
 print("{} adlı öğenin veri tipi: {}".format(öğe, type(öğe)))

```

Bu kodları çalıştırdığımızda da şöyle bir çıktı alıyoruz:

```python
Ali adlı öğenin veri tipi: <class 'str'>
Veli adlı öğenin veri tipi: <class 'str'>
['Ayşe', 'Nazan', 'Zeynep'] adlı öğenin veri tipi: <class 'list'>
34 adlı öğenin veri tipi: <class 'int'>
65 adlı öğenin veri tipi: <class 'int'>
33 adlı öğenin veri tipi: <class 'int'>
5.6 adlı öğenin veri tipi: <class 'float'>

```

Bu kodlar bize şunu gösteriyor: Farklı öğeleri bir araya getirip bunları köşeli
parantezler içine alırsak ‘liste’ adlı veri tipini oluşturmuş oluyoruz. Bu
listenin öğeleri farklı veri tiplerine ait olabilir. Yukarıdaki kodların da
gösterdiği gibi, liste içinde yer alan“Ali”ve“Veli”öğeleri birer
karakter dizisi;[‘Ayşe’, ‘Nazan’, ‘Zeynep’]adlı öğe bir liste;34,65ve33öğeleri birer tam sayı;5.6öğesi ise bir kayan noktalı sayıdır. İşte
farklı veri tiplerine ait bu öğelerin hepsi bir araya gelerek liste denen veri
tipini oluşturuyor. Yukarıdaki örnekten de gördüğünüz gibi, bir listenin içinde
başka bir liste de yer alabiliyor. Örneğin burada listemizin öğelerinden biri,[‘Ayşe’, ‘Nazan’, ‘Zeynep’]adlı başka bir listedir.

Hatırlarsanız karakter dizilerinin belirleyici özelliği tırnak işaretleri idi.
Yukarıdaki örneklerden de gördüğünüz gibi listelerin belirleyici özelliği de
köşeli parantezlerdir. Mesela:

```python
>>> karakter = ""

```

Bu boş bir karakter dizisidir. Şu ise boş bir liste:

```python
>>> liste = []

```

Tıpkı karakter dizilerinde olduğu gibi, listelerle de iki şekilde
karşılaşabilirsiniz:
1. Listeyi kendiniz tanımlamış olabilirsiniz.
1. Liste size başka bir kaynaktan gelmiş olabilir.

Listeyi kendiniz tanımlamış olabilirsiniz.

Liste size başka bir kaynaktan gelmiş olabilir.

Yukarıdaki örneklerde bir listeyi kendimizin nasıl tanımlayacağımızı öğrendik.
Peki listeler bize başka hangi kaynaktan gelebilir?

Hatırlarsanız karakter dizilerinin metotlarını sıralamak içindir()adlı bir
fonksiyondan yararlanmıştık.

Mesela karakter dizilerinin bize hangi metotları sunduğunu görmek için bu
fonksiyonu şöyle kullanmıştık:

```python
>>> dir(str)

```

Bu komut bize şu çıktıyı vermişti:

```python
['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__',
'__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__',
'__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
'__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
'__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', 'capitalize', 'center', 'count', 'encode', 'endswith',
'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha',
'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable',
'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',
'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']

```

Artık bu çıktı size çok daha anlamlı geliyor olmalı. Gördüğünüz gibi çıktımız
köşeli parantezler arasında yer alıyor. Yani aslında yukarıdaki çıktı bir liste.
Dilerseniz bunu nasıl teyit edebileceğinizi biliyorsunuz:

```python
>>> komut = dir(str)
>>> type(komut)

<class 'list'>

```

Gördüğünüz gibi, tıpkıinput()fonksiyonundan gelen verinin bir karakter
dizisi olması gibi,dir()fonksiyonundan gelen veri tipi de bir listedir.

dir()fonksiyonu dışında, başka bir şeyin daha bize liste verdiğini
biliyoruz. Bu şey, karakter dizilerininsplit()adlı metodudur:

```python
>>> kardiz = "İstanbul Büyükşehir Belediyesi"
>>> kardiz.split()

['İstanbul', 'Büyükşehir', 'Belediyesi']

```

Görüyorsunuz,split()metodunun çıktısı da köşeli parantezler içinde yer
alıyor. Demek ki bu çıktı da bir listedir.

Peki bir fonksiyonun bize karakter dizisi mi, liste mi yoksa başka bir veri tipi
mi verdiğini bilmenin ne faydası var?

Her zaman söylediğimiz gibi, Python’da o anda elinizde olan verinin tipini
bilmeniz son derece önemlidir. Aksi halde o veriyi nasıl evirip çevireceğinizi,
o veriyle neler yapabileceğinizi bilemezsiniz. Mesela ‘İstanbul Büyükşehir
Belediyesi’ ifadesini ele alalım. Bu ifadeyle ilgili size şöyle bir soru
sorduğumu düşünün: ‘Acaba bu ifadenin ilk harfini nasıl alırız?’

Eğer bu ifade sizeinput()fonksiyonundan gelmişse, yani bir karakter
dizisiyse uygulayacağınız yöntem farklı,split()metoduyla gelmişse, yani
liste ise uygulayacağınız yöntem farklı olacaktır.

Eğer bu ifade bir karakter dizisi ise ilk harfi şu şekilde alabilirsiniz:

```python
>>> kardiz = "İstanbul Büyükşehir Belediyesi"
>>> kardiz[0]

'İ'

```

Ama eğer bu ifade bir liste ise yukarıdaki yöntem size farklı bir sonuç verir:

```python
>>> liste = kardiz.split()
>>> liste[0]

'İstanbul'

```

Çünkü“İstanbul Büyükşehir Belediyesi”adlı karakter dizisinin ilk öğesi“İ”karakteridir, ama[‘İstanbul’, ‘Büyükşehir’, ‘Belediyesi’]adlı listenin ilk
öğesi“İ”karakteri değil,“İstanbul”kelimesidir.

Gördüğünüz gibi, bir nesnenin hangi veri tipine ait olduğunu bilmek o nesneyle
neleri nasıl yapabileceğimizi doğrudan etkiliyor. O yüzden programlama
çalışmalarınız esnasında veri tiplerine karşı her zaman uyanık olmalısınız.

> **Not**
> Python’da bir nesnenin hangi veri tipine ait olduğunu bilmenin neden
bu kadar önemli olduğunu gerçek bir örnek üzerinde görmek istersenizistihza.com/forum/viewtopic.php?f=43&t=62(arşiv linki) adresindeki tartışmayı
inceleyebilirsiniz.

Not

Python’da bir nesnenin hangi veri tipine ait olduğunu bilmenin neden
bu kadar önemli olduğunu gerçek bir örnek üzerinde görmek istersenizistihza.com/forum/viewtopic.php?f=43&t=62(arşiv linki) adresindeki tartışmayı
inceleyebilirsiniz.

Her ne kadar karakter dizileri ve listeler iki farklı veri tipi olsa ve bu iki
veri tipinin birbirinden çok farklı yönleri ve yetenekleri olsa da, bu iki veri
tipi arasında önemli benzerlikler de vardır. Örneğin karakter dizilerini
işlerken öğrendiğimiz pek çok fonksiyonu listelerle birlikte de
kullanabilirsiniz. Mesela karakter dizilerini incelerken öğrendiğimizlen()fonksiyonu listelerin boyutunu hesaplamada da kullanılabilir:

```python
>>> diller = ["İngilizce", "Fransızca", "Türkçe", "İtalyanca", "İspanyolca"]
>>> len(diller)

5

```

Karakter dizileri karakterlerden oluşan bir veri tipi olduğu içinlen()fonksiyonu karakter dizisi içindeki karakterlerin sayısını veriyor. Listeler ise
başka veri tiplerini bir araya toplayan bir veri tipi olduğu içinlen()fonksiyonu liste içindeki veri tiplerinin sayısını söylüyor.

len()fonksiyonu dışında,range()fonksiyonuyla listeleri de birlikte
kullanabilirsiniz. Mesela herhangi bir kaynaktan size şunlar gibi iki öğeli
listeler geliyor olabilir:

```python
[0, 10]
[6, 60]
[12, 54]
[67, 99]

```

Bu iki öğeli listeleri tek bir liste içinde topladığımızı düşünürsek şöyle bir
kod yazabiliriz:

```python
sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]]

for i in sayılar:
 print(*range(*i))

```

Eğer ilk bakışta bu kod gözünüze anlaşılmaz göründüyse bu kodu parçalara
ayırarak inceleyebilirsiniz.

Burada öncelikle birfordöngüsü oluşturduk. Bu sayedesayılaradlı
listedeki öğelerin üzerinden tek tek geçebileceğiz. Eğer döngü içinde sadece
öğeleri ekrana yazdırıyor olsaydık şöyle bir kodumuz olacaktı:

```python
for i in sayılar:
 print(i)

```

Bu kod bize şöyle bir çıktı verecektir:

```python
[0, 10]
[6, 60]
[12, 54]
[67, 99]

```

range()fonksiyonunun nasıl kullanıldığını hatırlıyorsunuz. Yukarıdaki
listelerde görünen ilk sayılarrange()fonksiyonunun ilk parametresi, ikinci
sayılar ise ikinci parametresi olacak. Yani her döngüde şöyle bir şey elde
etmemiz gerekiyor:

```python
range(0, 10)
range(6, 60)
range(12, 54)
range(67, 99)

```

Aslında kodlarımızı şöyle yazarak yukarıdaki çıktıyı elde edebilirdik:

```python
sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]]

for i in sayılar:
 print(range(i[0], i[1]))

```

Yukarıdaki açıklamalarda gördüğünüz gibi,ideğişkeninin çıktısı ikişer öğeli
bir liste oluyor. İşte burada yaptığımız şey, bu ikişer öğeli listelerin ilk
öğesini (i[0])range()fonksiyonunun ilk parametresi, ikinci öğesini
(i[1]) iserange()fonksiyonunun ikinci parametresi olarak atamaktan
ibaret. Ancak ilk derslerimizden hatırlayacağınız gibi, bunu yapmanın daha kısa
bir yolu var. Bildiğiniz gibi, öğelerden oluşan dizileri ayrıştırmak için yıldız
işaretinden yararlanabiliyoruz. Dolayısıyla yukarıdaki kodları şöyle yazmak daha
pratik olabilir:

```python
sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]]

for i in sayılar:
 print(range(*i))

```

Gördüğünüz gibi,ideğişkeninin soluna bir yıldız ekleyerek bu değişken
içindeki değerleri ayrıştırdık ve şöyle bir çıktı elde ettik:

```python
range(0, 10)
range(6, 60)
range(12, 54)
range(67, 99)

```

Hatırlarsanız,range(0,10)gibi bir kod yazdığımızda Python bize0ile10arasındaki sayıları doğrudan göstermiyordu. Aralıktaki sayıları görmek içinrange()fonksiyonunun çıktısını bir döngü içine almalıyız:

```python
for i in range(0, 10):
 print(i)

```

range(0,10)çıktısını görmek için döngü kurmak yerine yine yıldız
işaretinden yararlanabiliyoruz. Örneğin:

```python
>>> print(*range(0, 10))

0 1 2 3 4 5 6 7 8 9

```

Aynı şeyi yukarıdaki kodlara da uygularsak şöyle bir şey elde ederiz:

```python
sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]]

for i in sayılar:
 print(*range(*i))

```

Gördüğünüz gibi, yıldız işaretini hemideğişkenine, hem derange()fonksiyonuna ayrı ayrı uygulayarak istediğimiz sonucu elde ettik.

Bu arada, yukarıdaki örnek bize listeler hakkında önemli bir bilgi de verdi.
Karakter dizilerinin öğelerine erişmek için nasılkardiz[öğe_sırası]gibi
bir formülden yararlanıyorsak, listelerin öğelerine erişmek için de aynı şekildeliste[öğe_sırası]gibi bir formülden yararlanabiliyoruz.

Listelerin öğelerine nasıl ulaşacağımızın ayrıntılarını biraz sonra göreceğiz.
Ama biz şimdi listelere ilişkin önemli bir fonksiyonu inceleyerek yolumuza devam
edelim.

#### list() Fonksiyonu

Yukarıdaki örneklerden de gördüğünüz gibi liste oluşturmak için öğeleri
belirleyip bunları köşeli parantezler içine almamız yeterli oluyor. Bu yöntemin
dışında, liste oluşturmanın bir yöntemi daha bulunur. Mesela elimizde şöyle bir
karakter dizisi olduğunu düşünelim:

```python
>>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz"

```

Sorumuz şu olsun: ‘Acaba bu karakter dizisini listeye nasıl çeviririz?’

Karakter dizilerini anlatırkensplit()adlı bir metottan söz etmiştik. Bu
metot karakter dizilerini belli bir ölçüte göre bölmemizi sağlıyordu.split()metoduyla elde edilen verinin bir liste olduğunu biliyorsunuz.
Örneğin:

```python
>>> isimler = "ahmet mehmet cem"

>>> isimler.split()

['ahmet', 'mehmet', 'cem']

```

Ancaksplit()metodunun bir karakter dizisini bölüp bize bir liste
verebilmesi için karakter dizisinin belli bir ölçüte göre bölünebilir durumda
olması gerekiyor. Mesela yukarıdakiisimleradlı karakter dizisi belli bir
ölçüte göre bölünebilir durumdadır. Neden? Çünkü karakter dizisi içindeki her
parça arasında bir boşluk karakteri var. Dolayısıylasplit()metodu bu
karakter dizisini boşluklardan bölebiliyor. Aynı şey şu karakter dizisi için de
geçerlidir:

```python
>>> isimler = "elma, armut, çilek"

```

Bu karakter dizisini oluşturan her bir parça arasında bir adet virgül ve bir
adet boşluk karakteri var. Dolayısıyla biz bu karakter dizisinisplit()metodunu kullanarak “virgül + boşluk karakteri” ölçütüne göre bölebiliriz:

```python
>>> isimler.split(", ")

['elma', 'armut', 'çilek']

```

Ancak bölümün başında tanımladığımızalfabeadlı karakter dizisi biraz
farklıdır:

```python
>>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz"

```

Gördüğünüz gibi, bu karakter dizisi tek bir parçadan oluşuyor. Dolayısıyla bu
karakter dizisini öğelerine bölmemizi sağlayacak bir ölçüt yok. Yani bu karakter
dizisini şu şekilde bölemeyiz:

```python
>>> alfabe.split()

['abcçdefgğhıijklmnoöprsştuüvyz']

```

Elbette bu karakter dizisini isterseniz farklı şekillerde bölebilirsiniz.
Mesela:

```python
>>> alfabe.split("i")

['abcçdefgğhı', 'jklmnoöprsştuüvyz']

```

Gördüğünüz gibi, biz buradaalfabekarakter dizisini “i” harfinden bölebildik.
Ama istediğimiz şey bu değil. Biz aslında şöyle bir çıktı elde etmek istiyoruz:

```python
['a', 'b', 'c', 'ç', 'd', 'e', 'f', 'g', 'ğ', 'h', 'ı', 'i', 'j',
 'k', 'l', 'm', 'n', 'o', 'ö', 'p', 'r', 's', 'ş', 't', 'u', 'ü',
 'v', 'y', 'z']

```

Yani bizim amacımız,alfabekarakter dizisi içindeki her bir öğeyi birbirinden
ayırmak. İşte Türk alfabesindeki harflerden oluşan bu karakter dizisini,list()adlı bir fonksiyondan yararlanarak istediğimiz şekilde bölebiliriz:

```python
>>> harf_listesi = list(alfabe)
>>> print(harf_listesi)

['a', 'b', 'c', 'ç', 'd', 'e', 'f', 'g', 'ğ', 'h', 'ı', 'i', 'j',
 'k', 'l', 'm', 'n', 'o', 'ö', 'p', 'r', 's', 'ş', 't', 'u', 'ü',
 'v', 'y', 'z']

```

Böylecelist()fonksiyonu yardımıyla bu karakter dizisini tek hamlede
listeye çevirmiş olduk.

Peki bir karakter dizisini neden listeye çevirme ihtiyacı duyarız? Şu anda
listelerle ilgili pek çok şeyi henüz bilmediğimiz için ilk bakışta bu çevirme
işlemi gözünüze gereksizmiş gibi görünebilir, ama ilerleyen zamanda sizin de
göreceğiniz gibi, bazı durumlarda listeleri manipüle etmek karakter dizilerini
manipüle etmeye kıyasla çok daha kolaydır. O yüzden kimi zaman karakter
dizilerini listeye çevirmek durumunda kalabilirsiniz.

list()fonksiyonunun yaptığı işi, daha önce öğrendiğimizstr(),int()vefloat()fonksiyonlarının yaptığı işle kıyaslayabilirsiniz.list()fonksiyonu da tıpkıstr(),int()vefloat()fonksiyonları
gibi bir dönüştürme fonksiyonudur. Örneğinint()fonksiyonunu kullanarak
sayı değerli karakter dizilerini sayıya dönüştürebiliyoruz:

```python
>>> k = "123"
>>> int(k)

123

```

Bu dönüştürme işlemi sayesinde sayılar üzerinde aritmetik işlem yapma imkanımız
olabiliyor. İştelist()fonksiyonu da buna benzer bir amaca hizmet eder.
Meselainput()fonksiyonundan gelen bir karakter dizisi ile toplama çıkarma
yapabilmek için nasıl bu karakter dizisini önce sayıya dönüştürmemiz
gerekiyorsa, bazı durumlarda bu karakter dizisini (veya başka veri tiplerini)
listeye çevirmemiz de gerekebilir. Böyle bir durumdalist()fonksiyonunu
kullanarak farklı veri tiplerini rahatlıkla listeye çevirebiliriz.

Yukarıdaki işlevlerinin dışında,list()fonksiyonu boş bir liste oluşturmak
için de kullanılabilir:

```python
>>> li = list()
>>> print(li)

[]

```

Yukarıdaki kodlardan gördüğünüz gibi, boş bir liste oluşturmak içinliste=[]koduna alternatif olaraklist()fonksiyonundan da yararlanabilirsiniz.

list()fonksiyonunun önemli bir görevi derange()fonksiyonunun, sayı
aralığını ekrana basmasını sağlamaktır. Bildiğiniz gibi,range()fonksiyonu
tek başına bir sayı aralığını ekrana dökmez. Bu fonksiyon bize yalnızca şöyle
bir çıktı verir:

```python
>>> range(10)

range(0, 10)

```

Bu sayı aralığını ekrana dökmek içinrange()fonksiyonu üzerinde birfordöngüsü kurmamız gerekir:

```python
>>> for i in range(10):
... print(i)
...
0
1
2
3
4
5
6
7
8
9

```

Bu bölümde verdiğimiz örneklerde aynı işi şöyle de yapabileceğimizi
öğrenmiştik:

```python
>>> print(*range(10))

0 1 2 3 4 5 6 7 8 9

```

Bu görevi yerine getirmenin üçüncü bir yolu dalist()fonksiyonunu
kullanmaktır:

```python
>>> list(range(10))

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Aslında burada yaptığımız şeyrange(10)ifadesini bir listeye dönüştürmekten
ibarettir. Buradarangetüründe bir veriyilisttüründe bir veriye
dönüştürüyoruz:

```python
>>> type(range(10))

<class 'range'>

>>> li = list(range(10))
>>> type(li)

<class 'list'>

```

Gördüğünüz gibi, yukarıdaki üç yöntem de aralıktaki sayıları ekrana döküyor.
Yalnız dikkat ederseniz bu üç yöntemin çıktıları aslında görünüş olarak
birbirlerinden ince farklarla ayrılıyor. Yazdığınız programda nasıl bir çıktıya
ihtiyacınız olduğuna bağlı olarak yukarıdaki yöntemlerden herhangi birini tercih
edebilirsiniz.

Böylece Python’da listelerin ne olduğunu ve bu veri tipinin nasıl
oluşturulacağını öğrenmiş olduk. O halde bir adım daha atarak listelerin başka
özelliklerine değinelim.

#### Listelerin Öğelerine Erişmek

Tıpkı karakter dizilerinde olduğu gibi, listelerde de her öğenin bir sırası
vardır. Hatırlarsanız karakter dizilerinin öğelerine şu şekilde ulaşıyorduk:

```python
>>> kardiz = "python"
>>> kardiz[0]

'p'

```

Bu bölümdeki birkaç örnekte de gördüğünüz gibi, listelerin öğelerine ulaşırken
de aynı yöntemi kullanabiliyoruz:

```python
>>> meyveler = ["elma", "armut", "çilek", "kiraz"]
>>> meyveler[0]

'elma'

```

Yalnız yöntem aynı olsa da yukarıdaki iki çıktı arasında bazı farklar olduğunu
da gözden kaçırmayın. Bir karakter dizisinin0.öğesini aldığımızda o karakter
dizisinin ilk karakterini almış oluyoruz. Bir listenin0.öğesini aldığımızda
ise o listenin ilk öğesini almış oluyoruz.

Sayma yöntemi olarak ise karakter dizileri ve listelerde aynı mantık geçerli.
Hem listelerde hem de karakter dizilerinde Python saymaya0’dan başlıyor. Yani
karakter dizilerinde olduğu gibi, listelerde de ilk öğenin sırası0.

Eğer bu listenin öğelerinin hepsine tek tek ulaşmak istersenizfordöngüsünden yararlanabilirsiniz:

```python
meyveler = ["elma", "armut", "çilek", "kiraz"]

for meyve in meyveler:
 print(meyve)

```

Bu listedeki öğeleri numaralandırmak da mümkün:

```python
meyveler = ["elma", "armut", "çilek", "kiraz"]

for öğe_sırası in range(len(meyveler)):
 print("{}. {}".format(öğe_sırası, meyveler[öğe_sırası]))

```

…veyaenumerate()fonksiyonunu kullanarak şöyle bir şey de yazabiliriz:

```python
for sıra, öğe in enumerate(meyveler, 1):
 print("{}. {}".format(sıra, öğe))

```

Dediğimiz gibi, liste öğelerine ulaşmak için kullandığımız yöntem, karakter
dizilerinin öğelerine ulaşmak için kullandığımız yöntemle aynı. Aslında karakter
dizileri ile listeler arasındaki benzerlik bununla sınırlı değildir.
Benzerlikleri birkaç örnek üzerinde gösterelim:

```python
>>> meyveler = ["elma", "armut", "çilek", "kiraz"]
>>> meyveler[-1]

'kiraz'

```

Karakter dizilerinde olduğu gibi, öğe sırasını eksi değerli bir sayı
yaptığımızda liste öğeleri sondan başa doğru okunuyor. Dolayısıylameyveler[-1]komutu bizemeyveleradlı listenin son öğesini veriyor.

```python
>>> meyveler[0:2]

['elma', 'armut']

```

Karakter dizileri konusunu işlerken öğrendiğimiz dilimleme yöntemi listeler için
de aynen geçerlidir. Orada öğrendiğimiz dilimleme kurallarını listelere de
uygulayabiliyoruz. Örneğin liste öğelerini ters çevirmek için şöyle bir kod
yazabiliyoruz:

```python
>>> meyveler[::-1]

['kiraz', 'çilek', 'armut', 'elma']

```

Bu bölümün başında da söylediğimiz gibi, liste adlı veri tipi, içinde başka bir
liste de barındırabilir. Buna şöyle bir örnek vermiştik:

```python
>>> liste = ["Ali", "Veli", ["Ayşe", "Nazan", "Zeynep"], 34, 65, 33, 5.6]

```

Bu listedeki öğeler şunlardır:

```python
Ali
Veli
['Ayşe', 'Nazan', 'Zeynep']
34
65
33
5.6

```

Gördüğünüz gibi, bu liste içinde[‘Ayşe’, ‘Nazan’, ‘Zeynep’]gibi bir liste
daha var. Bu liste ana listenin öğelerinden biridir ve bu da öteki öğeler gibi
tek öğelik bir yer kaplar. Yani:

```python
>>> len(liste)

7

```

Bu çıktıdan anlıyoruz ki, listemiz toplam7öğeden oluşuyor. Listenin2.sırasında yer alan listenin kendisi üç öğeden oluştuğu halde bu öğe ana liste
içinde sadece tek öğelik bir yer kaplıyor. Yani2.sıradaki listenin öğeleri
tek tek sayılmıyor. Peki böyle bir liste içindeki gömülü listenin öğelerini elde
etmek istersek ne yapacağız? Yani mesela içe geçmiş listenin tamamını değil de,
örneğin sadece“Ayşe”öğesini almak istersek ne yapmamız gerekiyor? Dikkatlice
bakın:

```python
>>> liste[2][0]

'Ayşe'

```

“Nazan” öğesini almak için:

```python
>>> liste[2][1]

'Nazan'

```

“Zeynep” öğesini almak için:

```python
>>> liste[2][2]

'Zeynep'

```

Gördüğünüz gibi, iç içe geçmiş listelerin öğelerini almak oldukça basit.
Yapmamız gereken tek şey, gömülü listenin önce ana listedeki konumunu, ardından
da almak istediğimiz öğenin gömülü listedeki konumunu belirtmektir.

İstersek gömülü listeyi ayrı bir liste olarak da alabiliriz:

```python
>>> yeni_liste = liste[2]
>>> yeni_liste

['Ayşe', 'Nazan', 'Zeynep']

```

Böylece bu listenin öğelerine normal bir şekilde ulaşabiliriz:

```python
>>> yeni_liste[0]

'Ayşe'

>>> yeni_liste[1]

'Nazan'

>>> yeni_liste[2]

'Zeynep'

```

Eğer bir listenin öğelerine erişmeye çalışırken, varolmayan bir sıra sayısı
belirtirseniz Python size bir hata mesajı gösterecektir:

```python
>>> liste = range(10)
>>> print(len(liste))

10

```

Buradarange()fonksiyonundan yararlanarak10öğeli bir liste tanımladık.
Bu listenin son öğesinin şu formüle göre bulunabileceğini karakter dizileri
konusundan hatırlıyor olmalısınız:

```python
>>> liste[len(liste)-1]

9

```

Demek ki bu listenin son öğesi9sayısı imiş… Bir de şunu deneyelim:

```python
>>> liste[10]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: range object index out of range

```

Gördüğünüz gibi, listemizde10.öğe diye bir şey olmadığı için Python bizeIndexErrortipinde bir hata mesajı gösteriyor. Çünkü bu listenin son öğesinin
sırasılen(liste)-1, yani9’dur.

#### Listelerin Öğelerini Değiştirmek

Hatırlarsanız karakter dizilerinden söz ederken bunların değiştirilemez
(immutable) bir veri tipi olduğunu söylemiştik. Bu özellikten ötürü, bir
karakter dizisi üzerinde değişiklik yapmak istediğimizde o karakter dizisini
yeniden oluşturuyoruz. Örneğin:

```python
>>> kardiz = "istihza"
>>> kardiz = "İ" + kardiz[1:]
>>> kardiz

'İstihza'

```

Listeler ise değiştirilebilen (mutable) bir veri tipidir. Dolayısıyla listeler
üzerinde doğrudan değişiklik yapabiliriz. Bir liste üzerinde değişiklik
yapabilmek için o listeyi yeniden tanımlamamıza gerek yok. Şu örneği dikkatlice
inceleyin:

```python
>>> renkler = ["kırmızı", "sarı", "mavi", "yeşil", "beyaz"]
>>> print(renkler)

['kırmızı', 'sarı', 'mavi', 'yeşil', 'beyaz']

>>> renkler[0] = "siyah"
>>> print(renkler)

['siyah', 'sarı', 'mavi', 'yeşil', 'beyaz']

```

Liste öğelerini nasıl değiştirdiğimize çok dikkat edin. Yukarıdaki örnekterenkleradlı listenin0.öğesini değiştirmek istiyoruz. Bunun için şöyle bir
formül kullandık:

```python
renkler[öğe_sırası] = yeni_öğe

```

Örnek olması açısından, aynı listenin 2. sırasındaki“mavi”adlı öğeyi“mor”yapalım bir de:

```python
>>> renkler[2] = "mor"
>>> print(renkler)

['siyah', 'sarı', 'mor', 'yeşil', 'beyaz']

```

Gördüğünüz gibi, listeler üzerinde değişiklik yapmak son derece kolay. Sırf bu
özellik bile, neden bazı durumlarda listelerin karakter dizileri yerine tercih
edilebileceğini gösterecek güçtedir.

Liste öğelerini değiştirmeye çalışırken, eğer var olmayan bir sıra numarasına
atıfta bulunursanız Python sizeIndexErrortipinde bir hata mesajı
gösterecektir:

```python
>>> renkler[10] = "pembe"

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range

```

Sıra numaralarını kullanarak listeler üzerinde daha ilginç işlemler de
yapabilirsiniz. Mesela şu örneğe bakın:

```python
>>> liste = [1, 2, 3]
>>> liste[0:len(liste)] = 5, 6, 7
>>> print(liste)

[5, 6, 7]

```

Buradalisteadlı listenin bütün öğelerini bir çırpıda değiştirdik. Peki bunu
nasıl yaptık?

Yukarıdaki örneği şu şekilde yazarsak biraz daha açıklayıcı olabilir:

```python
>>> liste[0:3] = 5, 6, 7

```

Bu kodlarla yaptığımız şey, listenin0.ve3.öğesi arasında kalan bütün
öğelerin yerine5,6ve7öğelerini yerleştirmekten ibarettir.

Karakter dizilerinden hatırlayacağınız gibi, eğer sıra numarası bir karakter
dizisinin ilk öğesine karşılık geliyorsa o sıra numarasını belirtmeyebiliriz.
Aynı şekilde eğer sıra numarası bir karakter dizisinin son öğesine karşılık
geliyorsa o sıra numarasını da belirtmeyebiliriz. Bu kural listeler için de
geçerlidir. Dolayısıyla yukarıdaki örneği şöyle de yazabilirdik:

```python
>>> liste[:] = 5, 6, 7

```

Sıra numaralarını kullanarak gerçekten son derece enteresan işlemler
yapabilirsiniz. Sıra numaraları ile neler yapabileceğinizi görmek için kendi
kendinize ve hayal gücünüzü zorlayarak bazı denemeler yapmanızı tavsiye ederim.

#### Listeye Öğe Eklemek

Listeler büyüyüp küçülebilen bir veri tipidir. Yani Python’da bir listeye
istediğiniz kadar öğe ekleyebilirsiniz. Diyelim ki elimizde şöyle bir liste
var:

```python
>>> liste = [2, 4, 5, 7]

```

Bu listeye yeni bir öğe ekleyebilmek için şöyle bir kod yazabiliriz:

```python
>>> liste + [8]

[2, 4, 5, 7, 8]

```

Bu örnek, bize listeler hakkında önemli bir bilgi veriyor. Python’da+işareti
kullanarak bir listeye öğe ekleyecekseniz, eklediğiniz öğenin de liste olması
gerekiyor. Mesela bir listeye doğrudan karakter dizilerini veya sayıları
ekleyemezsiniz:

```python
>>> liste + 8

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "int") to list

>>> liste + "8"

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "str") to list

```

Listelere+işareti ile ekleyeceğiniz öğelerin de bir liste olması gerekiyor.
Aksi halde Python bize bir hata mesajı gösteriyor.

#### Listeleri Birleştirmek

Bazı durumlarda elinize farklı kaynaklardan farklı listeler gelebilir. Böyle bir
durumda bu farklı listeleri tek bir liste halinde birleştirmeniz gerekebilir.
Tıpkı karakter dizilerinde olduğu gibi, listelerde de birleştirme işlemleri için+işlecinden yararlanabilirsiniz.

Diyelim ki elimizde şöyle iki adet liste var:

```python
>>> derlenen_diller = ["C", "C++", "C#", "Java"]
>>> yorumlanan_diller = ["Python", "Perl", "Ruby"]

```

Bu iki farklı listeyi tek bir liste haline getirmek için şöyle bir kod
yazabiliriz:

```python
>>> programlama_dilleri = derlenen_diller + yorumlanan_diller

['C', 'C++', 'C#', 'Java', 'Python', 'Perl', 'Ruby']

```

Bu işlemin sonucunu görelim:

```python
>>> print(programlama_dilleri)

```

Gördüğünüz gibi,derlenen_dillerveyorumlanan_dilleradlı listelerin
öğeleriniprogramlama_dilleriadlı tek bir liste içinde topladık.

Programcılık maceranız boyunca listeleri birleştirmenizi gerektiren pek çok
farklı durumla karşılaşabilirsiniz. Örneğin şöyle bir durum düşünün: Diyelim ki
kullanıcı tarafından girilen sayıların ortalamasını hesaplayan bir program
yazmak istiyorsunuz. Bunun için şöyle bir kod yazabilirsiniz:

```python
sayılar = 0

for i in range(10):
 sayılar += int(input("not: "))

print(sayılar/10)

```

Bu program kullanıcının10adet sayı girmesine izin verip, program çıkışında,
girilen sayıların ortalamasını verecektir.

Peki girilen sayıların ortalaması ile birlikte, hangi sayıların girildiğini de
göstermek isterseniz nasıl bir kod yazarsınız?

Eğer böyle bir şeyi karakter dizileri ile yazmaya kalkışırsanız epey eziyet
çekersiniz. Ama şöyle bir kod yardımıyla istediğiniz şeyi basit bir şekilde elde
edebilirsiniz:

```python
sayılar = 0
notlar = []

for i in range(10):
 veri = int(input("{}. not: ".format(i+1)))
 sayılar += veri
 notlar += [veri]

print("Girdiğiniz notlar: ", *notlar)
print("Not ortalamanız: ", sayılar/10)

```

Burada kullanıcıdan gelen verileri her döngüde tek teknotlaradlı listeye
gönderiyoruz. Böylece programın sonunda, kullanıcıdan gelen veriler bir liste
halinde elimizde bulunmuş oluyor.

Bu arada, yukarıdaki kodlarda dikkatinizi bir şey çekmiş olmalı. Kullanıcıdan
gelen verilerinotlaradlı listeye gönderirken şöyle bir kod yazdık:

```python
notlar += [veri]

```

Buradaki[veri]ifadesine dikkat edin. Bu kod yardımıyla kullanıcıdan gelenveriadlı değişkeni liste haline getiriyoruz. Bu yöntem bizim için yeni bir
şey. Peki neden buradalist()fonksiyonundan yararlanmadık?

Bunu anlamak içinlist()fonksiyonunun çalışma mantığını anlamamız
gerekiyor.

Elinizde şöyle bir karakter dizisi olduğunu düşünün:

```python
>>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz"

```

Diyelim ki siz bu karakter dizisindeki bütün öğeleri tek tek bir listeye atmak
istiyorsunuz. Bu iş içinlist()fonksiyonunu kullanabileceğimizi daha önce
söylemiştik:

```python
>>> liste = list(alfabe)

```

Pekilist()fonksiyonu bu karakter dizisinin öğelerini listeye atarken nasıl
bir yöntem izliyor?

Aslındalist()fonksiyonunun yaptığı iş şuna eşdeğerdir:

```python
liste = []
alfabe = "abcçdefgğhıijklmnoöprsştuüvyz"

for harf in alfabe:
 liste += harf

print(liste)

```

list()fonksiyonu da tam olarak böyle çalışır. Yani bir karakter dizisi
üzerinde döngü kurarak, o karakter dizisinin her bir öğesini tek tek bir listeye
atar.

fordöngülerini işlerken, bu döngünün sayılar üzerinde çalışmayacağını
söylemiştik. Çünkü sayılar, karakter dizilerinin aksine, üzerinde döngü
kurulabilen bir veri tipi değildir. Bunu bir örnek üzerinde tekrar görelim:

```python
>>> for i in 12345:
... print(i)
...

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'int' object is not iterable

```

Gördüğünüz gibi,12345sayısı üzerinde döngü kuramıyoruz. Aynı hata mesajınılist()fonksiyonunda da görürsünüz:

```python
>>> list(12345)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'int' object is not iterable

```

Dediğimiz gibi, tıpkıfordöngüsünde olduğu gibi,list()fonksiyonu da
ancak, üzerinde döngü kurulabilen nesneler üzerinde çalışabilir. Mesela:

```python
>>> list("12345")

['1', '2', '3', '4', '5']

```

Bu bilgilerin ışığında, yukarıda yazdığımız kodların şu şekilde yazılması
halinde Python’ın bize hata mesajı göstereceğini söyleyebiliriz:

```python
notlar = []

for i in range(10):
 veri = int(input("{}. not: ".format(i+1)))
 notlar += list(veri)

print("Girdiğiniz notlar: ", *notlar)

```

Kullanıcıdan gelenverideğeriniint()fonksiyonuyla sayıya
dönüştürdüğümüz için ve sayılar da üzerinde döngü kurulabilen bir veri tipi
olmadığı içinlist()fonksiyonuna parametre olarak atanamaz.

Peki kullanıcıdan gelenverideğerini sayıya dönüştürmeden, karakter dizisi
biçimindelist()fonksiyonuna parametre olarak verirsek ne olur? Bu durumdalist()fonksiyonu çalışır, ama istediğimiz gibi bir sonuç vermez. Şu kodları
dikkatlice inceleyin:

```python
notlar = []

for i in range(10):
 veri = input("{}. not: ".format(i+1))
 notlar += list(veri)

print("Girdiğiniz notlar: ", *notlar)

```

Bu kodları çalıştırdığınızda, tek haneli sayılar düzgün bir şekilde listeye
eklenir, ancak çift ve daha fazla haneli sayılar ise listeye parça parça
eklenir. Örneğin234sayısını girdiğinizde listeye2,3ve4sayıları
tek tek eklenir. Çünkü, yukarıda da dediğim gibi,list()fonksiyonu, aslında
karakter dizileri üzerine birfordöngüsü kurar. Yani:

```python
>>> for i in "234":
... print(i)

2
3
4

```

Dolayısıyla listeye234sayısı bir bütün olarak değil de, parça parça
eklendiği için istediğiniz sonucu alamamış olursunuz.

Peki bu sorunun üstesinden nasıl geleceğiz? Aslında bu sorunun çözümü çok
basittir. Eğer bir verinin listeye parça parça değil de, bir bütün olarak
eklenmesini istiyorsanız[]işaretlerinden yararlanabilirsiniz. Tıpkı şu
örnekte olduğu gibi:

```python
liste = []

while True:
 sayı = input("Bir sayı girin: (çıkmak için q) ")

 if sayı == "q":
 break

 sayı = int(sayı)

 if sayı not in liste:
 liste += [sayı]
 print(liste)
 else:
 print("Bu sayıyı daha önce girdiniz!")

```

Gördüğünüz gibi, kullanıcı tarafından aynı verinin birden fazla girilmesini
önlemek için de listelerden yararlanabiliyoruz.

Yalnız burada şunu söyleyelim: Gerçek programlarda listelere öğe eklemek veya
listeleri birleştirmek gibi işlemler için yukarıdaki gibi+işlecinden
yararlanmayacağız. Yukarıda gösterdiğimiz yöntem de doğru olmakla birlikte, bu
iş için genellikle liste metotlarından yararlanılır. Bu metotları birazdan
göreceğiz.

#### Listeden Öğe Çıkarmak

Bir listeden öğe silmek içindeladlı ifadeden yararlanabilirsiniz. Örneğin:

```python
>>> liste = [1, 5, 3, 2, 9]
>>> del liste[-1]
>>> liste

[1, 5, 3, 2]

```

#### Listeleri Silmek

Python’da listeleri tamamen silmek de mümkündür. Örneğin:

```python
>>> liste = [1, 5, 3, 2, 9]
>>> del liste
>>> liste

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
NameError: name 'liste' is not defined

```

#### Listeleri Kopyalamak

Diyelim ki, yazdığınız bir programda, varolan bir listeyi kopyalamak, yani aynı
listeden bir tane daha üretmek istiyorsunuz. Mesela elimizde şöyle bir liste
olsun:

```python
>>> li1 = ["elma", "armut", "erik"]

```

Amacımız bu listeden bir tane daha oluşturmak. İlk olarak aklınıza şöyle bir
yöntem gelmiş olabilir:

```python
>>> li2 = li1

```

Gerçekten de bu yöntem bize aynı öğelere sahip iki liste verdi:

```python
>>> print(li1)

["elma", "armut", "erik"]

>>> print(li2)

["elma", "armut", "erik"]

```

Gelin şimdi ilk listemiz olanli1üzerinde bir değişiklik yapalım. Mesela bu
listenin“elma”olan ilk öğesini“karpuz”olarak değiştirelim:

```python
>>> li1[0] = "karpuz"
>>> print(li1)

["karpuz", "armut", "erik"]

```

Gördüğünüz gibi,li1adlı listenin ilk öğesini başarıyla değiştirdik. Şimdi şu
noktada,li2adlı öbür listemizin durumunu kontrol edelim:

```python
>>> print(li2)

["karpuz", "armut", "erik"]

```

O da ne! Biz biraz önceli1üzerinde değişiklik yapmıştık, ama görünüşe göre
bu değişikliktenli2de etkilenmiş. Muhtemelen beklediğiniz şey bu değildi.
Yani sizli2listesinin içeriğinin aynı kalıp, değişiklikten yalnızcali1listesinin etkilenmesini istiyordunuz. Biraz sonra bu isteğinizi nasıl yerine
getirebileceğinizi göstereceğiz. Ama önce dilerseniz, bir liste üzerindeki
değişiklikten öteki listenin de neden etkilendiğini anlamaya çalışalım.

Hatırlarsanız, listelerin değiştirilebilir (mutable) bir veri tipi olduğunu
söylemiştik. Listeler bu özellikleriyle karakter dizilerinden ayrılıyor. Zira
biraz önceli1veli2üzerinde yaptığımız işlemin bir benzerini karakter
dizileri ile yaparsak farklı bir sonuç alırız. Dikkatlice bakın:

```python
>>> a = "elma"

```

Burada, değeri“elma”olanaadlı bir karakter dizisi tanımladık. Şimdi bu
karakter dizisini kopyalayalım:

```python
>>> b = a

>>> a

'elma'

>>> b

'elma'

```

Böylece aynı değere sahip iki farklı karakter dizimiz olmuş oldu.

Şimdiaadlı
karakter dizisi üzerinde değişiklik yapalım. Ama biz biliyoruz ki, bir karakter
dizisini değiştirmenin tek yolu, o karakter dizisini yeniden tanımlamaktır:

```python
>>> a = "E" + a[1:]

>>> a

'Elma'

```

Burada yaptığımız şeyin bir ‘değişiklik’ olmadığına dikkatinizi çekmek isterim.
Çünkü aslında biz burada varolanaadlı değişken üzerinde bir değişiklik
yapmak yerine, yineaadı taşıyan başka bir değişken oluşturuyoruz.

Peki bu ‘değişiklikten’ öbür karakter dizisi etkilendi mi?

```python
>>> b

'elma'

```

Gördüğünüz gibi, bu değişiklik öteki karakter dizisini etkilememiş. Bunun
sebebinin, karakter dizilerinin değiştirilemeyen (immutable) bir veri tipi
olması olduğunu söylemiştik.

Gelin isterseniz bu olgunun derinlerine inelim biraz…

Yukarıdaavebadlı iki değişken var. Bunların kimliklerini kontrol
edelim:

```python
>>> id(a)

15182784

>>> id(b)

15181184

```

Gördüğünüz gibi, bu iki değişken farklı kimlik numaralarına sahip. Bu durumu şu
şekilde de teyit edebileceğimizi biliyorsunuz:

```python
>>> id(a) == id(b)

False

```

Demek ki gerçekten deid(a)ileid(b)birbirinden farklıymış. Yani
aslında biz aynı nesne üzerinde bir değişiklik yapmak yerine, farklı bir nesne
oluşturmuşuz.

Bu sonuç bize, bu iki karakter dizisinin bellekte farklı konumlarda saklandığını
gösteriyor. Dolayısıyla Python, bir karakter dizisini kopyaladığımızda bellekte
ikinci bir nesne daha oluşturuyor. Bu nedenle birbirinden kopyalanan karakter
dizilerinin biri üzerinde yapılan herhangi bir işlem öbürünü etkilemiyor. Ama
listelerde (ve değiştirilebilir bütün veri tiplerinde) durum farklı. Şimdi şu
örneklere dikkatlice bakın:

```python
>>> liste1 = ["ahmet", "mehmet", "özlem"]

```

Bu listeyi kopyalayalım:

```python
>>> liste2 = liste1

```

Elimizde aynı öğelere sahip iki liste var:

```python
>>> liste1

['ahmet', 'mehmet', 'özlem']

>>> liste2

['ahmet', 'mehmet', 'özlem']

```

Bu listelerin kimlik numaralarını kontrol edelim:

```python
>>> id(liste1)

14901376

>>> id(liste2)

14901376

>>> id(liste1) == id(liste2)

True

```

Gördüğünüz gibi,liste1veliste2adlı listeler aynı kimlik numarasına
sahip. Yani bu iki nesne birbiriyle aynı. Dolayısıyla birinde yaptığınız
değişiklik öbürünü de etkiler. Eğer birbirinden kopyalanan listelerin birbirini
etkilemesini istemiyorsanız, önünüzde birkaç seçenek var.

İlk seçeneğe göre şöyle bir kod yazabilirsiniz:

Önce özgün listemizi oluşturalım:

```python
>>> liste1 = ["ahmet", "mehmet", "özlem"]

```

Şimdi bu listeyi kopyalayalım:

```python
>>> liste2 = liste1[:]

```

Buradaliste1’i kopyalarken, listeyi baştan sona dilimlediğimize dikkat edin.

Bakalımliste1’deki değişiklik öbürünü de etkiliyor mu:

```python
>>> liste1[0] = "veli"
>>> liste1

['veli', 'mehmet', 'özlem']

>>> liste2

['ahmet', 'mehmet', 'özlem']

```

Gördüğünüz gibi,liste1’de yaptığımız değişiklikliste2’ye yansımadı. Demek
ki yöntemimiz işe yaramış.

Aynı işi yapmak için kullanabileceğimiz ikinci yöntem iselist()fonksiyonunu kullanmaktır:

Önce özgün listemizi görelim:

```python
>>> liste1 = ["ahmet", "mehmet", "özlem"]

```

Şimdi bu listeyi kopyalayalım:

```python
>>> liste2 = list(liste1)

```

Artık elimizde birbirinin kopyası durumunda iki farklı liste var:

```python
>>> liste2

['ahmet', 'mehmet', 'özlem']

>>> liste1

['ahmet', 'mehmet', 'özlem']

```

Şimdiliste2üzerinde bir değişiklik yapalım:

```python
>>> liste2[0] = 'veli'

```

liste2’yi kontrol edelim:

```python
>>> liste2

['veli', 'mehmet', 'özlem']

```

Bakalımliste1bu değişiklikten etkilenmiş mi:

```python
>>> liste1

['ahmet', 'mehmet', 'özlem']

```

Gördüğünüz gibi, her şey yolunda. Dilerseniz bu nesnelerin birbirinden farklı
olduğunuid()fonksiyonu aracılığıyla teyit edebileceğinizi biliyorsunuz.

Listeleri kopyalamanın üçüncü bir yöntemi daha var. Bu yöntemi de bir sonraki
bölümde liste metotlarını incelerken ele alacağız.

#### Liste Üreteçleri (List Comprehensions)

Şimdi Python’daki listelere ilişkin çok önemli bir konuya değineceğiz. Bu
konunun adı ‘liste üreteçleri’. İngilizce’de buna “List Comprehension” adı
veriliyor.

Adından da anlaşılacağı gibi, liste üreteçlerinin görevi liste üretmektir. Basit
bir örnek ile liste üreteçleri konusuna giriş yapalım:

```python
liste = [i for i in range(1000)]

```

Burada 0’dan 1000’e kadar olan sayıları tek satırda bir liste haline getirdik.
Bu kodların söz dizimine çok dikkat edin. Aslında yukarıdaki kod şu şekilde de
yazılabilir:

```python
liste = []

for i in range(1000):
 liste += [i]

```

Burada öncelisteadlı boş bir liste tanımladık. Daha sonra 0 ile 1000
aralığında bütün sayıları bu boş listeye teker teker gönderdik. Böylece elimizde
0’dan 1000’e kadar olan sayıları tutan bir liste olmuş oldu. Aynı iş için liste
üreteçlerini kullandığımızda ise bu etkiyi çok daha kısa bir yoldan halletmiş
oluyoruz. Liste üreteçlerini kullandığımız kodu tekrar önümüze alalım:

```python
liste = [i for i in range(1000)]

```

Gördüğünüz gibi, burada önceden boş bir liste tanımlamamıza gerek kalmadı.
Ayrıca bu kodlardafordöngüsünün parantezler içine alınarak nasıl
sadeleştirildiğine de dikkatinizi çekmek isterim. Şu kod:

```python
for i in range(1000):
 liste += [i]

```

Liste üreteçlerini kullandığımızda şu koda dönüşüyor:

```python
[i for i in range(1000)]

```

Pek çok durumda liste üreteçleri öbür seçeneklere kıyasla bir alternatif olma
işlevi görür. Yani liste üreteçleri ile elde edeceğiniz sonucu başka araçlarla
da elde edebilirsiniz. Mesela yukarıdaki kodların yaptığı işlevi yerine getirmek
için başka bir seçenek olaraklist()fonksiyonundan da yararlanabileceğimizi
biliyorsunuz:

```python
liste = list(range(1000))

```

Bu basit örneklerde liste üreteçlerini kullanmanın erdemi pek göze çarpmıyor.
Ama bazı durumlarda liste üreteçleri öteki alternatiflere kıyasla çok daha
pratik bir çözüm sunar. Böyle durumlarda başka seçeneklere başvurup yolunuzu
uzatmak yerine liste üreteçlerini kullanarak işinizi kısa yoldan
halledebilirsiniz.

Örneğin 0 ile 1000 arasındaki çift sayıları listelemek için liste üreteçlerini
kullanmak, alternatiflerine göre daha makul bir tercih olabilir:

```python
liste = [i for i in range(1000) if i % 2 == 0]

```

Aynı işifordöngüsü ile yapmak için şöyle bir kod yazmamız gerekir:

```python
liste = []
for i in range(1000):
 if i % 2 == 0:
 liste += [i]

```

Gördüğünüz gibi, liste üreteçleri bize aynı işi daha kısa bir yoldan halletme
imkanı tanıyor. Bu aradafordöngüsünün ve bu döngü içinde yer alanifdeyiminin liste üreteçleri içinde nasıl göründüğüne dikkat ediyoruz.

Liste üreteçleri ile ilgili bir örnek daha verelim. Mesela elinizde şöyle bir
liste olduğunu düşünün:

```python
liste = [[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
 [10, 11, 12]]

```

Burada iç içe geçmiş 4 adet liste var. Bu listenin bütün öğelerini tek bir
listeye nasıl alabiliriz? Yani şöyle bir çıktıyı nasıl elde ederiz?

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

```

fordöngülerini kullanarak şöyle bir kod yazabiliriz:

```python
liste = [[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
 [10, 11, 12]]

tümü = []

for i in liste:
 for z in i:
 tümü += [z]

print(tümü)

```

Liste üreteçleri ise daha kısa bir çözüm sunar:

```python
liste = [[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
 [10, 11, 12]]

tümü = [z for i in liste for z in i]
print(tümü)

```

Bu liste üreteci gerçekten de bize kısa bir çözüm sunuyor, ama bu tip iç içe
geçmişfordöngülerinden oluşan liste üreteçlerinde bazen okunaklılık sorunu
ortaya çıkabilir. Yani bu tür iç içe geçmişfordöngülerinden oluşan liste
üreteçlerini anlamak, alternatif yöntemlere göre daha zor olabilir.

Bazı durumlarda ise liste üreteçleri bir sorunun çözümü için tek makul yol
olabilir. Diyelim ki bir X.O.X Oyunu (Tic Tac Toe) yazıyorsunuz. Bu oyunda
oyuncular oyun tahtası üzerine X veya O işaretlerinden birini yerleştirecek.
Oyuncunun bu oyunu kazanabilmesi için, X veya O işaretlerinden birisinin oyun
tahtası üzerinde belli konumlarda bulunması gerekiyor. Yani mesela X işaretinin
oyunu kazanabilmesi için bu işaretin oyun tahtası üzerinde şu şekilde bir
dizilime sahip olması gerekir:

```python
 O X O

___ X O

___ X ___

```

Bu dizilime göre oyunu X işareti kazanır. Peki X işaretinin, oyunu kazanmasını
sağlayacak bu dizilime ulaştığını nasıl tespit edeceksiniz?

Bunun için öncelikle oyun tahtası üzerinde hangi dizilim şekillerinin galibiyeti
getireceğini gösteren bir liste hazırlayabilirsiniz. Mesela yukarıdaki gibi 3x3
boyutundaki bir oyun tahtasında X işaretinin oyunu kazanabilmesi için şu
dizilimlerden herhangi birine sahip olması gerekir:

```python
[0, 0], [1, 0], [2, 0]

 X ___ ___

 X ___ ___

 X ___ ___

[0, 1], [1, 1], [2, 1]

 ___ X ___

 ___ X ___

 ___ X ___

[0, 2], [1, 2], [2, 2]

 ___ ___ X

 ___ ___ X

 ___ ___ X

[0, 0], [0, 1], [0, 2]

 X X X
___ ___ ___

___ ___ ___

[1, 0], [1, 1], [1, 2]

___ ___ ___

 X X X
___ ___ ___

[2, 0], [2, 1], [2, 2]

___ ___ ___

___ ___ ___

 X X X

[0, 0], [1, 1], [2, 2]

 X ___ ___

 ___ X ___

 ___ ___ X

 [0, 2], [1, 1], [2, 0]

 ___ ___ X

 ___ X ___

 X ___ ___

```

Aynı dizilimler O işareti için de geçerlidir. Dolayısıyla bu kazanma ölçütlerini
şöyle bir liste içinde toplayabilirsiniz:

```python
kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]],
 [[0, 1], [1, 1], [2, 1]],
 [[0, 2], [1, 2], [2, 2]],
 [[0, 0], [0, 1], [0, 2]],
 [[1, 0], [1, 1], [1, 2]],
 [[2, 0], [2, 1], [2, 2]],
 [[0, 0], [1, 1], [2, 2]],
 [[0, 2], [1, 1], [2, 0]]]

```

Oyun sırasında X veya O işaretlerinin aldığı konumu bu kazanma ölçütleri ile
karşılaştırarak oyunu kimin kazandığını tespit edebilirsiniz. Yanikazanma_ölçütleriadlı liste içindeki, iç içe geçmiş listelerden herhangi biri
ile oyunun herhangi bir aşamasında tamamen eşleşen işaret, oyunu kazanmış
demektir.

Bir sonraki bölümde bu bahsettiğimiz X.O.X Oyununu yazacağız. O zaman bu sürecin
nasıl işlediğini daha ayrıntılı bir şekilde inceleyeceğiz. Şimdilik yukarıdaki
durumu temsil eden basit bir örnek vererek liste üreteçlerinin kullanımını
incelemeye devam edelim.

Örneğin elinizde, yukarıda bahsettiğimiz kazanma ölçütlerini temsil eden şöyle
bir liste olduğunu düşünün:

```python
liste1 = [[1, 2, 3],
 [4, 5, 6],
 [7, 8, 9],
 [10, 11, 12],
 [13, 14, 15],
 [16, 17, 18],
 [19, 20, 21],
 [22, 23, 24],
 [25, 26, 27],
 [28, 29, 30],
 [31, 32, 33]]

```

Bir de şöyle bir liste:

```python
liste2 = [1, 27, 88, 98, 50, 9, 28, 45, 54, 66, 61, 23, 10, 33,
 22, 12, 6, 99, 63, 26, 87, 25, 77, 5, 16, 93, 99, 44,
 59, 69, 34, 10, 60, 92, 61, 44, 5, 3, 23, 99, 79, 51,
 89, 63, 53, 31, 76, 41, 49, 10, 88, 63, 55, 43, 40, 71,
 16, 49, 78, 41, 35, 97, 33, 76, 25, 81, 15, 99, 64, 20,
 33, 6, 89, 81, 44, 53, 59, 75, 27, 15, 64, 36, 72, 78,
 34, 36, 20, 41, 41, 75, 56, 30, 86, 46, 9, 42, 21, 64,
 26, 52, 77, 65, 64, 12, 38, 1, 35, 20, 73, 71, 37, 35,
 72, 38, 100, 52, 16, 49, 79]

```

Burada amacınızliste1içinde yer alan iç içe geçmiş listelerden hangisininliste2içindeki sayıların alt kümesi olduğunu, yaniliste2içindeki
sayıların,liste1içindeki üçlü listelerden hangisiyle birebir eşleştiğini
bulmak. Bunun için şöyle bir kod yazabiliriz:

```python
for i in liste1:
 ortak = [z for z in i if z in liste2]
 if len(ortak) == len(i):
 print(i)

```

Bu kodlar ilk bakışta gözünüze çok karmaşık gelmiş olabilir. Ama aslında hiç de
karmaşık değildir bu kodlar. Şimdi bu kodları Türkçe’ye çevirelim:

1. satır:liste1adlı listedeki her bir öğeyeiadını verelim

2. satır:iiçindeki,liste2’de de yer alan her bir öğeye dezadını verelim ve
bunlarıortakadlı bir listede toplayalım.

3. satır: eğerortakadlı listenin uzunluğuideğişkeninin uzunluğu ile aynıysa

4. satır:i’yi ekrana basalım ve böylece alt kümeyi bulmuş olalım.

Eğer bu satırları anlamakta zorluk çekiyorsanız okumaya devam edin. Biraz sonra
vereceğimiz örnek programda da bu kodları görecek ve bu kodların ne işe
yaradığını orada daha iyi anlayacaksınız.

#### Örnek Program: X.O.X Oyunu

Şu ana kadar Python programlama dili hakkında epey bilgi edindik. Buraya kadar
öğrendiklerimizi kullanarak işe yarar programlar yazabiliyoruz. Belki
farkındasınız, belki de değilsiniz, ama özellikle listeler konusunu öğrenmemiz
bize çok şey kazandırdı.

Bir önceki bölümde, bir X.O.X Oyunu yazacağımızdan söz etmiş ve bu oyunun
Python’la nasıl yazılabileceğine dair bazı ipuçları da vermiştik. İşte bu
bölümde, Python programlama dilinde şimdiye kadar öğrendiklerimizi kullanarak bu
oyunu yazacağız.

Yazacağımız oyunun İngilizce adıTic Tac Toe. Bu oyunun ne olduğunu ve
kurallarını bir önceki bölümde kabataslak bir şekilde vermiştik. Eğer isterseniz
oyun kurallarınawikipedia.org/wiki/Çocuk_oyunları#X_O_X_OYUNUadresinden de
bakabilirsiniz.

Oyunu ve kurallarını bildiğinizi varsayarak kodlamaya başlayalım.

Burada ilk yapmamız gereken şey, üzerinde oyun oynanacak tahtayı çizmek olmalı.
Amacımız şöyle bir görüntü elde etmek:

```python
___ ___ ___

___ ___ ___

___ ___ ___

```

Bu tahtada oyuncu soldan sağa ve yukarıdan aşağıya doğru iki adet konum bilgisi
girecek ve oyunu oynayan kişinin gireceği bu konumlara “X” ve “O” harfleri
işaretlenecek.

Böyle bir görüntü oluşturmak için pek çok farklı yöntem kullanılabilir. Ama
oyuncunun her konum bilgisi girişinde, X veya O işaretini tahta üzerinde
göstereceğimiz için tahta üzerinde oyun boyunca sürekli birtakım değişiklikler
olacak. Bildiğiniz gibi karakter dizileri, üzerinde değişiklik yapmaya müsait
bir veri tipi değil. Böyle bir görev için listeler daha uygun bir araç
olacaktır. O yüzden tahtayı oluşturmada listeleri kullanmayı tercih edeceğiz.

```python
tahta = [["___", "___", "___"],
 ["___", "___", "___"],
 ["___", "___", "___"]]

```

Gördüğünüz gibi, burada iç içe geçmiş üç adet listeden oluşan bir liste var.print(tahta)komutunu kullanarak bu listeyi ekrana yazdırırsanız listenin
yapısı daha belirgin bir şekilde ortaya çıkacaktır:

```python
[['___', '___', '___'], ['___', '___', '___'], ['___', '___', '___']]

```

Oyun tahtasını oluşturduğumuza göre, şimdi yapmamız gereken şey bu oyun
tahtasını düzgün bir şekilde oyuncuya göstermek olmalı. Dediğimiz gibi, oyuncu
şöyle bir çıktı görmeli:

```python
___ ___ ___

___ ___ ___

___ ___ ___

```

Bu görüntüyü elde etmek için şu kodları yazıyoruz:

```python
print("\n"*15)

for i in tahta:
 print("\t".expandtabs(30), *i, end="\n"*2)

```

Bu kodlarda bilmediğiniz hiçbir şey yok. Burada gördüğünüz her şeyi önceki
derslerde öğrenmiştiniz.

Yukarıdaki kodları yazarken tamamen, elde etmek istediğimiz görüntüye
odaklanıyoruz. Meselaprint("\n"*15)kodunu yazmamızın nedeni, oyun tahtası
için ekranda boş bir alan oluşturmak. Bu etkiyi elde etmek için 15 adet yeni
satır karakteri bastık ekrana. Bu kodla elde edilen etkiyi daha iyi görebilmek
için bu kodu programdan çıkarmayı deneyebilirsiniz.

Alttaki satırda ise birfordöngüsü tanımladık. Bu döngünün amacıtahtaadlı listedeki “__” öğelerini düzgün bir şekilde oyuncuya gösterebilmek. Oyun
tahtasının, ekranı (yaklaşık olarak da olsa) ortalamasını istiyoruz. O yüzden,
tahta öğelerine soldan girinti verebilmek içinprint()fonksiyonunun ilk
parametresini"\t".expandtabs(30)şeklinde yazdık. Karakter dizilerininexpandtabs()adlı metodunu önceki derslerimizden hatırlıyor olmalısınız. Bu
metodu kullanarak sekme (TAB) karakterlerini genişletebiliyorduk. Burada da
“\t” karakterini bu metot yardımıyla genişleterek liste öğelerini sol baştan
girintiledik.

print()fonksiyonunun ikinci parametresi ise*i. Bu parametrenin ne iş
yaptığını anlamak için şöyle bir kod yazalım:

```python
tahta = [["___", "___", "___"],
 ["___", "___", "___"],
 ["___", "___", "___"]]

for i in tahta:
 print(i)

```

Bu kodları çalıştırdığımızda şöyle bir çıktı elde ederiz:

```python
['___', '___', '___']
['___', '___', '___']
['___', '___', '___']

```

Gördüğünüz gibi, iç içe geçmiş üç adet listeden oluşantahtaadlı liste
içindeki bu iç listeler ekrana döküldü. Bir de şuna bakın:

```python
tahta = [["___", "___", "___"],
 ["___", "___", "___"],
 ["___", "___", "___"]]

for i in tahta:
 print(*i)

```

Bu kodlar çalıştırıldığında şu çıktıyı verir:

```python
___ ___ ___
___ ___ ___
___ ___ ___

```

Bu defa liste yapısını değil, listeyi oluşturan öğelerin kendisini görüyoruz.
Yıldız işaretinin, birlikte kullanıldığı öğeler üzerinde nasıl bir etkiye sahip
olduğunu yine önceki derslerimizden hatırlıyorsunuz. Mesela şu örneğe bakın:

```python
kardiz = "istihza"

for i in kardiz:
 print(i, end=" ")
print()

```

Bu kodlar şu çıktıyı veriyor:

```python
i s t i h z a

```

Aynı çıktıyı basitçe şu şekilde de elde edebileceğimizi biliyorsunuz:

```python
kardiz = "istihza"
print(*kardiz)

```

İşte oyun tahtasını ekrana dökmek için kullandığımız kodda da benzer bir şey
yaptık. Yıldız işareti yardımıyla,tahtaadlı listeyi oluşturan iç içe geçmiş
listeleri liste dışına çıkarıp düzgün bir şekilde kullanıcıya gösterdik.

print()fonksiyonu içindeki son parametremiz şu:end="\n"*2

Bu parametrenin ne işe yaradığını kolaylıkla anlayabildiğinizi zannediyorum. Bu
parametre de istediğimiz çıktıyı elde etmeye yönelik bir çabadan ibarettir.tahtaadlı liste içindeki iç içe geçmiş listelerin her birinin sonuna ikişer
adet “\n” karakteri yerleştirerek, çıktıdaki satırlar arasında yeterli miktarda
aralık bıraktık. Eğer oyun tahtasındaki satırların biraz daha aralıklı olmasını
isterseniz bu parametredeki 2 çarpanını artırabilirsiniz. Mesela:end="\n"*3

Şimdi yapmamız gereken şey, oyundaki kazanma ölçütlerini belirlemek.
Hatırlarsanız bu konuya bir önceki bölümde değinmiştik. O yüzden aşağıda
söyleyeceklerimizin bir bölümüne zaten aşinasınız. Burada önceden söylediğimiz
bazı şeylerin yeniden üzerinden geçeceğiz.

Dediğim gibi, kodların bu bölümünde, hangi durumda oyunun biteceğini ve
kazananın kim olacağını tespit edebilmemiz gerekiyor. Mesela oyun sırasında
şöyle bir görüntü ortaya çıkarsa hemen oyunu durdurup “O KAZANDI!” gibi bir
çıktı verebilmemiz lazım:

```python
 O O O

___ X X

___ ___ ___

```

Veya şöyle bir durumda “X KAZANDI!” diyebilmeliyiz:

```python
X O ___

X O O

X ___ ___

```

Yukarıdaki iki örnek üzerinden düşünecek olursak, herhangi bir işaretin şu
konumlarda bulunması o işaretin kazandığını gösteriyor:

```python
yukarıdan aşağıya 0; soldan sağa 0
yukarıdan aşağıya 1; soldan sağa 0
yukarıdan aşağıya 2; soldan sağa 0

```

veya:

```python
yukarıdan aşağıya 0; soldan sağa 0
yukarıdan aşağıya 0; soldan sağa 1
yukarıdan aşağıya 0; soldan sağa 2

```

İşte bizim yapmamız gereken şey, bir işaretin oyun tahtası üzerinde hangi
konumlarda bulunması halinde oyunun biteceğini tespit etmek. Yukarıdaki
örnekleri göz önüne alarak bunun için şöyle bir liste hazırlayabiliriz:

```python
kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]],
 [[0, 0], [0, 1], [0, 2]]]

```

Burada iki adet listeden oluşan,kazanma_ölçütleriadlı bir listemiz var.
Liste içinde, her biri üçer öğeden oluşan şu listeleri görüyoruz:

```python
[[0, 0], [1, 0], [2, 0]]
[[0, 0], [0, 1], [0, 2]]

```

Bu listeler de kendi içinde ikişer öğeli bazı listelerden oluşuyor. Mesela ilk
liste içinde şu listeler var:

```python
[0, 0], [1, 0], [2, 0]

```

İkinci liste içinde ise şu listeler:

```python
[0, 0], [0, 1], [0, 2]

```

Burada her bir liste içindeki ilk sayı oyun tahtasında yukarıdan aşağıya doğru
olan düzlemi; ikinci sayı ise soldan sağa doğru olan düzlemi gösteriyor.

Tabii ki oyun içindeki tek kazanma ölçütü bu ikisi olmayacak. Öteki kazanma
ölçütlerini de tek tek tanımlamalıyız:

```python
kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]],
 [[0, 1], [1, 1], [2, 1]],
 [[0, 2], [1, 2], [2, 2]],
 [[0, 0], [0, 1], [0, 2]],
 [[1, 0], [1, 1], [1, 2]],
 [[2, 0], [2, 1], [2, 2]],
 [[0, 0], [1, 1], [2, 2]],
 [[0, 2], [1, 1], [2, 0]]]

```

İşte X veya O işaretlerikazanma_ölçütleriadlı listede belirtilen
koordinatlarda bulunduğunda, ilgili işaretin oyunu kazandığını ilan edip oyundan
çıkabileceğiz.

Yukarıdaki açıklamalardan da anlayacağınız gibi, X ve O işaretlerinin oyun
tahtasındaki konumu, oyunun gidişatı açısından önem taşıyor. O yüzden şu şekilde
iki farklı liste daha tanımlamamızda fayda var:

```python
x_durumu = []
o_durumu = []

```

Bu değişkenler sırasıyla X işaretinin ve O işaretinin oyun içinde aldıkları
konumları kaydedecek. Bu konumlarla, bir önceki adımda tanımladığımız kazanma
ölçütlerini karşılaştırarak oyunu kimin kazandığını tespit edebileceğiz.

Gördüğünüz gibi, oyunda iki farklı işaret var: X ve O. Dolayısıyla oynama sırası
sürekli olarak bu iki işaret arasında değişmeli. Mesela oyuna 0 işareti ile
başlanacaksa, 0 işaretinin yerleştirilmesinden sonra sıranın X işaretine geçmesi
gerekiyor. X işareti de yerleştirildikten sonra sıra tekrar 0 işaretine geçmeli
ve oyun süresince bu böyle devam edebilmeli.

Bu sürekliliği sağlamak için şöyle bir kod yazabiliriz:

```python
sıra = 1

while True:
 if sıra % 2 == 0:
 işaret = "X".center(3)
 else:
 işaret = "O".center(3)

 sıra += 1

 print()
 print("İŞARET: {}\n".format(işaret))

```

Burada sayıların tek veya çift olma özelliğinden yararlanarak X ve O işaretleri
arasında geçiş yaptık. Öncesıraadlı bir değişken tanımlayıp bunun değerini 1
olarak belirledik.whiledöngüsünde ise bu değişkenin değerini her defasında 1
artırdık. Eğer sayının değeri çiftse işaret X; tekse O olacak. Bu arada X ve O
adlı karakter dizilerini,center()metodu yardımıyla ortaladığımıza dikkat
edin.

Yukarıdaki kodları bu şekilde çalıştırdığınızda X ve O harflerinin çok hızlı bir
şekilde ekrandan geçtiğini göreceksiniz. Eğer ekranda son hız akıp giden bu
verileri yavaşlatmak ve neler olup bittiğini daha net görmek isterseniz
yukarıdaki kodları şöyle yazabilirsiniz:

```python
from time import sleep

sıra = 1

while True:
 if sıra % 2 == 0:
 işaret = "X".center(3)
 else:
 işaret = "O".center(3)
 sıra += 1

 print()
 print("İŞARET: {}\n".format(işaret))
 sleep(0.3)

```

Bu kodlarda henüz öğrenmediğimiz parçalar var. Ama şimdilik bu bilmediğiniz
parçalara değil, sonuca odaklanın. Burada yaptığımız şey,whiledöngüsü içinde
her birprint()fonksiyonu arasına 0.3 saniyelik duraklamalar eklemek.
Böylece programın akışı yavaşlamış oluyor. Biz deişaretdeğişkeninin her
döngüde bir X, bir O oluşunu daha net bir şekilde görebiliyoruz.

> **Not**
> Asıl program içinde X ve O karakterlerinin geçişini özellikle
yavaşlatmamıza gerek kalmayacak. Programın ilerleyen satırlarındainput()fonksiyonu yardımıyla kullanıcıdan veri girişi isteyeceğimiz için X ve O’ların
akışı zaten doğal olarak duraklamış olacak.

Not

Asıl program içinde X ve O karakterlerinin geçişini özellikle
yavaşlatmamıza gerek kalmayacak. Programın ilerleyen satırlarındainput()fonksiyonu yardımıyla kullanıcıdan veri girişi isteyeceğimiz için X ve O’ların
akışı zaten doğal olarak duraklamış olacak.

whiledöngümüzü yazmaya devam edelim:

```python
x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30))
if x == "q":
 break

y = input("soldan sağa [1, 2, 3]: ".ljust(30))
if y == "q":
 break

x = int(x)-1
y = int(y)-1

```

Burada X veya O işaretlerini tahta üzerinde uygun yerlere yerleştirebilmek için
kullanıcının konum bilgisi girmesini istiyoruz.xdeğişkeni yukarıdan aşağıya
doğru olan düzlemdeki konumu,ydeğişkeni ise soldan sağa doğru olan
düzlemdeki konumu depolayacak. Oyunda kullanıcının girebileceği değerler 1, 2
veya 3 olacak. Mesela oyuncu O işareti için yukarıdan aşağıya 1; soldan sağa 2
değerini girmişse şöyle bir görüntü elde edeceğiz:

```python
___ O ___

___ ___ ___

___ ___ ___

```

Buradaljust()metotlarını, kullanıcıya gösterilecek verinin düzgün bir
şekilde hizalanması amacıyla kullandık.

Eğer kullanıcıxveyaydeğişkenlerinden herhangi birine “q” cevabı verirse
oyundan çıkıyoruz.

Yukarıdaki kodların son iki satırında ise kullanıcıdan gelen karakter dizilerini
birer sayıya dönüştürüyoruz. Bu arada, bildiğiniz gibi Python saymaya 0’dan
başlıyor. Ama insanlar açısından doğal olan saymaya 1’den başlamaktır. O yüzden
mesela kullanıcı 1 sayısını girdiğinde Python’ın bunu 0 olarak algılamasını
sağlamamız gerekiyor. Bunun için x ve y değerlerinden 1 çıkarıyoruz.

Kullanıcıdan gerekli konum bilgilerini aldığımıza göre, bu bilgilere dayanarak X
ve O işaretlerini oyun tahtası üzerine yerleştirebiliriz. Şimdi şu kodları
dikkatlice inceleyin:

```python
print("\n"*15)

if tahta[x][y] == "___":
 tahta[x][y] = işaret
 if işaret == "X".center(3):
 x_durumu += [[x, y]]
 elif işaret == "O".center(3):
 o_durumu += [[x, y]]
 sıra += 1
else:
 print("\nORASI DOLU! TEKRAR DENEYİN\n")

```

Burada öncelikle15adet satır başı karakteri basıyoruz. Böylece oyun tahtası
için ekranda boş bir alan oluşturmuş oluyoruz. Bu satır tamamen güzel bir
görüntü elde etmeye yönelik bir uygulamadır. Yani bu satırı yazmasanız da
programınız çalışır. Veya siz kendi zevkinize göre daha farklı bir görünüm elde
etmeye çalışabilirsiniz.

İkinci satırda gördüğümüziftahta[x][y]=="___":kodu, oyun tahtası
üzerindeki bir konumun halihazırda boş mu yoksa dolu mu olduğunu tespit etmemizi
sağlıyor. Amacımız oyuncunun aynı konuma iki kez giriş yapmasını engellemek.
Bunun için tahta üzerinde x ve y konumlarına denk gelen yerde “___” işaretinin
olup olmadığına bakmamız yeterli olacaktır. Eğer bakılan konumda “___” işareti
varsa orası boş demektir. O konuma işaret koyulabilir. Ama eğer o konumda “___”
işareti yoksa X veya O işaretlerinden biri var demektir. Dolayısıyla o konuma
işaret koyulamaz. Böyle bir durumda kullanıcıya “ORASI DOLU! TEKRAR DENEYİN”
uyarısını gösteriyoruz.

Oyun tahtası üzerinde değişiklik yapabilmek için nasıl bir yol izlediğimize
dikkat edin:

```python
tahta[x][y] = işaret

```

Mesela oyuncu yukarıdan aşağıya 1; soldan sağa 2 sayısını girmişse, kullanıcıdan
gelen sayılardan 1 çıkardığımız için, Python yukarıdaki kodu şöyle
değerlendirecektir:

```python
tahta[0][1] = işaret

```

Yanitahtaadlı liste içindeki ilk listenin ikinci sırasına ilgili işaret
yerleştirilecektir.

Ayrıca yukarıdaki kodlarda şu satırları da görüyoruz:

```python
if işaret == "X".center(3):
 x_durumu += [[x, y]]
elif işaret == "O".center(3):
 o_durumu += [[x, y]]

```

Eğer işaret sırası X’te ise oyuncunun girdiği konum bilgilerinix_durumuadlı
değişkene, eğer işaret sırası O’da ise konum bilgilerinio_durumuadlı
değişkene yolluyoruz. Oyunu hangi işaretin kazandığını tespit edebilmemiz
açısından bu kodlar büyük önem taşıyor.x_durumuveo_durumudeğişkenlerinikazanma_ölçütleriadlı liste ile karşılaştırarak oyunu kimin kazandığına karar
vereceğiz.

Bu arada, oyunun en başında tanımladığımızsıraadlı değişkeniifbloğu
içinde artırdığımıza dikkat edin. Bu sayede, kullanıcının yanlışlıkla aynı
konuma iki kez işaret yerleştirmeye çalışması halinde işaret sırası
değişmeyecek. Yani mesela o anda sıra X’te ise ve oyuncu yanlış bir konum
girdiyse sıra yine X’te olacak. Eğersıradeğişkeniniifbloğu içine
yazmazsak, yanlış konum girildiğinde işaret sırası O’a geçecektir.

İsterseniz şimdiye kadar yazdığımız kodları şöyle bir topluca görelim:

```python
tahta = [["___", "___", "___"],
 ["___", "___", "___"],
 ["___", "___", "___"]]

print("\n"*15)

for i in tahta:
 print("\t".expandtabs(30), *i, end="\n"*2)

kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]],
 [[0, 1], [1, 1], [2, 1]],
 [[0, 2], [1, 2], [2, 2]],
 [[0, 0], [0, 1], [0, 2]],
 [[1, 0], [1, 1], [1, 2]],
 [[2, 0], [2, 1], [2, 2]],
 [[0, 0], [1, 1], [2, 2]],
 [[0, 2], [1, 1], [2, 0]]]

x_durumu = []
o_durumu = []

sıra = 1
while True:
 if sıra % 2 == 0:
 işaret = "X".center(3)
 else:
 işaret = "O".center(3)

 print()
 print("İŞARET: {}\n".format(işaret))

 x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30))
 if x == "q":
 break

 y = input("soldan sağa [1, 2, 3]: ".ljust(30))
 if y == "q":
 break

 x = int(x)-1
 y = int(y)-1

 print("\n"*15)

 if tahta[x][y] == "___":
 tahta[x][y] = işaret
 if işaret == "X".center(3):
 x_durumu += [[x, y]]
 elif işaret == "O".center(3):
 o_durumu += [[x, y]]
 sıra += 1
 else:
 print("\nORASI DOLU! TEKRAR DENEYİN\n")

```

Gördüğünüz gibi epey kod yazmışız. Kodlarımızı topluca incelediğimize göre
yazmaya devam edebiliriz:

```python
for i in tahta:
 print("\t".expandtabs(30), *i, end="\n"*2)

```

Bu kodların ne işe yaradığınız biliyorsunuz. Oyun tahtasının son durumunu
kullanıcıya göstermek için kullanıyoruz bu kodları.

Sıra geldi oyunun en önemli kısmına. Bu noktada oyunu kimin kazandığını
belirlememiz gerekiyor. Dikkatlice inceleyin:

```python
for i in kazanma_ölçütleri:
 o = [z for z in i if z in o_durumu]
 x = [z for z in i if z in x_durumu]
 if len(o) == len(i):
 print("O KAZANDI!")
 quit()
 if len(x) == len(i):
 print("X KAZANDI!")
 quit()

```

Bu kodları anlayabilmek için en iyi yol uygun yerlereprint()fonksiyonları
yerleştirerek çıktıları incelemektir. Mesela bu kodları şöyle yazarakovexdeğişkenlerinin değerlerini izleyebilirsiniz:

```python
for i in kazanma_ölçütleri:
 o = [z for z in i if z in o_durumu]
 x = [z for z in i if z in x_durumu]
 print("o: ", o)
 print("x: ", x)
 if len(o) == len(i):
 print("O KAZANDI!")
 quit()
 if len(x) == len(i):
 print("X KAZANDI!")
 quit()

```

Bu kodlar içindeki en önemli öğelerovexadlı değişkenlerdir. Burada,o_durumuveyax_durumuadlı listelerdeki değerlerlekazanma_ölçütleriadlı
listedeki değerleri karşılaştırarak, ortak değerlerioveyaxdeğişkenlerine
yolluyoruz. Eğer ortak öğe sayısı 3’e ulaşırsa (iflen(o)==len(i):veyaiflen(x)==len(i):), bu sayıyı yakalayan ilk işaret hangisiyse oyunu o
kazanmış demektir.

Kodlarımızın son hali şöyle oldu:

```python
tahta = [["___", "___", "___"],
 ["___", "___", "___"],
 ["___", "___", "___"]]

print("\n"*15)

for i in tahta:
 print("\t".expandtabs(30), *i, end="\n"*2)

kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]],
 [[0, 1], [1, 1], [2, 1]],
 [[0, 2], [1, 2], [2, 2]],
 [[0, 0], [0, 1], [0, 2]],
 [[1, 0], [1, 1], [1, 2]],
 [[2, 0], [2, 1], [2, 2]],
 [[0, 0], [1, 1], [2, 2]],
 [[0, 2], [1, 1], [2, 0]]]

x_durumu = []
o_durumu = []

sıra = 1
while True:
 if sıra % 2 == 0:
 işaret = "X".center(3)
 else:
 işaret = "O".center(3)

 print()
 print("İŞARET: {}\n".format(işaret))

 x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30))
 if x == "q":
 break

 y = input("soldan sağa [1, 2, 3]: ".ljust(30))
 if y == "q":
 break

 x = int(x)-1
 y = int(y)-1

 print("\n"*15)

 if tahta[x][y] == "___":
 tahta[x][y] = işaret
 if işaret == "X".center(3):
 x_durumu += [[x, y]]
 elif işaret == "O".center(3):
 o_durumu += [[x, y]]
 sıra += 1
 else:
 print("\nORASI DOLU! TEKRAR DENEYİN\n")

 for i in tahta:
 print("\t".expandtabs(30), *i, end="\n"*2)

 for i in kazanma_ölçütleri:
 o = [z for z in i if z in o_durumu]
 x = [z for z in i if z in x_durumu]

 if len(o) == len(i):
 print("O KAZANDI!")
 quit()
 if len(x) == len(i):
 print("X KAZANDI!")
 quit()

```

Gördüğünüz gibi, sadece şu ana kadar öğrendiğimiz bilgileri kullanarak bir oyun
yazabilecek duruma geldik. Burada küçük parçaları birleştirerek bir bütüne nasıl
ulaştığımızı özellikle görmenizi isterim. Dikkat ederseniz, yukarıdaki programda
sadece karakter dizileri, sayılar, listeler ve birkaç fonksiyon var. Nasıl
sadece 7 nota ile müzik şaheserleri meydana getirilebiliyorsa, yalnızca 4-5 veri
tipi ile de dünyayı ayağa kaldıracak programlar da yazılabilir.

Listeleri temel olarak incelediğimize göre biraz da demetlerden söz edebiliriz.

### Demetler

Demetler, özellikle görünüş olarak listelere çok benzeyen bir veri tipidir. Bu
veri tipi de, tıpkı listeler gibi, farklı veri tiplerini içinde barındıran
kapsayıcı bir veri tipidir.

#### Demet Tanımlamak

Demet tanımlamanın birkaç farklı yolu vardır. Nasıl karakter dizilerinin ayırt
edici özelliği tırnak işaretleri, listelerin ayırt edici özelliği ise köşeli
parantez işaretleri ise, demetlerin ayırt edici özelliği de normal parantez
işaretleridir. Dolayısıyla bir demet tanımlamak için normal parantez
işaretlerinden yararlanacağız:

```python
>>> demet = ("ahmet", "mehmet", 23, 45)

>>> type(demet)

<class 'tuple'>

```

Gördüğünüz gibi, karakter dizilerinintype()sorgusunastr, listelerin iselistcevabı vermesi gibi, demetler detype()sorgusunatuplecevabı
veriyor.

Yalnız, dediğimiz gibi Python’da demet tanımlamanın birden fazla yolu vardır.
Mesela yukarıdaki demeti şöyle de tanımlayabiliriz:

```python
>>> demet = "ahmet", "mehmet", 23, 45

```

Gördüğünüz gibi, parantez işaretlerini kullanmadan, öğeleri yalnızca virgül
işareti ile ayırdığımızda da elde ettiğimiz şey bir demet oluyor.

Demet oluşturmak içintuple()adlı bir fonksiyondan da yararlanabilirsiniz.
Bu fonksiyon, liste oluşturanlist()fonksiyonuna çok benzer:

```python
>>> tuple('abcdefg')

('a', 'b', 'c', 'd', 'e', 'f', 'g')

```

Bu fonksiyonu kullanarak başka veri tiplerini demete dönüştürebilirsiniz:

```python
>>> tuple(["ahmet", "mehmet", 34, 45])

('ahmet', 'mehmet', 34, 45)

```

Burada,[“ahmet”, “mehmet”, 34, 45]adlı bir listeyituple()fonksiyonu
yardımıyla demete dönüştürdük.

#### Tek Öğeli bir Demet Tanımlamak

Tek öğeli bir karakter dizisi oluşturabilmek için şu yolu izliyorduk
hatırlarsanız:

```python
>>> kardiz = 'A'

```

Bu tek öğeli bir karakter dizisidir. Bir de tek öğeli bir liste tanımlayalım:

```python
>>> liste = ['ahmet']

```

Bu da tek öğeli bir listedir. Gelin bir de tek öğeli bir demet oluşturmaya
çalışalım:

```python
>>> demet = ('ahmet')

```

Bu şekilde tek öğeli bir demet oluşturduğunuzu zannediyorsunuz, ama aslında
oluşturduğunuz şey basit bir karakter dizisinden ibaret! Gelin kontrol edelim:

```python
>>> type(demet)

<class 'str'>

```

Python programlama dilinde tek öğeli bir demet oluşturma işlemi biraz
‘tuhaf’tır. Eğer tek öğeye sahip bir demet oluşturacaksak şöyle bir şey
yazmalıyız:

```python
>>> demet = ('ahmet',)

```

veya:

```python
>>> demet = 'ahmet',

```

Gördüğünüz gibi, tek öğeli bir demet tanımlarken, o tek öğenin yanına bir tane
virgül işareti yerleştiriyoruz. Böylece demet tanımlamak isterken, yanlışlıkla
alelade bir şekilde ‘ahmet’ adlı bir karakter dizisini ‘demet’ adlı bir
değişkene atamamış oluyoruz…

#### Demetlerin Öğelerine Erişmek

Eğer bir demet içinde yer alan herhangi bir öğeye erişmek isterseniz, karakter
dizileri ve listelerden hatırladığınız yöntemi kullanabilirsiniz:

```python
>>> demet = ('elma', 'armut', 'kiraz')
>>> demet[0]

'elma'

>>> demet[-1]

'kiraz'

>>> demet[:2]

('elma', 'armut')

```

Gördüğünüz gibi, daha önce öğrendiğimiz indeksleme ve dilimleme kuralları aynen
demetler için de geçerli.

#### Demetlerle Listelerin Birbirinden Farkı

En başta da söylediğimiz gibi, demetlerle listeler birbirine çok benzer. Ama
demetlerle listelerin birbirinden çok önemli bazı farkları da vardır. Bu iki
veri tipi arasındaki en önemli fark şudur; listeler değiştirilebilir (mutable) bir
veri tipi iken, demetler değiştirilemez (immutable) bir veri tipidir.
Yani tıpkı karakter dizileri gibi, demetler de bir kez tanımlandıktan sonra
bunların üzerinde değişiklik yapmak mümkün değildir:

```python
>>> demet = ('elma', 'armut', 'kiraz')
>>> demet[0] = 'karpuz'

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

```

Gördüğünüz gibi, demetin herhangi bir öğesini değiştirmeye çalıştığımızda Python
bize bir hata mesajı gösteriyor.

Bu bakımdan, eğer programın akışı esnasında üzerinde değişiklik yapmayacağınız
veya değişiklik yapılmasını istemediğiniz birtakım veriler varsa ve eğer siz bu
verileri liste benzeri bir taşıyıcı içine yerleştirmek istiyorsanız, listeler
yerine demetleri kullanabilirsiniz. Ayrıca demetler üzerinde işlem yapmak
listelere kıyasla daha hızlıdır. Dolayısıyla, performans avantajı nedeniyle de
listeler yerine demetleri kullanmak isteyebilirsiniz.

Tahmin edebileceğiniz gibi, tıpkı karakter dizilerinde olduğu gibi, önceden
tanımlanmış bir demetin üzerinde değişiklik yapabilmek için, örneğin bir demetle
başka bir demeti birleştirmek için o demeti yeniden tanımlamak da mümkündür:

```python
>>> demet = ('ahmet', 'mehmet')
>>> demet = demet + ('selin',)

```

Eğer sadecedemet+('selin',)demiş olsaydık özgün demet üzerinde herhangi
bir değişiklik yapmış olmayacaktık. Siz bu olguya karakter dizilerinden de
aşinasınız. O yüzden, özgün demet üzerinde herhangi bir değişiklik yapabilmek
için, daha doğrusu özgün demet üzerinde bir değişiklik yapmış gibi görünebilmek
için, özgün demeti sıfırdan tanımlamamız gerekiyor…

Burada ayrıca ‘ahmet’ ve ‘mehmet’ öğelerinden oluşan bir demete ‘selin’ öğesini
nasıl eklediğimize de dikkat edin. Asla unutmamalısınız: Python programlama
dilinde sadece aynı tür verileri birbiriyle birleştirebilirsiniz. Mesela
yukarıdaki örnekte ‘selin’ adlı öğeyidemetadlı demete bir karakter dizisi
olarak ekleyemezsiniz:

```python
>>> demet = demet + 'selin'

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: can only concatenate tuple (not "str") to tuple

```

Bu arada, yukarıdaki kodu şöyle yazdığınızda da aslında bir demetle karakter
dizisini birleştirmeye çalışıyor olduğunuza dikkat edin:

```python
>>> demet = demet + ('selin')

```

Hatırlarsanız, tek öğeli bir demet tanımlayabilmek için parantez içindeki tek
öğenin yanına bir virgül işareti yerleştirmemiz gerekiyordu. Aksi halde demet
değil, karakter dizisi tanımlamış oluyorduk. Zaten bir Python programcısı
olarak, demetler üzerinde çalışırken en sık yapacağınız hata da demet
tanımlamaya çalışırken yanlışlıkla karakter dizisi tanımlamak olacaktır.

Dediğimiz ve yukarıda da örneklerle gösterdiğimiz gibi, bir demeti yeni baştan
tanımlayarak da o demet üzerinde değişiklik yapmış etkisi elde edebilirsiniz.
Ancak elbette bir araya topladığınız veriler üzerinde sık sık değişiklikler
yapacaksanız demetler yerine listeleri tercih etmelisiniz.

#### Demetlerin Kullanım Alanı

Demetleri ilk öğrendiğinizde bu veri tipi size son derece gereksizmiş gibi
gelebilir. Ama aslında oldukça yaygın kullanılan bir veri tipidir bu. Özellikle
programların ayar (conf) dosyalarında bu veri tipi sıklıkla kullanılır.
Örneğin Python tabanlı bir web çatısı (framework) olan Django’nunsettings.pyadlı ayar dosyasında pek çok değer bir demet olarak saklanır.
Mesela bir Django projesinde web sayfalarının şablonlarını (template) hangi
dizin altında saklayacağınızı belirlediğiniz ayar şöyle görünür:

```python
TEMPLATE_DIRS = ('/home/projects/djprojects/blog/templates',)

```

Burada, şablon dosyalarının hangi dizinde yer alacağını bir demet içinde
gösteriyoruz. Bu demet içine birden fazla dizin adı yazabilirdik. Ama biz bütün
şablon dosyalarını tek bir dizin altında tutmayı tercih ettiğimiz için tek öğeli
bir demet tanımlamışız. Bu arada, daha önce de söylediğimiz gibi, demetlerle
ilgili en sık yapacağınız hata, tek öğeli demet tanımlamaya çalışırken aslında
yanlışlıkla bir karakter dizisi tanımlamak olacaktır. Örneğin yukarıdakiTEMPLATE_DIRSdeğişkenini şöyle yazsaydık:

```python
TEMPLATE_DIRS = ('/home/projects/djprojects/blog/templates')

```

Aslında bir demet değil, alelade bir karakter dizisi tanımlamış olurduk…

## Listelerin ve Demetlerin Metotları

### Listelerin Metotları

Burada, geçen bölümde kaldığımız yerden devam edeceğiz listeleri anlatmaya.
Ağırlıklı olarak bu bölümde listelerin metotlarından söz edeceğiz. ‘Metot’
kavramını karakter dizilerinden hatırlıyorsunuz. Karakter dizilerini anlatırken
bol miktarda metot görmüştük.

Python’da bütün veri tipleri bize birtakım metotlar sunar. Bu metotlar
yardımıyla, ilgili veri tipi üzerinde önemli değişiklikler veya sorgulamalar
yapabiliyoruz.

Hatırlarsanız bir veri tipinin hangi metotlara sahip olduğunu görmek içindir()fonksiyonundan yararlanıyorduk. Listelerde de durum farklı değil.
Dolayısıyla şu komut bize listelerin metotlarını sıralayacaktır:

```python
>>> dir(list)

['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
 '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',
 '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
 '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__',
 '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
 '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop',
 'remove', 'reverse', 'sort']

```

Gördüğünüz gibi, tıpkı karakter dizilerinde olduğu gibi, listelerin metotlarını
görmek için dedir()fonksiyonuna parametre olarak veri tipinin teknik adını
veriyoruz. Python’da listelerin teknik adılistolduğu için bu komutudir(list)şeklinde kullanıyoruz. Elbette, eğer istersek, listelerin
metotlarını almak için herhangi bir listeyi de kullanabiliriz. Mesela boş bir
liste kullanalım:

```python
>>> dir([])

```

Bu komut dadir(list)ile aynı çıktıyı verecektir. Bu listede bizi
ilgilendiren metotlar ise şunlardır:

```python
>>> [i for i in dir(list) if not "_" in i]

['append', 'clear', 'copy', 'count', 'extend', 'index',
 'insert', 'pop', 'remove', 'reverse', 'sort']

```

Metotlar, bir programcının hayatını önemli ölçüde kolaylaştıran araçlardır. Bu
yüzden, ‘Listeler’ konusunun ilk bölümünde öğrendiğimiz listeye öğe ekleme, öğe
çıkarma, öğe değiştirme, öğe silme gibi işlemleri orada anlattığımız yöntemlerle
değil, biraz sonra göreceğimiz metotlar aracılığıyla yapmayı tercih edeceğiz.
Ama tabii ki, metotları tercih edecek olmamız, birinci bölümde anlattığımız
yöntemleri bir kenara atmanızı gerektirmez. Unutmayın, bir dildeki herhangi bir
özelliği siz kullanmasanız bile, etrafta bu özelliği kullanan başka programcılar
var. Dolayısıyla en azından başkalarının yazdığı kodları anlayabilmek için dahi
olsa, kendinizin kullanmayacağı yöntem ve yolları öğrenmeniz gerekir.

append()metoduyla başlayalım…

#### append()

appendkelimesi İngilizcede ‘eklemek, ilave etmek, iliştirmek’ gibi anlamlara
gelir.append()metodunun görevi de kelime anlamıyla uyumludur. Bu metodu,
bir listeye öğe eklemek için kullanıyoruz. Mesela:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.append("erik")

```

Bu metot, yeni öğeyi listenin en sonuna ekler. Mesela yukarıdaki örnekte“erik”adlı karakter dizisi listede“çilek”adlı karakter dizisinin sağına
eklendi.

Hatırlarsanız bir önceki bölümde listeye öğe ekleme işini+işleci ile de
yapabileceğimizi söylemiştik. Dolayısıyla, aslında yukarıdaki kodu şöyle de
yazabiliriz:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste = liste + ["erik"]
>>> print(liste)

['elma', 'armut', 'çilek', 'erik']

```

Bu iki yöntem birbiriyle aynı sonucu verse de hem pratiklik hem de işleyiş
bakımından bu iki yöntemin birbirinden farklı olduğunu görüyoruz.

Pratiklik açısından bakarsak,append()metodununu kullanmanın+işlecini
kullanmaya kıyasla daha kolay olduğunu herhalde kimse reddetmeyecektir. Bu iki
yöntem işleyiş bakımından da birbirinden ayrılıyor. Zira+işlecini
kullandığımızda listeye yeni bir öğe eklerken aslındalisteadlı başka bir
liste daha oluşturmuş oluyoruz. Hatırlarsanız önceki bölümlerde listelerin
değiştirilebilir (mutable) veri tipleri olduğunu söylemiştik. İşteappend()metodu sayesinde listelerin bu özelliğinden sonuna kadar
yararlanabiliyoruz.+işlecini kullandığımızda ise, orijinal listeyi
değiştirmek yerine yeni bir liste oluşturduğumuz için, sanki listelere karakter
dizisi muamelesi yapmış gibi oluyoruz. Gördüğünüz gibi, listeyeappend()metodunu uyguladıktan sonra bunu bir değişkene atamamıza gerek kalmıyor.append()metodu orijinal liste üzerinde doğrudan değişiklik yapmamıza izin
verdiği için daha az kod yazmamızı ve programımızın daha performanslı
çalışmasını sağlıyor.

+işleci ileappend()metodu işlev olarak birbirine benzese de bu iki
yöntem arasında önemli farklılıklar da vardır. Mesela şu örneğe bir göz atalım:

```python
işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"]
platformlar = ["IPhone", "Android", "S60"]
hepsi = işletim_sistemleri + platformlar
print(hepsi)

['Windows', 'GNU/Linux', 'Mac OS X', 'IPhone', 'Android', 'S60']

```

Burada iki farklı listeyi,+işleci kullanarak birleştirdik. Aynı işiappend()metoduyla şu şekilde yapabiliriz:

```python
işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"]
platformlar = ["IPhone", "Android", "S60"]
for i in platformlar:
 işletim_sistemleri.append(i)

print(işletim_sistemleri)

```

Buradaplatformlaradlı liste üzerinde birfordöngüsü kurmamızın nedeni,append()metodunun yalnızca tek bir parametre alabilmesidir. Yani bu metodu
kullanarak bir listeye birden fazla öğe ekleyemezsiniz:

```python
>>> liste = [1, 2, 3]
>>> liste.append(4, 5, 6)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: append() takes exactly one argument (3 given)

```

Bu sebeple, ekleyeceğiniz listenin öğeleri üzerinde birfordöngüsü kurmanız
gerekir:

```python
>>> liste = [1, 2, 3]
>>> for i in [4, 5, 6]:
... liste.append(i)
...
>>> print(liste)

[1, 2, 3, 4, 5, 6]

```

Bir listeye birden fazla öğe eklemek için aklınıza şöyle bir yöntem de gelmiş
olabilir:

```python
>>> liste = [1, 2, 3]
>>> liste.append([4, 5, 6])

```

Ancak bu komutun çıktısı pek beklediğiniz gibi olmayabilir:

```python
>>> print(liste)

[1, 2, 3, [4, 5, 6]]

```

Gördüğünüz gibi,[4,5,6]öğesi listeye tek parça olarak eklendi. Eğer
istediğiniz şey buysa ne âlâ! Ama değilse,fordöngüsü ya da+işleci ile
istediğiniz çıktıyı elde edebilirsiniz.

Şöyle bir örnek daha düşünün: Diyelim ki kullanıcının girdiği bütün sayıları
birbiriyle çarpan bir uygulama yazmak istiyoruz. Bunun için şöyle bir kod
yazabiliriz:

```python
sonuç = 1

while True:
 sayı = input("sayı (hesaplamak için q): ")
 if sayı == "q":
 break

 sonuç *= int(sayı)

print(sonuç)

```

Burada kullanıcı her döngüde bir sayı girecek ve programımız girilen bu sayıyısonuçdeğişkeninin o anki değeriyle çarparak yinesonuçdeğişkenine
gönderecek. Böylece kullanıcı tarafından girilen bütün sayıların çarpımını elde
etmiş olacağız. Kullanıcının ‘q’ harfine basmasıyla birlikte desonuçdeğişkeninin değeri ekranda görünecek. Yalnız burada birkaç sorun var. Diyelim
ki kullanıcı hiçbir sayı girmeden ‘q’ harfine basarsa,sonuçdeğişkeninin1olan değeri ekranda görünecek ve bu şekilde kullanıcı yanlış bir sonuç elde
etmiş olacak. Ayrıca çarpma işlemi için en az2adet sayı gerekiyor.
Dolayısıyla kullanıcı2’den az sayı girerse de programımız yanlış sonuç
verecektir. Kullanıcının yeterli miktarda sayı girip girmediğini tespit
edebilmek için yine listelerden ve listelerinappend()metodundan
yararlanabiliriz:

```python
kontrol = []
sonuç = 1

while True:
 sayı = input("sayı (hesaplamak için q): ")
 if sayı == "q":
 break
 kontrol.append(sayı)
 sonuç *= int(sayı)

if len(kontrol) < 2:
 print("Yeterli sayı girilmedi!")
else:
 print(sonuç)

```

Burada önceki koda ilave olarak,kontroladlı boş bir liste tanımladık. Bu
liste kullanıcının girdiği sayıları depolayacak. Bir önceki örnekte kullanıcının
girdiği sayıları hiçbir yerde depolamadık. Orada yaptığımız şey her döngüde
kullanıcı tarafından girilen sayıyısonuçdeğişkeninin değeriyle çarpıp yinesonuçdeğişkenine göndermekti. Dolayısıyla kullanıcı tarafından girilen
sayılar bir yerde tutulmadığı için kaybolup gidiyordu. Burada isekontroladlı
liste, kullanıcı tarafından girilen sayıları tuttuğu için, bu sayıları daha
sonra istediğimiz gibi kullanabilme imkanına kavuşuyoruz.

Ayrıca bu ikinci kodlardakontroldeğişkeninin boyutuna bakarak kullanıcının2’den az sayı girip girmediğini denetliyoruz. Eğerkontrollistesinin
uzunluğu2’den azsa kullanıcı çarpma işlemi için yeterli sayı girmemiş
demektir. Böyle bir durumda çarpma işlemini yapmak yerine, kullanıcıya ‘Yeterli
sayı girilmedi!’ şeklinde bir uyarı mesajı gösteriyoruz.

append()metodu listelerin en önemli metotlarından biridir. Hem kendi
yazdığınız, hem de başkalarının yazdığı programlardaappend()metodunu sıkça
göreceksiniz. Dolayısıyla listelerin hiçbir metodunu bilmeseniz bileappend()metodunu öğrenmelisiniz.

#### extend()

extendkelimesi İngilizcede ‘genişletmek, yaymak’ gibi anlamlara gelir. İşteextend()adlı metot da kelime anlamına uygun olarak listeleri ‘genişletir’.

Şöyle bir düşündüğünüzdeextend()metodununappend()metoduyla aynı işi
yaptığını zannedebilirsiniz. Ama aslında bu iki metot işleyiş olarak birbirinden
çok farklıdır.

append()metodunu kullanarak yazdığımız şu koda dikkatlice bakın:

```python
li1 = [1, 3, 4]
li2 = [10, 11, 12]
li1. append(li2)

print(li1)

```

append()metodunu anlatırken söylediğimiz gibi, bu metot bir listeye her
defasında sadece tek bir öğe eklenmesine izin verir. Yukarıda olduğu gibi, eğer
bu metodu kullanarak bir listeye yine bir liste eklemeye çalışırsanız,
eklediğiniz liste tek bir öğe olarak eklenecektir. Yani yukarıdaki kodlar size
şöyle bir çıktı verecektir:

```python
[1, 3, 4, [10, 11, 12]]

```

Gördüğünüz gibi,[10, 11, 12]listesi öteki listeye tek bir liste halinde
eklendi. İşteextend()metodu bu tür durumlarda işinize yarayabilir. Mesela
yukarıdaki örneği bir deextend()metodunu kullanarak yazalım:

```python
li1 = [1, 3, 4]
li2 = [10, 11, 12]
li1. extend(li2)

print(li1)

```

Bu defa şöyle bir çıktı alıyoruz:

```python
[1, 3, 4, 10, 11, 12]

```

Gördüğünüz gibi,extend()metodu tam da kelime anlamına uygun olarak listeyi
yeni öğelerle genişletti.

Hatırlarsanızappend()metodunu anlatırken şöyle bir örnek vermiştik:

```python
işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"]
platformlar = ["IPhone", "Android", "S60"]
hepsi = işletim_sistemleri + platformlar
print(hepsi)

```

Burada+işlecini kullanarakişletim_sistemleriveplatformlaradlı
listeleri birleştirerekhepsiadlı tek bir liste elde ettik. Aynı etkiyiappend()metodunu kullanarak şu şekilde elde edebileceğimizi de söylemiştik
orada:

```python
işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"]
platformlar = ["IPhone", "Android", "S60"]
for i in platformlar:
 işletim_sistemleri.append(i)

print(işletim_sistemleri)

```

Esasında,append()metodunu kullanmaya kıyasla, burada+işlecini
kullanmak sanki daha pratikmiş gibi görünüyor. Bir de şuna bakın:

```python
işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"]
platformlar = ["IPhone", "Android", "S60"]
işletim_sistemleri.extend(platformlar)
print(işletim_sistemleri)

```

Gördüğünüz gibi, bu örnekteextend()metodunu kullanmakappend()metodunu kullanmaya göre daha pratik ve makul. Çünkü bir listeye tek tek öğe
eklemek açısındanappend()metodu daha uygundur, ama eğer yukarıda olduğu
gibi bir listeye başka bir liste ekleyeceksekextend()metodunu kullanmayı
tercih edebiliriz.

#### insert()

Bildiğiniz gibi,+işleci,append()veextend()metotları öğeleri
listenin sonuna ekliyor. Peki biz bir öğeyi listenin sonuna değil de, liste
içinde başka bir konuma eklemek istersek ne yapacağız? İşte bunun içininsert()adlı başka bir metottan yararlanacağız.

insertkelimesi ‘yerleştirmek, sokmak’ gibi anlamlara gelir.insert()metodu da bu anlama uygun olarak, öğeleri listenin istediğimiz bir konumuna
yerleştirir. Dikkatlice inceleyin:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.insert(0, "erik")
>>> print(liste)

['erik', 'elma', 'armut', 'çilek']

```

Gördüğünüz gibiinsert()metodu iki parametre alıyor. İlk parametre, öğenin
hangi konuma yerleştirileceğini, ikinci parametre ise yerleştirilecek öğenin ne
olduğunu gösteriyor. Yukarıdaki örnekte“erik”öğesini listenin0.konumuna,
yani listenin en başına yerleştiriyoruz.

ìnsert()metodu özellikle dosya işlemlerinde işinize yarar. Diyelim ki
elimizde içeriği şöyle olandeneme.txtadlı bir dosya var:

```python
Ahmet Özkoparan
Mehmet Veli
Serdar Güzel
Zeynep Güz

```

Bizim amacımız, ‘Ahmet Özkoparan’ satırından sonra ‘Ferhat Yaz’ diye bir satır
daha eklemek. Yani dosyamızı şu hale getirmek istiyoruz:

```python
Ahmet Özkoparan
Ferhat Yaz
Mehmet Veli
Serdar Güzel
Zeynep Güz

```

Biz henüz Python’da dosya işlemlerinin nasıl yapılacağını öğrenmedik. Ama
hatırlarsanız bundan önceki bölümlerde birkaç yerdeopen()adlı bir
fonksiyondan bahsetmiş ve bu fonksiyonun dosya işlemlerinde kullanıldığını
söylemiştik. Mesela yukarıda bahsettiğimizdeneme.txtadlı dosyayı açmak içinopen()fonksiyonunu şu şekilde kullanabiliriz:

```python
f = open("deneme.txt", "r")

```

Buradadeneme.txtadlı dosyayı okuma modunda açmış olduk. Şimdi dosya
içeriğini okuyalım:

```python
içerik = f.readlines()

```

Bu satır sayesinde dosya içeriğini bir liste halinde alabildik. Eğer yukarıdaki
kodlara şu eklemeyi yaparsanız, dosya içeriğini görebilirsiniz:

```python
print(içerik)

['Ahmet Özkoparan\n', 'Mehmet Veli\n', 'Serdar Güzel\n', 'Zeynep Güz\n', '\n']

```

Gördüğünüz gibi, dosya içeriği basit bir listeden ibaret. Dolayısıyla listelerle
yapabildiğimiz her şeyiiçerikadlı değişkenle de yapabiliriz. Yani bu listeye
öğe ekleyebilir, listeden öğe çıkarabilir ya da bu listeyi başka bir liste ile
birleştirebiliriz.

Dosya içeriğini bir liste olarak aldığımıza göre şimdi bu listeye“Ahmet
Özkoparan”öğesinden sonra“Ferhat Yaz”öğesini ekleyelim. Dikkatlice bakın:

```python
içerik.insert(1, "Ferhat Yaz\n")

```

Dediğimiz gibi,f.readlines()satırı bize dosya içeriğini bir liste olarak
verdi. Amacımız“Ahmet Özkoparan”öğesinden sonra“Ferhat Yaz”öğesini
eklemek. Bunun için, liste metotlarından biri olaninsert()metodunu
kullanarak listenin1.sırasına“Ferhat Yaz”öğesini ekledik. Burada“Ferhat Yaz”öğesinenadlı satır başı karakterini de ilave ettiğimize
dikkat edin. Bu eklemeyi neden yaptığımızı anlamak için satır başı karakterini
çıkarmayı deneyebilirsiniz.

içerikadlı değişkenin değerini istediğimiz biçime getirdiğimize göre bu
listeyi tekrardeneme.txtadlı dosyaya yazabiliriz. Ama bunun için öncelikledeneme.txtadlı dosyayı yazma modunda açmamız gerekiyor. Python’da dosyalar ya
okuma ya da yazma modunda açılabilir. Okuma modunda açılan bir dosyaya
yazılamaz. O yüzden dosyamızı bir de yazma modunda açmamız gerekiyor:

```python
g = open("deneme.txt", "w")

```

open()fonksiyonunun ilk parametresi dosya adını gösterirken, ikinci
parametresi dosyanın hangi modda açılacağını gösteriyor. Biz buradadeneme.txtadlı dosyayı yazma modunda açtık. Buradaki“w”parametresi İngilizcede
‘yazmak’ anlamına gelenwritekelimesinin ilk harfidir. Biraz önce isedeneme.txtdosyasını“r”, yani okuma (read) modunda açmıştık.

Dosyamız artık üzerine yazmaya hazır. Dikkatlice bakın:

```python
g.writelines(içerik)

```

Burada, biraz önce istediğimiz biçime getirdiğimiziçerikadlı listeyi doğrudan
dosyaya yazdık. Bu işlem içinwritelines()adlı özel bir metottan
yararlandık. Bu metotları birkaç bölüm sonra ayrıntılı olarak inceleyeceğiz. Biz
şimdilik sadece sonuca odaklanalım.

Yapmamız gereken son işlem, açık dosyaları kapatmak olmalı:

```python
f.close()
g.close()

```

Şimdi kodlara topluca bir bakalım:

```python
f = open("deneme.txt", "r")
içerik = f.readlines()
içerik.insert(1, "Ferhat Yaz\n")

g = open("deneme.txt", "w")
g.writelines(içerik)

f.close()
g.close()

```

Gördüğünüz gibi yaptığımız işlem şu basamaklardan oluşuyor:
1. Öncelikle dosyamızı okuma modunda açıyoruz (f=open("deneme.txt","r"))
1. Ardından dosya içeriğini bir liste olarak alıyoruz (içerik=f.readlines())
1. Aldığımız bu listenin2.sırasına“Ferhat Yaz”öğesini ekliyoruz
(içerik.insert(1,"FerhatYaz\n"))
1. Listeyi istediğimiz şekle getirdikten sonra bu defa dosyamızı yazma
modunda açıyoruz (g=open("deneme.txt","w"))
1. Biraz önce düzenlediğimiz listeyi dosyaya yazıyoruz (g.writelines(içerik))
1. Son olarak da, hem yaptığımız değişikliklerin etkin hale gelebilmesi
hem de işletim sisteminin programımıza tahsis ettiği kaynakların serbest
kalması için dosyalarımızı kapatıyoruz (f.close()veg.close())

Öncelikle dosyamızı okuma modunda açıyoruz (f=open("deneme.txt","r"))

Ardından dosya içeriğini bir liste olarak alıyoruz (içerik=f.readlines())

Aldığımız bu listenin2.sırasına“Ferhat Yaz”öğesini ekliyoruz
(içerik.insert(1,"FerhatYaz\n"))

Listeyi istediğimiz şekle getirdikten sonra bu defa dosyamızı yazma
modunda açıyoruz (g=open("deneme.txt","w"))

Biraz önce düzenlediğimiz listeyi dosyaya yazıyoruz (g.writelines(içerik))

Son olarak da, hem yaptığımız değişikliklerin etkin hale gelebilmesi
hem de işletim sisteminin programımıza tahsis ettiği kaynakların serbest
kalması için dosyalarımızı kapatıyoruz (f.close()veg.close())

Buradainsert()metodunun bize nasıl kolaylık sağladığına dikkat edin.insert()metodu da listelerin önemli metotlarından biridir ve dediğimiz
gibi, özellikle dosyaları manipüle ederken epey işimize yarar.

#### remove()

Bu metot listeden öğe silmemizi sağlar. Örneğin:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.remove("elma")
>>> liste

['armut', 'çilek']

```

#### reverse()

Daha önce verdiğimiz örneklerde, liste öğelerini ters çevirmek için dilimleme
yöntemini kullanabileceğimizi öğrenmiştik:

```python
>>> meyveler = ["elma", "armut", "çilek", "kiraz"]
>>> meyveler[::-1]

['kiraz', 'çilek', 'armut', 'elma']

```

Eğer istersek, bu iş için, karakter dizilerini incelerken öğrendiğimizreversed()fonksiyonunu da kullanabiliriz:

```python
>>> reversed(meyveler)

```

Bu komut bize şu çıktıyı verir:

```python
<list_reverseiterator object at 0x00DC9810>

```

Demek kireversed()fonksiyonunu bir liste üzerine uyguladığımızda
‘list_reverseiterator’ adı verilen bir nesne elde ediyoruz. Bu nesnenin
içeriğini görmek için birkaç farklı yöntemden yararlanabiliriz. Örneğin:

```python
>>> print(*reversed(meyveler))

kiraz çilek armut elma

```

… veya:

```python
>>> print(list(reversed(meyveler)))

['kiraz', 'çilek', 'armut', 'elma']

```

… ya da:

```python
>>> for i in reversed(meyveler):
... print(i)
...
kiraz
çilek
armut
elma

```

Gördüğünüz gibi, Python’da bir listeyi ters çevirmenin pek çok yöntemi var.
Dilerseniz şimdi bu yöntemlere bir tane daha ekleyelim.

Python’da listelerin öğelerini ters çevirmek için yukarıdaki yöntemlere ek
olarak listelerinreverse()metodunu da kullanabilirsiniz:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.reverse()
>>> liste

['çilek', 'armut', 'elma']

```

İhtiyacınız olan çıktının türüne ve şekline göre yukarıdaki yöntemlerden
herhangi birini tercih edebilirsiniz.

#### pop()

Tıpkıremove()metodu gibi, bu metot da bir listeden öğe silmemizi sağlar:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.pop()

```

Ancak bu metot,remove()metodundan biraz farklı davranır.pop()metodunu kullanarak bir liste öğesini sildiğimizde, silinen öğe ekrana
basılacaktır. Bu metot parametresiz olarak kullanıldığında listenin son öğesini
listeden atar. Alternatif olarak, bu metodu bir parametre ile birlikte de
kullanabilirsiniz. Örneğin:

```python
>>> liste.pop(0)

```

Bu komut listenin0.öğesini listeden atar ve atılan öğeyi ekrana basar.

#### sort()

Yine listelerin önemli bir metodu ile karşı karşıyayız.sort()adlı bu
önemli metot bir listenin öğelerini belli bir ölçüte göre sıraya dizmemizi
sağlar. Basit bir örnek verelim. Diyelim ki elimizde şöyle bir liste var:

```python
üyeler = ['Ahmet', 'Mehmet', 'Ceylan', 'Seyhan', 'Mahmut', 'Zeynep',
 'Abdullah', 'Kadir', 'Kemal', 'Kamil', 'Selin', 'Senem',
 'Sinem', 'Tayfun', 'Tuna', 'Tolga']

```

Bu listedeki isimleri mesela alfabe sırasına dizmek içinsort()metodunu
kullanabiliriz:

```python
>>> üyeler.sort()
>>> print(üyeler)

['Abdullah', 'Ahmet', 'Ceylan', 'Kadir', 'Kamil', 'Kemal', 'Mahmut',
 'Mehmet', 'Selin', 'Senem', 'Seyhan', 'Sinem', 'Tayfun', 'Tolga',
 'Tuna', 'Zeynep']

```

Bu metot elbette yalnızca harfleri alfabe sırasına dizmek için değil sayıları
sıralamak için de kullanılabilir:

```python
>>> sayılar = [1, 0, -1, 4, 10, 3, 6]
>>> sayılar.sort()
>>> print(sayılar)

[-1, 0, 1, 3, 4, 6, 10]

```

Gördüğünüz gibi,sort()metodu öğeleri artan sıralamaya tabi tutuyor. Yani
öğeler ‘a, b, c’ veya 1, 2, 3 şeklinde sıralanıyor. Bunun tersini yapmak da
mümkündür. Yani istersek Python’ın sıralama işlemini ‘c, b, a’ şeklinde
yapmasını da sağlayabiliriz. Bunun içinsort()metodununreverseparametresini kullanacağız:

```python
>>> üyeler = ['Ahmet', 'Mehmet', 'Ceylan', 'Seyhan', 'Mahmut', 'Zeynep',
 'Abdullah', 'Kadir', 'Kemal', 'Kamil', 'Selin', 'Senem',
 'Sinem', 'Tayfun', 'Tuna', 'Tolga']

>>> üyeler.sort(reverse=True)

```

Gördüğünüz gibisort()metodununreverseadlı bir parametresine verdiğimizTruedeğeri sayesinde liste öğelerini ters sıraladık. Bu parametrenin
öntanımlı değeriFalse’tur. Yanisort()metodu öntanımlı olarak öğeleri
artıra artıra sıralar. Öğeleri azalta azalta sıralamak içinreverseparametresininFalseolan öntanımlı değeriniTrueyapmamız yeterli
olacaktır.

Gelin istersenizsort()metodunu kullanarak bir örnek daha verelim. Elimizde
şöyle bir liste olsun:

```python
>>> isimler = ["Ahmet", "Işık", "İsmail", "Çiğdem", "Can", "Şule"]

```

Bu listedeki isimleri alfabe sırasına dizelim:

```python
>>> isimler.sort()
>>> isimler

['Ahmet', 'Can', 'Işık', 'Çiğdem', 'İsmail', 'Şule']

```

Gördüğünüz gibi, çıktı pek beklediğimiz gibi değil. Tıpkı karakter dizilerini
anlatırken öğrendiğimizsorted()fonksiyonunda olduğu gibi, listelerinsort()metodu da Türkçe karakterleri düzgün sıralayamaz. Eğer Türkçe
karakterleri sıralamamız gereken bir program yazıyorsak bizimsort()metodunun işleyişine müdahale etmemiz gerekir. Temel olarak,sorted()fonksiyonunu anlatırken söylediklerimiz burada da geçerlidir. Orada
bahsettiğimizlocalemodülü burada da çoğu durumda işimizi halletmemizi
sağlar. Amasorted()fonksiyonunu anlatırken de söylediğimiz gibi,localemodülü burada da ‘i’ ve ‘ı’ harflerini düzgün sıralayamaz. Türkçe
harflerin tamamını düzgün sıralayabilmek için şöyle bir kod yazabiliriz:

```python
harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
çevrim = {harf: harfler.index(harf) for harf in harfler}

isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule"]

isimler.sort(key=lambda x: çevrim.get(x[0]))

print(isimler)

```

Bu kodların bir kısmını anlayabiliyor, bir kısmını ise anlayamıyor
olabilirsiniz. Çünkü burada henüz işlemediğimiz konular var. Zamanı geldiğinde
bu kodların tamamını anlayabilecek duruma geleceksiniz. Siz şimdilik sadece bu
kodlardan ne çıkarabildiğinize bakın yeter. Zaten bizim buradaki amacımız,sort()metodunun Türkçe harfleri de düzgün bir şekilde sıralayabileceğini
göstermekten ibarettir.

Bu arada ufak bir uyarı yapmadan geçmeyelim: Yukarıdaki kodlar da esasında
Türkçe kelimeleri tam anlamıyla düzgün bir şekilde sıralamak için yeterli değil.
‘Gömülü Fonksiyonlar’ konusunu incelerken, yeri geldiğinde bu konuya tekrar
değinip, Türkçe kelimelerin nasıl doğru, tam ve eksiksiz bir biçimde
sıralanacağını da tüm ayrıntılarıyla inceleyeceğiz.

#### index()

Karakter dizileri konusunu anlatırken bu veri tipininindex()adlı bir
metodu olduğundan söz etmiştik hatırlarsanız. İşte liste veri tipinin deindex()adında ve karakter dizilerininindex()metoduyla aynı işi yapan
bir metodu bulunur. Bu metot bir liste öğesinin liste içindeki konumunu söyler
bize:

```python
>>> liste = ["elma", "armut", "çilek"]
>>> liste.index("elma")

0

```

Karakter dizilerininindex()metoduyla ilgili söylediğimiz her şey
listelerinindex()metodu için de geçerlidir.

#### count()

Karakter dizileri ile listelerin ortak metotlarından biri decount()metodudur. Tıpkı karakter dizilerinde olduğu gibi, listelerincount()metodu
da bir öğenin o veri tipi içinde kaç kez geçtiğini söyler:

```python
>>> liste = ["elma", "armut", "elma", "çilek"]
>>> liste.count("elma")

2

```

Karakter dizilerinincount()metoduyla ilgili söylediğimiz her şey
listelerincount()metodu için de geçerlidir.

#### copy()

Hatırlarsanız, geçen bölümde, listeleri, birbirlerini etkilemeyecek şekilde
kopyalamak için şu iki yöntemi kullanmıştık:

```python
>>> liste1 = ["ahmet", "mehmet", "özlem"]
>>> liste2 = liste1[:]

```

ve:

```python
>>> liste2 = list(liste1)

```

İşte aynı iş için yukarıdakilere ek olarakcopy()adlı bir metottan da
yararlanabiliriz. Dikkatlice bakın:

```python
>>> liste2 = liste1.copy()

```

Hangi yöntemi seçeceğiniz size kalmış…

#### clear()

Listelerle ilgili olarak ele alacağımız son metodun adıclear(). Bu metodun
görevi bir listenin içeriğini silmektir.

Diyelim ki elimizde şöyle bir liste var:

```python
>>> liste = [1, 2, 3, 5, 10, 20, 30, 45]

```

Bu listenin içini boşaltmak içinclear()metodunu kullanabiliriz:

```python
>>> liste.clear()
>>> liste

[]

```

Bu metodundelsözcüğünden farklı olduğunu dikkat edin.clear()metodu
listenin içeriğini boşaltırken,delsözcüğü listeyi olduğu gibi ortadan
kaldırır.

### Demetlerin Metotları

Listelerin metotlarını incelediğimize göre, artık demetlerin metotlarına
bakabiliriz.

Geçen bölümde de söylediğimiz gibi, listeler ve demetler birbirine benzer.
Aralarındaki en önemli fark, listelerin değiştirilebilir bir veri tipi iken,
demetlerin değiştirilemez bir veri tipi olmasıdır. Elbette bu fark, iki veri
tipinin metotlarında da kendini gösterir. Demetler üzerinde değişiklik
yapamadığımız için, bu veri tipi değişiklik yapmaya yarayan metotlara sahip
değildir.

Demetlerin hangi metotları olduğunu şu komutla görebilirsiniz:

```python
>>> dir(tuple)

```

Gördüğünüz gibi, bu veri tipinin bizi ilgilendiren iki metodu var:
1. index()
1. count()

index()

count()

#### index()

Listeler ve karakter dizileri konusunu anlatırken bu veri tiplerininindex()adlı bir metodu olduğundan söz etmiştik hatırlarsanız. İşte demet veri tipinin
deindex()adında ve listelerle karakter dizilerininindex()metoduyla
aynı işi yapan bir metodu bulunur. Bu metot bir demet öğesinin demet içindeki
konumunu söyler bize:

```python
>>> demet = ("elma", "armut", "çilek")
>>> demet.index("elma")

0

```

Listelerin ve karakter dizilerininindex()metoduyla ilgili söylediğimiz her
şey demetlerinindex()metodu için de geçerlidir.

#### count()

Karakter dizileri, listeler ve demetlerin ortak metotlarından biri decount()metodudur. Tıpkı karakter dizileri ve listelerde olduğu gibi,
demetlerincount()metodu da bir öğenin o veri tipi içinde kaç kez geçtiğini
söyler:

```python
>>> demet = ("elma", "armut", "elma", "çilek")
>>> demet.count("elma")

2

```

Karakter dizilerinin ve listelerincount()metoduyla ilgili söylediğimiz her
şeydemetlerincount()metodu için de geçerlidir.

## Sayma Sistemleri

Sayılar olmadan bilgisayar ve programlama düşünülemez. O yüzden, önceki
derslerimizde karakter dizilerini anlatırken şöyle bir değinip geçtiğimiz
sayılar konusunu, sayma sistemleri konusunu da ilave ederek, birer programcı
adayı olan bizleri yakından ilgilendirdiği için mümkün olduğunca ayrıntılı bir
şekilde ele almaya çalışacağız.

Sayılar ve Sayma Sistemleri konusunu iki farklı bölümde inceleyeceğiz.

Sayılar konusunun temelini oluşturduğu için, öncelikle sayma sistemlerinden söz
edelim.

Öncelikle ‘sayma sistemi’ kavramını tanımlayarak işe başlayalım. Nedir bu ‘sayma
sistemi’ denen şey?

Sayma işleminin hangi ölçütlere göre yapılacağını belirleyen kurallar bütününe
sayma sistemi adı verilir.

Dünyada yaygın olarak kullanılan dört farklı sayma sistemi vardır. Bunlar, onlu,
sekizli, on altılı ve ikili sayma sistemleridir. Bu dördü arasında en yaygın
kullanılan sayma sistemi ise, tabii ki, onlu sistemdir. İnsanların elleri ve
ayaklarında on parmak olduğunu düşünürsek, bu sistemin neden daha yaygın
kullanıldığını anlamak aslında hiç de zor değil!

Onlu sistemin yaygınlığını düşünerek, sayma sistemleri konusunu anlatmaya onlu
sayma sisteminden başlayalım.

### Onlu Sayma Sistemi

Biz insanlar genellikle hesap işlemleri için onlu sayma sistemini kullanırız.
Hepinizin bildiği gibi bu sistem;0,1,2,3,4,5,6,7,8ve9olmak üzere toplam on rakamdan oluşur. Yani sayıları gösteren, birbirinden
farklı toplam on simge (rakam) vardır bu sistemde. Bu on simgeyi kullanarak,
olası bütün sayıları gösterebiliriz.

Bu arada terminoloji ile ilgili ufak bir açıklama yapalım:

Rakamlar, sayıları göstermeye yarayan simgelerdir. Onlu sayma sisteminde toplam
on farklı rakam vardır. Bütün rakamlar birer sayıdır, ama bütün sayılar birer
rakam değildir. Örneğin8hem bir rakam hem de bir sayıdır. Ancak mesela32bir sayı olup bu sayı,3ve2adlı iki farklı rakamın bir araya getirilmesi
ile gösterilir. Yani32sayısı tek başına bir rakam değildir.

Açıklamamızı da yaptığımıza göre yolumuza devam edebiliriz.

İnsanlar yukarıda bahsettiğimiz bu onlu sisteme ve bu sistemi oluşturan
rakamlara/simgelere o kadar alışmıştır ki, çoğu zaman başka bir sistemin
varlığından veya var olma olasılığından haberdar bile değildir.

Ama elbette dünya üzerindeki tek sayma sistemi onlu sistem olmadığı gibi,
sayıları göstermek için kullanılabilecek rakamlar da yukarıdakilerle sınırlı
değildir.

Nihayetinde rakam dediğimiz şeyler insan icadı birtakım simgelerden ibarettir.
Elbette doğada ‘2’ veya ‘7’ diye bir şey bulunmaz. Bizim yaygın olarak
yukarıdaki şekilde gösterdiğimiz rakamlar Arap rakamlarıdır. Mesela Romalılar
yukarıdakiler yerine I, II, III, IV, V, VI, VII, VIII, IX ve X gibi farklı
simgeler kullanıyordu… Neticede2veIIaynı kavrama işaret ediyor. Sadece
kullanılan simgeler birbirinden farklı, o kadar.

Onlu sayma sisteminde bir sayıyı oluşturan rakamlar10’un kuvvetleri olarak
hesaplanır. Örneğin1980sayısını ele alalım. Bu sayıyı10’un kuvvetlerini
kullanarak şu şekilde hesaplayabiliriz:

```python
>>> (0 * (10 ** 0)) + (8 * (10 ** 1)) + (9 * (10 ** 2)) + (1 * (10 ** 3))

1980

```

Gördüğünüz gibi, sayının en sağındaki basamak10’un0.kuvveti olacak
şekilde, sola doğru kuvveti artırarak ilerliyoruz.

Gelelim öteki sayma sistemlerine…

### Sekizli Sayma Sistemi

Onlu sayma sisteminin aksine sekizli sayma sisteminde toplam sekiz rakam
bulunur. Bu rakamlar şunlardır:

0, 1, 2, 3, 4, 5, 6, 7

Gördüğünüz gibi, onlu sistemde toplam on farklı simge varken, sekizli sistemde
toplam sekiz farklı simge var.

Bu bölümün en başında da söylediğimiz gibi, insanlar onlu sayma sistemine ve bu
sistemi oluşturan simgelere o kadar alışmıştır ki, çoğu zaman başka bir sistemin
varlığından veya var olma olasılığından haberdar bile değildir. Hatta başka
sayma sistemlerinden bir vesileyle haberdar olup, bu sistemleri öğrenmeye
çalışanlar onlu sayma sistemine olan alışkanlıkları nedeniyle yeni sayma
sistemlerini anlamakta dahi zorluk çekebilirler. Bunun birincil nedeni,
iyi tanıdıklarını zannettikleri onlu sistemi de aslında o kadar iyi tanımıyor
olmalarıdır.

O halde başka sayma sistemlerini daha iyi anlayabilmek için öncelikle yaygın
olarak kullandığımız sayma sisteminin nasıl işlediğini anlamaya çalışalım:

Onlu sistemde toplam on farklı simge bulunur:

0, 1, 2, 3, 4, 5, 6, 7, 8, 9

9’dan büyük bir sayıyı göstermek gerektiğinde simge listesinin en başına
dönülür ve basamak sayısı bir artırılarak, semboller birleştirilir:

10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …, 99, 100, …, 999, 1000

İşte bu kural öteki sayma sistemleri için de geçerlidir. Mesela sekizli sayma
sistemini ele alalım.

Dediğimiz gibi, sekizli sistemde toplam sekiz farklı simge bulunur:

0, 1, 2, 3, 4, 5, 6, 7

Bu sistemde7’den büyük bir sayıyı göstermek gerektiğinde, tıpkı onlu sistemde
olduğu gibi, simge listesinin en başına dönüyoruz ve basamak sayısını bir
artırarak sembolleri birleştiriyoruz:

10, 11, 12, 13, 14, 15, 16, 17, 20, …, 77, 100

Onlu sayma sistemi ile sekizli sayma sistemi arasındaki farkı daha belirgin bir
şekilde görebilmek için şu kodları yazalım:

```python
sayı_sistemleri = ["onlu", "sekizli"]

print(("{:^5} "*len(sayı_sistemleri)).format(*sayı_sistemleri))

for i in range(17):
 print("{0:^5} {0:^5o}".format(i))

```

Bu kodlarda öğrenmediğimiz ve anlayamayacağımız hiçbir şey yok. Bu kodları
oluşturan bütün parçaları önceki derslerimizde ayrıntılı olarak incelemiştik.

Bu kodlardan şöyle bir çıktı alacağız:

```python
onlu sekizli
 0 0
 1 1
 2 2
 3 3
 4 4
 5 5
 6 6
 7 7
 8 10
 9 11
 10 12
 11 13
 12 14
 13 15
 14 16
 15 17
 16 20

```

Gördüğünüz gibi, onlu sistemde elimizde toplam on farklı simge olduğu için,
elimizdeki simgeleri kullanarak 10. sayıya kadar ilerleyebiliyoruz. Bu noktadan
sonra simge stoğumuz tükendiği için en başa dönüp bir basamak artırıyoruz ve
simgeleri birbiriyle birleştirerek yeni sayılar elde ediyoruz.

Sekizli sistemde ise elimizde yalnızca sekiz farklı simge olduğu için,
elimizdeki simgeleri kullanarak ancak 8. sayıya kadar gelebiliyoruz. Öteki
sayıları gösterebilmek için bu noktadan sonra başa dönüp bir artırmamız ve
simgeleri birbiriyle birleştirerek yeni sayılar elde etmemiz gerekiyor.

Sekizli sayma sisteminde bir sayıyı oluşturan rakamlar8’in kuvvetleri olarak
hesaplanır. Örneğin sekizli sayma sistemindeki3674sayısını ele alalım. Bu
sayıyı8’in kuvvetlerini kullanarak şu şekilde hesaplayabiliriz:

```python
>>> (4 * (8 ** 0)) + (7 * (8 ** 1)) + (6 * (8 ** 2)) + (3 * (8 ** 3))

1980

```

Bu hesaplama şeklini onlu sayma sisteminden hatırlıyor olmalısınız. Gördüğünüz
gibi, sekizli sistemdeki bir sayının her bir basamağını8’in kuvvetleri olarak
hesapladığımızda, bu sayının onlu sistemdeki karşılığını elde ediyoruz.

### On Altılı Sayma Sistemi

Şu ana kadar onlu ve sekizli sayma sistemlerinden bahsettik. Önemli bir başka
sayma sistemi de on altılı sayma sistemidir.

Onlu sayma sisteminde on farklı rakam, sekizli sayma sisteminde sekiz farklı
rakam olduğunu öğrenmiştik. On altılı sayma sisteminde ise, tahmin
edebileceğiniz gibi, on altı farklı rakam bulunur:

0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f

Şimdiye kadar öğrenmiş olduğumuz sayma sistemleri arasındaki farkı daha net
görmek için biraz önce yazdığımız kodlara on altılı sayma sistemini de
ekleyelim:

```python
sayı_sistemleri = ["onlu", "sekizli", "on altılı"]

print(("{:^8} "*len(sayı_sistemleri)).format(*sayı_sistemleri))

for i in range(17):
 print("{0:^8} {0:^8o} {0:^8x}".format(i))

```

Buradan şöyle bir çıktı alacağız:

```python
onlu sekizli on altılı
 0 0 0
 1 1 1
 2 2 2
 3 3 3
 4 4 4
 5 5 5
 6 6 6
 7 7 7
 8 10 8
 9 11 9
 10 12 a
 11 13 b
 12 14 c
 13 15 d
 14 16 e
 15 17 f
 16 20 10

```

Gördüğünüz gibi, onlu sistemde birbirinden farklı toplam10adet rakam/simge
varken, sekizli sistemde toplam8farklı simge, on altılı sistemde ise toplam16farklı simge var. Yani onlu sistemde olası bütün sayılar eldeki10farklı
simge ve bunların kombinasyonunun kullanılması yoluyla; sekizli sistemde8farklı simge ve bunların kombinasyonunun kullanılması yoluyla; on altılı
sistemde ise16farklı simge ve bunların kombinasyonunun kullanılması yoluyla
gösteriliyor. Bu sebeple onlu sistemde9sayısından itibaren bir basamak
artırılıp simge listesinin başına dönülürken, sekizli sistemde7sayısından
itibaren; on altılı sistemde isefsayısından itibaren başa dönülüyor.

On altılı sistemde9sayısından sonra gelen harfleri yadırgamış olabilirsiniz.
Bu durumu şöyle düşünün: Sayı dediğimiz şeyler insan icadı birtakım simgelerden
ibarettir. Daha önce de söylediğimiz gibi, doğada ‘2’ veya ‘7’ diye bir şey
göremezsiniz…

İşte on altılık sistemdeki sayıları gösterebilmek için de birtakım simgelere
ihtiyaç var. İlk on simge, onluk sayma sistemindekilerle aynı. Ancak10’dan
sonraki sayıları gösterebilmek için elimizde başka simge yok. On altılık sistemi
tasarlayanlar, bir tercih sonucu olarak, eksik sembolleri alfabe harfleriyle
tamamlamayı tercih etmişler. Alfabe harfleri yerine pekala Roma rakamlarını da
tercih edebilirlerdi. Eğer bu sistemi tasarlayanlar böyle tercih etmiş olsaydı
bugün on altılık sistemi şöyle gösteriyor olabilirdik:

```python
0
1
2
3
4
5
6
7
8
9
I
II
III
IV
V
VI

```

Bugün bu sayıları bu şekilde kullanmıyor olmamızın tek sebebi, sistemi
tasarlayanların bunu böyle tercih etmemiş olmasıdır…

On altılı sayma sisteminde bir sayıyı oluşturan rakamlar16’nın kuvvetleri
olarak hesaplanır. Peki ama bu sayma sistemindekia,b,c,d,evefharfleriyle nasıl aritmetik işlem yapacağız? Örneğin on altılı sayma
sistemindeki7bcsayısını ele alalım. Bu sayının onlu sistemdeki karşılığını16’nın kuvvetlerini kullanarak hesaplayabiliriz hesaplamasına, ama peki
yukarıda bahsettiğimiz harfler ne olacak? Yani şöyle bir işlem tabii ki mümkün
değil:

```python
>>> ((c * 16 ** 0)) + ((b * 16 ** 1)) + ((7 * 16 ** 2))

```

Elbettecvebsayılarını herhangi bir aritmetik işlemde kullanamayız. Bunun
yerine, bu harflerin onlu sistemdeki karşılıklarını kullanacağız:

a –> 10

b –> 11

c –> 12

d –> 13

e –> 14

f –> 15

Buna göre:

```python
>>> ((12 * (16 ** 0)) + ((11 * (16 ** 1)) + ((7 * (16 ** 2))

1980

```

Demek ki on altılı sistemdeki ‘7bc’ sayısının onlu sistemdeki karşılığı1980’miş.

### İkili Sayma Sistemi

Bildiğiniz, veya orada burada duymuş olabileceğiniz gibi, bilgisayarların
temelinde iki tane sayı vardır:0ve1. Bilgisayarlar bütün işlemleri sadece
bu iki sayı ile yerine getirir.

Onlu, sekizli ve on altılı sayı sistemleri dışında, özellikle bilgisayarların
altyapısında tercih edilen bir başka sayı sistemi daha bulunur. İşte bu sistemin
adı ikili (binary) sayı sistemidir. Nasıl onlu sistemde10, sekizli sistemde8, on altılı sistemde ise sayıları gösteren16farklı simge varsa, bu sayı
sisteminde de sayıları gösteren toplam iki farklı sembol vardır:0ve1.

İkili sayı sisteminde olası bütün sayılar işte bu iki simge ile gösterilir.

Gelin isterseniz durumu daha net bir şekilde görebilmek için yukarıda verdiğimiz
sayı sistemi tablosuna ikili sayıları da ekleyelim:

```python
sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"]

print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri))

for i in range(17):
 print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i))

```

Bu kodlar şu çıktıyı verecektir:

```python
onlu sekizli on altılı ikili
 0 0 0 0
 1 1 1 1
 2 2 2 10
 3 3 3 11
 4 4 4 100
 5 5 5 101
 6 6 6 110
 7 7 7 111
 8 10 8 1000
 9 11 9 1001
 10 12 a 1010
 11 13 b 1011
 12 14 c 1100
 13 15 d 1101
 14 16 e 1110
 15 17 f 1111
 16 20 10 10000

```

Burada, onlu, sekizli ve on altılı sayı sistemleri için geçerli olan durumun
aynen ikili sayı sistemi için de geçerli olduğunu rahatlıkla görebiliyoruz.
İkili sayı sistemindeki mevcut sayıları gösterebilmemiz için toplam iki farklı
simge var. Bunlar:0ve1. İkili sayı sisteminde0ve1diye saymaya
başlayıp üçüncü sayıyı söylememiz gerektiğinde, elimizde0ve1’den başka
simge olmadığı için bir basamak artırıp simge listesinin başına dönüyoruz ve
böylece onluk düzendeki2sayısını ikili düzende gösterebilmek için0ve1’den sonra10simgesini kullanıyoruz.

Bu söylediklerimizden sonra İnternet üzerinde sıkça karşılaştığınız şu sözün
anlamını herhalde artık daha iyi anlıyor olmalısınız:

İnsanlar 10’a ayrılır: İkili sistemi bilenler ve bilmeyenler!

Bu arada, elbette ikili düzendeki10sayısı ‘on’ şeklinde telaffuz edilmiyor.
Bu sayıyı “bir-sıfır” diye seslendiriyoruz…

İkili sayma sisteminde bir sayıyı oluşturan rakamlar2’nin kuvvetleri olarak
hesaplanır. Örneğin ikili sayma sistemindeki1100sayısını ele alalım. Bu
sayıyı2’nin kuvvetlerini kullanarak şu şekilde hesaplayabiliriz:

```python
>>> (0 * (2 ** 0)) + (0 * (2 ** 1)) + (1 * (2 ** 2)) + (1 * (2 ** 3))

12

```

Demek ki ‘1100’ sayısı onlu sistemde12sayısına karşılık geliyormuş.

### Sayma Sistemlerini Birbirine Dönüştürme

Sıklıkla kullanılan dört farklı sayma sistemini öğrendik. Peki biz bir sayma
sisteminden öbürüne dönüştürme işlemi yapmak istersek ne olacak? Örneğin onlu
sistemdeki bir sayıyı ikili sisteme nasıl çevireceğiz?

Python programlama dilinde bu tür işlemleri kolaylıkla yapmamızı sağlayan
birtakım fonksiyonlar bulunur. Ayrıca özel fonksiyonları kullanmanın yanısıra
karakter dizisi biçimlendirme (string formatting) yöntemlerini kullanarak da
sayma sistemlerini birbirine dönüştürebiliriz. Biz burada her iki yöntemi de tek
tek inceleyeceğiz.

Gelin isterseniz bu dönüştürme işlemleri için hangi özel fonksiyonların olduğuna
bakalım önce.

#### Fonksiyon Kullanarak

##### bin()

Bu fonksiyon bir sayının ikili (binary) sayı sistemindeki karşılığını verir:

```python
>>> bin(2)

'0b10'

```

Bu fonksiyonun çıktı olarak bir karakter dizisi verdiğine dikkat edin. Bu
karakter dizisinin ilk iki karakteri (‘0b’), o sayının ikili sisteme ait bir
sayı olduğunu gösteren bir işarettir. Bu bilgilerden yola çıkarak, yukarıdaki
karakter dizisinin gerçek ikili kısmını almak için şu yöntemi
kullanabilirsiniz:

```python
>>> bin(2)[2:]

'10'

```

##### hex()

Bu fonksiyon, herhangi bir sayıyı alıp, o sayının on altılı sistemdeki
karşılığını verir:

```python
>>> hex(10)

'Oxa'

```

Tıpkıbin()fonksiyonunda olduğu gibi,hex()fonksiyonunun da çıktı
olarak bir karakter dizisi verdiğine dikkat edin. Hatırlarsanızbin()fonksiyonunun çıktısındaki ilk iki karakter (0b), o sayının ikili sisteme ait
bir sayı olduğunu gösteren bir işaret olarak kullanılıyordu.hex()fonksiyonunun çıktısındaki ilk iki karakter de (0x), o sayının on altılı
sisteme ait bir sayı olduğunu gösteriyor.

##### oct()

Bu fonksiyon, herhangi bir sayıyı alıp, o sayının sekizli sistemdeki karşılığını
verir:

```python
>>> oct(10)

'0o12'

```

Tıpkıbin()vehex()fonksiyonlarında olduğu gibi,oct()fonksiyonunun da çıktı olarak bir karakter dizisi verdiğine dikkat edin.
Hatırlarsanızbin()vehex()fonksiyonlarının çıktısındaki ilk iki
karakter (0bve0x), o sayıların hangi sisteme ait sayılar olduğunu
gösteriyordu. Aynı şekildeoct()fonksiyonunun çıktısındaki ilk iki karakter
de (0o), o sayının sekizli sisteme ait bir sayı olduğunu gösteriyor.

##### int()

Aslında biz bu fonksiyonu yakından tanıyoruz. Bildiğiniz gibi bu fonksiyon
herhangi bir sayı veya sayı değerli karakter dizisini tam sayıya (integer)
dönüştürmek için kullanılıyor.int()fonksiyonunun şimdiye kadar gördüğümüz
işlevi dışında bir işlevi daha bulunur: Biz bu fonksiyonu kullanarak herhangi
bir sayıyı onlu sistemdeki karşılığına dönüştürebiliriz:

```python
>>> int('7bc', 16)

1980

```

Gördüğünüz gibi, bu fonksiyonu kullanırken dikkat etmemiz gereken bazı noktalar
var. İlkin, eğerint()fonksiyonunu yukarıdaki gibi bir dönüştürme işlemi için
kullanacaksak, bu fonksiyona verdiğimiz ilk parametrenin bir karakter
dizisi olması gerekiyor. Dikkat etmemiz gereken ikinci nokta,int()fonksiyonuna verdiğimiz ikinci parametrenin niteliği. Bu parametre, dönüştürmek
istediğimiz sayının hangi tabanda olduğunu gösteriyor. Yukarıdaki örneğe göre
biz, on altı tabanındaki7bcsayısını on tabanına dönüştürmek istiyoruz.

Bir de şu örneklere bakalım:

```python
>>> int('1100', 2)

12

>>> int('1100', 16)

4352

```

İlk örnekte, ikili sistemdeki1100sayısını onlu sisteme çeviriyoruz ve12sayısını elde ediyoruz. İkinci örnekte ise on altılı sistemdeki1100sayısını
onlu sisteme çeviriyoruz ve4352sayısını elde ediyoruz.

#### Biçimlendirme Yoluyla

Esasında biz karakter dizisi biçimlendirme yöntemlerini kullanarak dönüştürme
işlemlerini nasıl gerçekleştireceğimizi biliyoruz. Biz burada zaten öğrendiğimiz
bu bilgileri tekrar ederek öğrendiklerimizi pekiştirme amacı güdeceğiz.

##### b

Bu karakteri kullanarak bir sayıyı ikili düzendeki karşılığına
dönüştürebiliriz:

```python
>>> '{:b}'.format(12)

'1100'

```

Bu karakter,bin()fonksiyonuyla aynı işi yapar.

##### x

Bu karakteri kullanarak bir sayıyı on altılı düzendeki karşılığına
dönüştürebiliriz:

```python
>>> '{:x}'.format(1980)

'7bc'

```

Bu karakter,hex()fonksiyonuyla aynı işi yapar.

##### o

Bu karakteri kullanarak bir sayıyı sekizli düzendeki karşılığına
dönüştürebiliriz:

```python
>>> '{:o}'.format(1980)

'3674'

```

Bu karakter,oct()fonksiyonuyla aynı işi yapar.

Bütün bu anlattıklarımızdan sonra (eğer o zaman anlamakta zorluk çekmişseniz)
aşağıdaki kodları daha iyi anlamış olmalısınız:

```python
sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"]

print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri))

for i in range(17):
 print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i))

```

Bu arada, yukarıda bir sayının, karakter dizisi biçimlendirme yöntemleri
kullanılarak ikili, sekizli ve on altılı düzene nasıl çevrileceğini gördük. Bir
sayıyı onlu düzene çevirmek için ise sadeceint()fonksiyonunu
kullanabiliyoruz. Böyle bir çevirme işlemini karakter dizisi biçimlendirme
yöntemlerini kullanarak yapamıyoruz. Ama elbette, eğer başka bir sayma
sisteminden onlu sisteme çevirdiğiniz bir sayıyı herhangi bir karakter dizisi
içinde biçimlendirmek isterseniz şöyle bir kod kullanabilirsiniz:

```python
>>> n = '7bc'
>>> "{} sayısının onlu karşılığı {:d} sayısıdır.".format(n, int(n, 16))

```

…veya:

```python
>>> n = '7bc'
>>> "{} sayısının onlu karşılığı {} sayısıdır.".format(n, int(n, 16))

```

Zira bildiğiniz gibi, Python’da onlu sayıları temsil eden harfdharfidir.
Eğer{}yapısı içinde herhangi bir harf kullanmazsanız yukarıdaki durumda
Python{:d}yazmışsınız gibi davranacaktır.

### Sayma Sistemlerinin Birbirlerine Karşı Avantajları

Böylece dört farklı sayı sisteminin hangi mantık üzerine işlediğini anlamış
olduk. Ayrıca sayı sistemleri arasında dönüştürme işlemlerini de öğrendik.

İşte bilgisayarlar bu sayı sistemleri arasında sadece ikili sayı sistemini
‘anlayabilir’. Aslında bu da hiç mantıksız değil. Bilgisayar dediğimiz şey,
üzerinden elektrik geçen devrelerden ibaret bir makinedir. Eğer bir devrede
elektrik yoksa o devrenin değeri ~0 volt iken, o devreden elektrik geçtiğinde
devrenin değeri ~5 volttur. Gördüğünüz gibi, ortada iki farklı değer var: ~0
volt ve ~5 volt. Yukarıda anlattığımız gibi, ikili (binary) sayma sisteminde
de iki değer bulunur:0ve1. Dolayısıyla ikili sayma sistemi bilgisayarın
iç işleyişine en uygun sistemdir. ikili sistemde ~0 volt’u 0 ile, ~5 volt’u ise1ile temsil edebiliyoruz. Yani devreden elektrik geçtiğinde o devrenin değeri1, elektrik geçmediğinde ise0olmuş oluyor. Tabii bilgisayar açısından
bakıldığında devrede elektrik vardır veya yoktur. Biz insanlar bu ikili durumu
daha kolay bir şekilde temsil edebilmek için her bir duruma0ve1gibi bir
ad veriyoruz.

Bilgisayarın işlemcisi sadece bu iki farklı durumu kullanarak her türlü
hesaplama işlemini gerçekleştirebilir. Bu sebeple ikili sayı sistemi
bilgisayarın çalışma mantığı için gayet yeterli ve uygundur. İkili sayı sistemi
yerine mesela onlu sayı sistemini kullanmak herhalde simge israfından başka bir
şey olmazdı. Neticede, dediğimiz gibi, bilgisayarın işleyebilmesi için iki
farklı simge yeterlidir.

Dediğimiz gibi, ikili sayma sistemi bilgisayarın yapısına gayet uygundur. Ama
biz insanlar açısından sadece iki simge yardımıyla saymaya çalışmak epey zor
olacaktır. Ayrıca sayı büyüdükçe, ikili sistemde sayının kapladığı alan hızla ve
kolayca artacak, yığılan bu sayıları idare etmek hiç de kolay olmayacaktır. İşte
bu noktada devreye on altılı (hexadecimal) sayılar girer. Bu sayma sisteminde
toplam16farklı rakam/simge olduğu için, büyük sayılar çok daha az yer
kaplayacak şekilde gösterilebilir.

Bildiğiniz gibi, ikili sayma sistemindeki her bir basamağa ‘bit’ adı verilir.
İkili sayma sistemini kullanarak,0’dan256’ya kadar sayabilmek için toplam8bitlik (yani8hanelik) bir yer kullanmanız gerekir. On altılı sistemde
ise bu işlemi sadece iki basamakla halledebilirsiniz. Yani on altılı sistemde 00
ile FF arasına toplam 255 tane sayı sığdırılabilir. Dolayısıyla on altılı
sistemi kullanarak, çok büyük sayıları çok az yer kullanarak gösterebilirsiniz:

```python
>>> for i in range(256):
... print(i, bin(i)[2:], hex(i)[2:])
...
0 0 0
(...)
255 11111111 ff
>>>

```

Gördüğünüz gibi, onlu sistemde255şeklinde, ikili sistemde ise11111111şeklinde gösterilen sayı on altılı sistemde yalnızcaffşeklinde
gösterilebiliyor. Dolayısıyla, kullanım açısından, biz insanlar için on altılık
sayma sisteminin ikili sisteme kıyasla çok daha pratik bir yöntem olduğunu
söyleyebiliriz.

Ayrıca on altılı sistem, az alana çok veri sığdırabilme özelliği nedeniyle HTML
renk kodlarının gösterilmesinde de tercih edilir. Örneğin beyaz rengi temsil
etmek için on altılı sistemdeki#FFFFFFifadesini kullanmakrgb(255,255,255)ifadesini kullanmaya kıyasla çok daha mantıklıdır. Hatta#FFFFFFifadesini#FFFşeklinde kısaltma imkanı dahi vardır.

## Sayılar

Geçen bölümde sayma sistemlerini ayrıntılı bir şekilde inceledik. Bu bölümde ise
yine bununla bağlantılı bir konu olan sayılar konusunu ele alacağız. Esasında
biz sayıların ne olduğuna ve Python’da bunların nasıl kullanılacağına dair
tamamen bilgisiz değiliz. Buraya gelene kadar, sayılar konusunda epey şey
söyledik aslında. Mesela biz Python’da üç tür sayı olduğunu biliyoruz:
1. Tam Sayılar (integers)
1. Kayan Noktalı Sayılar (floating point numbersveya kısacafloats)
1. Karmaşık Sayılar (complex numbers)

Tam Sayılar (integers)

Kayan Noktalı Sayılar (floating point numbersveya kısacafloats)

Karmaşık Sayılar (complex numbers)

Eğer bir veritype(veri)sorgulamasınaintcevabı veriyorsa o veri bir
tam sayıdır. Eğer bir veritype(veri)sorgulamasınafloatcevabı veriyorsa
o veri bir kayan noktalı sayıdır. Eğer bir veritype(veri)sorgulamasınacomplexcevabını veriyorsa o veri bir karmaşık sayıdır.

Mesela şunlar birer tam sayıdır:

15, 4, 33

Şunlar birer kayan noktalı sayıdır:

3.5, 6.6, 2.3

Şunlarsa birer karmaşık sayıdır:

3+3j, 5+2j, 19+10j

Ayrıca şimdiye kadar öğrendiklerimiz sayesinde bu sayıların çeşitli fonksiyonlar
yardımıyla birbirlerine dönüştürülebileceğini de biliyoruz:
| Fonksiyon | Görevi | Örnek |
| --- | --- | --- |
| int() | Bir veriyi tam sayıya dönüştürür | int('2') |
| float() | Bir veriyi kayan noktalı sayıya
dönüştürür | float(2) |
| complex() | Bir veriyi karmaşık sayıya
dönüştürür | complex(2) |

Fonksiyon

Görevi

Örnek

int()

Bir veriyi tam sayıya dönüştürür

int('2')

float()

Bir veriyi kayan noktalı sayıya
dönüştürür

float(2)

complex()

Bir veriyi karmaşık sayıya
dönüştürür

complex(2)

Dediğimiz gibi, bunlar bizim zaten sayılara dair bildiğimiz şeyler. Elbette bir
de henüz öğrenmediklerimiz var.

Gelin şimdi bunların neler olduğunu inceleyelim.

### Sayıların Metotları

Tıpkı öteki veri tiplerinde olduğu gibi, sayıların da bazı metotları bulunur. Bu
metotları kullanarak sayılar üzerinde çeşitli işlemler gerçekleştirebiliriz.

#### Tam Sayıların Metotları

Dediğimiz gibi, Python’da birkaç farklı sayı tipi bulunur. Biz ilk olarak tam
sayı (integer) denen sayı tipinin metot ve niteliklerini inceleyeceğiz.

Öncelikle hangi metotlar ve niteliklerle karşı karşıya olduğumuza bakalım:

```python
>>> [i for i in dir(int) if not i.startswith("_")]

['bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator',
'real', 'to_bytes']

```

Bu listede şimdilik bizi ilgilendiren tek bir metot var. Bu metodun adıbit_length().

##### bit_length()

Bilgisayarlar hakkında bilmemiz gereken en önemli bilgilerden biri şudur:
Bilgisayarlar ancak ve ancak sayılarla işlem yapabilir. Bilgisayarların işlem
yapabildiği sayılar da onlu sistemdeki sayılar değil, ikili sistemdeki
sayılardır. Yani 0’lar ve 1’ler.

Bilgisayar terminolojisinde bu 0’lar ve 1’lerden oluşan herbir basamağa ‘bit’
adı verilir. Yani ikili sayma sisteminde ‘0’ ve ‘1’ sayılarından herbiri 1
bit’tir. Mesela onlu sistemde2sayısının ikili sistemdeki karşılığı olan10sayısı iki bit’lik bir sayıdır. Onlu sistemdeki100sayısının ikili sistemdeki
karşılığı olan1100100sayısı ise yedi bitlik bir sayıdır.

Bu durumu daha net bir şekilde görebilmek için şu kodları yazalım:

```python
>>> for i in range(11):
... print(i, bin(i)[2:], len(bin(i)[2:]), sep="\t")
...
0 0 1
1 1 1
2 10 2
3 11 2
4 100 3
5 101 3
6 110 3
7 111 3
8 1000 4
9 1001 4
10 1010 4

```

Burada ikinci sütundaki sayılar ilk sütundaki sayıların ikili sistemdeki
karşılıklarıdır. Üçüncü sütundaki sayılar ise her bir sayının kaç bit olduğunu,
yani bir bakıma ikili sayma sisteminde kaç basamağa sahip olduğunu gösteriyor.

İşte herhangi bir tam sayının kaç bit’lik bir yer kapladığını öğrenmek için, tam
sayıların metotlarından biri olanbit_length()metodundan yararlanacağız:

```python
>>> sayı = 10
>>> sayı.bit_length()

4

```

Demek ki10sayısı bellekte dört bitlik bir yer kaplıyormuş. Yani bu sayının
ikili sistemdeki karşılığı olan1010sayısı dört basamaktan oluşuyormuş.

Yukarıdaki örneklerden de rahatlıkla çıkarabileceğiniz gibi,bit_length()metodu, ikili sayma sistemindeki bir sayı üzerinelen()fonksiyonunun
uygulanması ile eşdeğerdir. Yani:

```python
>>> len(bin(10)[2:]) == (10).bit_length()
True

```

Bu arada şu son örnekte bir şey dikkatinizi çekmiş olmalı:bit_length()metodunu doğrudan sayılar üzerine uygulayamıyoruz. Yani:

```python
>>> 10.bit_length()
 File "<stdin>", line 1
 10.bit_length()
 ^
SyntaxError: invalid syntax

```

Bu metodu sayılarla birlikte kullanabilmek için iki seçeneğimiz var:bit_length()metodunu uygulamak istediğimiz sayıyı önce bir değişkene
atayabiliriz:

```python
>>> a = 10
>>> a.bit_length()

4

```

…veya ilgili sayıyı parantez içine alabiliriz:

```python
>>> (10).bit_length()

4

```

Bu durum, yani sayıyı parantez içinde gösterme zorunluluğu,10sayısının
sağına bir nokta işareti koyduğumuzda, Python’ın bu sayıyı bir kayan noktalı
sayı olarak değerlendirmesinden kaynaklanıyor. Yani biz ‘10’ yazıp,bit_length()metodunu bu sayıya bağlama amacıyla sayının sağına bir nokta
koyduğumuz anda, Python bu sayının bir kayan noktalı sayı olduğunu zannediyor.
Çünkü Python açısından,10.sayısı bir kayan noktalı sayıdır. Bunu teyit
edelim:

```python
>>> type(10.)

<class 'float'>

```

Kayan noktalı sayılarınbit_length()adlı bir metodu olmadığı için de
Python’ın bize bir hata mesajı göstermekten başka yapabileceği bir şey kalmıyor.

#### Kayan Noktalı Sayıların Metotları

Python’da tam sayılar dışında kayan noktalı sayıların da olduğunu biliyoruz. Bu
sayı tipinin şu metotları vardır:

```python
>>> [i for i in dir(float) if not i.startswith("_")]

['as_integer_ratio', 'conjugate', 'fromhex', 'hex', 'imag', 'is_integer', 'real']

```

Biz bu metotlar arasından,as_integer_ratio()veis_integer()adlı
metotlarla ilgileneceğiz.

##### as_integer_ratio()

Bu metot, birbirine bölündüğünde ilgili kayan noktalı sayıyı veren iki adet tam
sayı verir bize. Örnek üzerinden açıklayalım:

```python
>>> sayı = 4.5
>>> sayı.as_integer_ratio()

(9, 2)

```

9sayısını2sayısına böldüğümüzde4.5sayısını elde ederiz. İşteas_integer_ratio()metodu, bu9ve2sayılarını bize ayrı ayrı verir.

##### is_integer()

Bir kayan noktalı sayının ondalık kısmında0harici bir sayının olup
olmadığını kontrol etmek için bu metodu kullanıyoruz. Örneğin:

```python
>>> (12.0).is_integer()

True

>>> (12.5).is_integer()

False

```

#### Karmaşık Sayıların Metotları

Gelelim karmaşık sayıların metot ve niteliklerine…

```python
>>> [i for i in dir(complex) if not i.startswith("_")]

['conjugate', 'imag', 'real']

```

Gördüğünüz gibi, karmaşık sayıların da birkaç tane metot ve niteliği var. Biz
bunlar arasındanimagverealadlı nitelikleri inceleyeceğiz.

##### imag

Bir gerçek bir de sanal kısımdan oluşan sayılara karmaşık sayılar (complex)
adı verildiğini biliyorsunuz. Örneğin şu bir karmaşık sayıdır:

12+4j

İşteimagadlı nitelik, bize bir karmaşık sayının sanal kısmını verir:

```python
>>> c = 12+4j
>>> c.imag

4.0

```

##### real

realadlı nitelik bize bir karmaşık sayının gerçek kısmını verir:

```python
>>> c = 12+4j
>>> c.real

12.0

```

### Aritmetik Fonksiyonlar

Python programlama dili, bize sayılarla rahat çalışabilmemiz için bazı
fonksiyonlar sunar. Bu fonksiyonları kullanarak, karmaşık aritmetik işlemleri
kolayca yapabiliriz.

Biz bu bölümde Python’ın bize sunduğu bu gömülü fonksiyonları tek tek
inceleyeceğiz.

Gömülü fonksiyonlar, Python programlama dilinde, herhangi bir özel işlem
yapmamıza gerek olmadan, kodlarımız içinde doğrudan kullanabileceğimiz
fonksiyonlardır. Biz şimdiye kadar pek çok gömülü fonksiyonla zaten tanışmıştık.
O yüzden gömülü fonksiyonlar bizim yabancısı olduğumuz bir konu değil. Mesela
buraya gelene kadar gördüğümüz,len(),range(),type(),open(),print()veid()gibi fonksiyonların tamamı birer gömülü fonksiyondur.
Biz bu fonksiyonları ilerleyen derslerde çok daha ayrıntılı bir şekilde
inceleyeceğiz. Ama şu anda bile fonksiyonlar konusunda epey bilgiye
sahibiz.

Şimdiye kadar öğrendiğimiz gömülü fonksiyonlardan şu listede yer alanlar,
matematik işlemlerinde kullanılmaya uygun olanlardır:
1. complex()
1. float()
1. int()
1. pow()
1. round()
1. hex()
1. oct()
1. bin()

complex()

float()

int()

pow()

round()

hex()

oct()

bin()

Biz bu fonksiyonların ne işe yaradığını önceki derslerimizde zaten ayrıntılı
olarak incelemiştik. O yüzden burada bunlardan söz etmeyeceğiz. Onun yerine,
henüz öğrenmediğimiz, ama mutlaka bilmemiz gereken gömülü fonksiyonları ele
alacağız.

O halde hiç vakit kaybetmeden yola koyulalım…

#### abs()

Bu fonksiyon bize bir sayının mutlak değerini verir:

```python
>>> abs(-2)

2

>>> abs(2)

2

```

#### divmod()

Bu fonksiyon, bir sayının bir sayıya bölünmesi işlemindebölümüvekalanıverir:

```python
>>> divmod(10, 2)

(5, 0)

```

10sayısı2sayısına bölündüğünde ‘bölüm’5, ‘kalan’ ise0’dır.

Bir örnek daha verelim:

```python
>>> divmod(14, 3)

(4, 2)

```

Bu sonuçtan gördüğünüz gibi, aslındadivmod()fonksiyonu şu kodlarla aynı
işi yapıyor:

```python
>>> 14 // 3, 14 % 3

```

Bu fonksiyonun gerçekleştirdiği bölme işleminin bir ‘taban bölme’ işlemi
olduğuna özellikle dikkatinizi çekmek istiyorum.

#### max()

Size şöyle bir soru sorduğumu düşünün: Acaba aşağıdaki listede yer alan
sayıların en büyüğü kaçtır?

```python
[882388, 260409, 72923, 692476, 131925, 259114, 47630, 84513, 25413, 614654,
 239479, 299159, 175488, 345972, 458112, 791030, 243610, 413702, 565285,
 773607, 131583, 979177, 247202, 615485, 647512, 556823, 242460, 852928,
 893126, 792435, 273904, 544434, 627222, 601984, 966446, 384143, 308858,
 915106, 914423, 826315, 258342, 188056, 934954, 253918, 468223, 262875,
 462902, 370061, 336521, 367829, 147846, 838385, 605377, 175140, 957437,
 105779, 153499, 435097, 9934, 435761, 989066, 357279, 341319, 420455,
 220075, 28839, 910043, 891209, 975758, 140968, 837021, 526798, 235190,
 634295, 521918, 400634, 385922, 842289, 106889, 742531, 359913, 842431,
 666182, 516933, 22222, 445705, 589281, 709098, 48521, 513501, 277645,
 860937, 655966, 923944, 7895, 77482, 929007, 562981, 904166, 619260,
 616293, 203512, 67534, 615578, 74381, 484273, 941872, 110617, 53517,
 402324, 156156, 839504 , 625325, 694080, 904277, 163914, 756250, 809689,
 354050, 523654, 26723, 167882, 103404, 689579, 121439, 158946, 485258,
 850804, 650603, 717388, 981770, 573882, 358726, 957285, 418479, 851590,
 960182, 11955, 894146, 856069, 369866, 740623, 867622, 616830, 894801,
 827179, 580024, 987174, 638930, 129200, 214789, 45268, 455924, 655940,
 335481, 845907, 942437, 759380, 790660, 432715, 858959, 289617, 757317,
 982063, 237940, 141714, 939369, 198282, 975017, 785968, 49954, 854914,
 996780, 121633, 436419, 471, 776271, 91626, 209175, 894281, 417963, 624464,
 736535, 418888, 506194, 591087, 64075, 50252, 952943, 25878, 217085,
 223996, 416042, 484123, 810460, 423284, 956886, 237772, 960241, 601551,
 830147, 449088, 364567, 337281, 524358, 980387, 393760, 619710, 100181,
 96738, 275199, 553783, 975654, 662536, 979103, 869504, 702350, 174361,
 970250, 267625, 661580, 444662, 871532, 881977, 981660, 446047, 508758,
 530694, 608789, 339540, 242774, 637473, 874011, 732999, 511638, 744144,
 710805, 641326, 88085, 128487, 59732, 739340, 443638, 830333, 832136,
 882277, 403538, 441349, 721048, 32859]

```

İşte böyle bir soruyu çözmek içinmax()fonksiyonundan yararlanabilirsiniz.
Yukarıdaki listeyisayılaradlı bir değişkene atadığımızı varsayarsak,
aşağıdaki kod bize listedeki en büyük sayıyı verecektir:

```python
>>> max(sayılar)

```

Yukarıdaki örneklerdemax()fonksiyonunu kullanarak bir dizi içindeki enbüyüksayıyı bulduk. Peki bu fonksiyonu kullanarak bir dizi içindeki enuzunkarakter dizisini bulabilir miyiz? Evet, bulabiliriz.

Diyelim ki elimizde şöyle bir liste var:

```python
isimler = ["ahmet", "mehmet", "necla", "sedat", "abdullah",
 "gıyaseddin", "sibel", "can", "necmettin", "savaş", "özgür"]

```

Amacımız bu liste içindeki en uzun kelimeyi bulmak. İşte bunumax()fonksiyonu ile yapabiliriz. Dikkatlice bakın:

```python
print(max(isimler, key=len))

```

Bu kodları çalıştırdığımızda, listedeki en uzun isim olan ‘gıyaseddin’i elde
edeceğiz.

Gördüğünüz gibi,max()fonksiyonukeyadlı özel bir parametre daha alıyor.
Bu parametreye biz ‘len’ değerini verdik. Böylecemax()fonksiyonu liste
içindeki öğeleri uzunluklarına göre sıralayıp en uzun öğeyi bize sundu.

Hatırlarsanız geçen bölümde şöyle bir kod yazmıştık:

```python
sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"]

print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri))

for i in range(17):
 print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i))

```

Bu kodlar, farklı sayma sistemleri arasındaki farkları daha net görmemizi
sağlamıştı. Yalnız burada dikkat ettiyseniz,sayı_sistemleriadlı listeye her
öğe ekleyişimizde, listedeki en uzun değeri dikkate alarak karakter dizisi
biçimlendiricileri içindeki, öğeler arasında ne kadar boşluk bırakılacağını
belirleyen sayıları güncelliyorduk. Mesela yukarıdaki örnekte, öğeler arasında
yeterince boşluk bırakabilmek için bu sayıyı9olarak belirlemiştik. İşte
şimdi öğrendiğimizmax()fonksiyonunu kullanarak bu sayının otomatik olarak
belirlenmesini sağlayabiliriz. Dikkatlice inceleyin:

```python
sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"]

en_uzun = len(max(sayı_sistemleri, key=len))

print(("{:^{aralık}} "*len(sayı_sistemleri)).format(*sayı_sistemleri, aralık=en_uzun))

for i in range(17):
 print("{0:^{1}} {0:^{1}o} {0:^{1}x} {0:^{1}b}".format(i, en_uzun))

```

Gördüğünüz gibi,max()fonksiyonunu ve bu fonksiyonunkeyparametresini
kullanarak, oluşturduğumuz tablodaki öğelerin arasına uygun boşluğu otomatik
olarak eklemiş olduk. Bunun için,sayı_sistemleriadlı listedeki en uzun
öğenin uzunluk miktarını temel aldık.

#### min()

Bu fonksiyon,max()fonksiyonun yaptığı işin tam tersini yapar. Yani bu
fonksiyonu kullanarak bir dizi içindeki en küçük sayıyı bulabilirsiniz:

```python
>>> min(sayılar)

```

Tıpkımax()fonksiyonunda olduğu gibi,min()fonksiyonunda dakeyparametresini kullanabilirsiniz. Meselamax()fonksiyonunu anlatırken
verdiğimiz isim listesindeki en kısa ismi bulabilmek için şu kodu
yazabilirsiniz:

```python
print(min(isimler, key=len))

```

#### sum()

Bu fonksiyon bir dizi içinde yer alan bütün sayıları birbiriyle toplar.
Örneğin:

```python
>>> a = [10, 20, 43, 45 , 77, 2, 0, 1]
>>> sum(a)

198

```

Eğer bu fonksiyonun, toplama işlemini belli bir sayının üzerine
gerçekleştirmesini istiyorsanız şu kodu yazabilirsiniz:

```python
>>> sum(a, 10)

208

```

sum()fonksiyonuna bu şekilde ikinci bir parametre verdiğinizde, bu ikinci
parametre toplam değere eklenecektir.

## Temel Dosya İşlemleri

Hatırlarsanızprint()fonksiyonunu anlatırken, bu fonksiyonunfileadlı
bir parametresi olduğundan söz etmiştik. Bu parametre yardımıylaprint()fonksiyonunun çıktılarını bir dosyaya gönderebiliyorduk. Böyleceprint()fonksiyonunun bu özelliği sayesinde, Python’daki ‘Dosya Girdi/Çıktısı’ (File
I/O) konusuyla da ilk kez tanışmış olmuştuk.

Ayrıcaprint()fonksiyonu dışında,open()adlı başka bir fonksiyon
yardımıyla da dosyaları açabileceğimizi ve bu dosyaların üzerinde çeşitli
işlemleri gerçekleştirebileceğimizi öğrenmiştik. Ancak gerekprint()fonksiyonununfileparametresi, gerekseopen()fonksiyonuyla şimdiye kadar
yaptığımız örnekler aracılığıyla öğrendiklerimiz dosyalara ilişkin çok sınırlı
işlemleri yerine getirmemizi sağlıyordu.

İşte biz bu bölümde, dosya girdi/çıktısı konusuna ilişkin bildiklerimizi bir
adım öteye götüreceğiz ve gerçek anlamda dosyaları nasıl manipüle edeceğimizi
öğreneceğiz.

Programcılık maceramız boyunca dosyalarla bol bol muhatap olacaksınız. O yüzden
bu konuyu olabildiğince ayrıntılı ve anlaşılır bir şekilde anlatmaya
çalışacağız.

Dediğimiz gibi, biz esasında bu noktaya gelinceye kadar çeşitli fonksiyonlar ve
bunların birtakım parametreleri aracılığıyla dosya işlemlerinden az da olsa
zaten söz etmiştik. Dolayısıyla aslında tamamen yabancısı olduğunuz bir konuyla
karşı karşıya olmanız gibi bir durum söz konusu değil. Biz bu bölümde, zaten
aşina olduğumuz bir konuyu çok daha derinlemesine ele alacağız.

Python programlama dilinde dosyalarla uğraşırken bütün dosya işlemleri için
temel olarak tek bir fonksiyondan yararlanacağız. Bu fonksiyonu siz zaten
tanıyorsunuz. Fonksiyonumuzun adıopen().

### Dosya Oluşturmak

Dediğimiz gibi, Python programlama dilinde dosya işlemleri içinopen()adlı
bir fonksiyondan yararlanacağız. İşte dosya oluşturmak için de bu fonksiyonu
kullanacağız.

Önceki derslerimizde verdiğimiz örneklerden de bildiğiniz gibi,open()fonksiyonunu temel olarak şöyle kullanıyoruz:

```python
f = open(dosya_adı, kip)

```

> **Not**
> open()fonksiyonudosya_adıvekipdışında başka parametreler
de alır. İlerleyen sayfalarda bu parametrelerden de söz edeceğiz.

Not

open()fonksiyonudosya_adıvekipdışında başka parametreler
de alır. İlerleyen sayfalarda bu parametrelerden de söz edeceğiz.

Mesela “tahsilat.txt” adlı bir dosyayıyazmakipinde açmak için şöyle bir
komut kullanıyoruz:

```python
tahsilat_dosyası = open("tahsilat_dosyası.txt", "w")

```

Burada ‘tahsilat_dosyası.txt’ ifadesi dosyamızın adını belirtiyor.“w”harfi
ise bu dosyanın yazma kipinde açıldığını söylüyor.

Yukarıdaki komutu çalıştırdığınızda, o anda hangi dizin altında bulunuyorsanız
o dizin içindetahsilat_dosyası.txtadlı boş bir dosyanın oluştuğunu
göreceksiniz.

Bu arada, dosya adını yazarken, dosya adı ile birlikte o dosyanın hangi dizin
altında oluşturulacağını da belirleyebilirsiniz. Örneğin:

```python
dosya = open("/dosyayı/oluşturmak/istediğimiz/dizin/dosya_adı", "w")

```

Eğer dosya adını dizin belirtmeden yazarsanız, oluşturduğunuz dosya, o anda
hangi dizin altında bulunuyorsanız orada oluşacaktır.

Ayrıca dosyayı barındıran dizin adlarını yazarken, dizinleri ayırmak için ters
taksim (\) yerine düz taksim (/) kullanmaya dikkat edin. Aksi halde, dizin
adı oluşturmaya çalışırken yanlışlıkla kaçış dizileri oluşturabilirsiniz.
Esasında siz bu olguya hiç yabancı değilsiniz. Zira kaçış dizilerini anlatırken
şöyle bir örnek verdiğimizi hatırlıyor olmalısınız:

```python
print("C:\aylar\nisan\toplam masraf")

```

İşte eğer bu örnekte olduğu gibi ters taksim işaretleri ile oluşturulmuş dizin
adları kullanırsanız programınız hata verecektir:

```python
>>> open("C:\aylar\nisan\toplam masraf\masraf.txt", "w")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
OSError: [Errno 22] Invalid argument: 'C:\x07ylar\nisan\toplam masraf\masraf.txt'

```

Bunun sebebi, bildiğiniz gibi, Python’ın\a,\nve\tifadelerini birer
kaçış dizisi olarak algılamasıdır. Bu durumdan kaçabilmek için, dizin adlarını
ters taksim işareti ile ayırmanın dışında,radlı kaçış dizisinden de
yararlanabilirsiniz:

```python
>>> open(r"C:\aylar\nisan\toplam masraf\masraf.txt", "w")

```

…veya ters taksim işaretlerini çiftleyebilirsiniz:

```python
>>> open("C:\\aylar\\nisan\\toplam masraf\\masraf.txt", "w")

```

Bu şekilde, eğer bilgisayarınızdaC:\aylar\nisan\toplam masraf\adlı bir
dizin varsa, o dizin içindemasraf.txtadlı bir dosya oluşturulacaktır.

Böylece Python programlama dilinde boş bir dosyanın nasıl oluşturulacağını
öğrenmiş olduk. O halde gelin isterseniz şimdi bu dosyanın içini nasıl
dolduracağımızı öğrenelim.

### Dosyaya Yazmak

Bir dosyayı, yukarıda gösterdiğimiz şekilde yazma kipinde açtığımız zaman,
Python bizim için içi boş bir dosya oluşturacaktır. Peki biz bu dosyanın içini
nasıl dolduracağız?

Python programlama dilinde,open()fonksiyonu ile yazma kipinde açtığımız
bir dosyaya bir veri yazabilmek için dosyalarınwrite()adlı
metodundan yararlanacağız.

Siz aslında bu metodun da nasıl kullanılacağını çok iyi biliyorsunuz:

```python
dosya.write(yazılacak_şeyler)

```

Gelin bu formülü somutlaştıracak bir örnek verelim. Mesela yukarıda
oluşturduğumuz tahsilat dosyasının içine bazı veriler girelim.

Önce dosyamızı nasıl oluşturacağımızı hatırlayalım:

```python
ths = open("tahsilat_dosyası.txt", "w")

```

Şimdi de bu dosyaya şu bilgileri girelim:

```python
ths.write("Halil Pazarlama: 120.000 TL")

```

Yani programımız şöyle görünsün:

```python
ths = open("tahsilat_dosyası.txt", "w")
ths.write("Halil Pazarlama: 120.000 TL")

```

Bu komutları verdiğinizde,tahsilat_dosyası.txtadlı dosyanın içine şu
bilgilerin işlendiğini göreceksiniz:

```python
Halil Pazarlama: 120.000 TL

```

Eğer dosyayı açtığınızda bu bilgi yerine hâlâ boş bir dosya görüyorsanız, sebebi
tamponda tutulan verilerin henüz dosyaya işlenmemiş olmasıdır.

> **Not**
> Bu konuyuprint()fonksiyonununflushadlı parametresini
incelerken öğrendiğimizi hatırlıyor olmalısınız.

Not

Bu konuyuprint()fonksiyonununflushadlı parametresini
incelerken öğrendiğimizi hatırlıyor olmalısınız.

Eğer durum böyleyse, dosyanızı kapatmanız gerekiyor. Bunuclose()adlı başka
bir metotla yapabildiğimizi biliyorsunuz:

```python
ths.close()

```

Bu arada, bu söylediklerimizden, eğer yazdığınız bilgiler zaten dosyaya
işlenmişse dosyayı kapatmanıza gerek olmadığı anlamını çıkarmayın. Herhangi bir
şekilde açtığınız dosyaları kapatmanız, özellikle dosyanın açılmasıyla birlikte
kullanılmaya başlayan ve arka planda çalışan kaynakların serbest bırakılması
açısından büyük önem taşıyor. O yüzden açtığımız dosyaların tamamını programın
işleyişi sona erdiğinde kapatmayı unutmuyoruz. Yani yukarıdaki programı tam
olarak şöyle yazıyoruz:

```python
ths = open("tahsilat_dosyası.txt", "w")
ths.write("Halil Pazarlama: 120.000 TL"),
ths.close()

```

Bu kodlarda sırasıyla şu işlemleri gerçekleştirdik:
1. tahsilat_dosyasıadlı bir dosyayı yazma kipinde açarak, bu adda bir
dosya oluşturulmasını sağladık,
1. write()metodunu kullanarak bu dosyaya bazı bilgiler girdik,
1. Dosyamıza yazdığımız bilgilerin dosyaya işlendiğinden emin olmak ve
işletim sisteminin dosyanın açılması ve dosyaya veri işlenmesi için devreye
soktuğu bütün kaynakları serbest bırakmak içinclose()metoduyla
programımızı kapattık.

tahsilat_dosyasıadlı bir dosyayı yazma kipinde açarak, bu adda bir
dosya oluşturulmasını sağladık,

write()metodunu kullanarak bu dosyaya bazı bilgiler girdik,

Dosyamıza yazdığımız bilgilerin dosyaya işlendiğinden emin olmak ve
işletim sisteminin dosyanın açılması ve dosyaya veri işlenmesi için devreye
soktuğu bütün kaynakları serbest bırakmak içinclose()metoduyla
programımızı kapattık.

Bu arada, bu başlığı kapatmadan önce önemli bir bilgi daha verelim. Python’da
bir dosyayı“w”kipinde açtığımızda, eğer o adda bir dosya ilgili dizin içinde
zaten varsa, Python bu dosyayı sorgusuz sualsiz silip, yerine aynı adda başka
bir boş dosya oluşturacaktır. Yani mesela yukarıdatahsilat_dosyası.txtadlı
dosyayı oluşturup içine bir şeyler yazdıktan sonra bu dosyayı yine“w”kipinde
açmaya çalışırsanız, Python bu dosyanın bütün içeriğini silip, yinetahsilat_dosyası.txtadını taşıyan başka bir dosya oluşturacaktır. O yüzden
dosya işlemleri sırasında bu“w”kipini kullanırken dikkat ediyoruz ve disk
üzerinde var olan dosyalarımızı yanlışlıkla silmiyoruz.

Böylece bir dosyanın nasıl oluşturulacağını, nasıl açılacağını ve içine birtakım
bilgilerin nasıl girileceğini kabataslak da olsa öğrenmiş olduk. Şimdi de
dosyaları nasılokuyacağımızıöğrenelim.

### Dosya Okumak

Bir önceki başlıkta dosyaların içine bilgi girme işleminin Python programlama
dilinde nasıl yapıldığını inceledik. Elbette bir dosyaya yazabilmenin yanısıra,
bilgisayarınızda halihazırda var olan bir dosyayı okumak da isteyeceksiniz. Peki
bunu nasıl yapacaksınız?

Python’da bir dosyayı okumak için yukarıda anlattığımız yazma yöntemine benzer
bir yöntem kullanacağız. Bildiğiniz gibi, bir dosyayı yazma kipinde açmak için“w”harfini kullanıyoruz. Bir dosyayı okuma kipinde açmak için ise“r”harfini kullanacağız.

Mesela, bilgisayarımızda var olanfihrist.txtadlı dosyayı okumak üzere
açalım:

```python
fihrist = open("fihrist.txt", "r")

```

Bir dosyayıopen()fonksiyonu yardımıyla açarken kip parametresi için“r”harfini kullanırsak, Python o dosyayı okuma yetkisiyle açacaktır. Yalnız burada
şöyle bir özellik var: Eğer bir dosyayı okuma kipinde açacaksanız, bu“r”harfini hiç belirtmeseniz de olur. Yani şu komut bilgisayarımızdakifihrist.txtadlı dosyayı okuma kipinde açacaktır:

```python
fihrist = open("fihrist.txt")

```

Dolayısıyla bir dosyayı açarken kip belirtmediğimizde Python bizim o dosyayı
okuma kipinde açmak istediğimizi varsayacaktır.

Hatırlarsanız,“w”kipiyle açtığımız bir dosyaya yazmak içinwrite()adlı
bir metottan yararlanıyorduk.“r”kipiyle açtığımız bir dosyayı okumak için
iseread(),readline()vereadlines()adlı üç farklı metottan
yararlanacağız.

Yukarıdaki üç metot da Python’da dosya okuma işlemlerini gerçekleştirmemizi
sağlar. Peki bu metotların üçü de aynı işi yapıyorsa neden tek bir metot değil
de üç farklı metot var?

Bu metotların üçü de dosya okumaya yarasa da, verdikleri çıktılar birbirinden
farklıdır. O yüzden farklı amaçlar için farklı metodu kullanmanız gereken
durumlarla karşılaşabilirsiniz.

Bu metotlar arasındaki farkı anlamanın en kolay yolu bu üç metodu sırayla
kullanıp, çıktıları incelemektir.

Öncelikle içeriği şu olan,fihrist.txtadlı bir dosyamızın olduğunu
varsayalım:

```python
Ahmet Özbudak : 0533 123 23 34
Mehmet Sülün : 0532 212 22 22
Sami Sam : 0542 333 34 34

```

Şimdi bir dosya açıp şu kodları yazalım:

```python
fihrist = open("fihrist.txt")
print(fihrist.read())

```

Bu kodları çalıştırdığımızda, eğer kullandığınız işletim sistemi GNU/Linux ise
muhtemelen şu çıktıyı elde edeceksiniz:

```python
Ahmet Özbudak : 0533 123 23 34
Mehmet Sülün : 0532 212 22 22
Sami Sam : 0542 333 34 34

```

Ama eğer bu kodları Windows’ta çalıştırdıysanız Türkçe karakterler bozuk çıkmış
olabilir. Bu durumu şimdilik görmezden gelin. Birazdan bu durumun nedenini
açıklayacağız.

Yukarıda elde ettiğimiz şey bir karakter dizisidir bunu şu şekilde teyit
edebileceğinizi biliyorsunuz:

```python
fihrist = open("fihrist.txt")
print(type(fihrist.read()))

```

Gördüğünüz gibi,read()metodu bize, dosyanın bütün içeriğini bir karakter
dizisi olarak veriyor. Bir de şuna bakalım:

```python
fihrist = open("fihrist.txt")
print(fihrist.readline())

```

Burada dareadline()metodunu kullandık. Bu kodlar bize şöyle bir çıktı
veriyor:

```python
Ahmet Özbudak : 0533 123 23 34

```

read()metodu bize dosya içeriğinin tamamını veriyordu. Gördüğünüz gibireadline()metodu tek bir satır veriyor. Yani bu metot yardımıyla dosyaları
satır satır okuyabiliyoruz.

Bu metodun işleyiş tarzını daha iyi görebilmek için bu kodları dosyaya yazıp
çalıştırmak yerine etkileşimli kabuk üzerinden de çalıştırabilirsiniz:

```python
>>> fihrist = open("fihrist.txt", "r")
>>> print(fihrist.readline())

Ahmet Özbudak : 0533 123 23 34

>>> print(fihrist.readline())

Mehmet Sülün : 0532 212 22 22

>>> print(fihrist.readline())

Sami Sam : 0542 333 34 34

```

Gördüğünüz gibi,readline()metodu gerçekten de dosyayı satır satır okuyor.

Son satırı da okuduktan sonra,readline()metodunu tekrar çalıştırırsak ne
olur peki? Bakalım:

```python
>>> print(fihrist.readline())

```

Gördüğünüz gibi, bu defa hiçbir çıktı almadık. Çünkü dosyada okunacak satır
kalmadı. Bu yüzden de Python bize boş bir çıktı verdi. Bu durumu daha net görmek
için kodu etkileşimli kabuktaprint()olmadan yazabilirsiniz:

```python
>>> fihrist.readline()

''

```

Gerçekten de elimizdeki şey boş bir karakter dizisi… Demek ki bir dosya
tamamen okunduktan sonra, Python otomatik olarak tekrar dosyanın başına
dönmüyor. Böyle bir durumda dosyanın başına nasıl geri döneceğimizi
inceleyeceğiz, ama isterseniz biz başka bir konuyla devam edelim.

> **Not**
> Bir dosyanın tamamı okunduktan sonra otomatik olarak başa sarılmaması
özelliği sadecereadline()metodu için değil, öteki bütün dosya okuma
metotları için de geçerlidir. Yani bir dosyayıread(),readline()veyareadlines()metotlarından herhangi biri ile okuduğunuzda imleç başa dönmez.

Not

Bir dosyanın tamamı okunduktan sonra otomatik olarak başa sarılmaması
özelliği sadecereadline()metodu için değil, öteki bütün dosya okuma
metotları için de geçerlidir. Yani bir dosyayıread(),readline()veyareadlines()metotlarından herhangi biri ile okuduğunuzda imleç başa dönmez.

Dediğimiz ve gösterdiğimiz gibi,read()vereadline()metotları bize bir
karakter dizisi döndürüyor. Bu iki metot arasındaki fark ise,read()metodunun dosyanın tamamını önümüze sererken,readline()metodunun dosyayı
satır satır okuyup, her defasında tek bir satırı önümüze sürmesidir. Bir dereadlines()metodunun ne yaptığına bakalım…

Şu kodları yazalım:

```python
fihrist = open("fihrist.txt")
print(fihrist.readlines())

```

Bu kodları yazdığımızda şuna benzer bir çıktı alacağız:

```python
['Ahmet Özbudak : 0533 123 23 34\n', 'Mehmet Sülün : 0532 212 22 22\n',
 'Sami Sam : 0542 333 34 34']

```

Gördüğünüz gibi, bu defa karakter dizisi yerine bir liste ile karşılaşıyoruz.
Demek kiread()vereadline()metotları çıktı olarak bize bir karakter
dizisi verirken,readlines()metodu liste veriyormuş. Bunun neden önemli bir
bilgi olduğunu artık gayet iyi biliyor olmanız lazım. Zira bir verinin tipi, o
veriyle neler yapıp neler yapamayacağımızı doğrudan etkiler…

### Dosyaları Otomatik Kapatma

Daha önce de söylediğimiz gibi, bir dosyayı açıp bu dosya üzerinde gerekli
işlemleri yaptıktan sonra bu dosyayı açık bırakmamak büyük önem taşır.
Dolayısıyla üzerinde işlem yaptığımız bütün dosyaları, işimiz bittikten sonra,
mutlaka kapatmalıyız. Çünkü bir dosya açıldığında işletim sistemi, sistem
kaynaklarının bir kısmını bu dosyaya ayırır. Eğer dosyayı açık bırakırsak,
sistem kaynaklarını gereksiz yere meşgul etmiş oluruz. Ancak farklı sebeplerden,
dosyalar açıldıktan sonra kapanmayabilir. Örneğin açtığınız dosyayı kapatmayı
unutmuş olabilirsiniz. Yani programınızın hiçbir yerindeclose()metodunu
kullanmamışsınızdır. Bunun dışında, programınızdaki bir hata da dosyaların
kapanmasını engelleyebilir. Örneğin bir dosya açıldıktan sonra programda
beklenmeyen bir hata gerçekleşirse, programınız aslaclose()satırına
ulaşamayabilir. Bu durumda da açılan dosya kapanmadan öylece bekler.

Bu tür durumlara karşı iki seçeneğiniz var:
1. try...except...finally...bloklarından yararlanmak
1. withadlı bir deyimi kullanmak

try...except...finally...bloklarından yararlanmak

withadlı bir deyimi kullanmak

Birinci yöntemden daha önce de bahsettiğimizi hatırlıyorsunuz. Hata yakalama
bölümünü anlatırken bununla ilgili şöyle bir örnek vermiştik:

```python
try:
 dosya = open("dosyaadı", "r")
 ...burada dosyayla bazı işlemler yapıyoruz...
 ...ve ansızın bir hata oluşuyor...
except IOError:
 print("bir hata oluştu!")
finally:
 dosya.close()

```

Bu yöntem gayet uygun ve iyi bir yöntemdir. Ancak Python bize bu tür durumlar
için çok daha pratik bir yöntem sunar. Dikkatlice bakın:

```python
with open("dosyaadı", "r") as dosya:
 print(dosya.read())

```

Dosyalarımızı bu şekilde açıp üzerlerinde işlemlerimizi yaptığımızda Python
dosyayı bizim için kendisi kapatacaktır. Bu şekilde bizim ayrıca birclose()satırı yazmamıza gerek yok.withdeyimini kullanmamız sayesinde, dosya
açıldıktan sonra arada bir hata oluşsa bile Python dosyayı sağsalim kapatıp
sistem kaynaklarının israf edilmesini önleyecektir.

### Dosyayı İleri-Geri Sarmak

Dosya okumak için kullanılan metotları anlatırken, dosya bir kez okunduktan
sonra imlecin otomatik olarak dosyanın başına dönmediğini görmüştük. Yani meselaread()metoduyla dosyayı bir kez okuduktan sonra, dosyayı tekrar okumak
istersek elde edeceğimiz şey boş bir karakter dizisi olacaktır. Çünkü dosya
okunduktan sonra okunacak başka bir satır kalmamış, imleç dosya sonuna ulaşmış
ve otomatik olarak da başa dönmemiştir. Bu olguyu etkileşimli kabuk üzerinde
daha net bir şekilde görebileceğinizi biliyorsunuz.

Peki dosyayı tamamen okuduktan sonra tekrar başa dönmek istersek ne yapacağız?
Bir dosya tamamen okunduktan sonra tekrar başa dönmek için dosyalarınseek()adlı bir metodundan yararlanacağız.

Mesela şu örneklere bakalım. Bu örnekleri daha iyi anlamak için bunları
Python’ın etkileşimli kabuğunda çalıştırmanızı tavsiye ederim:

```python
>>> f = open("python.txt")
>>> f.read()

'Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcı\ntarafından 90’lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan,\nisminin Python olmasına aldanarak, bu programlama dilinin,
adını piton\nyılanından aldığını düşünür. Ancak zannedildiğinin aksine bu
programlama dilinin\nadı piton yılanından gelmez. Guido Van Rossum bu
programlama dilini, The Monty\nPython adlı bir İngiliz komedi grubunun,
Monty Python’s Flying Circus adlı\ngösterisinden esinlenerek adlandırmıştır.
Ancak her ne kadar gerçek böyle olsa\nda, Python programlama dilinin pek çok
yerde bir yılan figürü ile temsil\nedilmesi neredeyse bir gelenek halini
almıştır.\n'

```

Buradaopen()fonksiyonunu kullanarakpython.txtadlı bir dosyayı açıp,read()metodu yardımıyla da bu dosyanın içeriğini okuduk. Bu noktada dosyayı
tekrar okumaya çalışırsak elde edeceğimiz şey boş bir karakter dizisi
olacaktır:

```python
>>> f.read()

''

```

Çünkü dosya bir kez tamamen okunduktan sonra imleç otomatik olarak başa
dönmüyor. Dosyayı tekrar okumak istiyorsak, bunu başa bizim sarmamız lazım. İşte
bunun içinseek()metodunu kullanacağız:

```python
>>> f.seek(0)

```

Gördüğünüz gibiseek()metodunu bir parametre ile birlikte kullandık. Bu
metoda verdiğimiz parametre, dosya içinde kaçıncı bayt konumuna gideceğimizi
gösteriyor. Biz burada0sayısını kullanarak dosyanın ilk baytına, yani en
başına dönmüş olduk. Artık dosyayı tekrar okuyabiliriz:

```python
>>> f.read()

'Bu programlama dili Guido Van Rossum adlı Hollandalı bir
programcı\ntarafından 90’lı yılların başında geliştirilmeye başlanmıştır.
Çoğu insan,\nisminin Python olmasına aldanarak, bu programlama dilinin,
adını piton\nyılanından aldığını düşünür. Ancak zannedildiğinin aksine bu
programlama dilinin\nadı piton yılanından gelmez. Guido Van Rossum bu
programlama dilini, The Monty\nPython adlı bir İngiliz komedi grubunun,
Monty Python’s Flying Circus adlı\ngösterisinden esinlenerek adlandırmıştır.
Ancak her ne kadar gerçek böyle olsa\nda, Python programlama dilinin pek çok
yerde bir yılan figürü ile temsil\nedilmesi neredeyse bir gelenek halini
almıştır.\n'

```

Elbetteseek()metodunu kullanarak istediğiniz bayt konumuna dönebilirsiniz.
Mesela eğer dosyanın10.baytının bulunduğu konuma dönmek isterseniz bu metodu
şöyle kullanabilirsiniz:

```python
>>> f.seek(10)

```

Eğer o anda dosyanın hangi bayt konumunda bulunduğunuzu öğrenmek isterseniz detell()adlı başka bir metottan yararlanabilirsiniz. Bu metodu parametresiz
olarak kullanıyoruz:

```python
>>> f.tell()

20

```

Bu çıktıya göre o anda dosyanın20.baytının üzerindeyiz…

Bu arada, dosya içinde bulunduğumuz konumu baytlar üzerinden tarif etmemizi
biraz yadırgamış olabilirsiniz. Acaba neden karakter değil de bayt? Biraz sonra
bu konuya geleceğiz. Biz şimdilik önemli başka bir konuya değinelim.

### Dosyalarda Değişiklik Yapmak

Buraya kadar, Python’da bir dosyanın nasıl oluşturulacağını, boş bir dosyaya
nasıl veri girileceğini ve varolan bir dosyadan nasıl veri okunacağını öğrendik.
Ama varolan ve içi halihazırda dolu bir dosyaya nasıl veri ekleneceğini
bilmiyoruz. İşte şimdi bu işlemin nasıl yapılacağını tartışacağız.

Ancak burada önemli bir ayrıntıya dikkatinizi çekmek istiyorum. Dosyaların
neresinde değişiklik yapmak istediğiniz büyük önem taşır. Unutmayın, dosyaların
başında, ortasında ve sonunda değişiklik yapmak birbirlerinden farklı kavramlar
olup, birbirinden farklı işlemlerin uygulanmasını gerektirir.

Biz bu bölümde dosyaların baş tarafına, ortasına ve sonuna nasıl veri eklenip
çıkarılacağını ayrı ayrı tartışacağız.

#### Dosyaların Sonunda Değişiklik Yapmak

Daha önce de söylediğimiz gibi, Python’da bir dosyayı açarken, o dosyayı hangi
kipte açacağımızı belirtmemiz gerekiyor. Yani eğer bir dosyayı okumak istiyorsak
dosyayı“r”kipinde, yazmak istiyorsak da“w”kipinde açmamız gerekiyor.
Bildiğiniz gibi“w”kipi dosya içeriğini tamamen siliyor.

Eğer bir dosyayıtamamen silmeden, o dosyaya ekleme yapmak veya o dosyada
herhangi bir değişiklik yapmak istiyorsak, dosyamızı buraya kadar öğrendiğimiz
iki kipten daha farklı bir kiple açmamız gerekiyor. Şimdi öğreneceğimiz bu yeni
kipin adı“a”. Yani Python’da içi boş olmayan bir dosyada değişiklik
yapabilmek için“a”adlı bir kipten yararlanacağız:

```python
f = open(dosya_adı, "a")

```

Örneğin yukarıda verdiğimizfihrist.txtadlı dosyayı bu kipte açalım ve
dosyaya yeni bir girdi ekleyelim:

```python
with open("fihrist.txt", "a") as f:
 f.write("Selin Özden\t: 0212 222 22 22")

```

Gördüğünüz gibi, dosyaya yeni eklediğimiz girdiler otomatik olarak dosyanın
sonuna ilave ediliyor. Burada şu noktaya dikkat etmeniz lazım. Dosyanın sonunda
bir satır başı karakterinin (\n) bulunup bulunmamasına bağlı olarak, dosyaya
eklediğiniz yeni satırlar düzgün bir şekilde bir alt satıra geçebileceği gibi,
dosyanın son satırının yanına da eklenebilir. Dolayısıyla duruma göre yukarıdaki
satırı şu şekilde yazmanız gerekebilir:

```python
with open("fihrist.txt", "a") as f:
 f.write("\nSelin Özden\t: 0212 222 22 22")

```

Burada bir alt satıra geçebilmek için ‘Selin’ ifadesinden önce bir satır başı
karakteri eklediğimize dikkat edin. Ayrıca eğer bu satırdan sonra bir başka
satır daha ekleyecekseniz, ilgili satırın sonuna da bir satır başı karakteri
koymanız gerekebilir:

```python
with open("fihrist.txt", "a") as f:
 f.write("Selin Özden\t: 0212 222 22 22\n")

```

Karşı karşıya olduğunuz duruma göre, satır başı karakterlerine ihtiyacınız olup
olmadığını ve ihtiyacınız varsa bunları nereye yerleştireceğinizi kendiniz
değerlendirmelisiniz.

#### Dosyaların Başında Değişiklik Yapmak

Bir önceki bölümde dosya sonuna nasıl yeni satır ekleyeceğimizi öğrendik. Ama
siz programcılık maceranız sırasında muhtemelen dosyaların sonuna değil de, en
başına ekleme yapmanız gereken durumlarla da karşılaşacaksınız. Python’da bu işi
yapmak da çok kolaydır.

Örnek olması açısından,fihrist.txtadlı dosyanın içeriğini ele alalım:

```python
Ahmet Özbudak : 0533 123 23 34
Mehmet Sülün : 0532 212 22 22
Sami Sam : 0542 333 34 34
Selin Özden : 0212 222 22 22

```

Dosya içeriği bu. Eğer bu dosyayı“a”kipi ile açtıktan sonra doğrudanwrite()metodunu kullanarak bir ekleme yaparsak, yeni değer dosyanın sonuna
eklenecektir. Ama biz mesela şu veriyi:

```python
Sedat Köz : 0322 234 45 45

```

‘Ahmet Özbudak : 0533 123 23 34’ girdisinin hemen üstüne, yani dosyanın sonuna
değil de en başına eklemek istersek ne yapacağız?

Öncelikle şu kodları deneyelim:

```python
with open("fihrist.txt", "r") as f:
 veri = f.read()
 f.seek(0) #Dosyayı başa sarıyoruz
 f.write("Sedat Köz\t: 0322 234 45 45\n"+veri)

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda Python bize şu hatayı
verecektir:

```python
Traceback (most recent call last):
 File "deneme.py", line 4, in <module>
 f.write("Sedat Köz\t: 0322 234 45 45\n"+veri)
io.UnsupportedOperation: not writable

```

Bu hatayı almamızın sebebi dosyayı ‘okuma’ kipinde açmış olmamız. Çünkü bir
dosyayı okuma kipinde açtığımızda o dosya üzerinde yalnızca okuma işlemleri
yapabiliriz. Dosyaya yeni veri ekleme kısmına gelindiğinde, dosya yalnızca okuma
yetkisine sahip olduğu için, Python bize yukarıdaki hata mesajını verecek,
dosyanın ‘yazılamaz’ olduğundan şikayet edecektir.

Peki dosyayı“w”karakteri yardımıyla yazma kipinde açarsak ne olur? O zaman
da şu meş’um hatayı alırız:

```python
Traceback (most recent call last):
 File "deneme.py", line 2, in <module>
 veri = f.read()
io.UnsupportedOperation: not readable

```

Gördüğünüz gibi, bu kez de dosyanın okunamadığına ilişkin bir hata alıyoruz.
Çünkü biz bu kez de dosyayı ‘yazma’ kipinde açtık. Ancak burada şöyle bir durum
var. Bildiğiniz gibi, bir dosyayı“w”kipi ile açtığımızda, Python bize hiçbir
şey sormadan varolan içeriği silecektir. Burada da yukarıda yazdığımız kodlar
yüzünden dosya içeriğini kaybettik. Unutmayın, dosya okuma-yazma işlemleri belli
bir takım riskleri içinde barındırır. O yüzden bu tür işlemleri yaparken
fazladan dikkat göstermeliyiz.

Yukarıda da gördüğümüz gibi, dosyamızı“r”veya“w”kiplerinde açmak işe
yaramadı. Peki ne yapacağız? Bunun cevabı çok basit: Dosyamızı hem okuma hem de
yazma kipinde açacağız. Bunun için de farklı bir kip kullanacağız. Dikkatlice
bakın:

```python
with open("fihrist.txt", "r+") as f:
 veri = f.read()
 f.seek(0) #Dosyayı başa sarıyoruz
 f.write("Sedat Köz\t: 0322 234 45 45\n"+veri)

```

Burada“r+”adlı yeni bir kip kullandığımıza dikkat edin.“+”işareti bir
dosyayı hem okuma hem de yazma kipinde açmamıza yardımcı olur. İşte bu işareti“r”kipiyle birlikte“r+”şeklinde kullanarak dosyamızı hem okuma hem de
yazma kipinde açmayı başardık. Artık ilgili dosya üzerinde hem okuma hem de
yazma işlemlerini aynı anda gerçekleştirebiliriz.

Yukarıdaki kodlarda ilk satırın ardından şöyle bir kod yazdık:

```python
veri = f.read()

```

Böylece dosyanın bütün içeriğiniveriadlı bir değişkene atamış olduk. Peki bu
işlemi yapmazsak ne olur? Yani mesela şöyle bir kod yazarsak:

```python
with open("fihrist.txt", "r+") as f:
 f.seek(0)
 f.write("Sedat Köz\t: 0322 234 45 45\n")

```

Bu şekilde ‘Sedat Köz\t: 0322 234 45 45\n’ satırı, dosyadaki ilk satırı silip
onun yerine geçecektir. Çünküf.seek(0)ile dosyanın başına dönüp o noktaya,
yani dosyanın ilk satırına bir veri ekledikten sonra Python öbür satırları
otomatik olarak bir alt satıra kaydırmaz. Bunun yerine ilk satırdaki verileri
silip onun yerine, yeni eklenen satırı getirir. Eğer yapmak istediğiniz şey
buysa ne âlâ. Bu kodları kullanabilirsiniz. Ama bizim istediğimiz şey bu değil.
O yüzdenveri = f.read()satırını kullanarak dosya içeriğini bir değişken
içinde depoluyoruz ve böylece bu verileri kaybetmemiş oluyoruz.

Bu satırın ardından gelenf.seek(0)satırının ne işe yaradığını biliyorsunuz.
Biz yeni veriyi dosyanın en başına eklemek istediğimiz için, doğal olarak bu kod
yardımıyla dosyanın en başına sarıyoruz. Böylece şu kod:

```python
f.write("Sedat Köz\t: 0322 234 45 45\n"+veri)

```

Sedat Köz\t: 0322 234 45 45\n’ satırını dosyanın en başına ekliyor. Ayrıca
burada, biraz önceverideğişkenine atadığımız dosya içeriğini de yeni
eklediğimiz satırın hemen arkasına ilave ettiğimize dikkat edin. Eğer bunu
yapmazsanız, elinizde sadece Sedat Köz’ün iletişim bilgilerini barındıran bir
dosya olacaktır…

#### Dosyaların Ortasında Değişiklik Yapmak

Gördüğünüz gibi, Python’da bir dosyanın en sonuna ve en başına veri eklemek çok
zor değil. Birkaç satır yardımıyla bu işlemleri rahatlıkla yapabiliyoruz. Peki
ya bir dosyanın en başına veya en sonuna değil de rastgele bir yerine ekleme
yapmak istersek ne olacak?

Hatırlarsanız, Python’da her veri tipinin farklı özellikleri olduğundan, her
veri tipinin farklı açılardan birbirlerine karşı üstünlükleri ya da zayıflıkları
olduğundan söz etmiştik. Dediğimiz gibi, Python’da bazı işler için bazı veri
tiplerini kullanmak daha pratik ve avantajlı olabilir. Örneğin karakter dizileri
değiştirilemeyen veri tipleri olduğu için, mesela bir metinde değişiklik
yapmamız gereken durumlarda, eğer mümkünse listeleri kullanmak daha mantıklı
olabilir. Zira bildiğiniz gibi, karakter dizilerinin aksine listeler
değiştirilebilir veri tipleridir.

Önceki sayfalarda bir dosyayı okurken üç farklı metottan yararlanabileceğimizi
öğrenmiştik. Bu metotlarınread(),readline()vereadlines()adlı
metotlar olduğunu biliyorsunuz. Bu üç metottanread()adlı olanı bize çıktı
olarak bir karakter dizisi veriyor.readline()metodu ise dosyaları satır
satır okuyor ve bize yine bir karakter dizisi veriyor. Sonuncu metot olanreadlines()ise bize bir liste veriyor.readline()metodundan
farklı olarakreadlines()metodu dosyanın tamamını bir çırpıda okuyor.

Bu üç metot arasından, adıreadlines()olanının, dosyaların herhangi bir
yerinde değişiklik yapmak konusunda bize yardımcı olabileceğini tahmin etmiş
olabilirsiniz. Çünkü dediğimiz gibireadlines()metodu bize bir dosyanın
içeriğini liste halinde veriyor. Bildiğiniz gibi listeler, üzerinde değişiklik
yapılabilen veri tipleridir. Listelerin bu özelliğinden yararlanarak, dosyaların
herhangi bir yerinde yapmak istediğimiz değişiklikleri rahatlıkla yapabiliriz.
Şimdi dikkatlice bakın şu kodlara:

```python
with open("fihrist.txt", "r+") as f:
 veri = f.readlines()
 veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n")
 f.seek(0)
 f.writelines(veri)

```

Bu kodları bir dosyaya kaydedip çalıştırdıysanız, istediğimiz işlemi başarıyla
yerine getirdiğini görmüşsünüzdür. Peki ama bu kodlar nasıl çalışıyor?

Yukarıdaki kodlarda dikkatimizi çeken pek çok özellik var. İlk olarak gözümüze
çarpan şey, dosyayı“r+”kipinde açmış olmamız. Bu şekilde dosyayı hem okuma
hem de yazma kipinde açmış oluyoruz. Çünkü dosyada aynı anda hem okuma hem de
yazma işlemleri gerçekleştireceğiz.

Daha sonra şöyle bir satır yazdık:

```python
veri = f.readlines()

```

Bu sayede dosyadaki bütün verileri bir liste olarak almış olduk. Liste adlı veri
tipi ile ne yapabiliyorsak, bu şekilde aldığımız dosya içeriği üzerinde de aynı
şeyleri yapabiliriz. Bizim amacımız bu listenin2.sırasına yeni bir satır
eklemek. Bu işlemi listelerininsert()adlı metodu yardımıyla rahatlıkla
yapabiliriz:

```python
veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n")

```

Bu şekilde liste üzerinde istediğimiz değişiklikleri yaptıktan sonra tekrar
dosyanın başına dönmemiz lazım. Çünküreadlines()metoduyla dosyayı bir kez
tam olarak okuduktan sonra imleç o anda dosyanın en sonunda bulunuyor. Eğer
dosyanın en başına dönmeden herhangi bir yazma işlemi gerçekleştirirsek, yazılan
veriler dosyanın sonuna eklenecektir. Bizim yapmamız gereken şey dosyanın en
başına sarıp, değiştirilmiş verilerin dosyaya yazılmasını sağlamak olmalı. Bunu
da şu satır yardımıyla yapıyoruz:

```python
f.seek(0)

```

Son olarak da bütün verileri dosyaya yazıyoruz:

```python
f.writelines(veri)

```

Şimdiye kadar dosyaya yazma işlemleri içinwrite()adlı bir metottan
yararlanmıştık. Burada isewritelines()adlı başka bir metot görüyoruz. Peki
bu iki metot arasındaki fark nedir?

write()metodu bir dosyaya yalnızca karakter dizilerini yazabilir. Bu metot
yardımıyla dosyaya liste tipinde herhangi bir veri yazamazsınız. Eğer mutlakawrite()metodunu kullanmak isterseniz, liste üzerinde birfordöngüsü
kurmanız gerekir. O zaman yukarıdaki kodları şöyle yazmanız gerekir:

```python
with open("fihrist.txt", "r+") as f:
 veri = f.readlines()
 veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n")
 f.seek(0)
 for öğe in veri:
 f.write(öğe)

```

writelines()adlı metot ise bize dosyaya liste tipinde verileri yazma imkanı
verir. Dolayısıyla herhangi bir döngü kurmak zorunda kalmadan listeleri
dosyalarımıza yazabiliriz.

Böylece Python’da dosyaların herhangi bir yerine nasıl yazabileceğimizi öğrenmiş
olduk. Bu arada eğer isteseydik yukarıdaki kodları şöyle de yazabilirdik:

```python
with open("fihrist.txt", "r") as f:
 veri = f.readlines()

with open("fihrist.txt", "w") as f:
 veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n")
 f.writelines(veri)

```

Bir önceki kodlardan farklı olarak bu kodlarda dosyamızı önce okuma kipinde açıp
verileriveriadlı bir değişken içinde sakladık. Ardından aynı dosyayı bir kez
de yazma kipinde açarak, gerekli değişiklikleri liste üzerinde
gerçekleştirdikten sonra bütün verileri dosyaya yazdık.

Unutmayın, Python’da herhangi bir işlemi pek çok farklı şekilde
gerçekleştirebilirsiniz. Biz yukarıda olası yöntemlerden bazılarını ele aldık.
Zaten bütün yöntemleri tek tek göstermemiz pek mümkün olmazdı. Siz dosyalara
ilişkin bilgilerinizi ve farklı araçları kullanarak aynı işlemleri çok daha
farklı şekillerde de yapabilirsiniz. Yani karşı karşıya olduğunuz durumu
değerlendirip, yukarıdaki kodlardan uygun olanını veya kendi bulduğunuz bambaşka
bir yöntemi kullanabilirsiniz.

Bu arada, aslında yukarıdaki kodlarda uyguladığımız yöntem biraz güvensiz. Çünkü
aynı dosyayı hem okuyup hem de bu dosyaya yeni veri ekliyoruz. Eğer bu
işlemlerin herhangi bir aşamasında bir hata oluşursa, bütün değişiklikleri
dosyaya işleyemeden dosya içeriğini tümden kaybedebiliriz. Bu tür risklere karşı
en uygun çözüm, okuma ve yazma işlemlerini ayrı dosyalar üzerinde
gerçekleştirmektir. Bunun nasıl yapılacağından biraz sonra söz edeceğiz. Biz
şimdi başka bir konuya değinelim.

### Dosyaya Erişme Kipleri

Dosyalar konusunu anlatırken yukarıda verdiğimiz örneklerden de gördüğünüz gibi,
Python’da dosyalara erişimin türünü ve niteliğini belirleyen bazı kipler var. Bu
kipler dosyaların açılırken hangi yetkilere sahip olacağını veya olmayacağını
belirliyor. Gelin isterseniz bu kipleri tek tek ele alalım.
| Kip | Açıklaması |
| --- | --- |
| "r" | Bu öntanımlı kiptir. Bu kip dosyayı okuma yetkisiyle açar. Ancak bu kipi
kullanabilmemiz için, ilgili dosyanın disk üzerinde halihazırda var olması
gerekir. Eğer bu kipte açılmak istenen dosya mevcut değilse Python bize bir
hata mesajı gösterecektir. Dediğimiz gibi, bu öntanımlı kiptir. Dolayısıyla
dosyayı açarken herhangi bir kip belirtmezsek Python dosyayı bu kipte açmak
istediğimizi varsayacaktır. |
| "w" | Bu kip dosyayı yazma yetkisiyle açar. Eğer belirttiğiniz adda bir dosya zaten
disk üzerinde varsa, Python hiçbir şey sormadan dosya içeriğini silecektir.
Eğer belirttiğiniz adda bir dosya diskte yoksa, Python o adda bir dosyayı
otomatik olarak oluşturur. |
| "a" | Bu kip dosyayı yazma yetkisiyle açar. Eğer dosya zaten disk üzerinde
mevcutsa içeriğinde herhangi bir değişiklik yapılmaz. Bu kipte açtığınız bir
dosyaya eklediğiniz veriler varolan verilere ilave edilir. Eğer
belirttiğiniz adda bir dosya yoksa Python otomatik olarak o adda bir dosyayı
sizin için oluşturacaktır. |
| "x" | Bu kip dosyayı yazma yetkisiyle açar. Eğer belirttiğiniz adda bir dosya
zaten disk üzerinde varsa, Python varolan dosyayı silmek yerine size bir
hata mesajı gösterir. Zaten bu kipin“w”kipinden farkı, varolan dosyaları
silmemesidir. Eğer belirttiğiniz adda bir dosya diskte yoksa, bu kip
yardımıyla o ada sahip bir dosya oluşturabilirsiniz. |
| "r+" | Bu kip, bir dosyayı hem yazma hem de okuma yetkisiyle açar. Bu kipi
kullanabilmeniz için, belirttiğiniz dosyanın disk üzerinde mevcut olması
gerekir. |
| "w+" | Bu kip bir dosyayı hem yazma hem de okuma yetkisiyle açar. Eğer dosya
mevcutsa içerik silinir, eğer dosya mevcut değilse oluşturulur. |
| "a+" | Bu kip bir dosyayı hem yazma hem de okuma yetkisiyle açar. Eğer dosya zaten
disk üzerinde mevcutsa içeriğinde herhangi bir değişiklik yapılmaz. Bu kipte
açtığınız bir dosyaya eklediğiniz veriler varolan verilere ilave edilir.
Eğer belirttiğiniz adda bir dosya yoksa Python otomatik olarak o adda bir
dosyayı sizin için oluşturacaktır. |
| "x+" | Bu kip dosyayı hem okuma hem de yazma yetkisiyle açar. Eğer belirttiğiniz
adda bir dosya zaten disk üzerinde varsa, Python varolan dosyayı silmek
yerine size bir hata mesajı gösterir. Zaten bu kipin“w+”kipinden farkı,
varolan dosyaları silmemesidir. Eğer belirttiğiniz adda bir dosya diskte
yoksa, bu kip yardımıyla o ada sahip bir dosya oluşturup bu dosyayı hem
okuma hem de yazma yetkisiyle açabilirsiniz. |
| "rb" | Bu kip, metin dosyaları ile ikili (binary) dosyaları ayırt eden
sistemlerde ikili dosyaları okuma yetkisiyle açmak için kullanılır.“r”kipi için söylenenler bu kip için de geçerlidir. |
| "wb" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“w”kipi için
söylenenler bu kip için de geçerlidir. |
| "ab" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“a”kipi için
söylenenler bu kip için de geçerlidir. |
| "xb" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“x”kipi için
söylenenler bu kip için de geçerlidir. |
| "rb+" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“r+”kipi için söylenenler bu kip için de geçerlidir. |
| "wb+" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“w+”kipi için söylenenler bu kip için de geçerlidir. |
| "ab+" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“a+”kipi için söylenenler bu kip için de geçerlidir. |
| "xb+" | Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“x+”kipi için söylenenler bu kip için de geçerlidir. |

Kip

Açıklaması

"r"

Bu öntanımlı kiptir. Bu kip dosyayı okuma yetkisiyle açar. Ancak bu kipi
kullanabilmemiz için, ilgili dosyanın disk üzerinde halihazırda var olması
gerekir. Eğer bu kipte açılmak istenen dosya mevcut değilse Python bize bir
hata mesajı gösterecektir. Dediğimiz gibi, bu öntanımlı kiptir. Dolayısıyla
dosyayı açarken herhangi bir kip belirtmezsek Python dosyayı bu kipte açmak
istediğimizi varsayacaktır.

"w"

Bu kip dosyayı yazma yetkisiyle açar. Eğer belirttiğiniz adda bir dosya zaten
disk üzerinde varsa, Python hiçbir şey sormadan dosya içeriğini silecektir.
Eğer belirttiğiniz adda bir dosya diskte yoksa, Python o adda bir dosyayı
otomatik olarak oluşturur.

"a"

Bu kip dosyayı yazma yetkisiyle açar. Eğer dosya zaten disk üzerinde
mevcutsa içeriğinde herhangi bir değişiklik yapılmaz. Bu kipte açtığınız bir
dosyaya eklediğiniz veriler varolan verilere ilave edilir. Eğer
belirttiğiniz adda bir dosya yoksa Python otomatik olarak o adda bir dosyayı
sizin için oluşturacaktır.

"x"

Bu kip dosyayı yazma yetkisiyle açar. Eğer belirttiğiniz adda bir dosya
zaten disk üzerinde varsa, Python varolan dosyayı silmek yerine size bir
hata mesajı gösterir. Zaten bu kipin“w”kipinden farkı, varolan dosyaları
silmemesidir. Eğer belirttiğiniz adda bir dosya diskte yoksa, bu kip
yardımıyla o ada sahip bir dosya oluşturabilirsiniz.

"r+"

Bu kip, bir dosyayı hem yazma hem de okuma yetkisiyle açar. Bu kipi
kullanabilmeniz için, belirttiğiniz dosyanın disk üzerinde mevcut olması
gerekir.

"w+"

Bu kip bir dosyayı hem yazma hem de okuma yetkisiyle açar. Eğer dosya
mevcutsa içerik silinir, eğer dosya mevcut değilse oluşturulur.

"a+"

Bu kip bir dosyayı hem yazma hem de okuma yetkisiyle açar. Eğer dosya zaten
disk üzerinde mevcutsa içeriğinde herhangi bir değişiklik yapılmaz. Bu kipte
açtığınız bir dosyaya eklediğiniz veriler varolan verilere ilave edilir.
Eğer belirttiğiniz adda bir dosya yoksa Python otomatik olarak o adda bir
dosyayı sizin için oluşturacaktır.

"x+"

Bu kip dosyayı hem okuma hem de yazma yetkisiyle açar. Eğer belirttiğiniz
adda bir dosya zaten disk üzerinde varsa, Python varolan dosyayı silmek
yerine size bir hata mesajı gösterir. Zaten bu kipin“w+”kipinden farkı,
varolan dosyaları silmemesidir. Eğer belirttiğiniz adda bir dosya diskte
yoksa, bu kip yardımıyla o ada sahip bir dosya oluşturup bu dosyayı hem
okuma hem de yazma yetkisiyle açabilirsiniz.

"rb"

Bu kip, metin dosyaları ile ikili (binary) dosyaları ayırt eden
sistemlerde ikili dosyaları okuma yetkisiyle açmak için kullanılır.“r”kipi için söylenenler bu kip için de geçerlidir.

"wb"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“w”kipi için
söylenenler bu kip için de geçerlidir.

"ab"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“a”kipi için
söylenenler bu kip için de geçerlidir.

"xb"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları yazma yetkisiyle açmak için kullanılır.“x”kipi için
söylenenler bu kip için de geçerlidir.

"rb+"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“r+”kipi için söylenenler bu kip için de geçerlidir.

"wb+"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“w+”kipi için söylenenler bu kip için de geçerlidir.

"ab+"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“a+”kipi için söylenenler bu kip için de geçerlidir.

"xb+"

Bu kip, metin dosyaları ile ikili dosyaları ayırt eden sistemlerde ikili
dosyaları hem okuma hem de yazma yetkisiyle açmak için kullanılır.“x+”kipi için söylenenler bu kip için de geçerlidir.

Bütün bu tabloya baktığınızda ilk bakışta sanki bir sürü farklı erişim kipi
olduğunu düşünmüş olabilirsiniz. Ama aslında tabloyu biraz daha incelerseniz,
temel olarak“r”,“w”,“a”, “x” ve“b”kiplerinin olduğunu, geri kalan
kiplerin ise bunların kombinasyonlarından oluştuğunu göreceksiniz.

Daha önce de söylediğimiz gibi, dosya işlemlerini pek çok farklı yöntemle
gerçekleştirebilirsiniz. Yukarıdaki tabloyu dikkatlice inceleyerek, yapmak
istediğiniz işleme uygun kipi rahatlıkla seçebilirsiniz.

Bu arada, yukarıdaki tabloda değindiğimiz ikili (binary) dosyalardan henüz söz
etmedik. Bir sonraki bölümde bu dosya türünü de ele alacağız.

## Dosyaların Metot ve Nitelikleri

Dosyalara ilişkin olarak bir önceki bölümde anlattığımız şeylerin kafanıza
yatması açısından size şu bilgiyi de verelim: Dosyalar da, tıpkı karakter
dizileri ve listeler gibi, Python programlama dilindeki veri tiplerinden
biridir. Dolayısıyla tıpkı karakter dizileri ve listeler gibi, dosya (file)
adlı bu veri tipinin de bazı metotları ve nitelikleri vardır. Gelin isterseniz
bu metot ve niteliklerin neler olduğunu şöyle bir listeleyelim:

```python
dosya = open("falanca_dosya.txt", "w")
print(*[metot for metot in dir(dosya) if not metot.startswith("_")], sep="\n")

```

Bu kodlar, dosya adlı veri tipinin bizi ilgilendiren bütün metotlarını alt alta
ekrana basacaktır. Eğer yukarıdaki kodları anlamakta zorluk çektiyseniz, bunları
şöyle de yazabilirsiniz:

```python
dosya = open("falanca_dosya.txt", "w")

for metot in dir(dosya):
 if not metot.startswith("_"):
 print(metot, sep="\n")

```

Bildiğiniz gibi bu kodlar bir öncekiyle tamamen aynı anlama geliyor.

Bu kodları çalıştırdığınızda karşınıza pek çok metot çıkacak. Biz buraya gelene
kadar bu metotların en önemlilerini zaten inceledik. İncelemediğimiz yalnızca
birkaç önemli metot (ve nitelik) kaldı. Gelin isterseniz henüz incelemediğimiz
bu önemli metot ve nitelikleri gözden geçirelim.

### closed Niteliği

Bu nitelik, bir dosyanın kapalı olup olmadığını sorgulamamızı sağlar. Dosya
adınınfolduğunu varsayarsak, bu niteliği şöyle kullanıyoruz:

```python
f.closed

```

Eğerfadlı bu dosya kapalıysaTrueçıktısı, açıksaFalseçıktısı
verilecektir.

### readable() Metodu

Bu metot bir dosyanın okuma yetkisine sahip olup olmadığını sorgulamamızı
sağlar. Eğer bir dosya“r”gibi bir kiple açılmışsa, yani o dosya ‘okunabilir’
özellikle ise bu metot bizeTrueçıktısı verir. Ama eğer dosya yazma kipinde
açılmışsa bu metot bizeFalseçıktısı verecektir.

### writable() Metodu

Bu metot bir dosyanın yazma yetkisine sahip olup olmadığını sorgulamamızı
sağlar. Eğer bir dosya“w”gibi bir kiple açılmışsa, yani o dosya
‘yazılabilir’ özellikle ise bu metot bizeTrueçıktısı verir. Ama eğer dosya
okuma kipinde açılmışsa bu metot bizeFalseçıktısı verecektir.

### truncate() Metodu

Bu metot, henüz işlemediğimiz metotlar arasında en önemlilerinden biridir. Bu
metot yardımıyla dosyalarımızı istediğimiz boyuta getirebiliyoruz.

İngilizcedetruncatekelimesi ‘budamak, kırpmak’ gibi anlamlara gelir. Bu
metodun yaptığı iş de bu anlamıyla uyumludur. Bu metodu temel olarak şöyle
kullanıyoruz:

```python
>>> with open("falanca.txt", "r+") as f:
... f.truncate()

```

Bu komutu bu şekilde kullandığımızda dosyanın bütün içeriği silinecektir. Yani
bu kodlar, sanki dosyayı“w”kipiyle açmışsınız gibi bir etki ortaya
çıkaracaktır.

truncate()metodu yukarıda gördüğünüz şekilde parametresiz olarak
kullanılabileceği gibi, parametreli olarak da kullanılabilir. Bu metodun
parantezleri arasına, dosyanın kaç baytlık bir boyuta sahip olmasını
istediğinizi yazabilirsiniz. Örneğin:

```python
>>> with open("falanca.txt", "r+") as f:
... f.truncate(10)

```

Bu kodlar,falanca.txtadlı dosyanın ilk10baytı dışındaki bütün verileri
siler. Yani dosyayı yalnızca10baytlık bir boyuta sahip olacak şekilde
kırpar.

Gelin isterseniz bu metotla ilgili bir örnek verelim. Elimizdeki dosyanın şu
içeriğe sahip olduğunu varsayalım:

```python
Ahmet Özbudak : 0533 123 23 34
Mehmet Sülün : 0532 212 22 22
Sami Sam : 0542 333 34 34

```

Amacımız dosyadaki şu iki satırı tamamen silmek:

```python
Mehmet Sülün : 0532 212 22 22
Sami Sam : 0542 333 34 34

```

Yani dosyanın yeni içeriğinin tam olarak şöyle olmasını istiyoruz:

```python
Ahmet Özbudak : 0533 123 23 34

```

Bunun içintruncate()metodundan yararlanarak şu kodları yazabiliriz:

```python
with open("fihrist.txt", "r+") as f:
 f.readline()
 f.seek(f.tell())
 f.truncate()

```

Bu kodları bir dosyaya kaydedip çalıştırdığınızda, istediğiniz sonucu elde
ettiğinizi göreceksiniz.

Burada sırasıyla şu işlemleri gerçekleştirdik:
1. Önce dosyamızı hem okuma hem de yazma kipinde açtık. Çünkü aynı dosya
üzerinde hem okuma hem de yazma işlemleri gerçekleştireceğiz:withopen("fihrist.txt","r+")asf:
1. Ardından dosyadan tek bir satır okuduk:f.readline()
1. Daha sonra,truncate()metodunun imleç konumundan itibaren kırpma işlemi
gerçekleştirebilmesi için imleci dosya içinde o anda bulunduğumuz konuma, yani
ikinci satırın başına getirdik. Bildiğiniz gibi dosyalarıntell()metodu, o
anda dosya içinde hangi konumda bulunduğumuzu bildiriyor. Biz biraz önce
yazdığımızreadline()komutu yardımıyla dosyadan bir satır okuduğumuz için,
o anda ikinci satırın başında bulunuyoruz. İşteseek()metodunu vetell()metodundan elde ettiğimiz bu konum bilgisini kullanarak imleci
istediğimiz konuma getirdik:f.seek(f.tell())
1. İmleci istediğimiz konuma getirdiğimize göre artık kırpma işlemini
gerçekleştirebiliriz:f.truncate()

Önce dosyamızı hem okuma hem de yazma kipinde açtık. Çünkü aynı dosya
üzerinde hem okuma hem de yazma işlemleri gerçekleştireceğiz:

```python
with open("fihrist.txt", "r+") as f:

```

Ardından dosyadan tek bir satır okuduk:

```python
f.readline()

```

Daha sonra,truncate()metodunun imleç konumundan itibaren kırpma işlemi
gerçekleştirebilmesi için imleci dosya içinde o anda bulunduğumuz konuma, yani
ikinci satırın başına getirdik. Bildiğiniz gibi dosyalarıntell()metodu, o
anda dosya içinde hangi konumda bulunduğumuzu bildiriyor. Biz biraz önce
yazdığımızreadline()komutu yardımıyla dosyadan bir satır okuduğumuz için,
o anda ikinci satırın başında bulunuyoruz. İşteseek()metodunu vetell()metodundan elde ettiğimiz bu konum bilgisini kullanarak imleci
istediğimiz konuma getirdik:

```python
f.seek(f.tell())

```

İmleci istediğimiz konuma getirdiğimize göre artık kırpma işlemini
gerçekleştirebiliriz:

```python
f.truncate()

```

Artık elimizde tek satırlık bir dosya var…

truncate()metodunun, yukarıda anlattığımızdan farklı bir özelliği daha
var. Her ne kadartruncatekelimesi ‘kırpmak’ anlamına gelse ve bu metotla
dosya boyutlarını küçültebilsek bile, bu metodu kullanarak aynı zamanda dosya
boyutlarını artırabiliriz de. Örneğin boyutu1kilobayt olan bir dosyayı3kilobayta çıkarmak için bu metodu şöyle kullanabiliriz:

```python
>>> f = open("fihrist.txt", "r+")
>>> f.truncate(1024*3)
>>> f.close()

```

Dosyanın boyutunu kontrol edecek olursanız, dosyanın gerçekten de 3 kilobayt’a
çıktığını göreceksiniz. Peki bu metot bu işi nasıl yapıyor? Aslında bunun cevabı
çok basit: Dosyanın sonuna gereken miktarda0ekleyerek… Zaten eğerfihrist.txtadlı bu dosyayı tekrar açıp okursanız bu durumu kendiniz de
görebilirsiniz:

```python
>>> f = open("fihrist.txt")
>>> f.read()

```

Gördüğünüz gibi, dosya sıfırlarla dolu.

### mode Niteliği

Bu nitelik, bize bir dosyanın hangi kipte açıldığına dair bilgi verir:

```python
>>> f = open("falanca.txt")
>>> f.mode

'r'

```

Demek ki bu dosya“r”kipinde açılmış…

### name Niteliği

Bu nitelik, bize bir dosyanın adını verir:

```python
>>> f.name

'falanca.txt'

```

### encoding Niteliği

Bu nitelik, bize bir dosyanın hangi dil kodlaması ile kodlandığını söyler:

```python
>>> f.encoding

'utf-8'

```

veya:

```python
>>> f.encoding

'cp1254' #Windows

```

> **Not**
> Bu ‘dil kodlaması’ konusunu ilerleyen sayfalarda ayrıntılı olarak inceleyeceğiz.

Not

Bu ‘dil kodlaması’ konusunu ilerleyen sayfalarda ayrıntılı olarak inceleyeceğiz.

Böylece dosyaların en önemli metot ve niteliklerini incelemiş olduk. Bu arada,
gerek bu derste, gerekse önceki derslerde verdiğimiz örneklerden, ‘metot’ ile
‘nitelik’ kavramları arasındaki farkı anladığınızı zannediyorum. Metotlar bir iş
yaparken, nitelikler bir değer gösterir. Nitelikler basit birer değişkenden
ibarettir. Metotlar ise bir işin nasıl yapılacağı ile ilgili süreci tanımlar.
Esasında bu ikisi arasındaki farkları çok fazla kafaya takmanıza gerek yok.
Zamanla (özellikle de başka programların kaynak kodlarını incelemeye
başladığınızda) bu ikisi arasındaki farkı bariz bir biçimde göreceksiniz. O
noktaya geldiğinizde, zaten kavramlar arasındaki farkları görmeniz konusunda biz
de size yardımcı olmaya çalışacağız.

## İkili (Binary) Dosyalar

Dosyalar çoğunlukla iki farklı sınıfa ayrılır: Metin dosyaları ve ikili
dosyalar. Metin dosyaları derken neyi kastettiğimiz az çok anlaşılıyor. Eğer bir
dosyayı bir metin düzenleyici ile açtığınızda herhangi bir dilde yazılmış
‘okunabilir’ bir metin görüyorsanız, o dosya bir metin dosyasıdır. Mesela
Notepad, Gedit, Kwrite veya benzeri metin düzenleyicileri kullanarak
oluşturduğunuz dosyalar birer metin dosyasıdır. Şimdiye kadar verdiğimiz bütün
örnekler metin dosyalarını içeriyordu. Peki ‘ikili’ (binary) dosya ne demek?

İkili dosyalar ise, metin dosyalarının aksine, metin düzenleyicilerle
açılamayan, açılmaya çalışıldığında ise çoğunlukla anlamsız karakterler içeren
bir dosya türüdür. Resim dosyaları, müzik dosyaları, video dosyaları, MS Office
dosyaları, LibreOffice dosyaları, OpenOffice dosyaları, vb. ikili dosyalara
örnektir.

Önceki bölümlerde de ifade ettiğimiz gibi, bilgisayarlar yalnızca sayılarla
işlem yapabilir. Bilgisayarların üzerinde işlem yapabildiği bu sayıların0ve1adlı iki sayı olduğunu biliyoruz.

Peki bu iki farklı sayıyı kullanarak neler yapabiliriz? Aslında, bu iki farklı
sayıyı kullanarak her türlü işlemi yapabiliriz: Basit veya karmaşık aritmetik
hesaplamalar, metin düzenleme, resim veya video düzenleme, web siteleri
hazırlama, uzaya mekik gönderme… Bütün bu işlemleri sadece iki farklı sayı
kullanarak yapabiliriz. Daha doğrusu bilgisayarlar yapabilir.

Durum böyle olmasına rağmen, ilk bilgisayarlar yalnızca hesaplama işlemleri için
kullanılıyordu. Yani metin içeren işlemleri yapmak bilgisayarların değil, mesela
daktiloların görevi olarak görülüyordu. Bu durumu telefon teknolojisi ile
kıyaslayabilirsiniz. Bildiğiniz gibi, ilk telefonlar yalnızca iki kişi
arasındaki sesli iletişimi sağlamak için kullanılıyordu. Ama yeni nesil
telefonlar artık ikiden fazla kişi arasındaki sesli ve görüntülü iletişimi
sağlayabilmenin yanısıra, önceleri birbirinden farklı cihazlarla
gerçekleştirilen işlemleri artık tek başına yerine getirebiliyor.

İlk bilgisayarlarda ise metinlerin, daha doğrusu karakterlerin görevi bir hayli
sınırlıydı.

Başta da söylediğimiz gibi, çoğunlukla dosyalar iki farklı sınıfa ayrılır: Metin
dosyaları ve ikili dosyalar. Ama işin aslı sadece tek bir dosya türü vardır:
İkili dosyalar (binary files). Yani bilgisayarlar açısından bütün dosyalar,
içlerinde ne olursa olsun, birer ikili dosyadır ve içlerinde sadece 0’ları ve
1’leri barındırır. İşte bu 0 ve 1’lerin ne anlama geleceğini, işletim sistemleri
ve bu sistemler üzerine kurulu yazılımlar belirler. Eğer bir dosya metin
dosyasıysa bu dosyadaki 0 ve 1’ler birer karakter/harf olarak yorumlanır. Ama
eğer dosya bir ikili dosyaysa dosya içindeki 0 ve 1’ler özel birtakım veriler
olarak ele alınır ve bu verileri okuyan yazılıma göre değer kazanır. Örneğin
eğer ilgili dosya bir resim dosyasıyla, bu dosya herhangi bir resim
görüntüleyici yazılım ile açıldığında karşımıza bir resim çıkar. Eğer ilgili
dosya bir video dosyasıyla, bu dosya bir video görüntüleyici yazılım ile
açıldığında karşımıza bir video çıkar. Bu olgudan bir sonraki bölümde daha
ayrıntılı olarak söz edeceğiz. Biz şimdilik işin sadece pratiğine yoğunlaşalım
ve temel olarak iki farklı dosya çeşidi olduğunu varsayalım: Metin dosyaları ve
ikili dosyalar.

Buraya gelene kadar hep metin dosyalarından söz etmiştik. Şimdi ise ikili
dosyalardan söz edeceğiz.

Hatırlarsanız metin dosyalarını açmak için temel olarak şöyle bir komut
kullanıyorduk:

```python
f = open(dosya_adı, 'r')

```

Bu şekilde bir metin dosyasını okuma kipinde açmış oluyoruz. Bir metin dosyasını
değil de, ikili bir dosyayı açmak için ise şu komutu kullanacağız:

```python
f = open(dosya_adı, 'rb')

```

Dosyaya erişme kiplerini gösterdiğimiz tabloda ikili erişim türlerini de
verdiğimizi hatırlıyorsunuz.

Peki neden metin dosyaları ve ikili dosyalar için farklı erişim kipleri
kullanıyoruz?

İşletim sistemleri satır sonları için birbirinden farklı karakterler
kullanırlar. Örneğin GNU/Linux dağıtımlarında satır sonları\nkarakteri ile
gösterilir. Windows işletim sistemi ise satır sonlarını\r\nkarakterleriyle
gösterir. İşte Python herhangi bir dosyayı açarken, eğer o dosya bir metin
dosyası ise, satır sonlarını gösteren karakterleri, dosyanın açıldığı işletim
sistemine göre ayarlar. Yani satır sonlarını standart bir hale getirerek\nkarakterine dönüştürür.

Metin dosyaları ile ikili dosyalar arasında önemli bir fark bulunur: Bir metin
dosyasındaki ufak değişiklikler dosyanın okunamaz hale gelmesine yol açmaz.
Olabilecek en kötü şey, değiştirilen karakterin okunamaz hale gelmesidir. Ancak
ikili dosyalarda ufak değişiklikler dosyanın tümden bozulmasına yol açabilir.
Dolayısıyla Python’ın yukarıda bahsedilen satır sonu değişiklikleri ikili
dosyaların bozulmasına yol açabilir. Yani eğer siz ikili bir dosyayı‘rb’yerine sadece‘r’gibi bir kiple açarsanız dosyanın bozulmasına yol
açabilirsiniz. İkili bir dosyayı‘rb’(veya‘wb’,‘ab’,‘xb’, vb.) gibi
bir kipte açtığınızda Python satır sonlarına herhangi bir değiştirme-dönüştürme
işlemi uygulamaz. Böylece dosya bozulma riskiyle karşı karşıya kalmaz. O yüzden,
metin dosyalarını ve ikili dosyaları açarken farklı kipler kullanmamız
gerektiğine dikkat ediyoruz.

### İkili Dosyalarla Örnekler

Gelin isterseniz bu noktada birkaç örnek verelim.

#### PDF Dosyalarından Bilgi Alma

Tıpkı resim, müzik ve video dosyaları gibi,PDFdosyaları da birer ikili
dosyadır. O halde hemen önümüze birPDFdosyası alalım ve bu dosyayı okuma
kipinde açalım:

```python
>>> f = open("falanca.pdf", "rb")

```

Şimdi de bu dosyadan10baytlık bir veri okuyalım:

```python
>>> f.read(10)

b'%PDF-1.3\n4'

```

Bu çıktıda gördüğünüz‘b’işaretine şimdilik takılmayın. Birazdan bunun ne
olduğunu bütün ayrıntılarıyla anlatacağız. Biz bu harfin, elimizdeki verinin
bayt türünde bir veri olduğunu gösteren bir işaret olduğunu bilelim yeter.

Gördüğünüz gibi, birPDFdosyasının ilk birkaç baytını okuyarak hem dosyanın
birPDFbelgesi olduğunu teyit edebiliyoruz, hem de buPDFbelgesinin, hangiPDFsürümü ile oluşturulduğunu anlayabiliyoruz. Buna göre bu belge PDF
talimatnamesinin 1.3 numaralı sürümü ile oluşturulmuş.

Eğer biz bu belgeyi bir ikili dosya olarak değil de bir metin dosyası olarak
açmaya çalışsaydık şöyle bir hata alacaktık:

```python
>>> f = open("falanca.pdf")
>>> okunan = f.read()

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "C:\Python33\lib\encodings\cp1254.py", line 23, in decode
 return codecs.charmap_decode(input,self.errors,decoding_table)[0]
UnicodeDecodeError: 'charmap' codec can't decode byte 0x9d in position 527: char
acter maps to <undefined>

```

Python’ın bu dosyanın bir ikili dosya olduğu konusunda bilgilendirerek, dosyanın
düzgün bir şekilde açılıp okunabilmesini sağlıyoruz.

Gelin buPDFbelgesi üzerinde biraz daha çalışalım.

PDFbelgelerinde, o belge hakkında bazı önemli bilgiler veren birtakım özel
etiketler bulunur. Bu etiketler şunlardır:
| Etiket | Anlamı |
| --- | --- |
| /Creator | Belgeyi oluşturan yazılım |
| /Producer | Belgeyi PDF’e çeviren yazılım |
| /Title | Belgenin başlığı |
| /Author | Belgenin yazarı |
| /Subject | Belgenin konusu |
| /Keywords | Belgenin anahtar kelimeleri |
| /CreationDate | Belgenin oluşturulma zamanı |
| /ModDate | Belgenin değiştirilme zamanı |

Etiket

Anlamı

/Creator

Belgeyi oluşturan yazılım

/Producer

Belgeyi PDF’e çeviren yazılım

/Title

Belgenin başlığı

/Author

Belgenin yazarı

/Subject

Belgenin konusu

/Keywords

Belgenin anahtar kelimeleri

/CreationDate

Belgenin oluşturulma zamanı

/ModDate

Belgenin değiştirilme zamanı

Bu etiketlerin tamamı bütünPDFdosyalarında tanımlı değildir. Ama özellikle/Produceretiketi herPDFdosyasında bulunur.

Şimdi örnek olması bakımından elimize birPDFdosyası alalım ve bunu güzelce
okuyalım:

```python
>>> f = open("falanca.pdf", "rb")
>>> okunan = f.read()

```

Şimdi de/Producerifadesinin dosya içinde geçtiği noktanın sıra numarasını
bulalım. Bildiğiniz gibi, dosyalarınread()metodu bize bir karakter dizisi
verir. Yine bildiğiniz gibi, karakter dizilerininindex()metodu yardımıyla
bir öğenin karakter dizisi içinde geçtiği noktayı bulabiliyoruz. Yani:

```python
>>> producer_index = okunan.index(b"/Producer")

```

Burada/Producerifadesinin başına‘b’harfini yerleştirmeyi unutmuyoruz.
Çünkü şu anda yaptığımız işlem ikili bir dosya içinde geçen birtakım baytları
arama işlemidir.

producer_indexdeğişkeni, ‘/Producer’ ifadesinin ilk baytının dosya içindeki
konumunu tutuyor. Kontrol edelim:

```python
>>> producer_index

4077883

```

Bu değerin gerçekten de ‘/Producer’ ifadesinin ilk baytını depoladığını teyit
edelim:

```python
>>> okunan[producer_index]

47

```

Daha önce de dediğimiz gibi, bilgisayarlar yalnızca sayıları görür. Bu sayının
hangi karaktere karşılık geldiğini bulmak içinchr()fonksiyonundan
yararlanabilirsiniz:

```python
>>> chr(okunan[producer_index])

'/'

```

Gördüğünüz gibi, gerçekten deproducer_indexdeğişkeni ‘/Producer’ ifadesinin
ilk baytının dosya içindeki konumunu gösteriyor. Biz bu konumu ve bu konumun 50-60
bayt ötesini sorgularsak,PDFbelgesini üreten yazılımın adına ulaşabiliriz.
Dikkatlice bakın:

```python
>>> okunan[producer_index:producer_index+50]

b'/Producer (Acrobat Distiller 2.0 for Macintosh)\r/T'

```

Hatta eğer bu çıktı üzerinesplit()metodunu uygularsak, çıktıyı daha
kullanışlı bir hale getirebiliriz:

```python
>>> producer = okunan[producer_index:producer_index+50].split()
>>> producer

[b'/Producer', b'(Acrobat', b'Distiller', b'2.0', b'for', b'Macintosh)', b'/T']

```

Bu şekilde, ihtiyacımız olan bilginin istediğimiz parçasına kolayca
ulaşabiliriz:

```python
>>> producer[0]

b'/Producer'

>>> producer[1]

b'(Acrobat'

>>> producer[1:3]

[b'(Acrobat', b'Distiller']

```

Elbette bu yöntem, birPDFdosyasından gerekli etiketleri almanın en iyi
yöntemi değildir. Ama henüz Python bilgimiz bu kadarını yapmamıza müsaade
ediyor. Ancak yine de, yukarıda örnek, bir ikili dosyadan nasıl veri alınacağı
konusunda size iyi bir fikir verecektir.

#### Resim Dosyalarının Türünü Tespit Etme

Dediğimiz gibi, resim dosyaları, müzik dosyaları, video dosyaları ve benzeri
dosyalar birer ikili dosyadır. Mesela resim dosyalarını ele alalım. Diyelim ki,
resimlerin hangi türde olduğunu tespit eden bir program yazmak istiyorsunuz.
Yani yazdığınız bu programla bir resim dosyasınınPNGmi,JPEGmi,TIFFmi, yoksaBMPmi olduğunu anlamak istiyorsunuz.

Peki bir resim dosyasının hangi türde olduğunu bulmak için uzantısına baksanız
olmaz mı? Asla unutmayın dosya uzantıları ile dosya biçimleri arasında doğrudan
bir bağlantı yoktur. O yüzden dosya uzantıları, dosya biçimini anlamak açısından
güvenilir bir yöntem değildir. Bir resim dosyasının sonuna hangi uzantıyı
getirirseniz getirin, o dosya bir resim dosyasıdır. Yani mesela bir resim
dosyasının uzantısı yanlışlıkla veya bilerek.docolarak değiştirilmişse, o
dosya bir WORD dosyası haline gelmez. İşte yazacağınız program, bir resim
dosyasının uzantısı ne olursa olsun, hatta dosyanın bir uzantısı olmasa bile, o
dosyanın hangi türde olduğunu söyleyebilecek.

Bir resim dosyasının hangi türde olduğunu anlayabilmek için ilgili dosyanın ilk
birkaç baytını okumanız yeterlidir. Bu birkaç bayt içinde o resim dosyasının
türüne dair bilgileri bulabilirsiniz.

Resim dosyalarının türlerini birbirinden ayırt etmenizi sağlayacak verilerin ne
olduğunu, ilgili resim türünün teknik şartnamesine bakarak öğrenebilirsiniz.
Ancak teknik şartnameler genellikle okuması zor metinlerdir. Bu yüzden, doğrudan
şartnameyi okumak yerine, Internet üzerinde kısa bir araştırma yaparak konuyu
daha kolay anlamanızı sağlayacak yardımcı belgelerden de yardım alabilirsiniz.

##### JPEG

JPEGbiçimi ile ilgili bilgilerihttps://jpeg.org/adresinde bulabilirsiniz.JPEGdosya biçimini daha iyi anlamanızı sağlayacak yardımcı kaynak ise
şudur:
1. http://www.faqs.org/faqs/jpeg-faq/part1/section-15.html

http://www.faqs.org/faqs/jpeg-faq/part1/section-15.html

Yukarıda verdiğimiz adreslerdeki bilgilere göre birJPEGdosyasının en başında
şu veriler bulunur:

```python
FF D8 FF E0 ? ? 4A 46 49 46 00

```

Ancak eğer ilgiliJPEGdosyası bir CANON fotograf makinesi ile oluşturulmuşsa
bu veri dizisi şöyle de olabilir:

```python
FF D8 FF E0 ? ? 45 78 69 66 00

```

Burada soru işareti ile gösterdiğimiz kısım, yani dosyanın5.ve6.baytları
farklıJPEGdosyalarında birbirinden farklı olabilir. Dolayısıyla birJPEGdosyasını başka resim dosyalarından ayırabilmek için dosyanın ilk dört baytına
bakmamız, sonraki iki baytı atlamamız ve bunlardan sonra gelen beş baytı kontrol
etmemiz yeterli olacaktır.

Yukarıda gördükleriniz birer on altılı (hex) sayıdır. Bunlar onlu düzende
sırasıyla şu sayılara karşılık gelir:

```python
255 216 255 224 ? ? 74 70 73 70 0
255 216 255 224 ? ? 45 78 69 66 0 #canon

```

Bu diziler içinde özellikle şu dört sayı bizi yakından ilgilendiriyor:

```python
74 70 73 70
45 78 69 66 #canon

```

Bu sayılar sırasıyla ‘J’, ‘F’, ‘I’, ‘F’ ve ‘E’, ‘x’, ‘i’, ‘f’ harflerine
karşılık gelir. Yani birJPEGdosyasını ayırt edebilmek için ilgili dosyanın
7-10 arası baytlarının ne olduğuna bakmamız yeterli olacaktır. Eğer bu aralıkta
‘JFIF’ veya ‘Exif’ ifadeleri varsa, o dosya birJPEGdosyasıdır. Buna göre
şöyle bir kod yazabiliriz:

```python
f = open(dosya_adı, 'rb')
data = f.read(10)
if data[6:11] in [b"JFIF", b"Exif"]:
 print("Bu dosya JPEG!")
else:
 print("Bu dosya JPEG değil!")

```

Burada herhangi bir resim dosyasının ilk on baytını okuduk öncelikle:

```python
data = f.read(10)

```

Çünkü aradığımız bilgiler ilk on bayt içinde yer alıyor.

Daha sonra okuduğumuz kısmın 7 ila 10. baytları arasında kalan verinin ne
olduğuna bakıyoruz:

```python
if data[6:11] in [b"JFIF", b"Exif"]:
 ...

```

Eğer ilgili aralıkta ‘JFIF’ veya ‘Exif’ baytları yer alıyorsa bu dosyanın birJPEGdosyası olduğuna karar veriyoruz.

Yukarıdaki kodları elinizdeki birJPEGdosyasına uygulayarak kendi kendinize
pratik yapabilirsiniz.

Mesela benim elimded1.jpg,d2.jpgved3.jpegadlı üç farklıJPEGdosyası var:

```python
dosyalar = ["d1.jpg", "d2.jpg", "d3.jpeg"]

```

Bu dosyaların ilk onar baytını okuyorum:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 print(okunan)

```

Buradan şu çıktıyı alıyorum:

```python
d1.jpg b'\xff\xd8\xff\xe0\x00\x10JFIF'
d2.jpg b'\xff\xd8\xff\xe1T\xaaExif'
d3.jpeg b'\xff\xd8\xff\xe0\x00\x10JFIF'

```

Gördüğünüz gibi bu çıktılar yukarıdaJPEGdosyalarına ilişkin olarak
verdiğimiz bayt dizilimi ile uyuşuyor. Mesela ilk dosyayı ele alalım:

```python
d1.jpg b'\xff\xd8\xff\xe0\x00\x10JFIF'

```

Burada şu baytlar var:

```python
\xff \xd8 \xff \xe0 \x00 \x10 J F I F

```

Sayıların başındaki\xişaretleri bunların birer on altılı sayı
olduğunu gösteren bir işarettir. Dolayısıyla yukarıdakileri daha net
inceleyebilmek için şöyle de yazabiliriz:

```python
ff d8 ff e0 00 10 J F I F

```

Şimdi de ikinci dosyanın çıktısını ele alalım:

```python
d2.jpg b'\xff\xd8\xff\xe1T\xaaExif'

```

Burada da şu baytlar var:

```python
ff d8 ff e1T aa E x i f

```

İşte dosyaların türünü ayırt etmek için bu çıktılardaki son dört baytı kontrol
etmemiz yeterli olacaktır:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 if okunan[6:11] in [b'JFIF', b'Exif']:
 print("Evet {} adlı dosya bir JPEG!".format(f))
 else:
 print("{} JPEG değil!".format(f))

```

Bu kodları elinizde bulunan farklı türdeki dosyalara uygulayarak, aldığınız
çıktıları inceleyebilirsiniz.

##### PNG

PNGdosya biçiminin teknik şartnamesinehttp://www.libpng.org/pub/png/spec/adresinden ulaşabilirsiniz.

Ayrıca yardımcı kaynak olarak dahttps://www.fileformat.info/format/png/egff.htmadresindeki belgeyi kullanabilirsiniz.

Şartnamade,http://www.libpng.org/pub/png/spec/1.2/PNG-Rationale.html#R.PNG-file-signaturesayfasındaki bilgiye göre birPNGdosyasının ilk8baytı mutlaka aşağıdaki
değerleri içeriyor:
| onlu değer | 137 80 78 71 13 10 26 10 |
| --- | --- |
| on altılı değer | 89 50 4e 47 0d 0a 1a 0a |
| karakter değeri | \211 P N G \r \n \032 \n |

onlu değer

137 80 78 71 13 10 26 10

on altılı değer

89 50 4e 47 0d 0a 1a 0a

karakter değeri

\211 P N G \r \n \032 \n

Şimdi elimize herhangi birPNGdosyası alarak bu durumu teyit edelim:

```python
>>> f = open("falanca.png", "rb")

>>> okunan = f.read(8)

```

Şartnamede de söylendiği gibi, birPNGdosyasını öteki türlerden ayırt
edebilmek için dosyanın ilk8baytına bakmamız yeterli olacaktır. O yüzden biz
de yukarıdaki kodlarda sadece ilk8baytı okumakla yetindik.

Bakalım ilk8baytta neler varmış:

```python
>>> okunan

 b'\x89PNG\r\n\x1a\n'

```

Bu değerin, şartnamedeki karakter değeri ile aynı olup olmadığını sorgulayarak
herhangi bir dosyanınPNGolup olmadığına karar verebilirsiniz:

```python
>>> okunan == b"\211PNG\r\n\032\n"

True

```

Dolayısıyla şuna benzer bir kod yazarak, farklı resim dosyalarının türünü tespit
edebilirsiniz:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 if okunan[6:11] in [b'JFIF', b'Exif']:
 print("{} adlı dosya bir JPEG!".format(f))
 elif okunan[:8] == b"\211PNG\r\n\032\n":
 print("{} adlı dosya bir PNG!".format(f))
 else:
 print("Türü bilinmeyen dosya: {}".format(f))

```

Bu kodlarda bir resim dosyasının ilk10baytını okuduk. 7-11 arası baytların
içinde ‘JFIF’ veya ‘Exif’ baytları varsa o dosyanın birJPEGolduğuna; ilk8baytb”211PNGrn032n”adlı bayt dizisine eşitse de o dosyanın birPNGolduğuna karar veriyoruz.

##### GIF

GIF şartnamesinehttps://www.w3.org/Graphics/GIF/spec-gif89a.txtadresinden
ulaşabilirsiniz.

Bir dosyanınGIFolup olmadığına karar verebilmek için ilk3baytını
okumanız yeterli olacaktır. Standart birGIFdosyasının ilk üç baytı ‘G’, ‘I’
ve ‘F’ karakterlerinden oluşur. Dosyanın sonraki3baytı iseGIF’in sürüm
numarasını verir. 19.08.2024 itibariyleGIFstandardının şu sürümleri
bulunmaktadır:
1. 87a - Mayıs 1987
1. 89a - Temmuz 1989

87a - Mayıs 1987

89a - Temmuz 1989

Dolayısıyla standart birGIFdosyasının ilk6baytı şöyledir:

‘GIF87a’ veya ‘GIF89a’

Eğer bir dosyanınGIFolup olmadığını anlamak isterseniz dosyanın ilk3veya6baytını denetlemeniz yeterli olacaktır:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 if okunan[6:11] in [b'JFIF', b'Exif']:
 print("{} adlı dosya bir JPEG!".format(f))
 elif okunan[:8] == b"\211PNG\r\n\032\n":
 print("{} adlı dosya bir PNG!".format(f))
 elif okunan[:3] == b'GIF':
 print("{} adlı dosya bir GIF!".format(f))
 else:
 print("Türü bilinmeyen dosya: {}".format(f))

```

##### TIFF

TIFFşartnamesinehttps://www.itu.int/itudoc/itu-t/com16/tiff-fx/docs/tiff6.pdfadresinden ulaşabilirsiniz. Bu şartnameye göre birTIFFdosyası şunlardan
herhangi biri ile başlar:
1. ‘II’
1. ‘MM’

‘II’

‘MM’

Dolayısıyla, birTIFFdosyasını tespit edebilmek için dosyanın ilk2baytına
bakmanız yeterli olacaktır:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 if okunan[6:11] in [b'JFIF', b'Exif']:
 print("{} adlı dosya bir JPEG!".format(f))
 elif okunan[:8] == b"\211PNG\r\n\032\n":
 print("{} adlı dosya bir PNG!".format(f))
 elif okunan[:3] == b'GIF':
 print("{} adlı dosya bir GIF!".format(f))
 elif okunan[:2] in [b'II', b'MM']:
 print("{} adlı dosya bir TIFF!".format(f))
 else:
 print("Türü bilinmeyen dosya: {}".format(f))

```

##### BMP

BMPtüründeki resim dosyalarına ilişkin bilgi içinhttps://www.loc.gov/preservation/digital/formats/fdd/fdd000189.shtmladresine
başvurabilirsiniz.

Buna göre,BMPdosyaları ‘BM’ ile başlar. Yani:

```python
for f in dosyalar:
 okunan = open(f, 'rb').read(10)
 if okunan[6:11] in [b'JFIF', b'Exif']:
 print("{} adlı dosya bir JPEG!".format(f))
 elif okunan[:8] == b"\211PNG\r\n\032\n":
 print("{} adlı dosya bir PNG!".format(f))
 elif okunan[:3] == b'GIF':
 print("{} adlı dosya bir GIF!".format(f))
 elif okunan[:2] in [b'II', b'MM']:
 print("{} adlı dosya bir TIFF!".format(f))
 elif okunan[:2] in [b'BM']:
 print("{} adlı dosya bir BMP!".format(f))
 else:
 print("Türü bilinmeyen dosya: {}".format(f))

```

Gördüğünüz gibi ikili dosyalar, baytların özel bir şekilde dizildiği ve özel bir
şekilde yorumlandığı bir dosya türüdür. Dolayısıyla ikili dosyalarla
çalışabilmek için, ikili dosyanın bayt dizilimini yakından tanımak gerekiyor.

## Basit bir İletişim Modeli

Bu bölümde, bilgisayarların çalışma mantığını, verileri nasıl işlediğini,
sayılarla karakter dizilerini nasıl temsil ettiğini daha iyi ve daha net bir
şekilde anlayabilmek için basit bir iletişim modeli kuracağız.

Şimdi şöyle bir durum hayal edin: Diyelim ki, hatlar üzerinden iletilen elektrik
akımı yoluyla bir arkadaşınızla haberleşmenizi sağlayacak bir sistem
tasarlıyorsunuz. Bu sistem, verici tarafında elektrik akımının gönderilmesini
sağlayan bir anahtardan, alıcı tarafında ise, gelen akımın şiddetine göre loş
veya parlak ışık veren bir ampulden oluşuyor. Eğer vericiden gönderilen elektrik
akımı düşükse alıcı loş bir ışık, eğer gelen akım yüksekse alıcı parlak bir ışık
görecek. Elbette eğer isterseniz düşük akım-yüksek akım karşıtlığı yerine akım
varlığı-akım yokluğu karşıtlığını da kullanabilirsiniz. Böylece vericiden akım
gönderildiğinde ampul yanar, gönderilmediğinde ise söner. Bana düşük akım-yüksek
akım karşıtlığı daha kullanışlı geldiği için böyle tercih ettim. Siz tabii ki
öbür türlüsünü de tercih edebilirsiniz.

Yukarıda bahsedildiği gibi sistemimizi kurduk diyelim. Peki ama bu sistem verici
ile alıcı arasında basit de olsa bir iletişim kurmamızı nasıl olacak da
sağlayacak?

Aslında bunun cevabı ve mantığı çok basit. Gördüğünüz gibi, bu sistemde iki
farklı durum söz konusu: Loş ışık ve parlak ışık (veya yanan ampul ve sönmüş
ampul).

Bu ikili yapıyı, tahmin edebileceğiniz gibi, ikili (binary) sayma sistemi
aracılığıyla rahatlıkla temsil edebiliriz. Mesela loş ışık durumuna0, parlak
ışık durumuna ise1diyebiliriz. Dolayısıyla verici, ampulün loş ışık
vermesini sağlayacak düşük bir akım gönderdiğinde bunun değerini0, ampulün
yüksek ışık vermesini sağlayacak yüksek bir akım gönderdiğinde ise bunun
değerini1olarak değerlendirebiliriz.

Burada yaptığımız dönüştürme işlemine teknik olarak ‘kodlama’ (encoding) adı
verilir. Bu kodlama sistemine göre biz, iki farklı elektrik akımı değerini, yani
loş ışık ve parlak ışık değerlerini sırasıyla ikili sistemdeki0ve1sayıları ile eşleştirip, loş ışığa0, parlak ışığa ise1dedik.

Hemen anlayacağınız gibi, bahsettiğimiz bu hayali sistem, telgraf iletişimine
çok benziyor. İşte gerçekte de kullanılan telgraf sistemine çok benzeyen bu
basitleştirilmiş model bizim bilgisayarların çalışma mantığını da daha net bir
şekilde anlamamızı sağlayacak.

### 8 Bitlik bir Sistem

Hatırlarsanız ikili sayma sisteminde0’lar ve1’lerin oluşturduğu her bir
basamağa ‘bit’ adını veriyorduk.

> **Not**
> Bitkelimesi İngilizcede ‘binary’ (ikili) ve ‘digit’ (rakam)
kelimelerinin birleştirilmesi ile üretilmiştir.

Not

Bitkelimesi İngilizcede ‘binary’ (ikili) ve ‘digit’ (rakam)
kelimelerinin birleştirilmesi ile üretilmiştir.

Bu bilgiye göre mesela0sayısı bir bitlik bir sayı iken,1001sayısı dört
bitlik bir sayıdır. İletişimimizi eksiksiz bir biçimde sağlayabilmemiz, yani
gereken bütün karakterleri temsil edebilmemiz için, sistemimizin 8 hanelik bir
sayı kapasitesine sahip olması, yani teknik bir dille ifade etmek gerekirse
sistemimizin 8 bitlik olması herhalde yeterli olacaktır.

8 bitlik bir iletişim sisteminde10’a kadar şu şekilde sayabiliriz:

```python
>>> for i in range(10):
... print(bin(i)[2:].zfill(8))
...
00000000
00000001
00000010
00000011
00000100
00000101
00000110
00000111
00001000
00001001

```

Verici tarafındaki kişi elindeki anahtar yardımıyla farklı kuvvetlere sahip
sinyalleri art arda göndererek yukarıda gösterildiği gibi on farklı sayıyı
alıcıya iletebilir. Sistemimizin 8 bitlik olduğunu düşünürsek karşı tarafa0sayısı ile birlikte toplam 2 ** 8 = 256 farklı sinyal gönderebiliriz:

```python
>>> for i in range(256):
... print(bin(i)[2:].zfill(8))

00000000
00000001
00000010
00000011
00000100
...
...
...
11111001
11111010
11111011
11111100
11111101
11111110
11111111

```

Gördüğünüz gibi, bizim 8 bitlik bu sistemle gönderebileceğimiz son sinyal, yani
sayı255’tir. Bu sistemle bundan büyük bir sayıyı gönderemeyiz. Bu durumu
kendi gözlerinizle görmek için şu kodları çalıştırın:

```python
>>> for i in range(256):
... print(bin(i)[2:], i.bit_length(), sep="\t")

```

Burada ilk sütun256’ya kadar olan sayıların ikili sistemdeki karşılıklarını,
ikinci sütun ise bu sayıların bit uzunluğunu gösteriyor. Bu çıktıyı
incelediğinizde de göreceğiniz gibi, 8 bit uzunluğa sahip son sayı255’tir.256sayısı ise 9 bit uzunluğa sahiptir. Yani256sayısı mecburen bizim
sistemimizin dışındadır:

```python
>>> bin(255)[2:]

'11111111'

>>> (255).bit_length()

8

>>> bin(256)[2:]

'100000000'

>>> (256).bit_length()

9

```

Dediğimiz gibi, bu sistemde elimizde toplam 8 bit var. Yani bu sistemi kullanarak0’dan256’ya kadar sayıp, bu sayıları alıcıya iletebiliriz.

Peki verici ile alıcı arasında birtakım sayıları gönderip alabilmek ne işimize
yarar? Yani bu iş neden bu kadar önemli?

Bu soruların cevabını birazdan vereceğiz, ama ondan önce daha önemli bir konuya
değinelim.

### Hata Kontrolü

Buraya kadar her şey yolunda. Alıcı ve verici arasındaki iletişimi elektrik
akımı vasıtasıyla, 8 bitlik bir sistem üzerinden sağlayabiliyoruz. Ancak
sistemimizin çok önemli bir eksiği var. Biz bu sistemde hiçbir hata kontrolü
yapmıyoruz. Yani vericiden gelen mesajın doğruluğunu test eden hiçbir ölçütümüz
yok. Zira alıcı ile verici arasında gidip gelen veriler pek çok farklı şekilde
ve sebeple bozulmaya uğrayabilir. Örneğin, gönderilen veri alıcı tarafından
doğru anlaşılamayabilir veya elektrik sinyallerini ileten kablolardaki arızalar
sinyallerin doğru iletilmesini engelleyebilir.

İşte bütün bunları hesaba katarak, iletişimin doğru bir şekilde
gerçekleşebilmesini sağlamak amacıyla sistemimiz için basit bir hata kontrol
süreci tasarlayalım.

Dediğimiz gibi, elimizdeki sistem toplam256’ya kadar saymamıza olanak
tanıyor. Çünkü bizim sistemimiz 8 bitlik bir sistem. Bu sisteme bir hata kontrol
mekanizması ekleyebilmek için veri iletimini 8 bitten 7 bite çekeceğiz. Yani
iletişimimizi toplam 2 ** 7 = 127 sayı ile sınırlayacağız. Boşta kalan 8. biti
ise bahsettiğimiz bu hata kontrol mekanizmasına ayıracağız.

Peki hata kontrol mekanizmamız nasıl işleyecek?

Çok basit: Vericiden alıcıya ulaşan verilerin tek mi yoksa çift mi olduğuna
bakacağız.

Buna göre sistemimiz şöyle çalışacak:

Diyelim ki verici alıcıya sinyaller aracılığıyla şu sayıyı göndermek istiyor:

```python
0110111

```

Bu arada, bunun 7 bitlik bir sayı olduğuna dikkat edin. Dediğimiz gibi, biz
kontrol mekanizmamızı kurabilmek için elimizdeki 8 bitlik kapasitenin 7 bitini
kullanacağız. Boşta kalan 8. biti ise kontrol mekanizmasına tahsis edeceğiz.

Ne diyorduk? Evet, biz karşı tarafa 7 bitlik bir sayı olan0110111sayısını
göndermek istiyoruz. Bu sayıyı göndermeden önce, içindeki1’lerin miktarına
bakarak bu sayının tek mi yoksa çift mi olduğuna karar verelim. Burada toplam
beş adet1sayısı var. Yani bu sayı bir tek sayıdır. Eğer göndermek
istediğimiz sayı bir tek sayı ise, karşı tarafa ulaştığında da bir tek sayı
olmalıdır.

Biz bu sistem için şöyle bir protokol tasarlayabiliriz:

Bu sistemde bütün sayılar karşı tarafa bir ‘tek sayı’ olarak iletilmelidir.
Eğer iletilen sayılar arasında bir çift sayı varsa, o sayı hatalı iletilmiş
veya iletim esnasında bozulmuş demektir.

Peki biz iletilen bütün sayıların bir tek sayı olmasını nasıl sağlayacağız? İşte
bu işlemi, boşa ayırdığımız o 8. bit ile gerçekleştireceğiz:

Eğer karşı tarafa iletilen bir sayı zaten tekse, o sayının başına0ekleyeceğiz. Böylece sayının teklik-çiftlik durumu değişmemiş olacak. Ama eğer
iletilecek sayı çiftse, o sayının başına1ekleyeceğiz. Böylece çift sayıyı,
sistemimizin gerektirdiği şekilde, tek sayıya çevirmiş olacağız.

Örnek olarak0110111sayısını verelim. Bu sayıda toplam beş adet1var. Yani
bu sayı bir tek sayı. Dolayısıyla bu sayının başına bir adet0ekliyoruz:

```python
0 0110111

```

Böylece sayımızın teklik-çiftlik durumu değişmemiş oluyor. Karşı taraf bu sayıyı
aldığında1’lerin miktarına bakarak bu verinin doğru iletildiğinden emin
oluyor.

Bir de şu sayıya bakalım:

```python
1111011

```

Bu sayıda toplam altı adet1sayısı var. Yani bu sayı bir çift sayı. Bir
sayının sistemimiz tarafından ‘hatasız’ olarak kabul edilebilmesi için bu
sayının bir tek sayı olması gerekiyor. Bu yüzden biz bu sayıyı tek sayıya
çevirmek için başına bir adet1sayı ekliyoruz:

```python
1 1111011

```

Böylece sayımızın içinde toplam yedi adet1sayısı olmuş ve böylece sayımız
tek sayıya dönüşmüş oluyor.

Teknik olarak ifade etmemiz gerekirse, yukarıda yaptığımız kontrol türüne ‘eşlik
denetimi’ (parity check) adı verilir. Bu işlemi yapmamızı sağlayan bit’e ise
‘eşlik biti’ (parity bit) denir. İki tür eşlik denetimi bulunur:
1. Tek eşlik denetimi (odd parity check)
1. Çift eşlik denetimi (even parity check)

Tek eşlik denetimi (odd parity check)

Çift eşlik denetimi (even parity check)

Biz kendi sistemimizde hata kontrol mekanizmasını bütün verilerin bir ‘tek sayı’
olması gerekliliği üzerine kurduk. Yani burada bir ‘tek eşlik denetimi’
gerçekleştirmiş olduk. Elbette bütün verilerin bir çift sayı olması gerekliliği
üzerine de kurabilirdik bu sistemi. Yani isteseydik ‘çift eşlik denetimi’ de
yapabilirdik. Bu tamamen bir tercih meselesidir. Bu tür sistemlerde yaygın
olarak ‘tek eşlik denetimi’ kullanıldığı için biz de bunu tercih ettik.

Bu örneklerden de gördüğünüz gibi, toplam 8 bitlik kapasitemizin 7 bitini veri
aktarımı için, kalan 1 bitini ise alınıp verilen bu verilerin doğruluğunu
denetlemek için kullanıyoruz. Elbette kullandığımız hata kontrol mekanizması
epey zayıf bir sistemdir. Ama, iletişim sistemleri arasında verilerin hatasız
bir şekilde aktarılıp aktarılamadığını kontrol etmeye yarayan bir sistem olan
eşlik denetiminin, bugün bilgisayarın belleklerinde (RAM) dahi kullanılmaya
devam ettiğini söylemeden geçmeyelim…

### Karakterlerin Temsili

Yukarıda anlattıklarımızdan da gördüğünüz gibi, sistemimizi kullanarak 7 bit
üzerinden toplam 127 sayı gönderebiliyoruz. Tabii ki sistemimiz 8 bit olduğu
için 1 bit de boşta kalıyor. İşte boşta duran bu 1 biti ise eşlik denetimi için
kullanıyoruz. Ama elbette alıcı ile verici arasında sayı alışverişi yapmak pek
de heyecan uyandırıcı bir faaliyet değil. Karşı tarafa sayısal mesajlar yerine
birtakım sözel mesajlar iletebilsek herhalde çok daha keyifli olurdu…

Şunu asla unutmayın. Eğer bir noktadan başka bir noktaya en az iki farklı sinyal
yolu ile birtakım sayısal verileri gönderebiliyorsanız aynı şekilde sözel
verileri de rahatlıkla gönderebilirsiniz. Tıpkı düşük voltaj ve yüksek voltaj
değerlerini sırasıyla0ve1sayıları ile temsil ettiğiniz gibi,
karakterleri de bu iki sayı ile temsil edebilirsiniz. Yapmanız gereken tek şey
hangi sayıların hangi karakterlere karşılık geleceğini belirlemekten ibarettir.
Mesela elimizde sayılarla karakterleri eşleştiren şöyle bir tablo olduğunu
varsayalım:
| sayı | karakter | sayı | karakter | sayı | karakter | sayı | karakter |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | ‘a’ | 1 | ‘b’ | 10 | ‘c’ | 11 | ‘d’ |
| 100 | ‘e’ | 101 | ‘f’ | 110 | ‘g’ | 111 | ‘h’ |
| 1000 | ‘i’ | 1001 | ‘j’ | 1010 | ‘k’ | 1011 | ‘l’ |
| 1100 | ‘m’ | 1101 | ‘n’ | 1110 | ‘o’ | 1111 | ‘p’ |
| 10000 | ‘q’ | 10001 | ‘r’ | 10010 | ‘s’ | 10011 | ‘t’ |
| 10100 | ‘u’ | 10101 | ‘v’ | 10110 | ‘w’ | 10111 | ‘x’ |
| 11000 | ‘y’ | 11001 | ‘z’ | 11010 | ‘A’ | 11011 | ‘B’ |
| 11100 | ‘C’ | 11101 | ‘D’ | 11110 | ‘E’ | 11111 | ‘F’ |
| 100000 | ‘G’ | 100001 | ‘H’ | 100010 | ‘I’ | 100011 | ‘J’ |
| 100100 | ‘K’ | 100101 | ‘L’ | 100110 | ‘M’ | 100111 | ‘N’ |
| 101000 | ‘O’ | 101001 | ‘P’ | 101010 | ‘Q’ | 101011 | ‘R’ |
| 101100 | ‘S’ | 101101 | ‘T’ | 101110 | ‘U’ | 101111 | ‘V’ |
| 110000 | ‘W’ | 110001 | ‘X’ | 110010 | ‘Y’ | 110011 | ‘Z’ |

sayı

karakter

sayı

karakter

sayı

karakter

sayı

karakter

0

‘a’

1

‘b’

10

‘c’

11

‘d’

100

‘e’

101

‘f’

110

‘g’

111

‘h’

1000

‘i’

1001

‘j’

1010

‘k’

1011

‘l’

1100

‘m’

1101

‘n’

1110

‘o’

1111

‘p’

10000

‘q’

10001

‘r’

10010

‘s’

10011

‘t’

10100

‘u’

10101

‘v’

10110

‘w’

10111

‘x’

11000

‘y’

11001

‘z’

11010

‘A’

11011

‘B’

11100

‘C’

11101

‘D’

11110

‘E’

11111

‘F’

100000

‘G’

100001

‘H’

100010

‘I’

100011

‘J’

100100

‘K’

100101

‘L’

100110

‘M’

100111

‘N’

101000

‘O’

101001

‘P’

101010

‘Q’

101011

‘R’

101100

‘S’

101101

‘T’

101110

‘U’

101111

‘V’

110000

‘W’

110001

‘X’

110010

‘Y’

110011

‘Z’

Bu tabloda toplam52karakter ile52sayı birbiriyle eşleştirilmiş durumda.
Mesela vericiden0sinyali geldiğinde bu tabloya göre biz bunu ‘a’ harfi
olarak yorumlayacağız. Örneğin karşı tarafa ‘python’ mesajını iletmek için
sırasıyla şu sinyalleri göndereceğiz:

```python
1111, 11000, 10011, 111, 1110, 1101

```

Gördüğünüz gibi, elimizdeki 127 sayının 52’sini harflere ayırdık ve elimizde 75
tane daha sayı kaldı. Eğer isterseniz geri kalan bu sayıları da birtakım başka
karakterlere veya işaretlere ayırarak, alıcı ve verici arasındaki bütün
iletişimin eksiksiz bir şekilde gerçekleşmesini sağlayabilirsiniz. Örneğin şöyle
bir tablo oluşturabilirsiniz:
| sayı | karakter | sayı | karakter | sayı | karakter | sayı | karakter |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | ‘0’ | 1 | ‘1’ | 10 | ‘2’ | 11 | ‘3’ |
| 100 | ‘4’ | 101 | ‘5’ | 110 | ‘6’ | 111 | ‘7’ |
| 1000 | ‘8’ | 1001 | ‘9’ | 1010 | ‘a’ | 1011 | ‘b’ |
| 1100 | ‘c’ | 1101 | ‘d’ | 1110 | ‘e’ | 1111 | ‘f’ |
| 10000 | ‘g’ | 10001 | ‘h’ | 10010 | ‘i’ | 10011 | ‘j’ |
| 10100 | ‘k’ | 10101 | ‘l’ | 10110 | ‘m’ | 10111 | ‘n’ |
| 11000 | ‘o’ | 11001 | ‘p’ | 11010 | ‘q’ | 11011 | ‘r’ |
| 11100 | ‘s’ | 11101 | ‘t’ | 11110 | ‘u’ | 11111 | ‘v’ |
| 100000 | ‘w’ | 100001 | ‘x’ | 100010 | ‘y’ | 100011 | ‘z’ |
| 100100 | ‘A’ | 100101 | ‘B’ | 100110 | ‘C’ | 100111 | ‘D’ |
| 101000 | ‘E’ | 101001 | ‘F’ | 101010 | ‘G’ | 101011 | ‘H’ |
| 101100 | ‘I’ | 101101 | ‘J’ | 101110 | ‘K’ | 101111 | ‘L’ |
| 110000 | ‘M’ | 110001 | ‘N’ | 110010 | ‘O’ | 110011 | ‘P’ |
| 110100 | ‘Q’ | 110101 | ‘R’ | 110110 | ‘S’ | 110111 | ‘T’ |
| 111000 | ‘U’ | 111001 | ‘V’ | 111010 | ‘W’ | 111011 | ‘X’ |
| 111100 | ‘Y’ | 111101 | ‘Z’ | 111110 | ‘!’ | 111111 | ‘”’ |
| 1000000 | ‘#’ | 1000001 | ‘$’ | 1000010 | ‘%’ | 1000011 | ‘&’ |
| 1000100 | “’”’ | 1000101 | ‘’(’ | 1000110 | ‘)’ | 1000111 | ‘*’ |
| 1001000 | ‘+’ | 1001001 | ‘,’ | 1001010 | ‘-’ | 1001011 | ‘.’ |
| 1001100 | ‘/’ | 1001101 | ‘:’ | 1001110 | ‘;’ | 1001111 | ‘<’ |
| 1010000 | ‘=’ | 1010001 | ‘>’ | 1010010 | ‘?’ | 1010011 | ‘@’ |
| 1010100 | ‘[’ | 1010101 | ‘\’ | 1010110 | ‘]’ | 1010111 | ‘^’ |
| 1011000 | ‘_’ | 1011001 | ‘’ | 1011010 | ‘{’ | 1011011 | ‘’ |
| 1011100 | ‘}’ | 1011101 | ‘~’ | 1011110 | ‘ ‘ | 1011111 | ‘t’ |
| 1100000 | ‘n’ | 1100001 | ‘r’ | 1100010 | ‘x0b’ | 1100011 | ‘x0c’ |

sayı

karakter

sayı

karakter

sayı

karakter

sayı

karakter

0

‘0’

1

‘1’

10

‘2’

11

‘3’

100

‘4’

101

‘5’

110

‘6’

111

‘7’

1000

‘8’

1001

‘9’

1010

‘a’

1011

‘b’

1100

‘c’

1101

‘d’

1110

‘e’

1111

‘f’

10000

‘g’

10001

‘h’

10010

‘i’

10011

‘j’

10100

‘k’

10101

‘l’

10110

‘m’

10111

‘n’

11000

‘o’

11001

‘p’

11010

‘q’

11011

‘r’

11100

‘s’

11101

‘t’

11110

‘u’

11111

‘v’

100000

‘w’

100001

‘x’

100010

‘y’

100011

‘z’

100100

‘A’

100101

‘B’

100110

‘C’

100111

‘D’

101000

‘E’

101001

‘F’

101010

‘G’

101011

‘H’

101100

‘I’

101101

‘J’

101110

‘K’

101111

‘L’

110000

‘M’

110001

‘N’

110010

‘O’

110011

‘P’

110100

‘Q’

110101

‘R’

110110

‘S’

110111

‘T’

111000

‘U’

111001

‘V’

111010

‘W’

111011

‘X’

111100

‘Y’

111101

‘Z’

111110

‘!’

111111

‘”’

1000000

‘#’

1000001

‘$’

1000010

‘%’

1000011

‘&’

1000100

“’”’

1000101

‘’(’

1000110

‘)’

1000111

‘*’

1001000

‘+’

1001001

‘,’

1001010

‘-’

1001011

‘.’

1001100

‘/’

1001101

‘:’

1001110

‘;’

1001111

‘<’

1010000

‘=’

1010001

‘>’

1010010

‘?’

1010011

‘@’

1010100

‘[’

1010101

‘\’

1010110

‘]’

1010111

‘^’

1011000

‘_’

1011001

‘’

1011010

‘{’

1011011

‘’

1011100

‘}’

1011101

‘~’

1011110

‘ ‘

1011111

‘t’

1100000

‘n’

1100001

‘r’

1100010

‘x0b’

1100011

‘x0c’

Aslında yukarıda anlattığımız sayı-karakter eşleştirme işleminin, ta en başta
yaptığımız sinyal-sayı eşleştirme işlemiyle mantık olarak aynı olduğuna
dikkatinizi çekmek isterim.

Sistemimizi tasarlarken, iletilen iki farklı sinyali0ve1sayıları ile
temsil etmiştik. Yani bu sinyalleri0ve1’ler halinde kodlamıştık. Şimdi
ise bu sayıları karakterlere dönüştürüyoruz. Yani yine bir kodlama (encoding)
işlemi gerçekleştiriyoruz.

Baştan beri anlattığımız bu küçük iletişim modeli, sayıların ve karakterlerin
nasıl temsil edilebileceği konusunda bize epey bilgi verdi. Bu arada, yukarıda
anlattığımız sistem her ne kadar hayali de olsa, bu sisteme benzeyen sistemlerin
tarih boyunca kullanıldığını ve hatta bugün kullandığımız bütün iletişim
sistemlerinin de yukarıda anlattığımız temel üzerinde şekillendiğini belirtmeden
geçmeyelim. Örneğin telgraf iletişiminde kullanılan Mors alfabesi yukarıda tarif
ettiğimiz sisteme çok benzer. Mors alfabesi, kısa ve uzun sinyallerle
karakterlerin eşleştirilmesi yoluyla oluşturulmuştur. Mors sisteminde farklı
sinyaller (tıpkı bizim sistemimizde olduğu gibi) farklı harflere karşılık gelir:

Mors alfabesinin bizim oluşturduğumuz sisteme mantık olarak ne kadar benzediğine
dikkat edin. Bu sistemin benzeri biraz sonra göstereceğimiz gibi, modern
bilgisayarlarda da kullanılmaktadır.

## Karakter Kodlama (Character Encoding)

Bu bölüme gelinceye kadar Python programlama dilindeki karakter dizisi, liste ve
dosya adlı veri tiplerine ilişkin epey söz söyledik. Artık bu veri tiplerine
dair hemen hemen bütün ayrıntıları biliyoruz. Ancak henüz öğrenmediğimiz, ama
programcılık maceramız açısından mutlaka öğrenmemiz gereken çok önemli bir konu
daha var. Bu önemli konunun adı, karakter kodlama.

Bu bölümde ‘karakter kodlama’ adlı hayati konuyu işlemenin yanısıra, son birkaç
bölümde üstünkörü bir şekilde üzerinden geçtiğimiz, ama derinlemesine incelemeye
pek fırsat bulamadığımız bütün konuları da ele almaya çalışacağız. Bu konuyu
bitirdikten sonra, önceki konuları çalışırken zihninizde oluşmuş olabilecek
boşlukların pek çoğunun dolduğunu farkedeceksiniz. Sözün özü, bu bölümde hem
yeni şeyler söyleyeceğiz, hem de halihazırda öğrendiğimiz şeylerin bir kez daha
üzerinden geçerek bunların zihnimizde iyiden iyiye pekişmesini sağlayacağız.

Hatırlarsanız önceki derslerimizde karakter dizilerininencode()adlı bir
metodu olduğundan söz etmiştik. Aynı şekilde, dosyaların daencodingadlı bir
parametresi olduğunu söylemiştik. Ayrıca buencodingkonusu, ilk derslerimizde
metin düzenleyici ayarlarını anlatırken de karşımıza çıkmıştı. Orada, yazdığımız
programlarda özellikle Türkçe karakterlerin düzgün görünebilmesi için,
kullandığımız metin düzenleyicinin dil kodlaması (encoding) ayarlarını düzgün
yapmamız gerektiğini üstüne basa basa söylemiştik. Biz şu ana kadar bu konuyu
ayrıntılı olarak ele almamış da olsak, siz şimdiye kadar yazdığınız programlarda
Türkçe karakterleri kullanırken halihazırda pek çok problemle karşılaşmış ve bu
sorunların neden kaynaklandığını anlamakta zorlanmış olabilirsiniz.

İşte bu bölümde, o zaman henüz bilgimiz yetersiz olduğu için ertelediğimiz buencodingkonusunu bütün ayrıntılarıyla ele alacağız ve yazdığımız programlarda
Türkçe karakterleri kullanırken neden sorunlarla karşılaştığımızı, bu sorunun
temelinde neyin yattığını anlamaya çalışacağız.

O halde hiç vakit kaybetmeden bu önemli konuyu incelemeye başlayalım.

### Giriş

Önceki bölümlerde sık sık tekrar ettiğimiz gibi, bilgisayar dediğimiz şey,
üzerinden elektrik geçen devrelerden oluşmuş bir sistemdir. Eğer bir devrede
elektrik yoksa o devrenin değeri0volt iken, o devreden elektrik geçtiğinde
devrenin değeri yaklaşık+5volttur.

Gördüğünüz gibi, ortada iki farklı değer var:0volt ve+5volt. İkili
(binary) sayma sisteminde de iki değer bulunur:0ve1. İşte biz bu0volt’u ikili sistemde0ile,+5volt’u ise1ile temsil ediyoruz. Yani
devreden elektrik geçtiğinde o devrenin değeri1, elektrik geçmediğinde ise0olmuş oluyor. Tabii bilgisayar açısından bakıldığında devrede elektrik
vardır veya yoktur. Biz insanlar bu ikili durumu daha kolay bir şekilde manipüle
edebilmek için farklı voltaj durumlarından her birine sırasıyla0ve1gibi
bir ad veriyoruz. Yani iki farklı voltaj değerini iki farklı sayı halinde
‘kodlamış’ oluyoruz…

Hatırlarsanız bir önceki bölümde tasarladığımız basit iletişim modelinde de
ampulün loş ışık vermesini sağlayan düşük elektrik sinyallerini0ile, parlak
ışık vermesini sağlayan yüksek elektrik sinyallerini ise1ile temsil
etmiştik. Bu temsil işine de teknik olarak ‘kodlama’ (encoding) adı
verildiğini söylemiştik. İşte bilgisayarlar açısından da benzer bir durum söz
konusudur. Bilgisayarlarda da0volt ve+5volt değerleri sırasıyla ikili
sayma sistemindeki0ve1sayıları halinde kodlanabilir.

Sözün özü ilk başta yalnızca iki farklı elektrik sinyali vardır. Elbette bu
elektrik sinyalleri ile doğrudan herhangi bir işlem yapamayız. Mesela elektrik
sinyallerini birbiriyle toplayıp, birbirinden çıkaramayız. Ama bu sinyalleri bir
sayma sistemi ile temsil edersek (yani bu sinyalleri o sayma sisteminde
kodlarsak), bunları kullanarak, örneğin, aritmetik işlemleri rahatlıkla
gerçekleştirebiliriz. Mesela0volt ile+5voltu birbiriyle toplayamayız,
ama0voltu ikili sistemdeki0sayısıyla,+5voltu ise ikili sistemdeki1sayısıyla kodladıktan sonra bu ikili sayılar arasında her türlü aritmetik
işlemi gerçekleştirebiliriz.

Bilgisayarlar yalnızca iki farklı voltaj durumundan anladığı ve bu iki farklı
voltaj durumu da ikili sayma sistemindeki iki farklı sayı ile kolayca temsil
edilebildiği için, ilk bilgisayarlar çoğunlukla sadece hesap işlemlerinde
kullanılıyordu. Karakterlerin/harflerin bilgisayar dünyasındaki işlevi bir hayli
kısıtlıydı. Metin oluşturma işi o zamanlarda daktilo ve benzeri araçların görevi
olarak görülüyordu. Bu durumu, telefon teknolojisi ile kıyaslayabilirsiniz. İlk
telefonlar da yalnızca iki kişi arasındaki sesli iletişimi sağlamak gibi kısıtlı
bir amaca hizmet ediyordu. Bugün ise, geçmişte pek çok farklı cihaza
paylaştırılmış görevleri akıllı telefonlar aracılığıyla tek elden
halledebiliyoruz.

Peki bir bilgisayar yalnızca elektrik sinyallerinden anlıyorsa, biz mesela
bilgisayarları nasıl oluyor da metin girişi için kullanabiliyoruz?

Bu sorunun cevabı aslında çok açık: Birtakım elektrik sinyallerini, birtakım
aritmetik işlemleri gerçekleştirebilmek amacıyla nasıl birtakım sayılar halinde
kodlayabiliyorsak; birtakım sayıları da, birtakım metin işlemlerini
gerçekleştirebilmek amacıyla birtakım karakterler halinde kodlayabiliriz.

Peki ama nasıl?

Bir önceki bölümde bahsettiğimiz basit iletişim modeli aracılığıyla bunun nasıl
yapılacağını anlatmıştık. Tıpkı bizim basit iletişim sistemimizde olduğu gibi,
bilgisayarlar da yalnızca elektrik sinyallerini görür. Tıpkı orada yaptığımız
gibi, bilgisayarlarda da hangi elektrik sinyalinin hangi sayıya; hangi sayının
da hangi karaktere karşılık geleceğini belirleyebiliriz. Daha doğrusu,
bilgisayarların gördüğü bu elektrik sinyallerini sayılara ve karakterlere
dönüştürebiliriz. Dışarıdan girilen karakterleri de, bilgisayarların
anlayabilmesi için tam aksi istikamette sayıya, oradan da elektrik sinyallerine
çevirebiliriz. İşte bu dönüştürme işlemine karakter kodlama (character encoding)
adı verilir.

Bu noktada şöyle bir soru akla geliyor: Tamam, sayıları karakterlere,
karakterleri de sayılara dönüştüreceğiz. Ama peki hangi sayıları hangi
karakterlere, hangi karakterleri de hangi sayılara dönüştüreceğiz? Yani mesela
ikili sistemdeki0sayısı hangi karaktere,1sayısı hangi karaktere,10sayısı hangi karaktere karşılık gelecek?

Siz aslında bu sorunun cevabını da biliyorsunuz. Yine bir önceki bölümde
anlattığımız gibi, hangi sayıların hangi karakterlere karşılık geleceğini,
sayılarla karakterlerin eşleştirildiği birtakım tablolalar yardımıyla rahatlıkla
belirleyebiliriz.

Bu iş ilk başta kulağa çok kolaymış gibi geliyor. Esasında iş kolaydır, ama
şöyle bir problem var: Herkes aynı sayıları aynı karakterlerle eşleştirmiyor
olabilir. Mesela durumu bir önceki bölümde tasarladığımız basit iletişim modeli
üzerinden düşünelim. Diyelim ki, başta yalnızca bir arkadaşınızla ikinizin
arasındaki iletişimi sağlamak için tasarladığınız bu sistem başkalarının da
dikkatini çekmiş olsun… Tıpkı sizin gibi, başkaları da loş ışık-parlak ışık
karşıtlığı üzerinden birbiriyle iletişim kurmaya karar vermiş olsun. Ancak
sistemin temeli herkesçe aynı şekilde kullanılıyor olsa da, karakter eşleştirme
tablolarını herkes aynı şekilde kullanmıyor olabilir. Örneğin başkaları, kendi
ihtiyaçları çerçevesinde, farklı sayıların farklı karakterlerle eşleştirildiği
farklı tablolar tasarlamış olabilir. Bu durumun dezavantajı, farklı sistemlerle
üretilen mesajların, başka sistemlerde aslı gibi görüntülenemeyecek olmasıdır.
Örneğin ‘a’ harfinin1010gibi bir sayıyla temsil edildiği sistemle üretilen
bir mesaj, aynı harfin mesela1101gibi bir sayıyla temsil edildiği sistemde
düzgün görüntülenemeyecektir. İşte aynı şey bilgisayarlar için de geçerlidir.

1960’lı yılların ilk yarısına kadar her bilgisayar üreticisi, sayılarla
karakterlerin eşleştirildiği, birbirinden çok farklı tablolar kullanıyordu. Yani
her bilgisayar üreticisi farklı karakterleri farklı sayılarla eşleştiriyordu.
Örneğin bir bilgisayarda10sayısı ‘a’ harfine karşılık geliyorsa, başka bir
bilgisayarda10sayısı ‘b’ harfine karşılık gelebiliyordu. Bu durumun doğal
sonucu olarak, iki bilgisayar arasında güvenilir bir veri aktarımı
gerçekleştirmek mümkün olmuyordu. Hatta daha da vahimi, aynı firma içinde bile
birden fazla karakter eşleştirme tablosunun kullanıldığı olabiliyordu…

Peki bu sorunun çözümü ne olabilir?

Cevap elbette standartlaşma.

Standartlaşma ilerleme ve uygarlık açısından çok önemli bir kavramdır.
Standartlaşma olmadan ilerleme ve uygarlık düşünülemez. Eğer standartlaşma diye
bir şey olmasaydı, mesela A4 piller boy ve en olarak standart bir ölçüye sahip
olmasaydı, evde kullandığınız küçük aletlerin pili bittiğinde uygun pili satın
almakta büyük zorluk çekerdiniz. Banyo-mutfak musluklarındaki plastik contanın
belli bir standardı olmasaydı, conta eskidiğinde yenisini alabilmek için
eskisinin ölçülerini inceden inceye hesaplayıp bu ölçülere göre yeni bir conta
arayışına çıkmanız gerekirdi. Herhangi bir yerden bulduğunuz contayı herhangi
bir muslukta kullanamazdınız. İşte bu durumun aynısı bilgisayarlar için de
geçerlidir. Eğer bugün karakterlerle sayıları eşleştirme işlemi belli bir
standart üzerinden yürütülüyor olmasaydı, kendi bilgisayarınızda oluşturduğunuz
bir metni başka bir bilgisayarda açtığınızda aynı metni göremezdiniz. İşte
1960’lı yıllara kadar bilgisayar dünyasında da aynen buna benzer bir sorun
vardı. Yani o dönemde, hangi sayıların hangi karakterlerle eşleşeceği konusunda
uzlaşma olmadığı için, farklı bilgisayarlar arasında metin değiş tokuşu pek
mümkün değildi.

1960’lı yılların başında IBM şirketinde çalışan Bob Bemer adlı bir bilim adamı
bu kargaşanın sona ermesi gerektiğine karar verip, herkes tarafından
benimsenecek ortak bir karakter kodlama sistemi üzerinde ilk çalışmaları
başlattı. İşte ASCII (‘aski’ okunur) böylece hayatımıza girmiş oldu.

Peki bu ‘ASCII’ denen şey tam olarak ne anlama geliyor? Gelin bu sorunun
cevabını, en baştan başlayarak ve olabildiğince ayrıntılı bir şekilde vermeye
çalışalım.

### ASCII

Bilgisayarların iki farklı elektrik sinyali ile çalıştığını, bu iki farklı
sinyalin de0ve1sayıları ile temsil edildiğini, bilgisayarla metin
işlemleri yapabilmek için ise bu sayıların belli karakterlerle eşleştirilmesi
gerektiğini söylemiştik.

Yukarıda da bahsettiğimiz gibi, uygarlık ve ilerleme açısından standartlaşma
önemli bir basamaktır. Şöyle düşünün: Biz bilgisayarların çalışma prensibinde
iki farklı elektrik sinyali olduğunu biliyoruz. Biz insanlar olarak, işlerimizi
daha kolay yapabilmek için, bu sinyalleri daha somut birer araç olan0ve1sayılarına atamışız. Eğer devrede elektrik yoksa bu durumu0ile, eğer devrede
elektrik varsa bu durumu1ile temsil ediyoruz. Esasında bu da bir uzlaşma
gerektirir. Devrede elektrik yoksa bu durumu pekala0yerine1ile de temsil
edebilirdik… Eğer elektrik sinyallerinin temsili üzerinde böyle bir
uzlaşmazlık olsaydı, her şeyden önce hangi sinyalin hangi sayıya karşılık
geleceği konusunda da ortak bir karara varmamız gerekirdi.

Elektriğin var olmadığı durumu0yerine1ile temsil etmek akla pek yatkın
olmadığı için uzlaşmada bir problem çıkmıyor. Ama karakterler böyle değildir.
Onlarca (hatta yüzlerce ve binlerce) karakterin sayılarla eşleştirilmesi gereken
bir durumda, ortak bir eşleştirme düzeni üzerinde uzlaşma sağlamak hiç de kolay
bir iş değildir. Zaten 1960’lı yılların başına kadar da böyle bir uzlaşma
sağlanabilmiş değildi. Dediğimiz gibi, her bilgisayar üreticisi sayıları farklı
karakterlerle eşleştiriyor, yani birbirlerinden tamamen farklı karakter kodlama
sistemleri kullanıyordu.

İşte bu kargaşayı ortadan kaldırmak gayesiyle, Bob Bemer ve ekibi hangi
sayıların hangi karakterlere karşılık geleceğini belli bir standarda bağlayan
bir tablo oluşturdu. Bu standarda iseAmerican Standard Code for Information
Interchange, yani ‘Bilgi Alışverişi için Standart Amerikan Kodu’ veya kısaca
‘ASCII’ adı verildi.

#### 7 Bitlik bir Sistem

ASCII adı verilen sistem, birtakım sayıların birtakım karakterlerle
eşleştirildiği basit bir tablodan ibarettir. Bu tabloyuhttps://www.asciitable.com/adresinde görebilirsiniz:

İsterseniz bu tabloyu Python yardımıyla kendiniz de oluşturabilirsiniz:

```python
for i in range(128):
 if i % 4 == 0:
 print("\n")

 print("{:<3}{:>8}\t".format(i, repr(chr(i))), sep="", end="")

```

> **Not**
> Bu kodlardarepr()fonksiyonu dışında bilmediğiniz ve
anlayamayacağınız hiçbir şey yok. Biraz sonrarepr()fonksiyonundan da
bahsedeceğiz. Ama dilerseniz, bu fonksiyonun ne işe yaradığı konusunda en
azından bir fikir sahibi olmak için, yukarıdaki kodları bir derepr()olmadan yazmayı ve aldığınız çıktıyı incelemeyi deneyebilirsiniz.

Not

Bu kodlardarepr()fonksiyonu dışında bilmediğiniz ve
anlayamayacağınız hiçbir şey yok. Biraz sonrarepr()fonksiyonundan da
bahsedeceğiz. Ama dilerseniz, bu fonksiyonun ne işe yaradığı konusunda en
azından bir fikir sahibi olmak için, yukarıdaki kodları bir derepr()olmadan yazmayı ve aldığınız çıktıyı incelemeyi deneyebilirsiniz.

ASCII tablosunda toplam 128 karakterin sayılarla eşleştirilmiş durumda olduğunu
görüyorsunuz. Bir önceki bölümde bahsettiğimiz basit iletişim modelinde
anlattıklarımızdan da aşina olduğunuz gibi, 128 adet sayı 7 bite karşılık gelir
(2**7=128). Yani 7 bit ile gösterilebilecek son sayı127’dir.
Dolayısıyla ASCII 7 bitlik bir sistemdir.

ASCII tablosunu şöyle bir incelediğimizde ilk 32 öğenin göze ilk başta anlamsız
görünen birtakım karakterlerden oluştuğunu görüyoruz:
| sayı | karakter | sayı | karakter | sayı | karakter | sayı | karakter |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | ‘\x00’ | 1 | ‘\x01’ | 2 | ‘\x02’ | 3 | ‘\x03’ |
| 4 | ‘\x04’ | 5 | ‘\x05’ | 6 | ‘\x06’ | 7 | ‘\x07’ |
| 8 | ‘\x08’ | 9 | ‘\t’ | 10 | ‘\n’ | 11 | ‘\x0b’ |
| 12 | ‘\x0c’ | 13 | ‘\r’ | 14 | ‘\x0e’ | 15 | ‘\x0f’ |
| 16 | ‘\x10’ | 17 | ‘\x11’ | 18 | ‘\x12’ | 19 | ‘\x13’ |
| 20 | ‘\x14’ | 21 | ‘\x15’ | 22 | ‘\x16’ | 23 | ‘\x17’ |
| 24 | ‘\x18’ | 25 | ‘\x19’ | 26 | ‘\x1a’ | 27 | ‘\x1b’ |
| 28 | ‘\x1c’ | 29 | ‘\x1d’ | 30 | ‘\x1e’ | 31 | ‘\x1f’ |

sayı

karakter

sayı

karakter

sayı

karakter

sayı

karakter

0

‘\x00’

1

‘\x01’

2

‘\x02’

3

‘\x03’

4

‘\x04’

5

‘\x05’

6

‘\x06’

7

‘\x07’

8

‘\x08’

9

‘\t’

10

‘\n’

11

‘\x0b’

12

‘\x0c’

13

‘\r’

14

‘\x0e’

15

‘\x0f’

16

‘\x10’

17

‘\x11’

18

‘\x12’

19

‘\x13’

20

‘\x14’

21

‘\x15’

22

‘\x16’

23

‘\x17’

24

‘\x18’

25

‘\x19’

26

‘\x1a’

27

‘\x1b’

28

‘\x1c’

29

‘\x1d’

30

‘\x1e’

31

‘\x1f’

> **Not**
> Bu arada, asciitable.com adresinden baktığınız tablo ile yukarıdaki
tablonun birbirinden farklı olduğunu zannedebilirsiniz ilk bakışta. Ama aslında
arada herhangi bir fark yok. Yalnızca iki tablonun karakterleri gösterim şekli
birbirinden farklı. Örneğin asciitable.com’daki tabloda 9 sayısının ‘TAB
(horizontal tab)’ adlı bir karaktere atandığını görüyoruz. Yukarıdaki tabloda
ise 9 sayısının yanında\tadlı kaçış dizisi var. Gördüğünüz gibi, ‘TAB
(horizontal tab)’ ifadesi ile\tifadesi aynı karaktere atıfta bulunuyor.
Yalnızca bunların gösterimleri birbirinden farklı, o kadar.

Not

Bu arada, asciitable.com adresinden baktığınız tablo ile yukarıdaki
tablonun birbirinden farklı olduğunu zannedebilirsiniz ilk bakışta. Ama aslında
arada herhangi bir fark yok. Yalnızca iki tablonun karakterleri gösterim şekli
birbirinden farklı. Örneğin asciitable.com’daki tabloda 9 sayısının ‘TAB
(horizontal tab)’ adlı bir karaktere atandığını görüyoruz. Yukarıdaki tabloda
ise 9 sayısının yanında\tadlı kaçış dizisi var. Gördüğünüz gibi, ‘TAB
(horizontal tab)’ ifadesi ile\tifadesi aynı karaktere atıfta bulunuyor.
Yalnızca bunların gösterimleri birbirinden farklı, o kadar.

Aslında bu karakter salatası arasında bizim tanıdığımız birkaç karakter de yok
değil. Mesela 9. sıradaki\töğesinin sekme oluşturan kaçış dizisi olduğunu
söyledik. Aynı şekilde, 10. sıradaki\nöğesinin satır başına geçiren kaçış
dizisi olduğunu, 13. sıradaki\röğesinin ise satırı başa alan kaçış dizisi
olduğunu da biliyoruz. Bu tür karakterler ‘basılamayan’ (non-printing)
karakterlerdir. Yani mesela ekranda görüntülenebilen ‘a’, ‘b’, ‘c’, ‘!’, ‘?’,
‘=’ gibi karakterlerden farklı olarak bu ilk 32 karakter ekranda görünmez.
Bunlara aynı zamanda ‘kontrol karakterleri’ (control characters) adı da
verilir. Çünkü bu karakterler ekranda görüntülenmek yerine, metnin akışını
kontrol eder. Bu karakterlerin ne işe yaradığını şu tabloyla tek tek
gösterebiliriz (tablohttps://tr.wikipedia.org/wiki/ASCIIadresinden alıntıdır):
| Sayı | Karakter | Sayı | Karakter |
| --- | --- | --- | --- |
| 0 | boş | 16 | veri bağlantısından çık |
| 1 | başlık başlangıcı | 17 | aygıt denetimi 1 |
| 2 | metin başlangıcı | 18 | aygıt denetimi 2 |
| 3 | metin sonu | 19 | aygıt denetimi 3 |
| 4 | aktarım sonu | 20 | aygıt denetimi 4 |
| 5 | sorgu | 21 | olumsuz bildirim |
| 6 | bildirim | 22 | zaman uyumlu boşta kalma |
| 7 | zil | 23 | aktarım bloğu sonu |
| 8 | geri al | 24 | iptal |
| 9 | yatay sekme | 25 | ortam sonu |
| 10 | satır besleme/yeni satır | 26 | değiştir |
| 11 | dikey sekme | 27 | çık |
| 12 | form besleme/yeni sayfa | 28 | dosya ayırıcısı |
| 13 | satır başı | 29 | grup ayırıcısı |
| 14 | dışarı kaydır | 30 | kayıt ayırıcısı |
| 15 | içeri kaydır | 31 | birim ayırıcısı |

Sayı

Karakter

Sayı

Karakter

0

boş

16

veri bağlantısından çık

1

başlık başlangıcı

17

aygıt denetimi 1

2

metin başlangıcı

18

aygıt denetimi 2

3

metin sonu

19

aygıt denetimi 3

4

aktarım sonu

20

aygıt denetimi 4

5

sorgu

21

olumsuz bildirim

6

bildirim

22

zaman uyumlu boşta kalma

7

zil

23

aktarım bloğu sonu

8

geri al

24

iptal

9

yatay sekme

25

ortam sonu

10

satır besleme/yeni satır

26

değiştir

11

dikey sekme

27

çık

12

form besleme/yeni sayfa

28

dosya ayırıcısı

13

satır başı

29

grup ayırıcısı

14

dışarı kaydır

30

kayıt ayırıcısı

15

içeri kaydır

31

birim ayırıcısı

Gördüğünüz gibi, bunlar birer harf, sayı veya noktalama işareti değil. O yüzden
bu karakterler ekranda görünmez. Ama bir metindeki veri, satır ve paragraf
düzeninin nasıl olacağını, metnin nerede başlayıp nerede biteceğini ve nasıl
görüneceğini kontrol ettikleri için önemlidirler.

Geri kalan sayılar ise doğrudan karakterlere, sayılara ve noktalama işaretlerine
tahsis edilmiştir:
| sayı | karakter | sayı | karakter | sayı | karakter | sayı | karakter |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 32 | ‘ ‘ | 33 | ‘!’ | 34 | ‘”’ | 35 | ‘#’ |
| 36 | ‘$’ | 37 | ‘%’ | 38 | ‘&’ | 39 | “’” |
| 40 | ‘(’ | 41 | ‘)’ | 42 | ‘*’ | 43 | ‘+’ |
| 44 | ‘,’ | 45 | ‘-’ | 46 | ‘.’ | 47 | ‘/’ |
| 48 | ‘0’ | 49 | ‘1’ | 50 | ‘2’ | 51 | ‘3’ |
| 52 | ‘4’ | 53 | ‘5’ | 54 | ‘6’ | 55 | ‘7’ |
| 56 | ‘8’ | 57 | ‘9’ | 58 | ‘:’ | 59 | ‘;’ |
| 60 | ‘<’ | 61 | ‘=’ | 62 | ‘>’ | 63 | ‘?’ |
| 64 | ‘@’ | 65 | ‘A’ | 66 | ‘B’ | 67 | ‘C’ |
| 68 | ‘D’ | 69 | ‘E’ | 70 | ‘F’ | 71 | ‘G’ |
| 72 | ‘H’ | 73 | ‘I’ | 74 | ‘J’ | 75 | ‘K’ |
| 76 | ‘L’ | 77 | ‘M’ | 78 | ‘N’ | 79 | ‘O’ |
| 80 | ‘P’ | 81 | ‘Q’ | 82 | ‘R’ | 83 | ‘S’ |
| 84 | ‘T’ | 85 | ‘U’ | 86 | ‘V’ | 87 | ‘W’ |
| 88 | ‘X’ | 89 | ‘Y’ | 90 | ‘Z’ | 91 | ‘[’ |
| 92 | ‘\’ | 93 | ‘]’ | 94 | ‘^’ | 95 | ‘_’ |
| 96 | ‘’’ | 97 | ‘a’ | 98 | ‘b’ | 99 | ‘c’ |
| 100 | ‘d’ | 101 | ‘e’ | 102 | ‘f’ | 103 | ‘g’ |
| 104 | ‘h’ | 105 | ‘i’ | 106 | ‘j’ | 107 | ‘k’ |
| 108 | ‘l’ | 109 | ‘m’ | 110 | ‘n’ | 111 | ‘o’ |
| 112 | ‘p’ | 113 | ‘q’ | 114 | ‘r’ | 115 | ‘s’ |
| 116 | ‘t’ | 117 | ‘u’ | 118 | ‘v’ | 119 | ‘w’ |
| 120 | ‘x’ | 121 | ‘y’ | 122 | ‘z’ | 123 | ‘{’ |
| 124 | ‘|’ | 125 | ‘}’ | 126 | ‘~’ | 127 | ‘x7f’ |

sayı

karakter

sayı

karakter

sayı

karakter

sayı

karakter

32

‘ ‘

33

‘!’

34

‘”’

35

‘#’

36

‘$’

37

‘%’

38

‘&’

39

“’”

40

‘(’

41

‘)’

42

‘*’

43

‘+’

44

‘,’

45

‘-’

46

‘.’

47

‘/’

48

‘0’

49

‘1’

50

‘2’

51

‘3’

52

‘4’

53

‘5’

54

‘6’

55

‘7’

56

‘8’

57

‘9’

58

‘:’

59

‘;’

60

‘<’

61

‘=’

62

‘>’

63

‘?’

64

‘@’

65

‘A’

66

‘B’

67

‘C’

68

‘D’

69

‘E’

70

‘F’

71

‘G’

72

‘H’

73

‘I’

74

‘J’

75

‘K’

76

‘L’

77

‘M’

78

‘N’

79

‘O’

80

‘P’

81

‘Q’

82

‘R’

83

‘S’

84

‘T’

85

‘U’

86

‘V’

87

‘W’

88

‘X’

89

‘Y’

90

‘Z’

91

‘[’

92

‘\’

93

‘]’

94

‘^’

95

‘_’

96

‘’’

97

‘a’

98

‘b’

99

‘c’

100

‘d’

101

‘e’

102

‘f’

103

‘g’

104

‘h’

105

‘i’

106

‘j’

107

‘k’

108

‘l’

109

‘m’

110

‘n’

111

‘o’

112

‘p’

113

‘q’

114

‘r’

115

‘s’

116

‘t’

117

‘u’

118

‘v’

119

‘w’

120

‘x’

121

‘y’

122

‘z’

123

‘{’

124

‘|’

125

‘}’

126

‘~’

127

‘x7f’

İşte 32 ile 127 arası sayılarla eşleştirilen yukarıdaki karakterler yardımıyla
metin ihtiyaçlarımızın büyük bölümünü karşılayabiliriz. Yani ASCII adı verilen
bu eşleştirme tablosu sayesinde bilgisayarların sayılarla birlikte karakterleri
de işleyebilmesini sağlayabiliriz.

1960’lı yıllara gelindiğinde, bilgisayarlar 8 bit uzunluğundaki verileri
işleyebiliyordu. Yani, ASCII sisteminin gerçeklendiği (yani hayata geçirildiği)
bilgisayarlar 8 bitlik bir kapasiteye sahipti. Bu 8 bitin 7 biti karakterle
ayrılmıştı. Dolayısıyla mevcut bütün karakterler 7 bitlik bir alana
sığdırılmıştı. Boşta kalan8.bit ise, veri aktarımının düzgün
gerçekleştirilip gerçekleştirilmediğini denetlemek amacıyla ‘doğruluk kontrolü’
için kullanılıyordu. Bu kontrole teknik olarak ‘eşlik denetimi’ (parity
check), bu eşlik denetimini yapmamızı sağlayan bit’e ise ‘eşlik biti’ (parity
bit) adı verildiğini biliyorsunuz. Geçen bölümde bu teknik terimlerin ne anlama
geldiğini açıklamış, hatta bunlarla ilgili basit bir örnek de vermiştik.

Adından da anlaşılacağı gibi, ASCII bir Amerikan standardıdır. Dolayısıyla
hazırlanışında İngilizce temel alınmıştır. Zaten ASCII tablosunu
incelediğinizde, bu tabloda Türkçeye özgü harflerin bulunmadığını göreceksiniz.
Bu sebepten, bu standart ile mesela Türkçeye özgü karakterleri gösteremeyiz.
Çünkü ASCII standardında ‘ş’, ‘ç’, ‘ğ’ gibi harfler kodlanmamıştır. Özellikle
Python’ın 2.x serisini kullanmış olanlar, ASCII’nin bu yetersizliğinin nelere
sebep olduğunu gayet iyi bilir. Python’ın 2.x serisinde mesela doğrudan şöyle
bir kod yazamayız:

```python
print("Merhaba Şirin Baba!")

```

“Merhaba Şirin Baba!adlı karakter dizisinde geçen ‘Ş’ harfi ASCII dışı bir
karakterdir. Yani bu harf ASCII ile temsil edilemez. O yüzden böyle bir kod
yazıp bu kodu çalıştırdığımızda Python bize şöyle bir hata mesajı
gösterecektir:

```python
 File "deneme.py", line 1
SyntaxError: Non-ASCII character '\xde' in file deneme.py on line 1, but no
encoding declared; see http://www.python.org/peps/pep-0263.html for details

```

Aynen anlattığımız gibi, yukarıdaki hata mesajı da kodlar arasında ASCII olmayan
bir karakter yer aldığından yakınıyor…

ASCII’nin her ne kadar yukarıda bahsettiğimiz eksiklikleri olsa da bu standart
son derece yaygındır ve piyasada bulunan pek çok sistemde kullanılmaya devam
etmektedir. Örneğin size kullanıcı adı ve parola soran hemen hemen bütün
sistemler bu ASCII tablosunu temel alır veya bu tablodan etkilenmiştir. O yüzden
çoğu yerde kullanıcı adı ve/veya parola belirlerken Türkçe karakterleri
kullanamazsınız. Hatta pek çok yazı tipinde yalnızca ASCII tablosunda yer alan
karakterlerin karşılığı bulunur. Bu yüzden, mesela blogunuzda kullanmak üzere
seçip beğendiğiniz çoğu yazı tipi ‘ş’, ‘ç’, ‘ğ’, ‘ö’ gibi harfleri
göstermeyebilir. Yukarıda ‘Merhaba Şirin Baba!’ örneğinde de gösterdiğimiz gibi,
Python’ın 2.x serisinde de öntanımlı olarak ASCII kodlama biçimi kullanılıyordu.
O yüzden Python’ın 2.x sürümlerinde Türkçe karakterleri gösterebilmek için daha
fazla ilave işlem yapmak zorunda kalıyorduk.

Sözün özü, eğer yazdığınız veya kendiniz yazmamış da olsanız herhangi bir
sebeple kullanmakta olduğunuz bir programda Türkçe karakterlere ilişkin bir hata
alıyorsanız, bu durumun en muhtemel sebebi, kullandığınız programın veya
sistemin, doğrudan ASCII’yi veya ASCII’ye benzer başka bir sistemi temel alarak
çalışıyor olmasıdır. ASCII tablosunda görünen 128 karakter dışında kalan hiçbir
karakter ASCII ile kodlanamayacağı için, özellikle farklı dillerin kullanıldığı
bilgisayarlarda çalışan programlar kaçınılmaz olarak karakterlere ilişkin pek
çok hata verecektir. Örneğin, karakter kodlamalarına ilişkin olarak yukarıda
bahsettiğimiz ayrıntılardan habersiz bir Amerikalı programcının yazdığı bir
programa Türkçe veri girdiğinizde bu program bir anda tuhaf görünen hatalar
verip çökecektir…

#### Genişletilmiş ASCII

Dediğimiz gibi, ASCII 7 bitlik bir karakter kümesidir. Bu standardın ilk çıktığı
dönemde 8. bitin hata kontrolü için kullanıldığını söylemiştik. Sonraki yıllarda
8. bitin hata kontrolü için kullanılmasından vazgeçildi. Böylece 8. bit yine
boşa düşmüş oldu. Bu bitin boşa düşmesi ile elimizde yine toplam128karakterlik bir boşluk olmuş oldu. Dediğimiz gibi 7 bit ile toplam128sayı-karakter eşleştirilebilirken, 8 bit ile toplam256sayı-karakter
eşleştirilebilir. Ne de olsa:

```python
>>> 2**7

128

>>> 2**8

256

```

İşte bu fazla bit, farklı kişi, kurum ve organizasyonlar tarafından, İngilizcede
bulunmayan ama başka dillerde bulunan karakterleri temsil etmek için kullanıldı.
Ancak elbette bu fazladan bitin sağladığı128karakter de dünyadaki bütün
karakterlerin temsil edilmesine yetmez. Bu yüzden 8. bitin sunduğu boşluk,
birbirinden farklı karakterleri gösteren çeşitli tabloların ortaya çıkmasına
sebep oldu. Bu birbirinden farklı tablolara genel olarak ‘kod sayfası’ adı
verilir. Örneğin Microsoft şirketinin Türkiye’ye gönderdiği bilgisayarlarda
tanımlı ‘cp857’ adlı kod sayfasında 128 ile 256 aralığında Türkçe karakterlere
de yer verilmişti (bkz).

Bu tabloya baktığınızda baştan 128’e kadar olan karakterlerin standart ASCII
tablosu ile aynı olduğunu göreceksiniz. 128. karakterden itibaren ise Türkçeye
özgü harfler tanımlanır. Mesela bu tabloda 128. karakter Türkçedeki büyük ‘ç’
harfi iken, 159. karakter küçük ‘ş’ harfidir. Bu durumu şu Python kodları ile de
teyit edebilirsiniz:

```python
>>> "Ç".encode("cp857")

b'\x80'

>>> "ş".encode("cp857")

b'\x9f'

```

Bu arada bu sayıların onaltılı sayma düzenine göre olduğunu biliyorsunuz. Onlu
düzende bunların karşılığı sırasıyla şudur:

```python
>>> int("80", 16)

128

>>> int("9f", 16)

159

```

Burada karakter dizilerininencode()adlı metodunu kullandığımıza dikkat
edin. Bu metot yardımıyla herhangi bir karakteri herhangi bir karakter kodlama
sistemine göre kodlayabiliriz. Mesela yukarıdaki iki örnekte ‘Ç’ ve ‘ş’
harflerini ‘cp857’ adlı kod sayfasına göre kodladık ve bunların bu kod
sayfasında hangi sayılara karşılık geldiğini bulduk.

cp857 numaralı kod sayfasında ‘Ç’ ve ‘ş’ harfleri yer aldığı için, biz bu
harfleri o kod sayfasına göre kodlayabiliyoruz. Ama mesela ASCII kodlama
sisteminde bu harfler bulunmaz. O yüzden bu harfleri ASCII sistemine göre
kodlayamayız:

```python
>>> "Ç".encode("ascii")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xc7' in position
0: ordinal not in range(128)

```

Tıpkı hata mesajında da söylendiği gibi:

```python
Unicode Kodlama Hatası: 'ascii' kod çözücüsü, 0 konumundaki '\xc7' adlı
karakteri kodlayamıyor. Sayı 0-128 aralığında değil.

```

Gerçekten de onlu sistemde199sayısına karşılık gelen bu onaltılı ‘\xc7’
sayısı ASCII’nin kapsadığı sayı aralığının dışında kalmakta, bu yüzden de ASCII
kod çözücüsü ile kodlanamamaktadır.

Dediğimiz gibi, Microsoft Türkiye’ye gönderdiği bilgisayarlarda 857 numaralı kod
sayfasını tanımlıyordu. Ama mesela Arapça konuşulan ülkelere gönderdiği
bilgisayarlarda ise,buadresten görebileceğiniz 708 numaralı kod sayfasını tanımlıyordu. Bu kod
sayfasını incelediğinizde, 128 altı karakterlerin standart ASCII ile aynı
olduğunu ancak 128 üstü karakterlerin Türkçe kod sayfasındaki karakterlerden
farklı olduğunu göreceksiniz. İşte 128 üstü karakterler bütün dillerde
birbirinden farklıdır. Bu farklılığın ne sonuç doğurabileceğini tahmin
edebildiğinizi zannediyorum. Elbette, mesela kendi bilgisayarınızda yazdığınız
bir metni Arapça konuşulan bir ülkedeki bilgisayara gönderdiğinizde, doğal
olarak metin içindeki Türkçeye özgü karakterlerin yerinde başka karakterler
belirecektir.

Bu bölümün başında da söylediğimiz gibi, Genişletilmiş ASCII sisteminde 128 ile
256 aralığı için pek çok farklı karakter eşleştirme tabloları kullanılıyordu.
Mesela Microsoft şirketi bu aralık için kendine özgü birtakım kod sayfaları
tasarlamıştı. Bu kod sayfalarına örnek olarak yukarıda cp857 ve cp708 numaralı
kod sayfalarını örnek vermiştik.

Elbette 128 ile 256 aralığını dolduran, yalnızca Microsoft’a ait kod sayfaları
yoktu piyasada. Aynı aralığı farklı karakterlerle dolduran pek çok başka
eşleştirme tablosu da dolaşıyordu etrafta. Örneğin özellikle Batı Avrupa
dillerindeki karakterleri temsil edebilmek için oluşturulmuş ‘latin1’ (öbür
adıyla ISO-8859-1) adlı karakter kümesi bugün de yaygın olarak kullanılan
sistemlerinden biridir. Almancada olup da ASCII sistemi ile temsil edilemeyen
‘ö’, ‘ß’, ‘ü’ gibi harfler ve Fransızcada olup da yine ASCII sistemi ile temsil
edilemeyen ‘ç’ ve ‘é’ gibi harfler bu karakter kümesinde temsil edilebiliyordu.
Eğer dilerseniz bu karakter kümesini dehttps://www.fileformat.info/info/charset/ISO-8859-1/list.htmadresinden
inceleyebilirsiniz.

Yalnız burada önemli bir ayrıntıyı not düşelim. ‘Genişletilmiş ASCII’, standart
ASCII gibi genel kabul görmüş tek bir sistem değildir.Genişletilmiş ASCII
dediğimizde zaten tek bir karakter kümesi akla gelmiyor. Dolayısıyla ASCII
dendiğinde anlamamız gereken şey 128 karakterlik bir sayı-karakter eşleştirme
tablosudur. ASCII hiçbir zaman bu 128 karakterin ötesine geçip de 256
karakterlik bir aralığı temsil etmiş değildir. Dolayısıyla 127. sayının
ötesindeki karakterleri kapsayan sistem ASCII değildir. ‘Genişletilmiş ASCII’
kavramı, temel ASCII sisteminde temsil edilen sayı-karakter çiftlerinin pek çok
farklı kurum ve kuruluş tarafından birbirinden farklı biçimlerde
‘genişletilmesiyle’ oluşturulmuş, ancak ASCII’nin kendisi kadar
standartlaşamamış bir sistemler bütünüdür. Bu sistem içinde pek çok farklı kod
sayfası (veya karakter kümesi) yer alır. Tek başına ‘Genişletilmiş ASCII’
ifadesi açıklayıcı olmayıp; ASCII’nin hangi karakter kümesine göre
genişletildiğinin de belirtilmesi gerekir.

Bütün bu anlattıklarımızdan şu sonucu çıkarıyoruz: ASCII bilgisayarlar arasında
güvenli bir şekilde veri aktarımını sağlamak için atılmış en önemli ve en
başarılı adımlardan bir tanesidir. Bu güçlü standart sayesinde uzun yıllar
bilgisayarlar arası temel iletişim başarıyla sağlandı. Ancak bu standardın zayıf
kaldığı nokta 7 bitlik olması ve boşta kalan 8. bitin tek başına dünyadaki bütün
dilleri temsil etmeye yeterli olmamasıdır.

#### 1 Karakter == 1 Bayt

ASCII standardı, her karakterin 1 bayt ile temsil edilebileceği varsayımı
üzerine kurulmuştur. Bildiğiniz gibi, 1 bayt (geleneksel olarak) 8 bit’e
karşılık gelir. Peki 1 bayt’ın 8 bit’e karşılık gelmesinin nedeni nedir? Aslında
bunun özel bir nedeni yok. 1 destede neden 10 öğe, 1 düzinede de 12 öğe varsa, 1
bayt’ta da 8 bit vardır… Yani biz insanlar öyle olmasına karar verdiğimiz için
1 destede 10 öğe, 1 düzinede 12 öğe, 1 bayt’ta ise 8 bit vardır.

Dediğimiz gibi ASCII standardı 7 bitlik bir sistemdir. Yani bu standartta en
büyük sayı olan 127 yalnızca 7 bit ile gösterilebilir:

```python
>>> bin(127)[2:]

'1111111'

```

127 sayısı 7 bit ile gösterilebilecek son sayıdır:

```python
>>> (127).bit_length()

7

>>> (128).bit_length()

8

```

8 bitlik bir sistem olan Genişletilmiş ASCII ise 0 ile 255 arası sayıları temsil
edebilir:

```python
>>> bin(255)[2:]

'11111111'

```

255 sayısı 8 bit ile gösterilebilecek son sayıdır:

```python
>>> (255).bit_length()

8

>>> (256).bit_length()

9

```

Dolayısıyla ASCII’de ve Genişletilmiş ASCII’de 1 baytlık alana toplam 256
karakter sığdırılabilir. Eğer daha fazla karakteri temsil etmek isterseniz 1
bayttan fazla bir alana ihtiyaç duyarsınız.

Bu arada, olası bir yanlış anlamayı önleyelim:

1 bayt olma durumu mesela doğrudan ‘a’ harfinin kendisi ile ilgili bir şey
değildir. Yani ‘a’ harfi 1 bayt ile gösterilebiliyorken, mesela ‘ş’ harfi 1 bayt
ile gösterilemiyorsa, bunun nedeni ‘ş’ harfininin ‘tuhaf bir harf’ olması
değildir! Eğer ASCII gibi bir sistem Türkiye’de tasarlanmış olsaydı, herhalde
‘ş’ harfi ilk 128 sayı arasında kendine bir yer bulurdu. Mesela böyle bir
sistemde muhtemelen ‘x’, ‘w’ ve ‘q’ harfleri, Türk alfabesinde yer almadıkları
için, dışarıda kalırdı. O zaman da ‘ş’, ‘ç’, ‘ğ’ gibi harflerin 1 bayt olduğunu,
‘x’, ‘w’ ve ‘q’ gibi harflerin ise 1 bayt olmadığını söylerdik.

### UNICODE

İlk bilgisayarların ABD çıkışlı olması nedeniyle, bilgisayarlar çoğunlukla
ABD’de üretilip ABD pazarına satılıyordu. Bu nedenle İngilizce alfabeyi temel
alan ASCII gibi bir sistem bu pazarın karakter temsil ihtiyaçlarını %99 oranında
karşılıyordu. Ancak bilgisayarların ABD dışına çıkması ve ABD dışında da da
yayılmaya başlamasının ardından, ASCII’nin yetersizlikleri de iyice görünür
olmaya başladı. Çünkü ASCII tablosunda, İngilizce dışındaki dillerde bulunan
aksanlı ve noktalı harflerin (é, ä, ö, ç gibi) hiçbiri bulunmuyordu.

İlk zamanlarda insanlar aksanlı ve noktalı harfleri ASCII tablosundaki
benzerleriyle değiştirerek kullanmaya razı olmuşlardı (é yerine e; ä yerine a; ö
yerine o; ç yerine c gibi). Ancak bu çözüm Avrupa dillerini kullananların
sorununu kısmen çözüyor da olsa, Asya dillerindeki problemi çözemez. Çünkü ASCII
tablosunu kullanarak Çince ve Japonca gibi dillerdeki karakterleri herhangi bir
şekilde temsil etmeniz mümkün değildir.

Bu sıkıntıyı kısmen de olsa giderebilmek için, yukarıda da bahsetmiş olduğumuz,
128-256 arasındaki boşluktan yararlanılmaya başlandı. Dediğimiz gibi, ASCII 7
bitlik bir sistem olduğu için, 8 bitlik bilgisayarlarda fazladan 1 bitin boşta
kalmasına izin verir. İşte bu 1 bitlik boşluk dünyanın çeşitli ülkeleri
tarafından kendi karakter ihtiyaçlarını karşılamak için kullanıldı. Dolayısıyla
Almanlar 128-256 arasını farklı karakterlerle, Fransızlar başka karakterlerle,
Yunanlar ise bambaşka karakterlerle doldurdular.

Hatırlarsanız ASCII’nin ortaya çıkış sebebi bilgisayarlar arasında veri
alışverişini mümkün kılmaktı. ASCII Amerika’daki bilgisayarlar arasında sağlıklı
bir veri alışverişi gerçekleştirilmesini rahatlıkla mümkün kılıyordu. Ama
bilgisayarların dünyaya yayılması ile birlikte ilk baştaki veri aktarımı
problemi tekrar ortaya çıktı. Bu defa da, mesela Türkiye’den gönderilen bir
metin (örneğin bir e.posta) Almanya’daki bilgisayarlarda düzgün
görüntülenemeyebiliyordu. Örneğin Windows-1254 (cp1254) numaralı kod sayfası ile
kodlanmış Türkçe bir metin, Almanya’da Windows-1250 numaralı kod sayfasının
tanımlı olduğu bir bilgisayarda, aynı sayıların her iki kod sayfasında farklı
karakterlere karşılık gelmesi nedeniyle düzgün görüntülenemez.

> **Not**
> Windows-1254 adlı kod sayfası içinhttps://en.wikipedia.org/wiki/Windows-1254adresine; Windows-1250 adlı kod
sayfası için isehttps://en.wikipedia.org/wiki/Windows-1250adresine
bakabilirsiniz.

Not

Windows-1254 adlı kod sayfası içinhttps://en.wikipedia.org/wiki/Windows-1254adresine; Windows-1250 adlı kod
sayfası için isehttps://en.wikipedia.org/wiki/Windows-1250adresine
bakabilirsiniz.

İşte nasıl 1960’lı yılların başında Bob Bemer ve arkadaşları bilgisayarlar
arasında sağlıklı bir veri iletişimi sağlamak için kolları sıvayıp ASCII gibi
bir çözüm ürettiyse, ASCII ve Genişletilmiş ASCII ile kodlanamayan karakterleri
de kodlayıp, uluslar arasında çok geniş çaplı veri alışverişine izin verebilmek
amacıyla Xerox şirketinden Joe Becker, Apple şirketinden ise Lee Collins ve Mark
Davis UNICODE adlı bir çözüm üzerinde ilk çalışmaları başlattı.

Peki tam olarak nedir bu UNICODE denen şey?

Aslında Unicode da tıpkı ASCII gibi bir standarttır. Unicode’un bir proje olarak
ortaya çıkışı 1987 yılına dayanır. Projenin amacı, dünyadaki bütün dillerde yer
alan karakterlerin tek, benzersiz ve doğru bir biçimde temsil edilebilmesidir.
Yani bu projenin ortaya çıkış gayesi, ASCII’nin yetersiz kaldığı noktaları
telafi etmektir.

#### Sınırsız Bitlik bir Sistem

Unicode standardı ile ilgili olarak bilmemiz gereken ilk şey bu standardın
ASCII’yi tamamen görmezden gelmiyor olmasıdır. Daha önce de söylediğimiz gibi,
ASCII son derece yaygın ve güçlü bir standarttır. Üstelik ASCII standardı yaygın
olarak kullanılmaya da devam etmektedir. Bu sebeple ASCII ile halihazırda
kodlanmış karakterler UNICODE standardında da aynı şekilde kodlanmıştır.
Dolayısıyla ASCII UNICODE sisteminin bir alt kümesi olduğu için, ASCII ile
uyumlu olan bütün sistemler otomatik olarak UNICODE ile de uyumludur. Ancak
tabii bunun tersi geçerli değildir.

UNICODE’un ASCII’den en önemli farkı, UNICODE’un ASCII’ye kıyasla çok daha büyük
miktarda karakterin kodlanmasına izin vermesidir. ASCII yalnızca 128 karakterin
kodlanmasına izin verirken UNICODE 1.000.000’dan fazla karakterin kodlanmasına
izin verir.

UNICODE sistemini devasa bir karakter tablosu olarak hayal edebilirsiniz.
Bildiğiniz gibi ASCII 7 bitlik bir sistemdir. Bu sebeple de sadece 128 karakteri
kodlayabilir. UNICODE ilk ortaya çıktığında 16 bitlik bir sistem olarak
tasarlanmıştı. Dolayısıyla UNICODE daha ilk çıkışında2**16=65536karakterin
kodlanmasına izin veriyordu. Bugün ise UNICODE sisteminin böyle kesin bir sınırı
yoktur. Çünkü ‘bilmem kaç bitlik bir sistem’ kavramı UNICODE için geçerli
değildir. Dediğimiz gibi, UNICODE’u, ucu bucağı olmayan dev bir karakter tablosu
olarak düşünebilirsiniz. Bu tabloya istediğimiz kadar karakteri ekleyebiliriz.
Bizi engelleyen sınırlı bir bit kavramı mevcut değildir. Çünkü UNICODE
sisteminin kendisi, ASCII sisteminin aksine, doğrudan doğruya karakterleri
kodlamaz. UNICODE’un yaptığı şey karakterleri tanımlamaktan ibarettir.

Unicode sisteminde her karakter tek ve benzersiz bir ‘kod konumuna’ (code
point) karşılık gelir. Kod konumları şu formüle göre gösterilir:

```python
U+sayının_onaltılı_değeri

```

Örneğin ‘a’ harfinin kod konumu şudur:

```python
u+0061

```

Buradaki0061sayısı onaltılı bir sayıdır. Bunu onlu sayı sistemine
çevirebilirsiniz:

```python
>>> int("61", 16)

97

```

Hatırlarsanız ‘a’ harfinin ASCII tablosundaki karşılığı da97idi.

Esasında ASCII ile UNICODE birbirleri ile karşılaştırılamayacak iki farklı
kavramdır. Neticede ASCII bir kodlama biçimidir. UNICODE ise pek çok farklı
kodlama biçimini içinde barındıran devasa bir sistemdir.

> **Not**
> Unicode standardınahttp://www.unicode.org/versions/Unicode6.2.0/UnicodeStandard-6.2.pdfadresinden
ulaşabilirsiniz.

Not

Unicode standardınahttp://www.unicode.org/versions/Unicode6.2.0/UnicodeStandard-6.2.pdfadresinden
ulaşabilirsiniz.

#### UTF-8 Kod Çözücüsü

Dediğimiz gibi UNICODE devasa bir tablodan ibarettir. Bu tabloda karakterlere
ilişkin birtakım bilgiler bulunur ve bu sistemde her karakter, kod konumları ile
ifade edilir. UNICODE kendi başına karakterleri kodlamaz. Bu sistemde tanımlanan
karakterleri kodlama işi kod çözücülerin görevidir.

UNICODE sistemi içinde UTF-1, UTF-7, UTF-8, UTF-16 ve UTF-32 adlı kod çözücüler
bulunur. UTF-8, UNICODE sistemi içindeki en yaygın, en bilinen ve en kullanışlı
kod çözücüdür.

UTF-8 adlı kod çözücünün kodlayabildiği karakterlerin listesinehttps://www.fileformat.info/info/charset/UTF-8/list.htmadresinden
ulaşabilirsiniz. Bu listenin sayfalar dolusu olduğuna ve her sayfaya, sayfanın
en altındaki ‘More…’ bağlantısı ile ulaşabileceğinize dikkat edin.

#### 1 Karakter != 1 Bayt

ASCII sisteminde her karakterin 1 bayt’a karşılık geldiğini söylemiştik. Ancak 1
bayt dünyadaki bütün karakterleri kodlamaya yetmez. Geri kalan karakterleri de
kodlayabilmek için 1 bayttan fazlasına ihtiyacımız var. Mesela karakter kodlama
için:

```python
1 bayt kullanırsak toplam 2**8 = 256
2 bayt kullanırsak toplam 2**16 = 65,536
3 bayt kullanırsak toplam 2**24 = 16,777,216
4 bayt kullanırsak toplam 2**32 = 4,294,967,296

```

karakter kodlayabiliriz. Bu durumu şu Python kodları ile de gösterebiliriz:

```python
>>> for i in range(1, 5):
... print("{} bayt kullanırsak toplam 2**{:<2} = {:,}".format(i, i*8, (2**(i*8))))

```

Görünüşe göre biz 4 baytlık bir sistem kullanırsak gelmiş geçmiş bütün
karakterleri rahatlıkla temsil etmeye yetecek kadar alana sahip oluyoruz. Ancak
burada şöyle bir durum var. Bildiğiniz gibi, 0 ile 256 aralığındaki karakterler
yalnızca 1 bayt ile temsil edilebiliyor. 256 ile 65,536 arasındaki karakterler
için ise 2 bayt yeter. Aynı şekilde 65,536 ile 16,777,216 aralığındaki sayılar
için de 3 bayt yeterli. Bu durumda eğer biz bütün karakterleri 4 bayt ile temsil
edecek olursak, korkunç derece bir israfa düşmüş oluruz. Çünkü ASCII gibi bir
kodlama sisteminde yalnızca 1 bayt ile temsil edilebilecek bir karakterin
kapladığı alan bu sistemle boşu boşuna 4 kat artmış olacaktır.

Bu sorunun çözümü elbette sabit boyutlu karakter kodlama biçimleri yerine
değişken boyutlu karakter kodlama biçimleri kullanmaktır. İşte UNICODE sistemi
içindeki UTF-8 adlı kod çözücü, karakterleri değişken sayıda baytlar halinde
kodlayabilir. UTF-8, UNICODE sistemi içinde tanımlanmış karakterleri
kodlayabilmek için 1 ile 4 bayt arası değerleri kullanır. Böylece de bu kod
çözücü UNICODE sistemi içinde tanımlanmış bütün karakterleri temsil edebilir.

Bu durumu bir örnek üzerinden göstermeye çalışalım:

```python
harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
for s in harfler:
 print("{:<5}{:<15}{:<15}".format(s,
 str(s.encode("utf-8")),
 len(s.encode("utf-8"))))

```

Buradan şuna benzer bir çıktı alıyoruz:

```python
a b'a' 1
b b'b' 1
c b'c' 1
ç b'\xc3\xa7' 2
d b'd' 1
e b'e' 1
f b'f' 1
g b'g' 1
ğ b'\xc4\x9f' 2
h b'h' 1
ı b'\xc4\xb1' 2
i b'i' 1
j b'j' 1
k b'k' 1
l b'l' 1
m b'm' 1
n b'n' 1
o b'o' 1
ö b'\xc3\xb6' 2
p b'p' 1
r b'r' 1
s b's' 1
ş b'\xc5\x9f' 2
t b't' 1
u b'u' 1
ü b'\xc3\xbc' 2
v b'v' 1
y b'y' 1
z b'z' 1

```

Burada,s.encode("utf-8")komutunun ‘baytlar’ (bytes) türünden bir veri
tipi verdiğine dikkat edin (baytlar veri tipini bir sonraki bölümde ayrıntılı
olarak inceleyeceğiz). Karakter dizilerinin aksine baytlarınformat()adlı
bir metodu bulunmaz. Bu yüzden, bu veri tipiniformat()metoduna göndermeden
öncestr()fonksiyonu yardımıyla karakter dizisine dönüştürmemiz gerekiyor.
Bu dönüştürme işlevini, alternatif olarak şu şekilde de yapabilirdik:

```python
print("{:<5}{!s:<15}{:<15}".format(s,
 s.encode("utf-8"),
 len(s.encode("utf-8"))))

```

Hangi yöntemi seçeceğiniz paşa gönlünüze kalmış… Biz konumuza dönelim.

Yukarıdaki tabloda ilk sütun Türk alfabesindeki tek tek harfleri gösteriyor.
İkinci sütun ise bu harflerin UTF-8 ile kodlandığında nasıl göründüğünü. Son
sütunda ise UTF-8 ile kodlanan Türk harflerinin kaç baytlık yer kapladığını
görüyoruz.

Bu tabloyu daha iyi anlayabilmek için mesela buradaki ‘ç’ harfini ele alalım:

```python
>>> 'ç'.encode('utf-8')

b'\xc3\xa7'

```

Burada Python’ın kendi yerleştirdiği karakterleri çıkarırsak (‘b’ ve ‘\x’
gibi) elimizde şu onaltılı sayı kalır:

```python
c3a7

```

Bu onaltılı sayının onlu sistemdeki karşılığı şudur:

```python
>>> int('c3a7', 16)

50087

```

50087sayısının ikili sayma sistemindeki karşılığı ise şudur:

```python
>>> bin(50087)

'0b1100001110100111'

```

Gördüğünüz gibi, bu sayı 16 bitlik, yani 2 baytlık bir sayıdır. Bunu nasıl teyit
edeceğinizi biliyorsunuz:

```python
>>> (50087).bit_length()

16

```

https://www.fileformat.info/info/charset/UTF-8/list.htmadresine gittiğinizde de
UTF-8 tablosunda ‘ç’ harfinin ‘c3a7’ sayısıyla eşleştirildiğini göreceksiniz.

Bir de UTF-8’in ‘a’ harfini nasıl temsil ettiğine bakalım:

```python
>>> "a".encode("utf-8")

b'a'

```

‘a’ harfi standart ASCII harflerinden biri olduğu için Python doğrudan bu harfin
kendisini gösteriyor. Eğer bu harfin hangi sayıya karşılık geldiğini görmek
isterseniz şu kodu kullanabilirsiniz:

```python
>>> ord("a")

97

```

Daha önce de söylediğimiz gibi, UNICODE sistemi ASCII ile uyumludur. Yani ASCII
sisteminde tanımlanmış bir harf hangi sayı değerine sahipse, UNICODE içindeki
bütün kod çözücüleri de o harf için aynı sayıyı kullanır. Yani mesela ‘a’ harfi
hem ASCII’de, hem UTF-8’de97sayısı ile temsil edilir. Bu sayı 256’dan küçük
olduğu için yalnızca 1 bayt ile temsil edilir. Ancak standart ASCII dışında
kalan karakterler, farklı kod çözücüler tarafından farklı sayılarla
eşleştirilecektir. Bununla ilgili şöyle bir çalışma yapabiliriz:

```python
kod_çözücüler = ['UTF-8', 'cp1254', 'latin-1', 'ASCII']

harf = 'İ'

for kç in kod_çözücüler:
 try:
 print("'{}' karakteri {} ile {} olarak "
 "ve {} sayısıyla temsil edilir.".format(harf, kç,
 harf.encode(kç),
 ord(harf)))
 except UnicodeEncodeError:
 print("'{}' karakteri {} ile temsil edilemez!".format(harf, kç))

```

Bu programı çalıştırdığımızda şuna benzer bir çıktı alırız:

```python
.. code-block:: pycon

```

‘İ’ karakteri UTF-8 ile b’xc4xb0’ olarak ve 304 sayısıyla temsil edilir
‘İ’ karakteri cp1254 ile b’xdd’ olarak ve 304 sayısıyla temsil edilir.
‘İ’ karakteri latin-1 ile temsil edilemez!
‘İ’ karakteri ASCII ile temsil edilemez!

Bu ufak programı kullanarak hangi karakterin hangi kod çözücü ile nasıl temsil
edildiğini (veya temsil edilip edilemediğini) görebilirsiniz.

#### Eksik Karakterler ve encode Metodu

Dediğimiz ve örneklerden de gördüğümüz gibi, her karakter her kod çözücü ile
çözülemeyebilir. Mesela Windows-1254 adlı kod sayfasında bulunan bir karakter
Windows-1250 adlı kod sayfasında bulunamadığında, bulunmayan karakterin yerine
bir soru işareti (veya başka bir simge) yerleştirilecektir.

Aslında siz bu olguya hiç yabancı değilsiniz. İnternette dolaşırken mutlaka
anlamsız karakterlerle dolu web sayfalarıyla karşılaşmışsınızdır. Bu durumun
sebebi, ilgili sayfanın dil kodlamasının (encoding) düzgün belirtilmemiş
olmasıdır. Yani sayfanın HTML kodları arasındameta charsetetiketi ya hiç
yazılmamış ya da yanlış yazılmıştır. Eğer bu etiket hiç yazılmamışsa, Internet
tarayıcınız dil kodlamasının ne olduğunu kendince tahmin etmeyece çalışacak,
çoğunlukla da yanlış bir karar verecektir. Tarayıcınız metnin dilini düzgün
tespit edemediği için de bu metni yanlış bir karakter tablosu ile
eşleştirecek, o karakter tablosunda tanımlanmamış karakterler yerine bir soru
işareti veya başka anlamsız bir simge yerleştirecektir. Metni düzgün
görüntüleyebilmek için tarayıcınızın dil kodlamasının yapıldığı menü öğesini
bulup, doğru dil kodlamasını kendiniz seçeceksiniz. Böyle bir şeyi hayatınız
boyunca en az bir kez yapmak zorunda kaldığınıza eminim…

Bir karakter kümesinde herhangi bir karakter bulunamadığında, bulunamayan bu
karakterin yerine neyin geleceği, tamamen aradaki yazılıma bağlıdır. Örneğin söz
konusu olan bir Python programıysa, ilgili karakter bulunamadığında öntanımlı
olarak bu karakterin yerine hiçbir şey koyulmaz. Onun yerine program çökmeye
bırakılır… Ancak böyle bir durumda ne yapılacağını isterseniz kendiniz de
belirleyebilirsiniz.

Bunun için karakter dizilerininencode()metodununerrorsadlı
parametresinden yararlanacağız. Bu parametre dört farklı değer alabilir:
| Parametre | Anlamı |
| --- | --- |
| ‘strict’ | Karakter temsil edilemiyorsa hata verilir |
| ‘ignore’ | Temsil edilemeyen karakter görmezden gelinir |
| ‘replace’ | Temsil edilemeyen karakterin yerine bir ‘?’ işareti koyulur |
| ‘xmlcharrefreplace’ | Temsil edilemeyen karakter yerine XML karşılığı koyulur |

Parametre

Anlamı

‘strict’

Karakter temsil edilemiyorsa hata verilir

‘ignore’

Temsil edilemeyen karakter görmezden gelinir

‘replace’

Temsil edilemeyen karakterin yerine bir ‘?’ işareti koyulur

‘xmlcharrefreplace’

Temsil edilemeyen karakter yerine XML karşılığı koyulur

Bu parametreleri şöyle kullanıyoruz:

```python
>>> "bu Türkçe bir cümledir.".encode("ascii", errors="strict")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xfc' in
position 4: ordinal not in range(128)

```

‘strict’ zaten öntanımlı değerdir. Dolayısıyla eğererrorsparametresine
herhangi bir değer vermezsek Python sanki ‘strict’ değerini vermişiz gibi
davranacak ve ilgili karakter kodlaması ile temsil edilemeyen bir karakter ile
karşılaşıldığında hata verecektir:

```python
>>> "bu Türkçe bir cümledir.".encode("ascii")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\xfc' in
position 4: ordinal not in range(128)

```

Gelelim öteki değerlerin ne yaptığına:

```python
>>> "bu Türkçe bir cümledir.".encode("ascii", errors="ignore")

b'bu Trke bir cmledir.'

```

Gördüğünüz gibi,errorsparametresine ‘ignore’ değerini verdiğimizde, temsil
edilemeyen karakterler görmezden geliniyor:

```python
>>> "bu Türkçe bir cümledir.".encode("ascii", errors="replace")

b'bu T?rk?e bir c?mledir.'

```

Burada ise ‘replace’ değerini kullandık. Böylece temsil edilemeyen karakterlerin
yerine birer?işareti koyuldu:

```python
>>> "bu Türkçe bir cümledir.".encode("ascii", errors="xmlcharrefreplace")

b'bu T&#252;rk&#231;e bir c&#252;mledir.'

```

Son olarak ise ‘xmlcharrefreplace’ değerinin ne yaptığını görüyoruz. Eğererrorsparametresine ‘xmlcharrefreplace’ değerini verecek olursak, temsil
edilemeyen her bir harf yerine o harfin XML karşılığı yerleştirilir. Bu değer,
programınızdan alacağınız çıktıyı bir XML dosyasında kullanacağınız durumlarda
işinize yarayabilir.

#### Dosyalar ve Karakter Kodlama

Dosyalar konusunu anlatırken, Python’da bir dosyanınopen()fonksiyonu ile
açılacağını söylemiştik. Bildiğiniz gibiopen()fonksiyonunu şu şekilde
kullanıyoruz:

```python
>>> f = open(dosya_adı, dosya_açma_kipi)

```

Burada bizopen()fonksiyonunu iki farklı parametre ile birlikte kullandık.
Ancak aslında belirtmemiz gereken önemli bir parametresi daha var bu
fonksiyonun. İşte bu parametrenin adıencoding’dir.

Gelin şimdi bu parametrenin ne olduğuna ve nasıl kullanıldığına bakalım:

##### encoding

Tahmin edebileceğiniz gibi,encodingparametresi bir dosyanın hangi kod çözücü
ile açılacağını belirtmemizi sağlar. Python’da dosyalar öntanımlı olaraklocaleadlı bir modülüngetpreferredencoding()adlı fonksiyonunun
gösterdiği kod çözücü ile açılır. Siz de dosyalarınızın varsayılan olarak hangi
kod çözücü ile açılacağını öğrenmek için şu komutları yazabilirsiniz:

```python
>>> import locale
>>> locale.getpreferredencoding()

```

İşte eğer sizencodingparametresini belirtmezseniz, dosyalarınız yukarıdaki
çıktıda görünen kod çözücü ile açılacaktır.

GNU/Linux dağıtımlarında bu çıktı çoğunlukla UTF-8 olacaktır. O yüzden
GNU/Linux’ta dosyalarınız muhtemelenencodingbelirtmeseniz bile düzgün
görünecektir. Ancak Windows’talocale.getpreferredencoding()değeri cp1254
olacağı için, mesela UTF-8 ile kodlanmış dosyalarınızda özellikle Türkçe
karakterler düzgün görüntülenemeyecektir. O yüzden, dosyalarınızın hangi kod
çözücü ile kodlanmış olduğunuopen()fonksiyonuna vereceğinizencodingparametresi aracılığıyla her zaman belirtmelisiniz:

```python
>>> f = open(dosya, encoding='utf-8')

```

Diyelim ki açmak istediğiniz dosya cp1254 adlı kod çözücü ile kodlanmış olsun.
Eğer siz bu dosyayı açarken cp1254 adlı kod çözücüyü değil de başka bir kod
çözücüyü yazarsanız elbette dosyadaki karakterler düzgün görüntülenemeyecektir.

Örneğin cp1254 ile kodlanmış bir belgeyi UTF-8 ile açmaya kalkışırsanız veya siz
hiçbir kod çözücü belirtmediğiniz halde kullandığınız işletim sistemi öntanımlı
olarak dosyaları açmak için cp1254 harici bir kod çözücüyü kullanıyorsa, dosyayı
okuma esnasında şuna benzer bir hata alırsınız:

```python
>>> f = open("belge.txt", encoding="utf-8")
>>> f.read(50)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "C:\Python33\lib\codecs.py", line 300, in decode
 (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xde in position 79: invalid
 continuation byte

```

Gördüğünüz gibi, dosyamız bizim kullanmaya çalıştığımız kod çözücüden (UTF-8)
farklı bir kod çözücü ile (cp1254) kodlanmış olduğu için, doğal olarak
karakterler doğru sayılarla eşleştirilemiyor. Bu da kaçınılmaz olarak yukarıdaki
hatanın verilmesine sebep oluyor.

Aslında siz bu hatayı tanıyorsunuz.encode()metodunu anlatırken bunun ne
olduğundan ve bu hataya karşı neler yapabileceğinizden söz etmiştik.

Hatırlarsanız bu tür hatalara karşı ne tepki verileceğini belirleyebilmek içinencode()metodundaerrorsadlı bir parametreyi kullanabiliyorduk. İşteopen()fonksiyonunda da aynıerrorsparametresi bulunur.

##### errors

Dediğimiz gibi, bir dosyanın doğru görüntülenebilmesi ve okunabilmesi için,
sahip olduğu kodlama biçiminin doğru olarak belirtilmesi gerekir. Ama
okuyacağınız dosyaların hangi kodlama sistemine sahip olduğunu doğru tahmin
etmeniz her zaman mümkün olmayabilir. Böyle durumlarda, programınızın çökmesini
önlemek için çeşitli stratejiler belirlemeniz gerekir.

Bir önceki bölümde verdiğimiz örnekten de gördüğünüz gibi, eğer Python, açılmaya
çalışılan dosyadaki karakterleriencodingparametresinde gösterilen kod çözücü
ile çözemezse öntanımlı olarak bir hata mesajı üretip programdan çıkacaktır.
Ancak sizin istediğiniz şey her zaman bu olmayabilir. Mesela dosyadaki
karakterler doğru kodlanamasa bile programınızın çökmemesini tercih
edebilirsiniz. İşte bunun içinerrorsparametresinden yararlanacaksınız.

Bu parametreyiencoding()metodundan hatırlıyorsunuz. Bu parametre orada
nasıl kullanılıyorsa,open()fonksiyonunda da aynı şekilde kullanılır.
Dikkatlice bakın:

```python
>>> f = open(dosya_adı, encoding='utf-8', errors='strict')

```

Bu zatenerrorsparametresinin öntanımlı değeridir. Dolayısıyla ‘strict’
değerini belirtmeseniz de öntanımlı olarak bu değeri belirtmişsiniz gibi
davranılacaktır.

```python
>>> f = open(dosya_adı, encoding='utf-8', errors='ignore')

```

Burada ise ‘ignore’ değerini kullanarak, Python’ın kodlanamayan karakterleri
görmezden gelmesini sağlıyoruz.

```python
>>> f = open(dosya_adı, encoding='utf-8', errors='replace')

```

‘replace’ değeri ise kodlanamayan karakterlerin yerine\ufffdkarakterini
yerleştirecektir. Bu karakter işlev bakımından,encode()metodunu anlatırken
gördüğümüz ‘?’ işaretine benzer. Bu karaktere teknik olarak ‘UNICODE Değiştirme
Karakteri’ (UNICODE Replacement Character) adı verilir. Bazı yerlerde bu
karakteri elmas şeklinde siyah bir küp içine yerleştirilmiş soru işareti
şeklinde görebilirsiniz.

Pekiencode()metodunu anlatırkenerrorsparametresi ile birlikte
kullanabildiğimiz ‘xmlcharrefreplace’ değeriniopen()fonksiyonu ile
birlikte kullanabilir miyiz?

Hayır,open()fonksiyonu,errorsparametresinde bu değerin kullanılmasına
izin vermez.

### Konu ile ilgili Fonksiyonlar

Bu bölümde, karakter kodlama işlemleri esnasında işimize yarayacak bazı
fonksiyonları ele alacağız.

#### repr()

İnceleyeceğimiz ilk fonksiyonun adırepr(). Esasında biz bu fonksiyonu
önceki derslerimizde de birkaç örnekte kullanmıştık. Belki o zaman bu
fonksiyonun ne işe yaradığını deneme-yanılma yoluyla anlamış olabilirsiniz. Eğer
henüz bu fonksiyonun görevini anlamadıysanız da mesele değil. Bu bölümde bu
fonksiyonu ve işlevini ayrıntılı bir şekilde anlatmaya çalışacağız.

Dilersenizrepr()fonksiyonunu anlatmaya bir örnek ile başlayalım.

Şimdi Python’ın etkileşimli kabuğunu açarak şu kodu yazın:

```python
>>> "Python programlama dili"

```

Bu kodu yazıpENTERdüğmesine bastığınızda şöyle bir çıktı alacağınızı
biliyorsunuz:

```python
>>> 'Python programlama dili'

```

Dikkat ettiyseniz, yukarıdaki kodların çıktısında karakter dizisi tırnak
işaretleri içinde gösteriliyor. Eğer bu karakter dizisiniprint()fonksiyonu
içine yazarsanız o tırnak işaretleri kaybolacaktır:

```python
>>> print("Python programlama dili")

Python programlama dili

```

Peki bu iki farklı çıktının sebebi ne?

Python programlama dilinde nesneler iki farklı şekilde temsil edilir:
1. Python’ın göreceği şekilde
1. Kullanıcının göreceği şekilde

Python’ın göreceği şekilde

Kullanıcının göreceği şekilde

Yukarıdaki ilk kullanım, yazdığımız kodu Python programlama dilinin nasıl
gördüğünü gösteriyor. İkinci kullanım ise aynı kodu bizim nasıl gördüğümüzü
gösteriyor. Zaten bu yüzden, etkileşimli kabuktaprint()fonksiyonu içinde
yazmadığımız karakter dizilerinin çıktılarını ekranda görebildiğimiz halde, aynı
karakter dizilerini bir dosyaya yazıp kaydettiğimizde ekranda çıktı olarak
görebilmek için bunlarıprint()fonksiyonu içine yazmamız gerekiyor.

Bu söylediklerimiz biraz karmaşık gelmiş olabilir. İsterseniz ne anlatmaya
çalıştığımızı daha açık bir örnek üzerinde gösterelim. Şimdi tekrar etkileşimli
kabuğu açıp şu kodu çalıştıralım:

```python
>>> "birinci satır\n"

```

Bu komut bize şu çıktıyı verdi:

```python
'birinci satır\n'

```

Şimdi aynı kodu bir de şöyle yazalım:

```python
>>> print("birinci satır\n")

birinci satır

```

Gördüğünüz gibi, ilk kodun çıktısında satır başı karakteri (\n) görünürken,
ikinci kodun çıktısında bu karakter görünmüyor (ama işlevini yerine getiriyor.
Yani satır başına geçilmesini sağlıyor).

İşte bunun sebebi, ilk kodun Python’ın bakış açısını yansıtırken, ikinci kodun
bizim bakış açımızı yansıtmasıdır.

Peki bu bilgi bizim ne işimize yarar?

Şimdi şöyle bir örnek düşünün:

Diyelim ki elimizde şöyle bir değişken var:

```python
>>> a = "elma "

```

Şimdi bu değişkeni ekrana çıktı olarak verelim:

```python
>>> print(a)

elma

```

Gördüğünüz gibi, bu çıktıya bakarak,adeğişkeninin tuttuğu karakter dizisinin
son tarafında bir adet boşluk karakteri olduğunu anlayamıyoruz. Bu yüzden bu
değişkeni şöyle bir program içinde kullanmaya çalıştığımızda neden bozuk bir
çıktı elde ettiğimizi anlamak zor olabilir:

```python
>>> print("{} kilo {} kaldı!".format(23, a))

23 kilo elma kaldı!

```

Gördüğünüz gibi,“elma”karakter dizisinin son tarafında bir boşluk olduğu
için ‘elma’ ile ‘kaldı’ kelimeleri arasında gereksiz bir açıklık meydana geldi.

Bu boşluğuprint()ile göremiyoruz, ama bu değişkeniprint()olmadan
yazdırdığımızda o boşluk da görünür:

```python
>>> a

'elma '

```

Bu sayede programınızdaki aksaklıkları giderme imkanı kazanmış olur, şu kodu
yazarak gereksiz boşlukları atabilirsiniz:

```python
>>> print("{} kilo {} kaldı!".format(23, a.strip()))

23 kilo elma kaldı!

```

Daha önce de dediğimiz gibi, başındaprint()olmayan ifadeler, bir dosyaya
yazılıp çalıştırıldığında çıktıda görünmez. O halde biz yukarıdaki özellikten
yazdığımız programlarda nasıl yararlanacağız? İşte burada yardımımızarepr()adlı bir fonksiyon yetişecek. Bu fonksiyonu şöyle kullanıyoruz:

```python
print(repr("karakter dizisi\n"))

```

Bu kodu bir dosyaya yazıp kaydettiğimizde şöyle bir çıktı alıyoruz:

```python
'karakter dizisi\n'

```

Gördüğünüz gibi hem tırnak işaretleri, hem de satır başı karakteri çıktıda
görünüyor. Eğerrepr()fonksiyonunu kullanmasaydık şöyle bir çıktı
alacaktık:

```python
karakter dizisi

```

repr()fonksiyonu özellikle yazdığımız programlardaki hataları çözmeye
çalışırken çok işimize yarar. Çünküprint()fonksiyonu, kullanıcının gözüne
daha cazip görünecek bir çıktı üretebilmek için arkaplanda neler olup bittiğini
kullanıcıdan gizler. İşte arkaplanda neler döndüğünü,print()fonksiyonunun
bizden neleri gizlediğini görebilmek için burepr()fonksiyonundan
yararlanabiliriz.

> **Not**
> repr()fonksiyonu ile ilgili gerçek hayattan bir örnek içinistihza.com/blog/windows-python-3-2de-bir-hata.html(arşiv linki)adresindeki yazımızı okuyabilirsiniz.

Not

repr()fonksiyonu ile ilgili gerçek hayattan bir örnek içinistihza.com/blog/windows-python-3-2de-bir-hata.html(arşiv linki)adresindeki yazımızı okuyabilirsiniz.

Bütün bu açıklamalar bize şunu söylüyor:repr()fonksiyonu, bir karakter
dizisinin Python tarafından nasıl temsil edildiğini gösterir. Yukarıda biz bu
fonksiyonun nasıl kullanıldığına dair ayrıntıları verdik. Ancak bu fonksiyonun,
yine yukarıdaki işleviyle bağlantılı olmakla birlikte biraz daha farklı görünen
bir işlevi daha bulunur.

Hatırlarsanız, ilk derslerimizderadlı bir kaçış dizisinden söz etmiştik. Bu
kaçış dizisini şöyle kullanıyorduk:

```python
print(r"\n")

```

Bildiğiniz gibi,\nkaçış dizisi bir alt satıra geçmemizi sağlıyor. İşteradlı kaçış dizisi\nkaçış dizisinin bu işlevini baskılayarak, bizim\nkaçış dizisinin kendisini çıktı olarak verebilmemizi sağlıyor.

O halde bu noktada size şöyle bir soru sormama izin verin:

Acaba bir değişkene atanmış kaçış dizilerinin işlevini nasıl baskılayabiliriz?
Yani mesela elimizde şöyle bir değişken bulunuyor olsun:

```python
yeni_satır = "\n"

```

Biz bu değişkenin değerini nasıl ekrana yazdıracağız?

Eğer bunu doğrudanprint()fonksiyonuna gönderirsek ne olacağını
biliyorsunuz: Yeni satır karakteri işlevini yerine getirecek ve biz de yeni
satır karakterinin kendisini değil, yaptığı işin sonucunu (yani satır başına
geçildiğini) göreceğiz.

İşte bu tür durumlar için derepr()fonksiyonundan yararlanabilirsiniz:

```python
print(repr('\n'))

```

Böylece satır başı karakterinin işlevi baskılanacak ve biz çıktıda bu karakterin
kendisini göreceğiz.

Hatırlarsanız ASCII konusunu anlatırken şöyle bir örnek vermiştik:

```python
for i in range(128):
 if i % 4 == 0:
 print("\n")

 print("{:<3}{:>8}\t".format(i, repr(chr(i))), sep="", end="")

```

İşte burada,repr()fonksiyonunun yukarıda sözünü ettiğimiz işlevinden
yararlanıyoruz. Eğer bu kodlardarepr()fonksiyonunu kullanmazsak, ASCII
tablosunu oluşturan karakterler arasındaki\n,\a,\tgibi kaçış
dizileri ekranda görünmeyecek, bunun yerine bu kaçış dizileri doğrudan
işlevlerini yerine getirecek, bu da bizim istediğimiz ASCII tablosunu üretmemize
engel olacaktır.

#### ascii()

ascii()fonksiyonu biraz önce öğrendiğimizrepr()fonksiyonuna çok
benzer. Örneğin:

```python
>>> repr("asds")

"'asds'"

>>> ascii("asds")

"'asds'"

```

Bu iki fonksiyon,ASCIItablosunda yer almayan karakterlere karşı tutumları
yönünden birbirlerinden ayrılır. Örneğin:

```python
>>> repr("İ")

"'İ'"

>>> ascii("İ")

"'\\u0130'"

```

Gördüğünüz gibi,repr()fonksiyonuASCIItablosunda yer almayan
karakterleri de göründükleri gibi temsil ediyor.ascii()fonksiyonu ise bu
karakterlerin UNICODE kod konumlarını (code points) gösteriyor.

Bir örnek daha verelim:

```python
>>> repr("€")

"'€'"

>>> ascii("€")

"'\\u20ac'"

```

ascii()fonksiyonunun UNICODE kod konumlarını gösterme özelliğinin bir
benzerini daha önce öğrendiğimizencode()metodu yardımıyla da elde
edebilirsiniz:

```python
>>> "€".encode("unicode_escape")

b'\\u20ac'

```

Ancakascii()fonksiyonununstrtipinde,encode()metodunun isebytestipinde bir çıktı verdiğine dikkat edin.

#### ord()

Bu fonksiyon, bir karakterin sayı karşılığını verir:

```python
>>> ord("\n")

10

>>> ord("€")

8364

```

#### chr()

Bu fonksiyon, bir sayının karakter karşılığını verir:

```python
>>> chr(10)

'\n'

>>> chr(8364)

'€'

```

## Baytlar (Bytes) ve Bayt Dizileri (Bytearrays)

Bu bölüme gelinceye kadar veri tipi olarak karakter dizilerinden, listelerden ve
dosyalardan söz etmiştik. Bu bölümde ise Python programlama dilindeki iki veri
tipinden daha söz edeceğiz. Birbirleriyle doğrudan bağlantılı oldukları için
bu bölümde birlikte ele alacağımız bu veri tiplerinin adı ‘baytlar’(bytes) ve
‘bayt dizileri’ (bytearrays).

Bu bölümde yalnızca ‘baytlar’ ve ‘bayt dizileri’ adlı veri tiplerinden söz
etmeyeceğiz. Bu iki yeni veri tipini bilgi dağarcığımıza eklemenin yanısıra,
önceki bölümlerde öğrendiğimiz konuları zihnimizde pekiştirmeye ve
sağlamlaştırmaya da devam edeceğiz.

### Giriş

Bilgisayar teknolojisi ve bilimi açısından ‘karakter’ tamamen soyut bir
kavramdır. Son birkaç bölümdür üstüne basa basa tekrar ettiğimiz gibi, karakter
dediğimiz şey, bilgisayarların anlayabildiği tek kavram olan sayılara biz
insanların atadığı birtakım işaretlerden ibarettir. Dolayısıyla bilgisayarlar
açısından karakterler değil, ikili sayma düzenindeki birtakım sayılar, yani
bitler ve baytlar vardır.

Teknik olarak 1 bit, ikili sayma sistemindeki her bir basamağa verilen isimdir.
Zaten ‘bit’ kelimesinin de İngilizcede ‘ikili basamak’ anlamına gelen ‘binary
digitifadesinin kısaltması olduğunu geçen bölümde öğrenmiştiniz.

Örneğin ikili sayma sistemindeki0, bir bitlik bir sayı iken,100üç bitlik
bir sayıdır. Bu bit’lerin8tanesi bir araya gelince ‘bayt’ denen birimi
oluşturur. Yani bayt, 8 adet bit’ten oluşan bir birimdir. Nasıl bir düzinede 10,
bir destede de 12 öğe olmasını biz insanlar tercih etmiş ve belirlemişsek, bir
bayt’ta da 8 bit olmasını yine biz insanlar tercih etmiş ve belirlemişizdir.

Önceki derslerimizde de öğrendiğimiz gibi, 8 adet bit, yani 1 bayt,
Genişletilmiş ASCII sisteminde bir adet karakteri temsil etmek için
kullanılabilecek en büyük birim olarak tasarlanmıştır. Yani Genişletilmiş ASCII
tablolarının en sonundaki 255 numaralı karakteri temsil edebilmek için 8 adet
bit, yani toplam 1 bayt kullanmamız gerekir. Standart ASCII sistemi ise 7 bitlik
bir sistem olduğu için, bir adet karakteri temsil etmek için kullanılabilecek en
büyük birimin 7 bit olduğunu biliyorsunuz. Dolayısıyla ASCII sistemindeki son
karaktere karşılık gelen 127. sayıyı temsil edebilmek için toplam 7 bit
yeterlidir.

Farklı bir sistem olan UTF-8 ise birden fazla bayt kullanarak çok sayıda
karakteri temsil etmeye imkan tanır. UTF-8 ile, duruma göre 1, 2, 3 veya 4 bayt
kullanarak, UNICODE sistemi içinde tanımlanmış bütün karakterleri temsil
edebilirsiniz. UTF-8, değişken boyutlu bir kodlama sistemi olması sayesinde, bir
karakteri temsil edebilmek için kaç bayt gerekiyorsa, o karakteri temsil etmek
için o kadar bayt kullanır. Ama mesela UTF-32 adlı kod çözücü hangi karakter
olursa olsun hepsini 4 bayt (32 bit) ile temsil eder. Bu durumda aslında tek
baytla temsil edilebilecek ‘a’, ‘b’, ‘c’ gibi karakterler de boşu boşuna 4 bayt
yer kaplamış olur. Zaten UTF-8’in bu kadar yaygın ve gözde olmasının nedeni de
hem çok sayıda karakteri kodlayabilmesi, hem de bu işi yaparken tasarruflu
olmayı başarabilmesidir.

Python programlama dilinde karakter dizileri UNICODE kod konumları şeklinde
temsil edilir. Dolayısıylastradı verilen veri tipi esasında karakter
dizilerini birtakım UNICODE kod konumları şeklinde gösteren soyut bir yapıdır.
Yani biz Python’da karakter dizileri üzerinde işlem yaparken aslında baytlarla
değil, UNICODE kod konumları ile muhatap oluyoruz. Ancak UNICODE kod konumları
da tamamen soyut kavramlardır. Bunları bilgisayarın belleğinde bu şekilde temsil
edemezsiniz ya da bu kod konumlarını herhangi bir ağ üzerinden başka
bilgisayarlara iletemezsiniz. Bu kod konumlarını anlamlı bir şekilde
kullanabilmek için öncelikle bunları bilgisayarların anlayabileceği bir biçim
olan baytlara çevirmeniz gerekir. Çünkü dediğimiz gibi bilgisayarlar yalnızca
bitler ve baytlardan anlar. İşte kod çözücülerin görevi de zaten bu kod
konumlarını baytlara çevirmektir.

Esasında programcılık maceranız boyunca genellikle metin ihtiyaçlarınızı UNICODE
kod konumları üzerinden halledeceksiniz. Python sistemdeki öntanımlı kod
çözücüyü kullanarak bu kod konumlarını alttan alta bayta çevirip bellekte
saklayacaktır. Ama eğer yazdığınız programlarda herhangi bir şekilde doğrudan
baytlarla muhatap olmanız gerekirsestrveri tipini değil,bytesadlı başka
bir veri tipini kullanacaksınız. Örneğin ikili (binary) dosyalar üzerinde
çeşitli çalışmalar yapacaksanız ve bu ikili dosyalara birtakım veriler
girecekseniz, gireceğiniz bu verilerbytestipinde olacaktır.

Bütün bu sebeplerden ötürü,strvebytesveri tipleri arasındaki farkı
anlamak, yazdığınız programların kararlılığı ve sağlamlığı açısından büyük önem
taşır. O anda elinizde olan verinin hangi tipte olduğunu bilmezseniz, bu
verinin, programınızın çalışması esnasında size ne tür tuzaklar kurabileceğini
de kestiremezsiniz. Örneğin bütün karakterlerin 1 bayt olduğunu ve bunların da
yalnızca 0 ile 127 arası sayılarla temsil edilebileceğini zanneden
yazılımcıların tasarladığı programlara Türkçe karakterler girdiğinizde nasıl bu
programlar patır patır dökülüyorsa, eğer siz de baytlar ve karakterler
arasındaki farkı anlamazsanız sizin yazdığınız programlar da hiç beklemediğiniz
bir anda tökezleyebilir.

Örneğin yazdığınız bir programın bir aşamasında programa yalnızca tek
karakterlik verilerin girilmesi temeli üzerinden bir işlem yaptığınızı düşünün.
Yani programınız içinde yapacağınız bir işlem, birden fazla karakter girişinin
engellenmesini gerektiriyor olsun.

Bunun için şöyle bir şey yazmış olun:

```python
a = "k"

if len(a) > 1:
 print("Lütfen yalnızca tek bir karakter giriniz!")
else:
 print("Teşekkürler!")

```

Ben burada temsili olarakaadlı bir değişken oluşturdum ve örnek olması
açısından da bunun değerini ‘k’ olarak belirledim. Bu değerlerle programımız
düzgün bir şekilde çalışır. Çünküadeğişkeninin değeri tek bir karakter olan
‘k’ harfi. Ama eğeradeğişkeninin değeri mesela ‘kz’ gibi bir şey olsaydı
programımız ‘Lütfen yalnızca tek bir karakter giriniz!’ uyarısı verecekti…

Şimdi buadeğişkeninin sizin tarafınızdan belirlenmediğini, bu değerin başka
bir kaynaktan geldiğini düşünün. Eğer size bu değeri gönderen kaynak, bu değeri
UNICODE kod konumu olarak gönderiyorsa programınız düzgün çalışır. Ama peki ya
gelen bu veri bayt olarak geliyorsa ne olacak?

Yukarıda verdiğimiz örneğin neden önemli olduğunu, daha doğrusu bu örnekle ne
demek istediğimiz ve nereye varmaya çalıştığımızı anlamamış olabilirsiniz. Ama
endişe etmenize hiç gerek yok. Zira bu bölümde yukarıda sorduğumuz sorunun
cevabını derinlemesine ele alacağız. Bu bölümün sonuna vardığımızda neler olup
bittiğini ve baytların neden bu kadar önemli olduğunu gayet iyi anlıyor
olacaksınız.

### Eskisi ve Yenisi

Gelin isterseniz tam olarak ne ile karşı karşıya olduğumuzu daha iyi
anlayabilmek için Python3 öncesi durumun nasıl olduğuna bakalım. Eğer geçmişte
Python programlama dilinin karakter dizileri ve baytları nasıl ele aldığını
bilirsek bugünkü durumu ve dolayısıyla genel olarak karakter dizisi ve bayt
kavramını çok daha net bir şekilde kavrayabiliriz.

Python’ın 2.x sürümlerinde, bir karakter dizisi tanımladığınızda Python bu
karakter dizisini bir bayt dizisi olarak temsil ediyordu. Örneğin:

```python
>>> kardiz = "e"

```

Buradakardizadlı değişkenin değeri, bir baytlık bir karakter dizisidir. Bunulen()fonksiyonu ile teyit edelim:

```python
>>> len(kardiz)

1

```

Bir de şuna bakalım:

```python
>>> kardiz = "ş"

```

Burada isekardizadlı değişkenin değerinin kaç baytlık bir karakter dizisi
olduğu, yani bir bakımalen()fonksiyonunun ne çıktı vereceği işletim
sisteminden işletim sistemine farklılık gösterir. Eğer kullandığınız işletim
sistemi Windows ise muhtemelenlen(kardiz)komutu1çıktısı verecektir.
Ama eğer bu komutu GNU/Linux dağıtımlarından birinde veriyorsanız alacağınız
çıktı büyük ihtimalle2olacaktır.

Dediğimiz gibi, Python2’destrveri tipi bize bir dizi bayt verir. Dolayısıyla
bu veri tipinin içinde tuttuğu karakter dizisinin kaç bayt ile gösterileceği,
sistemdeki öntanımlı kod çözücünün hangisi olduğuna bağlıdır. Kullandığınız
işletim sisteminde öntanımlı kod çözücünün hangisi olduğunu şu komutla
bulabilirsiniz:

```python
>>> import locale
>>> locale.getpreferredencoding()

```

Eğer Windows kullanıyorsanız buradan alacağınız çıktı muhtemelen cp1254
olacaktır. cp1254, Microsoft’un Türkçe için özel olarak kullandığı bir kod
sayfası olduğu için, 128 ile 256 sayıları arasında Türkçe karakterleri içerir. O
yüzden bu kodlama sisteminde Türkçe karakterler 1 bayt ile gösterilebilir. Bu
kod sayfasının içeriğinde hangi karakterlerin hangi sayılara karşılık geldiğini
görmek içinen.wikipedia.org/wiki/Windows-1254adresindeki tabloyu
inceleyebilirsiniz.

Ama eğer yukarıdaki komutların çıktısı UTF-8 veya başka bir kod çözücü ise,
Türkçe karakterler 1 bayt ile gösterilemeyeceği içinlen(kardiz)komutu1değil,2çıktısı verecektir.

Bir de şuna bakalım:

```python
>>> len("€")

```

Bu komutu hangi işletim sisteminde verdiğinize bağlı olarak yukarıdaki komuttan
alacağınız çıktı farklı olacaktır.strtipi Python2’de karakter dizilerini
bayt olarak temsil eder. Bu temsilin de hangi kurallara göre yapılacağı
kullanılan kod çözücüye bağlıdır. Eğer karakter dizileri baytlara çevrilirken
cp1254 adlı kod çözücü kullanılırsa, bu kod çözücü ‘€’ simgesini tek bayt
ile gösterilebildiği için yukarıdaki komut1çıktısı verir. Ama UTF-8 adlı kod
çözücü ‘€’ simgesini3baytla gösterebildiği için yukarıdaki komutun çıktısı
da buna paralel olarak3olacaktır.

strveri tipi ile gösterilen bu karakter dizilerinin içindeki baytlara ulaşmak
için şu yöntemi kullanabilirsiniz:

```python
>>> "ş"[0]

'\xc5'

>>> "ş"[1]

'\x9f'

```

Gördüğünüz gibi,strveri tipi gerçekten de bize bir dizi bayt veriyor. Eğer
karakter dizilerini baytlarına göre değil de sahip oldukları karakter sayısına
göre saymak isterseniz bunları UNICODE olarak tanımlanız gerekiyor:

```python
>>> len(u'ş')

1

```

Python3 ile birlikte yukarıda bahsettiğimiz durumda bazı değişiklikler oldu.
Artıkstrveri tipi UNICODE kod konumlarını döndürüyor. Dolayısıyla artık her
karakter dizisi, sahip oldukları karakter sayısına göre sayılabiliyor:

```python
>>> len("ş")

1

>>> len("€")

1

```

İşte eğer Python2’dekistrveri tipini elde etmek istiyorsanız, Python3’tebytesadlı yeni veri tipini kullanmanız gerekiyor.

### Bayt Tanımlamak

Bildiğiniz gibi Python programlama dilinde her veri tipinin kendine özgü bir
tanımlanma biçimi var. Örneğin bir liste tanımlamak için şöyle bir şey
yazıyoruz:

```python
>>> liste = []

```

Böylece boş bir liste tanımlamış olduk. Aynı şekilde karakter dizilerini de
şöyle tanımlıyorduk:

```python
>>> kardiz = ''

```

Bu şekilde de boş bir karakter dizisi tanımlamış olduk. İşte boş bir bayt
tanımlamak için de şu yapıyı kullanıyoruz:

```python
>>> bayt = b''

```

Gelin tanımladığımız bu veri tipinin bayt olduğunu teyit edelim:

```python
>>> type(bayt)

<class 'bytes'

```

Gördüğünüz gibi, gerçekten de bayt tipinde bir veri tanımlamışız. Nasıl karakter
dizileri ‘str’, listeler ‘list’ ifadesiyle gösteriliyorsa, baytlar da ‘bytes’
ifadesi ile gösterilir.

Peki bu şekilde bir bayt veri tipi tanımlamak ne işimize yarar?

Hatırlarsanız bayt veri tipini ikili (binary) dosyaları anlatırken de
görmüştük. Orada da söylediğimiz gibi, ikili dosyaları okuduğunuzda elde
edeceğiniz şey karakter dizisi değil bayttır. Aynı şekilde, ikili dosyalara da
ancak baytları yazabilirsiniz. Dolayısıyla eğer ikili dosyalarla birtakım
işlemler yapacaksanız bu bayt veri tipini yoğun olarak kullanacağınızdan hiç
şüpheniz olmasın. Yani bayt veri tipi kolayca görmezden gelebileceğiniz
gereksiz bir veri tipi değildir.

### bytes() Fonksiyonu

Bayt veri tipi temel olarak ASCII karakterleri kabul eder. Dolayısıyla ASCII
tablosu dışında kalan karakterleri doğrudan bayt olarak temsil edemezsiniz:

```python
>>> b'ş'

 File "<stdin>", line 1
SyntaxError: bytes can only contain ASCII literal characters.

```

Ama ASCII dışında kalan karakterleri de bayt’a dönüştürmenin bir yolu var. Bunun
içinbytes()adlı bir fonksiyondan yararlanacağız:

```python
>>> b = bytes("ş", "utf-8")

```

Gördüğünüz gibi, ilgili karakterin hangi kod çözücü ile kodlanacağını
belirterek, bayt tipinde bir veri oluşturabiliyoruz.

Tahmin edebileceğiniz gibi,bytes()fonksiyonu, belirttiğimiz kod çözücü ile
kodlanamayan karakterlerle karşılaşılması durumunda ne yapılacağını
belirlememizi sağlayanerrorsadlı bir parametreye de sahiptir:

```python
>>> b = bytes("Fırat", "ascii", errors="xmlcharrefreplace")
>>> b

b'F&#305;rat'

```

Önceki derslerimizdeerrorsparametresinin hangi değerleri alabileceğini
tartışmıştık. Orada anlattığımız şeyler burada da geçerlidir.

### Baytların Metotları

Bütün veri tiplerinde olduğu gibi,bytesadlı veri tipinin de birtakım
metotları bulunur. Bu metotların listesini almak için şu komutu
kullanabileceğinizi biliyorsunuz:

```python
>>> dir(bytes)

```

Listeye baktığınızda bu metotları karakter dizilerinin metotları ile hemen hemen
aynı olduğunu göreceksiniz. Baytların metotları arasında olup da karakter
dizilerinin metotları arasında olmayan metotları şu şekilde elde edebilirsiniz:

```python
>>> for i in dir(bytes):
... if i not in dir(str):
... print(i)

decode
fromhex

```

Gördüğünüz gibi,decode()vefromhex()adlı metotlar baytlarda var, ama
karakter dizilerinde yok. O yüzden biz de bu bölümde yalnızca bu iki metodu
incelemekle yetineceğiz. Çünkü öteki metotları zaten karakter dizilerinden
tanıyorsunuz.

#### decode

Hatırlarsanız karakter dizilerininencode()adlı bir metodu vardı. Bu metot
yardımıyla karakter dizilerini belli bir kodlama biçimine göre kodlayabiliyor,
yani bunları baytlara çevirebiliyorduk. Mesela ‘İ’ harfini UTF-8 ile
kodlayalım:

```python
>>> "İ".encode("utf-8")

b'\xc4\xb0'

```

Aynı harfi cp1254 ile kodlarsak şu çıktıyı elde ederiz:

```python
>>> "İ".encode("cp1254")

b'\xdd'

```

Tahmin edebileceğiniz gibi, bu harfi ASCII ile kodlayamayız:

```python
>>> "İ".encode("ascii")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\u0130' in position 0:
 ordinal not in range(128)

```

İşte bu kodlama işlemini tersine çevirebilmek, yani baytları belli bir kodlama
biçimine göre karakter dizilerine dönüştürebilmek içindecode()metodundan
yararlanacağız:

```python
>>> b"\xc4\xb0".decode("utf-8")

'İ'

```

Bu baytları bir de başka kodlama sistemleri ile kodlamayı deneyelim:

```python
>>> b"\xc4\xb0".decode("cp1254")

'Ä°'

```

Gördüğünüz gibi, cp1254 adlı kod çözücü bu baytı çözebiliyor, ama yanlış
çözüyor! Çünkü bu baytın gösterdiği sayı cp1254 adlı kod sayfasında ‘İ’ye değil,
başka bir karaktere karşılık geliyor. Aslında başka iki karaktere, yani C4 ve B0
ile gösterilenÄve°karakterlerine karşılık geliyor… Bu durumuhttps://en.wikipedia.org/wiki/Windows-1254adresine gidip kendiniz de
görebilirsiniz.

Bu baytları bir de ASCII ile çözmeye çalışalım:

```python
>>> b"\xc4\xb0".decode("ascii")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 0: ordinal
not in range(128)

```

Elbette, bu karakter 128’den büyük bir sayıya karşılık geldiği için ASCII
tarafından çözülemeyecektir.

#### fromhex

Bu metot, onaltılı sayma sistemindeki bir sayıdan oluşan bir karakter dizisini
alıp, bayta dönüştürür. Bu metodu şöyle kullanıyoruz:

```python
>>> bytes.fromhex("c4b0")

b'\xc4\xb0'

```

Gördüğünüz gibi, bu metot bir onaltılı sayı olanc4b0’ı alıp, bize bir bayt
nesnesi veriyor.

### Bayt Dizileri

bytesadlı veri tipi ile elde ettiğimiz veri tıpkı karakter dizileri gibi,
üzerinde değişiklik yapılamayan bir veridir. Dolayısıyla birbytesnesnesi
üzerinde değişiklik yapabilmek için o nesneyi tekrar tanımlamamız gerekir:

```python
>>> b = b'PDF'
>>> v = b'-1.7'
>>> b = b + v
>>> b

b'PDF-1.7'

```

Ama Python programlama dilindebytesveri tipi dışında, baytlara ilişkin ikinci
veri tipi daha bulunur.bytearrayadlı bu veri tipi,bytesveri tipinin
aksine, üzerinde değişiklik yapılabilen bir veri tipidir.

Python’dabytearrayveri tipini şu şekilde tanımlıyoruz:

```python
>>> pdf = bytearray(b'PDF-1.7')

```

Gördüğünüz gibi, bir bayt dizisi tanımlayabilmek içinbytearray()adlı bir
fonksiyondan faydalanıyoruz.

### Bayt Dizilerinin Metotları

Bayt dizileri bir bakıma listelerle baytların karışımı gibidir.dir(bytearray)gibi bir komutla bu veri tipinin metotlarını inceleyecek olursanız, bu veri
tipinin hem baytlardan hem de listelerden birtakım metotlar aldığını görürsünüz.

Bu veri tipi listelerin şu metotlarına sahiptir:
1. append
1. clear
1. copy
1. count
1. extend
1. index
1. insert
1. pop
1. remove
1. reverse

append

clear

copy

count

extend

index

insert

pop

remove

reverse

Bu veri tipi baytların ise şu metotlarına sahiptir:
1. capitalize
1. center
1. count
1. decode
1. endswith
1. expandtabs
1. find
1. fromhex
1. index
1. isalnum
1. isalpha
1. isdigit
1. islower
1. isspace
1. istitle
1. isupper
1. join
1. ljust
1. lower
1. lstrip
1. maketrans
1. partition
1. replace
1. rfind
1. rindex
1. rjust
1. rpartition
1. rsplit
1. rstrip
1. split
1. splitlines
1. startswith
1. strip
1. swapcase
1. title
1. translate
1. upper
1. zfill

capitalize

center

count

decode

endswith

expandtabs

find

fromhex

index

isalnum

isalpha

isdigit

islower

isspace

istitle

isupper

join

ljust

lower

lstrip

maketrans

partition

replace

rfind

rindex

rjust

rpartition

rsplit

rstrip

split

splitlines

startswith

strip

swapcase

title

translate

upper

zfill

## Sözlükler

Şu ana kadar Python programlama dilinde veri tipi olarak karakter dizilerini,
sayıları, listeleri, demetleri ve dosyaları öğrendik. Yeni veri tipleri
öğrendikçe Python’daki hareket alanımızın da genişlediğini siz de
farketmişsinizdir. Bu bölümde yine Python’daki önemli veri tiplerinden birini
inceleyeceğiz. Bu defa inceleyeceğimiz veri tipinin adı sözlük. İngilizcede bunadictionarydiyorlar.

Sözlükler de, tıpkı daha önceki derslerimizde öğrendiğimiz karakter dizileri,
sayılar, listeler, demetler ve dosyalar gibi programlama maceramız boyunca
işlerimizi bir hayli kolaylaştıracak ve hareket imkanımızı genişletecek veri
tiplerinden biridir.

Öteki veri tiplerinde olduğu gibi, sözlüklerin de birtakım metotları vardır.
İşte bu bölümde hem genel olarak sözlüklerden söz edeceğiz, hem de bu veri
tipinin metotlarını en ince ayrıntısına kadar inceleyeceğiz.

Sözlük denen veri tipi Python programlama dilinin son derece kullanışlı ve işe
yarar araçlarından bir tanesidir. Programlama alanında ilerledikçe, bu veri
tipinin neler yapabileceğini görüp şaşıracağınızı rahatlıkla söyleyebilirim.

Esasında biz daha önceki derslerimizin birinde sözlük adlı bu veri tipinden
üstünkörü de olsa söz etmiştik. Yani aslında bu veri tipiyle tanışıklığımız
eskiye dayanıyor.

Hatırlayacaksınız, karakter dizilerininstr.maketrans()vetranslate()adlı metotlarını anlatırken, Türkçeye özgü karakterleri ve
bunların noktasız karşılıklarını içerençeviri_tablosuadını verdiğimiz şöyle
bir değişken tanımlamıştık:

```python
çeviri_tablosu = {"Ö": "O",
 "ç": "c",
 "Ü": "U",
 "Ç": "C",
 "İ": "I",
 "ı": "i",
 "Ğ": "G",
 "ö": "o",
 "ş": "s",
 "ü": "u",
 "Ş": "S",
 "ğ": "g"}

```

Buradaçeviri_tablosudeğişkeni içinde gösterdiğimiz biçimin Python’daki
adının ‘sözlük’ olduğunu da ifade etmiştik. İşte bu bölümde, orada şöyle bir
değinip geçtiğimiz bu veri tipini çok daha ayrıntılı bir şekilde ele alma
imkanımız olacak.

Hem eski bilgilerimize dayanarak, hem de yukarıda anlattıklarımızdan yola
çıkarak sözlük veri tipinin ne olduğuna dair halihazırda kafamızda bir fikir
oluşmuş olduğunu söyleyebiliriz.

Sözlükler öteki veri tiplerine kıyasla biraz farklı bir görünüşe sahip bir veri
tipidir. Biz birazdan sözlüklerin yapısını derinlemesine inceleyeceğiz.

Ancak sözlüklerin yapısını incelemeye geçmeden önce öğrenmemiz gereken bir şey
var. Tıpkı öteki veri tiplerinde olduğu gibi, sözlüklerle de çalışabilmek için
öncelikle bu veri tipini tanımlamış olmamız gerekiyor. O yüzden isterseniz
sözlüklerin yapısından söz etmeden önce bir sözlüğü nasıl tanımlayacağımızdan
bahsedelim.

### Sözlük Tanımlamak

Dediğimiz gibi, karakter dizilerini anlatırken verdiğimiz sözlük örneği
sayesinde sözlüklerin neye benzediğini az çok biliyoruz. Gelin isterseniz
sözlüklerin nasıl tanımlandığını inceleyerek bu veri tipinin derinliklerine
doğru ilk kulaçlarımızı atalım.

Python programlama dilindeki sözlük veri tipi, gerçek hayatta ‘sözlük’ denince
aklınıza gelen şeye çok benzer. Mesela gerçek hayatta ‘kitap’ kelimesinin
İngilizce bir sözlükteki karşılığıbookkelimesidir. Dolayısıyla ‘kitap’ ve
‘book’ kelimeleri arasındaki ilişkiyi herhalde şu şekilde temsil edebiliriz:

kitap: book

Bu manzara bize ‘kitap’ kelimesinin karşılığının ‘book’ olduğunu açık bir
şekilde gösteriyor. Eğer bu durumu Python’daki sözlük veri tipiyle göstermek
isteseydik şöyle bir şey yazacaktık:

```python
>>> kelimeler = {"kitap": "book"}

```

Burada, içeriği sözlük veri tipi olankelimeleradlı bir değişken tanımladık.
Gördüğünüz gibi, listelere benzer bir şekilde sözlük veri tipi de içinde farklı
veri tiplerini barındıran, ‘kapsayıcı’ bir veri tipidir. Burada sözlüğümüz iki
adet karakter dizisinden oluşuyor.

Yukarıdaki sözlüğü nasıl tanımladığımıza çok dikkat edin. Nasıl ki listelerin
ayırt edici özelliği köşeli parantezlerdi, sözlüklerin ayırt edici özelliği de
küme parantezleridir.

Esasında sözlük dediğimiz şey en basit haliyle şöyle görünür:

```python
>>> sözlük = {}

```

Bu örnek boş bir sözlüktür. İsterseniz yukarıdaki veri tipinin gerçekten de bir
sözlük olduğunu kanıtlayalım:

```python
>>> type(sözlük)

<class 'dict'>

```

Sözlüklerin Python programlama dilindeki teknik karşılığıdictifadesidir.type(sözlük)sorgusu<class'dict'>çıktısı verdiğine göre,sözlükadlı değişkenin gerçekten de bir sözlük olduğunu söyleyebiliyoruz.

Yukarıda şöyle bir sözlük örneği verdiğimizi hatırlıyorsunuz:

```python
>>> kelimeler = {"kitap": "book"}

```

Python programlama diline özellikle yeni başlayanlar, sözlüklerin görünüşü
nedeniyle bir sözlükteki öğe sayısı konusunda tereddüte kapılabilir, örneğin
yukarıdaki sözlüğün2öğeden oluştuğu yanılgısına düşebilir. O halde bu
noktada size şöyle bir soru sormama izin verin: Acaba bu sözlükte kaç öğe var?
Hemen bakalım:

```python
>>> len(kelimeler)

1

```

Demek ki elimizdeki veri tipi bir adet öğeye sahip bir sözlükmüş. Gördüğünüz
gibi,"kitap":"book"ifadesi tek başına bir öğe durumundadır. Yani burada“kitap”karakter dizisini ayrı,“book”karakter dizisini ayrı bir öğe olarak
almıyoruz. Bu ikisi tek bir sözlük öğesi oluşturuyor. Hatırlarsanız, listelerde
öğeleri birbirinden ayırmak için virgül işaretlerinden yararlanıyorduk.
Sözlüklerde de birden fazla öğeyi birbirinden ayırmak için virgül işaretlerinden
yararlanacağız:

```python
>>> kelimeler = {"kitap": "book", "bilgisayar": "computer"}

```

Bir önceki örnek tek öğeliydi. Bu sözlük ise2öğeye sahiptir:

```python
>>> len(kelimeler)

2

```

İlk derslerimizden bu yana sürekli olarak vurguladığımız gibi, Python
programlama dilinde doğru kod yazmak kadar okunaklı kod yazmak da çok önemlidir.
Mesela bir sözlüğü şöyle tanımladığımızda kodlarımızın pek okunaklı olmayacağını
söyleyebiliriz:

```python
sözlük = {"kitap": "book", "bilgisayar": "computer", "programlama": "programming",
"dil": "language", "defter": "notebook"}

```

Teknik olarak baktığımızda bu kodlarda hiçbir problem yok. Ancak sözlükleri
böyle sağa doğru uzayacak şekilde tanımladığımızda okunaklılığı azaltmış
oluyoruz. Bu yüzden yukarıdaki sözlüğü şöyle yazmayı tercih edebiliriz:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming",
 "dil" : "language",
 "defter" : "notebook"}

```

Bu şekilde sözlükteki öğeler arasındaki ilişki daha belirgin, yazdığınız kodlar
da daha okunaklı bir hale gelecektir.

Python’da bir sözlük oluşturmanın başka yolları da olmakla birlikte, en temel
sözlük oluşturma yöntemi yukarıdaki örneklerde gösterdiğimiz gibidir. Biz
ilerleyen sayfalarda sözlük oluşturmanın farklı yöntemlerini de ele alacağız.
Ancak şimdilik ‘sözlük tanımlama’ konusunu burada noktalayıp sözlüklerle ilgili
önemli bir konuya daha değinelim.

### Sözlük Öğelerine Erişmek

Yukarıdaki örneklerden bir sözlüğün en basit şekilde nasıl tanımlanacağını
öğrendik. Peki tanımladığımız bir sözlüğün öğelerine nasıl erişeceğiz?

Hemen basit bir örnek verelim. Daha önce tanımladığımız şu sözlüğe bir bakalım
mesela:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming",
 "dil" : "language",
 "defter" : "notebook"}

```

Bu sözlükte birtakım Türkçe kelimeler ve bunların İngilizce karşılıkları var.
Şimdi mesela bu sözlükteki ‘kitap’ adlı öğeye erişelim:

```python
print(sözlük["kitap"])

```

Bu kodları çalıştırdığımızda şöyle bir çıktı alırız:

```python
book

```

Yukarıdaki örnekten anladığımız gibi, sözlük öğelerine erişmek için şöyle bir
formül kullanıyoruz:

```python
sözlük[sözlük_öğesinin_adı]

```

Aynı şekildesözlükdeğişkeni içindeki ‘bilgisayar’ öğesinin karşılığını almak
istersek şöyle bir kod yazıyoruz:

```python
print(sözlük["bilgisayar"])

```

Bu da bize“computer”çıktısını veriyor.

Karakter dizilerini anlatırken verdiğimizçeviri_tablosuadlı sözlüğe ve orada
anlattıklarımıza geri dönelim şimdi. Artık sözlük adlı veri tipiyle iyiden iyiye
tanıştığımıza göre, orada anlattıklarımız zihninizde daha net bir hale gelmiş
olmalı.

Oradaki tablomuz şöyleydi:

```python
çeviri_tablosu = {"Ö": "O",
 "ç": "c",
 "Ü": "U",
 "Ç": "C",
 "İ": "I",
 "ı": "i",
 "Ğ": "G",
 "ö": "o",
 "ş": "s",
 "ü": "u",
 "Ş": "S",
 "ğ": "g"}

```

Mesela bu sözlükteki“Ö”öğesinin karşılığını elde etmek için şöyle bir kod
yazdığımızı gayet iyi hatırlıyorsunuz:

```python
print(çeviri_tablosu["Ö"])

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda şöyle bir çıktı alıyorduk:

```python
O

```

Gördüğünüz gibi sözlükteki“Ö”adlı öğeyi parantez içinde belirttiğimiz zaman,
Python bize bu öğenin karşısındaki değeri veriyor. Dolayısıyla sözlük içinde“Ö”öğesinin karşılığı“O”harfi olduğu için de çıktımız“O”oldu.

Sözlüğün öteki öğelerini ise şu şekilde alabiliyoruz:

```python
print(çeviri_tablosu["Ö"])
print(çeviri_tablosu["ç"])
print(çeviri_tablosu["Ü"])
print(çeviri_tablosu["Ç"])
print(çeviri_tablosu["İ"])
print(çeviri_tablosu["ı"])
print(çeviri_tablosu["Ğ"])
print(çeviri_tablosu["ö"])
print(çeviri_tablosu["Ş"])
print(çeviri_tablosu["ğ"])

```

Ancak kod tekrarından kaçınmak için yukarıdaki kodları şu şekilde sadeleştirme
imkanımızın da olduğunu biliyorsunuz:

```python
for i in çeviri_tablosu:
 print(çeviri_tablosu[i])

```

Gördüğünüz gibi, sözlük içinde iki nokta üst üste işaretinin sol tarafında
görünen öğeleri köşeli parantez içinde yazarak, iki nokta üst üste işaretinin
sağ tarafındaki değerleri elde edebiliyoruz.

Eğer bir sözlük içinde bulunmayan bir öğeye erişmeye çalışırsak Python bizeKeyErrortipinde bir hata mesajı verecektir. Mesela yukarıdaki sözlüğü temel
alacak olursak şöyle bir sorgu hata verecektir:

```python
>>> print(çeviri_tablosu["Z"])

Traceback (most recent call last):
 File "deneme.py", line 14, in <module>
 print(çeviri_tablosu["Z"])
KeyError: 'Z'

```

Sözlükte“Z”kaydı bulunmadığı için doğal olarak Python’ın bize bir hata
mesajı göstermekten başka çaresi kalmıyor.

Sözlükler ile ilgili epey bilgi edindik. Dilerseniz bu öğrendiklerimizi örnek
bir uygulama üzerinde somutlaştırmaya çalışalım. Mesela Python’daki sözlükleri
kullanarak basit bir telefon defteri uygulaması yazalım:

```python
telefon_defteri = {"ahmet öz" : "0532 532 32 32",
 "mehmet su": "0543 543 42 42",
 "seda naz" : "0533 533 33 33",
 "eda ala" : "0212 212 12 12"}

kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ")

cevap = "{} adlı kişinin telefon numarası: {}"

print(cevap.format(kişi, telefon_defteri[kişi]))

```

Burada öncelikle isimler ve telefon numaralarından oluşan, sözlük veri tipinde
bir telefon defteri oluşturduk:

```python
telefon_defteri = {"ahmet öz" : "0532 532 32 32",
 "mehmet su": "0543 543 42 42",
 "seda naz" : "0533 533 33 33",
 "eda ala" : "0212 212 12 12"}

```

Bu kodlarda bilmediğimiz hiçbir şey yok. Sözlüklere dair öğrendiklerimizi
kullanarak oluşturduğumuz oldukça basit bir sözlüktür bu.

Daha sonra kullanıcıdan, telefon numarasını öğrenmek için bir kişi adı girmesini
istiyoruz. Bunu da şu kodlar yardımıyla yapıyoruz:

```python
kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ")

```

Ardından da telefon defterinde sorgulama yapacak olan kullanıcıya göstereceğimiz
cevap için bir şablon oluşturuyoruz:

```python
cevap = "{} adlı kişinin telefon numarası: {}"

```

Mesela kullanıcı“ahmet öz”ismini sorgulamışsa ona şöyle bir cevap
vereceğiz:

```python
"ahmet öz adlı kişinin telefon numarası 0532 532 32 32"

```

Eğer aranan isim telefon defterinde varsa, bir önceki adımda tanımladığımız
cevap şablonuna göre kullanıcıyı bilgilendiriyoruz. Ama eğer isim defterde
yoksa, programımız hata veriyor. Bunu önlemek için şöyle bir kod
yazabilirsiniz:

```python
telefon_defteri = {"ahmet öz" : "0532 532 32 32",
 "mehmet su": "0543 543 42 42",
 "seda naz" : "0533 533 33 33",
 "eda ala" : "0212 212 12 12"}

kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ")

if kişi in telefon_defteri:
 cevap = "{} adlı kişinin telefon numarası: {}"
 print(cevap.format(kişi, telefon_defteri[kişi]))
else:
 print("Aradığınız kişi telefon rehberinde yok!")

```

Gördüğünüz gibi,ifkişiintelefon_defterisatırı yardımıyla öncelikle
aranan ismin sözlükte olup olmadığını denetledik. Eğer aranan isim sözlükte yer
alıyorsa bu telefon numarasını kullanıcılarımıza gösteriyoruz. Aksi durumda
aranan kişinin telefon rehberinde olmadığı konusunda kullanıcılarımızı
bilgilendiriyoruz.

Gördüğünüz gibi, sözlükler gerçekten de bize Python programlama maceramızda
yepyeni olanakların kapısını açabilecek kadar güçlü bir veri tipi. Bu veri
tipini programlarınızda bolca kullanacaksınız.

Yukarıda verdiğimiz telefon defteri uygulamasına şöyle bir baktığınızda bu
uygulamanın aslında geliştirilmeye bir hayli açık olduğu dikkatinizi çekmiştir.
Mesela biz bu uygulamada sadece kendi tanımladığımız bir telefon defteri
üzerinden sorgulama yapmaya izin verdik. Örneğin kullanıcı bu telefon defterine
kendi isim-telefon çiftlerini giremiyor. Bu veri tipini etkili bir şekilde
kullanmamızı sağlayacak araçlardan henüz yoksun olduğumuz için yukarıda
tanımladığımız uygulama çok basit kaldı. O halde, sözlük veri tipini daha
verimli ve etkili bir biçimde kullanabilmek için hiç vakit kaybetmeden bu veri
tipinin derinliklerine doğru yol almaya devam edelim.

### Sözlüklerin Yapısı

Yukarıdaki örneklerden, Python’da bir sözlüğün nasıl tanımlanacağını ve bir
sözlüğün öğelerine nasıl erişileceğini öğrendik. Gelin isterseniz şimdi sözlük
veri tipinin yapısına ilişkin bazı ayrıntıları inceleyelim.

Mesela şu örneği tekrar önümüze alalım:

```python
sözlük = {"kitap": "book"}

```

Burada iki nokta üst üste işaretinden önce ve sonra birer tane karakter dizisi
görüyoruz. Bu karakter dizileri“kitap”ve“book”. Dediğimiz gibi, sözlükler
de tıpkı listeler gibi, farklı veri tiplerinin bir araya gelmesi ile oluşan
birleşik/kapsayıcı bir veri tipidir. Dolayısıyla bir sözlük içinde sadece
karakter dizilerini değil, başka veri tiplerini de görebilirsiniz. İlerleyen
sayfalarda sözlüklere ilişkin daha karmaşık örnekler verdiğimizde sözlüklerin
hangi veri tiplerini içerebileceğini de göreceğiz.

Ne dedik? Sözlük içinde iki nokta üst üste işaretinin solunda ve sağında“kitap”ve“book”adlı karakter dizileri var. Teknik olarak, iki nokta üst
üste işaretinin solundaki karakter dizisine ‘anahtar’ (key), sağındaki
karakter dizisine ise ‘değer’ (value) adı verilir. Bu bilgilere bakarak sözlük
için şöyle bir tanım verebiliriz:

Sözlükler; anahtar ve değer çiftlerinin birbirleriyle eşleştirildiği bir
veri tipidir. Dolayısıyla sözlükler bu anahtar ve değer çiftleri arasında
birebir ilişki kurar.

Mesela yukarıdaki örnekte“kitap”öğesi anahtar,“book”öğesi ise değerdir.
İşte sözlük dediğimiz şey, bu anahtar ve değer çifti arasında birebir ilişki
kuran bir veri tipidir. Yani sözlük adlı veri tipi, bir anahtarı bir değerle
eşleştirme görevi görür.

Sözlüklerin bu özelliğini, sözlük öğelerine erişirken gayet net bir şekilde
görebiliyoruz.

Yukarıdaki örneklerde tanımladığımız sözlüklerde sadece karakter dizilerini
kullandık. Ama aslında sözlükler farklı veri tiplerinden oluşabilir. Mesela:

```python
sözlük = {"sıfır": 0,
 "bir" : 1,
 "iki" : 2,
 "üç" : 3,
 "dört" : 4,
 "beş" : 5}

```

Burada sözlük içinde hem sayıları hem de karakter dizilerini kullandık. Aynı
şekilde sözlük içinde listelere de yer verebiliriz:

```python
sözlük = {"Ahmet Özkoparan": ["İstanbul", "Öğretmen", 34],
 "Mehmet Yağız" : ["Adana", "Mühendis", 40],
 "Seda Bayrak" : ["İskenderun", "Doktor", 30]}

```

Mesela bu sözlükte“Seda Bayrak”adlı kişinin bilgilerine ulaşmak istersek
şöyle bir kod yazabiliriz:

```python
print(sözlük["Seda Bayrak"])

```

Bu kod bize şöyle bir çıktı verecektir:

```python
['İskenderun', 'Doktor', 30]

```

Gördüğünüz gibi, sözlük içinde“Seda Bayrak”adlı öğenin karşısındaki bilgi
listesine ulaşabildik.

İstersek sözlükleri, içlerinde başka sözlükleri barındıracak şekilde de
tanımlayabiliriz:

```python
kişiler = {"Ahmet Özkoparan": {"Memleket": "İstanbul",
 "Meslek" : "Öğretmen",
 "Yaş" : 34},

 "Mehmet Yağız" : {"Memleket": "Adana",
 "Meslek" : "Mühendis",
 "Yaş" : 40},

 "Seda Bayrak" : {"Memleket": "İskenderun",
 "Meslek" : "Doktor",
 "Yaş" : 30}}

```

Böylece şöyle kodlar yazabiliriz:

```python
print(kişiler["Mehmet Yağız"]["Memleket"])
print(kişiler["Seda Bayrak"]["Yaş"])
print(kişiler["Ahmet Özkoparan"]["Meslek"])

```

Yukarıdaki yapının benzerini listeler konusundan hatırlıyor olmalısınız. İç içe
geçmiş listelerin öğelerine ulaşırken de buna benzer bir sözdiziminden
yararlanıyorduk. Örneğin:

```python
liste = [["Ahmet", "Mehmet", "Ayşe"],
 ["Sedat", "Serkan", "Selin"],
 ["Zeynep", "Nur", "Eda"]]

```

Burada bir liste içinde iç içe geçmiş üç farklı liste ile karşı karşıyayız.
Mesela ilk listenin ilk öğesi olan“Ahmet”adlı öğeye erişmek istersek şöyle
bir kod yazmamız gerekiyor:

```python
print(liste[0][0])

```

İşte iç içe geçmiş sözlüklerin öğelerine ulaşmak için de buna benzer bir kod
yazmamız gerekiyor. Örneğinkişileradlı sözlükteki“Mehmet Yağız”adlı
kişinin yaşına ulaşmak istersek şöyle bir şey yazacağız:

```python
print(kişiler["Mehmet Yağız"]["Yaş"])

```

Gelin istersenizkişileradlı sözlüğü kullanarak basit bir irtibat listesi
uygulaması yazalım. Böylece sözlüklere elimizi alıştırmış oluruz:

```python
kişiler = {"Ahmet Özkoparan": {"Memleket": "İstanbul",
 "Meslek" : "Öğretmen",
 "Yaş" : 34},

 "Mehmet Yağız" : {"Memleket": "Adana",
 "Meslek" : "Mühendis",
 "Yaş" : 40},

 "Seda Bayrak" : {"Memleket": "İskenderun",
 "Meslek" : "Doktor",
 "Yaş" : 30}}

isim = "Hakkında ayrıntılı bilgi edinmek \
istediğiniz kişinin adını girin: "

arama = input(isim)

ayrıntı = input("Memleket/Meslek/Yaş? ")

print(kişiler[arama][ayrıntı])

```

Tıpkı bir önceki telefon defteri uygulamamız gibi, bu irtibat listesi uygulaması
da geliştirilmeye açıktır. Ancak henüz bu iki uygulamayı geliştirmemizi
sağlayacak bilgilerden yoksunuz. Bu uygulamaları istediğimiz kıvama sokabilmek
için sözlüklere dair öğrenmemiz gereken başka şeyler de var.

Sözlüklerin öteki veri tiplerinden önemli bir farkı, sözlük içinde yer
alan öğelerin herhangi bir sıralama mantığına sahip olmamasıdır. Yani sözlükteki
öğeler açısından ‘sıra’ diye bir kavram yoktur.

> **Not**
> Python3.7’dan başlayarak sözlükler içerdikleri öğelerin eklenme sırasını korumaktadır. Python’un 3.7’den yüksek bir versiyonunda oluşturduğunuz sözlükleri ekrana yazdırmayı denerseniz sözlüğü oluştururken elemanların içinde bulunduğu sıranın korunduğunu siz de görebilirsiniz. Ancak sözlüklerin elemanlarına listeler gibi bir sıra ile (liste[sıra]gibi) erişilemez. Ayrıntılı bilgi içinburayabakabilirsiniz.

Not

Python3.7’dan başlayarak sözlükler içerdikleri öğelerin eklenme sırasını korumaktadır. Python’un 3.7’den yüksek bir versiyonunda oluşturduğunuz sözlükleri ekrana yazdırmayı denerseniz sözlüğü oluştururken elemanların içinde bulunduğu sıranın korunduğunu siz de görebilirsiniz. Ancak sözlüklerin elemanlarına listeler gibi bir sıra ile (liste[sıra]gibi) erişilemez. Ayrıntılı bilgi içinburayabakabilirsiniz.

Örneğin bir liste, demet veya karakter dizisi içindeki öğelere; bu öğelerin o
liste, demet veya karakter dizisi içindeki sıralarına göre erişebilirsiniz:

```python
>>> liste = ["Ahmet", "Mehmet", "Zeynep"]
>>> liste[0]

'Ahmet'

>>> liste[-1]

'Zeynep'

```

Ancak sözlükler açısından böyle bir şey söz konusu değildir:

```python
>>> sözlük = {'elma': 'apple',
... 'armut': 'pear',
... 'çilek': 'strawberry'}
>>> sözlük[0]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
KeyError: 0

```

Gördüğünüz gibi, sözlükler üzerinde sıralamaya dayalı bir sorgulama yapmaya
çalıştığımızda Python bize bir hata mesajı gösteriyor.

Bu durumun etkilerini şurada da görebilirsiniz:

Dikkatlice bakın:

```python
>>> sözlük = {'a': '0', 'b': '1', 'c': '2'}
>>> sözlük

{'a': '0', 'c': '2', 'b': '1'}

```

> **Not**
> Yukarıda da dediğimiz gibi, Python3.7+ versiyonlarında buradaki örneğin aksine
elemanlar her zaman onları sözlüğe eklediğiniz sırada ekrana yazılacaktır.

Not

Yukarıda da dediğimiz gibi, Python3.7+ versiyonlarında buradaki örneğin aksine
elemanlar her zaman onları sözlüğe eklediğiniz sırada ekrana yazılacaktır.

Bu çıktıyı iyi inceleyin. Göreceğiniz gibi, çıktıda görünen öğeler bizim sözlüğü
tanımladığımız sıradaki gibi değil. Biz sözlüğü ‘a’, ‘b’ ve ‘c’ şeklinde
sıralayarak tanımladık, ama çıktı ‘a’, ‘c’ ve ‘b’ şeklinde oldu. O yüzden
sözlükler üzerinde çalışırken öğelerin sırasına dayalı herhangi bir işlem yapmak
hiç mantıklı değildir. Çünkü sözlükteki öğeleri tanımlarken kullandığınız
sıralama düzeninin çıktıda da aynen korunacağının herhangi bir garantisi
bulunmaz.

### Sözlüklere Öğe Eklemek

Tıpkı listeler gibi, sözlükler de büyüyüp küçülebilen bir veri tipidir. Yani bir
sözlüğü ilk kez tanımladıktan sonra istediğimiz zaman bu sözlüğe yeni öğeler
ekleyebilir veya varolan öğeleri çıkarabiliriz. Biz şimdi bir sözlüğe nasıl öğe
ekleyeceğimizi inceleyeceğiz.

Diyelim ki elimizde şöyle boş bir sözlük var:

```python
>>> sözlük = {}

```

Bu listeye öğe eklemek için şöyle bir formül kullanacağız:

```python
>>> sözlük[anahtar] = değer

```

Bu formülü bir örnek üzerinden somutlaştıralım:

```python
>>> sözlük["Ahmet"] = "Adana"

```

Böylece sözlüğe, anahtarı“Ahmet”, değeri ise“Adana”olan bir öğe eklemiş
olduk. Sözlüğümüzün son durumunu kontrol edelim:

```python
>>> print(sözlük)

{'Ahmet': 'Adana'}

```

Gördüğünüz gibi, “Ahmet” öğesi sözlüğe eklendi. Artık bu öğeye normal yollardan
ulaşabiliriz:

```python
>>> print(sözlük["Ahmet"])

Adana

```

Elimiz alışsın diye sözlüğe öğe eklemeye devam edelim:

```python
>>> sözlük["Mehmet"] = "İstanbul"
>>> sözlük

{'Ahmet': 'Adana', 'Mehmet': 'İstanbul'}

>>> sözlük["Seda"] = "Mersin"
>>> sözlük

{'Ahmet': 'Adana', 'Mehmet': 'İstanbul', 'Seda': 'Mersin'}

>>> sözlük["Eda"] = "Tarsus"
>>> sözlük

{'Ahmet': 'Adana', 'Eda': 'Tarsus', 'Mehmet': 'İstanbul', 'Seda': 'Mersin'}

```

Özellikle son çıktıya dikkatlice bakın. Sözlüğe en son“Eda”öğesini
eklemiştik. Ama sözlüğü ekrana bastığımızda bu öğenin sözlüğün sonuna değil
ortasına bir yere yerleştiğini görüyoruz. Bu durumun, sözlüklerin sırasız bir
veri tipi olmasından kaynaklandığını biliyorsunuz.

Gelin pratik olması açısından birkaç örnek daha verelim.

Elimizde şöyle bir sözlük olsun:

```python
>>> personel = {"Mehmet Öz": "AR-GE Müdürü",
... "Samet Söz": "Genel Direktör",
... "Sedat Gün": "Proje Müdürü"}

```

Şimdi bu sözlüğe"TurgutÖzben":"Mühendis"anahtar-değer çiftini
ekleyelim:

```python
>>> personel["Turgut Özben"] = "Mühendis"

```

Sözlüğümüzün son halini görelim:

```python
>>> print(personel)

{'Samet Söz': 'Genel Direktör', 'Mehmet Öz': 'AR-GE Müdürü', 'Turgut Özben':
'Mühendis', 'Sedat Gün': 'Proje Müdürü'}

```

Gördüğünüz gibi eklemek istediğimiz öğe sözlüğe eklenmiş. Ancak bu öğenin
sözlüğün en sonuna değil, sözlük içine rastgele bir şekilde yerleştirildiğine
dikkatinizi çekmek isterim. Çünkü, dediğimiz gibi, sözlükler sırasız bir veri
tipidir.

Gelin bu konuyu daha iyi anlamak için bir örnek daha verelim.

Öncenotlaradında boş bir sözlük tanımlayalım:

```python
>>> notlar = {}

```

Bu sözlüğe öğrencilerin sınavdan aldıkları notları ekleyeceğiz:

```python
>>> notlar["Ahmet"] = 45
>>> notlar["Mehmet"] = 77
>>> notlar["Seda"] = 98
>>> notlar["Deniz"] = 95
>>> notlar["Ege"] = 95
>>> notlar["Zeynep"] = 100

```

Sözlüğümüzün son halini görelim:

```python
>>> print(notlar)

{'Seda': 98, 'Ege': 95, 'Mehmet': 77, 'Zeynep': 100, 'Deniz': 95, 'Ahmet': 45}

```

Bu noktada sözlüklerin önemli bir özelliğinden bahsetmemiz uygun olacak. Bir
sözlüğe değer olarak bütün veri tiplerini verebiliriz. Yani:

```python
>>> sözlük = {}
>>> sözlük = {'a': 1}
>>> sözlük = {'a': (1,2,3)}
>>> sözlük = {'a': 'kardiz'}
>>> sözlük = {'a': [1,2,3]}

```

Gördüğünüz gibi, sözlükler değer olarak her türlü veri tipini kabul ediyor. Ama
durum sözlük anahtarları açısından böyle değildir. Yani sözlüklere anahtar
olarak her veri tipini atayamayız. Bir değerin ‘anahtar’ olabilmesi için, o
öğenin değiştirilemeyen (immutable) bir veri tipi olması gerekir. Python’da
şimdiye kadar öğrendiğimiz şu veri tipleri değiştirilemeyen veri tipleridir:
1. Demetler
1. Sayılar
1. Karakter Dizileri

Demetler

Sayılar

Karakter Dizileri

Şu veri tipleri ise değiştirilebilen veri tipleridir:
1. Listeler
1. Sözlükler

Listeler

Sözlükler

Dolayısıyla bir sözlüğe anahtar olarak ancak şu veri tiplerini ekleyebiliriz:
1. Demetler
1. Sayılar
1. Karakter Dizileri

Demetler

Sayılar

Karakter Dizileri

Şu kodları dikkatlice inceleyin:

Önce boş bir sözlük oluşturalım:

```python
>>> sözlük = {}

```

Bu sözlüğe anahtar olarak bir demet ekleyelim:

```python
>>> l = (1,2,3)
>>> sözlük[l] = 'falanca'
>>> sözlük

{(1, 2, 3): 'falanca'}

```

Bir sayı ekleyelim:

```python
>>> l = 45
>>> sözlük[l] = 'falanca'
>>> sözlük

{45: 'falanca', (1, 2, 3): 'falanca'}

```

Bir karakter dizisi ekleyelim:

```python
>>> l = 'kardiz'
>>> sözlük[l] = 'falanca'
>>> sözlük

{'kardiz': 'falanca', 45: 'falanca', (1, 2, 3): 'falanca'}

```

Yukarıdakiler, değiştirilemeyen veri tipleri olduğu için sözlüklere anahtar
olarak eklenebildi.

Bir de şunlara bakalım:

Sözlüğümüze anahtar olarak bir liste eklemeye çalışalım:

```python
>>> l = [1,2,3]
>>> sözlük[l] = 'falanca'

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

```

Sözlüğümüze bir sözlük eklemeye çalışalım:

```python
>>> l = {"a": 1, "b": 2, "c": 3}
>>> sözlük[l] = 'falanca'

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'dict'

```

Sözlüklerle çalışırken sözlüklerin bu özelliğine karşı uyanık olmalıyız.

### Sözlük Öğeleri Üzerinde Değişiklik Yapmak

Sözlükler değiştirilebilir veri tipleridir. Dolayısıyla sözlükler üzerinde
rahatlıkla istediğimiz değişikliği yapabiliriz.

Sözlükler üzerinde değişiklik yapma işlemi, biraz önce öğrendiğimiz, sözlüklere
yeni öğe ekleme işlemiyle aynıdır. Dikkatlice bakın:

```python
>>> notlar = {'Seda': 98, 'Ege': 95, 'Mehmet': 77,
... 'Zeynep': 100, 'Deniz': 95, 'Ahmet': 45}

```

Sözlüğümüz bu. Şimdi bu sözlükteki ‘Ahmet’ adlı kişinin45olan notunu65olarak değiştirelim:

```python
>>> notlar["Ahmet"] = 65
>>> print(notlar)

{'Seda': 98, 'Ege': 95, 'Mehmet': 77, 'Zeynep': 100, 'Deniz': 95, 'Ahmet': 65}

```

Gördüğünüz gibi Ahmet’in notu65olarak değişmiş…

### Sözlük Üreteçleri (Dictionary Comprehensions)

Hatırlarsanız listeleri anlatırken liste üreteçleri adı bir kavramdan söz
etmiştik. Liste üreteçlerini kullanarak tek satırda ve hızlı bir şekilde
listeler oluşturabiliyorduk. Aynı şey sözlükler için de geçerlidir. Tıpkı liste
üreteçlerinde olduğu gibi, sözlük üreteçleri sayesinde tek satırda ve hızlı bir
şekilde sözlükler üretebiliriz.

Örneğin elimizde, Türkçe alfabedeki harfleri içerenharfleradlı şöyle bir
karakter dizisi olduğunu düşünün:

```python
>>> harfler = 'abcçdefgğhıijklmnoöprsştuüvyz'

```

Amacımız bu harflerin her birine bir numara vermek. Yani nihai olarak şöyle bir
sözlük elde etmek istiyoruz:

```python
{'ğ': 8,
 'v': 26,
 'ş': 22,
 'u': 24,
 't': 23,
 'ö': 18,
 'ı': 10,
 'p': 19,
 's': 21,
 'r': 20,
 'ü': 25,
 'y': 27,
 'ç': 3,
 'z': 28,
 'e': 5,
 'd': 4,
 'g': 7,
 'f': 6,
 'a': 0,
 'c': 2,
 'b': 1,
 'm': 15,
 'l': 14,
 'o': 17,
 'n': 16,
 'i': 11,
 'h': 9,
 'k': 13,
 'j': 12}

```

Bunun için birkaç farklı yöntemden yararlanabiliriz. Örneğin:

```python
>>> sözlük = {}
>>> for i in harfler:
... sözlük[i] = harfler.index(i)

```

veya:

```python
>>> sözlük = {}
>>> for i in range(len(harfler)):
... sözlük[harfler[i]] = i

```

İşte bu işlemleri sözlük üreteçlerini kullanarak çok daha hızlı ve pratik bir
şekilde halledebiliriz. Dikkatlice bakın:

```python
>>> sözlük = {i: harfler.index(i) for i in harfler}

```

Bir örnek daha verelim. Diyelim ki elinizde şöyle bir isim listesi var:

```python
isimler = ["ahmet", "mehmet", "fırat", "zeynep", "selma", "abdullah", "cem"]

```

Amacınız, bu isimleri ve her bir ismin kaç harften oluştuğunu gösteren bir
sözlük elde etmek. Yani nihai olarak şöyle bir şey olsun istiyorsunuz elinizde:

```python
{'zeynep': 6,
 'cem': 3,
 'abdullah': 8,
 'ahmet': 5,
 'mehmet': 6,
 'fırat': 5,
 'selma': 5}

```

İşte bu görev için de sözlük üreteçlerinden yararlanabilirsiniz:

```python
>>> isimler = ["ahmet", "mehmet", "fırat", "zeynep", "selma", "abdullah", "cem"]
>>> sözlük = {i: len(i) for i in isimler}
>>> sözlük

{'zeynep': 6, 'cem': 3, 'abdullah': 8, 'ahmet': 5, 'mehmet': 6, 'fırat': 5, 'selma': 5}

```

Bildiğiniz gibi sözlükler, her biri birbirinden:işareti ile ayrılan birtakım
anahtar-değer çiftlerinden oluşuyor. İşte yukarıdaki sözlük üreteci yapısında
biz:işaretinin sol tarafınaisimleradlı listedeki her bir öğeyi; sağ
tarafına da bu öğelerin uzunluklarını bir çırpıda ekliyoruz.

## Sözlüklerin Metotları

Tıpkı öteki veri tiplerinde olduğu gibi, sözlüklerin de birtakım metotları
bulunur. Bu bölümde sözlüklerin şu metotlarını inceleyeceğiz:
1. keys()
1. values()
1. items()
1. get()
1. clear()
1. copy()
1. fromkeys()
1. pop()
1. popitem()
1. setdefault()
1. update()

keys()

values()

items()

get()

clear()

copy()

fromkeys()

pop()

popitem()

setdefault()

update()

İlk olarakkeys()metoduyla başlayalım.

### keys()

Sözlükleri tarif ederken, sözlüklerin anahtar-değer çiftlerinden oluşan bir veri
tipi olduğunu söylemiştik. Bir sözlüğü normal yollardan ekrana yazdırırsanız
size hem anahtarları hem de bunlara karşılık gelen değerleri verecektir. Ama
eğer bir sözlüğün sadece anahtarlarını almak istersenizkeys()metodundan
yararlanabilirsiniz:

```python
>>> sözlük = {"a": 0,
... "b": 1,
... "c": 2,
... "d": 3}
>>> print(sözlük.keys())

dict_keys(['b', 'c', 'a', 'd'])

```

Gördüğünüz gibi,sözlük.keys()komutu bize birdict_keysnesnesi veriyor.
Bu nesneyi programınızda kullanabilmek için isterseniz, bunu listeye, demete
veya karakter dizisine dönüştürebilirsiniz:

```python
>>> liste = list(sözlük.keys())
>>> liste

['b', 'c', 'a', 'd']

>>> demet = tuple(sözlük.keys())
>>> demet

('b', 'c', 'a', 'd')

>>> kardiz = "".join(sözlük.keys())
>>> kardiz

'bcad'

```

Son örnekte sözlük anahtarlarını karakter dizisine dönüştürmek içinstr()fonksiyonunu değil, karakter dizilerininjoin()adlı metodunu kullandığımıza
dikkat edin. Çünkütuple()velist()fonksiyonlarının aksinestr()fonksiyonu, sözlükteki anahtarların nasıl bir ölçüte göre karakter dizisine
çevrileceğine dair bir kural içermez. Zira siz bu sözlük anahtarlarını pek çok
farklı şekilde karakter dizisine çevirebilirsiniz. Örneğin öğeleri karakter
dizisi içine yerleştirirken öğelerin arasına virgül koymak isteyebilirsiniz:

```python
>>> kardiz = ', '.join(sözlük.keys())
>>> kardiz

'b, c, a, d'

```

Eğer sözlük anahtarlarınıstr()fonksiyonu yardımıyla karakter dizisine
dönüştürmeye kalkışırsanız beklemediğiniz bir çıktı alırsınız.

### values()

keys()metodu bir sözlüğün anahtarlarını veriyor. Bir sözlüğün değerlerini
isevalues()metodu verir:

```python
>>> sözlük
{'b': 1, 'c': 2, 'a': 0, 'd': 3}

>>> print(sözlük.values())

dict_values([1, 2, 0, 3])

```

Gördüğünüz gibi, bu metottan birdict_valuesnesnesi alıyoruz. Tıpkıkeys()metodunda olduğu gibi,values()metodunda da bu çıktıyı başka
veri tiplerine dönüştürme imkanına sahibiz:

```python
>>> liste = list(sözlük.values())
>>> liste

[1, 2, 0, 3]

>>> demet = tuple(sözlük.values())
>>> demet

(1, 2, 0, 3)

```

Yalnız bu verileri karakter dizisine dönüştürmeye çalıştığınızda ufak bir
problemle karşılaşacaksınız:

```python
>>> kardiz = "".join(sözlük.values())

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: sequence item 0: expected str instance, int found

```

Bunun sebebi, sözlükteki değerlerininttipinde olmasıdır. Bildiğiniz gibi,
sadece aynı tip verileri birbiriyle birleştirebiliriz. Eğer birleştirmek
istediğimiz veriler birbirinden farklı tipte ise, bunları birleştirmeden önce
bir dönüştürme işlemi yapmamız gerekir:

```python
>>> kardiz = "".join([str(i) for i in sözlük.values()])
>>> kardiz

'1203'

```

Gördüğünüz gibi, sözlükteki değerlerin her birini, tek bir liste üreteci içinde
karakter dizisine dönüştürdük ve ortaya çıkan listeyi karakter dizilerininjoin()metodu yardımıyla, öğelerin arasında hiçbir boşluk bırakmadankardizadlı bir karakter dizisi içine yerleştirdik. Elbette eğer isteseydik bu
öğelerin her birinin arasına bir virgül de koyabilirdik:

```python
>>> kardiz = ", ".join([str(i) for i in sözlük.values()])
>>> kardiz

'1, 2, 0, 3'

```

### items()

Bu metot, bir sözlüğün hem anahtarlarını hem de değerlerini aynı anda almamızı
sağlar:

```python
>>> sözlük.items()

dict_items([('a', 0), ('c', 2), ('b', 1)])

```

Gördüğünüz gibi, tek bir liste içinde iki öğeli demetler halinde hem anahtarları
hem de değerleri görebiliyoruz. Bu metot sıklıklafordöngüleri ile birlikte
kullanılarak bir sözlüğün anahtar ve değerlerinin manipüle edilebilmesini
sağlar:

```python
>>> for anahtar, değer in sözlük.items():
... print("{} = {}".format(anahtar, değer))
...
a = 0
c = 2
b = 1

```

### get()

Bu metot sözlüklerin en kullanışlı metotlarından biridir. Bu metot pek çok
durumda işinizi bir hayli kolaylaştırır.

Diyelim ki şöyle bir program yazdık:

```python
#!/usr/bin/env python3.0

ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"}

sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:")

print(ing_sözlük[sorgu])

```

Bu programı çalıştırdığımızda eğer kullanıcı “ing_sözlük” adıyla belirttiğimiz
sözlük içinde bulunan kelimelerden birini yazarsa, o kelimenin karşılığını
alacaktır. Diyelim ki kullanıcımız soruya “dil” diye cevap verdi. Bu durumda
ekrana “dil” kelimesinin sözlükteki karşılığı olan “language” yazdırılacaktır.
Peki ya kullanıcı sözlükte tanımlı olmayan bir kelime yazarsa ne olacak? Öyle
bir durumda programımız hata verecektir. Programımız için doğru yol, hata
vermektense, kullanıcıyı kelimenin sözlükte olmadığı konusunda
bilgilendirmektir. Bunu klasik bir yaklaşımla şu şekilde yapabiliriz:

```python
ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"}

sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:")

if sorgu not in ing_sözlük:
 print("Bu kelime veritabanımızda yoktur!")

else:
 print(ing_sözlük[sorgu])

```

Ama açıkçası bu pek verimli bir yaklaşım sayılmaz. Yukarıdaki yöntem yerine
sözlükleringet()metodundan faydalanabiliriz. Bakalım bunu nasıl
yapıyoruz:

```python
ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"}

sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:")

print(ing_sözlük.get(sorgu, "Bu kelime veritabanımızda yoktur!"))

```

Gördüğünüz gibi, burada çok basit bir metot yardımıyla bütün dertlerimizi
hallettik. Sözlükleringet()adlı metodu, parantez içinde iki adet argüman
alır. Birinci argüman sorgulamak istediğimiz sözlük öğesidir. İkinci argüman ise
bu öğenin sözlükte bulunmadığı durumda kullanıcıya hangi mesajın gösterileceğini
belirtir. Buna göre, yukarıda yaptığımız şey, önce “sorgu” değişkenini sözlükte
aramak, eğer bu öğe sözlükte bulunamıyorsa da kullanıcıya, “Bu kelime
veritabanımızda yoktur!” cümlesini göstermekten ibarettir…

Gelin isterseniz bununla ilgili bir örnek daha yapalım.

Diyelim ki bir havadurumu programı yazmak istiyoruz. Bu programda kullanıcı bir
şehir adı girecek. Program da girilen şehre ait havadurumu bilgilerini ekrana
yazdıracak. Bu programı klasik yöntemle şu şekilde yazabiliriz:

```python
#!/usr/bin/env python3

soru = input("Şehrinizin adını tamamı küçük harf olacak şekilde yazın:")

if soru == "istanbul":
 print("gök gürültülü ve sağanak yağışlı")

elif soru == "ankara":
 print("açık ve güneşli")

elif soru == "izmir":
 print("bulutlu")

else:
 print("Bu şehre ilişkin havadurumu bilgisi bulunmamaktadır.")

```

Yukarıdaki, gayet geçerli bir yöntemdir. Ama biz istersek bu kodları “get”
metodu yardımıyla çok daha verimli ve sade bir hale getirebiliriz:

```python
#!/usr/bin/env python3

soru = input("Şehrinizin adını tamamı küçük harf olacak şekilde yazın:")

cevap = {"istanbul": "gök gürültülü ve sağanak yağışlı",
 "ankara": "açık ve güneşli", "izmir": "bulutlu"}

print(cevap.get(soru, "Bu şehre ilişkin havadurumu bilgisi bulunmamaktadır."))

```

### clear()

Bu kelime İngilizce’de “temizlemek” anlamına gelir. Görevi sözlükteki öğeleri
temizlemektir. Yani içi dolu bir sözlüğü bu metot yardımıyla tamamen
boşaltabiliriz:

```python
 >>> lig = {"şampiyon": "Adana Demirspor", "ikinci": "Mersin İdman Yurdu",
... "üçüncü": "Adana Gençlerbirliği"}

```

İsterseniz sözlüğümüzü boşaltmadan önce bu sözlükle biraz çalışalım:

Sözlüğümüzün öğelerine şöyle ulaşıyoruz:

```python
 >>> lig

 {'şampiyon': 'Adana Demirspor', 'ikinci': 'Mersin İdman Yurdu',
'üçüncü': 'Adana Gençlerbirliği'}

```

Eğer bu sözlüğün öğelerine tek tek erişmek istersek şöyle yapıyoruz:

```python
>>> lig["şampiyon"]

'Adana Demirspor'

>>> lig["üçüncü"]

'Adana Gençlerbirliği'

```

Şimdi geldi bu sözlüğün bütün öğelerini silmeye:

```python
>>> lig.clear()

```

Şimdi sözlüğümüzün durumunu tekrar kontrol edelim:

```python
>>> lig

{}

```

Gördüğünüz gibi artık “lig” adlı sözlüğümüz bomboş.clear()metodunu
kullanarak bu sözlüğün bütün öğelerini sildik. Ama tabii ki bu şekilde sözlüğü
silmiş olmadık. Boş da olsa bellekte hâlâ “lig” adlı bir sözlük duruyor. Eğer
siz “lig”i ortadan kaldırmak isterseniz “del” adlı bir parçacıktan yararlanmanız
gerekir:

```python
>>> del lig

```

Kontrol edelim:

```python
>>> lig

NameError: name 'lig' is not defined

```

Gördüğünüz gibi artık “lig” diye bir şey yok… Bu sözlüğü bellekten tamamen
kaldırdık.

clear()adlı metodun ne olduğunu ve ne işe yaradığını gördüğümüze göre başka
bir metoda geçebiliriz.

### copy()

Diyelim ki elimizde şöyle bir sözlük var:

```python
>>> hava_durumu = {"İstanbul": "yağmurlu", "Adana": "güneşli", ... "İzmir": "bulutlu"}

```

Biz bu sözlüğü kopyalamak istiyoruz. Hemen şöyle bir şey deneyelim:

```python
>>> yedek_hava_durumu = hava_durumu

```

Artık elimizde aynı sözlükten iki tane var:

```python
>>> hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'İzmir': 'bulutlu'}

>>> yedek_hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'İzmir': 'bulutlu'}

```

Şimdi hava_durumu adlı sözlüğe bir öğe ekleyelim:

```python
>>> hava_durumu["Mersin"] = "sisli"

>>> hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'Mersin': 'sisli', 'İzmir': 'bulutlu'}

```

Şimdi bir de yedek_hava_durumu adlı sözlüğün durumuna bakalım:

```python
>>> yedek_hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'Mersin': 'sisli', 'İzmir': 'bulutlu'}

```

Gördüğünüz gibi, hava_durumu adlı sözlüğe yaptığımız ekleme yedek_hava_durumu
adlı sözlüğü de etkiledi. Hatırlarsanız buna benzer bir durumla daha önce
listeleri anlatırken de karşılaşmıştık. Çünkü varolan bir sözlüğü veya listeyi
başka bir değişkene atadığımızda aslında yaptığımız şey bir kopyalama işleminden
ziyade bellekteki aynı nesneye gönderme yapan iki farklı isim belirlemekten
ibaret. Yani sözlüğümüzü bellekteki bir nesne olarak düşünürsek, bu nesneye
atıfta bulunan, “hava_durumu” ve “yedek_hava_durumu” adlı iki farklı isim
belirlemiş oluyoruz. Eğer istediğimiz şey bellekteki nesneden iki adet
oluşturmak ve bu iki farklı nesneyi iki farklı isimle adlandırmak ise yukarıdaki
yöntemi kullanmak istemediğiniz sonuçlar doğurabilir. Yani amacınız bir sözlüğü
yedekleyip orijinal sözlüğü korumaksa ve yukarıdaki yöntemi kullandıysanız, hiç
farkında olmadan orijinal sözlüğü de değiştirebilirsiniz. İşte böyle durumlarda
imdadımıza sözlüklerin “copy” metodu yetişecek. Bu metodu kullanarak varolan bir
sözlüğü gerçek anlamda kopyalayabilir, yani yedekleyebiliriz…

```python
>>> hava_durumu = {"İstanbul": "yağmurlu", "Adana": "güneşli", ... "İzmir": "bulutlu"}

```

Şimdi bu sözlüğü yedekliyoruz. Yani kopyalıyoruz:

```python
>>> yedek_hava_durumu = hava_durumu.copy()

```

Bakalım hava_durumu adlı sözlüğe ekleme yapınca yedek_hava_durumu adlı sözlüğün
durumu ne oluyor?

```python
>>> hava_durumu["Mersin"] = "sisli"

>>> hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'Mersin': 'sisli', 'İzmir':
'bulutlu'}

```

yedek_hava_durumu adlı sözlüğe bakalım:

```python
>>> yedek_hava_durumu

{'İstanbul': 'yağmurlu', 'Adana': 'güneşli', 'İzmir': 'bulutlu'}

```

Gördüğünüz gibi bu defa sözlüklerin birinde yapılan değişiklik öbürünü
etkilemedi… copy metodu sağolsun!…

### fromkeys()

fromkeys()metodu öteki metotlardan biraz farklıdır. Bu metot mevcut sözlük
üzerinde işlem yapmaz.fromkeys()’in görevi yeni bir sözlük oluşturmaktır.
Bu metot yeni bir sözlük oluştururken listeler veya demetlerden yararlanır.
Şöyle ki:

```python
>>> elemanlar = "Ahmet", "Mehmet", "Can"

>>> adresler = dict.fromkeys(elemanlar, "Kadıköy")

>>> adresler

{'Ahmet': 'Kadıköy', 'Mehmet': 'Kadıköy', 'Can': 'Kadıköy'}

```

Gördüğünüz gibi öncelikle “elemanlar” adlı bir demet tanımladık. Daha sonra da
“adresler” adlı bir sözlük tanımlayarak,fromkeys()metodu yardımıyla
anahtar olarak “elemanlar” demetindeki öğelerden oluşan, değer olarak ise
“Kadıköy”ü içeren bir sözlük meydana getirdik.

En başta tanımladığımız “elemanlar” demeti liste de olabilirdi. Hatta tek başına
bir karakter dizisi dahi yazabilirdik oraya…

### pop()

Bu metodu listelerden hatırlıyoruz. Bu metot listelerle birlikte
kullanıldığında, listenin en son öğesini silip, silinen öğeyi de ekrana
basıyordu. Eğer bu metodu bir sıra numarası ile birlikte kullanırsak, listede o
sıra numarasına karşılık gelen öğe siliniyor ve silinen bu öğe ekrana
basılıyordu. Bu metodun sözlüklerdeki kullanımı da az çok buna benzer. Ama
burada farklı olarak,popmetodunu argümansız bir şekilde kullanamıyoruz.
Yanipopmetodunun parantezi içinde mutlaka bir sözlük öğesi belirtmeliyiz:

```python
>>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye"),
... "içecekler": ("su", "kola", "ayran")}

>>> sepet.pop("meyveler")

```

Bu komut, sözlükteki “meyveler” anahtarını silecek ve sildiği bu öğenin değerini
ekrana basacaktır. Eğer silmeye çalıştığımız anahtar sözlükte yoksa Python bize
bir hata mesajı gösterecektir:

```python
>>> sepet.pop("tatlılar")

KeyError: 'tatlılar'

```

Bir program yazarken böyle bir durumla karşılaşmak istemeyiz çoğu zaman. Yani
bir sözlük içinde arama yaparken, aranan öğenin sözlükte bulunmadığı bir durumda
kullanıcıya mekanik ve anlamsız bir hata göstermek yerine, daha anlaşılır bir
mesaj iletmeyi tercih edebiliriz. Hatırlarsanız sözlükleringet()metodunu
kullanarak benzer bir şey yapabiliyorduk. Şu anda incelemekte olduğumuzpop()metodu da bize böyle bir imkan verir. Bakalım:

```python
>>> sepet.pop("tatlılar", "Silinecek öğe yok!")

```

Böylelikle sözlükte bulunmayan bir öğeyi silmeye çalıştığımızda Python bize bir
hata mesajı göstermek yerine, “Silinecek öğe yok!” şeklinde daha anlamlı bir
mesaj verecektir…

### popitem()

popitem()metodu da bir önceki bölümde öğrendiğimizpop()metoduna
benzer. Bu iki metodun görevleri hemen hemen aynıdır. Ancakpop()metodu
parantez içinde bir parametre alırken,popitem()metodunun parantezi boş,
yani parametresiz olarak kullanılır. Bu metot bir sözlükten son eklenen öğeyi
silmek için kullanılır(Python 3.7’den önceki sürümlerde bunun yerine rastgele
bir öğe kaldırılır)…

```python
>>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye")}

>>> sepet.popitem()

```

Eğer sözlük boşsa bu metot bize KeyError hata mesajı gösterir.

### setdefault()

Bu metot epey enteresan, ama bir o kadar da yararlı bir araçtır… Bu metodun
ne işe yaradığını doğrudan bir örnek üzerinde görelim:

```python
>>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye")}

>>> sepet.setdefault("içecekler", ("su", "kola"))

```

Bu komut yardımıyla sözlüğümüz içinde “içecekler” adlı bir anahtar oluşturduk.
Bu anahtarın değeri ise(“su”, “kola”)oldu… Bir de şuna bakalım:

```python
>>> sepet.setdefault("meyveler", ("erik", "çilek"))

('elma', 'armut')

```

Gördüğünüz gibi, sözlükte zaten “meyveler” adlı bir anahtar bulunduğu için,
Python aynı adı taşıyan ama değerleri farklı olan yeni bir “meyveler” anahtarı
oluşturmadı. Demek ki bu metot yardımıyla bir sözlük içinde arama yapabiliyor,
eğer aradığımız anahtar sözlükte yoksa,setdefault()metodu içinde
belirttiğimiz özellikleri taşıyan yeni bir anahtar-değer çifti
oluşturabiliyoruz.

### update()

İnceleyeceğimiz son metotupdate()metodu… Bu metot yardımıyla
oluşturduğumuz sözlükleri yeni verilerle güncelleyeceğiz. Diyelim ki elimizde
şöyle bir sözlük var:

```python
>>> stok = {"elma": 5, "armut": 10, "peynir": 6, "sosis": 15}

```

Stoğumuzda 5 adet elma, 10 adet armut, 6 kutu peynir, 15 adet de sosis var.
Diyelim ki daha sonraki zamanlarda bu stoğa mal giriş-çıkışı oldu ve stoğun son
hali şöyle:

```python
>>> yeni_stok = {"elma": 3, "armut": 20, "peynir": 8, "sosis": 4, "sucuk": 6}

```

Yapmamız gereken şey, stoğumuzu yeni bilgilere göre güncellemek olacaktır. İşte
bu işlemiupdate()metodu ile yapabiliriz:

```python
>>> stok.update(yeni_stok)

>>> print(stok)

{'peynir': 8, 'elma': 3, 'sucuk': 6, 'sosis': 4, 'armut': 20}

```

Böylelikle malların son miktarlarına göre stok bilgilerimizi güncellemiş
olduk…

## Kümeler ve Dondurulmuş Kümeler

Bu bölümde Python’daki iki veri tipini daha inceleyeceğiz. İnceleyeceğimiz veri
tiplerinin adı küme ve dondurulmuş küme.

Özellikle kümeleri öğrendiğimizde, bu veri tipinin kendine has birtakım
özellikleri sayesinde bunların kimi zaman hiç tahmin bile edemeyeceğimiz
yerlerde işimize yaradığını göreceğiz. Normalde uzun uzun kod yazmayı gerektiren
durumlarda kümeleri kullanmak, bir-iki satırla işlerimizi halletmemizi
sağlayabilir.

Bu bölümde kümeler dışında, bir de dondurulmuş kümelerden söz edeceğiz. Bu iki
veri tipi birbiriyle ilişkilidir. O yüzden bu iki veri tipini tek bölümde ele
alacağız.

İsterseniz anlatmaya önce kümelerle başlayalım.

### Kümeler

Tıpkı listeler, demetler, karakter dizileri, sayılar ve dosyalar gibi kümeler de
Python’daki veri tiplerinden biridir. Adından da az çok tahmin edebileceğiniz
gibi kümeler, matematikten bildiğimiz “küme” kavramıyla sıkı sıkıya
bağlantılıdır. Bu veri tipi, matematikteki kümelerin sahip olduğu bütün
özellikleri taşır. Yani matematikteki kümelerden bildiğimiz kesişim, birleşim ve
fark gibi özellikler Python’daki kümeler için de geçerlidir.

#### Küme Oluşturmak

Kümelerin bize sunduklarından faydalanabilmek için elbette öncelikle bir küme
oluşturmamız gerekiyor. Küme oluşturmak çok kolay bir işlemdir. Örneğin boş bir
kümeyi şöyle oluşturuyoruz:

```python
>>> boş_küme = set()

```

Listeler, demetler ve sözlüklerin aksine kümelerin ayırt edici bir işareti
yoktur. Küme oluşturmak için set() adlı özel bir fonksiyondan yararlanıyoruz.

Yukarıdaki boş veri tipinin bir küme olduğunu nasıl teyit edeceğinizi
biliyorsunuz:

```python
>>> type(boş_küme)

<class 'set'>

```

Gördüğünüz gibi, Python programlama dilinde kümelersetifadesiyle
gösteriliyor.

Yukarıda boş bir küme oluşturduk. İçinde öğe de barındıran kümeleri ise şu
şekilde oluşturuyoruz:

```python
>>> küme = set(["elma", "armut", "kebap"])

```

Böylelikle, içinde öğe barındıran ilk kümemizi başarıyla oluşturduk. Dikkat
ederseniz, küme oluştururken listelerden faydalandık. Gördüğünüz gibiset()fonksiyonu içindeki öğeler bir liste içinde yer alıyor. Dolayısıyla yukarıdaki
tanımlamayı şöyle de yapabiliriz:

```python
>>> liste = ["elma", "armut", "kebap"]
>>> küme = set(liste)

```

Bu daha temiz bir görüntü oldu. Elbette küme tanımlamak için mutlaka liste
kullanmak zorunda değiliz. İstersek demetleri de küme haline getirebiliriz:

```python
>>> demet = ("elma", "armut", "kebap")
>>> küme = set(demet)

```

Hatta ve hatta karakter dizilerinden dahi küme yapabiliriz:

```python
>>> kardiz = "Python Programlama Dili için Türkçe Kaynak"
>>> küme = set(kardiz)

```

Kullandığımız karakter dizisinin böyle uzun olmasına da gerek yok. Tek
karakterlik dizilerden bile küme oluşturabiliriz:

```python
>>> kardiz = "a"
>>> küme = set(kardiz)

```

Ama sayılardan küme oluşturamayız:

```python
>>> n = 10
>>> küme = set(n)

TypeError: 'int' object is not iterable

```

Peki sözlükleri kullanarak küme oluşturabilir miyiz? Elbette, neden olmasın?

```python
>>> bilgi = {"işletim sistemi": "GNU", "sistem çekirdeği": "Linux",
... "dağıtım": "Ubuntu GNU/Linux"}

>>> küme = set(bilgi)

```

Küme oluşturmanın son bir yönteminden daha söz edelim. En başta söylediğimiz
gibi, listeler, demetler, sözlükler ve karakter dizilerinin aksine kümelerin[
],( ),{ },‘ ‘gibi ayırt edici bir işareti yoktur. Ama eğer istersek
sözlükleri oluşturmak için kullandığımız özel işaretleri küme oluşturmak için de
kullanabiliriz. Dikkatlice bakın:

```python
>>> küme = {'Python', 'C++', 'Ruby', 'PHP'}

```

Gördüğünüz gibi, aslında sözlüklerin ayırt edici işareti olan süslü parantezleri
kullanarak ve öğeleri birbirinden virgülle ayırarak da küme adlı veri tipini
elde edebiliyoruz. Teyit edelim bunu:

```python
>>> type(küme)

<class 'set'>

```

Ancak bu yapıyı kullanarak boş bir küme oluşturamazsınız:

```python
>>> küme = {}

```

Bu şekilde oluşturduğunuz şey bir küme değil, sözlük olacaktır:

```python
>>> type(küme)

<class 'dict'>

```

Boş bir küme oluşturmak içinset()fonksiyonunu kullanmanız gerektiğini
biliyorsunuz:

```python
>>> küme = set(küme)
>>> type(küme)

<class 'set'>

```

Böylece kümeleri nasıl oluşturacağımızı öğrendik. Eğer oluşturduğunuz kümeyi
ekrana yazdırmak isterseniz, ne yapacağınızı biliyorsunuz. Tanımladığınızkümedeğişkenini kullanmanız yeterli olacaktır:

```python
>>> küme

{'işletim sistemi', 'sistem çekirdeği', 'dağıtım'}

```

Bu arada, bir sözlüğü kümeye çevirdiğinizde, elbette sözlüğün yalnızca
anahtarları kümeye eklenecektir. Sözlüğün değerleri ise böyle bir işlemin
sonucunda ortadan kaybolur.

Eğer bir sözlüğü kümeye çevirirken hem anahtarları hem de değerleri korumak
gibi bir niyetiniz varsa şöyle bir şey yazabilirsiniz:

Sözlüğümüz şu:

```python
>>> bilgi = {"işletim sistemi": "GNU", "sistem çekirdeği": "Linux",
... "dağıtım": "Ubuntu GNU/Linux"}

```

Bu sözlükteki anahtar-değer çiftlerini bir küme içine, çift öğeli demetler
olarak yerleştirebiliriz:

```python
>>> liste = [(anahtar, değer) for anahtar, değer in bilgi.items()]
>>> küme = set(liste)

```

Gördüğünüz gibi, liste üreteçlerini kullanarak önce bir liste oluşturuyoruz. Bu
liste her bir anahtarı ve değeri tek tek bir demet içine yerleştiriyor. Daha
sonra da bu listeyiset()fonksiyonuna göndererek kümemizi oluşturuyoruz.

#### Kümelerin Yapısı

Bir önceki başlık altında kümelerin nasıl tanımlanacağını inceledik. Gelin şimdi
de biraz kümelerin yapısından bahsedelim.

Örneğin şöyle bir küme tanımlayalım:

```python
>>> kardiz = "Python Programlama Dili"
>>> küme = set(kardiz)
>>> print(küme)

{'g', 'D', 'a', ' ', 'o', 'n', 'm', 'l', 'i', 'h', 't', 'r', 'P', 'y'}

```

Burada bir şey dikkatinizi çekmiş olmalı. Bir öğeyi küme olarak tanımlayıp
ekrana yazdırdığımızda elde ettiğimiz çıktı, o öğe içindeki her bir alt öğeyi
tek bir kez içeriyor. Yani mesela “Python Programlama Dili” içinde iki adet “P”
karakteri var, ama çıktıda bu iki “P” karakterinin yalnızca biri görünüyor.
Buradan anlıyoruz ki, kümeler aynı öğeyi birden fazla tekrar etmez. Bu çok
önemli bir özelliktir ve pek çok yerde işimize yarar. Aynı durum karakter dizisi
dışında kalan öteki veri tipleri için de geçerlidir. Yani mesela eğer bir
listeyi küme haline getiriyorsak, o listedeki öğeler küme içinde yalnızca bir
kez geçecektir. Listede aynı öğeden iki-üç tane bulunsa bile, kümemiz bu öğeleri
teke indirecektir.

```python
>>> liste = ["elma", "armut", "elma", "kebap", "şeker", "armut",
... "çilek", "ağaç", "şeker", "kebap", "şeker"]

>>> for i in set(liste):
... print(i)
...
ağaç
elma
şeker
kebap
çilek
armut

```

Gördüğünüz gibi, liste içinde birden fazla bulunan öğeler, Python’daki kümeler
yardımıyla teke indirilebiliyor.

Öğrendiğimiz bu bilgi sayesinde, daha önce gördüğümüzcount()metodunu da
kullanarak, şöyle bir kod yazabiliriz:

```python
>>> liste = ["elma", "armut", "elma", "kiraz",
... "çilek", "kiraz", "elma", "kebap"]

>>> for i in set(liste):
... print("{} listede {} kez geçiyor!".format(i, liste.count(i)))

kebap listede 1 kez geçiyor!
elma listede 3 kez geçiyor!
kiraz listede 2 kez geçiyor!
armut listede 1 kez geçiyor!
çilek listede 1 kez geçiyor!

```

Buradaset(liste)ifadesini kullanarak, liste öğelerini eşşiz ve benzersiz
bir hale getirdik.

Kümelerin önemli bir özelliği de, tıpkı sözlükler gibi, herhangi bir şekilde
‘öğe sırası’ kavramına sahip olmamasıdır.

Dikkatlice bakın:

```python
>>> arayüz_takımları = {'Tkinter', 'PyQT', 'PyGobject'}
>>> arayüz_takımları

{'PyGobject', 'PyQT', 'Tkinter'}

```

Sözlüklerde karşılaştığımız durumun aynısının kümeler için de geçerli olduğuna
dikkatinizi çekmek isterim. Gördüğünüz gibi,arayüz_takımlarıadlı kümenin
öğeleri, öğe tanımlama sırasını çıktıda korumuyor. Biz ‘Tkinter’ öğesini kümenin
ilk sırasına yerleştirmiştik, ama bu öğe çıktıda en sona gitti… Aynen
sözlüklerde olduğu gibi, kümelerde de öğelerin tanımlanma sırasına bel
bağlayarak herhangi bir işlem yapamazsınız. Bu durumun bir yansıması olarak,
küme öğelerine sıralarına göre de erişemezsiniz:

```python
>>> arayüz_takımları[0]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'set' object does not support indexing

```

Tıpkı hata mesajında da söylendiği gibi, küme adlı veri tipi açısından öğe
sırası diye bir kavram yoktur…

Esasında tek bir küme pek bir işe yaramaz. Kümeler ancak birden fazla olduğunda
bunlarla yararlı işler yapabiliriz. Çünkü kümelerin en önemli özelliği, başka
kümelerle karşılaştırılabilme kabiliyetidir. Yani mesela kümelerin kesişimini,
birleşimini veya farkını bulabilmek için öncelikle elimizde birden fazla küme
olması gerekiyor. İşte biz de şimdi bu tür işlemleri nasıl yapacağımızı
öğreneceğiz. O halde hiç vakit kaybetmeden yolumuza devam edelim.

#### Küme Üreteçleri (Set Comprehensions)

Bildiğiniz gibi liste üreteçleri, liste oluşturmanın kısa ve temiz bir yoludur.
Aynı şekilde sözlük üreteçleri de sözlük oluşturmanın kısa ve temiz bir yoludur.

İşte liste üreteçlerini ve sözlük üreteçlerini kullanarak nasıl tek satırda ve
hızlı bir şekilde listeler ve sözlükler üretebiliyorsak, aynı şekilde küme
üreteçlerini kullanarak tek satırda ve hızlı bir şekilde kümeler de
üretebiliriz.

Örneğin elimizde şöyle bir liste olduğunu düşünelim:

```python
import random

liste = [random.randint(0, 10000) for i in range(1000)]

```

Bu arada, buradakirandomadlı modüle şimdilik takılmayın. Birkaç bölüm sonra
bu modülü inceleyeceğiz. Biz şimdilikrandom’un da tıpkısysveosgibi
bir modül olduğunu ve rastgele sayılar üretmemizi sağladığını bilelim yeter.
Yukarıdaki kodlarda da bu modül0ile10000arasında rastgele1000adet
sayı üretmemizi sağladı.

Şimdi amacımız bu liste içinde yer alan sayılardan, değeri100’den küçük
olanları bulmak.

Bunun için şu kodları kullanabiliriz:

```python
import random

liste = [random.randint(0, 10000) for i in range(1000)]

yüzden_küçük_sayılar = [i for i in liste if i < 100]
print(yüzden_küçük_sayılar)

```

Ancak ortaya çıkan listede aynı sayılardan birkaç tane olabilir. İşte eğer
birbirinin aynı olmayan sayılardan oluşmuş bir listeyi hızlı ve pratik bir
şekilde elde etmek istiyorsanız küme üreteçlerini kullanabilirsiniz:

```python
import random

liste = [random.randint(0, 10000) for i in range(1000)]

küme = {i for i in liste if i < 100}
print(küme)

```

Gördüğünüz gibi, küme üreteçlerinin sözdizimi, liste ve sözlük üreteçlerinin
sözdizimine çok benziyor.

#### Kümelerin Metotları

Daha önceki veri tiplerinde olduğu gibi, kümelerin de metotları vardır. Artık
biz bir veri tipinin metotlarını nasıl listeleyeceğimizi çok iyi biliyoruz.
Nasıl liste içinlist(); demet içintuple(); sözlük için dedict()fonksiyonlarını kullanıyorsak, kümeler için deset()adlı fonksiyondan
yararlanacağız:

```python
>>> dir(set)

['__and__', '__class__', '__contains__', '__delattr__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
'__hash__', '__iand__', '__init__', '__ior__', '__isub__', '__iter__',
'__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__',
'__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__',
'__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__',
'__str__', '__sub__', '__subclasshook__', '__xor__', 'add',
'clear','copy', 'difference', 'difference_update', 'discard',
'intersection', 'intersection_update', 'isdisjoint', 'issubset',
'issuperset', 'pop', 'remove', 'symmetric_difference',
'symmetric_difference_update', 'union', 'update']

```

Hemen işimize yarayacak metotları alalım:

```python
>>> for i in dir(set):
... if "__" not in i:
... print(i)
...
add
clear
copy
difference
difference_update
discard
intersection
intersection_update
isdisjoint
issubset
issuperset
pop
remove
symmetric_difference
symmetric_difference_update
union
update

```

Gördüğünüz gibi kümelerin epey metodu var. Bu aradaif"__"notinisatırında “_” yerine “__” kullandığımıza dikkat edin. Neden? Çünkü eğer sadece
“_” kullanırsaksymmetric_differencevesymmetric_difference_updatemetotları çıktımızda yer almayacaktır.

Unutmadan söyleyelim: Kümeler de, tıpkı listeler ve sözlükler gibi,
değiştirilebilir bir veri tipidir.

##### clear()

Kümelerle ilgili olarak inceleyeceğimiz ilk metotclear(). Bu metodu daha önce
sözlükleri çalışırken de görmüştük. Sözlüklerde bu metodun görevi sözlüğün içini
boşaltmak idi. Burada da aynı vazifeyi görür:

```python
>>> km = set("adana")
>>> for i in km:
... print(i)
...
a
d
n

>>> km.clear()
>>> km
set()

```

Burada önce “km” adlı bir küme oluşturduk. Daha sonra daclear()metodunu
kullanarak bu kümenin bütün öğelerini sildik. Artık elimizde boş bir küme var.

##### copy()

Listeler ve sözlükleri incelerkencopy()adlı bir metot öğrenmiştik. Bu
metot aynı zamanda kümelerle birlikte de kullanılabilir. Üstelik işlevi de
aynıdır:

```python
>>> km = set("kahramanmaraş")
>>> yedek = km.copy()
>>> yedek

{'a', 'r', 'h', 'k', 'm', 'ş', 'n'}

>>> km

{'a', 'h', 'k', 'm', 'n', 'r', 'ş'}

```

Burada bir şey dikkatinizi çekmiş olmalı. “km” adlı kümeyi “yedek” adıyla
kopyaladık, ama bu iki kümenin çıktılarına baktığımız zaman öğe sıralamasının
birbirinden farklı olduğunu görüyoruz. Biliyorsunuz, tıpkı sözlüklerde olduğu
gibi, kümeler de sırasız veri tipleridir. Bu yüzden, elde ettiğimiz çıktıda
öğeler rastgele diziliyor. Dolayısıyla öğelere sıralarına göre erişemiyoruz.
Aynen sözlüklerde olduğu gibi…

##### add()

Kümelerden bahsederken, bunların değiştirilebilir bir veri tipi olduğunu
söylemiştik. Dolayısıyla kümeler, üzerlerinde değişiklik yapmamıza müsaade eden
metotlar da içerir. Örneğinadd()bu tür metotlardan biridir.Addkelimesi
Türkçe’de “eklemek” anlamına gelir. Adından da anlaşılacağı gibi, bu metot
yardımıyla kümelerimize yeni öğeler ilave edebileceğiz. Hemen bunun nasıl
kullanıldığına bakalım:

```python
>>> küme = set(["elma", "armut", "kebap"])
>>> küme.add("çilek")
>>> print(küme)

{'elma', 'armut', 'kebap', 'çilek'}

```

Gördüğünüz gibi,add()metodunu kullanarak, kümemizeçilekadlı yeni bir öğe
ekledik. Eğer kümede zaten varolan bir öğe eklemeye çalışırsak kümede herhangi
bir değişiklik olmayacaktır. Çünkü, daha önce de söylediğimiz gibi, kümeler her
bir öğeyi tek bir sayıda barındırır.

Eğer bir kümeye birden fazla öğeyi aynı anda eklemek istersenizfordöngüsünden yararlanabilirsiniz:

```python
>>> yeni = [1,2,3]
>>> for i in yeni:
... küme.add(i)
...

>>> küme

{1, 2, 3, 'elma', 'kebap', 'çilek', 'armut'}

```

Buradayeniadlı listeyi kümeyefordöngüsü ile ekledik. Ama bu işlemi
yapmanın başka bir yolu daha vardır. Bu işlem için Python’da ayrı bir metot
bulunur. Bu metodun adıupdate()metodudur. Sırası gelince bu metodu da
göreceğiz.

Bu arada, yeri gelmişken kümelerin önemli bir özelliğinden daha söz edelim. Bir
kümeye herhangi bir öğe ekleyebilmemiz için, o öğenin değiştirilemeyen
(immutable) bir veri tipi olması gerekiyor. Bildiğiniz gibi Python’daki şu
veri tipleri değiştirilemeyen veri tipleridir:
1. Demetler
1. Sayılar
1. Karakter Dizileri

Demetler

Sayılar

Karakter Dizileri

Şu veri tipleri ise değiştirilebilen veri tipleridir:
1. Listeler
1. Sözlükler
1. Kümeler

Listeler

Sözlükler

Kümeler

Dolayısıyla bir kümeye ancak şu veri tiplerini ekleyebiliriz:
1. Demetler
1. Sayılar
1. Karakter Dizileri

Demetler

Sayılar

Karakter Dizileri

Şu kodları dikkatlice inceleyin:

Önce boş bir küme oluşturalım:

```python
>>> küme = set()

```

Bu kümeye bir demet ekleyelim:

```python
>>> l = (1,2,3)
>>> küme.add(l)
>>> küme

{(1, 2, 3)}

```

Bir sayı ekleyelim:

```python
>>> l = 45
>>> küme.add(l)
>>> küme

{45, (1, 2, 3)}

```

Bir karakter dizisi ekleyelim:

```python
>>> l = 'Jacques Derrida'
>>> küme.add(l)
>>> küme

{'Jacques Derrida', 45, (1, 2, 3)}

```

Yukarıdakiler, değiştirilemeyen veri tipleri olduğu için kümelere eklenebilir.

Bir de şunlara bakalım:

Kümemize bir liste eklemeye çalışalım:

```python
>>> l = [1,2,3]
>>> küme.add(l)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'

```

Kümemize bir sözlük eklemeye çalışalım:

```python
>>> l = {"a": 1, "b": 2, "c": 3}
>>> küme.add(l)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'dict'

```

Kümemize bir küme eklemeye çalışalım:

```python
>>> l = {1, 2, 3}
>>> küme.add(l)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'set'

```

Gördüğünüz gibi, tıpkı sözlüklerde olduğu gibi, bir kümeye herhangi bir veri
ekleyebilmemiz için o verinin ‘değiştirilemeyen’ bir veri tipi olması gerekiyor.

##### difference()

Bu metot iki kümenin farkını almamızı sağlar. Örneğin:

```python
>>> k1 = set([1, 2, 3, 5])
>>> k2 = set([3, 4, 2, 10])

>>> k1.difference(k2)

{1, 5}

```

Demek ki k1’in k2’den farkı buymuş. Peki k2’nin k1’den farkını bulmak istersek
ne yapacağız?

```python
>>> k2.difference(k1)

{10, 4}

```

Gördüğünüz gibi, birinci kullanımda, k1’de bulunup k2’de bulunmayan öğeleri elde
ediyoruz. İkinci kullanımda ise bunun tam tersi. Yani ikinci kullanımda k2’de
bulunup k1’de bulunmayan öğeleri alıyoruz.

İsterseniz uzun uzundifference()metodunu kullanmak yerine sadece eksi (-)
işaretini kullanarak da aynı sonucu elde edebilirsiniz:

```python
>>> k1 - k2

```

…veya…

```python
>>> k2 - k1

```

Hayır, “madem eksi işaretini kullanabiliyoruz, o halde artı işaretini de
kullanabiliriz!” gibi bir fikir doğru değildir.

##### difference_update()

Bu metot,difference()metodundan elde edilen sonuca göre bir kümenin
güncellenmesini sağlar. Yani?
Hemen bir örnek verelim:

```python
>>> k1 = set([1, 2, 3])
>>> k2 = set([1, 3, 5])
>>> k1.difference_update(k2)
>>> print(k1)

{2}

>>> print(k2)

{1, 3, 5}

```

Gördüğünüz gibi, bu metot k1’in k2’den farkını aldı ve bu farkı kullanarak k1’i
yeniden oluşturdu. k1 ile k2 arasındaki tek fark2adlı öğe idi. Dolayısıyladifference_update()metodunu uyguladığımızda k1’in öğelerinin silinip
yerlerine2adlı öğenin geldiğini görüyoruz.

##### discard()

Bir önceki bölümde öğrendiğimizadd()metodu yardımıyla, önceden
oluşturduğumuz bir kümeye yeni öğeler ekleyebiliyorduk. Bu bölümde öğreneceğimizdiscard()metodu ise kümeden öğe silmemizi sağlayacak:

```python
>>> hayvanlar = set(["kedi", "köpek", "at", "kuş", "inek", "deve"])
>>> hayvanlar.discard("kedi")
>>> print(hayvanlar)

{'kuş', 'inek', 'deve', 'köpek', 'at'}

```

Eğer küme içinde bulunmayan bir öğe silmeye çalışırsak hiç bir şey olmaz. Yani
hata mesajı almayız:

```python
>>> hayvanlar.discard("yılan")

```

Burada etkileşimli kabuk sessizce bir alt satıra geçecektir. Bu metodun en
önemli özelliği budur. Yani olmayan bir öğeyi silmeye çalıştığımızda hata
vermemesi.

##### remove()

Bu metot da bir önceki bölümde gördüğümüzdiscard()metoduyla aynı işlevi
yerine getirir. Eğer bir kümeden öğe silmek istersekremove()metodunu da
kullanabiliriz:

```python
>>> hayvanlar.remove("köpek")

```

Pekidiscard()varkenremove()metoduna ne gerek var? Ya da tersi.

Bu iki metot aynı işlevi yerine getirse de aralarında önemli bir fark vardır.
Hatırlarsanızdiscard()metoduyla, kümede olmayan bir öğeyi silmeye çalışırsak
herhangi bir hata mesajı almayacağımızı söylemiştik. Eğerremove()metodunu
kullanarak, kümede olmayan bir öğeyi silmeye çalışırsak,discard()metodunun
aksine, hata mesajı alırız:

```python
>>> hayvanlar.remove("fare")

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
KeyError: 'fare'

```

Bu iki metot arasındaki bu fark önemli bir farktır. Bazen yazdığınız
programlarda, duruma göre her iki özelliğe de ihtiyacınız olabilir.

##### intersection()

intersectionkelimesi Türkçe’de “kesişim” anlamına gelir. Adından da
anladığımız gibi,intersection()metodu bize iki kümenin kesişim kümesini
verecektir:

```python
>>> k1 = set([1, 2, 3, 4])
>>> k2 = set([1, 3, 5, 7])
>>> k1.intersection(k2)

{1, 3}

```

Gördüğünüz gibi, bu metot bize k1 ve k2’nin kesişim kümesini veriyor.
Dolayısıyla bu iki küme arasındaki ortak elemanları bulmuş oluyoruz.

Hatırlarsanız,difference()metodunu anlatırken,difference()kelimesi
yerine “-” işaretini de kullanabileceğimiz, söylemiştik. Benzer bir durumintersection()metodu için de geçerlidir. İki kümenin kesişimini bulmak için
“&” işaretinden yararlanabiliriz:

```python
>>> k1 & k2

{1, 3}

```

Python programcıları genellikle uzun uzunintersectionyazmak yerine “&”
işaretini kullanırlar…

İsterseniz bu metot için örnek bir program verelim. Böylece gerçek hayatta bu
metodu nasıl kullanabileceğimizi görmüş oluruz:

```python
tr = "şçöğüıŞÇÖĞÜİ"

parola = input("Sisteme giriş için bir parola belirleyin: ")

if set(tr) & set(parola):
 print("Parolanızda Türkçe harfler kullanmayın!")

else:
 print("Parolanız kabul edildi!")

```

Burada eğer kullanıcı, parola belirlerken içinde Türkçe bir harf geçen bir
kelime yazarsa programımız kendisini Türkçe harf kullanmaması konusunda
uyaracaktır. Bu kodlarda kümeleri nasıl kullandığımıza dikkat edin. Programda
asıl işi yapan kısım şu satırdır:

```python
if set(tr) & set(parola):
 print("Parolanızda Türkçe harfler kullanmayın!")

```

Burada aslında şöyle bir şey demiş oluyoruz:

Eğer set(tr) ve set(parola) kümelerinin kesişim kümesi boş değilse,
kullanıcıya “Parolanızda Türkçe harfler kullanmayın!” uyarısını göster!

set(tr)veset(parola)kümelerinin kesişim kümesinin boş olmaması,
kullanıcının girdiği kelime içindeki harflerden en az birinintradlı
değişken içinde geçtiği anlamına gelir. Burada basitçe,trdeğişkeni ileparoladeğişkeni arasındaki ortak öğeleri sorguluyoruz. Eğer kullanıcı
herhangi bir Türkçe harf içermeyen bir kelime girerseset(tr)veset(parola)kümelerinin kesişim kümesi boş olacaktır. İsterseniz küçük bir
deneme yapalım:

```python
>>> tr = "şçöğüıŞÇÖĞÜİ"
>>> parola = "çilek"
>>> set(tr) & set(parola)

{'ç'}

```

Burada kullanıcının “çilek” adlı kelimeyi girdiğini varsayıyoruz. Böyle bir
durumdaset(tr)veset(parola)kümelerinin kesişim kümesi “ç” harfini
içerecek, dolayısıyla da programımız kullanıcıya uyarı mesajı gösterecektir.
Eğer kullanıcımız “kalem” gibi Türkçe harf içermeyen bir kelime girerse:

```python
>>> tr = "şçöğüıŞÇÖĞÜİ"
>>> parola = "kalem"
>>> set(tr) & set(parola)

set()

```

Gördüğünüz gibi, elde ettiğimiz küme boş. Dolayısıyla böyle bir durumda
programımız kullanıcıya herhangi bir uyarı mesajı göstermeyecektir.

intersection()metodunu pek çok yerde kullanabilirsiniz. Hatta iki dosya
arasındaki benzerlikleri bulmak için dahi bu metottan yararlanabilirsiniz.
İlerde dosya işlemleri konusunu işlerken bu metottan nasıl yararlanabileceğimizi
de anlatacağız.

##### intersection_update()

Hatırlarsanızdifference_update()metodunu işlerken şöyle bir şey demiştik:

Bu metot, difference() metodundan elde edilen sonuca göre bir kümenin
güncellenmesini sağlar.

İşteintersection_updatemetodu da buna çok benzer bir işlevi yerine getirir.
Bu metodun görevi,intersection()metodundan elde edilen sonuca göre bir
kümenin güncellenmesini sağlamaktır:

```python
>>> k1 = set([1, 2, 3])
>>> k2 = set([1, 3, 5])
>>> k1.intersection_update(k2)
>>> print(k1)

{1, 3}

>>> print(k2)

{1, 3, 5}

```

Gördüğünüz gibi,intersection_update()metodu k1’in bütün öğelerini sildi ve
yerlerine k1 ve k2’nin kesişim kümesinin elemanlarını koydu.

##### isdisjoint()

Bu metodun çok basit bir görevi vardır.isdisjoint()metodunu kullanarak iki
kümenin kesişim kümesinin boş olup olmadığı sorgulayabilirsiniz. Hatırlarsanız
aynı işi bir önceki bölümde gördüğümüzintersection()metodunu kullanarak da
yapabiliyorduk. Ama eğer hayattan tek beklentiniz iki kümenin kesişim kümesinin
boş olup olmadığını, yani bu iki kümenin ortak eleman içerip içermediğini
öğrenmekse, basitçeisdisjoint()metodundan yararlanabilirsiniz:

```python
>>> a = set([1, 2, 3])
>>> b = set([2, 4, 6])
>>> a.isdisjoint(b)

False

```

Gördüğünüz gibi,avebkümesinin kesişimi boş olmadığı için, yani bu
iki küme ortak en az bir öğe barındırdığı için,isdisjoint()metoduFalseçıktısı veriyor. Burada temel olarak şu soruyu sormuş oluyoruz:

a ve b ayrık kümeler mi?

Python da bize cevap olarak, “Hayır değil,” anlamına gelenFalseçıktısını
veriyor… Çünküavebkümelerinin ortak bir elemanı var (2).

Bir de şuna bakalım:

```python
>>> a = set([1, 3, 5])
>>> b = set([2, 4, 6])
>>> a.isdisjoint(b)

True

```

Buradaavebkümeleri ortak hiç bir elemana sahip olmadığı için “Doğru”
anlamına gelenTrueçıktısını elde ediyoruz.

##### issubset()

Bu metot yardımıyla, bir kümenin bütün elemanlarının başka bir küme içinde yer
alıp yer almadığını sorgulayabiliriz. Yani bir kümenin, başka bir kümenin alt
kümesi olup olmadığını bu metot yardımıyla öğrenebiliriz. Eğer bir küme başka
bir kümenin alt kümesi ise bu metot bizeTruedeğerini verecek; eğer değilseFalseçıktısını verecektir:

```python
>>> a = set([1, 2, 3])
>>> b = set([0, 1, 2, 3, 4, 5])
>>> a.issubset(b)

True

```

Bu örnekteTrueçıktısını aldık, çünkü a kümesinin bütün öğeleribkümesi içinde yer alıyor. Yania,b’nin alt kümesidir.

##### issuperset()

Bu metot, bir önceki bölümde gördüğümüzissubset()metoduna benzer. Matematik
derslerinde gördüğümüz “kümeler” konusunda hatırladığınız “b kümesi a kümesini
kapsar” ifadesini bu metotla gösteriyoruz. Önce bir önceki derste gördüğümüz
örneğe bakalım:

```python
>>> a = set([1, 2, 3])
>>> b = set([0, 1, 2, 3, 4, 5])
>>> a.issubset(b)

True

```

Buradan, “a kümesi b kümesinin alt kümesidir,” sonucuna ulaşıyoruz. Bir de şuna
bakalım:

```python
>>> a = set([1, 2, 3])
>>> b = set([0, 1, 2, 3, 4, 5])
>>> b.issuperset(a)

True

```

Burada ise, “b kümesi a kümesini kapsar,” sonucunu elde ediyoruz. Yanibkümesiakümesinin bütün elemanlarını içinde barındırıyor.

##### union()

union()metodu iki kümenin birleşimini almamızı sağlar. Hemen bir örnek
verelim:

```python
>>> a = set([2, 4, 6, 8])
>>> b = set([1, 3, 5, 7])
>>> a.union(b)

{1, 2, 3, 4, 5, 6, 7, 8}

```

Önceki bölümlerde gördüğümüz bazı metotlarda olduğu gibi,union()metodu da
bir kısayola sahiptir.union()metodu yerine “|” işaretini de kullanabiliriz:

```python
>>> a | b

```

union()metodu yerine, bu metodun kısayolu olan “|” işareti Python
programcıları tarafından daha sık kullanılır.

##### update()

Hatırlarsanızadd()metodunu anlatırken şöyle bir örnek vermiştik:

```python
>>> küme = set(["elma", "armut", "kebap"])
>>> yeni = [1, 2, 3]

>>> for i in yeni:
... küme.add(i)
...
>>> küme

{1, 2, 3, 'elma', 'armut', 'kebap'}

```

Bu örneği verdikten sonra da şöyle bir şey demiştik:

“Buradayeniadlı listeyi kümeyefordöngüsü ile ekledik. Ama bu işlemi
yapmanın başka bir yolu daha vardır. Bu işlem için Python’da ayrı bir metot
bulunur.”

İşte bu metodu öğrenmenin vakti geldi. Metodumuzun adıupdate(). Bu metot, bir
kümeyi güncellememizi sağlar. İsterseniz yukarıdaki örneği, bu metodu kullanarak
tekrar yazalım:

```python
>>> küme = set(["elma", "armut", "kebap"])
>>> yeni = [1, 2, 3]
>>> küme.update(yeni)
>>> print(küme)

{1, 2, 3, 'elma', 'armut', 'kebap'}

```

Gördüğünüz gibi,fordöngüsünü kullanmaya gerek kalmadan aynı sonucu elde
edebildik.

##### symmetric_difference()

Daha önceki bölümlerdedifference()metodunu kullanarak iki küme arasındaki
farklı öğeleri bulmayı öğrenmiştik. Örneğin elimizde şöyle iki küme var
diyelim:

```python
>>> a = set([1, 2, 5])
>>> b = set([1, 4, 5])

```

Eğerakümesininbkümesinden farkını bulmak istersek şöyle yapıyoruz:

```python
>>> a.difference(b)

{2}

```

Demek kiakümesinde bulunupbkümesinde bulunmayan öğe2imiş.

Bir debkümesinde bulunupakümesinde bulunmayan öğelere bakalım:

```python
>>> b.difference(a)

{4}

```

Bu da bize “4” çıktısını verdi. Demek ki bu öğebkümesinde bulunuyor, amaakümesinde bulunmuyormuş. Peki ya kümelerin sadece birinde bulunan öğeleri nasıl alacağız?
İşte bu noktada yardımımızasymmetric_difference()adlı metot yetişecek:

```python
>>> a.symmetric_difference(b)

{2, 4}

```

Böylece iki kümenin ortak olarak sahip olmadığı öğeleri almış olduk.

##### symmetric_difference_update()

Daha öncedifference_updateveintersection_updategibi metotları
öğrenmiştik.symmetric_difference_update()metodu da bunlara benzer bir işlevi
yerine getirir:

```python
>>> a = set([1,2, 5])
>>> b = set([1,4, 5])
>>> a.symmetric_difference_update(b)
>>> print(a)

{2, 4}

```

Gördüğünüz gibi, a kümesinin eski öğeleri gitti, yerlerinesymmetric_difference()metoduyla elde edilen çıktı geldi. Yaniakümesi,symmetric_difference()metodunun sonucuna göre güncellenmiş oldu…

##### pop()

İnceleyeceğimiz son metotpop()metodu olacak. Gerçi bu metot bize hiç yabancı
değil. Bu metodu listeler konusundan hatırlıyoruz. Orada öğrendiğimize göre, bu
metot listenin bir öğesini silip ekrana basıyordu. Aslında buradaki fonksiyonu
da farklı değil. Burada da kümelerin öğelerini silip ekrana basıyor:

```python
>>> a = set(["elma", "armut", "kebap"])
>>> a.pop()

'elma'

```

Peki bu metot hangi ölçüte göre kümeden öğe siliyor? Herhangi bir ölçüt yok. Bu
metot, küme öğelerini tamamen rastgele siliyor.

Böylelikle Python’da Listeler, Demetler, Sözlükler ve Kümeler konusunu bitirmiş
olduk. Bu konuları sık sık tekrar etmek, hiç olmazsa arada sırada göz gezdirmek
bazı şeylerin zihnimizde yer etmesi açısından oldukça önemlidir.

### Dondurulmuş Kümeler (Frozenset)

Daha önce de söylediğimiz gibi, kümeler üzerinde değişiklik yapabiliyoruz. Zaten
kümelerinadd()veremove()gibi metotlarının olması bu durumu teyit ediyor.
Ancak kimi durumlarda, öğeleri üzerinde değişiklik yapılamayan kümelere de
ihtiyaç duyabilirsiniz. Hatırlarsanız listeler ve demetler arasında da buna
benzer bir ilişki var. Demetler çoğu zaman, üzerinde değişiklik yapılamayan bir
liste gibi davranır. İşte Python aynı imkanı bize kümelerde de sağlar. Eğer
öğeleri üzerinde değişiklik yapılamayan bir küme oluşturmak istersenizset()yerinefrozenset()fonksiyonunu kullanabilirsiniz. Dilerseniz hemen bununla
ilgili bir örnek verelim:

```python
>>> dondurulmuş = frozenset(["elma", "armut", "ayva"])

```

Dondurulmuş kümeleri bu şekilde oluşturuyoruz. Şimdi bu dondurulmuş kümenin
metotlarına bakalım:

```python
>>> dir(dondurulmuş)

['__and__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__',
 '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',
 '__init__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__',
 '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__',
 '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__',
 '__subclasshook__', '__xor__', 'copy', 'difference', 'intersection',
 'isdisjoint', 'issubset', 'issuperset', 'symmetric_difference', 'union']

```

Gördüğünüz gibi,add(),remove(),update()gibi, değişiklik yapmaya
yönelik metotlar listede yok.

Dondurulmuş kümeler ile normal kümeler arasında işlev olarak hiçbir fark yoktur.
Bu ikisi arasındaki fark, listeler ile demetler arasındaki fark gibidir.

## Fonksiyonlar

İlk derslerimizden bu yana bir şey özellikle dikkatinizi çekmiş olmalı: İlk
andan itibaren hep ‘fonksiyon’ diye bir kavramdan söz ettik; üstelik yazdığımız
kodlarda da bu fonksiyon denen şeyi bolca kullandık. Evet, belki bu kavramı
şimdiye dek enine boyuna inceleme fırsatımız hiç olmadı, ama yine de adının
fonksiyon olduğunu söylediğimiz pek çok araç tanıdık bu noktaya gelinceye kadar.

Herhalde, ‘Fonksiyon denince aklınıza ilk ne geliyor?’ diye bir soru sorsam,
vereceğiniz cevapprint()fonksiyonu olacaktır. Gerçekten de bu fonksiyonu
ilk derslerimizden bu yana o kadar sık kullandık ki, fonksiyon denince aklınıza
ilk bu fonksiyonun gelmesi gayet doğal.

Elbette öğrendiğimiz tek fonksiyonprint()değildi. Bunun dışındatype()diye bir fonksiyondan da söz etmiştik.print()kadar olmasa da,type()fonksiyonunu da yazdığımız kodlarda epey kullandık.print()vetype()dışında, fonksiyon olarakstr(),int()ve benzeri araçlarla da tanıştık.
Bunların dışında pek çok başka fonksiyon da Python’la birlikte hayatımıza girdi.

İşte bu bölümde, en baştan bu yana sıklıkla sözünü ettiğimiz, ama hiçbir zaman
tam anlamıyla ele almadığımız bu kavramı daha iyi anlayabilmek için, fonksiyon
konusunu ayrıntılı olarak ele alacağız. Bu bölümde amacımız fonksiyonları enine
boyuna inceleyerek, okurun bilgi dağarcığında fonksiyonlara ilişkin sağlam bir
altyapı oluşturmaktır. Okur, bu bölümü bitirdikten sonra fonksiyonlara ilişkin
olarak bilmesi gereken her şeyi öğrenmiş olacak.

### Fonksiyon Nedir ve Ne İşe Yarar?

Biz şimdiye dek karşılaştığımızprint(),len(),type()veopen()gibi örnekler sayesinde ‘fonksiyon’ denen şeyi az çok tanıdığımızı
söyleyebiliriz. Dolayısıyla fonksiyonun ne demek olduğunu şeklen de olsa
biliyoruz ve hatta fonksiyonları kodlarımız içinde etkili bir şekilde
kullanabiliyoruz.

İlk derslerimizden bu yana öğrendiğimiz fonksiyonlara şöyle bir bakacak olursak,
fonksiyonların görünüşüne ve yapısına dair herhalde şu tespitleri yapabiliriz:
1. Her fonksiyonun bir adı bulunur ve fonksiyonlar sahip oldukları bu
adlarla anılır. (printfonksiyonu,openfonksiyonu,typefonksiyonu,inputfonksiyonu,lenfonksiyonu vb.)
1. Şekil olarak, her fonksiyonun isminin yanında birer parantez işareti
bulunur. (open(),print(),input(),len()vb.)
1. Bu parantez işaretlerinin içine, fonksiyonlara işlevsellik kazandıran
bazı parametreler yazılır. (open(dosya_adı),print("MerhabaZalimDünya!"),len("kahramanmaraş")vb.)
1. Fonksiyonlar farklı sayıda parametre alabilir. Örneğinprint()fonksiyonu toplam256adet parametre alabilirken,input()fonksiyonu
yalnızca tek bir parametre alır.
1. Fonksiyonların isimli ve isimsiz parametreleri vardır.print()fonksiyonundakisep,endvefileparametreleri isimli parametrelere
örnekken, meselaprint("MerhabaDünya!")kodundaMerhaba Dünya!parametresi isimsiz bir parametredir. Aynı şekildeinput("Adınız:")gibi bir koddaAdınız:parametresi isimsiz bir parametredir.
1. Fonksiyonların, isimli ve isimsiz parametreleri dışında, bir de
varsayılan değerli parametreleri vardır. Örneğinprint()fonksiyonununsep,endvefileparametreleri varsayılan değerli parametrelere birer
örnektir. Eğer bir parametrenin varsayılan bir değeri varsa, o parametreye
herhangi bir değer vermeden de fonksiyonu kullanabiliriz. Python bu
parametrelere, belirli değerleri öntanımlı olarak kendisi atayacaktır. Tabii
eğer istersek, varsayılan değerli parametrelere kendimiz de başka birtakım
değerler verebiliriz.

Her fonksiyonun bir adı bulunur ve fonksiyonlar sahip oldukları bu
adlarla anılır. (printfonksiyonu,openfonksiyonu,typefonksiyonu,inputfonksiyonu,lenfonksiyonu vb.)

Şekil olarak, her fonksiyonun isminin yanında birer parantez işareti
bulunur. (open(),print(),input(),len()vb.)

Bu parantez işaretlerinin içine, fonksiyonlara işlevsellik kazandıran
bazı parametreler yazılır. (open(dosya_adı),print("MerhabaZalimDünya!"),len("kahramanmaraş")vb.)

Fonksiyonlar farklı sayıda parametre alabilir. Örneğinprint()fonksiyonu toplam256adet parametre alabilirken,input()fonksiyonu
yalnızca tek bir parametre alır.

Fonksiyonların isimli ve isimsiz parametreleri vardır.print()fonksiyonundakisep,endvefileparametreleri isimli parametrelere
örnekken, meselaprint("MerhabaDünya!")kodundaMerhaba Dünya!parametresi isimsiz bir parametredir. Aynı şekildeinput("Adınız:")gibi bir koddaAdınız:parametresi isimsiz bir parametredir.

Fonksiyonların, isimli ve isimsiz parametreleri dışında, bir de
varsayılan değerli parametreleri vardır. Örneğinprint()fonksiyonununsep,endvefileparametreleri varsayılan değerli parametrelere birer
örnektir. Eğer bir parametrenin varsayılan bir değeri varsa, o parametreye
herhangi bir değer vermeden de fonksiyonu kullanabiliriz. Python bu
parametrelere, belirli değerleri öntanımlı olarak kendisi atayacaktır. Tabii
eğer istersek, varsayılan değerli parametrelere kendimiz de başka birtakım
değerler verebiliriz.

Fonksiyon kavramının tam olarak ne olduğunu henüz bilmiyor da olsak, şimdiye
kadar öğrendiğimiz fonksiyonlara bakarak fonksiyonlar hakkında yukarıdaki
çıkarımları yapabiliyoruz. Demek ki aslında fonksiyonlar hakkında alttan alta
pek çok şey öğrenmişiz. O halde, fonksiyonlar hakkında şimdiden bildiklerimize
güvenerek, fonksiyon kavramının ne olduğundan ziyade ne işe yaradığı konusuna
rahatlıkla eğilebiliriz. Zaten fonksiyonların ne işe yaradığını öğrendikten
sonra, fonksiyonların ne olduğunu da hemencecik anlayacaksınız.

Fonksiyonların ne işe yaradığını en genel ve en kaba haliyle tarif etmek
istersek şöyle bir tanımlama yapabiliriz:

Fonksiyonların görevi, karmaşık işlemleri bir araya toplayarak, bu
işlemleri tek adımda yapmamızı sağlamaktır. Fonksiyonlar çoğu zaman, yapmak
istediğimiz işlemler için bir şablon vazifesi görür. Fonksiyonları
kullanarak, bir veya birkaç adımdan oluşan işlemleri tek bir isim altında
toplayabiliriz. Python’daki ‘fonksiyon’ kavramı başka programlama dillerinde
‘rutin’ veya ‘prosedür’ olarak adlandırılır. Gerçekten de fonksiyonlar
rutin olarak tekrar edilen görevleri veya prosedürleri tek bir ad/çatı
altında toplayan araçlardır.

Dilerseniz yukarıdaki soyut ifadeleri basit bir örnek üzerinde somutlaştırmaya
çalışalım. Örneğinprint()fonksiyonunu ele alalım.

Bu fonksiyonun görevini biliyorsunuz:print()fonksiyonunun görevi,
kullanıcının girdiği parametreleri ekrana çıktı olarak vermektir. Her ne kadarprint()fonksiyonunun görevini, ekrana çıktı vermek olarak tanımlasak da,
aslında bu fonksiyon, ekrana çıktı vermenin yanı sıra, başka bir takım ilave
işlemler de yapar. Yani bu fonksiyon, aslında aldığı parametreleri sadece ekrana
çıktı olarak vermekle yetinmez. Örneğin şu komutu inceleyelim:

```python
>>> print("Fırat", "Özgül", "1980", "Adana")

```

Buradaprint()fonksiyonu toplam dört adet parametre alıyor. Fonksiyonumuz,
görevi gereği, bu parametreleri ekrana çıktı olarak verecek. Bu komutu
çalıştırdığımızda şöyle bir çıktı alıyoruz:

```python
Fırat Özgül 1980 Adana

```

Dikkat ederseniz, burada salt bir ‘ekrana çıktı verme’ işleminden fazlası var.
Ziraprint()fonksiyonu aldığı parametreleri şu şekilde de ekrana
verebilirdi:

```python
FıratÖzgül1980Adana

```

Veya şu şekilde:

```python
F
ı
r
a
t
Ö
z
g
ü
l
1
9
8
0
A
d
a
n
a

```

Neticede bunlar da birer çıktı verme işlemidir. Ama dediğimiz gibi,print()fonksiyonu aldığı parametreleri sadece ekrana çıktı olarak vermekle yetinmiyor.
Gelin isterseniz ne demek istediğimizi biraz daha açıklayalım:

print()fonksiyonunun yukarıdaki komutu nasıl algıladığını önceki
derslerimizde öğrenmiştik. Yukarıdaki komut Python tarafından şu şekilde
algılanıyor:

```python
>>> print("Fırat", "Özgül", "1980", "Adana", sep=" ", end="\n",
... file=sys.stdout, flush=False)

```

Yaniprint()fonksiyonu;
1. Kendisine verilen“Fırat”,“Özgül”,“1980”ve“Adana”parametrelerini ekrana basıyor,
1. sep=” “parametresinin etkisiyle, bu parametreler arasına birer boşluk
ekliyor,
1. end=”\n”parametresinin etkisiyle, sonuncu parametreyi de ekrana
bastıktan sonra bir alt satıra geçiyor,
1. file=sys.stdoutparametresinin etkisiyle, çıktı konumu olarak komut
ekranını kullanıyor. Yani çıktıları ekrana veriyor.
1. flush=Falseparametresinin etkisiyle, çıktılar ekrana gönderilmeden önce
tamponda bekletiliyor.

Kendisine verilen“Fırat”,“Özgül”,“1980”ve“Adana”parametrelerini ekrana basıyor,

sep=” “parametresinin etkisiyle, bu parametreler arasına birer boşluk
ekliyor,

end=”\n”parametresinin etkisiyle, sonuncu parametreyi de ekrana
bastıktan sonra bir alt satıra geçiyor,

file=sys.stdoutparametresinin etkisiyle, çıktı konumu olarak komut
ekranını kullanıyor. Yani çıktıları ekrana veriyor.

flush=Falseparametresinin etkisiyle, çıktılar ekrana gönderilmeden önce
tamponda bekletiliyor.

Eğerprint()gibi bir fonksiyon olmasaydı, yukarıda listediğimiz bütün bu
işlemleri kendimiz yapmak zorunda kalacaktık. Yani ekranda göstermek istediğimiz
ifadeleri ekrana çıktı olarak vermenin yanısıra, bunların ekranda nasıl
görüneceğini de tek tek kendimiz elle ayarlamak zorunda kalacaktık. Ekrana çıktı
verme ile ilgili pek çok işlem tek birprint()fonksiyonu altında
birleştirildiği için, her ihtiyaç duyduğumuzda o işlemleri tek tek bizim
yapmamıza gerek kalmıyor.

Aynı şey meselainput()fonksiyonu için de geçerlidir. Bu fonksiyonu
kullanarak, programımızı kullanan kişilerle etkileşim içine girebiliyoruz. Tıpkıprint()fonksiyonunda olduğu gibi,input()fonksiyonu da aslında alttan
alta epey karmaşık işlemler gerçekleştirir. Ama o karmaşık işlemlerin tek birinput()fonksiyonu içinde bir araya getirilmiş olması sayesinde, sadeceinput()gibi basit bir komut vererek kullanıcılarımızla iletişime
geçebiliyoruz.

Bu açıdan bakıldığında fonksiyonlar değişkenlere benzer. Bildiğiniz gibi, her
defasında bir değeri tekrar tekrar yazmak yerine bir değişkene atayarak o değere
kolayca erişebiliyoruz. Örneğin:

```python
>>> kurum = "Sosyal Sigortalar Kurumu"

```

Burada tanımladığımızkurumadlı değişken sayesinde, ‘Sosyal Sigortalar
Kurumu’ ifadesini kullanmamız gereken her yerde sadece değişken adını
kullanarak, değişkenin tuttuğu değere ulaşabiliyoruz. İşte fonksiyonlar da buna
benzer bir işlev görür: Örneğin ekrana bir çıktı vermemiz gereken her yerde,
yukarıda verdiğimiz karmaşık adımları tek tek gerçekleştirmeye çalışmak yerine,
bu karmaşık ve rutin adımları bir araya getirenprint()gibi bir
fonksiyondan yararlanarak işlerimizi çok daha kolay bir şekilde halledebiliriz.

Bu anlattıklarımız fonksiyonların ne işe yaradığı konusunda size bir fikir
vermiş olabilir. Dilerseniz bu anlattıklarımızı bir örnek aracılığıyla biraz
daha somutlaştırmaya çalışalım:

Hatırlarsanız ‘Kullanıcıyla Veri Alışverişi’ başlıklı bölümde şöyle bir örnek
vermiştik:

```python
isim = "Fırat"
soyisim = "Özgül"
işsis = "Ubuntu"
şehir = "İstanbul"

print("isim : ", isim)
print("soyisim : ", soyisim)
print("işletim sistemi: ", işsis)
print("şehir : ", şehir)

```

Bu programı çalıştırdığımızda şöyle bir çıktı alıyoruz:

```python
isim : Fırat
soyisim : Özgül
işletim sistemi: Ubuntu
şehir : İstanbul

```

Bu program, belli değerleri kullanarak bir kayıt oluşturma işlemi
gerçekleştiriyor. Mesela yukarıdaki örnekte, ‘Fırat Özgül’ adlı şahsa ait isim,
soyisim, işletim sistemi ve şehir bilgilerini alarak, bu kişi için bir kayıt
oluşturuyoruz.

Peki ‘Fırat Özgül’ adlı kişinin yanısıra, ‘Mehmet Öztaban’ adlı başka bir kişi
için de kayıt oluşturmak istersek ne yapacağız?

Aklınıza şöyle bir şey yazmak gelmiş olabilir:

```python
isim1 = "Fırat"
soyisim1 = "Özgül"
işsis1 = "Ubuntu"
şehir1 = "İstanbul"

print("isim : ", isim1)
print("soyisim : ", soyisim1)
print("işletim sistemi: ", işsis1)
print("şehir : ", şehir1)

print("-"*30)

isim2 = "Mehmet"
soyisim2 = "Öztaban"
işsis2 = "Debian"
şehir2 = "Ankara"

print("isim : ", isim2)
print("soyisim : ", soyisim2)
print("işletim sistemi: ", işsis2)
print("şehir : ", şehir2)

print("-"*30)

```

Programa her yeni kayıt eklenişinde, her yeni kişi için benzer satırları tekrar
tekrar yazabilirsiniz. Peki ama bu yöntem sizce de çok sıkıcı değil mi? Üstelik
bir o kadar da hataya açık bir yöntem. Muhtemelen ilk kaydı ekledikten sonra,
ikinci kaydı eklerken birinci kayıttaki bilgileri kopyalayıp, bu kopya üzerinden
ikinci kaydı oluşturuyorsunuz. Hatta muhtemelen kopyalayıp yapıştırdıktan sonra
yeni kaydı düzenlerken bazı hatalar da yapıyor ve düzgün çalışan bir program
elde edebilmek için o hataları düzeltmekle de uğraşıyorsunuz.

Bütün bu işleri kolaylaştıracak bir çözüm olsa ve bizi aynı şeyleri tekrar
tekrar yazmaktan kurtarsa sizce de çok güzel olmaz mıydı? Mesela tıpkıprint()fonksiyonu gibi,kayıt_oluştur()adlı bir fonksiyon olsa, biz
sadece gerekli bilgileri bu fonksiyonun parantezleri içine parametre olarak
yazsak ve bu fonksiyon bize istediğimiz bilgileri içeren bir kayıt oluştursa ne
hoş olurdu, değil mi? Yani örneğin bahsettiğimiz bu hayalikayıt_oluştur()fonksiyonunu şu şekilde kullanabilseydik…

```python
kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara")

```

… ve bu komut bize şu çıktıyı verebilseydi…

```python
------------------------------
isim : Mehmet
soyisim : Öztaban
işletim sistemi: Debian
şehir : Ankara
------------------------------

```

… ne kadar güzel olurdu, değil mi?

İşte böyle bir şey Python’da mümkündür. Nasıl Python geliştiricileriprint(),input()ve benzeri fonksiyonları tanımlayıp, karmaşık işlemleri
tek adımda yapabilmemiz için bize sunmuş ve böylece bizi her defasında tekerleği
yeniden icat etme külfetinden kurtarmışsa, biz de kendi fonksiyonlarımızı
tanımlayarak, kendimizi aynı işlemleri tekrar tekrar yapma zahmetinden
kurtarabiliriz.

Gelin şimdi bu işi nasıl yapabileceğimizi tartışalım.

### Fonksiyon Tanımlamak ve Çağırmak

Bir önceki bölümde,kayıt_oluştur()adlı hayali bir fonksiyondan söz
etmiştik. Tasarımıza göre bu fonksiyon şu şekilde kullanılacak:

```python
kayıt_oluştur("Ahmet", "Gür", "Pardus", "İzmir")

```

Bu komutu verdiğimizde ise şöyle bir çıktı almayı planlıyoruz:

```python
------------------------------
isim : Ahmet
soyisim : Gür
işletim sistemi: Pardus
şehir : İzmir
------------------------------

```

Dediğimiz gibi, böyle bir şey yapmak Python’la mümkündür. Ancak tabii kikayıt_oluştur()adlı böyle bir fonksiyonu kullanabilmenin belli ön koşulları
var. Nasılsayıadlı bir değişkeni kullanabilmek için öncelikle bu ada sahip
bir değişken tanımlamış olmamız gerekiyorsa, aynı şekildekayıt_oluştur()adlı bir fonksiyonu kullanabilmek için de öncelikle bu ada sahip bir fonksiyonu
tanımlamış olmamız gerekiyor. Zira meselainput()veprint()gibi
fonksiyonları kullanabiliyor olmamız, Python geliştiricilerinin bu fonksiyonları
tanımlayıp dilin içine gömmüş olmaları sayesindedir.

İşte biz dekayıt_oluştur()adlı fonksiyonu kullanabilmek için bu ada sahip
fonksiyonu aşağıdaki şekilde tanımlamalıyız:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

```

İlk bakışta bu kodlar size hiçbir şey ifade etmemiş olabilir. Ama hiç endişe
etmeyin. Biz birazdan bu satırların ne anlama geldiğini bütün ayrıntılarıyla
anlatacağız. Siz şimdilik anlamadığınız kısımları görmezden gelip okumaya devam
edin.

Yukarıdaki kodlar yardımıyla fonksiyonumuzu tanımlamış olduk. Artık elimizde,
tıpkıprint()veyainput()gibi,kayıt_oluştur()adlı ‘ev yapımı’
bir fonksiyon var. Dolayısıyla bu yeni fonksiyonumuzu, daha önce öğrendiğimiz
fonksiyonları nasıl kullanıyorsak aynı şekilde kullanabiliriz. Yani aşağıdaki
gibi komutlar yazabiliriz:

```python
kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul")
kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara")

```

Yalnız fonksiyonumuzu tanımlayıp bitirdikten sonra, bu fonksiyonu kullanırken,
kodlarımızın hizalamasına dikkat ediyoruz. Fonksiyonu kullanmak için yazdığımız
kodlarıdefifadesinin hizasına getiriyoruz. Yani:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul")
kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara")

```

Yukarıdaki yapıyı kullanarak, istediğiniz sayıda kayıt oluşturabilirsiniz. Mesela:

```python
kayıt_oluştur("İlkay", "Kaya", "Mint", "Adana")
kayıt_oluştur("Seda", "Kara", "SuSe", "Erzurum")

```

Gördüğünüz gibi, yukarıdaki yöntem sayesinde kodlarımızdaki tekrar eden kısımlar
ortadan kalktı. Yukarıdaki fonksiyonun bize nasıl bir kolaylık sağladığını daha
net görebilmek için, fonksiyon kullanarak sadece şu11satırla elde ettiğimiz
çıktıyı, fonksiyon kullanmadan elde etmeyi deneyebilirsiniz:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul")
kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara")
kayıt_oluştur("İlkay", "Kaya", "Mint", "Adana")
kayıt_oluştur("Seda", "Kara", "SuSe", "Erzurum")

```

Bu anlattıklarımız size çok karmaşık gelmiş olabilir. Ama endişe etmenize hiç
gerek yok. Biraz sonra, yukarıda yazdığımız kodların hepsini didik didik
edeceğiz. Ama öncelikle yukarıdaki kod parçasını yapısal olarak bir incelemenizi
istiyorum. Fonksiyonu tanımladığımız aşağıdaki kod parçasına şöyle bir
baktığınızda neler görüyorsunuz?

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul")

```

Bu kodları incelediğinizde şu noktalar dikkatinizi çekiyor olmalı:
1. Kodlardefadlı bir ifade ile başlamış.
1. Bunun ardından ‘kayıt_oluştur’ ifadesini görüyoruz.
1. Bu ifadeyi, içinde birtakım kelimeler barındıran bir parantez çifti izliyor.
1. Parantezin içinde,isim,soyisim,işsisveşehiradlı değerler var.
1. defile başlayan bu satır iki nokta üst üste işareti ile son buluyor.
1. İlk satırın ardından gelen kısım ilk satıra göre girintili bir şekilde yazılmış.
1. kayıt_oluştur("Fırat","Özgül","Ubuntu","İstanbul")satırı önceki
satırlara göre girintisiz yazılmış.

Kodlardefadlı bir ifade ile başlamış.

Bunun ardından ‘kayıt_oluştur’ ifadesini görüyoruz.

Bu ifadeyi, içinde birtakım kelimeler barındıran bir parantez çifti izliyor.

Parantezin içinde,isim,soyisim,işsisveşehiradlı değerler var.

defile başlayan bu satır iki nokta üst üste işareti ile son buluyor.

İlk satırın ardından gelen kısım ilk satıra göre girintili bir şekilde yazılmış.

kayıt_oluştur("Fırat","Özgül","Ubuntu","İstanbul")satırı önceki
satırlara göre girintisiz yazılmış.

Eğer bu kodlara dikkatlice bakacak olursanız, aslında bu kodların topu topu iki
parçadan oluştuğunu göreceksiniz. İsterseniz yukarıdaki yapıyı biraz
sadeleştirelim:

```python
def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4):
 (...)

kayıt_oluştur(parametre1, parametre2, parametre3, parametre4)

```

Bu yapının ilk parçası şudur:

```python
def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4):
 (...)

```

İkinci parçası ise şu:

```python
kayıt_oluştur(parametre1, parametre2, parametre3, parametre4)

```

Teknik olarak söylemek gerekirse, ilk parçaya ‘fonksiyon tanımı’ (function
definition), ikinci parçaya ise ‘fonksiyon çağrısı’ (function call) adı
verilir. Dolayısıyla bir fonksiyonun yaşam döngüsü iki aşamadan oluşur. Buna
göre bir fonksiyon önce tanımlanır;

```python
def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4):
 (...)

```

…sonra da çağrılır;

```python
kayıt_oluştur(parametre1, parametre2, parametre3, parametre4)

```

Aslında biz şimdiye kadar gördüğümüzprint(),type(),open()vb.
fonksiyonlarda bu ‘fonksiyon çağrısı’ kısmıyla zaten tanışmıştık. Zira şu komut
tam anlamıyla bir fonksiyon çağrısıdır (yani bir fonksiyon çağırma işlemidir):

```python
print("Fırat", "Özgül", "Adana", 32)

```

Gördüğünüz gibi, yukarıdaki komutun yapı olarak şu komuttan hiçbir farkı yok:

```python
kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul")

```

Bu iki fonksiyon arasındaki tek fark,print()fonksiyonunu Python
geliştiricilerinin;kayıt_oluştur()fonksiyonunu ise sizin tanımlamış
olmanızdır.

Elbette bu iki fonksiyon yapı olarak birbirinin aynı olsa da, işlev olarak
birbirinden farklıdır.print()fonksiyonunun görevi kendisine parametre
olarak verilen değerleri ekrana çıktı vermek iken,kayıt_oluştur()fonksiyonunun görevi kendisine parametre olarak verilen değerleri kullanarak bir
kayıt oluşturmaktır.

Bu derse gelinceye kadar öğrendiğimizprint(),type()veopen()gibi
fonksiyonlara teknik olarak ‘gömülü fonksiyonlar’ (builtin functions) adı
verilir. Bu fonksiyonlara bu adın verilmiş olmasının sebebi, bu fonksiyonların
gerçekten de Python programlama dili içine gömülü bir vaziyette olmalarıdır.
Dikkat ederseniz kendi yazdığımız fonksiyonları kullanabilmek için öncelikle
fonksiyonu tanımlamamız gerekiyor. Gömülü fonksiyonlar ise Python
geliştiricileri tarafından halihazırda tanımlanmış olduğu için bunları biz
herhangi bir tanımlama işlemi yapmaya gerek kalmadan doğrudan çağırabiliyoruz.

Böylece bir fonksiyonun yapı olarak neye benzediğini üstünkörü de olsa incelemiş
olduk. Buraya kadar anlatılan kısımda bazı noktaları anlamakta zorlanmış
olabilirsiniz. Eğer öyleyse hiç endişelenmeyin. Bu gayet doğal.

Gelin isterseniz şimdi yukarıda anlattıklarımızın içini doldurmaya çalışalım.

### Fonksiyonların Yapısı

İsterseniz biraz da fonksiyonların yapısından söz edelim. Böylelikle ne ile
karşı karşıya olduğumuzu anlamak zihninizde biraz daha kolaylaşır.

Dedik ki, bir fonksiyonun ilk parçasına ‘fonksiyon tanımı’ (function
definition) adı verilir. Bir fonksiyonu tanımlamak içindefadlı bir
parçacıktan yararlanıyoruz. Örneğin:

```python
def bir_fonksiyon():
 (...)

```

Buradadefparçacığı, tanımladığımız şeyin bir fonksiyon olduğunu gösteriyor.bir_fonksiyonifadesi ise tanımladığımız bu fonksiyonun adıdır. Fonksiyonu
tanımladıktan sonra, çağırırken bu adı kullanacağız.

defbir_fonksiyon():ifadesinin sonundaki iki nokta işaretinden de tahmin
edebileceğiniz gibi, sonraki satıra yazacağımız kodlar girintili olacak. Yani
mesela:

```python
def selamla():
 print("Elveda Zalim Dünya!")

```

Yukarıdaselamla()adlı bir fonksiyon tanımlamış olduk. Bu fonksiyonun
görevi ekranaElveda Zalim Dünya!çıktısı vermektir.

Bu noktada şöyle bir soru akla geliyor: Acaba fonksiyon gövdesindeki kısım için
ne kadarlık bir girinti oluşturacağız?

Girintilemeye ilişkin olarak önceki derslerde bahsettiğimiz bütün kurallar
burada da geçerlidir. Fonksiyon gövdesine,defifadesinden itibaren4(dört)
boşlukluk bir girinti veriyoruz.defifadesinden itibaren girintili olarak
yazdığımız kısmın tamamı o fonksiyonun gövdesini oluşturur ve bütünüyle o
fonksiyona aittir.

Bu kodlarla yaptığımız şey bir fonksiyon tanımlama işlemidir. Eğer bu kodları
bir dosyaya kaydedip çalıştırırsak herhangi bir çıktı almayız. Çünkü henüz
fonksiyonumuzu çağırmadık. Bu durumuprint(),input()ve benzeri gömülü
fonksiyonlara benzetebilirsiniz. Tıpkı yukarıda bizim yaptığımız gibi, gömülü
fonksiyonlar da Python geliştiricileri tarafından bir yerlerde tanımlanmış
vaziyette dururlar, ama biz bu fonksiyonları yazdığımız programlarda çağırana
kadar bu fonksiyonlar çalışmaz.

Daha önce de dediğimiz gibi, bir fonksiyonun yaşam döngüsü iki aşamadan oluşur:
Fonksiyon tanımı ve fonksiyon çağrısı. Yukarıda bu döngünün sadece fonksiyon
tanımı aşaması mevcut. Unutmayın, bir fonksiyon çağrılmadan asla çalışmaz. Bir
fonksiyonun çalışabilmesi için o fonksiyonun tanımlandıktan sonra çağrılması
gerekir. Örneğininput()fonksiyonu Python’ın derinliklerinde bir yerlerde
tanımlanmış vaziyette durur. Bu fonksiyon, biz onu çağırana kadar, bulunduğu
yerde sessizce bekler. Aynı şekildeselamla()adlı fonksiyon da programımız
içinde tanımlanmış vaziyette, bizim onu çağıracağımız anı bekliyor. Bu
söylediklerimizi destekleyecek açıklayıcı bilgileri biraz sonra vereceğiz. Biz
şimdilik fonksiyon tanımı kısmını incelemeye devam edelim.

Bu arada yukarıdaki fonksiyon tanımının yapısına çok dikkat edin. İki nokta üst
üste işaretinden sonraki satırda girintili olarak yazılan bütün kodlar (yani
fonksiyonun gövde kısmı) fonksiyonun bir parçasıdır. Girintinin dışına çıkıldığı
anda fonksiyon tanımlama işlemi de sona erer.

Örneğin:

```python
def selamla():
 print("Elveda Zalim Dünya!")

selamla()

```

İşte burada fonksiyonumuzu çağırmış olduk. Dikkat edin! Dediğim gibi, iki nokta
üst üste işaretinden sonraki satırda girintili olarak yazılan bütün kodlar
fonksiyona aittir.selamla()satırı ise fonksiyon tanımının dışında yer
alır. Bu satırla birlikte girintinin dışına çıkıldığı için artık fonksiyon
tanımlama safhası sona ermiş oldu.

Biz yukarıdaki örnekte,selamla()adlı fonksiyonu tanımlar tanımlamaz
çağırmayı tercih ettik. Ama elbette siz bir fonksiyonu tanımlar tanımlamaz
çağırmak zorunda değilsiniz. Yazdığınız bir program içinde fonksiyonlarınızı
tanımladıktan sonra, ihtiyacınıza bağlı olarak, programın herhangi başka bir
yerinde fonksiyonlarınızı çağırabilirsiniz.

Fonksiyonlarla ilgili söylediklerimizi toparlayacak olursak şöyle bir bilgi
listesi ortaya çıkarabiliriz:
1. Python’da kabaca iki tip fonksiyon bulunur. Bunlardan biri gömülü
fonksiyonlar (builtin functions), öteki ise özel fonksiyonlardır (custom
functions). Burada ‘özel’ ifadesi, ‘kullanıcının ihtiyaçlarına göre
kullanıcı tarafından özel olarak üretilmiş’ anlamına gelir.
1. Gömülü fonksiyonlar; Python geliştiricileri tarafından tanımlanıp dilin
içine gömülmüş olanprint(),open(),type(),str(),int()vb. fonksiyonlardır. Bu fonksiyonlar halihazırda tanımlanıp
hizmetimize sunulduğu için bunları biz herhangi bir tanımlama işlemi
yapmadan doğrudan kullanabiliriz.
1. Özel fonksiyonlar ise, gömülü fonksiyonların aksine, Python
geliştiricileri tarafından değil, bizim tarafımızdan tanımlanmıştır. Bu
fonksiyonlar dilin bir parçası olmadığından, bu fonksiyonları kullanabilmek
için bunları öncelikle tanımlamamız gerekir.
1. Python’da bir fonksiyonun yaşam döngüsü iki aşamadan oluşur: Tanımlanma
ve çağrılma.
1. Bir fonksiyonun çağrılabilmesi (yani kullanılabilmesi) için mutlaka
birisi tarafından tanımlanmış olması gerekir.
1. Fonksiyonu tanımlayan kişi Python geliştiricileri olabileceği gibi, siz
de olabilirsiniz. Ama neticede ortada bir fonksiyon varsa, bir yerlerde o
fonksiyonun tanımı da vardır.
1. Fonksiyon tanımlamak içindefadlı bir ifadeden yararlanıyoruz. Bu
ifadeden sonra, tanımlayacağımız fonksiyonun adını belirleyip iki nokta üst
üste işareti koyuyoruz. İki nokta üst üste işaretinden sonra gelen satırlar
girintili olarak yazılıyor. Daha önce öğrendiğimiz bütün girintileme
kuralları burada da geçerlidir.
1. Fonksiyonun adını belirleyip iki nokta üst üste koyduktan sonra, alt
satırda girintili olarak yazdığımız bütün kodlar fonksiyonun gövdesini
oluşturur. Doğal olarak, bir fonksiyonun gövdesindeki bütün kodlar o
fonksiyona aittir. Girintinin dışına çıkıldığı anda fonksiyon tanımı da sona
erer.

Python’da kabaca iki tip fonksiyon bulunur. Bunlardan biri gömülü
fonksiyonlar (builtin functions), öteki ise özel fonksiyonlardır (custom
functions). Burada ‘özel’ ifadesi, ‘kullanıcının ihtiyaçlarına göre
kullanıcı tarafından özel olarak üretilmiş’ anlamına gelir.

Gömülü fonksiyonlar; Python geliştiricileri tarafından tanımlanıp dilin
içine gömülmüş olanprint(),open(),type(),str(),int()vb. fonksiyonlardır. Bu fonksiyonlar halihazırda tanımlanıp
hizmetimize sunulduğu için bunları biz herhangi bir tanımlama işlemi
yapmadan doğrudan kullanabiliriz.

Özel fonksiyonlar ise, gömülü fonksiyonların aksine, Python
geliştiricileri tarafından değil, bizim tarafımızdan tanımlanmıştır. Bu
fonksiyonlar dilin bir parçası olmadığından, bu fonksiyonları kullanabilmek
için bunları öncelikle tanımlamamız gerekir.

Python’da bir fonksiyonun yaşam döngüsü iki aşamadan oluşur: Tanımlanma
ve çağrılma.

Bir fonksiyonun çağrılabilmesi (yani kullanılabilmesi) için mutlaka
birisi tarafından tanımlanmış olması gerekir.

Fonksiyonu tanımlayan kişi Python geliştiricileri olabileceği gibi, siz
de olabilirsiniz. Ama neticede ortada bir fonksiyon varsa, bir yerlerde o
fonksiyonun tanımı da vardır.

Fonksiyon tanımlamak içindefadlı bir ifadeden yararlanıyoruz. Bu
ifadeden sonra, tanımlayacağımız fonksiyonun adını belirleyip iki nokta üst
üste işareti koyuyoruz. İki nokta üst üste işaretinden sonra gelen satırlar
girintili olarak yazılıyor. Daha önce öğrendiğimiz bütün girintileme
kuralları burada da geçerlidir.

Fonksiyonun adını belirleyip iki nokta üst üste koyduktan sonra, alt
satırda girintili olarak yazdığımız bütün kodlar fonksiyonun gövdesini
oluşturur. Doğal olarak, bir fonksiyonun gövdesindeki bütün kodlar o
fonksiyona aittir. Girintinin dışına çıkıldığı anda fonksiyon tanımı da sona
erer.

Fonksiyonlarla ilgili öğrendiklerimizi toparladığımıza göre, gelin isterseniz
fonksiyonlarla ilgili bir örnek yaparak, bu yapıyı daha iyi anlamaya çalışalım:

```python
def sistem_bilgisi_göster():
 import sys
 print("\nSistemde kurulu Python'ın;")
 print("\tana sürüm numarası:", sys.version_info.major)
 print("\talt sürüm numarası:", sys.version_info.minor)
 print("\tminik sürüm numarası:", sys.version_info.micro)

 print("\nKullanılan işletim sisteminin;")
 print("\tadı:", sys.platform)

```

Buradasistem_bilgisi_göster()adlı bir fonksiyon tanımladık. Bu fonksiyonun
görevi, kullanıcının sistemindeki Python sürümü ve işletim sistemine dair
birtakım bilgiler vermektir.

Bu arada, bu kodlarda, daha önceki derslerimizde öğrendiğimizsysmodülünden
ve bu modül içindeki değişkenlerden yararlandığımızı görüyorsunuz. Bu kodlardasysmodülünün içindeki şu araçları kullandık:
1. version_info.major: Python’ın ana sürüm numarası (Örn. 3)
1. version_info.minor: Python’ın alt sürüm numarası (Örn. 4)
1. version_info.micro: Python’ın minik sürüm numarası (Örn. 0)
1. platform: Kullanılan işletim sisteminin adı (Örn. ‘win32’ veya ‘linux2’)

version_info.major: Python’ın ana sürüm numarası (Örn. 3)

version_info.minor: Python’ın alt sürüm numarası (Örn. 4)

version_info.micro: Python’ın minik sürüm numarası (Örn. 0)

platform: Kullanılan işletim sisteminin adı (Örn. ‘win32’ veya ‘linux2’)

Yukarıda tanımladığımız fonksiyonu nasıl çağıracağımızı biliyorsunuz:

```python
sistem_bilgisi_göster()

```

Bu fonksiyonun tanımını ve çağrısını eksiksiz bir program içinde gösterelim:

```python
def sistem_bilgisi_göster():
 import sys
 print("\nSistemde kurulu Python'ın;")
 print("\tana sürüm numarası:", sys.version_info.major)
 print("\talt sürüm numarası:", sys.version_info.minor)
 print("\tminik sürüm numarası:", sys.version_info.micro)

 print("\nKullanılan işletim sisteminin;")
 print("\tadı:", sys.platform)

sistem_bilgisi_göster()

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda şuna benzer bir çıktı
alacağız:

```python
Sistemde kurulu Python'ın;
 ana sürüm numarası: 3
 alt sürüm numarası: 3
 minik sürüm numarası: 0

Kullanılan işletim sisteminin;
 adı: linux

```

Demek ki bu kodların çalıştırıldığı sistem Python’ın 3.3.0 sürümünün kurulu
olduğu bir GNU/Linux işletim sistemi imiş…

### Fonksiyonlar Ne İşe Yarar?

Şimdiye kadar söylediklerimizden ve verdiğimiz örneklerden fonksiyonların ne işe
yaradığını anlamış olmalısınız. Ama biz yine de fonksiyonların faydası üzerine
birkaç söz daha söyleyelim. Böylece fonksiyonların ne işe yaradığı konusunda
aklımızda hiçbir şüphe kalmaz…

İsterseniz bir örnek üzerinden ilerleyelim.

Diyelim ki, bir sayının karesini bulan bir program yazmak istiyoruz. Şimdiye
kadarki bilgilerimizi kullanarak şöyle bir şey yazabiliriz:

```python
sayı = 12
çıktı = "{} sayısının karesi {} sayısıdır"
print(çıktı.format(sayı, sayı**2))

```

Yukarıdaki programı çalıştırdığımızda şöyle bir çıktı elde edeceğiz:

```python
12 sayısının karesi 144 sayısıdır

```

Gayet güzel. Şimdi şöyle bir durum hayal edin: Diyelim ki büyük bir program
içinde, farklı farklı yerlerde yukarıdaki işlemi tekrar tekrar yapmak
istiyorsunuz. Böyle bir durumda şöyle bir şey yazmanız gerekebilir:

```python
sayı = 12
çıktı = "{} sayısının karesi {} sayısıdır"
print(çıktı.format(sayı, sayı**2))

####programla ilgili başka kodlar###

sayı = 15
print(çıktı.format(sayı, sayı**2))

###programla ilgili başka kodlar###

sayı = 29
print(çıktı.format(sayı, sayı**2))

```

Buradaki sorun, aynı şeyleri tekrar tekrar yazmak zorunda kalmamızdır. Bu küçük
örnekte pek belli olmuyor olabilir, ama özellikle büyük programlarda aynı
kodların program içinde sürekli olarak tekrarlanması pek çok probleme yol açar.
Örneğin kodlarda bir değişiklik yapmak istediğinizde, tekrarlanan kısımları
bulup hepsinin üzerinde tek tek değişiklik yapmanız gerekir. Meselaçıktıadlı
değişkenin içeriğini değiştirmek isterseniz, yaptığınız değişiklik programınızın
pek çok kısmını etkileyebilir. Örneğin,çıktıdeğişkenini şu şekle
getirdiğinizi düşünün:

```python
çıktı = "{} sayısının karesi {}, karekökü {} sayısıdır"

```

Böyle bir durumda, program içinde geçen bütünprint(çıktı.format(sayı,sayı**2))satırlarını bulup, üçüncü{}işaretine ait işlemi parantez içine
eklemeniz gerekir. Tahmin edebileceğiniz gibi, son derece sıkıcı, yorucu ve
üstelik hata yapmaya açık bir işlemdir bu. İşte bu tür problemlere karşı
fonksiyonlar çok iyi bir çözümdür.

Yukarıda bahsettiğimiz kare bulma işlemi için şu şekilde basit bir fonksiyon
tanımlayabiliriz:

```python
def kare_bul():
 sayı = 12
 çıktı = "{} sayısının karesi {} sayısıdır"
 print(çıktı.format(sayı, sayı**2))

```

Bu fonksiyonu tanımladık. Şimdi de fonksiyonumuzu çağıralım:

```python
kare_bul()

```

Kodlarımız tam olarak şöyle görünüyor:

```python
def kare_bul():
 sayı = 12
 çıktı = "{} sayısının karesi {} sayısıdır"
 print(çıktı.format(sayı, sayı**2))

kare_bul()

```

Burada fonksiyonumuzdefkare_bul():satırıyla başlıyor,print(çıktı.format(sayı,sayı**2))satırıyla bitiyor. Daha sonra gelenkare_bul()kodu, girintinin dışında yer aldığı için fonksiyon tanımına ait
değildir.

Bu kodları bir dosyaya kaydedip çalıştırdığımızda alacağımız çıktı şu
olacaktır:

```python
12 sayısının karesi 144 sayısıdır

```

kare_bul()adlı fonksiyonu bir kez tanımladıktan sonra bu fonksiyonu
programınız içinde gereken her yerde çağırabilirsiniz:

```python
kare_bul()

####programla ilgili başka kodlar###

kare_bul()

###programla ilgili başka kodlar###

kare_bul()

```

Gördüğünüz gibikare_bul()adlı bu fonksiyon bizi pek çok zahmetten
kurtarıyor. Ancak bu fonksiyonun bir sorunu var. Bu fonksiyon ekrana yalnızca12 sayısının karesi 144 sayısıdırçıktısı verebiliyor. Buradaki problem,
fonksiyonun sadece12sayısı üzerinde işlem yapabilmesi. Şöyle bir düşününce,
bu çıktının ne kadar anlamsız olduğunu, aslında yukarıdaki fonksiyonun tamamen
gereksiz bir iş yaptığını rahatlıkla görebiliyoruz. Fonksiyonumuzun adıkare_bul. Ama dediğimiz gibi, fonksiyonumuz sadece12sayısının karesini
söyleyebiliyor. Halbuki mantık olarak fonksiyonumuzun, bütün sayıların karesini
söyleyebilmesini beklerdik.

> **Not**
> Bu arada, gördüğünüz gibi, yukarıdaki fonksiyon parametresiz bir
fonksiyondur. Dolayısıyla bu fonksiyonu çağırırken parantez içinde herhangi bir
değer belirtmiyoruz.

Not

Bu arada, gördüğünüz gibi, yukarıdaki fonksiyon parametresiz bir
fonksiyondur. Dolayısıyla bu fonksiyonu çağırırken parantez içinde herhangi bir
değer belirtmiyoruz.

Fonksiyonumuzun gerçek anlamda işlevli bir hale gelebilmesi için sadece tek bir
sayıyı değil, bütün sayıları inceleyebiliyor olması gerek. İşte fonksiyonumuza
bu yeteneği parametreler aracılığıyla kazandırabiliriz.

Dikkatlice bakın:

```python
def kare_bul(sayı):
 çıktı = "{} sayısının karesi {} sayısıdır"
 print(çıktı.format(sayı, sayı**2))

```

Fonksiyona parametre olarak nasıl bir isim verdiğinizin önemi yoktur. Parantez
içine parametre olarak istediğiniz kelimeyi yazabilirsiniz. Önemli olan,
parantez içinde fonksiyonun kaç parametre alacağını gösteren bir işaret
olmasıdır. Mesela yukarıdaki fonksiyonu şöyle de tanımlayabilirdik:

```python
def kare_bul(i):
 çıktı = "{} sayısının karesi {} sayısıdır"
 print(çıktı.format(i, i**2))

```

…veya şöyle:

```python
def kare_bul(osman):
 çıktı = "{} sayısının karesi {} sayısıdır"
 print(çıktı.format(osman, osman**2))

```

Elbette parametre adı olarak akılda kalıcı ve daha mantıklı bir seçim yapmak
işlerinizi kolaylaştıracaktır…

Şimdi de yukarıdaki fonksiyonu çağıralım:

```python
kare_bul(9)

```

Bu fonksiyonu çalıştırdığımızda şu çıktıyı alırız:

```python
9 sayısının karesi 81 sayısıdır

```

Bu fonksiyona parametre olarak hangi sayıyı verirseniz o sayının karesi
hesaplanacaktır. Örneğin:

```python
kare_bul(15)
kare_bul(25555)

```

Yine bu fonksiyonu programınız içinde gereken her yerde çağırabilirsiniz:

```python
kare_bul(17)

####programla ilgili başka kodlar###

kare_bul(21)

###programla ilgili başka kodlar###

kare_bul(54354)

```

Fonksiyonu oluşturan kodlarda herhangi bir değişiklik yapmak istediğinizde
sadece fonksiyon tanımının gövdesini değiştirmeniz yeterli olacaktır. Örneğin:

```python
def kare_bul(sayı):
 çıktı = "{} sayısının karesi {}, karekökü ise {} sayısıdır"
 print(çıktı.format(sayı, sayı**2, sayı**0.5))

```

Bu sayede sadece fonksiyon gövdesinde değişiklik yaparak, programın başka
kısımlarını hiç etkilemeden yolumuza devam edebiliyoruz.

Buraya kadar anlattıklarımız, fonksiyonların ne işe yaradığı ve bir program
yazarken neden fonksiyonlara ihtiyaç duyacağımız konusunda size bir fikir vermiş
olmalı. Eğer hala aklınızda fonksiyonların faydası konusunda bir şüphe kaldıysa,
fonksiyonların faydasını anlamanızı sağlayabilmek için size şöyle bir soru
sormama izin verin: Acaba ‘istihza’ kelimesinin kaç karakterden oluştuğunu nasıl
buluruz?

‘Elbettelen()fonksiyonunu kullanarak!’ dediğinizi duyar gibiyim. Gerçekten
de Python’da bir karakter dizisinin uzunluğunu bulmanın en iyi yolulen()fonksiyonunu kullanmaktır:

```python
>>> len("istihza")

7

```

Peki ya Python’dalen()diye bir fonksiyon olmasaydı ne yapacaktınız? Böyle
bir durumda, karakter dizilerinin uzunluğunu ölçmek için sizin bir yöntem icat
etmeniz gerekecekti. Mesela ‘istihza’ kelimesinin kaç karakterden oluştuğunu
bulmak için şöyle bir kod yazacaktınız:

```python
c = 0
for s in "istihza":
 c += 1
print(c)

```

Burada öncecadlı bir değişken tanımlayıp, bu değişkenin değerini0yaptık.
Bu değişken, uzunluğunu sorgulamak istediğimiz kelimenin kaç karakterden
oluştuğu bilgisini saklayacak.

Ardından birfordöngüsü tanımlıyoruz. Bu döngüde, ‘istihza’ kelimesindeki
her bir karakter içincdeğişkeninin değerini1sayı artırıyoruz. Böylece
döngü sonundacdeğişkeni ‘istihza’ kelimesi içinde kaç karakter olduğu
bilgisini tutmuş oluyor.

Son olarak dacdeğişkeninin nihai değerini ekrana yazdırıyoruz.

Bu kodları çalıştırdığınızda7cevabı alacaksınız. Demek ki ‘istihza’
kelimesinde7karakter varmış. Peki ‘istihza’ kelimesi yerine mesela
‘Afyonkarahisar’ kelimesi içinde kaç karakter olduğunu hesaplamak isterseniz ne
yapacaksınız? Elbette yukarıdaki kodları tekrar yazıp, ‘istihza’ kelimesini
‘Afyonkarahisar’ kelimesi ile değiştireceksiniz. Böylece bu kelimenin kaç
karakterden oluştuğunu bulmuş olacaksınız. Sorgulamak istediğiniz her kelime
için aynı şeyleri yapabilirsiniz…

Ne kadar verimsiz bir yöntem, değil mi?

Halbuki hiç bu tür şeylerle uğraşmaya gerek yok. Eğer Python bizelen()fonksiyonu gibi bir fonksiyon vermemiş olsaydı, kendilen()fonksiyonumuzu
icat edebilirdik. Dikkatlice bakın:

```python
def uzunluk(öğe):
 c = 0
 for s in öğe:
 c += 1
 print(c)

```

Böylece adıuzunlukolan bir fonksiyon tanımlamış olduk. Artık bir öğenin
uzunluğunu hesaplamak istediğimizde, bütün o kodları her defasında tekrar tekrar
yazmak yerine sadeceuzunluk()fonksiyonunu kullanabiliriz:

```python
uzunluk("istihza")
uzunluk("Afyonkarahisar")
uzunluk("Tarım ve Köyişleri Bakanlığı")

```

Üstelik bu fonksiyon yalnızca karakter dizilerinin değil öteki veri tiplerinin
de uzunluğunu hesaplayabilir:

```python
liste = ["ahmet", "mehmet", "veli"]
uzunluk(liste)

```

Verdiğimiz bu örnek bize hem gömülü fonksiyonların faydasını, hem de genel
olarak fonksiyonların ne işe yaradığını açıkça gösteriyor. Buna göre,len()benzeri gömülü fonksiyonlar tekerleği yeniden icat etme derdinden kurtarıyor
bizi. Örneğin Python geliştiricilerininlen()gibi bir fonksiyon tanımlamış
olmaları sayesinde, bir karakter dizisinin uzunluğunu hesaplamak için kendi
kendimize yöntem icat etmek zorunda kalmıyoruz. Ama eğer kendi yöntemimizi icat
etmemiz gerekirse, istediğimiz işlevi yerine getiren bir fonksiyon tanımlamamız
da mümkün.

Böylece temel olarak fonksiyonların ne işe yaradığını, neye benzediğini, nasıl
tanımlandığını ve nasıl çağrıldığını incelemiş olduk. Şimdi fonksiyonların biraz
daha derinine dalmaya başlayabiliriz.

### Parametreler ve Argümanlar

Şimdiye kadar yaptığımız örnekler sayesinde aslında parametrelerin neye
benzediğini ve ne işe yaradığını öğrenmiştik. Bu bölümde ise sizi ‘argüman’ adlı
bir kavramla tanıştırıp, argüman ile parametre arasındaki benzerlik ve
farklılıkları inceleyeceğiz. Bunun yanısıra, parametre kavramını da bu bölümde
daha derinlikli bir şekilde ele alacağız.

O halde hemen yola koyulalım.

Parametrenin ne olduğunu biliyorsunuz. Bunlar fonksiyon tanımlarken parantez
içinde belirttiğimiz, fonksiyon gövdesinde yapılan işin değişken öğelerini
gösteren parçalardır. Mesela:

```python
def kopyala(kaynak_dosya, hedef_dizin):
 çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!"
 print(çıktı.format(kaynak_dosya, hedef_dizin))

```

Buradakopyala()adlı bir fonksiyon tanımladık. Bu fonksiyon toplam iki adet
parametre alıyor:kaynak_dosyavehedef_dizin. Gördüğünüz gibi, bu iki
parametre gerçekten de fonksiyon gövdesinde yapılan işin değişken öğelerini
gösteriyor. Bu fonksiyonun üreteceği çıktı, fonksiyonu çağıran kişinin bu iki
parametreye vereceği değerlere bağlı olarak şekillenecek.

Bildiğiniz gibi, parametrelere ne ad verdiğinizin hiçbir önemi yok. Elbette
parametrenin görevine uygun bir isim vermeniz fonksiyonunuzun okunaklılığını
artıracaktır. Ama tabii ki bu fonksiyonu pekala şu parametrelerle de
tanımlayabilirdik:

```python
def kopyala(a, b):
 çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!"
 print(çıktı.format(a, b))

```

Burada önemli olan, parametre görevi görecek iki adet kelime bulmak. Bu
kelimelerin ne olduğunun önemi yok. Ama tabii kikaynak_dosyavehedef_dizinadları,avebadlarına kıyasla, fonksiyondaki parametrelerin yaptığı işi
çok daha iyi tarif ediyor.

Parametre adı belirleme kuralları değişken adı belirleme kurallarıyla aynıdır.
Dolayısıyla bir değişken adı belirlerken neye dikkat ediyorsak, parametre adı
belirlerken de aynı şeye dikkat etmeliyiz.

Gelin şimdi isterseniz tanımladığınız bu fonksiyonu çağıralım:

```python
kopyala("deneme.txt", "/home/istihza/Desktop")

```

Kodlarımız dosya içinde tam olarak şöyle görünüyor:

```python
def kopyala(kaynak_dosya, hedef_dizin):
 çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!"
 print(çıktı.format(kaynak_dosya, hedef_dizin))

kopyala("deneme.txt", "/home/istihza/Desktop")

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda şöyle bir çıktı alırız:

```python
deneme.txt adlı dosya /home/istihza/Desktop adlı dizin içine kopyalandı!

```

Gördüğünüz gibi,“deneme.txt”ve“/home/istihza/Desktop”değerleri,çıktıadlı karakter dizisinde uygun yerlere yerleştirildi ve ekrana çıktı olarak
verildi. İşte burada gördüğünüz bu“deneme.txt”ve“/home/istihza/Desktop”değerlerine argüman adı verilir. Yani bir fonksiyonutanımlarkenbelirlediğimiz adlara parametre, aynı fonksiyonuçağırırkenbelirlediğimiz
adlara ise argüman deniyor. Dolayısıyla fonksiyon tanımında belirlediğimizkaynak_dosyavehedef_dizinadlı değişkenler birer parametre, fonksiyon
çağrısında bu parametrelere karşılık gelen“deneme.txt”ve“/home/istihza/Desktop”değerleri ise birer argüman oluyor.

Böylece parametre ve argüman arasındaki farkı öğrenmiş olduk. Ancak şunu
belirtmekte yarar var: Bu iki kavram genellikle birbirinin yerine kullanılır.
Yani bu iki kavram arasındaki, yukarıda açıkladığımız farka pek kimse dikkat
etmez. Dolayısıyla pek çok yerde hem parametre hem de argüman için aynı ifadenin
kullanıldığını görebilirsiniz. Özellikle Türkçede parametre kelimesi argüman
kelimesine kıyasla daha bilinir ve yaygın olduğu için, ayrım yapılmaksızın hem
fonksiyon çağrısındaki değerlere, hem de fonksiyon tanımındaki değerlere
parametre adı verilir.

Gelelim parametrelerin çeşitlerine…

Python’da parametreler işlevlerine göre farklı kategorilere ayrılır. Gelin şimdi
bu kategorileri tek tek inceleyelim.

#### Sıralı (veya İsimsiz) Parametreler

Python’da şöyle bir fonksiyon tanımlayabileceğimizi biliyoruz:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

```

Yukarıda tanımladığımız bu fonksiyonu şu şekilde çağırabiliriz:

```python
kayıt_oluştur("Ahmet", "Öz", "Debian", "Ankara")

```

Bu fonksiyonda, yazdığımız parametrelerin sırası büyük önem taşır. Mesela
yukarıdaki fonksiyonu şöyle çağırdığımızı düşünün:

```python
kayıt_oluştur("Debian", "Ankara", "Öz", "Ahmet")

```

Eğer fonksiyon parametrelerini bu sırayla kullanırsak aldığımız çıktı hatalı
olacaktır:

```python
------------------------------
isim : Debian
soyisim : Ankara
işletim sistemi: Öz
şehir : Ahmet
------------------------------

```

Gördüğünüz gibi, isim, soyisim ve öteki bilgiler birbirine karışmış. İşte
Python’da, veriliş sırası önem taşıyan bu tür parametrelere ‘sıralı
parametreler’ (veya isimsiz parametreler) adı verilir.

#### İsimli Parametreler

Bir önceki bölümde verdiğimiz şu örneği yeniden ele alalım:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

```

Bu fonksiyonu çağırırken parametrelerin sırasını doğru vermenin, alacağımız
çıktının düzgün olması bakımından büyük önem taşıdığını biliyoruz. Ancak
özellikle parametre sayısının çok olduğu fonksiyonlarda parametre sırasını
akılda tutmak zor olabilir. Böyle durumlarda parametreleri isimleri ile birlikte
kullanmayı tercih edebiliriz:

```python
kayıt_oluştur(soyisim="Öz", isim="Ahmet", işsis="Debian", şehir= "Ankara")

```

Böylece fonksiyon parametrelerini istediğimiz sıra ile kullanabiliriz. Ancak
burada dikkat etmemiz gereken bazı noktalar var. Python’da isimli bir
parametrenin ardından sıralı bir parametre gelemez. Yani şu kullanım yanlıştır:

```python
kayıt_oluştur(soyisim="Öz", isim="Ahmet", "Debian", "Ankara")

```

Bu kodlar bize şu hatayı verir:

```python
 File "<stdin>", line 1
SyntaxError: non-keyword arg after keyword arg

```

Bu yüzden, eğer isimli parametreler kullanacaksak, isimli parametrelerden sonra
sıralı parametre kullanmamaya dikkat ediyoruz.

#### Varsayılan Değerli Parametreler

Şimdiye kadar karşılaştığımız fonksiyonlarda bir şey dikkatinizi çekmiş olmalı.
Meselaprint()fonksiyonunu ele alalım. Bildiğiniz gibi, bu fonksiyonu en
basit şekilde şöyle kullanıyoruz:

```python
print("Fırat", "Özgül")

```

Evet,print()fonksiyonunu bu şekilde kullanabiliyoruz, ancak bildiğiniz
gibi, aslında bu fonksiyonun bazı özel parametreleri de var. Daha önceki
derslerimizden hatırlayacağınız gibi, biz yukarıdaki komutu verdiğimizde aslında
Python bunu şu şekilde algılıyor:

```python
print("Fırat", "Özgül", sep=" ", end="\n", file=sys.stdout, flush=False)

```

Yani biz görmesek de aslında herprint()çağrısısep,end,fileveflushparametrelerini de içeriyor. Biz bu özel parametreleri kullanmasak da,
yazdığımız kod düzgün bir şekilde çalışır. Bunun nedeni,sep,end,fileveflushparametrelerinin öntanımlı olarak birtakım değerlere sahip olmasıdır.
Yani biz bu parametrelere kendimiz bir değer atamazsak Python bu parametrelere
kendi belirlediği bazı öntanımlı değerleri atayacaktır. Dolayısıyla, eğer biz
başka bir değer yazmazsak,sepparametresi“ “değerine,endparametresi“n”değerine,fileparametresisys.stdoutdeğerine,flushparametresi
iseFalsedeğerine sahip olacaktır. İşte bu tür parametrelere Python’da
‘varsayılan değerli parametreler’ adı verilir. Peki biz kendimiz varsayılan
değerli parametreler içeren fonksiyonları nasıl tanımlayabiliriz?

Şu örneğe dikkatlice bakın:

```python
def kur(kurulum_dizini="/usr/bin/"):
 print("Program {} dizinine kuruldu!".format(kurulum_dizini))

```

Buradakur()adlı bir fonksiyon tanımladık. Bu fonksiyonun görevi,
yazdığımız bir programı, kullanıcının bilgisayarındaki bir dizine kurmak ve
programın hangi dizine kurulduğu konusunda kullanıcıyı bilgilendirmek. Bu
fonksiyonu şu şekilde çağırabiliriz:

```python
kur()

```

Eğerkur()fonksiyonunu böyle çağırırsak bize şu çıktıyı verecektir:

```python
Program /usr/bin/ dizinine kuruldu!

```

Gördüğünüz gibi,kur()fonksiyonununkurulum_diziniadlı bir parametresi
var. Biz fonksiyonu tanımlarken, bu parametreye bir varsayılan değer atadık
(/usr/bin/). Böylecekur()fonksiyonu parametresiz olarak çağrıldığında bu
varsayılan değer devreye girdi. Eğer biz bu değeri değiştirmek istersek, mesela
programımızın “C:\Users\firat” dizinine kurulmasını istersek,kur()fonksiyonunu şöyle çağırmalıyız:

```python
kur("C:\\Users\\firat")

```

kur()fonksiyonunu yukarıdaki gibi çağırdığımızda Python bize şöyle bir
çıktı verir:

```python
Program C:\Users\firat dizinine kuruldu!

```

Bu örnek size, varsayılan değerli parametreler belirlemenin ne kadar faydalı
olabileceğini göstermiş olmalı. Mesela bir program yazdığınızı düşünün.
Programınızı indiren kullanıcılar, yukarıdaki gibi bir varsayılan değerli
parametre belirlemiş olmanız sayesinde programınızı nereye kuracaklarını
belirlemek zorunda kalmadan bir sonraki kurulum adımına geçebiliyorlar…

Elbette eğer isterseniz kullanıcılarınızı bir kurulum dizini belirlemeye
zorlamak da isteyebilirsiniz. Bunun için yine varsayılan değerli parametrelerden
yararlanabilirsiniz:

```python
def kur(kurulum_dizini=''):
 if not kurulum_dizini:
 print("Lütfen programı hangi dizine kurmak istediğinizi belirtin!")
 else:
 print("Program {} dizinine kuruldu!".format(kurulum_dizini))

```

Bu defakurulum_diziniparametresinin varsayılan değerini boş bir karakter
dizisi olarak belirledik. Eğer bu parametrenin değeri boş bir karakter dizisi
olursa, kullanıcı herhangi bir kurulum dizini belirtmemiş demektir. Eğer
kullanıcı herhangi bir kurulum dizini belirtmezsekurulum_diziniparametresinin bool değeriFalseolacaktır. Bu özelliği dikkate alarak
fonksiyon gövdesinde şu kodları kullanabiliyoruz:

```python
if not kurulum_dizini:
 print("Lütfen programı hangi dizine kurmak istediğinizi belirtin!")

```

Böylece,kurulum_diziniparametresinin bool değeriFalseolursa
kullanıcılarımıza şöyle bir uyarı gösteriyoruz:

```python
"Lütfen programı hangi dizine kurmak istediğinizi belirtin!"

```

Dolayısıyla kuruluma başlayabilmek içinkur()fonksiyonunun şöyle
çalıştırılmasını zorunlu tutuyoruz:

```python
kur("C:\\Users\\istihza")

```

Buna benzer durumlarla pek çok kez karşılaşmış olmalısınız. Özellikle
programların kurulmasını sağlayan ‘setup’ betiklerinde her aşama için bir
varsayılan değer belirlenip, kullanıcının sadece ‘Next’ tuşlarına basarak
sağlıklı bir kurulum yapması sağlanabiliyor. Eğer kullanıcı varsayılan
değerlerin dışında birtakım değerler belirlemek isterse, yukarıda örneğini
verdiğimiz yapı kullanıcıya böyle bir özgürlük de sağlıyor.

#### Rastgele Sayıda İsimsiz Parametre Belirleme

Şimdiye kadar öğrendiğimiz pek çok fonksiyonun toplam kaç parametre alabileceği
bellidir. Örneğininput()fonksiyonu yalnızca tek bir parametre alabilir.
Eğer bu fonksiyona birden fazla parametre verirsek Python bize bir hata mesajı
gösterecektir. Aynı şekilde meselapow()fonksiyonunun da kaç parametre
alabileceği bellidir. Ama örneğinprint()fonksiyonuna verebileceğimiz
parametre sayısı (teknik olarak 256 ile sınırlı olsa da) pratik olarak neredeyse
sınırsızdır.

Peki acaba biz kendimiz, sınırsız parametre alabilen fonksiyonlar üretebilir
miyiz?

Bu sorunun cevabı ‘evet’ olacaktır. Şimdi şu örneğe dikkatlice bakın:

```python
def fonksiyon(*parametreler):
 print(parametreler)

fonksiyon(1, 2, 3, 4, 5)

```

Bu kodları çalıştırdığımızda şu çıktıyı alacağız:

```python
(1, 2, 3, 4, 5)

```

Gördüğünüz gibi, fonksiyon tanımı içinde kullandığımız*işareti sayesinde
fonksiyonumuzun pratik olarak sınırsız sayıda parametre kabul etmesini
sağlayabiliyoruz. Bu arada, bu tür fonksiyonların alabileceği parametre sayısı,
dediğimiz gibi, pratikte sınırsızdır, ama teknik olarak bu sayı 256 adedi
geçemez.

Yukarıdaki kodların verdiği çıktının bir demet olduğuna dikkatinizi çekmek
isterim. Bu bilgiye sahip olduktan sonra, bu tür fonksiyonları demet işleme
kurallarına göre istediğiniz şekilde manipüle edebilirsiniz.

Peki böyle bir fonksiyon tanımlamak ne işimize yarar?

Mesela bu yapıyı kullanarak şöyle bir fonksiyon yazabilirsiniz:

```python
def çarp(*sayılar):
 sonuç = 1
 for i in sayılar:
 sonuç *= i
 print(sonuç)

```

Bu fonksiyon kendisine verilen bütün parametreleri birbiriyle çarpar. Örneğin:

```python
çarp(1, 2, 3, 4)

```

Bu kodun çıktısı24olacaktır. Gördüğünüz gibi, fonksiyonumuza istediğimiz
sayıda parametre vererek bu sayıların birbiriyle çarpılmasını sağlayabiliyoruz.

Aslında burada kullandığımız*işareti size hiç yabancı değil. Hatırlarsanızprint()fonksiyonundan bahsederken şuna benzer bir kullanım örneği
vermiştik:

```python
>>> print(*'TBMM', sep='.')

T.B.M.M

```

Burada*işareti, eklendiği parametreyi öğelerine ayırıyor.sepparametresi
ise*işaretinin birbirinden ayırdığı öğelerin arasına birer ‘.’ karakteri
ekliyor.

Bu işaretin etkilerini şu örneklerde daha net görebilirsiniz:

```python
>>> liste = ["Ahmet", "Mehmet", "Veli"]
>>> print(*liste)

Ahmet Mehmet Veli

>>> sözlük = {"a": 1, "b": 2}
>>> print(*sözlük)

a b

```

Gördüğünüz gibi,*işareti herhangi bir öğeyi alıp, bunu parçalarına ayırıyor.
İşte bu*işaretini fonksiyon tanımlarken kullandığımızda ise bu işlemin tam
tersi gerçekleşiyor. Yani fonksiyon tanımında parametrenin soluna*getirdiğimizde, bu fonksiyon çağrılırken verilen argümanlar tek bir değişken
içinde bir demet olarak toplanıyor. Zaten bu konunun başında verdiğimiz şu
örnekte de bu durum açıkça görünüyor:

```python
def fonksiyon(*parametreler):
 print(parametreler)

fonksiyon(1, 2, 3, 4, 5)

```

Bu fonksiyonu çağırdığımızda şu çıktı veriliyor:

```python
(1, 2, 3, 4, 5)

```

Aynen söylediğimiz gibi,fonksiyon()adlı fonksiyona argüman olarak
verdiğimiz her bir öğenin (1,2,3,4,5) tek bir demet içinde
toplandığını görüyorsunuz.

Yıldızlı parametreler, tanımladığınız fonksiyonun parametre sayısını herhangi
bir şekilde sınırlamak istemediğiniz durumlarda çok işinize yarar.

Elbette*işaretiyle birlikte kullanacağınız parametrenin adı olarak,
Python’ın değişken adlandırma kurallarına uygun bütün kelimeleri
belirleyebilirsiniz. Mesela biz yukarıda ‘parametreler’ adını tercih ettik. Ama
Python dünyasında*işaretiyle birlikte kullanılacak parametrenin adı
geleneksel olarak, ‘argümanlar’ anlamında ‘args’tır. Yani Python programcıları
genellikle yukarıdaki gibi bir fonksiyonu şöyle tanımlar:

```python
def fonksiyon(*args):
 ...

```

*işareti ile birlikte kullanılacak parametrenin adını ‘args’ yapmak bir
zorunluluk olmamakla birlikte, başka Python programcılarının kodlarınızı daha
kolay anlayabilmesi açısından bu geleneği devam ettirmenizi tavsiye ederim.
Yazdığımız kodlarda Python programlama dilinin geleneklerine bağlı kalmak
çoğunlukla iyi bir alışkanlıktır.

#### Rastgele Sayıda İsimli Parametre Belirleme

Bir önceki başlık altında, fonksiyon tanımlarken rastgele sayıda isimsiz
parametrelerin nasıl belirleneceğini tartıştık. Aynı bu şekilde, rastgele sayıdaisimliparametre belirlemek de mümkündür.

Örneğin:

```python
def fonksiyon(**parametreler):
 print(parametreler)

fonksiyon(isim="Ahmet", soyisim="Öz", meslek="Mühendis", şehir="Ankara")

```

Bu kodları çalıştırdığımızda şöyle bir çıktı alıyoruz:

```python
{'isim': 'Ahmet', 'soyisim': 'Öz', 'meslek': 'Mühendis', 'şehir': 'Ankara'}

```

Gördüğünüz gibi, fonksiyonu tanımlarken parametremizin sol tarafına
yerleştirdiğimiz**işareti, bu fonksiyonu çağırırken yazdığımız isimli
parametrelerin bize bir sözlük olarak verilmesini sağlıyor. Bu yapının bize bir
sözlük verdiğini bildikten sonra, bunu sözlük veri tipinin kuralları
çerçevesinde istediğimiz şekilde evirip çevirebiliriz.

Peki bu araç ne işimize yarar?

Hatırlarsanız bu bölümün en başındakayıt_oluştur()adlı şöyle bir fonksiyon
tanımlamıştık:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

```

Bu fonksiyon bize toplam dört adet parametre kullanarak, isim, soyisim, işletim
sistemi ve şehir bilgilerinden meydana gelen bir kayıt oluşturma imkanı
sağlıyor. Bu fonksiyonda kullanıcının girebileceği bilgiler sınırlı. Ama bir de
şöyle bir fonksiyon yazdığımızı düşünün:

```python
def kayıt_oluştur(**bilgiler):
 print("-"*30)

 for anahtar, değer in bilgiler.items():
 print("{:<10}: {}".format(anahtar, değer))

 print("-"*30)

kayıt_oluştur(ad="Fırat", soyad="Özgül", şehir="İstanbul", tel="05333213232")

```

Bu fonksiyonu çalıştırdığımızda şu çıktıyı alacağız:

```python
tel : 05333213232
ad : Fırat
şehir : İstanbul
soyad : Özgül

```

Gördüğünüz gibi,**işaretlerini kullanmamız sayesinde hem adlarını hem de
değerlerini kendimiz belirlediğimiz bir kişi veritabanı oluşturma imkanı elde
ediyoruz. Üstelik bu veritabanının, kişiye ait kaç farklı bilgi içereceğini de
tamamen kendimiz belirleyebiliyoruz.

Tıpkı*işaretlerinin betimlediği parametrenin geleneksel olarak ‘args’
şeklinde adlandırılması gibi,**işaretlerinin betimlediği parametre de
geleneksel olarak ‘kwargs’ şeklinde adlandırılır. Dolayısıyla yukarıdaki gibi
bir fonksiyonu Python programcıları şöyle tanımlar:

```python
def kayıt_oluştur(**kwargs):
 ...

```

**işaretli parametreler pek çok farklı durumda işinize yarayabilir veya
işinizi kolaylaştırabilir. Mesela*ve**işaretlerini kullanarak şöyle bir
program yazabilirsiniz:

```python
def karşılık_bul(*args, **kwargs):
 for sözcük in args:
 if sözcük in kwargs:
 print("{} = {}".format(sözcük, kwargs[sözcük]))
 else:
 print("{} kelimesi sözlükte yok!".format(sözcük))

sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

karşılık_bul("kitap", "bilgisayar", "programlama", "fonksiyon", **sözlük)

```

Burada tanımladığımızkarşılık_bul()adlı fonksiyon, kendisine verilen
parametreleri (*args), bir sözlük içinde arayarak (**sözlük) karşılıklarını
bize çıktı olarak veriyor. Eğer verilen parametre sözlükte yoksa, ilgili
kelimenin sözlükte bulunmadığı konusunda da bizi bilgilendiriyor.

karşılık_bul()adlı fonksiyonu nasıl tanımladığımıza çok dikkat edin.
Parametre listesi içinde belirttiğimiz*argsifadesi sayesinde, fonksiyonu
kullanacak kişiye, istediği sayıda isimsiz parametre girme imkanı tanıyoruz.**kwargsparametresi ise kullanıcıya istediği sayıda isimli parametre girme
olanağı veriyor.

Esasında yukarıdaki kod*argsve**kwargsyapıları açısından ucuz bir
örnektir. Bu yapılar için daha nitelikli bir örnek verelim…

Bildiğiniz gibiprint()fonksiyonu sınırsız sayıda isimsiz parametre ve buna
ek olarak birkaç tane de isimli parametre alıyor. Bu fonksiyonun alabildiği
isimli parametrelerinsep,end,fileveflushadlı parametreler olduğunu
biliyorsunuz. Yine bildiğiniz gibi,sepparametresiprint()fonksiyonuna
verilen isimsiz parametrelerin her birinin arasına hangi karakterin geleceğini;endparametresi ise bu parametrelerin en sonuna hangi karakterin geleceğini
belirliyor. Bizim amacımız bu fonksiyona bir destartadında isimli bir
parametre ekleyerekprint()fonksiyonunun işlevini genişleten başka bir
fonksiyon yazmak. Bu yeni parametre, karakter dizilerininen başınahangi
karakterin geleceğini belirleyecek.

Şimdi bu amacımızı gerçekleştirecek kodlarımızı yazalım:

```python
def bas(*args, start='', **kwargs):
 for öğe in args:
 print(start+öğe, **kwargs)

bas('öğe1', 'öğe2', 'öğe3', start="#.")

```

print()fonksiyonunun işlevini genişleten yeni fonksiyonumuzun adıbas(). Bu fonksiyon her bakımdanprint()fonksiyonu ile aynı işlevi
görecek. Ancakbas()fonksiyonu,print()fonksiyonuna ek olarak, sahip
olduğustartadlı bir isimli parametre sayesinde, kendisine verilen
parametrelerinen başınaistediğimiz herhangi bir karakteri ekleme
olanağı da verecek bize.

bas()fonksiyonunun ilk parametresi olan*argssayesinde kullanıcıya
istediği kadar parametre verme imkanı tanıyoruz. Daha sonra da ilavestartparametresini tanımlıyoruz. Bu parametrenin öntanımlı değeri boş bir karakter
dizisi. Yani eğer kullanıcı bu parametrenin değerine herhangi bir şey yazmazsa,*argskapsamında verilen parametreler üzerinde hiçbir değişiklik yapmıyoruz.
Bunun ardından gelen**kwargsparametresi iseprint()fonksiyonunun
halihazırda sahip olduğusep,end,fileveflushparametrelerininbas()fonksiyonunda da aynı şekilde kullanılmasını sağlıyor.**kwargsşeklinde bir tanımlama sayesinde,print()fonksiyonunun isimli
parametrelerini tek tek belirtip tanımlamak zorunda kalmıyoruz:

```python
def bas(*args, start='', **kwargs):
 for öğe in args:
 print(start+öğe, **kwargs)

f = open("te.txt", "w")

bas('öğe1', 'öğe2', 'öğe3', start="#.", end="", file=f)

```

Eğer elimizde**kwargsgibi bir imkan olmasaydı yukarıdaki fonksiyonu şu
şekilde tanımlamamız gerekirdi:

```python
import sys

def bas(*args, start='', sep=' ', end='\n', file=sys.stdout, flush=False):
 for öğe in args:
 print(start+öğe, sep=sep, end=end, file=file, flush=flush)

```

Gördüğünüz gibi,print()fonksiyonunun bütün isimli parametrelerini ve
bunların öntanımlı değerlerini tanımlamak zorunda kaldık. Eğer günün birinde
Python geliştiricileriprint()fonksiyonuna bir başka isimli parametre daha
eklerse, yukarıdaki fonksiyonu ilgili yeniliğe göre elden geçirmemiz gerekir.
Ama**kwargsyapısını kullandığımızda,print()fonksiyonuna Python
geliştiricilerince eklenecek bütün parametreler bizim fonksiyonumuza da otomatik
olarak yansıyacaktır…

### return Deyimi

Bu bölümdereturnadlı bir deyimden söz edeceğiz. Özellikle Python
programlama dilini öğrenmeye yeni başlayanlar bu deyimin ne işe yaradığını
anlamakta zorlanabiliyor. Biz burada bu deyimi anlaşılır hale getirebilmek için
elimizden geleni yapacağız. Öncelikle çok basit bir örnek verelim:

```python
def ismin_ne():
 isim = input("ismin ne? ")
 print(isim)

```

Bu çok basit bir fonksiyon. Bu fonksiyonu nasıl çağıracağımızı biliyoruz:

```python
ismin_ne()

```

Fonksiyonu bu şekilde çağırdıktan sonra, fonksiyon tanımında yer alaninput()fonksiyonu sayesinde kullanıcıya ismi sorulacak ve verdiği cevap
ekrana basılacaktır.

Yukarıdaki fonksiyonun tek işlevi kullanıcıdan aldığı isim bilgisini ekrana
basmaktır. Aldığınız bu veriyi başka yerlerde kullanamazsınız. Bu fonksiyonu
çağırdığınız anda kullanıcıya ismi sorulacak ve alınan cevap ekrana
basılacaktır. Ancak siz, tanımladığınız fonksiyonların tek görevinin bir veriyi
ekrana basmak olmasını istemeyebilirsiniz.

Örneğin yukarıdaki fonksiyon yardımıyla kullanıcıdan ismini aldıktan sonra, bu
isim bilgisini başka bir karakter dizisi içinde kullanmak isteyebilirsiniz.
Diyelim ki amacınızismin_ne()fonksiyonuyla aldığınız ismi şu karakter
dizisi içine aşağıdaki şekilde yerleştirmek:

```python
Merhaba Fırat. Nasılsın?

```

Bildiğimiz yöntemi kullanarak bu amacımızı gerçekleştirmeye çalışalım:

```python
print("Merhaba {}. Nasılsın?".format(ismin_ne()))

```

Buradan şöyle bir çıktı alıyoruz:

```python
ismin ne? Fırat
Fırat
Merhaba None. Nasılsın?

```

Gördüğünüz gibi, istediğimiz şeyi elde edemiyoruz. Çünkü dediğimiz gibi,
yukarıdaki fonksiyonun tek görevi kullanıcıdan aldığı çıktıyı ekrana basmaktır.
Bu fonksiyondan gelen çıktıyı başka yerde kullanamayız. Eğer kullanmaya
çalışırsak yukarıdaki gibi hiç beklemediğimiz bir sonuç alırız.

Bu arada, çıktıdaNonediye bir şey gördüğünüze dikkat edin. Yukarıdaki
fonksiyonu şu şekilde çağırarak bunu daha net görebilirsiniz:

```python
print(ismin_ne())

```

Buradan şu çıktıyı alıyoruz:

```python
ismin ne? Fırat
Fırat
None

```

Bu çıktının ne anlama geldiğini birazdan açıklayacağız. Ama öncelikle başka bir
konudan söz edelim.

Biraz önce söylediğimiz gibi, yukarıda tanımladığımızismin_ne()adlı
fonksiyonun tek görevi kullanıcıdan aldığı isim bilgisini ekrana basmaktır.
Şimdi bu fonksiyonu bir de şöyle tanımlayalım:

```python
def ismin_ne():
 isim = input("ismin ne? ")
 return isim

```

Şimdi de bu fonksiyonu çağıralım:

```python
ismin_ne()

```

Gördüğünüz gibi, fonksiyonu çağırdığımızda yalnızca fonksiyon gövdesindekiinput()fonksiyonu çalıştı, ama bu fonksiyondan gelen veri ekrana çıktı
olarak verilmedi. Çünkü biz burada herhangi bir ekrana basma (‘print’) işlemi
yapmadık. Yaptığımız tek şeyisimadlı değişkeni ‘döndürmek’.

Peki bu ne anlama geliyor?

returnkelimesi İngilizcede ‘iade etmek, geri vermek, döndürmek’ gibi anlamlar
taşır. İşte yukarıdaki örnekte dereturndeyiminin yaptığı iş budur. Yani bu
deyim bize fonksiyondan bir değer ‘döndürür’.

Eğer tanımladığımız bir fonksiyondareturndeyimini kullanarak herhangi bir
değer döndürmezsek, Python fonksiyondan hususi bir değerin döndürülmediğini
göstermek için ‘None’ adlı bir değer döndürür… İşte yukarıda tanımladığımız
ilkismin_ne()fonksiyonunuprint(ismin_ne())şeklinde çağırdığımızda
ekrandaNonedeğerinin görünmesinin nedeni budur.

Peki bir fonksiyon içinde herhangi bir veriyi ekrana basmayıpreturndeyimi
yardımıyla döndürmemizin bize ne faydası var?

Aslında bunun cevabı çok açık. Bir fonksiyon içinde bir değeri döndürmek yerine
ekrana bastığınızda o fonksiyonun işlevini alabildiğine kısıtlamış oluyorsunuz.
Fonksiyonunuzun tek işlevi bir değeri ekrana basmak oluyor. Şu örnekte de
gösterdiğimiz gibi, bu değeri daha sonra başka ortamlarda kullanamıyoruz:

```python
def ismin_ne():
 isim = input("ismin ne? ")
 print(isim)

print("Merhaba {}. Nasılsın?".format(ismin_ne()))

```

Ama eğer, mesela yukarıdaki fonksiyondaisimdeğişkenini basmak yerine
döndürürsek işler değişir:

```python
def ismin_ne():
 isim = input("ismin ne? ")
 return isim

print("Merhaba {}. Nasılsın?".format(ismin_ne()))

```

Bu kodları çalıştırdığımızda şu çıktıyı alıyoruz:

```python
.. code-block:: pycon

```

ismin ne? Fırat
Merhaba Fırat. Nasılsın?

Gördüğünüz gibi, istediğimiz çıktıyı rahatlıkla elde ettik.ismin_ne()adlı
fonksiyondanisimdeğerini döndürmüş olmamız sayesinde bu değerle istediğimiz
işlemi gerçekleştirebiliyoruz. Yani bu değeri sadece ekrana basmakla
sınırlamıyoruz kendimizi. Hatta fonksiyondan döndürdüğümüz değeri başka bir
değişkene atama imkanına dahi sahibiz bu şekilde:

```python
ad = ismin_ne()
print(ad)

```

Eğer fonksiyondan değer döndürmek yerine bu değeri ekrana basmayı tercih
etseydik yukarıdaki işlemi yapamazdık.

returndeyimiyle ilgili son bir şey daha söyleyelim…

Bu deyim, içinde bulunduğu fonksiyonun çalışma sürecini kesintiye uğratır. Yanireturndeyimini kullandığınız satırdan sonra gelen hiçbir kod çalışmaz.
Basit bir örnek verelim:

```python
def fonk():
 print(3)
 return
 print(5)

fonk()

```

Bu kodları çalıştırdığınızda yalnızcaprint(3)satırının çalıştığını,print(5)satırına ise hiç ulaşılmadığını göreceksiniz. İşte bu durumun
sebebi, Python’ın kodlarıreturnsatırından itibaren okumayı bırakmasıdır.
Bu özellikten çeşitli şekillerde yararlanabilirsiniz. Örneğin:

```python
def fonk(n):
 if n < 0:
 return 'eksi değerli sayı olmaz!'
 else:
 return n

f = fonk(-5)
print(f)

```

Burada eğer fonksiyona parametre olarak eksi değerli bir sayı verilirse Python
bize bir uyarı verecek ve fonksiyonun çalışmasını durduracaktır.

### Örnek bir Uygulama

Gelin isterseniz buraya kadar öğrendiklerimizi kullanarak örnek bir uygulama
yazalım. Bir yandan da yeni şeyler öğrenerek bilgimize bilgi katalım.

Amacımız belli miktarda ve belli aralıkta rastgele sayılar üreten bir program
yazmak. Örneğin programımız şu şekilde altı adet rastgele sayı üretebilecek:

```python
103, 298, 152, 24, 91, 285

```

Ancak programımız bu sayıları üretirken her sayıdan yalnızca bir adet üretecek.
Yani aynı seride bir sayıdan birden fazla bulunamayacak.

Dilerseniz öncelikle kodlarımızı görelim:

```python
import random

def sayı_üret(başlangıç=0, bitiş=500, adet=6):
 sayılar = set()

 while len(sayılar) < adet:
 sayılar.add(random.randrange(başlangıç, bitiş))

 return sayılar

```

Esasında bu kodların (neredeyse) tamamını anlayabilecek kadar Python bilgisine
sahipsiniz. Burada anlamamış olabileceğiniz tek şeyrandommodülüdür. O yüzden
gelin isterseniz bu modülden biraz söz edelim.

Biz henüz modül kavramını bilmiyoruz. Ama buraya gelene kadar birkaç konu
altında modüllerle ilgili bazı örnekler de yapmadık değil. Örneğin şimdiye kadar
yazdığımız programlardan öğrendiğimiz kadarıyla Python’daosvesysadlı iki
modülün bulunduğunu, bu modüllerin içinde, program yazarken işimize yarayacak
pek çok değişken ve fonksiyon bulunduğunu ve bu fonksiyonları programlarımızda
kullanabilmek için ilkin bu modülleri içe aktarmamız gerektiğini biliyoruz. İşte
tıpkıosvesysgibi,randomda Python programlama dili bünyesinde bulunan
modüllerden biridir. Bu modülün içinde, rastgele sayılar üretmemizi sağlayacak
bazı fonksiyonlar bulunur. İşterandrange()de bu fonksiyonlardan biridir.
Dilerseniz bu fonksiyonun nasıl kullanıldığını anlamak için etkileşimli kabukta
birkaç deneme çalışması yapalım.

randommodülünün içindeki araçları kullanabilmek için öncelikle bu modülü içe
aktarmalıyız:

```python
>>> import random

```

Acaba bu modülün içinde neler varmış?

```python
>>> dir(random)

['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random',
'SG_MAGICCONST', 'SystemRandom', 'TWOPI', '_BuiltinMethodType',
'_MethodType', '_Sequence', '_Set', '__all__', '__builtins__',
'__cached__', '__doc__', '__file__', '__initializing__',
'__loader__', '__name__', '__package__', '_acos', '_ceil',
'_cos', '_e', '_exp', '_inst', '_log', '_pi', '_random', '_sha512',
'_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_warn',
'betavariate', 'choice', 'expovariate', 'gammavariate', 'gauss',
'getrandbits', 'getstate', 'lognormvariate', 'normalvariate',
'paretovariate', 'randint', 'random', 'randrange', 'sample',
'seed', 'setstate', 'shuffle', 'triangular', 'uniform',
'vonmisesvariate', 'weibullvariate']

```

Gördüğünüz gibi bu modülün içinde epey araç var. Gelin isterseniz bu araçlardan
en sık kullanılanlarını tanıyalım.

Örneğinrandommodülü içinde bulunansample()adlı fonksiyon herhangi bir
dizi içinden istediğimiz sayıda rastgele numune almamızı sağlar:

```python
>>> liste = ["ahmet", "mehmet", "sevgi", "sevim", "selin", "zeynep", "selim"]
>>> random.sample(liste, 2)

['sevim', 'ahmet']

```

Gördüğünüz gibi, yedi kişilik bir isim listesinden2adet rastgele numune
aldık. Aynı işlemi tekrarlayalım:

```python
>>> random.sample(liste, 2)

['sevgi', 'zeynep']

>>> random.sample(liste, 5)

['selin', 'zeynep', 'ahmet', 'selim', 'mehmet']

```

Numune alma işlemi tamamen rastgeledir. Ayrıca gördüğünüz gibi, listeden
istediğimiz sayıda numune alabiliyoruz.

randommodülü içinde bulunanshuffle()adlı başka bir fonksiyon, bir dizi
içindeki öğelerin sırasını rastgele bir şekilde karıştırmamızı sağlar:

```python
>>> liste = ["ahmet", "mehmet", "sevgi", "sevim",
... "selin", "zeynep", "selim"]
>>> random.shuffle(liste)

```

shuffle()fonksiyonu liste öğelerini yine aynı liste içinde değiştirdi.
Değişikliği görmek için listeyi ekrana basabilirsiniz:

```python
>>> liste

['selim', 'selin', 'ahmet', 'mehmet',
'sevim', 'sevgi', 'zeynep']

```

randommodülü içinde bulunan bir başka fonksiyon iserandrange()fonksiyonudur. Bu fonksiyon, belli bir aralıkta rastgele sayılar üretmemizi
sağlar:

```python
>>> random.randrange(0, 500)

156

```

Burada0ile500arasında rastgele bir sayı ürettik.

Gördüğünüz gibirandomson derece faydalı olabilecek bir modüldür. Dilerseniz
şimdirandommodülünü bir kenara bırakıp kodlarımıza geri dönelim:

```python
import random

def sayı_üret(başlangıç=0, bitiş=500, adet=6):
 sayılar = set()

 while len(sayılar) < adet:
 sayılar.add(random.randrange(başlangıç, bitiş))

 return sayılar

```

Burada ilk satırın ne iş yaptığını öğrendik. Bu satır yardımıylarandommodülünü içe aktarıyoruz.

Sonraki satırda fonksiyonumuzu tanımlamaya başlıyoruz:

```python
def sayı_üret(başlangıç=0, bitiş=500, adet=6):
 ...

```

Fonksiyonumuzun adısayı_üret. Bu fonksiyon toplam üç farklı parametre alıyor.
Bunlarbaşlangıç,bitişveadet. Dikkat ederseniz bu parametrelerin her
birinin bir varsayılan değeri var. Dolayısıylasayı_üret()fonksiyonu
parametresiz olarak çağrıldığında bu üç parametre öntanımlı değerlerine sahip
olacaktır.

Gelelim fonksiyon gövdesine…

İlk olaraksayılaradlı bir küme tanımlıyoruz.

Bildiğiniz gibi, kümeler içinde öğeler her zaman tektir. Yani bir küme içinde
aynı öğeden yalnızca bir adet bulunabilir. Kümelerin bu özelliği bizim
yazdığımız program için oldukça uygun. Çünkü biz de ürettiğimiz rastgele
sayıların benzersiz olmasını istiyoruz. Bu benzersizliği sağlayabilecek en uygun
veri tipi kümelerdir.

Bir sonraki satırda birwhiledöngüsü görüyoruz:

```python
while len(sayılar) < adet:
 sayılar.add(random.randrange(başlangıç, bitiş))

```

Bu döngüye göre,sayılardeğişkeninin uzunluğuadetparametresinin
değerinden az olduğu müddetçe,sayılaradlı değişkenebaşlangıçvebitişparametrelerinin gösterdiği değerler arasından rastgele sayılar eklemeye devam
edeceğiz. Örneğin kullanıcı fonksiyonumuzu parametresiz olarak çağırdıysa,
yukarıdaki döngü şu şekilde işleyecektir:

```python
while len(sayılar) < 6:
 sayılar.add(random.randrange(0, 500))

```

Buna göre,sayılardeğişkeninin uzunluğu6’dan az olduğu müddetçe bu
değişkene0ile500arasında rastgele sayılar eklemeye devam edeceğiz.
Böyleliklesayılardeğişkeni içinde birbirinden farklı toplam6sayı olmuş
olacak.

Fonksiyonun son satırında ise şu kodu görüyoruz:

```python
return sayılar

```

Bu kod yardımıyla, belirtilen miktardaki sayıları tutansayılaradlı değişkeni
fonksiyondan döndürüyoruz. Yani fonksiyonumuz dış dünyayasayılaradlı bir
değişken veriyor… Bu değişkeni bu şekilde döndürdükten sonra istediğimiz gibi
kullanabiliriz. Mesela:

```python
for i in range(100):
 print(sayı_üret())

```

Buradan şuna benzer bir çıktı alacaksınız:

```python
{34, 144, 211, 468, 58, 286}
{41, 170, 395, 113, 178, 29}
{161, 195, 452, 271, 212, 324}
{1, 328, 461, 398, 464, 220}
{356, 489, 12, 114, 329, 472}
{320, 34, 238, 176, 243, 149}
{364, 304, 434, 403, 217, 63}
{452, 392, 175, 464, 81, 467}
{36, 230, 21, 440, 287, 415}
{292, 391, 145, 182, 440, 223}
{386, 38, 309, 377, 59, 277}
{0, 2, 42, 400, 404, 60}
{48, 482, 393, 80, 116, 407}
{483, 136, 431, 35, 344, 381}
...

```

Gördüğünüz gibi,sayı_üret()fonksiyonunu kullanarak, her biri6öğeden
oluşan100adet sayı listesi elde ettik. Biz yukarıda bu fonksiyonu
parametresiz olarak çalıştırdığımız için, Pythonbaşlangıç,bitişveadetparametrelerinin öntanımlı değerlerini kullandı (sırasıyla0,500ve6).

İstersek biz fonksiyonumuzu farklı parametrelerle çağırabiliriz:

```python
print(sayı_üret(0, 100, 10))

```

Bu kodlar bize0ile100arasından10adet rastgele sayı seçer:

```python
{3, 4, 9, 11, 13, 47, 50, 53, 54, 61}

```

Eğer çıktının küme parantezleri arasında görünmesini istemiyorsanız elbette
çıktıyı keyfinize göre biçimlendirebilirsiniz:

```python
print(*sayı_üret(100, 1500, 20), sep='-')

```

Bu şekilde,100ile1500arası sayılardan rastgele20adet seçip her bir
sayının arasına bir tane-işareti yerleştirdik:

```python
352-1251-1366-1381-1350-330-203-842-269-285-816
-658-643-308-1174-152-594-522-1214-959

```

### Fonksiyonların Kapsamı ve global Deyimi

Elimizde şöyle bir kod olduğunu düşünelim:

```python
x = 0

def fonk():
 x = 1
 return x

```

Bu kodlarda, fonksiyonun dışındaxadlı bir değişken var. Fonksiyonun içinde
de yinexadını taşıyan başka bir değişken var. Fonksiyonumuzun görevi buxdeğişkenini döndürmek.

Bu noktada size şöyle bir soru sormama izin verin: Acaba fonksiyon içinde
tanımladığımızxdeğişkeni, fonksiyon dışındakixdeğişkeninin değerini
değiştiriyor mu? Bu sorunun cevabını şu kodlarla verelim:

```python
x = 0

def fonk():
 x = 1
 return x

print('fonksiyon içindeki x: ', fonk())
print('fonksiyon dışındaki x: ', x)

```

Bu kodları çalıştırdığımızda şu çıktıyı alacağız:

```python
fonksiyon içindeki x: 1
fonksiyon dışındaki x: 0

```

Gördüğünüz gibi fonksiyon içindeki ve fonksiyon dışındaki aynı adlı değişkenler
birbirine karışmıyor. Bunun sebebi, Python’daki ‘isim alanı’ (namespace) adlı
bir kavramdır.

Peki isim alanı ne demek?

Python’da değişkenlerin, fonksiyonların ve daha sonra göreceğiniz gibi
sınıfların bir kapsamı vardır. Bu kapsama Python’da ‘isim alanı’ adı verilir.
Dolayısıyla Python’da her nesnenin, geçerli ve etkin olduğu bir isim alanı
bulunur. Örneğin yukarıdaki kodlarda fonksiyon dışındakixdeğişkeni ana isim
alanında yer alan ‘global’ bir değişkendir. Fonksiyon içindekixdeğişkeni isefonk()değişkeninin isim alanı içinde yer alan ‘lokal’ bir değişkendir. Bu
iki değişken, adları aynı da olsa, birbirlerinden farklı iki nesnedir.

Bir de şu örneklere bakalım:

```python
x = []
print('x\'in ilk hali:', x)

def değiştir():
 print('x\'i değiştiriyoruz...')
 x.append(1)
 return x

değiştir()
print('x\'in son hali: ', x)

```

Burada ise daha farklı bir durum söz konusu. Fonksiyon içindeappend()metodunu kullanarak yaptığımız ekleme işlemi fonksiyon dışındaki listeyi de
etkiledi. Peki ama bu nasıl oluyor?

Python herhangi bir nesneye göndermede bulunduğumuzda, yani o nesnenin
değerini talep ettiğimizde aradığımız nesneyi ilk önce mevcut isim alanı içinde
arar. Eğer aranan nesneyi mevcut isim alanı içinde bulamazsa yukarıya doğru
bütün isim alanlarını tek tek kontrol eder.

Birkaç örnek verelim:

```python
def fonk():
 print(x)

fonk()

```

Tahmin edebileceğiniz gibi, bu kodlar şu hatayı verecektir:

```python
Traceback (most recent call last):
 File "deneme.py", line 4, in <module>
 fonk()
 File "deneme.py", line 2, in fonk
 print(x)
NameError: global name 'x' is not defined

```

Bu hatanın sebebi,xadlı bir değişkenin tanımlanmamış olmasıdır. Bu hatayı
gidermek için şöyle bir kod yazabiliriz:

```python
x = 0

def fonk():
 print(x)

fonk()

```

Bu kod global alandakixdeğişkeninin değerini verecektir.

Yukarıdaki örnekte, bizprint()ilex’in değerini sorguladığımızda Python
önceliklefonk()adlı fonksiyonun isim alanına baktı. Oradax’i
bulamayınca bu kez global alana yönelip, orada bulduğux’in değerini yazdırdı.

Bu durumu daha net anlayabilmek için şu kodları inceleyelim:

```python
x = 0

def fonk():
 x = 10
 print(x)

fonk()
print(x)

```

Bu kodları çalıştırdığımızda10çıktısını alırız. Çünkü Python, dediğimiz
gibi, öncelikle mevcut isim alanını kontrol ediyor.xdeğişkenini mevcut isim
alanında bulduğu için de global alana bakmasına gerek kalmıyor.

Yalnız burada dikkat etmemiz gereken bazı şeyler var.

Dediğimiz gibi, global isim alanındaki nesnelerin değerini lokal isim
alanlarından sorgulayabiliyoruz. Ancak istediğimiz şey global isim alanındaki
nesnelerin değerini değiştirmekse bazı kavramlar arasındaki farkları iyi
anlamamız gerekiyor.

Python’da bir nesnenin değerini değiştirmekle, o nesneyi yeniden tanımlamak
farklı kavramlardır.

Eğer bir nesne değiştirilebilir bir nesne ise, o nesnenin değerini, lokal
isim alanlarından değiştirebilirsiniz:

```python
x = set()

def fonk():
 x.add(10)
 return x

print(fonk())

```

Ama eğer bir nesne değiştirilemez bir nesne ise, o nesnenin değerini zaten
normalde de değiştiremezsiniz. Değiştirmiş gibi yapmak için ise o nesneyi
yeniden tanımlamanız gerektiğini biliyorsunuz:

```python
>>> isim = 'Fırat'
>>> isim += ' Özgül'
>>> print(isim)

Fırat Özgül

```

Burada yaptığımız şey, karakter dizisinin değerini değiştirmekten ziyade bu
karakter dizisini yeniden tanımlamaktır. Çünkü bildiğiniz gibi karakter dizileri
değiştirilemeyen veri tipleridir.

İşte karakter dizileri gibi değiştirilemeyen nesneleri, lokal isim alanlarında
değiştiremeyeceğiniz gibi, yeniden tanımlayamazsınız da…

```python
isim = 'Fırat'

def fonk():
 isim += ' Özgül'
 return isim

print(fonk())

```

Bu kodları çalıştırdığınızda Python size bir hata mesajı gösterecektir.

Aynı durum değiştirilebilir nesneler için de geçerlidir:

```python
isim_listesi = []

def fonk():
 isim_listesi += ['Fırat Özgül', 'Orçun Kunek']
 return isim_listesi

print(fonk())

```

Değiştirilebilen bir veri tipi olan listeleri, fonksiyon içinde yeniden
tanımlayamazsınız. Ancak tabii isterseniz listeleri değişikliğe
uğratabilirsiniz:

```python
isim_listesi = []

def fonk():
 isim_listesi.extend(['Fırat Özgül', 'Orçun Kunek'])
 return isim_listesi

print(fonk())

```

Bu kodlar düzgün bir şekilde çalışıp, fonksiyon dışındakiisim_listesiadlı
listeyi değişikliğe uğratacaktır. Ancak şu kodlar hata verecektir:

```python
isim_listesi = []

def fonk():
 isim_listesi += ['Fırat Özgül', 'Orçun Kunek']
 return isim_listesi

print(fonk())

```

İşte Python programlama dili bu tür durumlar için çözüm olacak bir araç sunar
bize. Bu aracın adıglobal.

Gelin isterseniz buglobaladlı deyimin nasıl kullanılacağına bakalım önce…

Şu kodların hata vereceğini biliyorsunuz:

```python
isim = 'Fırat'

def fonk():
 isim += ' Özgül'
 return isim

print(fonk())

```

Ama bu kodlara şöyle bir ekleme yaparsanız işler değişir:

```python
isim = 'Fırat'

def fonk():
 global isim
 isim += ' Özgül'
 return isim

print(fonk())

```

Buradafonk()adlı fonksiyonun ilk satırında şöyle bir kod görüyoruz:

```python
global isim

```

İşte bu satır,isimadlı değişkenin global alana taşınmasını sağlıyor. Böylece
global alanda bulunanisimadlı değişkeni değişikliğe uğratabiliyoruz.

globaldeyimi her ne kadar ilk bakışta çok faydalı bir araçmış gibi görünse de
aslında programlarımızda genellikle bu deyimi kullanmaktan kaçınmamız iyi bir
fikir olacaktır. Çünkü bu deyim aslında global alanı kirletmemize neden oluyor.
Global değişkenlerin lokal isim alanlarında değişikliğe uğratılması, eğer
dikkatsiz davranırsanız programlarınızın hatalı çalışmasına yol açabilir.

## Gömülü Fonksiyonlar

Bu bölümde, daha önce de birkaç kez bahsettiğimiz ve çokça örneğini gördüğümüz
bir kavramdan söz edeceğiz. Bu kavramın adı ‘gömülü fonksiyonlar’.

Esasında biz buraya gelene kadar Python’da pek çok gömülü fonksiyon gördük.
Dolayısıyla aslında görünüş olarak bunların neye benzediğini biliyoruz. Örneğin
daha önceki derslerimizde gördüğümüzprint()gömülü bir fonksiyondur. Aynı
şekildeopen(),type(),len(),pow(),bin()ve şimdiye kadar
tanıştığımız öteki bütün fonksiyonlar birer gömülü fonksiyondur.

Gömülü fonksiyonlar İngilizcedebuiltin functionsolarak adlandırılır. Bu
fonksiyonlar gerçekten de dile gömülü vaziyettedirler. Bildiğiniz gibi, bir
fonksiyonu kullanabilmemiz için o fonksiyonu tanımlamamız gerekir. İşte gömülü
fonksiyonlar, bizim tanımlamamıza gerek kalmadan, Python geliştiricileri
tarafından önceden tanımlanıp dile gömülmüş ve hizmetimize sunulmuş faydalı
birtakım araçlardır.

İşte bu bölümde biz de bu gömülü fonksiyonları tek tek ve ayrıntılı olarak
inceleyeceğiz. Dediğimiz gibi, bunlardan bir kısmını halihazırda görmüştünüz.
Ama biz bütünlük açısından, önceden ele almış olduğumuz bu fonksiyonlara da
kısaca değinmeden geçmeyeceğiz. Böylelikle hem yeni fonksiyonlar öğrenmiş
olacağız hem de önceden öğrendiğimiz fonksiyonlarla birlikte yeni fonksiyonları
da derli toplu bir şekilde görme imkanımız olacak.

Bu bölümde elbette birtakım fonksiyonları salt art arda sıralamakla
yetinmeyeceğiz. Python’daki gömülü fonksiyonları incelerken bir yandan da Python
programlama dilindeki çok önemli bazı kavramları ele alacağız.

İlk olarakabs()adlı bir fonksiyonla başlıyoruz gömülü fonksiyonları
incelemeye…

### abs()

İngilizcede ‘mutlak’ anlamına gelenabsoluteadlı bir kelime bulunur. İşte bu
fonksiyonun adı da bu kelimeden gelir. Fonksiyonumuzun görevi de isminin
anlamına yakındır.abs()fonksiyonunu bir sayının mutlak değerini elde etmek
için kullanıyoruz.

Peki ‘mutlak değer’ ne anlama geliyor. Esasında siz bu kavrama matematik
derslerinden aşinasınız. Ama bilmeyenler veya unutmuş olanlar için tekrar
edelim. ‘Mutlak değer’ bir sayının0’a olan uzaklığıdır. Örneğin20sayısının0sayısına olan uzaklığı 20’dir. Dolayısıyla20sayısının mutlak
değeri 20’dir. Aynı şekilde-20sayısının da0sayısına uzaklığı 20’dir.
Yani,-20sayısının da mutlak değeri 20’dir.

İşteabs()fonksiyonu bize bir sayının mutlak değerinin ne olduğunu söyler:

```python
>>> abs(-20)

20

>>> abs(20)

20

>>> abs(20.0)

20.0

```

Mutlak değer kavramı yalnızca tamsayılar ve kayan noktalı sayılar için değil,
aynı zamanda karmaşık sayılar için de geçerlidir. Dolayısıylaabs()fonksiyonunu kullanarak karmaşık sayıların da mutlak değerini hesaplayabiliriz:

```python
>>> abs(20+3j)

20.223748416156685

```

Gördüğünüz gibi bu fonksiyon yalnızca tek bir parametre alıyor ve bu
parametrenin mutlak değerini döndürüyor.

### round()

round()fonksiyonu bir sayıyı belli ölçütlere göre yukarı veya aşağı doğru
yuvarlamamızı sağlar. Basit birkaç örnek verelim:

```python
>>> round(12.4)

12

>>> round(12.7)

13

```

Gördüğünüz gibi bu fonksiyon, kayan noktalı sayıları en yakın tam sayıya doğru
yuvarlıyor.

Ancak burada dikkat etmemiz gereken bir nokta var.

Şu örnekleri bir inceleyelim:

```python
>>> round(1.5)

2

>>> round(12.5)

12

```

Gördüğünüz gibi, fonksiyonumuz1.5sayısını yukarı doğru,12.5sayısını ise
aşağı doğru yuvarladı. Bunun sebebi, kayan noktalı bir sayının üst ve alt tam
sayılara olan uzaklığının birbirine eşit olduğu durumlarda Python’ın çift sayıya
doğru yuvarlama yapmayı tercih etmesidir. Mesela yukarıdaki örneklerde1.5sayısı hem1sayısına, hem de2sayısına eşit uzaklıkta bulunuyor. İşte
Python bu durumda, bir çift sayı olan2sayısına doğru yuvarlamayı tercih
edecektir.

round()fonksiyonu toplam iki parametre alır. İlk parametre, yuvarlanacak
sayının kendisidir. Yuvarlama hassasiyetini belirlemek için ise ikinci bir
parametreden yararlanabiliriz.

Örneğin22sayısını7’ye böldüğümüzde normalde şöyle bir çıktı elde ederiz:

```python
>>> 22/7

3.142857142857143

```

round()fonksiyonunu tek parametre ile kullandığımızda bu fonksiyon
yukarıdaki sayıyı şu şekilde yuvarlayacaktır:

```python
>>> round(22/7)

3

```

İşte bizround()fonksiyonuna ikinci bir parametre daha vererek, yuvarlama
hassasiyetini kontrol edebiliriz.

Aşağıdaki örnekleri dikkatlice inceleyin:

```python
>>> round(22/7)

3

>>> round(22/7, 0)

3.0

>>> round(22/7, 1)

3.1

>>> round(22/7, 2)

3.14

>>> round(22/7, 3)

3.143

>>> round(22/7, 4)

3.1429

```

Gördüğünüz gibi,round()fonksiyonuna verdiğimiz ikinci parametre, yuvarlama
işleminin ne kadar hassas olacağını belirliyor.

### all()

Allkelimesi Türkçede ‘hepsi’ anlamına gelir. Bu fonksiyonun görevi de bu
anlamı çağrıştırır.all()fonksiyonunun görevi, bir dizi içinde bulunan
bütün değerlerTrueiseTruedeğeri, eğer bu değerlerden herhangi biriFalseise deFalsedeğeri döndürmektir.

Örneğin elimizde şöyle bir liste olduğunu varsayalım:

```python
>>> liste = [1, 2, 3, 4]

```

Şimdiall()fonksiyonunu bu liste üzerine uygulayalım:

```python
>>> all(liste)

True

```

Bildiğiniz gibi,0hariç bütün sayıların bool değeriTrue’dur. Yukarıdaki
listedeFalsedeğeri verebilecek herhangi bir değer bulunmadığından,all()fonksiyonu bu liste içinTruedeğerini veriyor. Bir de şuna bakalım:

```python
>>> liste = [0, 1, 2, 3, 4]
>>> all(liste)

False

```

Dediğimiz gibi,all()fonksiyonu ancak dizi içindeki bütün değerlerin bool
değeriTrueiseTrueçıktısı verecektir.

Son bir örnek daha verelim:

```python
>>> liste = ['ahmet', 'mehmet', '']
>>> all(liste)

False

```

ListedeFalsedeğerine sahip bir boş karakter dizisi bulunduğu içinall()fonksiyonuFalseçıktısı veriyor.

Bu fonksiyonu her türlü kodun bool değerlerini test etmek için
kullanabilirsiniz. Mesela bu fonksiyonu kullanarak, bir nesnenin listelenen
özelliklerin hepsine sahip olup olmadığını denetleyebilirsiniz:

```python
>>> a = 3
>>> t1 = a == 3 #sayı 3 mü?
>>> t2 = a < 4 #sayı 4'ten küçük mü?
>>> t3 = a % 2 == 1 #sayı bir tek sayı mı?
>>> all([t1, t2, t3]) #sayı bu özelliklerin hepsine sahip mi?

True

```

Eğer sayımız bu özelliklerin birine bile sahip değilse,all()fonksiyonuFalseçıktısı verecektir.

### any()

Anykelimesi İngilizcede ‘herhangi bir’ anlamına gelir. İşteany()fonksiyonunun görevi de, bir dizi içindeki bütün değerlerden en az biriTrueiseTrueçıktısı vermektir.

Örneğin:

```python
>>> liste = ['ahmet', 'mehmet', '']
>>> any(liste)

True

```

any()fonksiyonununTrueçıktısı verebilmesi için listede yalnızca bir
adetTruedeğerli öğe olması yeterlidir. Bu fonksiyonunFalseçıktısı
verebilmesi için dizi içindeki bütün öğelerin bool değerininFalseolması
gerekir:

```python
>>> l = ['', 0, [], (), set(), dict()]
>>> any(l)

False

```

İçi boş veri tiplerinin bool değerininFalseolduğunu biliyorsunuz.

Tıpkıall()fonksiyonunda olduğu gibi,any()fonksiyonunu da, bir grup
nesnenin bool değerlerini denetlemek amacıyla kullanabilirsiniz.

### ascii()

Bu fonksiyon, bir nesnenin ekrana basılabilir halini verir bize. Dilerseniz bu
fonksiyonun yaptığı işi tanımlamak yerine bunu bir örnek üzerinden anlatmaya
çalışalım:

```python
>>> a = 'istihza'
>>> print(ascii(a))

'istihza'

```

Bu fonksiyonun,print()fonksiyonundan farklı olarak, çıktıya tırnak
işaretlerini de eklediğine dikkat edin.

ascii()fonksiyonunun tam olarak ne yaptığını daha iyi anlamak için herhalde
şu örnek daha faydalı olacaktır.

Dikkatlice bakın:

```python
>>> print('\n')

```

Bu komutu verdiğimizde,nkaçış dizisinin etkisiyle yeni satıra geçileceğini
biliyorsunuz.

Bir de şuna bakın:

```python
>>> print(ascii('\n!'))

'\n'

```

Gördüğünüz gibi,ascii()fonksiyonu, satır başı kaçış dizisinin görevini
yapmasını sağlamak yerine bu kaçış dizisinin ekrana basılabilir halini veriyor
bize.

Ayrıca bu fonksiyon, karakter dizileri içindeki Türkçe karakterlerin de UNICODE
temsillerini döndürür. Örneğin:

```python
>>> a = 'ışık'
>>> print(ascii(a))
'\u0131\u015f\u0131k'

```

Bunu daha net şu şekilde görebiliriz:

```python
>>> for i in a:
... print(ascii(i))
...
'\u0131'
'\u015f'
'\u0131'
'k'

```

Gördüğünüz gibi,ascii()fonksiyonu ASCII olmayan karakterlerle
karşılaştığında bunların karakter temsilleri yerine UNICODE temsillerini (veya
onaltılık sayma düzenindeki karşılıklarını) veriyor.

Son olarak şu örneğe bakalım:

```python
>>> liste = ['elma', 'armut', 'erik']
>>> temsil = ascii(liste)
>>> print(temsil)

['elma', 'armut', 'erik']

```

Burada listemizascii()fonksiyonuna parametre olarak verildikten sonra
artık liste olma özelliğini yitirip bir karakter dizisi haline gelir. Bunu
denetleyelim:

```python
>>> print(type(temsil))
<class 'str'>

>>> temsil[0]

'['

```

Gördüğünüz gibi,ascii()fonksiyonu listeyi alıp, bunu ekrana basılabilir
bir bütün haline getiriyor. Elbette bunun için de, kendisine verilen parametreyi
bir karakter dizisine dönüştürüyor.

### repr()

repr()fonksiyonunun yaptığı iş, biraz önce gördüğümüzascii()fonksiyonunun yaptığı işe çok benzer. Bu iki fonksiyon, ASCII olmayan
karakterlere muameleleri açısından birbirinden ayrılır.

Hatırlarsanızascii()fonksiyonu ASCII olmayan karakterlerle karşılaştığında
bunların UNICODE (veya onaltılık) temsillerini gösteriyordu:

```python
>>> ascii('şeker')

"'\\u015feker'"

```

repr()fonksiyonu ise ASCII olmayan karakterlerle karşılaşsa bile, bize
çıktı olarak bunların da karakter karşılıklarını gösterir:

```python
>>> repr('şeker')

"'şeker'"

```

Geri kalan özellikleri bakımındanrepr()veascii()fonksiyonları
birbiriyle aynıdır.

### bool()

Bu fonksiyon bir nesnenin bool değerini verir:

```python
>>> bool(0)

False

>>> bool(1)

True

>>> bool([])

False

```

### bin()

Bu fonksiyon, bir sayının ikili düzendeki karşılığını verir:

```python
>>> bin(12)

'0b1100'

```

Bu fonksiyonun verdiği çıktının bir sayı değil, karakter dizisi olduğuna dikkat
etmelisiniz.

### bytes()

Bu fonksiyonbytestüründe nesneler oluşturmak için kullanılır. Bu fonksiyonu
‘bayt’ adlı veri tipini incelerken ayrıntılı olarak ele almıştık. Gelin
isterseniz burada da bu fonksiyona şöyle bir değinelim.

Dediğimiz gibi,bytes()adlı fonksiyon,bytestüründe veriler oluşturmaya
yarar. Bu fonksiyon işlev olarak, daha önce öğrendiğimizlist(),str(),int(),set(),dict()gibi fonksiyonlara çok benzer. Tıpkı bu
fonksiyonlar gibi,bytes()fonksiyonunun görevi de farklı veri tiplerini
‘bayt’ adlı veri tipine dönüştürmektir.

Bu fonksiyon, kendisine verilen parametrelerin türüne bağlı olarak birbirinden
farklı sonuçlar ortaya çıkarır. Örneğin eğer bu fonksiyona parametre olarak bir
tam sayı verecek olursanız, bu fonksiyon size o tam sayı miktarınca bir bayt
nesnesi verecektir. Gelin isterseniz bu durumu örnekler üzerinde göstermeye
çalışalım:

```python
>>> bytes(10)

b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

```

Yukarıdaki komut bize, her bir öğesinin değeri0olan 10 baytlık bir veri
döndürdü:

```python
>>> a = bytes(10)

>>> a

b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

>>> a[0]

0

>>> a[1]

0

>>> a[2]

0

```

Gördüğünüz gibi,bytes(10)komutuyla oluşturduğumuzadeğişkeni içinde
toplam 10 adet bayt var ve bu baytların her birinin değeri 0.

Yukarıda,bytes()fonksiyonuna bir tam sayı değerli parametre verdiğimizde
nasıl bir sonuç alacağımızı öğrendik. Peki biz bu fonksiyona parametre olarak
bir karakter dizisi verirsek ne olur?

Hemen görelim:

```python
>>> bytes('istihza')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: string argument without an encoding

```

Bu fonksiyona karakter dizilerini doğrudan parametre olarak veremeyiz. Eğer
verirsek yukarıdaki gibi bir hata alırız. Peki acaba bu hatayı almamızın nedeni
ne olabilir?

Dediğimiz gibi,bytes()fonksiyonu, çeşitli veri tiplerini bayta
dönüştürmeye yarar. Ancak bildiğiniz gibi, bayta dönüştürme işlemi her kod
çözücü tarafından farklı biçimde yapılır. Örneğin:

```python
>>> 'ışık'.encode('utf-8')

b'\xc4\xb1\xc5\x9f\xc4\xb1k'

>>> 'ışık'.encode('cp857')

b'\x8d\x9f\x8dk'

>>> 'ışık'.encode('cp1254')

b'\xfd\xfe\xfdk'

```

Dolayısıyla,bytes()fonksiyonunun bir karakter dizisini bayta çevirirken
nasıl davranması gerektiğini anlayabilmesi için, bayta dönüştürme işlemini hangi
kod çözücü ile yapmak istediğimizi açıkça belirtmemiz gerekir:

```python
>>> bytes('ışık', 'utf-8')

b'\xc4\xb1\xc5\x9f\xc4\xb1k'

>>> bytes('ışık', 'cp1254')

b'\xfd\xfe\xfdk'

>>> bytes('ışık', 'cp857')

b'\x8d\x9f\x8dk'

```

Gördüğünüz gibi,bytes()fonksiyonuna parametre olarak bir karakter dizisi
verebilmek için, bu karakter dizisi ile birlikte bir kod çözücü de belirtmemiz
gerekiyor. Böylecebytes()fonksiyonu kendisine verdiğimiz karakter
dizisini, belirttiğimiz kod çözücünün kurallarına göre bayta dönüştürüyor.

Bu arada, çıktıda görünen ‘b’ harflerinin, elimizdeki verinin bir bayt olduğunu
gösteren bir işaret olduğunu biliyorsunuz.

Ayrıca,bytes()fonksiyonuna verdiğimiz ikinci parametrenin ismininencodingolduğunu ve bu parametreyi isimli bir parametre olarak da
kullanabileceğimizi belirtelim:

```python
>>> bytes('istihza', encoding='ascii')

```

Bu noktada size şöyle bir soru sorayım: Acababytes()fonksiyonuna
ilk parametre olarak verdiğimiz karakter dizisi, ikinci parametrede
belirttiğimiz kod çözücü tarafından tanınmazsa ne olur?

Cevabı tahmin edebilirsiniz: Böyle bir durumda elbette Python bize bir hata
mesajı gösterir:

```python
>>> bytes('şeker', 'ascii')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character '\u015f' in position 0:
 ordinal not in range(128)

```

… veya:

```python
>>> bytes('€', 'cp857')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "C:\Python33\lib\encodings\cp857.py", line 12, in encode
 return codecs.charmap_encode(input,errors,encoding_map)
UnicodeEncodeError: 'charmap' codec can't encode character '\u20ac' in position
0: character maps to <undefined>

```

‘ş’ harfi ‘ASCII’ karakter kümesinde; ‘€’ işareti ise ‘CP857’ adlı karakter
kümesinde tanımlanmamış birer karakter olduğu için, ilgili kod çözücüler bu
karakterleri çözüp bayta dönüştüremiyor. Yazdığımız kodların bu tür durumlarda
tamamen çökmesini engellemek için, önceki derslerimizde de çeşitli vesilelerle
öğrenmiş olduğumuzerrorsadlı bir parametreden yararlanabiliriz:

```python
>>> bytes('ışık', encoding='ascii', errors='replace')

b'???k'

>>> bytes('şeker', encoding='ascii', errors='replace')

b'?eker'

>>> bytes('€', encoding='cp857', errors='replace')

b'?'

>>> bytes('€', encoding='cp857', errors='ignore')

b''

>>> bytes('€', encoding='cp857', errors='xmlcharrefreplace')

b'&#8364;'

>>> bytes('şeker', encoding='cp857', errors='xmlcharrefreplace')

b'\x9feker'

```

Gördüğünüz gibi,errorsparametresine verdiğimiz çeşitli değerler yardımıyla,bytes()fonksiyonunun,encodingparametresinde belirtilen kod çözücü ile
çözülemeyen karakterlerle karşılaştığında nasıl davranacağını
belirleyebiliyoruz.

errorsparametresine verdiğimiz bütün bu değerleri önceki derslerimizde
öğrenmiştik. Dolayısıyla yukarıda gösterdiğimiz kodları rahatlıkla anlayabilecek
kadar Python bilgisine sahibiz.

Son olarak,bytes()fonksiyonuna parametre olarak 0-256 arası sayılardan
oluşan diziler de verebiliriz:

```python
>>> bytes([65, 10, 12, 11, 15, 66])

b'A\n\x0c\x0b\x0fB'

```

Bu yapı içinde Python,0ile128arası sayılar için standart ASCII
tablosunu,128ile256arası sayılar için ise Latin-1 karakter kümesini
temel alarak sayıları birer bayta dönüştürecektir.

### bytearray()

Bildiğiniz gibi baytlar değiştirilemeyen bir veri tipidir. Dolayısıyla bir bayt
veri tipi üzerinde herhangi bir değişiklik yapamayız. Örneğin bir baytın
herhangi bir öğesini başka bir değerle değiştiremeyiz:

```python
>>> a = bytes('istihza', 'ascii')
>>> a[0]

105

>>> a[0] = 106

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: 'bytes' object does not support item assignment

```

Ama eğer hem baytlarla çalışmak, hem de bu baytların üzerinde değişiklik
yapabilmek isterseniz baytlar yerine bayt dizileri ile çalışabilirsiniz. İşte
bunun içinbytearray()adlı bir fonksiyondan yararlanıyoruz.

Yaptıkları iş bakımındanbytearray()vebytes()fonksiyonları
birbirlerine çok benzer. Bu ikisi arasındaki tek fark,bytearray()ile
oluşturulan veri tipinin,bytes()ile oluşturulan veri tipinin aksine,
değiştirilebilir nitelikte olmasıdır:

```python
>>> a = bytearray('adana', 'ascii')

>>> a

bytearray(b'adana')

>>> a[0] = 65

>>> a

bytearray(b'Adana')

```

### chr()

Bu fonksiyon, kendisine parametre olarak verilen bir tam sayının karakter
karşılığını döndürür. Örneğin:

```python
>>> chr(10)

'\n'

```

Bildiğiniz gibi10sayısının karakter karşılığı satır başı karakteridir. Bir
de şuna bakalım:

```python
>>> chr(65)

'A'

```

65sayısının karakter karşılığı ise ‘A’ harfidir.

Bu fonksiyon sayıları karakterlere dönüştürürken ASCII sistemini değil, UNICODE
sistemini temel alır. Dolayısıyla bu fonksiyon ile 128 (veya 255) üstü sayıları
da dönüştürebiliriz. Örneğin:

```python
>>> chr(305)

'ı'

```

### list()

Bu fonksiyon iki farklı amaç için kullanılabilir:
1. Liste tipinde bir veri oluşturmak
1. Farklı veri tiplerini liste adlı veri tipine dönüştürmek

Liste tipinde bir veri oluşturmak

Farklı veri tiplerini liste adlı veri tipine dönüştürmek

Birinci amaç için bu fonksiyonu şu şekilde kullanıyoruz:

```python
>>> l = list()

```

Böylece liste tipinde bir veri oluşturmuş olduk.

Dediğimiz gibilist()fonksiyonunu, farklı tipteki verileri listeye
dönüştürmek için de kullanabiliriz. Örneğin:

```python
>>> list('istihza')

['i', 's', 't', 'i', 'h', 'z', 'a']

```

Burada‘istihza’adlı karakter dizisini bir listeye dönüştürdük.

Elbette bu fonksiyonu kullanarak başka veri tiplerini de listeye
dönüştürebiliriz. Örneğin bir sözlüğü, bu fonksiyon yardımıyla kolayca listeye
dönüştürebiliriz:

```python
>>> s = {'elma': 44, 'armut': 10, 'erik': 100}
>>> list(s)

['elma', 'armut', 'erik']

```

Bir sözlük listeye dönüştürülürken, elbette sözlüğün anahtarları dikkate
alınacaktır. Eğer siz sözlüğün anahtarlarından değil de değerlerinde bir liste
oluşturmak isterseniz şöyle bir kod yazabilirsiniz:

```python
>>> list(s.values())

[44, 10, 100]

```

### set()

set()fonksiyonulist()fonksiyonuna çok benzer. Bu fonksiyon da tıpkılist()fonksiyonu gibi, veri tipleri arasında dönüştürme işlemleri
gerçekleştirmek için kullanılabilir.set()fonksiyonunun görevi farklı veri
tiplerini kümeye dönüştürmektir:

```python
>>> k = set()

```

Burada boş bir küme oluşturduk. Şimdi de mesela bir karakter dizisini kümeye
dönüştürelim:

```python
>>> i = 'istihza'
>>> set(i)

{'t', 's', 'z', 'a', 'i', 'h'}

```

### tuple()

tuple()fonksiyonu da, tıpkılist(),set()ve benzerleri gibi bir
dönüştürücü fonksiyondur. Bu fonksiyon farklı veri tiplerini demete dönüştürür:

```python
>>> tuple('a')

('a',)

```

### frozenset()

Bu fonksiyonu kullanarak farklı veri tiplerini dondurulmuş kümeye
dönüştürebilirsiniz:

```python
>>> s = set('istihza')
>>> df = frozenset(s)
>>> df

frozenset({'t', 's', 'a', 'z', 'i', 'h'})

```

### complex()

Sayılardan söz ederken, eğer matematikle çok fazla içli dışlı değilseniz pek
karşılaşmayacağınız, ‘karmaşık sayı’ adlı bir sayı türünden de bahsetmiştik.
Karmaşık sayılar, bir gerçek, bir de sanal kısımdan oluşan sayılardır.

Karmaşık sayılar Python’da ‘complex’ ifadesiyle gösteriliyor. Mesela şu bir
karmaşık sayıdır:

```python
>>> 12+0j

```

İşte eğer herhangi bir sayıyı karmaşık sayıya dönüştürmeniz gerekirsecomplex()adlı bir fonksiyondan yararlanabilirsiniz. Örneğin:

```python
>>> complex(15)

(15+0j)

```

Böyle bir kod yazdığımızda, verdiğimiz parametre karmaşık sayının gerçek kısmını
oluşturacak, sanal kısım ise0olarak kabul edilecektir. Elbette isterseniz
sanal kısmı kendiniz de belirleyebilirsiniz:

```python
>>> complex(15, 2)

(15+2j)

```

### float()

Bu fonksiyonu, sayıları veya karakter dizilerini kayan noktalı sayıya
dönüştürmek için kullanıyoruz:

```python
>>> float('134')

134.0

>>> float(12)

12.0

```

### int()

Bu fonksiyon birkaç farklı amaç için kullanılabilir.int()fonksiyonunun en
temel görevi, bir karakter dizisi veya kayan noktalı sayıyı (eğer mümkünse) tam
sayıya dönüştürmektir:

```python
>>> int('10')

10

>>> int(12.4)

12

```

Bunun dışında bu fonksiyonu, herhangi bir sayma sisteminde temsil edilen bir
sayıyı onlu sayma sistemine dönüştürmek için de kullanabiliriz. Örneğin:

```python
>>> int('12', 8)

10

```

Burada, sekizli sayma sistemine ait sayı değerli bir karakter dizisi olan‘12’`yi onlu sayma sistemine dönüştürdük ve böylece `10sayısını elde ettik.

int()fonksiyonunu sayma sistemleri arasında dönüştürme işlemlerinde
kullanabilmek için ilk parametrenin bir karakter dizisi olması gerektiğine
dikkat ediyoruz.

Bu arada,int('12',8)komutununun12sayısını sekizli sayma sistemine
dönüştürmediğine dikkat edin. Bu komutun yaptığı iş sekizli sayma sistemindeki12sayısını onlu sayma sistemine dönüştürmektir.

int()fonksiyonunun bu kullanımıyla ilgili bir örnek daha verelim:

```python
>>> int('4cf', 16)

1231

```

Burada da, onaltılı sayma sistemine ait bir sayı olan4cf’yi onlu sayma
sistemine çevirdik ve1231sayısını elde ettik.4cfsayısınıint()fonksiyonuna parametre olarak verirken bunu karakter dizisi şeklinde yazmayı
unutmuyoruz. Aksi halde Python bize bir hata mesajı gösterecektir.

### str()

Bu fonksiyonun, farklı veri tiplerini karakter dizisine dönüştürmek için
kullanıldığını biliyorsunuz. Örneğin:

```python
>>> str(12)

'12'

```

Burada12sayısını bir karakter dizisine dönüştürdük. Şimdi de bir baytı
karakter dizisine dönüştürelim:

```python
>>> bayt = b'istihza'

```

Bayt nesnemizi tanımladık. Şimdi bunu bir karakter dizisine dönüştürelim:

```python
>>> kardiz = str(bayt, encoding='utf-8')
>>> print(kardiz)

istihza

```

Gördüğünüz gibi, bir baytı karakter dizisine dönüştürmek içinstr()fonksiyonunaencodingadlı bir parametre veriyoruz. Fonksiyonumuz, bu
parametrede hangi kodlama biçimi belirtildiyse, baytları bu kodlama biçiminin
kurallarına göre bir karakter dizisine dönüştürüyor.

Tahmin edebileceğiniz gibi, belirttiğiniz kodlama biçiminin herhangi bir baytı
karakter dizisine dönüştüremediği durumlara karşı birerrorsparametresi de
verebilirizstr()fonksiyonuna. Örneğin elimizde bayt tipinde şöyle bir veri
olduğunu varsayalım:

```python
>>> bayt = bytes('kadın', encoding='utf-8')
>>> print(bayt)

b'kad\xc4\xb1n'

```

Şimdi bu bayt veri tipini bir karakter dizisine dönüştürmeye çalışalım:

```python
>>> kardiz = str(bayt, encoding='ascii')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc4 in position 3: ordinal
not in range(128)

```

ASCII adlı kod çözücü,b'kadın'içindeki baytlardan birini tanıyamadığı için
bize bir hata mesajı gösterdi. Bildiğiniz gibi ASCII 128’den büyük baytları
dönüştüremez. İşte bu tür durumlara karşıerrorsparametresinden
yararlanabilirsiniz:

```python
>>> kardiz = str(bayt, encoding='ascii', errors='ignore')
>>> print(kardiz)

kadn

```

errorsparametresine verdiğimiz ‘ignore’ değeri sayesinde Python bize hata
mesajı göstermek yerine, ASCII ile çözülemeyen baytı görmezden geldi.errorsparametresinin hangi değerleri alabileceğini önceki derslerimizden hatırlıyor
olmalısınız.

### dict()

Bu fonksiyon, farklı veri tiplerinden sözlükler üretmemizi sağlar. Örneğin bu
fonksiyonu kullanarak boş bir sözlük oluşturabiliriz:

```python
>>> s = dict()

```

Bu fonksiyon, değişkenlerden sözlükler oluşturmamızı da sağlar:

```python
>>> s = dict(a=1, b=2, c=3)

{'a': 1, 'b': 2, 'c': 3}

```

dict()fonksiyonuna parametre olarak iç içe geçmiş listeler veya demetler
vererek de sözlük üretebiliriz:

```python
>>> öğeler = (['a', 1], ['b', 2], ['c', 3])
>>> dict(öğeler)

{'a': 1, 'b': 2, 'c': 3}

```

### callable()

Bu fonksiyon, bir nesnenin ‘çağrılabilir’ olup olmadığını denetler. Peki hangi
nesneler çağrılabilir özelliktedir. Mesela fonksiyonlar çağrılabilir
nesnelerdir. Değişkenler ise çağrılabilir nesneler değildir.

Birkaç örnek verelim bununla ilgili:

```python
>>> callable(open)

True

```

Python’ınopen()adlı bir fonksiyonu olduğu için, doğal olarakcallable()fonksiyonuTrueçıktısı veriyor.

Bir de şuna bakalım:

```python
>>> import sys
>>> callable(sys.version)

False

```

Burada dasysmodülü içindekiversionadlı nesnenin çağrılabilir özellikte
olup olmadığını sorguladık. Daha önceki derslerimizde de gördüğünüz gibi,sysmodülü içindekiversionadlı araç bir fonksiyon değil, değişkendir.
Dolayısıyla bu değişkencallable(sys.version)sorgusunaFalseyanıtı
verir.

### ord()

Bu fonksiyon, bir karakterin karşılık geldiği ondalık sayıyı verir. Örneğin:

```python
>>> ord('a')

97

>>> ord('ı')

305

```

### oct()

Bu fonksiyon, bir sayıyı sekizli düzendeki karşılığına çevirmemizi sağlar:

```python
>>> oct(10)

'0o12'

```

### hex()

Bu fonksiyon, bir sayıyı onaltılı düzendeki karşılığına çevirmemizi sağlar:

```python
>>> hex(305)

'Ox131'

```

Yalnız hemoct()hem dehex()fonksiyonlarında dikkat etmemiz gereken
şey, bu fonksiyonların parametre olarak bir sayı alıp, çıktı olarak bir karakter
dizisi veriyor olmasıdır.

### eval(), exec(), globals(), locals()

Bu bölümde dört farklı fonksiyonu bir arada inceleyeceğiz. Bu fonksiyonları
birlikte ele almamızın nedeni bunların birbiriyle yakından bağlantılı olması.

Burada işleyeceğimiz bu dört fonksiyon şunlardan oluşuyor:
1. eval()
1. exec()
1. globals()
1. locals()

eval()

exec()

globals()

locals()

Ancak bu fonksiyonlardan söz etmeye başlamadan önce Python’daki iki önemli
kavramı açıklığa kavuşturmamız gerekiyor: Bu kavramlar şunlar:
1. ifade
1. deyim

ifade

deyim

Öncelikle ‘ifade’ kavramından başlayalım.

İngilizcedeexpressiondenen ‘ifadeler’, bir değer üretmek için kullanılan kod
parçalarıdır. Karakter dizileri, sayılar, işleçler, öteki veri tipleri, liste
üreteçleri, sözlük üreteçleri, küme üreteçleri, fonksiyonlar hep birer ifadedir.
Örneğin:

```python
>>> 5

>>> 23 + 4

>>> [i for i in range(10)]

>>> len([1, 2, 3])

```

İngilizcedestatementolarak adlandırılan ‘deyimler’ ise ifadeleri de kapsayan
daha geniş bir kavramdır. Buna göre bütün ifadeler aynı zamanda birer deyimdir.
Daha doğrusu, ifadelerin bir araya gelmesi ile deyimler oluşturulabilir.

Deyimlere birkaç örnek verelim:

```python
>>> a = 5

>>> if a:
... print(a)

>>> for i in range(10):
... print(i)

```

Python programlama dilinde deyimlerle ifadeleri ayırt etmenin kolay bir yolu daeval()fonksiyonundan yararlanmaktır. Eğer deyim mi yoksa ifade mi
olduğundan emin olamadığınız bir şeyieval()fonksiyonuna parametre olarak
verdiğinizde hata almıyorsanız o parametre bir ifadedir. Eğer hata alıyorsanız o
parametre bir deyimdir. Çünküeval()fonksiyonuna parametre olarak yalnızca
ifadeler verilebilir.

Birkaç örnek verelim:

```python
>>> eval('a = 5')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "<string>", line 1
 a = 5
 ^
SyntaxError: invalid syntax

```

Gördüğünüz gibi,eval()fonksiyonu bize bir hata mesajı verdi. Çünküa=5kodu bir deyimdir. Unutmayın, Python’da bütün değer atama işlemleri birer
deyimdir. Dolayısıylaeval()fonksiyonu bu deyimi parametre olarak alamaz.

Bir de şuna bakalım:

```python
>>> eval('5 + 25')

30

```

Bu defa hata almadık. Çünküeval()fonksiyonuna, olması gerektiği gibi,
parametre olarak bir ifade verdik. Bildiğiniz gibi,5+25kodu bir
ifadedir.

Dediğimiz gibi,eval()fonksiyonu deyimleri parametre olarak alamaz. Amaexec()fonksiyonu alabilir:

```python
>>> exec('a = 5')

```

Bu şekilde, değeri5olanaadlı bir değişken oluşturmuş olduk. İsterseniz
kontrol edelim:

```python
>>> print(a)

5

```

Gördüğünüz gibi,exec()fonksiyonu, mevcut isim alanı içindeaadlı bir
değişken oluşturdu. Yalnız elbette mevcut isim alanı içinde yeni değişkenler ve
yeni değerler oluştururken dikkatli olmamız gerektiğini biliyorsunuz. Zira
mesela yukarıdaki komutu vermeden önce mevcut isim alanında zatenaadlı bir
değişken varsa, o değişkenin değeri değişecektir:

```python
>>> a = 20

```

Elimizde, değeri20olanaadlı bir değişken var. Şimdiexec()fonksiyonu yardımıylaadeğişkeninin de içinde yer aldığı mevcut isim alanına
müdahale ediyoruz:

```python
>>> exec('a = 10')

```

Böyleceadeğişkeninin eski değerini silmiş olduk. Kontrol edelim:

```python
>>> print(a)

10

```

Bu tür durumlarda,exec()ile oluşturduğunuz değişkenleri global isim
alanına değil de, farklı bir isim alanına göndermeyi tercih edebilirsiniz. Peki
ama bunu nasıl yapacağız?

Python programlama dilinde isim alanları sözlük tipinde bir veridir. Örneğin
global isim alanı basit bir sözlükten ibarettir.

Global isim alanını gösteren sözlükte hangi anahtar ve değerlerin olduğunu
görmek içinglobals()adlı bir fonksiyonu kullanabilirsiniz:

```python
>>> globals()

```

Bu fonksiyonu çalıştırdığımızda şuna benzer bir çıktı alırız:

```python
{'__doc__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>,
'__name__': '__main__', '__package__': None, '__builtins__': <module 'builtins'>}

```

Gördüğünüz gibi, elimizdeki şey gerçekten de bir sözlük. Dolayısıyla bir sözlük
ile ne yapabilirsek bu sözlükle de aynı şeyi yapabiliriz…

‘globals’ adlı bu sözlüğün içeriği, o anda global isim alanında bulunan
nesnelere göre farklılık gösterecektir. Örneğin:

```python
>>> x = 10

```

şeklinde10değerine sahip birxnesnesi tanımladıktan sonraglobals()fonksiyonunu tekrar çalıştırırsanız global isim alanına bu nesnenin de eklenmiş
olduğunu görürsünüz.

Dediğimiz gibi,globals()fonksiyonundan dönen nesne bir sözlüktür. Bu
sözlüğe, herhangi bir sözlüğe veri ekler gibi değer de ekleyebilirsiniz:

```python
>>> globals()['z'] = 23

```

Bu şekilde global isim alanınazadlı bir değişken eklemiş oldunuz:

```python
>>> z

23

```

Yalnız, Python programlama dili bize bu şekilde global isim alanına nesne ekleme
imkanı verse de, biz mecbur değilsek bu yöntemi kullanmaktan kaçınmalıyız. Çünkü
bu şekilde sıradışı bir yöntemle değişken tanımladığımız için aslında global
isim alanını, nerden geldiğini kestirmenin güç olduğu değerlerle ‘kirletmiş’
oluyoruz.

Bildiğiniz gibi, Python’da global isim alanı dışında bir de lokal isim alanı
bulunur. Lokal isim alanlarının, fonksiyonlara (ve ileride göreceğimiz gibi
sınıflara) ait bir isim alanı olduğunu biliyorsunuz. İşte bu isim alanlarına
ulaşmak için delocals()adlı bir fonksiyondan yararlanacağız:

```python
def fonksiyon(param1, param2):
 x = 10
 print(locals())

fonksiyon(10, 20)

```

Bu fonksiyonu çalıştırdığınızda şu çıktıyı alacaksınız:

```python
{'param2': 20, 'param1': 10, 'x': 10}

```

Gördüğünüz gibi,locals()fonksiyonu gerçekten de bizefonksiyon()adlı
fonksiyon içindeki lokal değerleri veriyor.

globals()velocals()fonksiyonlarının ne işe yaradığını incelediğimize
göreexec()fonksiyonunu anlatırken kaldığımız yere dönebiliriz.

Ne diyorduk?

Elimizde, değeri20olanaadlı bir değişken vardı:

```python
>>> a = 20

```

exec()fonksiyonu yardımıylaadeğişkeninin de içinde yer aldığı mevcut
isim alanına müdahale edelim:

```python
>>> exec('a = 3')

```

Bu şekildeadeğişkeninin varolan değerini silmiş olduk:

```python
>>> print(a)

3

```

Dediğimiz gibi, bu tür durumlarda,exec()ile oluşturduğunuz değişkenleri
global isim alanı yerine farklı bir isim alanına göndermeyi tercih etmemiz daha
uygun olacaktır. Python’da isim alanlarının basit bir sözlük olduğunu
öğrendiğimize göre,exec()ile oluşturduğumuz değişkenleri global isim alanı
yerine nasıl farklı bir isim alanına göndereceğimizi görebiliriz.

Önce yeni bir isim alanı oluşturalım:

```python
>>> ia = {}

```

Şimdiexec()ile oluşturacağımız değerleri bu isim alanına gönderebiliriz:

```python
>>> exec('a = 3', ia)

```

Böylece global isim alanındakiadeğişkeninin değerine dokunmamış olduk:

```python
>>> a

20

```

Yeni oluşturduğumuz değer iseiaadlı yeni isim alanına gitti:

```python
>>> ia['a']

3

```

### copyright()

Bu fonksiyon yardımıyla Python’ın telif haklarına ilişkin bilgilere
erişebilirsiniz:

```python
>>> copyright()

Copyright (c) 2001-2012 Python Software Foundation.
All Rights Reserved.

Copyright (c) 2000 BeOpen.com.
All Rights Reserved.

Copyright (c) 1995-2001 Corporation for National Research Initiatives.
All Rights Reserved.

Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.
All Rights Reserved.

```

### credits()

Bu fonksiyon, Python programlama diline katkıda bulunanlara teşekkür içeren
küçük bir metni ekrana çıktı olarak verir:

```python
>>> credits()

Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
for supporting Python development. See www.python.org for more information.

```

### license()

Bu fonksiyon yardımıyla Python’ın lisansına ilişkin epey ayrıntılı metinlere
ulaşabilirsiniz.

### dir()

Eğerdir()fonksiyonunu parametresiz olarak kullanırsak, mevcut isim
alanındaki öğeleri bir liste halinde elde ederiz:

```python
>>> dir()

['__builtins__', '__doc__', '__loader__', '__name__', '__package__']

```

Bu bakımdandir()fonksiyonuglobals()velocals()fonksiyonlarına
benzer. Ancak onlardan farkı,dir()fonksiyonunun çıktı olarak bir liste,globals()velocals()fonksiyonlarının ise birer sözlük vermesidir.

Ayrıcadir()fonksiyonunu kullanarak nesnelerin metot ve niteliklerini
içeren bir listeye ulaşabileceğimizi de biliyorsunuz. Örneğin bu fonksiyonu
kullanarak farklı veri tiplerinin metot ve niteliklerini listeleyebiliriz:

```python
>>> dir('')
>>> dir([])
>>> dir({})

```

### divmod()

Bu fonksiyonun işlevini bir örnek üzerinden göstermeye çalışalım:

```python
>>> divmod(10, 2)

(5, 0)

```

Gördüğünüz gibidivmod(10,2)komutu bize iki öğeli bir demet veriyor. Bu
demetin ilk öğesi,divmod()fonksiyonuna verilen ilk parametrenin ikinci
parametreye bölünmesi işleminin sonucudur. Demetimizin ikinci öğesi ise, ilk
parametrenin ikinci parametreye bölünmesi işleminden kalan sayıdır. Yani demetin
ilk parametresi bölme işleminin ‘bölüm’ kısmını, ikinci öğesi ise ‘kalan’
kısmını verir.

Bu fonksiyonun bölme işlemininin sonucunu tamsayı cinsinden verdiğine dikkat
ediyoruz:

```python
>>> divmod(10, 3)

(3, 1)

```

10sayısı3sayısına bölündüğünde tamsayı cinsinden sonuç3’tür. Bu bölme
işleminin kalanı ise1’dir.

### enumerate()

İngilizcedeenumeratekelimesi ‘numaralandırmak’ anlamına gelir.enumerate()fonksiyonunun görevi de kelimenin bu anlamıyla aynıdır. Yani bu
fonksiyonu kullanarak nesneleri numaralandırabiliriz.

Bu fonksiyon bize bir ‘enumerate’ nesnesi verir:

```python
>>> enumerate('istihza')

<class 'enumerate'>

```

Bu nesnenin içeriğine nasıl erişebileceğimizi biliyorsunuz:

Nesneyi bir listeye çevirebiliriz:

```python
>>> list(enumerate('istihza'))

[(0, 'i'), (1, 's'), (2, 't'), (3, 'i'), (4, 'h'), (5, 'z'), (6, 'a')]

```

veya:

```python
>>> [i for i in enumerate('istihza')]

[(0, 'i'), (1, 's'), (2, 't'), (3, 'i'), (4, 'h'), (5, 'z'), (6, 'a')]

```

print()fonksiyonuna yıldızlı parametre olarak verebiliriz:

```python
>>> print(*enumerate('istihza'))

(0, 'i') (1, 's') (2, 't') (3, 'i') (4, 'h') (5, 'z') (6, 'a')

```

veya nesne üzerinde bir döngü kurabiliriz:

```python
>>> for i in enumerate('istihza'):
... print(i)
...
(0, 'i')
(1, 's')
(2, 't')
(3, 'i')
(4, 'h')
(5, 'z')
(6, 'a')

```

Gördüğünüz gibi, ‘enumerate’ nesnesi bize her koşulda iki öğeli demetler
veriyor. Bu demetlerin her bir öğesine nasıl ulaşabileceğimizi de biliyor
olmalısınız:

```python
>>> for sıra, öğe in enumerate('istihza'):
... print("{}. {:>2}".format(sıra, öğe))
...
0. i
1. s
2. t
3. i
4. h
5. z
6. a

```

Örneklerden de gördüğünüz gibi,enumerate()fonksiyonu bize bir dizi
içindeki öğelerin sırasını ve öğenin kendisini içeren bir demet veriyor. Dikkat
ettiyseniz, her zaman olduğu gibi, Python burada da saymaya 0’dan başlıyor. Yanienumerate()fonksiyonunun ürettiği öğe sıralamasında ilk öğenin sırası 0
oluyor. Elbette eğer istersenizenumerate()fonksiyonunun saymaya kaçtan
başlayacağını kendiniz de belirleyebilirsiniz:

```python
>>> for sıra, öğe in enumerate('istihza', 1):
... print("{}. {:>2}".format(sıra, öğe))
...
1. i
2. s
3. t
4. i
5. h
6. z
7. a

```

enumerate()fonksiyonuna verdiğimiz ikinci parametre saymaya kaçtan
başlanacağını gösteriyor. Eğer bu fonksiyonu ikinci parametre olmadan
kullanırsak Python bizim saymaya 0’dan başlamak istediğimizi varsayacaktır.

### exit()

Bu fonksiyon, o anda çalışan programdan çıkmanızı sağlar. Eğer bu komutu
etkileşimli kabukta verirseniz o anda açık olan oturum kapanacaktır.

### help()

help()fonksiyonu gömülü fonksiyonlar içinde en faydalı fonksiyonların
başında gelir. Bu fonksiyonu kullanarak Python programlama diline ait öğelere
ilişkin yardım belgelerine ulaşabiliriz. Örneğin:

```python
>>> help(dir)

```

Bu komutu verdiğimizdedir()fonksiyonunun ne işe yaradığını gösteren
İngilizce bir belgeye ulaşırız. Gördüğünüz gibi, hakkında bilgi edinmek
istediğimiz öğeyihelp()fonksiyonuna parametre olarak vererek ilgili
yardım dosyasına erişebiliyoruz.

Eğer bu fonksiyonu parametresiz olarak kullanırsak ‘etkileşimli yardım’ denen
ekrana ulaşırız:

```python
>>> help()

Welcome to Python 3.3! This is the interactive help utility.

If this is your first time using Python, you should definitely check out
the tutorial on the Internet at http://docs.python.org/3.3/tutorial/.

Enter the name of any module, keyword, or topic to get help on writing
Python programs and using Python modules. To quit this help utility and
return to the interpreter, just type "quit".

To get a list of available modules, keywords, or topics, type "modules",
"keywords", or "topics". Each module also comes with a one-line summary
of what it does; to list the modules whose summaries contain a given word
such as "spam", type "modules spam".

help>

```

Bu ekranda, hakkında bilgi edinmek istediğiniz öğeyihelp>ibaresinden hemen
sonra, boşluk bırakmadan yazarak öğeye ilişkin bilgilere ulaşabilirsiniz:

```python
help> dir

```

Etkileşimli yardım ekranından çıkmak için ‘q’ harfine basabilirsiniz.

### id()

Python’da her nesnenin bir kimliğinin olduğunu biliyorsunuz. Kimlik işleçlerini
incelediğimiz konuda bundan bir miktar bahsetmiş ve oradaid()adlı bir
fonksiyondan söz etmiştik.

Orada şöyle bir örnek vermiştik:

```python
>>> a = 50
>>> id(a)

505494576

>>> kardiz = "Elveda Zalim Dünya!"
>>> id(kardiz)

14461728

```

Orada söylediğimiz ve yukarıdaki örneklerden de bir kez daha gördüğünüz gibi,
Python’daki her nesnenin kimliği eşşiz, tek ve benzersizdir.

### input()

Bu fonksiyonun ne işe yaradığını gayet iyi biliyorsunuz.input()adlı bu
gömülü fonksiyonu kullanarak kullanıcı ile veri alışverişinde bulunabiliyoruz.

### format()

Bu gömülü fonksiyonun görevi, daha önce karakter dizilerini işlerken, karakter
dizilerinin bir metodu olarak öğrendiğimizformat()metoduna benzer bir
şekilde, karakter dizilerini biçimlendirmektir. Ancakformat()fonksiyonu,
daha önce öğrendiğimizformat()metoduna göre daha dar kapsamlıdır.format()metodunu kullanarak oldukça karmaşık karakter dizisi biçimlendirme
işlemlerini gerçekleştirebiliriz, ama birazdan inceleyeceğimizformat()gömülü fonksiyonu yalnızca tek bir değeri biçimlendirmek için kullanılır.

Basit bir örnek verelim:

```python
>>> format(12, '.2f')

```

‘12.00’

Yukarıdaki ifadeyi daha önce gördüğümüzformat()metodu ile şu şekilde
yazabiliriz:

```python
>>> '{:.2f}'.format(12)

'12.00'

```

### filter()

Bu gömülü fonksiyon yardımıyla dizi niteliği taşıyan nesneler içindeki öğeler
üzerinde belirli bir ölçüte göre bir süzme işlemi uygulayabiliriz. Dilersenizfilter()fonksiyonunun görevini bir örnek üzerinden anlamaya çalışalım.

Diyelim ki elimizde şöyle bir liste var:

```python
>>> l = [400, 176, 64, 175, 355, 13, 207, 298, 397, 386, 31, 120, 120, 236, 241, 123, 249, 364, 292, 153]

```

Amacımız bu liste içindeki tek sayıları süzmek.

Daha önce öğrendiğimiz yöntemleri kullanarak bu görevi şu şekilde yerine
getirebiliriz:

```python
>>> for i in l:
... if i % 2 == 1:
... print(i)
...
175
355
13
207
397
31
241
123
249
153

```

Hatta eğer istersek liste üreteçlerini kullanarak aynı işlemi daha kısa bir
yoldan da halledebiliriz:

```python
>>> [i for i in l if i % 2 == 1]

[175, 355, 13, 207, 397, 31, 241, 123, 249, 153]

```

İşte Python, yukarıdaki işlemi yapabilmemiz için bize üçüncü bir yol daha
sunar. Bu üçüncü yolun adıfilter()fonksiyonudur. Dikkatlice bakın:

```python
def tek(sayı):
 return sayı % 2 == 1

print(*filter(tek, l))

```

Dilerseniz bu kodları daha iyi anlayabilmek içinfilter()fonksiyonuna biraz
daha yakından bakalım…

filter()fonksiyonu toplam iki parametre alır. Bu parametrelerden ilki
ölçütü belirleyen fonksiyon, ikincisi ise bu ölçütün uygulanacağı öğedir.
Yukarıdaki örneğe baktığımızda,tek()adlı fonksiyonun,ladlı öğe üzerine
uygulandığını görüyoruz.

Yukarıdaki örnekte ilk olaraktek()adlı bir fonksiyon tanımladık:

```python
def tek(sayı):
 return sayı % 2 == 1

```

Bu fonksiyonun görevi, kendisine parametre olarak verilen bir sayının tek sayı
olup olmadığını sorgulamak. Eğer verilen parametre bir tek sayı ise
fonksiyonumuzTruedeğerini, tek sayı değilseFalsedeğerini döndürecektir.
İsterseniz fonksiyonumuzu test edelim:

```python
print(tek(12))

```

12sayısı bir tek sayı olmadığı için fonksiyonumuz bizeFalseçıktısı verir.

Bir de şuna bakalım:

```python
print(tek(117))

```

117sayısı ise bir tek sayıdır. Bu nedenle fonksiyonumuz bizeTruedeğerini
verecektir.

İşte biz bu fonksiyonu,filter()fonksiyonu yardımıyla şu liste üzerine
uygulayacağız:

```python
l = [400, 176, 64, 175, 355, 13, 207, 298, 397, 386, 31,
 120, 120, 236, 241, 123, 249, 364, 292, 153]

```

Dediğimiz gibi,filter()fonksiyonu, dizi özelliği taşıyan nesneler üzerinde
belli bir ölçüte göre filtreleme işlemi yapmamızı sağlar. Biz de biraz önce
tanımladığımıztek()adlı fonksiyonuladlı bu listeye uygulayarak liste
içindeki tek sayıları filtreleyeceğiz.

filter()fonksiyonunu çalıştıralım:

```python
>>> filter(tek, l)

```

Buradafilter()fonksiyonuna ilk parametre olaraktek()fonksiyonunu
verdik. İkinci parametremiz ise bu fonksiyonu uygulayacağımızladlı liste.
Amacımız,ladlı liste üzerinetek()fonksiyonunu uygulayarak, bu liste
içindeki öğelerdenTrueçıktısı verenleri (yani tek sayıları) ayıklamak.

Şimdi de yukarıdaki koddan aldığımız çıktıya bakalım:

```python
<filter object at 0x00F74F30>

```

Gördüğünüz gibi, bu fonksiyonu bu şekilde kullandığımızda elde ettiğimiz şey bir
‘filtre nesnesi’. Bu nesne içindeki öğeleri görebilmek için ne yapabileceğimizi
biliyorsunuz:

```python
>>> list(filter(tek, l))

[175, 355, 13, 207, 397, 31, 241, 123, 249, 153]

```

veya:

```python
>>> print(*filter(tek, l))

175 355 13 207 397 31 241 123 249 153

```

ya da:

```python
>>> [i for i in filter(tek, l)]

[175, 355, 13, 207, 397, 31, 241, 123, 249, 153]

```

Gördüğünüz gibi, gerçekten deladlı liste içindeki bütün tek sayılar süzüldü.

Gelin istersenizfilter()fonksiyonunu biraz daha iyi anlayabilmek için
basit bir çalışma yapalım.

Elimizde bir sınıftaki öğrencilerin Matematik sınavından aldığı notları içeren
bir sözlük var:

```python
notlar = {'Ahmet' : 60,
 'Sinan' : 50,
 'Mehmet' : 45,
 'Ceren' : 87,
 'Selen' : 99,
 'Cem' : 98,
 'Can' : 51,
 'Kezban' : 100,
 'Hakan' : 66,
 'Mahmut' : 80}

```

Okulda kullanılan not sistemine göre yukarıdaki notları şu şekilde
sınıflandırabiliyoruz:

```python
def not_durumu(n):
 if n in range(0, 50): return 'F'
 if n in range(50, 70): return 'D'
 if n in range(70, 80): return 'C'
 if n in range(80, 90): return 'B'
 if n in range(90, 101): return 'A'

```

Buna göre meselaprint(not_durumu(54))gibi bir kod yazdığımızda bu notun
karşılık geldiği ‘D’ sayısını alabiliyoruz. Peki biz bu notları belli bir ölçüte
göre süzmek, ayıklamak istersek ne yapabiliriz? Örneğin notu 70’ten yukarı olan
öğrencileri listelemek istersek nasıl bir kod yazabiliriz?

İşte böyle bir durumdafilter()adlı gömülü fonksiyonu kullanabiliriz:

```python
notlar = {'Ahmet' : 60,
 'Sinan' : 50,
 'Mehmet' : 45,
 'Ceren' : 87,
 'Selen' : 99,
 'Cem' : 98,
 'Can' : 51,
 'Kezban' : 100,
 'Hakan' : 66,
 'Mahmut' : 80}

def süz(n):
 return n >= 70

print(*filter(süz, notlar.values()))

```

Gördüğünüz gibi,filter()fonksiyonu,süz()adlı fonksiyon ile
belirlediğimiz ölçütünotlaradlı sözlüğün değerleri üzerine tek tek
uygulamamızı sağlıyor.

### hash()

Bu fonksiyon, belirli türdeki nesnelere bir karma değeri vermemizi sağlar.
Örneğin:

```python
>>> hash('istihza')

-840510580

>>> hash('python')

212829695

```

Ancak bu fonksiyonun ürettiği çıktı aynı nesne için bütün sistemlerde aynı
olmayabilir. Yani örneğin yukarıdakihash('istihza')komutu 32 bitlik ve 64
bitlik işletim sistemlerinde birbirinden farklı sonuçlar verebilir. Ayrıca bu
fonksiyonun ürettiği karma değerlerinin birbiriyle çakışma ihtimali de
yüksektir. Dolayısıyla bu fonksiyonu kullanarak, mesela parola girişleri için
karma değeri üretmek doğru olmaz.

### isinstance()

Hatırlarsanız daha ilk derslerimizde öğrendiğimiztype()adlı bir fonksiyon
vardı. Bu fonksiyonu bir nesnenin hangi veri tipinde olduğunu tespit etmek için
kullanıyorduk:

```python
>>> type('istihza')

<class 'str'>

```

İşte buna benzer şekilde, tip denetimi için kullanabileceğimiz bir fonksiyon
daha var. Bu fonksiyonun adıisinstance().

Bu fonksiyonu şöyle kullanıyoruz:

```python
>>> isinstance('istihza', str)

True

```

Gördüğünüz gibi'istihza'gerçekten bir karakter dizisi (str) olduğu
için komutumuzTrueçıktısı veriyor.

Bir de şuna bakalım:

```python
>>> isinstance('istihza', list)

False

```

'istihza'bir liste (list) olmadığı için komutumuz bu kezFalseçıktısı verdi.

### len()

Bu fonksiyon yardımıyla nesnelerin uzunluklarını hesaplayabileceğimizi
biliyorsunuz:

```python
>>> len('istihza')

7

>>> l = [1, 4, 5, 3, 2, 9, 10]
>>> len(l)

7

```

### map()

Diyelim ki elimizde şöyle bir liste var:

```python
>>> l = [1, 4, 5, 4, 2, 9, 10]

```

Amacımız bu liste içindeki her öğenin karesini hesaplamak. Bunun için şöyle bir
yol izleyebiliriz:

```python
>>> for i in l:
... i ** 2
...
1
16
25
16
4
81
100

```

Böylece, istediğimiz gibi, bütün öğelerin karesini bulmuş olduk. Bu tür bir
işlemi yapmanın bir başka yolu damap()adlı bir gömülü fonksiyondan
yararlanmaktır. Dikkatlice bakın:

```python
>>> def karesi(n):
... return n ** 2
...

```

Burada birnsayısının karesini hesaplayan bir fonksiyon tanımladık. Şimdi bu
fonksiyonullistesinin bütün öğeleri üzerine uygulayacağız:

```python
>>> list(map(karesi, l))

[1, 16, 25, 16, 4, 81, 100]

```

### max()

max()gömülü fonksiyonunun görevi, bir dizi içindeki en büyük öğeyi
vermektir. Bu fonksiyon birkaç farklı parametre alır ve verdiği çıktı, aldığı
parametrelerin türüne ve sayısına bağlı olarak değişiklik gösterebilir.

Bu fonksiyonu en basit şu şekilde kullanabilirsiniz:

```python
>>> max(1, 2, 3)

3

```

max()fonksiyonu yukarıdaki şekilde çalıştırıldığında, kendisine verilen
parametreler arasında en büyük olanı bulacaktır. Yukarıdaki parametrelerden en
büyüğü3olduğu için de yukarıdaki komut3çıktısı verecektir.

Yukarıdaki kodların sağladığı etkiyi şu şekilde de elde edebiliriz:

```python
>>> liste = [1, 2, 3]
>>> max(liste)

3

```

max()fonksiyonu yukarıda gösterildiği gibi birtakım isimsiz parametrelerle
birliktekeyadlı isimli bir parametre de alır. Bu parametre yardımıylamax()fonksiyonunun ‘en büyük’ kavramını hangi ölçüte göre seçeceğini
belirleyebiliriz. Örneğin:

```python
>>> isimler = ['ahmet', 'can', 'mehmet', 'selin', 'abdullah', 'kezban']
>>> max(isimler, key=len)

'abdullah'

```

max()fonksiyonu öntanımlı olarak, ‘en büyük’ kavramını sayısal büyüklük
üzerinden değerlendirir. Yani herhangi birkeyparametresi kullanılmadığında,
bu fonksiyon otomatik olarak bir dizi içindeki en büyük sayıyı bulur. Ancak eğer
biz istersek, yukarıdaki örnekte olduğu gibi, ‘en büyük’ kavramının uzunluk
cinsinden değerlendirilmesini de sağlayabiliriz.

Yukarıdaki örnekte elimizde şöyle bir liste var:

```python
>>> isimler = ['ahmet', 'can', 'mehmet', 'selin', 'abdullah', 'kezban']

```

Amacımız bu liste içindeki isimler arasından, en fazla harf içerenini bulmak.
Bildiğiniz gibi Python’da bir karakter dizisinin uzunluğunu belirlemek içinlen()adlı bir fonksiyondan yararlanıyoruz. İşte aşağıdaki kod yardımıyla damax()fonksiyonunun ‘en büyük’ ölçütünülen()fonksiyonu üzerinden
değerlendirmesini sağlıyoruz:

```python
>>> max(isimler, key=len)

```

Bu aradakeyfonksiyonunalen()fonksiyonunu parantezsiz olarak
verdiğimize dikkat edin.

Gelin istersenizmax()fonksiyonunu biraz daha iyi anlamak için ufak bir
çalışma yapalım.

Diyelim ki elimizde şöyle bir sözlük var:

```python
askerler = {'ahmet' : 'onbaşı',
 'mehmet' : 'teğmen',
 'ali' : 'yüzbaşı',
 'cevat' : 'albay',
 'berkay' : 'üsteğmen',
 'mahmut' : 'binbaşı'}

```

Amacımız bu sözlük içindeki en yüksek askeri rütbeyi bulmak. İşte bunun içinmax()fonksiyonundan yararlanabiliriz.

Bildiğiniz gibi,max()fonksiyonu ölçüt olarak sayısal büyüklüğü göz önüne
alıyor. Elbette askeri rütbeleri böyle bir ölçüte göre sıralamak pek mümkün
değil. Ama eğer şöyle bir fonksiyon yazarsak işler değişir:

```python
def en_yüksek_rütbe(rütbe):
 rütbeler = {'er' : 0,
 'onbaşı' : 1,
 'çavuş' : 2,
 'asteğmen' : 3,
 'teğmen' : 4,
 'üsteğmen' : 5,
 'yüzbaşı' : 6,
 'binbaşı' : 7,
 'yarbay' : 8,
 'albay' : 9}

 return rütbeler[rütbe]

```

Burada, rütbelerin her birine bir sayı verdik. En küçük rütbe en düşük sayıya,
en yüksek rütbe ise en büyük sayıya sahip. Fonksiyonumuz bir adet parametre
alıyor. Bu parametrenin adırütbe. Yazdığımız fonksiyon, kendisine parametre
olarak verilecek rütbeyirütbeleradlı sözlükte arayıp, bu rütbeye karşılık
gelen sayıyı döndürecek.

Bu bilgileri kullanarak kodlarımızın son halini düzenleyelim:

```python
def en_yüksek_rütbe(rütbe):
 rütbeler = {'er' : 0,
 'onbaşı' : 1,
 'çavuş' : 2,
 'asteğmen' : 3,
 'teğmen' : 4,
 'üsteğmen' : 5,
 'yüzbaşı' : 6,
 'binbaşı' : 7,
 'yarbay' : 8,
 'albay' : 9}

 return rütbeler[rütbe]

askerler = {'ahmet': 'onbaşı',
 'mehmet': 'teğmen',
 'ali': 'yüzbaşı',
 'cevat': 'albay',
 'berkay': 'üsteğmen',
 'mahmut': 'binbaşı'}

```

Artıkmax()fonksiyonunuaskerleradlı sözlük üzerinde uygulayabiliriz:

```python
print(max(askerler.values(), key=en_yüksek_rütbe))

```

Böyleceaskerleradlı sözlüğün değerlerien_yüksek_rütbe()fonksiyonunun
sunduğu ölçüt üzerinden ele alınacak ve en büyük sayı değerine sahip olan rütbe
çıktı olarak verilecektir.

Yukarıdaki kodlar problemimizi çözüyor. Peki ama ya biz rütbe ile birlikte bu
rütbeyi taşıyan askerin adını da öğrenmek istersek nasıl bir kod yazacağız?

Bunun için de şöyle bir kod yazabiliriz:

```python
for k, v in askerler.items():
 if askerler[k] in max(askerler.values(), key=en_yüksek_rütbe):
 print(v, k)

```

Eğer isterseniz buradainişleci yerine==işlecini de kullanabilirsiniz:

```python
for k, v in askerler.items():
 if askerler[k] == max(askerler.values(), key=en_yüksek_rütbe):
 print(v, k)

```

### min()

min()fonksiyonumax()fonksiyonunun tam tersini yapar. Bildiğiniz gibimax()fonksiyonu bir dizi içindeki en büyük öğeyi buluyordu. İştemin()fonksiyonu da bir dizi içindeki en küçük öğeyi bulur. Bu fonksiyonun kullanımımax()ile aynıdır.

### open()

Bu fonksiyon herhangi bir dosyayı açmak veya oluşturmak için kullanılır. Eğer
dosyanın açılması veya oluşturulması esnasında bir hata ortaya çıkarsaIOErrortüründe bir hata mesajı verilir.

Bu fonksiyonun formülü şudur:

```python
>>> open(dosya_adi, mode='r', buffering=-1, encoding=None,
... errors=None, newline=None, closefd=True, opener=None)

```

Gördüğünüz gibi, bu fonksiyon pek çok farklı parametre alabiliyor. Biz şimdiye
kadar bu parametrelerin yalnızca en sık kullanılanlarını işlemiştik. Şimdi ise
geri kalan parametrelerin ne işe yaradığını da ele alacağız.

Yukarıdaki formülden de görebileceğiniz gibi,open()fonksiyonunun ilk
parametresidosya_adi’dır. Yani açmak veya oluşturmak istediğimiz dosya adını
bu parametre ile belirtiyoruz:

```python
>>> open('falanca_dosya.txt')

```

Elbette eğer açmak istediğiniz dosya, o anda içinde bulunduğunuz dizinde değilse
dosya adı olarak, o dosyanın tam adresini yazmanız gerekir. Mesela:

```python
>>> open('/home/istihza/Desktop/dosya.txt')

```

Bu arada, dosya adresini yazarken ters taksim yerine düz taksim işaretlerini
kullanmak daha doğru olacaktır. Bu taksim türü hem Windows’ta hem de
GNU/Linux’ta çalışır. Ancak eğer ters taksim işaretlerini kullanacaksanız, dosya
yolu içindeki sinsi kaçış dizilerine karşı dikkatli olmalısınız:

```python
>>> f = open('test\nisan.txt')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
OSError: [Errno 22] Invalid argument: 'test\nisan.txt'

```

Burada probleminnisan.txtadlı dosyanın ilk harfi ile, bundan önce gelen ters
taksim işaretinin birleşerek tesadüfen bir kaçış dizisi oluşturması olduğunu
biliyorsunuz. Bu tür hatalara karşı ters taksim yerine düz taksim işaretlerini
kullanabileceğiniz gibiradlı kaçış dizisinden de yararlanabilirsiniz:

```python
f = open(r'test\nisan.txt')

```

open()fonksiyonunun ikinci parametresi olanmode’un da ne olduğunu
biliyorsunuz. Bu parametre yardımıyla, herhangi bir dosyayı hangi kipte açmak
istediğimizi belirtebiliyoruz.

Bildiğiniz gibi, eğermodeparametresine herhangi bir değer vermezseniz Python
ilgili dosyayı okuma kipinde açacaktır.

Bu parametreye verebileceğiniz değerleri şöyle özetleyebiliriz:
| Karakter | Anlamı |
| --- | --- |
| ‘r’ | Okuma kipidir. Öntanımlı değer budur. |
| ‘w’ | Yazma kipidir. Eğer belirtilen adda dosya zaten varsa o dosya
silinir. |
| ‘x’ | Yeni bir dosya oluşturulup yazma kipinde açılır. |
| ‘a’ | Dosya ekleme kipinde açılır. Bu kip ile, varolan bir dosyanın sonuna
eklemeler yapılabilir. |
| ‘b’ | Dosyaları ikili kipte açmak için kullanılır. |
| ‘t’ | Dosyaları metin kipinde açmak için kullanılır. Öntanımlı değerdir. |
| ‘+’ | Aynı dosya üzerinde hem okuma hem de yazma işlemleri yapılmasını
sağlar. |

Karakter

Anlamı

‘r’

Okuma kipidir. Öntanımlı değer budur.

‘w’

Yazma kipidir. Eğer belirtilen adda dosya zaten varsa o dosya
silinir.

‘x’

Yeni bir dosya oluşturulup yazma kipinde açılır.

‘a’

Dosya ekleme kipinde açılır. Bu kip ile, varolan bir dosyanın sonuna
eklemeler yapılabilir.

‘b’

Dosyaları ikili kipte açmak için kullanılır.

‘t’

Dosyaları metin kipinde açmak için kullanılır. Öntanımlı değerdir.

‘+’

Aynı dosya üzerinde hem okuma hem de yazma işlemleri yapılmasını
sağlar.

open()fonksiyonunun alabileceği bir başka parametre debufferingparametresidir. Bildiğiniz gibi,open()fonksiyonuyla bir dosyayı açıp bu
dosyaya veri girdiğimizde bu veriler önce tampona alınacak, dosya kapandıktan
sonra ise tamponda bekletilen veriler dosyaya işlenecektir. İşte bubufferingparametresi yardımıyla bu tampona alma işleminin nasıl yürüyeceğini
belirleyebiliriz.

Eğer dosyaya işlenecek verilerin tampona alınmadan doğrudan dosyaya işlenmesini
istersenizbufferingdeğerini0olarak belirlersiniz. Yalnız bu değer sadece
ikili kipte etkindir. Yani bir dosyayı eğer metin kipinde açıyorsanızbufferingparametresinin değerini0yapamazsınız.

Eğer dosyaya veri işlerken tampona alınan verilerin satır satır dosyaya
eklenmesini istersenizbufferingdeğerini1olarak belirlersiniz. Bunun
nasıl çalıştığını anlamak için şu örneği dikkatlice inceleyin:

```python
>>> f = open('ni.txt', 'w', buffering=1)
>>> f.write('birinci satır\n')

14

>>> f.write('ikinci satır\n')

13

>>> f.write('aaa')

3

>>> f.write('\n')

1

```

Burada herwrite()komutundan sonrani.txtadlı dosyayı açıp bakarsanız,
şu durumu görürsünüz:
- f.write('birincisatır\n')komutuyla dosyaya bir satırlık veri ekledik ve
bu veri dosyaya anında işlendi.
- f.write('ikincisatır\n')komutuyla dosyaya bir satırlık başka bir veri
daha ekledik ve bu veri de dosyaya anında işlendi.
- f.write('aaa')komutuyla eklenen veri satır değil. Çünkü satır sonuna
işaret eden satır başı kaçış dizisini kullanmadık.
- f.write('\n')komutuyla satır başı kaçış dizisini eklediğimiz anda bir
önceki karakter dizisi ('aaa') de dosyaya eklenecektir.

f.write('birincisatır\n')komutuyla dosyaya bir satırlık veri ekledik ve
bu veri dosyaya anında işlendi.

f.write('ikincisatır\n')komutuyla dosyaya bir satırlık başka bir veri
daha ekledik ve bu veri de dosyaya anında işlendi.

f.write('aaa')komutuyla eklenen veri satır değil. Çünkü satır sonuna
işaret eden satır başı kaçış dizisini kullanmadık.

f.write('\n')komutuyla satır başı kaçış dizisini eklediğimiz anda bir
önceki karakter dizisi ('aaa') de dosyaya eklenecektir.

Ancakbufferingparametresi bu1değerini yalnızca metin kipinde alabilir.
Bu kısıtlamayı da aklımızın bir kenarına not edelim…

0ve1dışındabufferingparametresine 1’den büyük bir değer verdiğinizde
ise tampon boyutunun ne kadar olacağını kendiniz belirlemiş olursunuz.

Yalnız çoğu durumdabufferingparametresine herhangi bir özel değer atamanız
gerekmeyecektir. Bu parametreye herhangi bir değer atamadığınızda, kullandığınız
işletim sistemi tampona alma işlemlerininin nasıl yürütüleceğine ve tampon
boyutuna kendisi karar verecektir. İşletim sisteminin sizin yerinize verdiği bu
karar da çoğunlukla istediğiniz şey olacaktır… Eğer kendi sisteminizde
öntanımlı tampon boyutunun ne olduğunu merak ediyorsanız şu komutları
kullanabilirsiniz:

```python
>>> import io
>>> io.DEFAULT_BUFFER_SIZE

```

Çoğu sistemde bu değer 4096 ve 8192 bayt olacaktır.

open()fonksiyonunun alabileceği bir başka parametre deencodingparametresidir. Bu parametre, dosyanın hangi karakter kodlaması ile açılacağını
belirler. Örneğin bir dosyayı ‘UTF-8’ karakter kodlaması ile açmak için şu
komutu kullanıyoruz:

```python
>>> f = open('dosya', encoding='utf-8')

```

Üzerinde işlem yaptığınız dosyalarda özellikle Türkçe karakter sorunları yaşamak
istemiyorsanız, bir dosyayı açarken mutlakaencodingparametresinin değerini
de ayarlamanızı tavsiye ederim.

Bir dosyayı açarken veya okurken herhangi bir karakter kodlama hatası ile
karşılaştığınızda Python’ın ne tepki vermesi gerektiğini iseerrorsadlı
parametre yardımıyla belirleyebilirsiniz.

Eğer bu parametreyestrictdeğerini verirseniz karakter kodlama hataları
programınızınValueErrortüründe bir hata vererek çalışmayı kesmesine neden
olacaktır. Bu parametreye herhangi bir değer vermediğinizde de Python sankistrictdeğerini vermişsiniz gibi davranır.

Eğererrorsparametresineignoredeğerini verirseniz kodlama hataları
görmezden gelinecek, bu hataya sebep olan karakter silinecektir. Yalnız bu
değerin veri kaybına yol açma ihtimalini de göz önünde bulundurmalısınız.

Eğererrorsparametresinereplacedeğerini verirseniz kodlama hatasına yol
açan karater ‘?’ veya ‘ufffd’ karakterleri ile değiştirilecektir.

open()fonksiyonunun kabul ettiği bir başka parametre denewlineadlı
parametredir. Peki bu parametre ne işe yarar?

Windows ve GNU/Linux işletim sistemleri satır sonlarını birbirlerinden farklı
şekilde gösterir. GNU/Linux’ta yazılmış dosyalarda satır sonları\nkarakteri
ile gösterilirken, Windows’ta yazılmış dosyalarda satır sonunda\r\nkarakterleri bulunur. Eğer Windows ve GNU/Linux sistemleri arasında dosya
alışverişi yapıyorsanız kimi durumlarda bu farklılık çeşitli sorunların ortaya
çıkmasına yol açabilir. İşte dosyalarınızın hangi satır sonu karakterine sahip
olacağını yukarıda bahsettiğimiznewlineadlı parametre ile
belirleyebilirsiniz. Örneğin:

```python
>>> f = open('dosya', newline='\n')

```

Bu şekilde dosyanız hangi işletim sisteminde olursa olsun satır sonlarında\nkarakterine sahip olacaktır.

Dosyaların metotlarını incelerseniz o listedefileno()adlı bir metodun
olduğunu göreceksiniz. Bu metot, bize bir dosyanın ‘dosya tanımlayıcısını’
(file descriptor) verir. Dosya tanımlayıcıları, dosyaya işaret eden
pozitif tam sayılardır.0,1ve2sayıları standart girdi, standart çıktı
ve standart hata dosyalarına ayrılmış olduğu için, sizin açtığınız ve üzerinde
işlem yaptığınız dosyaların tanımlayıcıları2sayısından büyük olacaktır.

Bir örnek verelim:

```python
>>> f = open('ni.txt')
>>> f.fileno()

3

```

İşte burada gördüğünüz sayı,ni.txtadlı dosyanın ‘dosya tanımlayıcısıdır. Her
dosyanın dosya tanımlayıcısı benzersizdir:

```python
>>> g = open('zi.txt')
>>> g.fileno()

4

```

Python’da bir dosyayıopen()fonksiyonuyla açarken dosya adını vermenin
yanı sıra, dosyanın tanımlayıcısını da kullanabilirsiniz:

```python
>>> z = open(4)

```

veya:

```python
>>> z = open(g.fileno())

```

Bu sayede, eğer isterseniz, elinizdeki dosyalarla daha ileri düzeyli işlemler
yapabilirsiniz. Bir örnek verelim.

Dediğimiz gibi, bir dosyanın tanımlayıcısı tek ve benzersizdir. Farklı dosyalar
aynı tanımlayıcılara sahip olmaz:

```python
>>> a = open('aaa.txt')
>>> a.fileno()

3

>>> b = open('bbb.txt')
>>> b.fileno()

4

```

Şimdi şu örneklere bakın:

```python
>>> c = open(b.fileno(), closefd=False)

```

Bu şekildebadlı dosyanın tanımlayıcısını kullanarak, aynı dosyayı bir decadıyla açtık. Ancak burada kullandığımızclosefd=Falseparametresine dikkat
edin. Normalde dosyayı kapattığımızda dosyanın tanımlayıcısı serbest kalır ve
başka bir dosya açıldığında bu tanımlayıcı yeni dosyaya atanır. AmaclosefdparametresineFalsedeğeri verdiğimizde dosya kapansa bile, o dosyaya ait
dosya tanımlayıcısı varolmaya devam edecektir.

### pow()

Daha önceki derslerimizde pek çok kez örneklerini verdiğimiz bu fonksiyon
İngilizcedekipower(kuvvet) kelimesinin kısaltmasından oluşur. Adının
anlamına uygun olarak, bu fonksiyonu bir sayının kuvvetlerini hesaplamak için
kullanıyoruz.

Bu fonksiyon en temel şekilde şöyle kullanılır:

```python
>>> pow(2, 3)

8

```

Bu komutla2sayısının 3. kuvvetini hesaplamış oluyoruz.

pow()fonksiyonu toplamda üç farklı parametre alır. İlk iki parametrenin ne
olduğunu yukarıda örnekledik. Üçüncü parametre ise kuvvet hesaplaması sonucu
elde edilen sayının modülüsünü hesaplayabilmemizi sağlar. Yani:

```python
>>> pow(2, 3, 2)

0

```

Burada yaptığımız şey şu: Öncelikle2sayısının 3. kuvvetini hesapladık. Elde
ettiğimiz sayı8. Ardından da bu sayının2’ye bölünmesi işleminden kalan
sayıyı elde ettik. Yani0. Çünkü bildiğiniz gibi8%2işleminin sonucu0’dır. Dolayısıyla yukarıdaki komut şuna eşdeğerdir:

```python
>>> (2 ** 3) % 2

0

```

Ancak önceki derslerimizde de söylediğimiz gibi,pow()fonksiyonu çoğunlukla
yalnızca ilk iki parametresi ile birlikte kullanılır:

```python
>>> pow(12, 2)

144

```

### print()

print()fonksiyonunu artık gayet iyi tanıyoruz. Bu fonksiyonu, bildiğiniz
gibi, kullanıcılarımıza birtakım mesajlar göstermek için kullanıyoruz.

Kullanımını daha önce ayrıntılı bir şekilde anlatmış olduğumuz bu fonksiyonu şu
şekilde formüle edebiliriz:

```python
print(deg1, deg2, deg3, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

```

Burada;

Çıktı verilecek değerlerin ne olduğunu belirtir. Buraya 256 adete
kadar değer yazabilirsiniz.

Çıktı verilirken değerlerin arasına hangi karakterin yerleştirileceğini
belirtir. Bu değer öntanımlı olarak boşluk karakteridir.

Çıktı verilecek son değerin ardından hangi karakterin iliştirileceğini
belirtir. Bu değer öntanımlı olarak satır başı (\n) karakteridir.

Çıktıların hangi dosyaya yazılacağını belirtir. Öntanımlı olarak bu
parametrenin değerisys.stdout’tur. Yaniprint()fonksiyonu
çıktılarını öntanımlı olarak standart çıktı konumuna gönderir.

Bildiğiniz gibi, herhangi bir dosyaya yazma işlemi sırasında dosyaya
yazılacak değerler öncelikle tampona alınır. İşlem tamamlandıktan sonra
tampondaki bu değerler topluca dosyaya aktarılır. İşte bu parametre, değerleri
tampona almadan doğrudan dosyaya gönderebilmemizi sağlar. Bu parametrenin
öntanımlı değeriFalse’tur. Yani değerler dosyaya yazılmadan önce
öntanımlı olarak öncelikle tampona gider. Ama eğer biz bu parametrenin
değeriniTrueolarak değiştirirsek, değerler doğrudan dosyaya yazılır.

### quit()

Bu fonksiyonu programdan çıkmak için kullanıyoruz. Eğer bu fonksiyonu
etkileşimli kabukta verecek olursanız etkileşimli kabuk kapanacaktır.

### range()

Bu fonksiyonu belli bir aralıktaki sayıları listelemek için kullanıyoruz. Yani
mesela0ile10arası sayıların listesini almak istersek şöyle bir komut
yazabiliriz:

```python
>>> l = range(0, 10)

```

Ancak burada dikkat etmemiz gereken bir özellik var: Bu fonksiyon aslında
doğrudan herhangi bir sayı listesi oluşturmaz. Yukarıdaldeğişkenine
atadığımız komutu ekrana yazdırırsak bunu daha net görebilirsiniz:

```python
>>> print(l)

range(0, 10)

```

Bir de bu verinin tipine bakalım:

```python
>>> type(l)

<class 'range'>

```

Gördüğünüz gibi, elimizdeki şey aslında bir sayı listesi değil, bir ‘range’
(aralık) nesnesidir. Biz bu nesneyi istersek başka veri tiplerine
dönüştürebiliriz. Mesela bunu bir listeye dönüştürelim:

```python
>>> list(l)

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

veya bir demete:

```python
>>> tuple(l)

(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

```

ya da bir kümeye veya dondurulmuş kümeye:

```python
>>> set(l) #küme

{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

>>> frozenset(l) #dondurulmuş küme

frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})

```

Bu ‘range’ nesnesini istediğiniz veri tipine dönüştürdükten sonra,
dönüştürdüğünüz veri tipinin kuralları çerçevesinde elinizdeki veriyi
işleyebilirsiniz.

range()fonksiyonundan elde ettiğiniz ‘range’ nesnesinin içeriğini elde etmek
için bunu başka bir veri tipine dönüştürmenin yanısıra, bu nesne üzerinde birfordöngüsü de kurabilirsiniz:

```python
>>> for i in range(10):
... print(i)
...
0
1
2
3
4
5
6
7
8
9

```

Ya da yıldızlı parametreler yardımıyla bu nesneyiprint()fonksiyonuna
göndererek, bu nesneyi istediğiniz gibi evirip çevirebilirsiniz:

```python
>>> print(*range(10), sep=', ')

0, 1, 2, 3, 4, 5, 6, 7, 8, 9

```

Esasında, yukarıda nasıl kullanılacağına dair bazı örnekler verdiğimiz burange()fonksiyonunu temel olarak şu şekilde formüle edebiliriz:

```python
range(başlangıç_değer, bitiş_değeri, atlama_değeri)

```

Aşağıdaki örneği tekrar ele alalım:

```python
>>> range(0, 10)

```

Burada0başlangıç değeri,10ise bitiş değeridir. Buna göre oluşturulacak
sayılar0ile10arasında olacaktır. Yalnız burada üretilecek sayı listesinde0sayısının dahil,10sayısının ise hariç olduğunu unutmuyoruz. Yani bu
komutun bize vereceği ilk sayı0; son sayı ise9olacaktır.

range()fonksiyonunda başlangıç değerinin öntanımlı değeri0’dır.
Dolayısıyla istersek biz yukarıdaki komutu şöyle de yazabiliriz:

```python
>>> range(10)

```

Böylece Python bizimrange(0,10)komutunu kastettiğimizi varsayacaktır.
Elbette eğer başlangıç değerinin0dışında bir değer olmasını istiyorsanız
bunu özellikle belirtmeniz gerekir:

```python
>>> range(10, 100)

```

Bu komut bize10ile (10dahil)100arası (100hariç) sayıları içeren
bir ‘range’ nesnesi verecektir.

Yukarıda verdiğimiz formülden de göreceğiniz gibi,başlangıç_değervebitiş_değerdışındarange()fonksiyonu üçüncü bir parametre daha
alabiliyor. Bu parametreyeatlama_değeriadı verdik. Bu parametreyi şöyle
kullanıyoruz:

```python
>>> list(range(0, 10, 2))

[0, 2, 4, 6, 8]

```

Gördüğünüz gibi,range()fonksiyonuna üçüncü parametre olarak verdiğimiz2sayısı,0ile10arası sayıların ikişer ikişer atlanarak üretilmesini
sağladı.

### reversed()

Diyelim ki elimizde şöyle bir liste var:

```python
>>> isimler = ['ahmet', 'mehmet', 'veli', 'ayşe', 'çiğdem', 'ışık']

```

Eğer bu listedeki isimleri ters çevirmek, yani şöyle bir liste elde etmek
isterseniz:

```python
['ışık', 'çiğdem', 'ayşe', 'veli', 'mehmet', 'ahmet']

```

… ne yapmanız gerektiğini biliyorsunuz. Bu amaç için liste dilimleme
yöntemlerinden yararlanabilirsiniz:

```python
>>> isimler[::-1]

['ışık', 'çiğdem', 'ayşe', 'veli', 'mehmet', 'ahmet']

```

İşte aynı işlevireversed()adlı bir fonksiyon yardımıyla da yerine
getirebilirsiniz:

```python
>>> reversed(isimler)

<list_reverseiterator object at 0x00EB9710>

```

Gördüğünüz gibi, tıpkırange()fonksiyonunda olduğu gibi,reversed()fonksiyonu da bize ürettiği öğelerin kendisi yerine, bir ‘nesne’ veriyor.
Ama tabii ki bu bizim için bir sorun değil. Biz bu nesnenin içeriğini nasıl elde
edebileceğimizi gayet iyi biliyoruz:

```python
>>> list(reversed(isimler))

['ışık', 'çiğdem', 'ayşe', 'veli', 'mehmet', 'ahmet']

```

range()fonksiyonunu anlatırken sözünü ettiğimiz içerik elde etme
yöntemlerinireversed()fonksiyonuna da uygulayabilirsiniz.

### sorted()

Bu metot, daha önceki derslerimizden de bildiğiniz gibi, bir dizi içindeki
öğeleri belirli bir ölçüte göre sıraya dizmemizi sağlıyor. Bununla ilgili çok
basit bir örnek verelim:

```python
>>> sorted('ahmet')

['a', 'e', 'h', 'm', 't']

```

Bu kodlar yardımıylaahmetadlı karakter dizisi içindeki harfleri alfabe
sırasına dizdik.

Elbette bu fonksiyonu sadece karakter dizileri üzerine uygulamıyoruz.sorted()adlı fonksiyon, dizi özelliği taşıyan her türlü nesne üzerine
uygulanabilir. Mesela demetlerin ve listelerin bir dizi olduğunu biliyoruz.
Dolayısıyla:

```python
>>> sorted(('elma', 'armut', 'kiraz', 'badem'))

['armut', 'badem', 'elma', 'kiraz']

>>> sorted(['elma', 'armut', 'kiraz', 'badem'])
['armut', 'badem', 'elma', 'kiraz']

```

sorted()fonksiyonuna hangi türde bir veri tipi verirseniz verin, aldığınız
çıktı her zaman bir liste olacaktır. Bunu unutmayın.

Gördüğünüz gibi,sorted()fonksiyonu nesneler üzerinde bir sıralama işlemi
gerçekleştiriyor. Ancak bu fonksiyonun bir problemi var.

Dikkatlice bakın:

```python
>>> isimler = ['ahmet', 'çiğdem', 'ışık', 'şebnem', 'zeynep', 'selin']
>>> sorted(isimler)

['ahmet', 'selin', 'zeynep', 'çiğdem', 'ışık', 'şebnem']

```

Bu fonksiyon, Türkçe karakter içeren öğeleri düzgün sıralayamaz.

Bu sorunukısmençözebilmek içinlocaleadlı bir modül içindekistrxfrm()adlı bir fonksiyondan yararlanabilirsiniz:

```python
>>> import locale

```

Henüz modülleri öğrenmemiş de olsak, bir modülü kullanabilmek için öncelikle o
modülü ‘içe aktarmamız’ gerektiğini artık biliyorsunuz. Bu işlemiimportadlı bir komut yardımıyla yaptığımızı da biliyorsunuz.

Şimdi de yerelimizi (locale) ‘Türkçe’ olarak ayarlayalım:

```python
>>> locale.setlocale(locale.LC_ALL, 'tr_TR') #GNU/Linux
>>> locale.setlocale(locale.LC_ALL, 'Turkish_Turkey.1254') #Windows

```

Bu işlemleri yaptıktan sonra,sorted()fonksiyonununkeyadlı bir
parametresini kullanarak ve yinelocalemodülününstrxfrm()adlı
fonksiyonundan faydalanarak Türkçe karakterler içeren listemizi sıralamayı
deneyebiliriz:

```python
>>> sorted(isimler, key=locale.strxfrm)

['ahmet', 'çiğdem', 'ışık', 'selin', 'şebnem', 'zeynep']

```

localemodülü içinde bulunanstrxfrm()adlı fonksiyon, karakter
dizilerinin, o anda etkin yerel neyse, ona göre muamele görmesini sağlar. Biz
yukarıda yerelimizi Türkçe olarak ayarladığımız içinstrxfrm()fonksiyonu,sorted()ile yapılan alfabe sırasına dizme işleminin Türkçenin kurallarına
göre yapılmasını sağlıyor.

Ancak bu yöntemin de sorunlu olduğunu bir süre sonra kendiniz de
farkedeceksiniz. Mesela şu örneği inceleyin:

```python
>>> sorted('afgdhkıi', key=locale.strxfrm)

['a', 'd', 'f', 'g', 'h', 'i', 'ı', 'k']

```

Gördüğünüz gibi, listede ‘i’ harfi ‘ı’ harfinden önce geliyor. Ama aslında bunun
tersi olmalıydı.

İşte böyle bir durumda, kendi sıralama mekanizmamızı kendimiz icat etmeliyiz.
Peki ama nasıl?

Bilgisayarlar farklı dillerdeki karakterleri her zaman doğru sıralayamasa da,
sayıları her zaman doğru sıralar:

```python
>>> sorted([10, 9, 4, 14, 20])

[4, 9, 10, 14, 20]

```

Bilgisayarların bu özelliğinden ve Python’daki sözlük veri tipinden yararlanarak
kendi sıralama mekanizmamızı rahatlıkla icat edebiliriz.

Öncelikle harflerimizi yazalım:

```python
>>> harfler = "abcçdefgğhıijklmnoöprsştuüvyz"

```

Burada Türk alfabesini oluşturan harfleri sırasına göre dizdik. Şimdi bu
harflerin her birine bir sayı vereceğiz:

```python
>>> çevrim = {'a': 0, 'b': 1, 'c': 2, 'ç': 3, 'd': 4,
... 'e': 5, 'f': 6, 'g': 7, 'ğ': 8, 'h': 9,
... 'ı': 10, 'i': 11, 'j': 12, 'k': 13,
... 'l': 14, 'm': 15, 'n': 16, 'o': 17,
... 'ö': 18, 'p': 19, 'r': 20, 's': 21,
... 'ş': 22, 't': 23, 'u': 24, 'ü': 25,
... 'v': 26, 'y': 27, 'z': 28}

```

Yalnız böyle her harfe karşılık gelen sayıyı elle yazmak yorucu olacaktır. Bu
işlemi daha kolay bir şekilde yapabilmek için farklı teknikleri
kullanabilirsiniz. Mesela daha önce öğrendiğimiz sözlük üreteçlerinden
yararlanabilirsiniz:

```python
>>> çevrim = {i: harfler.index(i) for i in harfler}

```

Bu şekildeharflerdeğişkeni içindeki her bir harfin bir anahtar; bu harflerinharflerdeğişkeni içindeki sırasını gösteren her bir sayının ise bir değer
olduğu bir sözlük oluşturmuş olduk.

Şimdi isim listemizi alalım karşımıza:

```python
isimler = ["ahmet", "ışık", "ismail",
 "çiğdem", "can", "şule"]

```

Normal birsorted()işleminin yanlış sonuç döndüreceğini biliyoruz:

```python
>>> sorted(isimler)

['ahmet', 'can', 'ismail',
 'çiğdem', 'ışık', 'şule']

```

Aynı şekildekeyparametresinelocale.strxfrmdeğerinin verilmesi de
yetersiz kalacaktır:

```python
>>> sorted(isimler, key=locale.strxfrm)

['ahmet', 'can', 'çiğdem', 'ismail',
 'ışık', 'şule']

```

Ama biraz önce oluşturduğumuzçevrimanahtarını kullanırsak durum bambaşka
olacaktır:

```python
>>> sorted(isimler, key=lambda x: çevrim.get(x[0]))

['ahmet', 'can', 'çiğdem', 'ışık', 'ismail', 'şule']

```

Ancak aslında burada da oldukça sinsi bir problem var. Bu metot ile kelime
listesini oluşturan kelimeleri yalnızca ilk harflerine göre sıralıyoruz
(x[0]). Peki ya aynı liste içinde ilk harfleri aynı olup, sonraki harflerde
farklılaşan kelimeler varsa ne olacak? Yani mesela bu metot acaba ‘ismail’ ve
‘iskender’ kelimelerini doğru bir şekilde sıralayabilir mi? Bakalım:

```python
harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
çevrim = {i: harfler.index(i) for i in harfler}

isimler = ["ahmet", "ışık", "ismail", "çiğdem",
 "can", "şule", "iskender"]

print(sorted(isimler, key=lambda x: çevrim.get(x[0])))

```

Buradan şu çıktıyı alıyoruz:

```python
['ahmet', 'can', 'çiğdem', 'ışık', 'ismail', 'iskender', 'şule']

```

Gördüğünüz gibi ‘ismail’ ve ‘iskender’ kelimeleri doğru bir şekilde sıralanmadı;
‘iskender’ kelimesinin ‘ismail’ kelimesinden önce gelmesi gerekiyordu…

Demek ki şimdiye kadar kullandığımız bütün sıralama yöntemlerinin bir eksiği
varmış. O halde başka bir metot bulmaya çalışalım.

Dikkatlice bakın:

```python
harfler = 'abcçdefgğhıijklmnoöprsştuüvyz'
çevrim = {i: harfler.index(i) for i in harfler}

def sırala(kelime):
 return ([çevrim.get(kelime[i]) for i in range(len(kelime))])

isimler = ['ahmet', 'can', 'iskender', 'cigdem',
 'ismet', 'ismail', 'ismit', 'çiğdem',
 'ismıt', 'ışık', 'şule']

print(*sorted(isimler, key=sırala), sep='\n')

```

Gelin bu kodları biraz inceleyelim.

Burada ilk gördüğümüz kodlar şunlar:

```python
harfler = 'abcçdefgğhıijklmnoöprsştuüvyz'
çevrim = {i: harfler.index(i) for i in harfler}

```

Esasında siz bu kodların anlamını biliyorsunuz. Önceki derslerimizde de aynı
kodları birkaç kez kullanmıştık. Yalnız biz burada, örnek olması açısından,harflerdeğişkeni için değer olarak yalnızca küçük harfleri kullandık. Bu
kodları daha kapsamlı bir program içinde kullanacaksanız bu değişkenin uygun
yerlerine mesela büyük harfleri ve noktalama işaretleriyle sayıları da eklemek
isteyebilirsiniz.

Sonraki satırlardasırala()adlı bir fonksiyon tanımladık:

```python
def sırala(kelime):
 return ([çevrim.get(kelime[i]) for i in range(len(kelime))])

```

Burada liste üreteçlerinden yararlandığımıza dikkatinizi çekmek isterim:

```python
[çevrim.get(kelime[i]) for i in range(len(kelime))]

```

Bu kod yardımıylakelimeiçinde geçen her bir harfiçevrimadlı sözlükte
sorgulayarak, sözlükte ilgili harfe karşılık gelen sayıyı buluyoruz.

Aslında bu kodları daha iyi anlayabilmek için Python’dakisorted()fonksiyonunun mantığını biraz daha derinlemesine incelememiz gerekiyor. Gelin
şimdi bu inceleme işini yapalım:

Diyelim ki elimizde şöyle bir liste var:

```python
elemanlar = [('ahmet', 33, 'karataş'),
 ('mehmet', 45, 'arpaçbahşiş'),
 ('sevda', 24, 'arsuz'),
 ('arzu', 40, 'siverek'),
 ('abdullah', 30, 'payas'),
 ('ilknur', 40, 'kilis'),
 ('abdurrezzak', 40, 'bolvadin')]

```

Bu liste, her biri ‘isim’, ‘yaş’ ve ‘memleket’ bilgilerini içeren üç öğeli birer
demetten oluşuyor. Eğer biz bu liste üzerinesorted()fonksiyonunu
uygularsak:

```python
print(*sorted(elemanlar), sep='\n')

```

Python elemanları demetlerin ilk öğesine göre sıralayacaktır. Yani isme göre.

Peki ya biz bu elemanları yaşa göre sıralamak istersek ne yapacağız?

Bu amacı gerçekleştirmek için şöyle bir kod yazabiliriz:

```python
def sırala(liste):
 return liste[1]

elemanlar = [('ahmet', 33, 'karataş'),
 ('mehmet', 45, 'arpaçbahşiş'),
 ('sevda', 24, 'arsuz'),
 ('arzu', 40, 'siverek'),
 ('abdullah', 30, 'payas'),
 ('ilknur', 40, 'kilis'),
 ('abdurrezzak', 40, 'bolvadin')]

print(*sorted(elemanlar, key=sırala), sep='\n')

```

Bu örnek bizekeyparametresinin de ne işe yaradığını açık seçik gösteriyor.
Eğer Python’ın kendi sıralama yönteminin dışında bir sıralama yöntemi
uygulayacaksak, bu sıralama yönteminin ne olduğunu bir fonksiyon yardımıyla
tarif edip bunukeyparametresine değer olarak veriyoruz. Örneğin biz
yukarıdaki Python’ınelemanlaradlı listeyi ilk sütuna (‘isim’ sütunu) göre
değil, ikinci sütuna (‘yaş’ sütunu) göre sıralamasını istedik. Bunun için de
şöyle bir fonksiyon yazdık:

```python
def sırala(liste):
 return liste[1]

```

Bu fonksiyon, kendisine parametre olarak verilen nesnenin ikinci öğesini
döndürüyor. İşte bizsorted()fonksiyonununkeyparametresine bu
fonksiyonu verdiğimizde Python sıralama işlemindeelemanlarlistesinin ikinci
öğesini dikkate alacaktır. Eğer Python’ın sıralama işleminde mesela üçüncü
sütunu dikkate almasını istersenizsırala()fonksiyonunu şöyle
yazabilirsiniz:

```python
def sırala(liste):
 return liste[2]

```

Gördüğünüz gibi,elemanlarlistesinin ikinci sütununda değeri aynı olan öğeler
var. Mesela ‘arzu’, ‘ilknur’ ve ‘abdurrezzak’ 40 yaşında. Python bu öğeleri
sıralarken, bunların listede geçtiği sırayı dikkate alacaktır. Ama bazen biz
sıralamanın böyle olmasını istemeyebiliriz. Mesela bizim istediğimiz şey, değeri
aynı olan öğeler için üçüncü sütunun (veya birinci sütunun) dikkate alınması
olabilir. İşte bunun için desırala()fonksiyonunu şu şekilde
tanımlayabiliriz:

```python
def sırala(liste):
 return (liste[1], liste[2])

```

Gördüğünüz gibi buradasırala()fonksiyonu bize iki öğeli bir demet
döndürüyor.

Kodlarımız tam olarak şöyle görünecek:

```python
def sırala(liste):
 return (liste[1], liste[2])

elemanlar = [('ahmet', 33, 'karataş'),
 ('mehmet', 45, 'arpaçbahşiş'),
 ('sevda', 24, 'arsuz'),
 ('arzu', 40, 'siverek'),
 ('abdullah', 30, 'payas'),
 ('ilknur', 40, 'kilis'),
 ('abdurrezzak', 40, 'bolvadin')]

print(*sorted(elemanlar, key=sırala), sep='\n')

```

Kodlarımızı böyle yazdığımızda Python listeyi ilk olarak ikinci sütundaki ‘yaş’
değerlerine göre sıralar. Değeri aynı olan öğelerle karşılaştığında ise üçüncü
sütundaki ‘memleket’ değerlerine bakar ve sıralamayı ona göre yapar.

Bütün bu açıklamalardan sonra yukarıdaki şu kodları daha iyi anlıyor
olmalısınız:

```python
harfler = 'abcçdefgğhıijklmnoöprsştuüvyz'
çevrim = {i: harfler.index(i) for i in harfler}

def sırala(kelime):
 return ([çevrim.get(kelime[i]) for i in range(len(kelime))])

isimler = ['ahmet', 'can', 'iskender', 'cigdem',
 'ismet', 'ismail', 'ismit', 'çiğdem',
 'ismıt', 'ışık', 'şule']

print(*sorted(isimler, key=sırala), sep='\n')

```

Biz yine de her şeyin iyiden iyine anlaşıldığından emin olmak için durumu kısaca
açıklayalım. Öncelikle ilgili fonksiyonu önümüze alalım:

```python
def sırala(kelime):
 return ([çevrim.get(kelime[i]) for i in range(len(kelime))])

```

Burada yaptığımız şey biraz önce yaptığımız şeyle tamamen aynı aslında. Tek
fark, Python’ın sıralamada kullanmasını istediğimiz öğeleri tek tek elle yazmak
yerine, bunları bir liste üreteci yardımıyla otomatik olarak belirlemek.

Eğer yukarıdaki kodları şöyle yazsaydık:

```python
def sırala(kelime):
 return (çevrim.get(kelime[0]))

```

Bu durumda Python sıralamada kelimelerin yalnızca ilk harflerini dikkate
alacaktı. İlk harfi aynı olan kelimeleri ise bu yüzden düzgün sıralayamayacaktı.
Elbette Python’ın önce ilk harfe, sonra ikinci harfe, sonra da üçüncü harfe
bakmasını sağlayabiliriz:

```python
def sırala(kelime):
 return (çevrim.get(kelime[0]), çevrim.get(kelime[1]), çevrim.get(kelime[2]))

```

Ancak bu yöntemin uygulanabilir ve pratik olmadığı ortada. Kendi kendinize bazı
denemeler yaparak bunu kendiniz de rahatlıkla görebilirsiniz.

Python’ın, sıralama yaparken kelimelerin önce ilk harflerini, sonra ikinci,
sonra üçüncü, vb. harflerini karşılaştırmasını sağlamanın en uygun yolu şu
olacaktır:

```python
def sırala(kelime):
 return ([çevrim.get(kelime[i]) for i in range(len(kelime))])

```

Gördüğünüz gibi, burada kelimelerdeki harflerin sırasını tek tek elle yazmak
yerine, bunu birfordöngüsü içinde otomatik olarak yaptırıyoruz.
Dolayısıylasırala()fonksiyonuna verilen parametrenin meselaahmetolduğu
bir durumda yukarıdaki fonksiyon şu demeti döndürüyor:

```python
def sırala('ahmet'):
 return (çevrim.get('ahmet'[0]),
 çevrim.get('ahmet'[1]),
 çevrim.get('ahmet'[2]),
 çevrim.get('ahmet'[3]),
 çevrim.get('ahmet'[4]))

```

Mesela ‘can’ için ise şunu:

```python
def sırala('can'):
 return (çevrim.get('can'[0]),
 çevrim.get('can'[1]),
 çevrim.get('can'[2]))

```

Böylece Python, hangi uzunlukta bir isimle karşılaşırsa karşılaşsın, sıralama
işlemini düzgün bir şekilde gerçekleştirebiliyor.

Bu bölümde Python’da sıralama konusunu epey ayrıntılı bir şekilde ele aldık.

> **Not**
> ‘Sıralama’ konusuna ilişkin bir tartışma içinhttps://web.archive.org/web/20161017211231/www.istihza.com/forum/viewtopic.php?f=25&t=1523adresindeki konuyu
inceleyebilirsiniz.

Not

‘Sıralama’ konusuna ilişkin bir tartışma içinhttps://web.archive.org/web/20161017211231/www.istihza.com/forum/viewtopic.php?f=25&t=1523adresindeki konuyu
inceleyebilirsiniz.

### slice()

Bildiğiniz gibi, birtakım öğelerden oluşan bir nesnenin yalnızca belli
kısımlarını ayırıp alma işlemine ‘dilimleme’ adı veriliyor. Örneğin elimizde
şöyle bir liste olduğunu düşünelim:

```python
>>> l = ['ahmet', 'mehmet', 'ayşe', 'senem', 'salih']

```

5 öğeli bu listenin yalnızca ilk iki öğesini almak, yani dilimlemek için şu
yapıyı kullanıyoruz:

```python
>>> l[0:2]

['ahmet', 'mehmet']

```

Dilimleme işleminin şöyle bir formülden oluştuğunu biliyoruz:

```python
l[başlangıç:bitiş:atlama_değeri]

```

Başlangıç parametresinin öntanımlı değeri0olduğu için yukarıdaki kodu şöyle
de yazabilirdik:

```python
>>> l[:2]

['ahmet', 'mehmet']

```

Aynı listenin, ilk öğeden itibaren sonuna kadar olan bütün öğelerini almak için
ise şunu yazıyoruz:

```python
>>> l[1:]

```

Eğer bu listeyi, öğelerini ikişer ikişer atlayarak dilimlemek istersek de şu
yolu takip ediyoruz:

```python
>>> l[::2]

['ahmet', 'ayşe', 'salih']

```

Bu örnekte başlangıç ve bitiş parametrelerinin öntanımlı değerlerini kullandık.
O yüzden o kısımları boş bıraktık. Öğeleri ikişer ikişer atlayabilmek için ise
atlama_değeri olarak2sayısını kullandık.

İşte yukarıdakine benzer dilimleme işlemleri içinslice()adlı bir gömülü
fonksiyondan da yararlanabiliriz. Dikkatlice bakın:

Listemiz şu:

```python
>>> l = ['ahmet', 'mehmet', 'ayşe', 'senem', 'salih']

```

Bir ‘dilimleme’ (slice) nesnesi oluşturuyoruz:

```python
>>> dl = slice(0, 3)

```

Bu nesneyi liste üzerine uyguluyoruz:

```python
>>> l[dl]

['ahmet', 'mehmet', 'ayşe']

```

Gördüğünüz gibi,slice()fonksiyonunu yukarıda iki parametre ile kullandık.
Tahmin edebileceğiniz gibi, bu fonksiyonunu formülü şu şekildedir:

```python
slice(başlangıç, bitiş, atlama)

```

### sum()

Bu fonksiyonun temel görevi, bir dizi içindeki değerlerin toplamını bulmaktır.
Örneğin:

```python
>>> l = [1, 2, 3]
>>> sum(l)

6

```

Bu fonksiyon genellikle yukarıdaki gibi tek parametreyle kullanılır. Ama aslında
bu fonksiyon ikinci bir parametre daha alır. Dikkatlice bakın:

```python
>>> l = [1, 2, 3]
>>> sum(l, 10)

16

```

Gördüğünüz gibi, Pythonsum()fonksiyonuna verilen ikinci parametreyi,
birinci parametredeki toplam değerin üzerine ekliyor.

### type()

type()fonksiyonunun görevi bir nesnenin hangi veri tipine ait olduğunu
söylemektir. Bu fonksiyonu artık yakından tanıyorsunuz:

```python
>>> type('elma')

<class 'str'>

```

### zip()

Gelin isterseniz bu fonksiyonu bir örnek üzerinden açıklamaya çalışalım.

Diyelim ki elimizde şöyle iki farklı liste var:

```python
>>> a1 = ['a', 'b', 'c']
>>> a2 = ['d', 'e', 'f']

```

Eğer bu listelerin öğelerini birbirleriyle eşleştirmek istersekzip()fonksiyonundan yararlanabiliriz.

Dikkatlice bakın:

```python
>>> zip(a1, a2)

<zip object at 0x00FD0BE8>

```

Gördüğünüz gibi, yukarıdaki kod bize bir ‘zip’ nesnesi veriyor. Bu nesnenin
öğelerine nasıl ulaşabileceğinizi biliyorsunuz:

```python
>>> print(*zip(a1, a2))

('a', 'd') ('b', 'e') ('c', 'f')

>>> list(zip(a1, a2))

[('a', 'd'), ('b', 'e'), ('c', 'f')]

>>> for a, b in zip(a1, a2):
... print(a, b)
...
a d
b e
c f

```

Yukarıdaki çıktıları incelediğimizde, ilk listenin ilk öğesinin, ikinci listenin
ilk öğesiyle; ilk listenin ikinci öğesinin, ikinci listenin ikinci öğesiyle; ilk
listenin üçüncü öğesinin ise, ikinci listenin üçüncü öğesiyle eşleştiğini
görüyoruz.

Bu özellikten pek çok farklı şekilde yararlanabilirsiniz. Örneğin:

```python
>>> isimler = ['ahmet', 'mehmet', 'zeynep', 'ilker']
>>> yaşlar = [25, 40, 35, 20]
>>> for i, y in zip(isimler, yaşlar):
... print('isim: {} / yaş: {}'.format(i, y))
...
isim: ahmet / yaş: 25
isim: mehmet / yaş: 40
isim: zeynep / yaş: 35
isim: ilker / yaş: 20

```

Buradaisimlerveyaşlaradlı listelerin öğelerinizip()fonksiyonu
yardımıyla birbirleriyle eşleştirdik.

### vars()

Bu fonksiyon, mevcut isim alanı içindeki metot, fonksiyon ve nitelikleri
listeler. Eğer bu fonksiyonu parametresiz olarak kullanırsak, daha önce
gördüğümüzlocals()fonksiyonuyla aynı çıktıyı elde ederiz:

```python
>>> vars()

{'__builtins__': <module 'builtins' (built-in)>, '__name__': '__main__',
 '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>,
 '__doc__': None}

```

Bu fonksiyonu, nesnelerin metotlarını ve niteliklerini öğrenmek için de
kullanabilirsiniz:

```python
>>> vars(str)
>>> vars(list)
>>> vars(dict)

```

Yukarıda sırasıyla karakter dizilerinin, listelerin ve sözlüklerin metotlarını
listeledik. Bu yönüylevars()fonksiyonudir()fonksiyonuna benzer.

Böylece Python’daki gömülü fonksiyonları tek tek incelemiş olduk. Bu bölümde
incelemediğimiz gömülü fonksiyonlar şunlar:
1. memoryview
1. iter
1. next
1. object
1. property
1. staticmethod
1. super
1. getattr
1. hasattr
1. delattr
1. classmethod
1. issubclass
1. setattr
1. __import__

memoryview

iter

next

object

property

staticmethod

super

getattr

hasattr

delattr

classmethod

issubclass

setattr

__import__

Bu fonksiyonları, ilerleyen derslerle birlikte Python bilgimiz biraz daha
arttığında ele alacağız.

## İleri Düzey Fonksiyonlar

Buraya gelinceye kadar fonksiyonlara ilişkin epey söz söyledik. Artık Python
programlama dilinde fonksiyonlara dair hemen her şeyi bildiğimizi rahatlıkla
söyleyebiliriz. Zira bu noktaya kadar hem fonksiyonların temel (ve orta düzey)
özelliklerini öğrendik, hem de ‘gömülü fonksiyon’ kavramını ve gömülü
fonksiyonların kendisini bütün ayrıntılarıyla inceledik. Dolayısıyla yazdığımız
kodlarda fonksiyonları oldukça verimli bir şekilde kullanabilecek kadar
fonksiyon bilgisine sahibiz artık.

Dediğimiz gibi, fonksiyonlara ilişkin en temel bilgileri edindik. Ancak
fonksiyonlara dair henüz bilmediğimiz şeyler de var. Ama artık Python
programlama dilinde geldiğimiz aşamayı dikkate alarak ileriye doğru bir adım
daha atabilir, fonksiyonlara dair ileri düzey sayılabilecek konulardan da söz
edebiliriz.

İlk olarak ‘lambda fonksiyonlarını’ ele alalım.

### Lambda Fonksiyonları

Şimdiye kadar Python programlama dilinde fonksiyon tanımlamak için hepdefadlı bir ifadeden yararlanmıştık. Bu bölümde ise Python programlama dilinde
fonksiyon tanımlamamızı sağlayacak, tıpkıdefgibi bir ifadeden daha söz
edeceğiz. Fonksiyon tanımlamamızı sağlayan bu yeni ifadeyelambdadenir. Bu
ifade ile oluşturulan fonksiyonlara ise ‘lambda fonksiyonları’…

Bildiğiniz gibi Python’da bir fonksiyonudefifadesi yardımıyla şöyle
tanımlıyoruz:

```python
>>> def fonk(param1, param2):
... return param1 + param2

```

Bu fonksiyon, kendisine verilen parametreleri birbiriyle toplayıp bize bunların
toplamını döndürüyor:

```python
>>> fonk(2, 4)

6

```

Peki aynı işlemi lambda fonksiyonları yardımıyla yapmak istersek nasıl bir yol
izleyeceğiz?

Dikkatlice bakın:

```python
>>> fonk = lambda param1, param2: param1 + param2

```

İşte burada tanımladığımız şey bir lambda fonksiyonudur. Bu lambda fonksiyonunu
da tıpkı biraz önce tanımladığımız def fonksiyonu gibi kullanabiliriz:

```python
>>> fonk(2, 4)

6

```

Gördüğünüz gibi lambda fonksiyonlarını tanımlamak ve kullanmak hiç de zor değil.

Lambda fonksiyonlarının neye benzediğinden temel olarak bahsettiğimize göre
artık biraz daha derine inebiliriz.

Lambda fonksiyonları Python programlama dilinin ileri düzey fonksiyonlarından
biridir. Yukarıdaki örnek yardımıyla bu lambda fonksiyonlarının nasıl bir şey
olduğunu gördük. Esasında biz buraya gelene kadar bu lambda fonksiyonlarını hiç
görmemiş de değiliz. Hatırlarsanız daha önceki derslerimizde şöyle bir örnek kod
yazmıştık:

```python
harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
çevrim = {i: harfler.index(i) for i in harfler}

isimler = ["ahmet", "ışık", "ismail", "çiğdem",
 "can", "şule", "iskender"]

print(sorted(isimler, key=lambda x: çevrim.get(x[0])))

```

Buradasorted()fonksiyonununkeyparametresi içinde kullandığımız ifade
bir lambda fonksiyonudur:

```python
lambda x: çevrim.get(x[0])

```

Peki lambda fonksiyonları nedir ve ne işe yarar?

Lambda fonksiyonlarını, bir fonksiyonun işlevselliğine ihtiyaç duyduğumuz, ama
konum olarak bir fonksiyon tanımlayamayacağımız veya fonksiyon tanımlamanın zor
ya da meşakkatli olduğu durumlarda kullanabiliriz. Yukarıdaki örnek kod, bu
tanıma iyi bir örnektir:sorted()fonksiyonununkeyparametresi bizden bir
fonksiyon tanımı bekler. Ancak biz elbette orayadefifadesini kullanarak
doğrudan bir fonksiyon tanımlayamayız. Amadefyerinelambdaifadesi
yardımıylakeyparametresi için bir lambda fonksiyonu tanımlayabiliriz.

Eğer yukarıdaki kodları ‘normal’ bir fonksiyonla yazmak isteseydik şu kodları
kullanabilirdik:

```python
harfler = "abcçdefgğhıijklmnoöprsştuüvyz"
çevrim = {i: harfler.index(i) for i in harfler}

isimler = ["ahmet", "ışık", "ismail", "çiğdem",
 "can", "şule", "iskender"]

def sırala(eleman):
 return çevrim.get(eleman[0])

print(sorted(isimler, key=sırala))

```

Burada lambda fonksiyonu kullanmak yerine,sırala()adlı bir fonksiyon
kullandık.

Eğer yukarıda ‘lambda’ ile yazdığımız örneğisırala()fonksiyonu ile
yazdığımız örnekle kıyaslarsanız lambda fonksiyonlarında hangi parçanın neye
karşılık geldiğini veya ne anlama sahip olduğunu rahatlıkla anlayabilirsiniz.

Gelin bir örnek daha verelim:

Diyelim ki bir sayının çift sayı olup olmadığını denetleyen bir fonksiyon yazmak
istiyorsunuz. Bunun için şöyle bir fonksiyon tanımlayabileceğimizi
biliyorsunuz:

```python
def çift_mi(sayı):
 return sayı % 2 == 0

```

Eğerçift_mi()fonksiyonuna parametre olarak verilen bir sayı çift ise
fonksiyonumuzTrueçıktısı verecektir:

```python
print(çift_mi(100))

True

```

Aksi haldeFalseçıktısı alırız:

```python
print(çift_mi(99))

False

```

İşte yukarıdaki etkiyi lambda fonksiyonları yardımıyla da elde edebiliriz.

Dikkatlice bakın:

```python
>>> çift_mi = lambda sayı: sayı % 2 == 0
>>> çift_mi(100)

True

>>> çift_mi(99)

False

```

Başka bir örnek daha verelim. Diyelim ki bir liste içindeki bütün sayıların
karesini hesaplamak istiyoruz. Elimizdeki liste şu:

```python
>>> l = [2, 5, 10, 23, 3, 6]

```

Bu listedeki sayıların her birinin karesini hesaplamak için şöyle bir şey
yazabiliriz:

```python
>>> for i in l:
... print(i**2)

4
25
100
529
9
36

```

Veya şöyle bir şey:

```python
>>> [i**2 for i in l]

[4, 25, 100, 529, 9, 36]

```

Ya damap()fonksiyonuyla birlikte lambda’yı kullanarak şu kodu
yazabiliriz:

```python
>>> print(*map(lambda sayı: sayı ** 2, l))

4 25 100 529 9 36

```

Son örnekte verdiğimiz lambda’lı kodu normal bir fonksiyon tanımlayarak şöyle
de yazabilirdik:

```python
>>> def karesi(sayı):
... return sayı ** 2
...
>>> print(*map(karesi, l))

4 25 100 529 9 36

```

Sözün özü, mesela şu kod:

```python
lambda x: x + 10

```

Türkçede şu anlama gelir:

```python
'x' adlı bir parametre alan bir lambda fonksiyonu tanımla. Bu fonksiyon, bu
'x parametresine 10 sayısını eklesin.

```

Biz yukarıdaki örneklerde lambda fonksiyonunu tek bir parametre ile tanımladık.
Ama elbette lambda fonksiyonlarının birden fazla parametre de alabileceğini de
biliyorsunuz.

Örneğin:

```python
>>> birleştir = lambda ifade, birleştirici: birleştirici.join(ifade.split())

```

Burada lambda fonksiyonumuz toplam iki farklı parametre alıyor: Bunlardan ilkiifade, ikincisi isebirleştirici. Fonksiyonumuzun gövdesindeifadeparametresinesplit()metodunu uyguladıktan sonra, elde ettiğimiz parçalarıbirleştiriciparametresinin değerini kullanarak birbirleriyle birleştiriyoruz.
Yani:

```python
>>> birleştir('istanbul büyükşehir belediyesi', '-')

'istanbul-büyükşehir-belediyesi'

```

Eğer aynı işlevi ‘normal’ bir fonksiyon yardımıyla elde etmek isteseydik şöyle
bir şey yazabilirdik:

```python
>>> def birleştir(ifade, birleştirici):
... return birleştirici.join(ifade.split())
...
>>> birleştir('istanbul büyükşehir belediyesi', '-')

'istanbul-büyükşehir-belediyesi'

```

Yukarıdaki örneklerin dışında, lambda fonksiyonları özellikle grafik arayüz
çalışmaları yaparken işinize yarayabilir. Örneğin:

```python
import tkinter
import tkinter.ttk as ttk

pen = tkinter.Tk()

btn = ttk.Button(text='merhaba', command=lambda: print('merhaba'))
btn.pack(padx=20, pady=20)

pen.mainloop()

```

> **Not**
> Bu kodlardan hiçbir şey anlamamış olabilirsiniz. Endişe etmeyin.
Burada amacımız size sadece lambda fonksiyonlarının kullanımını göstermek. Bu
kodlarda yalnızca lambda fonksiyonuna odaklanmanız şimdilik yeterli olacaktır.
Eğer bu kodları çalıştıramadıysanızhttps://forum.yazbel.com/adresinde
sorununuzu dile getirebilirsiniz.

Not

Bu kodlardan hiçbir şey anlamamış olabilirsiniz. Endişe etmeyin.
Burada amacımız size sadece lambda fonksiyonlarının kullanımını göstermek. Bu
kodlarda yalnızca lambda fonksiyonuna odaklanmanız şimdilik yeterli olacaktır.
Eğer bu kodları çalıştıramadıysanızhttps://forum.yazbel.com/adresinde
sorununuzu dile getirebilirsiniz.

Bu kodları çalıştırıp ‘merhaba’ düğmesine bastığınızda komut satırında ‘merhaba’
çıktısı görünecektir. Tkinter’de fonksiyonlarıncommandparametresi bizden
parametresiz bir fonksiyon girmemizi bekler. Ancak bazen, elde etmek istediğimiz
işlevsellik için oraya parametreli bir fonksiyon yazmak durumunda kalabiliriz.
İşte bunun gibi durumlarda lambda fonksiyonları faydalı olabilir. Elbette
yukarıdaki kodları şöyle de yazabilirdik:

```python
import tkinter
import tkinter.ttk as ttk

pen = tkinter.Tk()

def merhaba():
 print('merhaba')

btn = ttk.Button(text='merhaba', command=merhaba)
btn.pack(padx=20, pady=20)

pen.mainloop()

```

Burada da lambda yerine isimli bir fonksiyon tanımlayıp,commandparametresine
doğrudan bu fonksiyonu verdik.

Bütün bu örneklerden gördüğünüz gibi, lambda fonksiyonları son derece pratik
araçlardır. Normal, isimli fonksiyonlarla elde ettiğimiz işlevselliği, lambda
fonksiyonları yardımıyla çok daha kısa bir şekilde elde edebiliriz. Ancak lambda
fonksiyonları normal fonksiyonlara göre biraz daha okunaksız yapılardır. O
yüzden, eğer lambda fonksiyonlarını kullanmaya mecbur değilseniz, bunların
yerine normal fonksiyonları veya yerine göre liste üreteçlerini tercih
edebilirsiniz.

### Özyinelemeli (Recursive) Fonksiyonlar

Bu bölümde, lambda fonksiyonlarının ardından, yine Python’ın ileri düzey
konularından biri olan ‘özyinelemeli fonksiyonlar’dan söz edeceğiz. İngilizcederecursive functionsolarak adlandırılan özyinelemeli fonksiyonların, Python
programlama dilinin anlaması en zor konularından biri olduğu söylenir. Ama bu
söylenti sizi hiç endişelendirmesin. Zira biz burada bu çapraşık görünen konuyu
size olabildiğince basit ve anlaşılır bir şekilde sunmak için elimizden gelen
bütün çabayı göstereceğiz.

O halde hemen başlayalım…

Şimdiye kadar Python’da pek çok fonksiyon gördük. Bu fonksiyonlar kimi zaman
Python programcılarınca tanımlanıp dile entegre edilmiş ‘gömülü fonksiyonlar’
(builtin functions) olarak, kimi zamansa o anda içinde bulunduğumuz duruma ve
ihtiyaçlarımıza göre bizzat kendimizin tanımladığı ‘el yapımı fonksiyonlar’
(custom functions) olarak çıktı karşımıza.

Şimdiye kadar öğrendiğimiz bütün bu fonksiyonların ortak bir noktası vardı. Bu
ortak nokta, şu ana kadar fonksiyonları kullanarak yaptığımız örneklerden de
gördüğünüz gibi, bu fonksiyonlar yardımıyla başka fonksiyonları çağırabiliyor
olmamız. Örneğin:

```python
def selamla(kim):
 print('merhaba', kim)

```

Buradaselamla()adlı bir fonksiyon tanımladık. Gördüğünüz gibi bu fonksiyonprint()adlı başka bir fonksiyonu çağırıyor. Burada sıradışı bir şey yok.
Dediğimiz gibi, şimdiye kadar zaten hep böyle fonksiyonlar görmüştük.

Python fonksiyonları, yukarıdaki örnekte de gördüğünüz gibi, nasıl başka
fonksiyonları çağırabiliyorsa, aynı şekilde, istenirse, kendi kendilerini de
çağırabilirler. İşte bu tür fonksiyonlara Python programlama dilinde ‘kendi
kendilerini yineleyen’, veya daha teknik bir dille ifade etmek gerekirse
‘özyinelemeli’ (recursive) fonksiyonlar adı verilir.

Çok basit bir örnek verelim. Diyelim ki, kendisine parametre olarak verilen bir
karakter dizisi içindeki karakterleri teker teker azaltarak ekrana basan bir
fonksiyon yazmak istiyorsunuz. Yani mesela elinizde ‘istihza’ adlı bir karakter
dizisi var. Sizin amacınız bu karakter dizisini şu şekilde basan bir fonksiyon
yazmak:

```python
istihza
stihza
tihza
ihza
hza
za
a

```

Elbette bu işi yapacak bir fonksiyonu, daha önce öğrendiğiniz döngüler ve başka
yapılar yardımıyla rahatlıkla yazabilirsiniz. Ama isterseniz aynı işi
özyinelemeli fonksiyonlar yardımıyla da yapabilirsiniz.

Şimdi şu kodlara dikkatlice bakın:

```python
def azalt(s):
 if len(s) == 0:
 return s
 else:
 print(s)
 return azalt(s[1:])

print(azalt('istihza'))

```

Bu kodlar bize yukarıda bahsettiğimiz çıktıyı verecek:

```python
istihza
stihza
tihza
ihza
hza
za
a

```

Fonksiyonumuzu yazıp çalıştırdığımıza ve bu fonksiyonun bize nasıl bir çıktı
verdiğini gördüğümüze göre fonksiyonu açıklamaya geçebiliriz.

Bu fonksiyon ilk bakışta daha önce öğrendiğimiz fonksiyonlardan çok da farklı
görünmüyor aslında. Ama eğer fonksiyonun son kısmına bakacak olursanız, bu
fonksiyonu daha önce öğrendiğimiz fonksiyonlardan ayıran şu satırı görürsünüz:

```python
return azalt(s[1:])

```

Gördüğünüz gibi, buradaazalt()fonksiyonu içinde yineazalt()fonksiyonunu çağırıyoruz. Böylece fonksiyonumuz sürekli olarak kendi kendini
yineliyor. Yani aynı fonksiyonu tekrar tekrar uyguluyor.

Peki ama bunu nasıl yapıyor?

Nasıl bir durumla karşı karşıya olduğumuzu daha iyi anlamak için yukarıdaki
kodları şu şekilde yazalım:

```python
def azalt(s):
 if len(s) < 1:
 return s
 else:
 print(list(s))
 return azalt(s[1:])

```

Burada fonksiyonun her yinelenişinde, özyinelemeli fonksiyona parametre olarak
giden karakter dizisinin nasıl değiştiğini birazcık daha net olarak görebilmek
için karakter dizisi içindeki karakterleri bir liste haline getirip ekrana
basıyoruz:

```python
print(list(s))

```

Bu kodları çalıştırdığımızda şu çıktıyı alacağız:

```python
['i', 's', 't', 'i', 'h', 'z', 'a']
['s', 't', 'i', 'h', 'z', 'a']
['t', 'i', 'h', 'z', 'a']
['i', 'h', 'z', 'a']
['h', 'z', 'a']
['z', 'a']
['a']

```

Yukarıdaki çıktının ilk satırında gördüğünüz gibi, fonksiyon ilk çağrıldığında
listede ‘istihza’ karakter dizisini oluşturan bütün harfler var. Yani
fonksiyonumuz ilk çalışmada parametre olarak karakter dizisinin tamamını alıyor.
Ancak fonksiyonun her yinelenişinde listedeki harfler birer birer düşüyor.
Böylece özyinelemeli fonksiyonumuz parametre olarak karakter dizisinin her
defasında bir eksiltilmiş biçimini alıyor.

Yukarıdaki sözünü ettiğimiz düşmenin yönü karakter dizisinin başından sonuna
doğru. Yani her defasında, elde kalan karakter dizisinin ilk harfi düşüyor.
Düşme yönünün böyle olması bizim kodları yazış şeklimizden kaynaklanıyor. Eğer
bu kodları şöyle yazsaydık:

```python
def azalt(s):
 if len(s) < 1:
 return s
 else:
 print(list(s))
 return azalt(s[:-1])

```

Harflerin düşme yönü sondan başa doğru olacaktı:

```python
['i', 's', 't', 'i', 'h', 'z', 'a']
['i', 's', 't', 'i', 'h', 'z']
['i', 's', 't', 'i', 'h']
['i', 's', 't', 'i']
['i', 's', 't']
['i', 's']
['i']

```

Burada, bir önceki koddakiazalt(s[1:])satırınıazalt(s[:-1])şeklinde
değiştirdiğimize dikkat edin.

Fonksiyonun nasıl işlediğini daha iyi anlamak için, ‘istihza’ karakter dizisinin
son harfinin her yineleniş esnasındaki konumunun nasıl değiştiğini de
izleyebilirsiniz:

```python
n = 0

def azalt(s):
 global n
 mesaj = '{} harfinin {}. çalışmadaki konumu: {}'
 if len(s) < 1:
 return s
 else:
 n += 1
 print(mesaj.format('a', n, s.index('a')))
 return azalt(s[1:])

azalt('istihza')

```

Bu kodlar şu çıktıyı verir:

```python
a harfinin 1. çalışmadaki konumu: 6
a harfinin 2. çalışmadaki konumu: 5
a harfinin 3. çalışmadaki konumu: 4
a harfinin 4. çalışmadaki konumu: 3
a harfinin 5. çalışmadaki konumu: 2
a harfinin 6. çalışmadaki konumu: 1
a harfinin 7. çalışmadaki konumu: 0

```

Gördüğünüz gibi ‘istihza’ kelimesinin en sonunda bulunan ‘a’ harfi her defasında
baş tarafa doğru ilerliyor.

Aynı şekilde, kodları daha iyi anlayabilmek için, fonksiyona parametre olarak
verdiğimiz ‘istihza’ kelimesinin her yinelemede ne kadar uzunluğa sahip olduğunu
da takip edebilirsiniz:

```python
def azalt(s):
 if len(s) < 1:
 return s
 else:
 print(len(s))
 return azalt(s[:-1])

```

Bu fonksiyonu ‘istihza’ karakter dizisine uyguladığımızda bize şu çıktıyı
veriyor:

```python
7
6
5
4
3
2
1

```

Gördüğünüz gibi, fonksiyonun kendini her yineleyişinde karakter dizimiz
küçülüyor.

Bu durum bize özyinelemeli fonksiyonlar hakkında çok önemli bir bilgi veriyor
esasında:

Özyinelemeli fonksiyonlar; büyük bir problemin çözülebilmesi için, o problemin,
problemin bütününü temsil eden daha küçük bir parçası üzerinde işlem
yapabilmemizi sağlayan fonksiyonlardır.

Yukarıdaki örnekte de bu ilkeyi uyguluyoruz. Yani biz ‘istihza’ karakter
dizisinin öncelikle yalnızca ilk karakterini düşürüyoruz:

```python
s[1:]

```

Daha sonra da bu yöntemi özyinelemeli bir şekilde uyguladığımızda, ‘istihza’
karakter dizisinin her defasında daha küçük bir parçası bu yöntemden
etkileniyor:

```python
azalt(s[1:])

```

Yani fonksiyonumuz ilk olarak ‘istihza’ karakter dizisinin ilk harfi olan ‘i’
harfini düşürüyor. Sonra ‘stihza’ kelimesinin ilk harfi olan ‘s’ harfini
düşürüyor. Ardından ‘tihza’ kelimesinin ilk harfi olan ‘t’ harfini düşürüyor ve
kelime tükenene kadar bu işlemi devam ettiriyor.

Peki ama bunu nasıl yapıyor?

Şimdi yukarıdaki fonksiyondaki şu kısma dikkatlice bakın:

```python
if len(s) < 1:
 return s

```

İşte burada özyinelemeli fonksiyonumuzun, karakter dizisi üzerinde ne kadar
derine inmesi gerektiğini belirliyoruz. Buna göre, karakter dizisinin uzunluğu
1’in altına düştüğünde eldeki karakter dizisini döndürüyoruz. Yani karakter
dizisinin uzunluğu 1’in altına düştüğünde elde kalan karakter dizisi boş bir
karakter dizisi olduğu için o boş karakter dizisini döndürüyoruz. Eğer istersek
elbette bu durumda başka bir şey de döndürebiliriz:

```python
def azalt(s):
 if len(s) < 1:
 return 'bitti!'
 else:
 print(s)
 return azalt(s[1:])

```

İşteiflen(s)<1:bloğunun bulunduğu bu kodlara ‘dip nokta’ adı veriyoruz.
Fonksiyonumuzun yinelene yinelene (veya başka bir ifadeyle ‘dibe ine ine’)
geleceği en son nokta burasıdır. Eğer bu dip noktayı belirtmezsek fonksiyonumuz,
tıpkı dipsiz bir kuyuya düşmüş gibi, sürekli daha derine inmeye çalışacak,
sonunda da hata verecektir. Ne demek istediğimizi daha iyi anlamak için
kodlarımızı şöyle yazalım:

```python
def azalt(s):
 print(s)
 return azalt(s[1:])

```

Gördüğünüz gibi burada herhangi bir dip nokta belirtmedik. Bu kodları
çalıştırdığımızda Python bize şöyle bir hata mesajı verecek:

```python
RuntimeError: maximum recursion depth exceeded

```

Yani:

```python
ÇalışmaZamanıHatası: Azami özyineleme derinliği aşıldı

```

Dediğimiz gibi, özyinelemeli fonksiyonlar her yinelenişte sorunun (yani üzerinde
işlem yapılan parametrenin) biraz daha derinine iner. Ancak bu derine inmenin de
bir sınırı vardır. Bu sınırın ne olduğunu şu kodlar yardımıyla
öğrenebilirsiniz:

```python
>>> import sys
>>> sys.getrecursionlimit()

```

İşte biz özyinelemeli fonksiyonlarımızda dip noktayı mutlaka belirterek,
Python’ın fonksiyonu yinelerken ne kadar derine inip nerede duracağını
belirlemiş oluyoruz.

Şimdi son kez, yukarıdaki örnek fonksiyonu, özyineleme mantığını çok daha iyi
anlamanızı sağlayacak bir şekilde yeniden yazacağız. Dikkatlice bakın:

```python
def azalt(s):
 if len(s) < 1:
 return s
 else:
 print('özyineleme sürecine girerken:', s)
 azalt(s[1:])
 print('özyineleme sürecinden çıkarken:', s)

azalt('istihza')

```

Burada, fonksiyon kendini yinelemeye başlamadan hemen önce birprint()satırı yerleştirereksdeğişkeninin durumunu takip ediyoruz:

```python
print('özyineleme sürecine girerken:', s)

```

Aynı işlemi bir de fonksiyonun kendini yinelemeye başlamasının hemen ardından
yapıyoruz:

```python
print('özyineleme sürecinden çıkarken:', s)

```

Yukarıdaki kodlar bize şu çıktıyı verecek:

```python
özyineleme sürecine girerken: istihza
özyineleme sürecine girerken: stihza
özyineleme sürecine girerken: tihza
özyineleme sürecine girerken: ihza
özyineleme sürecine girerken: hza
özyineleme sürecine girerken: za
özyineleme sürecine girerken: a
özyineleme sürecinden çıkarken: a
özyineleme sürecinden çıkarken: za
özyineleme sürecinden çıkarken: hza
özyineleme sürecinden çıkarken: ihza
özyineleme sürecinden çıkarken: tihza
özyineleme sürecinden çıkarken: stihza
özyineleme sürecinden çıkarken: istihza

```

Gördüğünüz gibi fonksiyon özyineleme sürecine girerken düşürdüğü her bir
karakteri, özyineleme sürecinden çıkarken yeniden döndürüyor. Bu, özyinelemeli
fonksiyonların önemli bir özelliğidir. Mesela bu özellikten yararlanarak şöyle
bir kod yazabilirsiniz:

```python
def ters_çevir(s):
 if len(s) < 1:
 return s
 else:
 ters_çevir(s[1:])
 print(s[0])

ters_çevir('istihza')

```

Yazdığımız bu koddaters_çevir()fonksiyonu, kendisine verilen parametreyi
ters çevirecektir. Yani yukarıdaki kod bize şu çıktıyı verir:

```python
a
z
h
i
t
s
i

```

Burada yaptığımız şey çok basit: Yukarıda da söylediğimiz gibi, özyinelemeli
fonksiyonlar, özyineleme sürecine girerken yaptığı işi, özyineleme sürecinden
çıkarken tersine çevirir. İşte biz de bu özellikten yararlandık. Fonksiyonun
kendini yinelediği noktanın çıkışına birprint()fonksiyonu yerleştirip,
geri dönen karakterlerin ilk harfini ekrana bastık. Böylecesadlı
parametrenin tersini elde etmiş olduk.

Ancak eğer yukarıdaki kodları bu şekilde yazarsak, fonksiyondan dönen değeri her
yerde kullanamayız. Mesela yukarıdaki fonksiyonu aşağıdaki gibi kullanamayız:

```python
def ters_çevir(s):
 if len(s) < 1:
 return s
 else:
 ters_çevir(s[1:])
 print(s[0])

kelime = input('kelime girin: ')
print('Girdiğiniz kelimenin tersi: {}'.format(ters_çevir(kelime)))

```

Fonksiyonumuzun daha kullanışlı olabilmesi için kodlarımızı şöyle yazabiliriz:

```python
def ters_çevir(s):
 if len(s) < 1:
 return s
 else:
 return ters_çevir(s[1:]) + s[0]

kelime = input('kelime girin: ')
print('Girdiğiniz kelimenin tersi: {}'.format(ters_çevir(kelime)))

```

Burada bizim amacımızı gerçekleştirmemizi sağlayan satır şu:

```python
return ters_çevir(s[1:]) + s[0]

```

İlk bakışta bu satırın nasıl çalıştığını anlamak zor gelebilir. Ama aslında son
derece basit bir mantığı var bu kodların. Şöyle düşünün:ters_çevir()fonksiyonunu özyinelemeli olarak işlettiğimizde, yani şu kodu yazdığımızda:

```python
return ters_çevir(s[1:])

```

…döndürülecek son değer boş bir karakter dizisidir. İşte biz özyinelemeden
çıkılırken geri dönen karakterlerin ilk harflerini bu boş karakter dizisine
ekliyoruz ve böylece girdiğimiz karakter dizisinin ters halini elde etmiş
oluyoruz.

Yukarıdaki işlevin aynısını, özyinelemeli fonksiyonunuzu şöyle yazarak da elde
edebilirdiniz:

```python
def ters_çevir(s):
 if not s:
 return s
 else:
 return s[-1] + ters_çevir(s[:-1])

print(ters_çevir('istihza'))

```

Burada aynı iş için farklı bir yaklaşım benimsedik. İlk olarak, dip noktasını şu
şekilde belirledik:

```python
if not s:
 return s

```

Bildiğiniz gibi, boş veri tiplerinin bool değeriFalse’tur. Dolayısıyla
özyineleme sırasındasparametresinin uzunluğunun 1’in altına düşmesi,sparametresinin içinin boşaldığını gösterir. Yani o andasparametresinin bool
değeriFalseolur. Biz de yukarıda bu durumdan faydalandık.

Bir önceki kodlara göre bir başka farklılık da şu satırda:

```python
return s[-1] + ters_çevir(s[:-1])

```

Burada benimsediğimiz yaklaşımın özü şu: Bildiğiniz gibi bir karakter dizisini
ters çevirmek istediğimizde öncelikle bu karakter dizisinin en son karakterini
alıp en başa yerleştiririz. Yani mesela elimizdeki karakter dizisi ‘istihza’
ise, bu karakter dizisini ters çevirmenin ilk adımı bunun en son karakteri olan
‘a’ harfini alıp en başa koymaktır. Daha sonra da geri kalan harfleri tek tek
tersten buna ekleriz:

```python
düz: istihza
ters: a + z + h + i + t + s + i

```

İşte yukarıdaki fonksiyonda da yaptığımız şey tam anlamıyla budur.

Önce karakter dizisinin son harfini en başa koyuyoruz:

```python
return s[-1]

```

Ardından da buna geri kalan harfleri tek tek tersten ekliyoruz:

```python
return s[-1] + ters_çevir(s[:-1])

```

Özyinelemeli fonksiyonlara ilişkin olarak yukarıda tek bir örnek üzerinde epey
açıklama yaptık. Bu örnek ve açıklamalar, özyinelemeli fonksiyonların nasıl
çalıştığı konusunda size epey fikir vermiş olmalı. Ancak elbette bu
fonksiyonları tek bir örnek yardımıyla tamamen anlayamamış olabilirsiniz. O
yüzden gelin isterseniz bir örnek daha verelim. Mesela bu kez de basit bir sayaç
yapalım:

```python
def sayaç(sayı, sınır):
 print(sayı)
 if sayı == sınır:
 return 'bitti!'
 else:
 return sayaç(sayı+1, sınır)

```

> **Not**
> Bu fonksiyonun yaptığı işi elbette başka şekillerde çok daha kolay bir
şekilde halledebilirdik. Bu örneği burada vermemizin amacı yalnızca özyinelemeli
fonksiyonların nasıl işlediğini göstermek. Yoksa böyle bir işi özyinelemeli
fonksiyonlarla yapmanızı beklemiyoruz.

Not

Bu fonksiyonun yaptığı işi elbette başka şekillerde çok daha kolay bir
şekilde halledebilirdik. Bu örneği burada vermemizin amacı yalnızca özyinelemeli
fonksiyonların nasıl işlediğini göstermek. Yoksa böyle bir işi özyinelemeli
fonksiyonlarla yapmanızı beklemiyoruz.

Yukarıdaki fonksiyona dikkatlice bakarsanız aslında yaptığı işi çok basit bir
şekilde gerçekleştirdiğini göreceksiniz.

Burada önceliklesayaç()adlı bir fonksiyon tanımladık. Bu fonksiyon toplam
iki farklı parametre alıyor:sayıvesınır.

Buna göre fonksiyonumuzu şöyle kullanıyoruz:

```python
print(sayaç(0, 100))

```

Buradasayıparametresine verdiğimiz0değeri sayacımızın saymaya kaçtan
başlayacağını gösteriyor.sınırparametresine verdiğimiz100değeri ise kaça
kadar sayılacağını gösteriyor. Buna göre biz0’dan100’e kadar olan sayıları
sayıyoruz…

Gelin şimdi biraz fonksiyonumuzu inceleyelim.

İlk olarak şu satırı görüyoruz fonksiyon gövdesinde:

```python
print(sayı)

```

Bu satır, özyinelemeli fonksiyonun her yinelenişindesayıparametresinin
durumunu ekrana basacak.

Sonraki iki satırda ise şu kodları görüyoruz:

```python
if sayı == sınır:
 return 'bitti!'

```

Bu bizim ‘dip nokta’ adını verdiğimiz şey. Fonksiyonumuz yalnızca bu noktaya
kadar yineleyecek, bu noktanın ilerisine geçmeyecektir. Yanisayıparametresinin değerisınırparametresinin değerine ulaştığında özyineleme
işlemi de sona erecek. Eğer böyle bir dip nokta belirtmezsek fonksiyonumuz
sonsuza kadar kendini yinelemeye çalışacak, daha önce sözünü ettiğimiz
‘özyineleme limiti’ nedeniyle de belli bir aşamadan sonra hata verip çökecektir.

Sonraki satırlarda ise şu kodları görüyoruz:

```python
else:
 return sayaç(sayı+1, sınır)

```

Bu satırlar, bir önceki aşamada belirttiğimiz dip noktaya ulaşılana kadar
fonksiyonumuzun hangi işlemleri yapacağını gösteriyor. Buna göre, fonksiyonun
her yinelenişindesayıparametresinin değerini 1 sayı artırıyoruz.

Fonksiyonumuzusayaç(0,100)gibi bir komutla çalıştırdığımızı düşünürsek,
fonksiyonun ilk çalışmasında0olan sayı değeri sonraki yinelemede1,
sonraki yinelemede2, sonraki yinelemede ise3olacak ve bu durumsınırdeğer olan100’e varılana kadar devam edecektir.sayıparametresinin değeri100olduğunda ise dip nokta olarak verdiğimiz ölçüt devreye girecek ve
fonksiyonun kendi kendisini yinelemesi işlemine son verilecektir.

Biz yukarıdaki örnekte yukarıya doğru sayan bir fonksiyon yazdık. Eğer yukarıdan
aşağıya doğru sayan bir sayaç yapmak isterseniz yukarıdaki fonksiyonu şu şekle
getirebilirsiniz:

```python
def sayaç(sayı, sınır):
 print(sayı)
 if sayı == sınır:
 return 'bitti!'
 else:
 return sayaç(sayı-1, sınır)

print(sayaç(100, 0))

```

Burada, önceki fonksiyonda+olan işleci-işlecine çevirdik:

```python
return sayaç(sayı-1, sınır)

```

Fonksiyonumuzu çağırırken de elbettesayıparametresinin değerini100olarak,sınırparametresinin değerini ise0olarak belirledik.

Bu arada, daha önce de bahsettiğimiz gibi, özyinelemeli fonksiyonlar,
özyinelemeye başlarken döndürdükleri değeri, özyineleme işleminin sonunda tek
tek geri döndürür. Bu özelliği göz önünde bulundurarak yukarıdaki fonksiyonu şu
şekilde de yazabilirdiniz:

```python
def sayaç(sayı, sınır):
 if sayı == sınır:
 return 'bitti!'
 else:
 sayaç(sayı+1, sınır)
 print(sayı)

print(sayaç(0, 10))

```

Dikkat ederseniz buradaprint(sayı)satırını özyineleme işlevinin çıkışına
yerleştirdik. Böylece0’dan10’a kadar olan sayıları tersten elde ettik.
Ancak tabii ki yukarıdaki anlamlı bir kod yazım tarzı değil. Çünkü
fonksiyonumuzun yazım tarzıyla yaptığı iş birbiriyle çok ilgisiz. Sayıları
yukarı doğru saymak üzere tasarlandığı belli olan bu kodlar, yalnızca birprint()fonksiyonunun özyineleme çıkışına yerleştirilmesi sayesinde yaptığı
işi yapıyor…

Yukarıda verdiğimiz örnekler sayesinde artık özyinelemeli fonksiyonlar hakkında
en azından fikir sahibi olduğumuzu söyleyebiliriz. Gelin isterseniz şimdi
özyinelemeli fonksiyonlarla ilgili (biraz daha mantıklı) bir örnek vererek bu
çetrefilli konuyu zihnimizde netleştirmeye çalışalım.

Bu defaki örneğimizde iç içe geçmiş listeleri tek katmanlı bir liste haline
getireceğiz. Yani elimizde şöyle bir liste olduğunu varsayarsak:

```python
l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14]

```

Yazacağımız kodlar bu listeyi şu hale getirecek:

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

```

Bu amacı gerçekleştirebilmek için şöyle bir fonksiyon yazalım:

```python
def düz_liste_yap(liste):
 if not isinstance(liste, list):
 return [liste]
 elif not liste:
 return []
 else:
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])

l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14]

print(düz_liste_yap(l))

```

Bu fonksiyonu yukarıdaki iç içe geçmiş listeye uyguladığınızda istediğiniz
sonucu aldığınızı göreceksiniz.

İlk bakışta yukarıdaki kodları anlamak biraz zor gelmiş olabilir. Ama endişe
etmenize gerek yok. Zira biz bu kodları olabildiğince ayrıntılı bir şekilde
açıklayacağız.

İlk olarak dip noktamızı tanımlıyoruz her zamanki gibi:

```python
if not isinstance(liste, list):
 return [liste]

```

Fonksiyonumuzun temel çalışma prensibine göre liste içindeki bütün öğeleri tek
tek alıp başka bir liste içinde toplayacağız. Eğer liste elemanları üzerinde
ilerlerken karşımıza liste olmayan bir eleman çıkarsa bu elemanı[liste]koduyla bir listeye dönüştüreceğiz.

Önceki örneklerden farklı olarak, bu kez kodlarımızda iki farklı dip noktası
kontrolü görüyoruz. İlkini yukarıda açıkladık. İkinci dip noktamız şu:

```python
elif not liste:
 return []

```

Burada yaptığımız şey şu: Eğer özyineleme esnasında boş bir liste ile
karşılaşırsak, tekrar boş bir liste döndürüyoruz. Peki ama neden?

Bildiğiniz gibi boş bir listenin 0. elemanı olmaz. Yani boş bir liste üzerinde
şu işlemi yapamayız:

```python
>>> a = []
>>> a[0]

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
IndexError: list index out of range

```

Gördüğünüz gibi, boş bir liste üzerinde indeksleme işlemi yapmaya
kalkıştığımızda hata alıyoruz. Şimdi durumu daha iyi anlayabilmek için
isterseniz yukarıdaki kodları bir de ikinci dip noktası kontrolü olmadan yazmayı
deneyelim:

```python
def düz_liste_yap(liste):
 if not isinstance(liste, list):
 return [liste]
 else:
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])

l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14]

print(düz_liste_yap(l))

```

Bu kodları çalıştırdığımızda şu hata mesajıyla karşılaşıyoruz:

```python
Traceback (most recent call last):
 File "deneme.py", line 9, in <module>
 print(düz_liste_yap(l))
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
 File "deneme.py", line 5, in düz_liste_yap
 return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])
IndexError: list index out of range

```

Gördüğünüz gibi, biraz önce boş bir liste üzerinde indeksleme yapmaya
çalıştığımızda aldığımız hatanın aynısı bu. Çünkü kodlarımızınelsebloğuna
bakarsanız liste üzerinde indeksleme yaptığımızı görürsünüz:

```python
return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])

```

Elbette boş bir listeliste[0]veyaliste[1:]gibi sorgulamalaraIndexErrortipinde bir hata mesajıyla cevap verecektir. İşte böyle bir
durumda hata almamak için şu kodları yazıyoruz:

```python
elif not liste:
 return []

```

Böylece özyineleme esnasında boş bir listeyle karşılaştığımızda bu listeyi şu
şekle dönüştürüyoruz:

```python
[[]]

```

Böyle bir yapı üzerinde indeksleme yapılabilir:

```python
>>> a = [[]]
>>> a[0]

[]

```

Dip noktaya ulaşılana kadar yapılacak işlemler ise şunlar:

```python
return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:])

```

Yani listenin ilk öğesine, geri kalan öğeleri teker teker ekliyoruz.

Gelin bir örnek daha verelim:

```python
def topla(sayilar):
 if len(sayilar) < 1:
 return 0
 else:
 ilk, son = sayilar[0], sayilar[1:]
 return ilk+topla(son)

```

Bu fonksiyonun görevi, kendisine liste olarak verilen sayıları birbiriyle
toplamak. Biz bu işi başka yöntemlerle de yapabileceğimizi biliyoruz, ama bizim
burada amacımız özyinelemeli fonksiyonları anlamak. O yüzden sayıları birbiriyle
toplama işlemini bir de bu şekilde yapmaya çalışacağız.

Elimizde şöyle bir liste olduğunu varsayalım:

```python
liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```

Böyle bir durumda fonksiyonumuz55çıktısı verir.

Gelelim bu fonksiyonu açıklamaya…

Her zamanki gibi ilk olarak dip noktamızı tanımlıyoruz:

```python
if len(sayilar) < 1:
 return 0

```

Buna göresayilaradlı listenin uzunluğu 1’in altına düşünce0değerini
döndürüyoruz. Burada0değerini döndürmemizin nedeni, listede öğe kalmadığında
programımızın hata vermesini önlemek. Eğer0dışında başka bir sayı
döndürürsek bu sayı toplama işleminin sonucuna etki edecektir. Toplama işleminin
sonucunu etkilemeyecek tek sayı0olduğu için biz de bu sayıyı döndürüyoruz.

Taban noktaya varılıncaya kadar yapılacak işlemler ise şunlar:

```python
ilk, son = sayilar[0], sayilar[1:]
return ilk+topla(son)

```

Burada amacımız, listenin ilk sayısı ile listenin geri kalan öğelerini tek tek
birbiriyle toplamak. Bunun içinsayilaradlı listenin ilk öğesini, listenin
geri kalanından ayırıyoruz ve ilk öğeyiilk; geri kalan öğeleri isesonadlı
bir değişkene gönderiyoruz:

```python
ilk, son = sayilar[0], sayilar[1:]

```

Sonra da ilk öğeyi, geri kalan liste öğeleri ile tek tek topluyoruz. Bunun için
detopla()fonksiyonunun kendisinisonadlı değişken içinde tutulan liste
öğelerine özyinelemeli olarak uyguluyoruz:

```python
return ilk+topla(son)

```

Böylece liste içindeki bütün öğelerin toplam değerini elde etmiş oluyoruz.

Bu arada, yeri gelmişken Python programlama dilinin pratik bir özelliğinden söz
edelim. Gördüğünüz gibi sayıların ilk öğesini geri kalan öğelerden ayırmak için
şöyle bir kod yazdık:

```python
ilk, son = sayilar[0], sayilar[1:]

```

Aslında aynı işi çok daha pratik bir şekilde de halledebilirdik. Dikkatlice
bakın:

```python
ilk, *son = sayilar

```

Böylecesayilardeğişkenin ilk öğesiilkdeğişkeninde, geri kalan öğeleri
isesondeğişkeninde tutulacaktır. İlerleyen derslerde ‘Yürüyücüler’
(Iterators) konusunu işlerken bu yapıdan daha ayrıntılı bir şekilde söz
edeceğiz.

### İç İçe (Nested) Fonksiyonlar

Bu bölümde iç içe fonksiyonların ne olduklarını ve nasıl kullanılabileceklerini
inceleceğiz.

#### İç İçe Fonksiyonlar Nedir?

İsminden anlayabileceğimiz gibi içe içe olan birden fazla fonksiyonumuz
olunca bunlaranested, yani iç içe fonksiyonlar diyoruz.
Aşağıdaki gibi iki fonksiyonumuz olduğunu düşünelim:

```python
def fonk1():
 def fonk2():
 ...

```

Buradafonk1kapsayıcı (enclosing) veya dış fonksiyonumuz,fonk2ise içerideki (nested) yani iç
fonksiyonumuz oluyor. İç içe fonksiyonlarımızın ilginç özellikleri olduğunu
söyleyebiliriz. Ayrıca bu fonksiyonları iyice anlamak, ileride üreteçleri
(diğer bir adı ile yürüyücüleri) de daha iyi anlamamızı sağlayacaktır.

İç içe fonksiyonları anlamanın en iyi yolu örnek üzerinden gitmektir.
Şimdi şöyle bir fonksiyon tanımlayalım:

```python
def yazıcı():
 def yaz(mesaj):
 print(mesaj)
 return yaz

```

Kodu çalıştırıp etkileşimli kabuğu kullanalım:

```python
>>> y = yazıcı()
>>> y("Merhaba")
Merhaba
>>> type(y)
<class 'function'>
>>> y
<function yazıcı.<locals>.yaz at 0x00000210D9235558>

```

Şimdi bu çıktılarımızı inceleyelim.yazıcıfonksiyonumuz çağrıldığında değer olarakyazfonksiyonunu çeviriyor. Buyazfonksiyonu dayazıcıfonksiyonumuzun
içerisinde tanımladığı için bizimiçfonksiyonumuz oluyor.yazıcıisekapsayıcıfonksiyonumuz.y("Merhaba")komutu çağırıldığında ekranaMerhabayazılıyor. Çünküy’ye atanan değer olanyazfonksiyonunun yaptığı iş
buydu. Dikkat edersenizy’nin türünün defunctionolduğunu görebilirsiniz.
Son çıktımızda ise alışılmışın dışında bir<locals>ifadesi görüyoruz.
Şimdi biraz bunun üzerine konuşacağız.

Normalde bir fonksiyon yazdığımızda ve bu fonksiyon başka bir fonksiyonun içerisinde
olmadığında, programı çalıştırıldığımızda ve kod işleme sırası bu fonksiyona geldiğinde
fonksiyonumuz tanımlanmış olur. Yani bu fonksiyonun ne olduğu, ne yapacağı
artık Python yorumlayıcısı tarafından bilinmektedir. Ayrıca bu fonksiyondan sadece bir tane
vardır. Örneğin fonksiyonumuz şu şekilde ise:

```python
def fonk():
 pass

```

Herfonk()yazdığımızda aynı fonksiyon çağrılır. Dikkat edin, aynı işlemler yapılır
demiyorum. Aynı fonksiyon çağrılır. Yapacağı işlem burada bizim için önemli değil.

Şimdi de iç içe fonksiyon tanımımıza ve şu<locals>kelimesine bakalım.
İlk önce:

```python
def yazıcı():
 def yaz(mesaj):
 print(mesaj)
 return yaz

```

Şeklinde kapsayıcı fonksiyonumuzu tanımlamış oluyoruz. Dikkat ederseniz sadece kapsa-
yıcı fonksiyonun tanımlandığını söyledim. Artıkyazıcıfonksiyonunun, Python yorum-
layıcısı tarafından ne yapacağı, nasıl çalışacağı biliniyor. Ancakyazfonksiyonu için
aynı şeyleri söyleyemeyiz. Sonuç olarak bir fonksiyon çağırılmadan içerisindeki
komutlar çalışmaz. Eğerdefyaz...komutu çalışmaz ise deyazfonksiyonumuz tanımlanmış
olmaz. Yani şu andayazfonksiyonumuz tanımlanmamıştır. Peki ne zaman tanımlanacaktır?
Tabii ki deyazıcıfonksiyonumuzu çağırdığımız zaman. Çünkü dediğimiz gibi,
yazıcı fonksiyonu çağrılmadığı sürecedefyaz...bölümü çalışmıyor. Python yorumlayıcısı
programımız çalışırkenyazıcıfonksiyonununne yapacağınıbilir, dolayısı ile deyazfonksiyonunununnasıl tanımlanacağınıbilir. Ancakyazfonksiyonu
tanımlanmadan öncene yapacağınıbilemez. Buradan önemli
yerlere varacağımız için bu kısmın anlaşılması gerekiyor. Şimdi şunu söyleyebiliriz kiyazıcıfonksiyonumuzu her çağırdımızdayazsınıfı en baştan tanımlanır.
Bu dayazıcıfonksiyonumuzu her çağırışımızda yeni tanımlananyazfonksiyonunun
farklı ve tek olduğu anlamına gelir. Yani kapsayıcı olanyazıcıfonksiyonu
sadece bir tane iken döndürdüğüyazfonksiyonu birden fazla ve farklı oluyor.
Yaniyazıcıfonksiyonumuzu her çağırdığımızda sadece o çağırışımıza özel biryazfonksiyonu elde ediyoruz. İşte bu<locals>kelimesi buradan geliyor.
Yani:

```python
>>> y
<function yazıcı.<locals>.yaz at 0x00000210D9235558>

```

Bu demek oluyor ki bizimydeğişkenimiz, daha önceki biryazıcıfonksiyonunun çağrısına
ait, yani onun içinde tanımlanan biryazfonksiyonudur.localsda zaten
yerel değişkenler anlamına gelir. Yani buradakiyazfonksiyonu, daha önce çağırdığımızyazıcıfonksiyonunun içinde tanımlanan yerel bir değişkendir. Tanımlanan heryazfonksiyonunun farklı olduğunu şu şekilde de görebiliriz:

```python
>>> y = yazıcı()
>>> b = yazıcı()
>>> y
<function yazıcı.<locals>.yaz at 0x00000210D9235558>
>>> b
<function yazıcı.<locals>.yaz at 0x00000210D920E678>
>>> id(y)
2271385703768
>>> id(b)
2271385544312

```

Gördüğünüz gibi farklıyazfonksiyonlarının hafızada saklandığı yerler de
farklı oluyor…

Bu konuda biraz daha ilerlemeden önce bilmemiz gereken başka şeyler de var.
Biraz da onlar hakkında konuşalım.

#### ‘nonlocal’ Deyimi

nonlocaldeyimiyerel olmayananlamına gelir. Kullanım amacıglobaldeyimi
ile benzerdir. Ancak bunu kullanmamız küresel yani global değişkenlere ulaşmamızı değil,
yerel olmayan değişkenlere ulaşmamızı sağlar. Ayrıca bu deyimi sadece iç içe fonksiyonlarda kullanabiliriz. Tabii bunu böyle söyleyince bir şey anlaşılmıyor. Örnek vermek lazım:

```python
def kapsayıcı_fonk():
 non_local_değişken = 1

 def iç_fonk():
 non_local_değişken = 2
 print(non_local_değişken)

 return iç_fonk

```

Burada iç içe bir fonksiyon yapısına sahibiz. Şimdi bu kodumuzu çalıştırıp
etkileşimli kabukta denemeler yapalım:

```python
>>> dönüş_fonksiyonu = kapsayıcı_fonk()
>>> dönüş_fonksiyonu()
2

```

Gördüğünüz gibi1yazılmadı. Yani kapsayıcı fonksiyona ait olannon_local_değişkenile iç fonksiyonumuza ait olannon_local_değişkenfarklılar. Aynı bu örnekte:

```python
 a = 1

def fonk():
 a = 2
 print(a)

>>> fonk()
2

```

küreseladeğişkeni ilefonkfonksiyonuna aitadeğişkeninin farklı olması gibi.
Peki biz burada fonksiyon içinde de küresela’yı kullanmak istersek nasıl yaparız?
Bir şey yapmamıza gerek yok, zaten fonksiyon kendi içindeadeğişkenini bulamayınca global alana bakacaktır:

```python
a = 1

def fonk():
 print(a)

>>> fonk()
1

```

Fakat eğer küresel olanadeğişkenini değiştirmek istiyorsanız bildiğiniz gibiglobaldeyimini kullanmamız lazım:

```python
a = 1

def fonk():
 global a
 a += 1
 print(a)

>>> fonk()
2
>>> a
2

```

İşte aynı bunun gibi:

```python
def kapsayıcı_fonk():
 non_local_değişken = 1

 def iç_fonk():
 non_local_değişken = 2
 print(non_local_değişken)

 return iç_fonk

```

Örneğimizde deiç_fonk’un içindekapsayıcı_fonk’a ait olannon_local_değişkendeğişkenini değiştirmek istersek bunu danonlocaldeyimi ile şöyle yapabiliriz:

```python
def kapsayıcı_fonk():
 non_local_değişken = 1

 def iç_fonk():
 nonlocal non_local_değişken
 non_local_değişken += 1
 print(non_local_değişken)

 return iç_fonk

>>> dönüş_fonksiyonu = kapsayıcı_fonk()
>>> dönüş_fonksiyonu()
2

```

Tabii bu değişkeni değiştirmek gibi bir amacımız yoksa, sadece kullanmak isteseydik şöyle de yapabilirdik venonlocaldeyimine gerek kalmazdı:

```python
def kapsayıcı_fonk():
 non_local_değişken = 1

 def iç_fonk():
 print(non_local_değişken)
 return iç_fonk

>>> dönüş_fonksiyonu = kapsayıcı_fonk()
>>> dönüş_fonksiyonu()
1

```

Gördüğünüz gibinonlocalifadesi iç içe fonksiyonlar ile çalışırken iç fonksiyonda,
kapsayıcı fonksiyonunun değişkenlerini değiştirmemizi sağlıyor. Artık bu bilgiyi kullanarak
şöyle bir fonksiyon oluşturabiliriz:

```python
def yazıcı(mesaj):
 def yaz():
 nonlocal mesaj
 mesaj += " Dünya"
 print(mesaj)
 return yaz

>>> y = yazıcı("Merhaba")
>>> y()
Merhaba Dünya

```

nonlocaldeyiminin nasıl kullanıldığını bildiğiniz için örneğimizi anladığınızı
düşünüyorum. Burda yaptığımız tek farklı şeynonlocaldeyimi ile birlikte
kullandığımız nesneninyazıcıfonksiyonunun parametresi olması. Bunu yapmamızda
bir sakınca yoktur. Sonuç olarakmesajparametresi, normalde deyazıcıfonksiyonu
içerisinde bir değişken gibi kullanılmaktadır. Ancak şunu da unutmayalım ki aynıglobalifadesini kullanırken olduğu gibinonlocalifadesinde de eğer
daha üst bir alandaki değişkenin üzerinde bir değer atama işleci kullanmayacaksaknonlocalifadesini kullanmamıza gerek yoktur. Yani değişkeninonlocalifadesi
olmadan da kullanabiliriz, ancak değerini değiştiremeyiz. Eğer yukarıdaki koddanonlocalifadesini kullanmazsak hata alırız:

```python
def yazıcı(mesaj):
 def yaz():
 mesaj += " Dünya"
 print(mesaj)
 return yaz

>>> y = yazıcı("Merhaba Dünya")
>>> y()
Traceback (most recent call last):
 File "<pyshell#1>", line 1, in <module>
 y()
 File "C:\Users\Dinçel\Desktop\istihza.py", line 3, in yaz
 mesaj += " Dünya"
UnboundLocalError: local variable 'mesaj' referenced before assignment

```

Sonuç olarak kapsayıcı fonksiyona ait değişkenleri, iç fonksiyonumuzda değiştirebilmek
içinnonlocalifadesine ihtiyacımız vardır.

Şimdi en başta konuştuğumuz<locals>konusuna geri dönüyoruz. İç fonksiyonun,
çağırılan kapsayıcı fonksiyonun yerel değişkenlerinden biri olduğunu ve
her seferinde yeniden tanımlandığını, bu yüzden de aynı işi yapsalar da
aslında farklı olan fonksiyonlar elde ettiğimizi konuşmuştuk. Ancak her seferinde
yeniden tanımlanan tek şey iç fonksiyon değildir. Kapsayıcı fonksiyonun içindeki
her değişken, dış fonksiyonun her çağırılışında baştan tanımlanır.
Bunu şu örnek üzerinden anlamaya çalışalım:

```python
def sayıcı():
 sayı = 0
 def say():
 nonlocal sayı
 sayı += 1
 return sayı
 return say

```

Kodumuzu kısaca incelerseksayfonksiyonundasayıdeğişkenininonlocalhale getiriyoruz. Aynı zamandasayfonksiyonu her çağırıldığındasayıdeğiş-
kenini de bir artırıp değer olarak döndürüyoruz. Şimdi kodumuzu çalıştıralım:

```python
>>> s = sayıcı()
>>> type(s)
<class 'function'>
>>> s
<function sayıcı.<locals>.say at 0x000001FD2213ED38>
>>>
>>> s()
1
>>> s()
2
>>> s()
3
>>> s()
4

```

Gördüğünüz gibi ilginç bir şekildesayıcıfonksiyonu çalışmış ve bitmiştir,
ancak içerisinde bulunansayıdeğişkeni silinmemiştir ve geri döndürülensayfonksiyonu tarafından kullanılmaya devam etmektedir. Yani biz göremesek desayıdeğişkeni hala bir yerlede saklanılıyordur. Peki normalde bir fonksiyonun
çalışması bitince yerel değişkenleri silinmez mi? Tabii ki silinir. Ancak buradasayfonksiyonu içindesayıdeğişkenininonlocalhale getirmiş oluyoruz. Yani aslında
bizsayıdeğişkenini kullanmaya devam ediyoruz. Eee şimdi Python kalkıp da bizim
kullanacağımız bir değişkeni silse ayıp olur. O da bunu yapmıyor zaten. Ancaksayıdeğişkeni iç fonksiyon olansayfonksiyonunda hiç kullanılmasaydı silinirdi. Aslında bu
örnekteki kilit olaylardan biri desayıdeğişkeninin sadece bir defa tanımlanması
ve bu tanımın aynısayfonksiyonunda olduğu gibisayıcıfonksiyonumuzun sadece bir çağırılışına özgü olması. Buradan iki sonuca varıyoruz:
- sayıcısınıfını birden fazla defa çağırsak bile geri döndürülen hersayfonksiyonu ekrana sayıları hep sırayla yazdıracaktır. Çünkü hersayfonksiyonu kendisini tanımlayansayıcıçağırılışına ait olansayıdeğişkenini kullanmaktadır.
- Hersayfonksiyonunun kullandığısayıdeğişkeni sadece bir defa0olarak tanımlanmakta ve daha sonrasayfonksiyonumuzu her çağırışımızda artmaktadır.

sayıcısınıfını birden fazla defa çağırsak bile geri döndürülen hersayfonksiyonu ekrana sayıları hep sırayla yazdıracaktır. Çünkü hersayfonksiyonu kendisini tanımlayansayıcıçağırılışına ait olansayıdeğişkenini kullanmaktadır.

Hersayfonksiyonunun kullandığısayıdeğişkeni sadece bir defa0olarak tanımlanmakta ve daha sonrasayfonksiyonumuzu her çağırışımızda artmaktadır.

Evet dediğimiz gibi farklısayfonksiyonları farklısayıdeğişkenlerini kullanıyor:

```python
>>> s = sayıcı()
>>> s()
1
>>> s()
2
>>> s()
3
>>> s()
4
>>>
>>> s2 = sayıcı()
>>> s2()
1
>>> s2()
2
>>> s2()
3
>>> s2()
4

```

Eğer bu örnekleri anlamakta zorluk çektiyseniz bunun çalışma mantığı olarak şunun ile aynı olduğunu söyleyebiliriz:

```python
sayı = 0
def say():
 global sayı
 sayı += 1
 print(sayı)

>>> s = say
>>> s()
1
>>> s()
2
>>> s()
3
>>> s()
4

```

globaldeyimi ile yaptığımız bu örneğinnonlocalile yaptığımız örnekten belki de en önemli
farkı,nonlocalörneğindesayıdeğişkenine doğrudan erişememizdir. Amasayıdeğişkeninisayfonksiyonu tarafından kullanılmaktadır. Ancak bizimsayıdeğişkenine bizzat erişememiz, gördüğümüz gibi, silindiği anlamına gelmiyor…

#### İç İçe Fonksiyonların Kullanım Alanları

Şu ana kadar iç içe fonksiyonların nasıl tanımlandığını ve nasıl çalıştığını öğrendik.
Ancak öğrenme aşamasında olduğumuz için buraya kadar hep basit örnekler verdik.
Şimdi bazı işe yarar örnekler vereceğiz ve ne zaman içe içe fonksiyon kullanıp ne zaman normal fonksiyonlar
kullanmamızın daha doğru olacağını konuşacağız.

Öncelikle şunu söyleyelim ki iç içe fonksiyonların en fazla kullanıldığı yer bezeyicilerdir.
Bu daha sonra göreceğimiz bir konu ancak orada iç içe fonksiyonları çok fazla kullanacağız, haberiniz olsun.

İç içe fonksiyonlar bazı işlemleri daha verimli yapmamızı sağlayabileceği gibi bazı işlemleri de
(yanlış veya gereksiz yere kullanırsak) yavaşlatırlar. Mesela şu fonksiyona bakalım:

```python
def işlem_yap(sayı, bölen, *eklenenler):
 sonuç = sayı / bölen

 for i in eklenenler:
 sonuç += i

 return sonuç

```

Bu fonksiyonumuz aldığısayıparametresinibölenparametresi ile böldükten sonra geriye kalan bütün parametreleri sonuca ekleyip geri döndürüyor.*eklenenler’in ne anlama geldiğini zaten daha önce öğrenmiştik. şimdi bu fonksiyonu kullanalım:

```python
>>> işlem_yap(10, 2, 5, 7)
17.0
>>> işlem_yap(8, 4, 1, 3)
6.0

```

Şimdi diyelim ki biz yazdığımız programda farklısayıvebölenparametreleri ile hep aynıeklenenlerparametrelerini kullanacağız. Yani şunun gibi işlemler yapacağız:

```python
>>> işlem_yap(4, 2, 1, 4, 5)
12.0
>>> işlem_yap(60, 12, 1, 4, 5)
15.0
>>> işlem_yap(48, 4, 1, 4, 5)
22.0
>>> işlem_yap(12, 6, 3, 6, 2)
13.0
>>> işlem_yap(12, 4, 3, 6, 2)
14.0
>>> işlem_yap(105, 15, 3, 6, 2)
18.0

```

Burada görebileceğimiz gibi aynıeklenenlerdeğerleri çoklukla kullanılıyor. Böyle bir durumda toplama işlemini her seferinde gerçekleştirmemiz gereksiz oluyor. Bu işlemin sadece bir defa yapılmasını şu şekilde sağlayabiliriz:

```python
def işlem_yapıcı(*eklenenler):
 ekle = 0
 for i in eklenenler:
 ekle += i

 def işlem(sayı, bölen):
 return sayı/bölen + ekle

 return işlem

```

Bu kodumuzdaişlem_yapıcıfonksiyonu hep aynı olacağı için değişmeyecek olaneklenenlerparametresini sadece bir defa alıyor ve hepsini topluyor, daha sonraişlemfonksiyonunu geri döndürüyor.işlemfonksiyonunu çağırdığımızda dasayıvebölenparametrelerini veriyoruz ve işlemin sonucu bize geri dönüyor. İlk yaptığımız işlemleri bir de böyle kullanalım:

```python
>>> işlemci = işlem_yapıcı(1, 4, 5)
>>> işlemci2 = işlem_yapıcı(3, 6, 2)
>>> işlemci(4, 2)
12.0
>>> işlemci(60, 12)
15.0
>>> işlemci(48, 4)
22.0
>>> işlemci2(12, 6)
13.0
>>> işlemci2(12, 4)
14.0
>>> işlemci2(105, 15)
18.0

```

Artık gerekli işlemi yapacak fonksiyonu sadece bir defa oluşturuyoruz ve sürekli onu kullanıyoruz. Bu da aynı parametrelerin sürekli fonksiyona parametre olarak yollanmasını engelliyor ve gerekli işlemlerin sadece bir defa yapılmasını sağlıyor. Kendi yazdığınız kodlarda herhangi bir amaç ile bir fonksiyon oluşturduğunuzda ve bu fonksiyonu da kullanırken bunun gibi bir durum ile karşılaştırdığımızda artık iç içe fonksiyonları kullanarak kodu nasıl daha verimli hale getireceğiniz hakkında aklınızda bir fikir oluşmuştur diye düşünüyorum.

Şimdi de bir fonksiyon oluştururken o fonksiyonun içinde kod tekrarları yaptığımız fark ettiğimizi varsayalım. Böyle bir durumda bu kod tekrarlarını da azaltmak için bir fonksiyon daha yazmamız iyi olacaktır. Yani:

```python
def dosyadaki_karakter_sayısı(dosya, karakter):
 sonuç = 0

 if type(dosya) == str:
 with open(dosya, "r") as f:
 veri = f.read()
 for i in veri:
 if i == karakter:
 sonuç += 1
 else:
 veri = dosya.read()
 for i in veri:
 if i == karakter:
 sonuç += 1

 return sonuç

```

Elimizde bir dosyayı okuyacak ve bu dosyadaki belli bir karakterin sayını döndürecek bir fonksiyon var. Ama bu fonksiyondosyaparametresi olarak hem dosyanın ismini hem de açılmış bir dosyanın kendisini alabiliyor.if type(dosya) == str:kısmıdosyadeğişkeninin türününstrolup olmadığını kontrol ediyor, eğer öyleyse dosyayı açıyoruz ve okuyoruz. Öyle değilse dosyayı direkt okuyoruz. Dikkat ederseniz daha sonra yapılan işlemler aynı, yani:

```python
for i in veri:
 if i == karakter:
 sonuç += 1

```

kısmı iki defa tekrar ediyor. Hatırlarsanız bir karakter dizisinin içinde herhangi bir karakterin kaç defa geçtiğini öğrenmek içincountmetodundan faydalanabiliriz:

```python
>>> "merhaba".count("a")
2

```

Ama burada örneğimiz anlaşılsın diye bunu kendimiz yapıyoruz.

Şimdi yukarıdaki tekrar eden yeri şu şekilde ayrı bir fonksiyon haline getirebiliriz:

```python
def karakter_sayısı(karakter_dizisi, karakter):
 sayaç = 0
 for i in karakter_dizisi:
 if i == karakter:
 sayaç += 1
 return sayaç

def dosyadaki_karakter_sayısı(dosya, karakter):
 if type(dosya) == str:
 with open(dosya, "r") as f:
 return karakter_sayısı(f.read(), karakter)
 else:
 return karakter_sayısı(dosya.read(), karakter)

```

Artık karakter dizisinin içinde bir karakterin kaç defa geçtiğini bulmak içinkarakter_sayısısayısı adlı fonksiyon yararlanıyoruz. Ancak bizim bu fonksiyonu tanımlama sebebimizdosyadaki_karakter_sayısıfonksiyonunda yaptığımız bir işlemi yerine getirmekdi. Eğerkarakter_sayısıfonksiyonunu programımızda sadecedosyadaki_karakter_sayısıfonksiyonu içinde kullanacaksak bu fonksiyonu global alanda tanımlamamıza gerek yokü,dosyadaki_karakter_sayısıfonksiyonunun içinde de tanımlayabiliriz:

```python
def dosyadaki_karakter_sayısı(dosya, karakter):

 def karakter_sayısı(karakter_dizisi):
 sayaç = 0
 for i in karakter_dizisi:
 if i == karakter:
 sayaç += 1
 return sayaç

 if type(dosya) == str:
 with open(dosya, "r") as f:
 return karakter_sayısı(f.read())
 else:
 return karakter_sayısı(dosya.read())

```

Ayrıca bu şekildekarakter_sayısıfonksiyonununkarakterşeklinde bir parametreye ihtiyacı kalmadı, zatendosyadaki_karakter_sayısıfonksiyonunun içindekikarakterdeğişkenine erişebiliyor. İç içe fonksiyonları bunun gibi durumlarda da kullanabiliriz.

### Üreteçler (Generators)

Biz üreteçlerle az çok tanışıyoruz. Liste üreteçleri olsun, sözlük üreteçleri
olsun bu konu hakkında bir şeyler öğrenmiştik. Ancak biz üreteçlerimizi hep
şunun gibi tanımlamıştık:

```python
>>> listem = [i for i in range(10)]
>>> listem
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Dikkat ederseniz buradaiforiinrange(10)kısmı (nasıllambdafonksiyonlar normal yolla tanımlanan fonksiyonlardan farklı bir söz dizimi kullanıyorsa) normal kodlardan biraz farklı bir söz dizimi kullanıyor. Bu söz dizimi ile karmaşık
algoritmalar oluşturmak zordur, çoğunlukla da mümkün değildir. Zaten bunun bulunma sebebi
karmaşık algoritmalarda kullanılması değil, kısa işlerde yazım kolaylığı sağlamasıdır.
Yani bu yazım şekli, bazı fonksiyonlarınlambdaolarak tanımlanması gibi,
üreteç tanımlamanın sadece kısa bir yoludur. Peki aslında üreteçler nasıl
tanımlanır? Şimdi gelin bu konuyu inceleyelim.

#### Üreteçlere Giriş

Üreteçler, fonksiyonlara benzer şekilde tanımlanır. Hatta tek farkınınyieldadındaki bir ifade olduğunu söyleyebiliriz. Hatırlarsanız iç içe fonksiyonlar
konusunda üreteçler konusuna birkaç defa atıfta bulunmuştuk.
Bu yüzden aynı işi yapacak iç içe bir fonksiyon ile bir üreteci karşılaştırarak
konuya başlamak istiyorum:

```python
def fonksiyon_sayıcı():
 sayı = 0
 def say():
 nonlocal sayı
 sayı += 1
 return sayı
 return say

def üreteç_sayıcı():
 sayı = 0
 while True:
 sayı += 1
 yield sayı

```

Endişe etmeyin. İlerideüreteç_sayıcı’nın nasıl çalıştığını inceleyeceğiz.
Şimdilik sadece şuraya odaklanalım:

```python
>>> type(fonksiyon_sayıcı)
<class 'function'>
>>> type(üreteç_sayıcı)
<class 'function'>

>>> fonk = fonksiyon_sayıcı()
>>> üreteç = üreteç_sayıcı()

>>> type(fonk)
<class 'function'>
>>> type(üreteç)
<class 'generator'>

>>> fonk()
1
>>> fonk()
2
>>> fonk()
3
>>> fonk()
4

>>> next(üreteç)
1
>>> next(üreteç)
2
>>> next(üreteç)
3
>>> next(üreteç)
4

```

fonkveüreteçdeğişkenlerini kullanarak elde ettiğimiz sonuçların aynı olduğunu görebiliyorsunuz. Şimdi
bundan faydalanarak tanımlanma şekillerini anlamaya çalışalım.

fonkfonksiyonunun nasıl çalıştığını zaten iç içe fonksiyonlar konusunda gördük.
Şimdinextfonksiyonu veyielddeyimi ile alakalı konuşalım. Öncelikle
şunu söylemek gerekir kinextfonksiyonu, gömülü bir fonksiyondur. Ne işe yaradığını anlamak
için iseyielddeyimini anlamamız gerekiyor. Eğer kodumuzu ve aldığımız
çıktıları incelersenizyielddeyiminin,returndeyimine bazı yönlerden
benzediğini fark edebilirsiniz. Tabii önemli farklılıklar da var. Bir kere
fark edeceğiniz gibiyielddeyimi hangi değeri döndüreceğimizi
belirliyor. Peki bu döndürme işlemininreturnile değer döndürmekten
ne farkı var? Bir fonksiyonun içindereturndeyimine ulaşıldığında
fonksiyon sonlanır ve fonksiyona ait yerel değişkenler silinir.yielddeyiminde böyle
bir şey söz konusu değildir. Aynı iç içe fonksiyonlarda iç fonksiyonunun dış fonksiyondaki değişkeni kullanması gibi
üreteçlerin de yerel değişkenleri Python tarafından saklanır. Ancak üreteçlerde
belli değişkenler değil, yerel değişkenlerin tamamı saklanır. Şimdi yukarıdaki örnekte şu üç kısma
tekrar bakarsak:

```python
>>> type(fonksiyon_sayıcı)
<class 'function'>
>>> type(üreteç_sayıcı)
<class 'function'>

>>> fonk = fonksiyon_sayıcı()
>>> üreteç = üreteç_sayıcı()

>>> type(fonk)
<class 'function'>
>>> type(üreteç)
<class 'generator'>

```

Şunu görüyoruz kiüreteç_sayıcıaslında bir fonksiyon. Ama alelade bir
fonksiyon değil, çağrıldığındageneratornesnesi döndüren bir fonksiyon.
Yani aynı iç içe fonksiyonlarda önce kapsayıcı fonksiyonu çağırıp dönüş değerini kullandığımız
gibi üreteçlerde de önce üreteci tanımladığımız fonksiyonu çağırıp dönüş değerini
kullanıyoruz. Çünkü aslında üreteç olan nesne, bu döndürülen değerdir. Ve aynı
iç içe fonksiyonlarda olduğu gibi bu durum birbirinden bağımsız ancak aynı işi
yapan değişkenler oluşturmamızı sağlar. Dikkat ederseniz iç içe fonksiyonlar ve
üreteçler, çalışma prensibi açısından benzerler. Ancak üreteçleryieldifadesininin
kullanımı ile bize daha kullanışlı bir algoritma şekli vermektedir.

Şu ana kadar üreteçlerin nasıl tanımlandığı ve nasıl kullanıldığı hakkında pek de bilgi
vermedik. Yaptığımız şey, iç içe fonksiyonlar ile üreteçlerin, çalışma
prensiblerinin ne kadar benzer olduğuna dikkat çekmek idi. Şimdinextfonksiyonu veyielddeyimi hakkında konuşarak kendi üreteçlerimizi nasıl tanımlayacağımıza
bakalım.

#### Üreteçlerin Tanımlanması

##### ‘yield’ Deyimi ve ‘next’ Fonksiyonu

nextfonksiyonunun gömülü bir fonksiyon olduğunu söylemiştik.yielddeyimi da
üretecimizden değer döndürmemizi sağlıyordu. Peki bu işlemler hangi kurallar çerçevesinde
gerçekleşiyor?

Basit bir üreteç tanımlayarakyieldmetodunu anlatmaya çalışalım:

```python
def üreteç():
 yield "Merhaba"
 yield "Dünya"

```

returndeyiminin fonksiyonu sonlandırırkenyielddeyimi üretecin çalışmasına ara
verir ve sağındaki değişkeni geriye döndürür. Herhangi bir değer verilmemiş iseNonedöndürecektir.
Şimdi kodumuzu çalıştıralım:

```python
>>> g = üreteç()
>>> next(g)
"Merhaba"
>>> next(g)
"Dünya"
>>> next(g)
Traceback (most recent call last):
 File "<pyshell#5>", line 1, in <module>
 next(g)
StopIteration

```

Çıktımızı incelerseknextfonksiyonunun, kendisine verilen üretecin kodunu biryielddeyimine
rastlayana kadar çalıştırdığını,yielddeyimine rastladığında ise deyimin sağındaki
değişkeni döndürdüğünü görebiliriz. Unutmayalım ki bu döndürme işlemini yapannextfonksiyonudur.
Üretecimizin içinde herhangi bir yönerge kalmadığında isenextfonksiyonumuzStopIterationhatası yükseltmektedir.

> **Not**
> ‘next’ fonksiyonunun burada yaptığı iş için ‘yineleme (iteration)’ terimi kullanılır.
‘next’ fonksiyonuna parametre olarak verilebilen nesneler ise birer ‘yinelenebilir nesne
(iterable object)’dir. ‘generator’ sınıfı yinelenebilir nesnelere bir örnektir.

Not

‘next’ fonksiyonunun burada yaptığı iş için ‘yineleme (iteration)’ terimi kullanılır.
‘next’ fonksiyonuna parametre olarak verilebilen nesneler ise birer ‘yinelenebilir nesne
(iterable object)’dir. ‘generator’ sınıfı yinelenebilir nesnelere bir örnektir.

Bir örnek daha yapalım:

```python
def üreteç():
 print("üreteç ilk defa next fonksiyonu ile kullanıldı.")
 yield "1. yield"
 print("üreteç ikinci defa next fonksiyonu ile kullanıldı.")
 yield "2. yield"
 print("üreteç üçüncü defa next fonksiyonu ile kullanıldı ve bitti.")

>>> g = üreteç()
>>> ilk_dönüş = next(g)
üreteç ilk defa next fonksiyonu ile kullanıldı.
>>> ikinci_dönüş = next(g)
üreteç ikinci defa next fonksiyonu ile kullanıldı.
>>> son_dönüş = next(g)
üreteç üçüncü defa next fonksiyonu ile kullanıldı ve bitti.
Traceback (most recent call last):
 File "<pyshell#5>", line 1, in <module>
 next(g)
StopIteration
>>>
>>> ilk_dönüş
'1. yield'
>>> ikinci_dönüş
'2. yield'
>>> son_dönüş
Traceback (most recent call last):
 File "<pyshell#0>", line 1, in <module>
 son_dönüş
NameError: name 'son_dönüş' is not defined

```

Örneğimiz gayet açık.nextfonksiyonu kendisine verilen üretecin kodunu en sol kaldığı yerden çalıştırmaya devam ediyor, biryieldifadesine denk geldiğinde de üretecin çalışması duruyor venextfonksiyonuyielddeyiminin sağındaki değeri geri döndürüyor. Tabiison_dönüş’ünNoneolmak yerine tanımlanmamış olması da ilginç gelmiş olabilir. Bunu da şu örnekle açıklayabiliriz:

```python
>>> def hata():
 raise Exception

>>> dönüş = hata()
Traceback (most recent call last):
 File "<pyshell#8>", line 1, in <module>
 dönüş = hata()
 File "<pyshell#7>", line 2, in hata
 raise Exception
Exception
>>> dönüş
Traceback (most recent call last):
 File "<pyshell#9>", line 1, in <module>
 dönüş
NameError: name 'dönüş' is not defined

```

Gördüğümüz gibison_dönüşdeğişkenimizin tanımlanmamış olmasının sebebi denextfonksiyonunun değer döndürmek yerine hata yükseltmiş olmasıdır.

Buraya kadar yaptığımız örnekleri iç içe fonksiyonlar ile de kolayca yapabilirdik. Üreteçlerin
önemli bir özelliği de tanımlanırken , fonksiyonlar gibi, her türlü ifade ile kullanılabilmesidir.
Örnek olarakwhiledöngüsü kullanarak, 1’den başlayarak her yinelediğimizde fibonacci
sayı dizisinin bir sonraki elemanını döndürecek bir üreteç yazalım:

```python
def fibonacci():
 x = 1
 y = 0
 z = 0
 while True:
 z = y
 y = x
 x = y + z
 yield x

```

> **Not**
> Fibonacci dizisi, 0 ve 1 ile başlayan ve her sayının kendisinden önce gelen
iki sayının toplanması ile elde edildiği bir sayı dizisidir. İtalyan matematikçi
Leonardo Fibonacci’den adını alır. 0, 1, 1 (0+1), 2 (1+1), 3 (1+2), 5 (2+3), 8 (3+5), 13 (5+8), 21 (8+13), 34 (13+21)
şeklinde devam eder.

Not

Fibonacci dizisi, 0 ve 1 ile başlayan ve her sayının kendisinden önce gelen
iki sayının toplanması ile elde edildiği bir sayı dizisidir. İtalyan matematikçi
Leonardo Fibonacci’den adını alır. 0, 1, 1 (0+1), 2 (1+1), 3 (1+2), 5 (2+3), 8 (3+5), 13 (5+8), 21 (8+13), 34 (13+21)
şeklinde devam eder.

Şimdi bu kodu çalıştıralım:

```python
>>> f = fibonacci()
>>> next(f)
1
>>> next(f)
2
>>> next(f)
3
>>> next(f)
5
>>> next(f)
8
>>> next(f)
13

```

Gördüğünüz gibi üretecimiz bize (ilk 0 ve 1 sonrasındaki) fibonacci sayılarını vermektedir. Kodumuzu anlamaya çalışırsak:
- İlk yinelemede, yaninextfonksiyonunu ilk kullanışımızda,x,yvezdeğişkenleri tanımlanıyor. Daha sonrawhiledöngüsüne giriliyor. Değişkenlerin değerleri değiştirildikten sonrayieldxdeyimine geldiğimiz içinnextfonksiyonuxdeğerini döndürürerek üretecemizin çalışmasını durduruyor.
- İkinci yinelememizde normal bir kodda olacağı gibiwhiledöngümüzün başına gidiliyor. Aynı işlemler tekrarlanıyor. Tekraryielddeyimine geliniyor.xdeğeri döndürürülüyor. Üretecimizin çalışması durduruluyor ve aynı şeyler tekrar etmeye devam ediyor.

İlk yinelemede, yaninextfonksiyonunu ilk kullanışımızda,x,yvezdeğişkenleri tanımlanıyor. Daha sonrawhiledöngüsüne giriliyor. Değişkenlerin değerleri değiştirildikten sonrayieldxdeyimine geldiğimiz içinnextfonksiyonuxdeğerini döndürürerek üretecemizin çalışmasını durduruyor.

İkinci yinelememizde normal bir kodda olacağı gibiwhiledöngümüzün başına gidiliyor. Aynı işlemler tekrarlanıyor. Tekraryielddeyimine geliniyor.xdeğeri döndürürülüyor. Üretecimizin çalışması durduruluyor ve aynı şeyler tekrar etmeye devam ediyor.

Üreteçlerin çok güzel özelliklerinden biri defordöngüsü ile kullanılabilmeleridir.
Örneğinfibonacciüretecimiz için bunu uygulayalım:

```python
>>> for i in fibonacci():
 print(i)

1
2
3
5
8
13
21
34
55
89
144
...

```

> **Not**
> foriinfibonacci()ifadesindefibonaccifonksiyonunu çağırdığımıza dikkat
edin. Sonuçta üretecimizin kendisifibonaccifonksiyonu değil, onun döndüreceği değer.

Not

foriinfibonacci()ifadesindefibonaccifonksiyonunu çağırdığımıza dikkat
edin. Sonuçta üretecimizin kendisifibonaccifonksiyonu değil, onun döndüreceği değer.

Ancak bu örnekte üretecimiz hiç durmuyor. Bazen üreteçlerimizin durmasını isteyebiliriz.
Bunu yapmamız için tek gereken şey üretecimizin durmasını istediğimiz yerde üretecimizireturnetmemizdir. Sonuçta üreteçler de bir tür fonksiyondur vereturndeyimi
fonksiyonları sonlandırır (bureturndeyiminden dönen değer üreteçlerde bize ulaşmaz).
Bu durumnextfonksiyonununStopIterationyükseltmesine neden olur.fordöngüsü bu hatayı yakalar ve üretecimizin bittiğini anlar:

```python
def fibonacci():
 x = 1
 y = 0
 z = 0
 while True:
 z = y
 y = x
 x = y + z
 yield x
 if x > 100:
 return

>>> for i in fibonacci():
 print(i)

1
2
3
5
8
13
21
34
55
89
144
>>>

```

Gördüğünüz gibi üretecimiz100’den büyük bir tane daha değer yazıp durdu. Tabii burada
fazladan birifkullanmak yerine bu şartıwhile’dan sonra da yazabilirdik:

```python
def fibonacci():
 x = 1
 y = 0
 z = 0
 while not x > 100:
 z = y
 y = x
 x = y + z
 yield x

```

Burada daxdeğişkeni100’den büyük olduğunda döngümüz bitiyor ve başka kodumuz kalmadığımız için
fonksiyon sonlanıyor. Zaten bir fonksiyonun sonuna ulaşıldığında da biz bir değer döndürmediysek deNonedeğeri döndürülecektir.

Son olarak parametre alan basit bir üreteç örneği yaparak bir sonraki konuya geçelim.
Unutmayalım ki üreteçler de bir çeşit fonksiyon olduğu için fonksiyon tanımlarken yapabildiğimiz
her şeyi üreteç tanımlarken de kullanabiliriz. Buna parametre vermek ve iç içe
fonksiyonlar oluşturmak da dahildir.

Üretecimiz birsayıparametresi alacak ve osayıdefa ekrana yazı yazdıracak:

```python
def yaz(sayı):
 for i in range(sayı):
 print("Merhaba Dünya!")
 yield

y = yaz(4)
for i in y:
 print(i)

```

Kodun çıktısı:

```python
Merhaba Dünya!
Merhaba Dünya!
Merhaba Dünya!
Merhaba Dünya!

```

##### ‘yield from’ Deyimi

yieldfromdeyimi bir üretecin içinde, başka bir üretecinyieldile
döndüreceği değerleri tekraryieldetmek istediğimizde kullanılabilir.
Şöyle bir örnek verelim:

```python
def üreteç1():
 yield "üreteç1 başladı"
 yield "üreteç1 bitti"

def üreteç2():
 yield "üreteç2 başladı"
 yield from üreteç1()
 yield "üreteç2 bitti"

>>> for i in üreteç2():
 print(i)

üreteç2 başladı
üreteç1 başladı
üreteç1 bitti
üreteç2 bitti
>>>

```

Aslındayieldfromile yazdığımız bu örnek şu kod ile eşdeğerdir:

```python
def üreteç1():
 yield "üreteç1 başladı"
 yield "üreteç1 bitti"

def üreteç2():
 yield "üreteç2 başladı"
 for i in üreteç1():
 yield i
 yield "üreteç2 bitti"

>>> for i in üreteç2():
 print(i)

üreteç2 başladı
üreteç1 başladı
üreteç1 bitti
üreteç2 bitti
>>>

```

Yani:

```python
yield from bir_üreteç

```

ifadesi bu ifade eş değerdir:

```python
for i in bir_üreteç:
 yield i

```

#### Liste ve Sözlük Üreteçleri Hakkında

Üreteçler konusunun başında söylediğimiz şu bilgiyi tekrarlayarak konumuza başlayalım:

Biz üreteçlerle az çok tanışıyoruz. Liste üreteçleri olsun, sözlük üreteçleri
olsun bu konu hakkında bir şeyler öğrenmiştik. Ancak biz üreteçlerimizi hep
şunun gibi tanımlamıştık:

```python
>>> listem = [i for i in range(10)]
>>> listem
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Dikkat ederseniz buradaiforiinrange(10)kısmı (nasıllambdafonksiyonlar normal yolla tanımlanan fonksiyonlardan farklı bir söz dizimi kullanıyorsa) normal kodlardan biraz farklı bir söz dizimi kullanıyor. Bu söz dizimi ile karmaşık
algoritmalar oluşturmak zordur, çoğunlukla da mümkün değildir. Zaten bunun bulunma sebebi
karmaşık algoritmalarda kullanılması değil, kısa işlerde yazım kolaylığı sağlamasıdır.
Yani bu yazım şekli, bazı fonksiyonlarınlambdaolarak tanımlanması gibi,
üreteç tanımlamanın sadece kısa bir yoludur. Peki aslında üreteçler nasıl
tanımlanır? Şimdi gelin bu konuyu inceleyelim.

Biz önceden üreteçleri şu şekilde kullanmayı biliyorduk:

```python
>>> listem = [i for i in range(10)]
>>> listem
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Peki üreteç bu kodun neresinde? Aslında bu yazım oldukça kısaltılmış, yani kolaylaştırılmış
bir yazım şeklidir. Biraz açacak olursak şunu elde ederiz:

```python
>>> üreteç = (i for i in range(10))
>>> type(üreteç)
<class 'generator'>
>>> listem = list(üreteç)
>>> listem
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Şimdilik liste kısmını bir kenara koyarak üreteç kısmı ile ilgilenelim.

Gördüğünüz gibi aslında şu yazım şekli:

```python
>>> üreteç = (i for i in range(10))

```

Bunun için bir kısaltmadır:

```python
def üreteç_fonksiyonu():
 for i in range(10):
 yield i

üreteç = üreteç_fonksiyonu()

```

Aynılambdafonksiyonların normal fonksiyonlar için bir kısaltma olması gibi.

Ancak şuraya dikkat etmek lazım ki:

```python
üreteç = (i for i in range(10))

```

Yazdığımızda, elimizde çağırıldığında bize üreteç döndürecek bir fonksiyonumuz yok.
Yaniüreteçdeğişkenimizgeneratortüründe bir nesne ve tek kullanımlık.
Sonuçta üreteçlerin yinelenmesi bir defa bittikten sonra bir daha kullanamayız, çünkü bir defa bittikten sonra hepStopIterationhatası yükseltirler. Eğer istersek yenisini oluşturabiliriz.üreteçdeğişkenimizin yinelenmesi bir defa tamamlandıktan sonra daha fazla onu kullanamayacağımızı şu şekilde görebiliriz:

```python
>>> üreteç = (i for i in range(5))
>>> for i in üreteç:
 print(i)
0
1
2
3
4
>>> for i in üreteç:
 print(i)

>>>

```

Gördüğünüz gibiüreteçdeğişkenimizi bir defafordöngüsü ile kullandığımızda
ikinci defa kullanamamaktayız. Çünkü ilk döngüde üretecimiz bitene kadar çalıştı
ve en sonundaStopIterationyükseltti. Artık istediğimiz kadar üretecimizi
kullanmayı deneyelim,StopIterationyükseltmeye devam edecektir (unutmayalım kifordöngüsüStopIterationhatalarını yakalar ve yakaladığında da çalışmayı bırakır)

```python
>>> üreteç = (i for i in range(3))
>>> next(üreteç)
0
>>> next(üreteç)
1
>>> next(üreteç)
2
>>> next(üreteç)
StopIteration
>>> next(üreteç)
StopIteration

```

Aynı şey normal yoldan tanımlanan üreteçler için de geçerlidir:

```python
def üreteç_fonksiyonu():
 for i in range(3):
 yield i

>>> üreteç = üreteç_fonksiyonu()
>>> next(üreteç)
0
>>> next(üreteç)
1
>>> next(üreteç)
2
>>> next(üreteç)
StopIteration
>>> next(üreteç)
StopIteration

```

Buradaki fark üretecimizi bize veren fonksiyonumuz durduğu için yeni bir üreteç oluşturabiliyor
olmamızdır:

```python
>>> üreteç2 = üreteç_fonksiyonu()
>>> next(üreteç2)
0

```

Ancak şu şekilde bir tanımlama yaptığımızda:

```python
>>> üreteç = (i for i in range(3))
>>> type(üreteç)
<class 'generator'>

```

Burada elde ettiğimiz üretecin kendisi oluyor, ve bu üreteç de tek kullanımlık. Şimdi
bunların liste üreteçleri ile alakasına geri dönecek olursak:

```python
>>> üreteç = üreteç_fonksiyonu()
>>> listem = list(üreteç)
>>> listem
[0, 1, 2]

```

Gördüğünüz gibi aslında normal yoldan tanımlanmış üreteçler, yaniyieldifadesi kullanılarak fonksiyon gibi tanımlanmış üreteçler, delistfonksiyonuna argüman olarak verilebilir. Aynıfordöngüsünde kullanılabilmesi gibi. Çünkü -kendi geliştirme arayüzünüzü kullanarak
görebilirsiniz- dikkat edersinizlistfonksiyonunun ilk parametresinin adıiterable’dır.
Türkçe’ye çevirirsekyinelenebilir. Biz zaten üreteçlerin yinelenebilir nesnelere örnek olduğunu
söylemiştik. Bu yüzden bütün üreteçlerilistfonksiyonunu kullanarak bir listeye çevirebiliriz.
Buna şu şekilde tanımlanan üreteçler de dahildir:

```python
>>> üreteç = (i for i in range(3))

```

Bu yüzden şu kod güzel bir şekilde çalışmaktadır:

```python
>>> üreteç = (i for i in range(3))
>>> list(üreteç)
[0, 1, 2]

```

Ve şu yazım da yukarıda yazdığımızın daha da kısaltılmış halinden başka bir şey değildir:

```python
>>> listem = [i for i in range(3)]

```

Anlattıklarımız sözlük üreteçleri için de geçerlidir. Dikkat edersiniz kısa yoldan üreteç
tanımlamaları(iforiinrange(3))şeklinde, liste tanımlamaları[iforiinrange(3)]şeklinde
ve sözlük tanımlamaları da{str(i):iforiinrange(3)}şeklinde yapılmaktadır. Bu liste tanımlamasını:

```python
>>> üreteç = (i for i in range(3))
>>> listem = list(üreteç)

```

Şu şekilde yazabileceğimiz gibi:

```python
>>> üreteç = (i for i in range(3))
>>> listem = []
>>> for i in üreteç:
 listem.append(i)

```

Bu sözlük tanımlamasını da:

```python
>>> üreteç = ((str(i),i) for i in range(3))
>>> sözlük = dict(üreteç)

```

Şu şekilde yazabilirdik:

```python
>>> üreteç = ((str(i),i) for i in range(3))
>>> sözlük = {}
>>> for key,value in üreteç:
 sözlük[key] = value

```

Son örneğimizde üretecimiz her yinelenişinde iki elemanlı birtupledöndürüyor ve
bu demetin ilk elemanıfordöngüsü içindekeydeğişkenine, ikinci elemanı isevaluedeğişkenine atanıyor. Şunun gibi de düşünebilirsiniz:

```python
>>> for key,value in (('0',0), ('1',1), ('2',2)):
 sözlük[key] = value

```

Evet, artık üreteçler konusunda da kayda değer bilgiler öğrendiğimize göre bir sonraki konumuza geçelim.

## Modüller

Bu bölümde, geçen derste ayrıntılı olarak incelediğimiz ‘Fonksiyonlar’ kadar
önemli bir konuyu ele alacağız. Bu önemli konunun adı ‘modüller’.

Biz şimdiye kadar modül konusunu hiç ayrıntılı olarak ele almamış olsak da
esasında siz modül kavramına büsbütün yabancı sayılmazsınız. Zira biz önceki
derslerimizde zaman zaman modüllerden söz etmiş, hatta yeri geldiğinde bunları
kodlarımız içinde kullanmaktan da çekinmemiştik.

Bu konuya gelene kadar, çeşitli bölümlerde şu modüllerden bahsettiğimizi
hatırlıyorsunuzdur:
- sys
- os
- keyword
- random
- unicodedata
- locale

sys

os

keyword

random

unicodedata

locale

İşte şimdi, daha önce farklı bölümlerde şöyle bir temas edip geçtiğimiz modüller
konusunu bu bölümde derinlemesine incelemeye çalışacağız.

### Modül Nedir?

Dediğimiz gibi, bu bölümde Python’daki en önemli konulardan biri olan
modüllerden söz edeceğiz. Ancak modülleri kullanabilmek için elbette öncelikle
‘modül’ denen şeyin ne olduğunu iyice bir anlamamız gerekiyor. Peki, nedir bu
modül denen şey?

Bu soruyu, şimdiye kadar gördüğümüz modüllere bakarak cevaplayacak olursak,
modüllerin, bazı işlevleri kolaylıkla yerine getirmemizi sağlayan birtakım
fonksiyonları ve nitelikleri içinde barındıran araçlar olduğunu söyleyebiliriz.

Mesela ‘Kümeler ve Dondurulmuş Kümeler’ adlı bölümderandomadlı bir modüle
değindiğimizi hatırlıyor olmalısınız. Orada bu modülle ilgili şöyle bir örnek
vermiştik:

```python
liste = [random.randint(0, 10000) for i in range(1000)]

```

Bu örnekte,randomadlı modülün içindekirandint()adlı faydalı bir
fonksiyondan yararlanarak 0 ile 10.000 sayıları arasında 1000 adet rastgele sayı
içeren bir liste oluşturmuştuk. Dolayısıyla, yukarıdaki tanımda da belirttiğimiz
gibi, bir modül olanrandom, örnekte bahsettiğimiz işlevi kolaylıkla yerine
getirmemizi sağlayan bir fonksiyon barındırıyor. Biz de bu fonksiyonu kullanarak
amacımızı rahatlıkla yerine getirebiliyoruz.

randommodülünün dışında, önceki derslerimizde şöyle bir değinip geçtiğimiz,sys,osvelocalegibi modüllerin de çeşitli görevleri kolayca
yerine getirmemizi sağlayan birtakım araçlar barındırdığını görmüştük.

İşin doğrusu, modül denen şey Python programlama dilinin bel kemiğidir. Eğer
modüller olmasaydı, Python programlama dili hem çok kullanışsız bir dil olurdu,
hem de modüller sayesinde çok kolay bir şekilde üstesinden gelebildiğimiz
zorluklar için her defasında kendimiz yeniden bir çözüm icat etmek zorunda
kalırdık.

Belki bu iddialı laf size şu anda pek anlamlı gelmemiş olabilir. Şu ana kadar
modüllerle ilgili öğrendikleriniz, henüz zihninizde bu lafın iddiasını teyit
etmiyor olabilir. Ama modüllerin neden bu kadar önemli olduğunu birazdan çok
daha net bir şekilde anlayacaksınız. Şimdilik okumaya devam edin.

Hatırlarsanız bir önceki bölümde Python’daki fonksiyonlardan bahsetmiştik. Yine
hatırlarsanız o bölümde pek çok örnek fonksiyon da tanımlamıştık. Meselakayıt_oluştur()adlı şöyle bir fonksiyon tanımladığımızı hatırlıyor
olmalısınız:

```python
def kayıt_oluştur(isim, soyisim, işsis, şehir):
 print("-"*30)

 print("isim : ", isim)
 print("soyisim : ", soyisim)
 print("işletim sistemi: ", işsis)
 print("şehir : ", şehir)

 print("-"*30)

```

Bu fonksiyonu bir kez tanımladıktan sonra, bu fonksiyonu aynı program içinde
istediğimiz kadar kullanabiliyoruz. Yanikayıt_oluşturadlı bir fonksiyon
tanımlamış olmamız sayesinde, bu fonksiyonun gövdesinde belirttiğimiz işlemleri
her defasında tekrar tekrar yapmak zorunda kalmıyoruz; bütün bu işlemleri tek
bir ‘kayıt_oluştur’ ismine atamış olduğumuz için, bu fonksiyonun bize sunduğu
işleve ihtiyaç duyduğumuz her yerde bu fonksiyonu kullanabiliyoruz. Örneğin:

```python
kayıt_oluştur('Fırat', 'Özgül', 'Debian', 'Arsuz')

```

Ya da:

```python
kayıt_oluştur('Zerrin', 'Söz', 'Ubuntu', 'Bolvadin')

```

Eğer yukarıdaki işlevselliği bir fonksiyon olarak tanımlamış olmasaydık,kayıt_oluştur('Fırat','Özgül','Debian','Arsuz')kodunun verdiği çıktıyı
elde etmek için şu kodları yazmak zorunda kalacaktık:

```python
print("-"*30)

print("isim : ", "Fırat")
print("soyisim : ", "Özgül")
print("işletim sistemi: ", "Debian")
print("şehir : ", "Arsuz")

print("-"*30)

```

Burada isim, soyisim, işletim sistemi ve şehir bilgileri değiştiğinde de her
defasında aynı şeyleri uzun uzadıya tekrar tekrar yazmamız gerekecekti:

```python
print("-"*30)

print("isim : ", "Zerrin")
print("soyisim : ", "Söz")
print("işletim sistemi: ", "Ubuntu")
print("şehir : ", "Bolvadin")

print("-"*30)

```

İşte modüller de buna benzer bir vazife görür. Yani Python’ın fonksiyon sistemi
nasıl bize bir işlevselliğiaynı dosya içindetekrar tekrar kullanma imkanı
veriyorsa, modül sistemi de bir fonksiyonufarklı dosyalar ve programlar
içindetekrar tekrar kullanma imkanı verir.

Dolayısıyla, eğer modül sistemi olmasaydı, biz bir kez yazdığımız (veya başka
bir Python programcısı tarafından yazılmış)kayıt_oluştur()fonksiyonunu
başka bir programda da kullanmak istediğimizde, bu fonksiyonu alıp her defasında
yeni programa elle kopyalamak zorunda kalırdık. Ama modül sistemi sayesinde, bir
program içinde bulunan fonksiyonları (ve diğer nitelikleri) başka Python
programları içine ‘aktarabiliyoruz’. Böylece bir Python programındaki (veya
modülündeki) işlevsellikten, başka bir Python programında da yararlanabiliyoruz.
Dolayısıyla modüller sayesinde, bir kez yazdığımız kodları pek çok farklı
program içinde kullanma imkanı elde ediyoruz. Bu da bizim;
- Daha az kod yazmamızı,
- Bir kez yazdığımız kodları tekrar tekrar kullanabilmemizi,
- Daha düzenli, daha derli toplu bir şekilde çalışabilmemizi

Daha az kod yazmamızı,

Bir kez yazdığımız kodları tekrar tekrar kullanabilmemizi,

Daha düzenli, daha derli toplu bir şekilde çalışabilmemizi

sağlıyor.

İşte bu bölümde, modüllerin bütün bu işlevleri nasıl yerine getirdiğini, modül
denen şeyden nasıl faydalanabileceğimizi ve modüllerin neden bu kadar önemli
olduğunu öğreneceğiz. Dilerseniz lafı daha fazla dolandırmadan modüller konusuna
hızlı bir giriş yapalım.

### Hazır Modüller

Hatırlarsanız, Python’da iki farklı fonksiyon türü olduğundan söz etmiştik:
1. Kendi tanımladığımız fonksiyonlar
1. Gömülü (‘built-in’) fonksiyonlar

Kendi tanımladığımız fonksiyonlar

Gömülü (‘built-in’) fonksiyonlar

Aynı şekilde modüller de iki farklı başlık altında incelenebilir:
1. Kendi tanımladığımız modüller
1. Hazır modüller

Kendi tanımladığımız modüller

Hazır modüller

Biz burada öncelikle hazır modülleri ele alacağız. Bu şekilde modül kavramını
iyice anladıktan sonra da kendi modüllerimizi nasıl yazacağımızı öğreneceğiz.

Hazır modüller, Python geliştiricilerinin veya bizim dışımızdaki Python
programcılarının yazıp hizmetimize sunduğu modüllerdir.

Hazır modüller de kendi içinde ikiye ayrılabilir:
1. Standart Kütüphane Modülleri
1. Üçüncü Şahıs Modülleri

Standart Kütüphane Modülleri

Üçüncü Şahıs Modülleri

Standart Kütüphane Modülleri, doğrudan Python geliştiricileri tarafından yazılıp
dile kaynaştırılmış modüllerdir. Bu yönüyle bu modüller daha önce öğrendiğimiz
gömülü fonksiyonlara çok benzer. Tıpkı gömülü fonksiyonlarda olduğu gibi,
Standart Kütüphane Modülleri de her an emrimize amadedir. Biz bunları
istediğimiz her an, herhangi bir ek yazılım kurmak zorunda kalmadan, kendi
programlarımız içinde kullanabiliriz.

> **Ayrıca bakınız**
> Python’ın Standart Kütüphanesi içinde hangi modüllerin olduğunuhttps://docs.python.org/3/library/adresinden inceleyebilirsiniz.

Ayrıca bakınız

Python’ın Standart Kütüphanesi içinde hangi modüllerin olduğunuhttps://docs.python.org/3/library/adresinden inceleyebilirsiniz.

Standart Kütüphane içinde, Python ile programlama yaparken işlerinizi bir hayli
kolaylaştıracak pek çok modül bulacaksınız.

Başta da söylediğimiz gibi, biz bu bölüme gelinceye kadar üstünkörü de olsa
modüllerden söz etmiştik. Örneğin önceki derslerimizde andığımızsys,os,randomve benzeri modüller hep birer Standart Kütüphane modülüdür.
Dolayısıyla bu modüllerin sunduğu işlevsellikten kendi programlarımızda
istediğimiz her an yararlanabiliriz.

### Modüllerin İçe Aktarılması

Python’da herhangi bir modülü kullanabilmek için öncelikle onu ‘içe aktarmamız’
gerekir. İçe aktarmak, bir modül içindeki fonksiyon ve nitelikleri başka bir
program (veya ortam) içinden kullanılabilir hale getirmek demektir. İsterseniz
bu soyut tanımlamayı bir örnek ile somutlaştıralım. Mesela, bir Standart
Kütüphane modülü olduğunu öğrendiğimiz ve önceki derslerimizde de değindiğimizosadlı modülü içe aktaralım. Bunun için öncelikle etkileşimli kabuğu
çalıştıralım ve şu komutu verelim:

```python
>>> import os

```

Böyleceosadlı modülü içe aktarmış, yani bu modül içindeki fonksiyon ve
nitelikleri kullanılabilir hale getirmiş olduk.

Hatırlarsanız ‘modül’ kavramını tanımlarken, bunların bize birtakım yararlı
fonksiyonlar ve nitelikler sunan araçlar olduğunu söylemiştik. İşte, mesela buosmodülünün bize hangi yararlı fonksiyonları ve nitelikleri sunduğunu
öğrenmek içindir()fonksiyonunu kullanabiliriz:

```python
>>> dir(os)

```

Gördüğünüz gibi bu modül pek çok fonksiyon ve nitelik barındırıyor.

Bu modüle adını verenoskelimesioperating system(işletim sistemi)
ifadesinin kısaltmasıdır. Bu modül, kullandığımız işletim sistemine ilişkin
işlemler yapabilmemiz için bize çeşitli fonksiyonlar ve nitelikler sunar. Hemen
bir örnek verelim.

Diyelim ki bir program yazdınız. Ancak yazdığınız bu programın yalnızca Windows
işletim sisteminde çalışmasını istiyorsunuz. Buna göre, eğer programınız Windows
işletim sistemi kurulu bir bilgisayarda çalıştırılırsa programınızın normal bir
şekilde başlamasını, ama eğer Windows dışı bir işletim sisteminde çalıştırılırsa
da kullanıcıya bir uyarı mesajı verilmesini istiyorsunuz.

İşte bunun içinosmodülünden yararlanabilirsiniz. Şimdidir(os)komutuyla elde ettiğimiz listeye bakalım. Oradanameadlı bir nitelik olduğunu
göreceksiniz. Bu nitelik, bize kodlarımızın hangi işletim sisteminde çalıştığını
gösterir. Dolayısıyla da yukarıda tarif ettiğimiz iş için gayet uygun bir
araçtır.

Öncedenimportoskomutuylaosmodülünü içe aktarmış olduğumuzu
varsayarsak, modülün bu niteliğini şöyle kullanıyoruz:

```python
>>> os.name

'posix'

```

osadlı modülün içindekinameniteliğine nasıl eriştiğimize çok dikkat
edin. Önce modülümüzün adı olan ‘os’u yazıyoruz. Ardından bir nokta işareti
koyup, ihtiyacımız olan niteliğin adını belirtiyoruz. Yani şöyle bir formül
takip ediyoruz:

```python
modül_adı.fonksiyon_veya_nitelik

```

os.namekomutu, kullandığınız işletim sistemine bağlı olarak farklı çıktılar
verir. Eğer bu komutu bir GNU/Linux dağıtımında veya bir Mac bilgisayarda
verirsek yukarıdaki gibi ‘posix’ çıktısı alırız. Ama eğer aynı komutu Windows’ta
verirsek ‘nt’ çıktısı alırız. Dolayısıylaosmodülününnameniteliğini
kullanarak, yazdığımız bir programın hangi işletim sisteminde çalıştığını
denetleyebiliriz:

```python
>>> if os.name != 'nt':
... print('Kusura bakmayın! Bu programı yalnızca',
... 'Windows\'ta kullanabilirsiniz!')
... else:
... print('Hoşgeldin Windows kullanıcısı!')

```

Etkileşimli kabukta yazdığımız bu programı gelin bir de bir metin dosyasına
kaydedelim. Zira biz henüz modülleri öğrenme aşamasında olduğumuz için şimdilik
bunları etkileşimli kabukta test ediyor olsak da, gerçek hayatta programlarımızı
etkileşimli kabuğa değil, program dosyaları içine yazacağız.

Yukarıdaki kodları bir dosyaya kaydettiğimizde programımız şöyle görünür:

```python
import os

if os.name != 'nt':
 print('Kusura bakmayın! Bu programı yalnızca',
 'Windows\'ta kullanabilirsiniz!')
else:
 print('Hoşgeldin Windows kullanıcısı!')

```

Gördüğünüz gibi, programımızı kaydederken, programımızın en başınaimportoskomutunu yazarak öncelikle ilgili modülü içe aktarıyoruz. Python’da modüller
genellikle programın en başında içe aktarılır. Ama bu bir zorunluluk değildir.
Modülleri programın istediğiniz her yerinde içe aktarabilirsiniz (bununla ilgili
bir istisnadan biraz sonra söz edeceğiz).

Modül içe aktarmaya ilişkin en önemli kural, modüle ait bir nitelik veya
fonksiyonun kullanılmasından önce modülün içe aktarılmış olması gerekliliğidir.
Yani mesela yukarıdaki programdaosmodülü içindekinameniteliğini
kullanmadan önceosmodülünü içe aktarmış olmamız gerekir. Eğer Python,ifos.name!='nt':satırından önce herhangi bir yerdeimportosgibi bir
komutlaosmodülünün içe aktarıldığını göremezse hata verecektir.

Bu programı yukarıdaki gibi bir dosyaya kaydettikten sonra bunu herhangi bir
Python programı gibi çalıştırabilirsiniz.

Eğer bu programı Windows dışındaki bir işletim sisteminde çalıştırırsanız şu
çıktıyı alırsınız:

```python
Kusura bakmayın! Bu programı yalnızca
Windows'ta kullanabilirsiniz!

```

Ama eğer bu program Windows işletim sisteminde çalıştırılırsa şu çıktıyı verir:

```python
Hoşgeldin Windows kullanıcısı!

```

Böylece modül içindeki bir niteliğe erişmiş olduk. Yalnız burada asla
unutmamamız gereken şey, öncelikle kullanacağımız modülüimportmodül_adıkomutuyla içe aktarmak olacaktır. Modülü içe aktarmazsak tabii ki o modüldeki
fonksiyon veya niteliklere de erişemeyiz. (Sık yapılan bir hata olduğu için,
bunu tekrar tekrar vurguluyoruz…)

Bu arada bir modülü, her etkileşimli kabuk oturumunda yalnızca bir kez içe
aktarmak yeterlidir. Yani siz etkileşimli kabuğu çalıştırdıktan sonra bir kezimportoskomutuyla modülü içe aktardıktan sonra, o etkileşimli kabuk
oturumunu kapatana kadar, aynı modülü tekrar içe aktarmak zorunda kalmadan bu
modülün içeriğini kullanabilirsiniz.

Aynı şekilde, eğer bu kodları etkileşimli kabuğa değil de bir program dosyasına
yazıyorsanız,importoskomutunu dosyanın başına bir kez yazdıktan sonra
aynı modülü programın ilerleyen kısımlarında tekrar içe aktarmak zorunda
kalmadan, o modülünün içeriğinden yararlanabilirsiniz.

Gördüğünüz gibi, bir Standart Kütüphane Modülü olanosbizenameadlı çok
kullanışlı bir nitelik sunuyor. Eğerosmodülü olmasaydı,nameadlı
niteliğin sunduğu işlevi kendimiz icat etmek zorunda kalırdık.

Başka bir örnek daha verelim…

Diyelim ki yine bir program yazdınız. Programınızın çalışması için, programınızı
kullanan kişinin bilgisayarında birtakım dizinler oluşturmanız gerekiyor. İşte
bu iş için deosmodülünden yararlanabilirsiniz.

Bu modül içindekimakedirs()fonksiyonunu kullanarak, o anda içinde
bulunduğunuz dizinde yeni bir dizin oluşturabilirsiniz:

```python
>>> os.makedirs('DATA')

```

Bu komutu verdikten sonra, o anda altında bulunduğunuz dizindeDATAadlı bir
dizin oluşacaktır. Eğer o anda hangi dizin altında bulunduğunuzu öğrenmek
isterseniz de yineosmodülünden faydalanabilirsiniz:

```python
>>> os.getcwd()

```

osmodülününgetcwd()fonksiyonu bize o anda hangi dizin altında
bulunduğumuzu gösterir. Bu komutun çıktısında hangi dizin adını görüyorsanız,
biraz öncemakedirs()fonksiyonu ile oluşturduğunuzDATAdizini de o dizin
altında oluşmuştur…

Gördüğünüz gibi, bir çırpıdaosmodülünün birkaç özelliğinden birden
yararlandık. Daha önce de söylediğimiz gibi, eğerosmodülü olmasaydı
yukarıda gerçekleştirdiğimiz bütün işlevleri kendiniz icat etmek zorunda
kalırdınız.

Böylece Python’daki modüllerin neye benzediğini ve nasıl kullanıldığını anlamış
olduk. Modüllerin faydalı araçlar olduğu konusunda sizleri ikna edebilmiş
olduğumuzu varsayarak bir sonraki bölüme geçelim.

#### Farklı İçe Aktarma Yöntemleri

Biz şimdiye kadar, modülleriimportmodül_adışeklinde içe aktardık.
Esasında standart içe aktarma yöntemi de budur. Bir modülü bu şekilde içe
aktardığımız zaman, modül adını kullanarak, o modülün içeriğine erişebiliriz:

```python
>>> import sys
>>> sys.version #Python'ın sürümünü verir

```

veya:

```python
>>> import os
>>> os.name #İşletim sistemimizin adını verir

```

gibi…

Ancak Python’da bir modülü içe aktarmanın tek yöntemi bu değildir. Eğer istersek
modülleri daha farklı şekillerde de içe aktarabiliriz.

Gelin şimdi bu alternatif modül aktarma biçimlerinin neler olduğunu görelim.

##### import modül_adı as farklı_isim

Bazı koşullar, bir modülü kendi adıyla değil de başka bir isimle içe aktarmanızı
gerektirebilir. Ya da siz bir modülü kendi adı dışında bir adla içe aktarmanın
daha iyi bir fikir olduğunu düşünebilirsiniz.

Peki ama ne tür koşullar bir modülü farklı bir adla içe aktarmamızı
gerektirebilir veya biz hangi sebeple bir modülü farklı adla içe aktarmayı
isteyebiliriz?

Bu soruların cevabını verebilmek için, gelin istersenizsubprocessadlı bir
Standart Kütüphane modülünden yararlanalım. Hem bu vesileyle yeni bir modül de
öğrenmiş oluruz…

> **Not**
> subprocessmodülü, harici komutları Python içinden
çalıştırabilmemizi sağlayan oldukça faydalı bir araçtır. Bu modülü kullanarak
Python programlarımızın içinden başka programları çalıştırabiliriz.

Not

subprocessmodülü, harici komutları Python içinden
çalıştırabilmemizi sağlayan oldukça faydalı bir araçtır. Bu modülü kullanarak
Python programlarımızın içinden başka programları çalıştırabiliriz.

Bir modülün içindeki fonksiyon ve nitelikleri her kullanmak isteyişimizde, o
fonksiyon veya niteliğin başına modül adını da eklememiz gerektiğini artık gayet
iyi biliyorsunuz. Örneğinsubprocessadlı modülü

```python
>>> import subprocess

```

komutuyla içe aktardıktan sonra, bu modül içindeki herhangi bir fonksiyon veya
niteliği kullanabilmenin birinci şartı, modül adını ilgili fonksiyon veya
niteliğin önüne getirmektir. Mesela bizsubprocessmodülününcall()adlı
fonksiyonunu kullanmak istersek, şöyle bir kod yazmamız gerekir:

```python
>>> subprocess.call('notepad.exe')

```

Bu şekilde ‘Notepad’ programını Python içinden çalıştırmış olduk.

Ancak gördüğünüz gibi, ‘subprocess’ biraz uzun bir kelime. Bu modülü her
kullanmak isteyişinizde nitelik veya fonksiyon adının önüne bu uzun kelimeyi
getirmek bir süre sonra sıkıcı bir hal alabilir. Bu yüzden eğer isterseniz
modülüimportsubprocessşeklinde kendi adıyla değil de daha kısa bir adla
içe aktarmayı tercih edebilirsiniz:

```python
>>> import subprocess as sp

```

Burada şöyle bir formül uyguladığımıza dikkat edin:

```python
>>> import modül_adı as farklı_bir_isim

```

Böylece artık bu modülü yalnızcaspönekiyle kullanabilirsiniz:

```python
>>> sp.call('notepad.exe')

```

Örnek olması açısından başka bir modülü daha ele alalım. Modülümüzün adıwebbrowser.

> **Not**
> webbrowsermodülü, bilgisayarımızda kurulu internet tarayıcısını
kullanarak internet sitelerini açabilmemizi sağlar.

Not

webbrowsermodülü, bilgisayarımızda kurulu internet tarayıcısını
kullanarak internet sitelerini açabilmemizi sağlar.

Tıpkı ‘subprocess’ gibi, ‘webbrowser’ kelimesi de, her defasında tekrar etmesi
sıkıcı olabilecek bir kelime. Dolayısıyla dilerseniz bu modülüimportwebbrowseryerine farklı bir isimle içe aktarabilirsiniz. Örneğin:

```python
>>> import webbrowser as br

```

veya:

```python
>>> import webbrowser as web

```

Modülü hangi adla içe aktaracağınız tamamen size kalmış. Diyelim ki bu modülü
‘web’ adıyla içe aktardık. Artık bu modülün içindeki araçlarıwebönekiyle
kullanabiliriz:

```python
>>> web.open('www.istihza.com')

```

> **Uyarı**
> Bazı GNU/Linux dağıtımlarında websitesi adresini ‘http’ önekiyle
birlikte belirtmeniz gerekebilir. Örn.web.open('http://www.istihza.com').

Uyarı

Bazı GNU/Linux dağıtımlarında websitesi adresini ‘http’ önekiyle
birlikte belirtmeniz gerekebilir. Örn.web.open('http://www.istihza.com').

Bu kod, bilgisayarımızdaki öntanımlı web tarayıcısı hangisiyse onu çalıştıracak
ve bizi, parantez içinde gösterilen web sayfasına götürecektir.

Eğer bizwebbrowsermodülünü doğrudan kendi adıyla içe aktarsaydık:

```python
>>> import webbrowser

```

Bu durumda yukarıdaki komutu şu şekilde vermek zorunda kalacaktık:

```python
>>> webbrowser.open('www.istihza.com')

```

Ama bu modülü daha kısa bir adla içe aktarmış olmamız sayesinde, bu modülü gayet
pratik bir şekilde kullanma imkanına kavuşuyoruz.

##### from modül_adı import isim1, isim2

Şimdiye kadar verdiğimiz örneklerden de gördüğünüz gibi, Standart Kütüphane
Modülleri’nin içinde çok sayıda fonksiyon ve nitelik bulunuyor. Meselaosmodülünü ele alalım:

```python
>>> import os
>>> dir(os)

```

Listede epey isim var…

Bizimportoskomutunu verdiğimizde, listedeki bütün o isimleri ‘os’ ismi
altında içe aktarmış oluyoruz. Bunun bir sakıncası yok, ancak yazdığımız
programlarda bu fonksiyon ve niteliklerin hepsine ihtiyaç duymayız. O yüzden,
eğer arzu ederseniz,importosgibi bir komutla bütün o isimleri içe
aktarmak yerine, yalnızca kullanacağınız isimleri içe aktarmayı tercih de
edebilirsiniz. Meselaosmodülünün yalnızcanameniteliğini
kullanacaksanız, modülü şu şekilde içe aktarabilirsiniz:

```python
>>> from os import name

```

Bu şekildeosmodülünden yalnızcanameismi içe aktarılmış olur ve
yalnızca bu ismi kullanabiliriz:

```python
>>> name

'posix'

```

Bu durumdaos.namekomutu hata verecektir:

```python
>>> os.name

NameError: name 'os' is not defined

```

Çünkü bizfromosimportnamekomutunu verdiğimizde,osmodülünü değil,
bu modül içindeki bir nitelik olanname’i içe aktarmış oluyoruz. Dolayısıylaosismini kullanamıyoruz.

Bu şekilde, aynı modül içinden birkaç farklı nitelik ve fonksiyonu da içe
aktarabilirsiniz:

```python
>>> from os import name, listdir, getcwd

```

Bu komutlaosmodülü içinden yalnızcanameniteliğini,listdir()fonksiyonunu vegetcwd()fonksiyonunu aktarmış olduk:

```python
>>> listdir()

```

Bu fonksiyon, o anda içinde bulunduğumuz dizindeki dosyaları listeler.

namevegetcwd()isimlerinin görevini ise daha önce öğrenmiştik:

```python
>>> name

'nt'

>>> getcwd()

'C:\\Documents and Settings\\fozgul\\'

```

Gelelim bir başka modül aktarma biçimine…

##### from modül_adı import isim as farklı_isim

Bir modülü, kendi adından farklı bir adla nasıl içe aktarabileceğinizi
biliyorsunuz:

```python
import subprocess as sp

```

Bu şekildesubprocessmodülünüspadıyla içe aktarmış oluyoruz.

Aynı şekilde, bir modül içinden belli nitelik ve fonksiyonları da nasıl içe
aktaracağınızı biliyorsunuz:

```python
from os import path, listdir

```

Bu şekildeosmodülündenpathniteliğini velistdir()fonksiyonunu içe
aktarmış oluyoruz.

Peki ya bir modül içinden belli nitelik ve fonksiyonları farklı bir adla içe
aktarmak isterseniz ne yapacaksınız?

İşte Python size bunun için de bir yol sunar. Dikkatlice bakın:

```python
from os import path as p

```

veya:

```python
from os import listdir as ld

```

gibi…

Bu örneklerde,osmodülü içindenpathadlı niteliğipadıyla;listdir()fonksiyonunu iseldadıyla içe aktardık. Böylecepathniteliğinipadıyla;listdir()fonksiyonunu daldadıyla kullanabiliriz.

Yalnız bu yöntem çok sık kullanılmaz. Bunu da not edip, içe aktarma
yöntemlerinin sonuncusuna geçelim.

##### from modül_adı import *

Python’daki modüllerifrommodül_adıimport*formülüne göre içe aktarmak da
mümkündür (bu yönteme ‘yıldızlı içe aktarma’ diyebilirsiniz). Bu şekilde bir
modül içindeki bütün fonksiyon ve nitelikleri içe aktarmış oluruz (ismi_ile
başlayanlar hariç):

```python
>>> from sys import *

```

Böylecesysmodülü içindeki bütün fonksiyon ve nitelikleri, başlarına modül
adını eklemeye gerek olmadan kullanabiliriz:

```python
>>> version

```

Ancak bu yöntem pek tavsiye edilmez. Çünkü bu şekilde, modül içindeki bütün
isimleri kontrolsüz bir şekilde mevcut ortama ‘boşaltmış’ oluyoruz. Mesela eğer
modül bu şekilde içe aktarılmadan önceversiondiye başka bir değişken
tanımlamışsanız, modül içe aktarıldıktan sonra, önceden tanımladığınız buversiondeğişkeninin değeri kaybolacaktır:

```python
>>> version = '1.0'
>>> print(version)

1.0

```

Bu ortamafromsysimport*komutuylasysmodülünün bütün içeriğini
aktaralım:

```python
>>> from sys import *

```

Şimdi deversiondeğişkeninin değerini yazdıralım:

```python
>>> print(version)

```

Burada alacağımız çıktı şu olur:

```python
'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

Gördüğünüz gibi,sysmodülünün içindekiversionniteliği bizim önceden
tanımladığımızversiondeğişkeniyle çakıştı ve herhangi bir uyarı vermeden,
bizim tanımladığımızversiondeğerini silip kendiversiondeğerini
bizimkinin yerine geçirdi…

frommodül_adıimport*komutunun yaptığı şeyi, sıkıştırılmış bir klasörün
bütün içeriğini olduğu gibi masaüstüne atmaya benzetebilirsiniz. Böyle bir
durumda, eğer masaüstünde sıkıştırılmış klasördekilerle aynı adlı dosyalar
varsa, sıkıştırılmış klasör içindeki dosya adları, masaüstünde halihazırda
varolan dosya adlarıyla çakışacaktır.

Bir sonraki konuya geçmeden önce, yıldızlı içe aktarma ile ilgili önemli bir
noktaya değinelim.

Hatırlarsanız, bu konunun başında, modülleri programımızın her yerinden içe
aktarabileceğimizi söylemiştik. Mesela bir modülü, program dosyamızın en başında
içe aktarabiliriz:

```python
from os import *

```

Ama bunun bir istisnası var. Bir modülü yıldızlı olarak içe aktaracaksak, bu
işlemi lokal etki alanları içinden gerçekleştiremeyiz. Yani mesela bir
fonksiyonun lokal isim alanı içinde şöyle bir kod yazabiliriz:

```python
def fonksiyon():
 import os

```

Veya:

```python
def fonksiyon():
 import subprocess as sp

```

Ama şöyle bir kod yazamayız:

```python
def fonksiyon():
 from os import *

```

Bu kodları bir dosyaya kaydedip çalıştırdığımızda şuna benzer bir hata alırız:

```python
 File "falanca.py", line 1
 def fonksiyon():
SyntaxError: import * only allowed at module level

```

Bunun anlamı şu: Yıldızlı içe aktarma işlemleri ancak modül seviyesinde, yani
global isim alanında gerçekleştirilebilir. Dolayısıyla yukarıdaki içe aktarma
işlemini ancak fonksiyonun dışında gerçekleştirebiliriz:

```python
from os import *

def fonksiyon():
 pass

```

Veya:

```python
def fonksiyon():
 pass

from os import *

```

Bu istisnai duruma dikkat ediyoruz. Elbette modül içe aktarma işlemlerini
gerçekleştirmenin en sağlıklı yolu bütün modülleri program dosyasının en başında
içe aktarmaktır.

### Kendi Tanımladığımız Modüller

Buraya gelene kadar sadece Python’daki hazır modüllerden söz ettik. Hazır
modüllerin, ‘Standart Kütüphane Modülleri’ ve ‘Üçüncü Şahıs Modülleri’ olarak
ikiye ayrıldığını öğrenmiştiniz. Yukarıda bu hazır modüllerin ‘Standart
Kütüphane Modülleri’ adını verdiğimiz alt başlığını halihazırda ele aldık.
Dolayısıyla artık standart modüllerin neler olduğunu ve genel olarak bunların
nasıl kullanıldığını biliyoruz.

Hazır modül başlığı altında bir de ‘üçüncü şahıs modülleri’nin bulunduğunu da
söylemiştik. Birazdan üçüncü şahıs modüllerinden de söz edeceğiz. Ama isterseniz
ondan önce hazır modüllere bir ara verelim ve biraz da kendi modüllerimizi nasıl
yazabileceğimize bakalım. Kendi modüllerimizi yazmak, modül konusunu biraz daha
net bir şekilde anlamamızı sağlayacaktır.

#### Modüllerin Tanımlanması

Hatırlarsanız bu bölümün başında, ‘modül nedir?’ sorusuna şu cevabı vermiştik:

Bazı işlevleri kolaylıkla yerine getirmemizi sağlayan birtakım
fonksiyonları ve nitelikleri içinde barındıran araçlar…

Esasında Python’daki modülleri şöyle de tanımlayabiliriz:

Diyelim ki bir program yazıyorsunuz. Yazdığınız bu programın içinde
karakter dizileri, sayılar, değişkenler, listeler, demetler, sözlükler ve
fonksiyonlar var. Programınız da .py uzantılı bir metin dosyası içinde yer
alıyor. İşte bütün bu öğeleri ve veri tiplerini içeren .py uzantılı dosyaya
‘modül’ adı verilir. Yani şimdiye kadar yazdığınız ve yazacağınız bütün
Python programları aynı zamanda birer modül adayıdır.

Gelin isterseniz yukarıdaki bu tanımın doğruluğunu test edelim.

Şimdi Python’ın etkileşimli kabuğunu çalıştırın ve kütüphane modüllerinden biri
olanosmodülünü içe aktarın:

```python
>>> import os

```

dir(os)komutunu kullanarak modülün içeriğini kontrol ettiğinizde, o listede__file__adlı bir niteliğin olduğunu göreceksiniz. Bu nitelik Python ile
yazılmış tüm modüllerde bulunur. Bu niteliği şu şekilde kullanıyoruz:

```python
>>> os.__file__

'C:\Python37\lib\os.py'
```

İşte buradan aldığımız çıktı bizeosmodülünün kaynak dosyasının nerede
olduğunu gösteriyor. Hemen çıktıda görünen konuma gidelim veos.pydosyasını
açalım.

Dosyayı açtığınızda, gerçekten de bu modülün aslında sıradan bir Python programı
olduğunu göreceksiniz. Dosyanın içeriğini incelediğinizde,dir(os)komutuyla
elde ettiğimiz nitelik ve fonksiyonların dosya içinde nasıl tanımlandığını
görebilirsiniz. Mesela yeni dizinler oluşturmak içinos.makedirs()şeklinde
kullandığımızmakedirsfonksiyonununos.pyiçinde tanımlanmış alelade bir
fonksiyon olduğunu görebilirsiniz.

Aynı şekilde, önceki sayfalarda örneklerini verdiğimizwebbrowsermodülü de,
bilgisayarımızdaki sıradan bir Python programından ibarettir. Bu modülün nerede
olduğunu da şu komutla görebilirsiniz:

```python
>>> import webbrowser
>>> webbrowser.__file__

```

Gördüğünüz gibi,webbrowsermodülü de, tıpkıosmodülü gibi,
bilgisayarımızdaki.pyuzantılı bir dosyadan başka bir şey değil. İsterseniz
bu dosyanın da içini açıp inceleyebilirsiniz.

Yalnız şu gerçeği de unutmamalıyız: Python’daki bütün modüller Python
programlama dili ile yazılmamıştır. Bazı modüller C ile yazılmıştır. Dolayısıyla
C ile yazılmış bir modülün.pyuzantılı bir Python dosyası bulunmaz. Meselasysböyle bir modüldür. Bu modül C programlama dili ile yazıldığı için,
kayıtlı bir.pydosyasına sahip değildir. Dolayısıyla bu modülün bir__file__niteliği de bulunmaz:

```python
>>> import sys
>>> sys.__file__

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute '__file__'

```

Ama tabii ki, Python’daki standart kütüphane modüllerinin çok büyük bölümü
Python ile yazılmıştır ve bu modüllerin kaynak dosyalarınıosvewebbrowsermodüllerini bulduğunuz dizinde görebilirsiniz. Örneğin önceki
derslerimizde bahsi geçenlocaleverandomgibi modüllerin kaynak
dosyalarını da burada bulabilirsiniz.

Gelelim asıl konumuz olan ‘modül tanımlama’ya…

Hatırlarsanız, Python’da bir fonksiyon tanımlamak için şu söz dizimini
kullanıyorduk:

```python
def fonksiyon_adı(parametreler):
 fonksiyon_gövdesi

```

Ancak yukarıdaki örneklerden de rahatlıkla görebileceğiniz gibi, modüller için
böyle özel bir söz dizimi yoktur. Yazdığınız her Python programı aynı zamanda
potansiyel bir modüldür.

O halde şimdi gelin bir tane de kendimiz modül yazalım.

Mesela bir program dosyası oluşturalım ve adını dasözlük.pykoyalım. İşte bu
program, aynı zamanda bir Python modülüdür. Bu modülün adı da ‘sözlük’tür.
Dediğimiz gibi, Python’da modüller genellikle.pyuzantısına sahiptir. Ancak
bir modülün adı söylenirken bu.pyuzantısı dikkate alınmaz. Bu yüzden
elinizdeki ‘sözlük.py’ adlı programın modül adı ‘sözlük’ olacaktır.

Gördüğünüz gibi, modül tanımlamakta herhangi bir özel zorluk yok. Yazdığımız her
program, otomatik olarak, aynı zamanda bir modül oluyor.

sözlük.pyadlı programımızın içeriği şöyle olsun:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 return sözlük.get(sözcük, hata.format(sözcük))

```

İşte böylece ilk modülümüzü tanımlamış olduk. Şimdi de, yazdığımız bu modülü
nasıl kullanacağımızı öğrenelim.

Esasında kütüphane modülleriyle kendi yazdığımız modüller arasında kullanım
açısından pek bir fark yoktur. Bu bölümün başında gördüğümüz kütüphane
modüllerini nasıl kullanıyorsak, kendi modüllerimizi de öyle kullanıyoruz.

Kütüphane modüllerini anlatırken gördüğümüz gibi, modül sistemi sayesinde, bir
program içinde bulunan fonksiyon (ve nitelikleri) başka Python programları
içine aktarabiliyoruz. Böylece bir Python programındaki (veya modülündeki)
işlevsellikten, başka bir Python programında da yararlanabiliyoruz.

Şimdi, eğer busözlük.pydosyasını, mesela masaüstüne kaydettiyseniz,
masaüstünün bulunduğu konumda bir komut satırı açın ve Python’ın etkileşimli
kabuğunu başlatın. Tıpkı kütüphane modüllerinde olduğu gibi, etkileşimli kabukta
şu komutu verereksözlükadlı modülü içe aktarın:

```python
>>> import sözlük

```

Eğer hiçbir şey olmadan bir alt satıra geçildiyse modülünüzü başarıyla içe
aktardınız demektir. EğerNomodulenamedsözlükgibi bir hata mesajıyla
karşılaşıyorsanız, muhtemelen Python’ısözlük.pydosyasının olduğu dizinde
başlatamamışsınızdır.

importsözlükkomutunun başarılı olduğunu varsayarak yolumuza devam
edelim…

#### Modüllerin Yolu

Python geliştiricilerinin yazıp dile kaynaştırdığı kütüphane modülleri ile
kendi yazdığınız modüller arasında pek bir fark bulunmadığını ifade etmiştik.
Her iki modül türü de, içinde Python komutlarını ve veri tiplerini barındıran
alelade Python programlarından ibarettir.

Ancak şimdiye kadar yaptığımız örneklerde bir şey dikkatinizi çekmiş olmalı.
Kütüphane modüllerini her yerden içe aktarabiliyoruz. Yani, komut satırını
çalıştırdığımız her konumda veya program dosyamızın bulunduğu her dizin altında
bu modülleri rahatlıkla kullanabiliyoruz. Python’ın bu modülleri bulamaması
gibi bir şey söz konusu değil.

Ama kendi yazdığımız modülleri içe aktarabilmemiz için, bu modüllerin o anda
içinde bulunduğumuz dizin altında yer alması gerekiyor. Yani mesela yukarıda
örneğini verdiğimizsözlükmodülünü,sözlük.pydosyasını
bilgisayarımızdaki hangi konuma kaydetmişsek o konumdan içe aktarabiliyoruz.

Diyelim kisözlük.pydosyasını masaüstüne kaydetmiştik. İşte bu modülü komut
satırında içe aktarabilmemiz için, komut satırını da masaüstünün bulunduğu
konumda çalıştırmış olmamız gerekiyor.

Aynı şekilde eğer biz busözlükmodülünü,deneme.pyadlı başka bir program
içinde kullanacaksak, budeneme.pydosyasının dasözlük.pyadlı dosya ile
aynı dizinde yer alması gerekiyor.

Aksi halde,importsözlükkomutu hata verecektir.

Peki neden kütüphane modüllerini her yerden içe aktarabilirken, kendi yazdığımız
modülleri yalnızca bulundukları dizin altında içe aktarabiliyoruz?

Aslında bunun cevabı çok basit: Biz bir program dosyasında veya komut satırındaimportmodül_adıgibi bir komut verdiğimizde Python ‘modül_adı’ olarak
belirttiğimiz modülü bulmak için bir arama işlemi gerçekleştirir. Elbette Python
bu modülü sabit diskin tamamında aramaz. Python, içe aktarmak istediğimiz modülü
bulmak için belli birtakım dizinlerin içini kontrol eder. Peki Python modül
dosyasını bulmak için hangi dizinlerin içine bakar? Bu sorunun cevabını bizesysmodülününpathadlı bir niteliği verecek. Hemen bakalım:

```python
>>> import sys
>>> sys.path

```

İşte Python bir modül dosyasını ararken,importkomutunun verildiği dizin
ile birlikte,sys.pathçıktısında görünen dizinlerin içine de bakar. Eğer
modül dosyasını bu dizinlerin içinde bulursa modülü başarıyla içe aktarır, ama
eğer bulamazsaImportErrorcinsinden bir hata verir.

Peki eğer biz kendi modüllerimizi de her yerden içe aktarabilmek istersek ne
yapmamız gerekiyor?

Bunun için iki seçeneğimiz var: Birincisi, modülün yolunusys.pathlistesine
ekleyebiliriz. İkincisi, modülümüzüsys.pathiçinde görünen dizinlerden
birine kopyalayabilir veya taşıyabiliriz.

Öncelikle birinci seçeneği ele alalım.

Gördüğünüz gibi,sys.pathkomutunun çıktısı aslında basit bir listeden başka
bir şey değildir. Dolayısıyla Python’da liste adlı veri tipi üzerinde ne tür
işlemler yapabiliyorsanız,sys.pathüzerinde de aynı şeyleri yapabilirsiniz.

Mesela, modül dosyasının/home/istihza/programlaradlı dizin içinde
bulunduğunu varsayarsak, modül dosyasının yolunusys.pathlistesinin en
sonuna şu şekilde ekleyebiliriz:

```python
sys.path.append(r'/home/istihza/programlar')

```

Burada listelerinappend()metodunu kullandığımıza dikkat edin. Dediğimiz
gibi,sys.pathaslında basit bir listeden ibarettir. Dolayısıyla bir listeye
nasıl öğe ekliyorsak,sys.path’e de aynı şekilde öğe ekliyoruz.

Modül dosyasının bulunduğu/home/istihza/programlaryolunusys.pathlistesine eklediğimize göre, artık modülümüzü her yerden içe aktarabiliriz.

Kendi yazdığımız bir modülü her yerden içe aktarabilmenin ikinci yönteminin,
ilgili modül dosyasınısys.pathçıktısında görünen dizinlerden herhangi
birine kopyalamak olduğunu söylemiştik. Dolayısıyla,sys.pathçıktısına
bakıp, modül dosyanızı orada görünen dizinlerden herhangi biri içine
kopyalayabilirsiniz. Yaygın olarak tercih edilen konum, Python kurulum dizini
içindekisite-packagesadlı dizindir. Bu dizinin yerini şu şekilde tespit
edebilirsiniz:

```python
>>> from distutils import sysconfig
>>> sysconfig.get_python_lib()

```

Modül dosyanızı, bu komutlardan aldığınız çıktının gösterdiği dizin içine
kopyaladıktan sonra, modülünüzü her yerden içe aktarabilirsiniz.

Bu konuyu kapatmadan öncesys.pathile ilgili önemli bir bilgi daha verelim.
Python, içe aktarmak istediğimiz bir modülü bulabilmek için dizinleri ararkensys.pathlistesindeki dizin adlarını soldan sağa doğru okur. Modül dosyasını
bulduğu anda da arama işlemini sona erdirir ve modülü içe aktarır. Diyelim kisys.pathçıktımız şöyle:

```python
['A', 'B', 'C']

```

Eğer hemA, hem deBdizinindesözlük.pyadlı bir dosya varsa, PythonAdizinindekisözlükmodülünü içe aktarır. Çünküsys.pathçıktısındaAdiziniBdizininden önce geliyor. Eğer siz içe aktarma sırasında bir dizine
öncelik vermek isterseniz o diziniappend()metoduylasys.pathlistesinin sonuna eklemek yerine,insert()metoduyla listenin en başına
ekleyebilirsiniz:

```python
>>> sys.path.insert(0, r'dizin/adı')

```

Böylece Python, modülünüzü en başa eklediğiniz dizinden içe aktaracaktır.

Tekrar tekrar söylediğimiz gibi,sys.pathsıradan bir listedir. Dolayısıyla
listelerin üzerine hangi metotları uygulayabiliyorsanızsys.pathüzerine de
o metotları uygulayabilirsiniz.

#### Modüllerde Değişiklik Yapmak

Python’da bir modül başka bir ortama aktarıldığında, o modülün içinde yer alan
nitelik ve fonksiyonların o ortam içinden kullanılabilir hale geldiğini
biliyorsunuz. Yukarıdaki örnekte bizimportsözlükkomutuyla,sözlükadlı modülün bütün içeriğini etkileşimli kabuk ortamına (veya program dosyasına)
aktarmış olduk. Dolayısıyla da artık bu modülün bütün içeriğine erişebiliriz.
Peki acaba bu modül içinde bizim erişebileceğimiz hangi nitelik ve fonksiyonlar
bulunuyor?

Tıpkı kütüphane modüllerini işlerken yaptığımız gibi,dir()fonksiyonundan
yararlanarak, içe aktardığımız bu modül içindeki kullanılabilir fonksiyon ve
nitelikleri görebilirsiniz:

```python
>>> dir(sözlük)

```

Bu komut bize şöyle bir çıktı verir:

```python
['__builtins__', '__cached__', '__doc__',
'__file__', '__loader__', '__name__',
'__package__', '__spec__', 'ara', 'sözlük']

```

Gördüğünüz gibi, nasılosmodülünün içindename,listdir()vegetcwd()gibi nitelik ve fonksiyonlar varsa, kendi yazdığımızsözlükmodülü içinde deara()adlı bir fonksiyon vesözlükadlı bir nitelik var.

İşte biz bu fonksiyon ve niteliği kullanma imkanına sahibiz. Gelin birkaç deneme
çalışması yapalım:

```python
>>> sözlük.sözlük

```

Bu komutun, bir kütüphane modülündeki niteliklere erişmekten hiçbir farkı
olmadığına dikkatinizi çekmek isterim. Meselasysmodülününversionniteliğine nasıl erişiyorsak,sözlükmodülününsözlükniteliğine de aynı
şekilde erişiyoruz.

sözlük.sözlükkomutu bizesözlükmodülü içindekisözlükadlı
değişkenin içeriğini verecektir.

Şimdi de aynı modül içindekiara()fonksiyonuna erişelim:

```python
>>> sözlük.ara('kitap')

```

Bu da bizeara()fonksiyonunukitapargümanıyla birlikte çağırma imkanı
veriyor.

Yukarıda verdiğimiz örnektesözlükmodülünü etkileşimli kabuk üzerinde
kullandık. Elbette program yazarken modülleri etkileşimli kabukta değil, program
dosyaları içinde kullanacağız. Ancak özellikle bir modülün geliştirilme
aşamasında o modülü test etmek için etkileşimli kabuk üzerinde çalışmak oldukça
pratik ve faydalı bir yoldur. Mesela yazmakta olduğunuz bir programın (diğer bir
deyişle modülün) nitelik ve fonksiyonlarını test etmek için, o programı
etkileşimli kabukta bir modül olarak içe aktarıp çeşitli deneme çalışmaları
yapabilirsiniz.

Dilerseniz yine yukarıdaki örnek üzerinden gidelim:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 return sözlük.get(sözcük, hata.format(sözcük))

```

Bu modülü içe aktaralım:

```python
>>> import sözlük

```

Modülün içeriğini kontrol edelim:

```python
>>> dir(sözlük)

```

Bu komutun çıktısındasözlükniteliğini veara()fonksiyonunu görüyoruz.
Gelin şimdi programımıza bir ekleme yapalım:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 return sözlük.get(sözcük, hata.format(sözcük))

def ekle(sözcük, anlam):
 mesaj = "{} kelimesi sözlüğe eklendi!"
 sözlük[sözcük] = anlam
 print(mesaj.format(sözcük))

```

Buradasözlükmodülüneekle()adlı bir fonksiyon ilave ettik. Bu
fonksiyon, sözlüğe yeni kelimeler eklememizi sağlayacak. Şimdi tekrar
modülümüzün içeriğini kontrol edelim:

```python
>>> dir(sözlük)

```

Ancak gördüğünüz gibi, modüle yeni eklediğimizekle()fonksiyonu bu çıktıda
görünmüyor. Bunun nedeni, etkileşimli kabukta modül bir kez içe aktarıldıktan
sonra, o modülde yapılan değişikliklerin otomatik olarak etkinleşmiyor oluşudur.
Yani değişikliklerin etkileşimli kabukta etkinleşebilmesi için o modülü yeniden
yüklememiz lazım. Bunu iki şekilde yapabiliriz:

Birincisi, etkileşimli kabuğu kapatıp yeniden açtıktan sonraimportsözlükkomutuylasözlükmodülünü tekrar içe aktarabiliriz.

İkincisi,importlibadlı bir kütüphane modülünden yararlanarak kendi
modülümüzün tekrar yüklenmesini sağlayabiliriz. Bu modülü şöyle kullanıyoruz:

```python
>>> import importlib
>>> importlib.reload(sözlük)

```

Bu iki komutu verdikten sonra,sözlüküzerinde tekrardir()fonksiyonunu
uygularsak, yeni eklediğimizekle()fonksiyonunun çıktıya yansıdığını
görürüz:

```python
>>> dir(sözlük)

['__builtins__', '__cached__', '__doc__', '__file__',
'__loader__', '__name__', '__package__', '__spec__',
'ara', 'ekle', 'sözlük']

```

Tıpkı önceki derslerimizde gördüğümüzsys,osvekeywordmodülleri
gibi,importlibde bir kütüphane modülüdür. Bu modülün bizim yukarıda
yazdığımızsözlükadlı modülden farkı, Python geliştiricileri tarafından
yazılıp dile entegre edilmiş bir ‘hazır modül’ olmasıdır. Yanisözlükmodülünü biz kendimiz yazdık,importlibmodülünü ise Python geliştiricileri
yazdı. İkisi arasındaki tek fark bu.

Ne diyorduk? Evet,sözlükadlı modüleekle()adlı yeni bir fonksiyon
ilave ettik. Bu fonksiyona da, tıpkısözlükniteliğinde veara()fonksiyonunda olduğu gibi, modül adını kullanarak erişebiliriz:

```python
>>> sözlük.ekle('araba', 'car')

araba kelimesi sözlüğe eklendi!

```

Sözlüğümüze, ‘araba’ adlı yeni bir kelimeyi, ‘car’ karşılığı ile birlikte
ekledik. Hemen bunu sorgulayalım:

```python
>>> sözlük.ara('araba')

'car'

```

Gayet güzel! Şimdi sözlüğümüze bir ekleme daha yapalım:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 return sözlük.get(sözcük, hata.format(sözcük))

def ekle(sözcük, anlam):
 mesaj = "{} kelimesi sözlüğe eklendi!"
 sözlük[sözcük] = anlam
 print(mesaj.format(sözcük))

def sil(sözcük):
 try:
 sözlük.pop(sözcük)
 except KeyError as err:
 print(err, "kelimesi bulunamadı!")
 else:
 print("{} kelimesi sözlükten silindi!".format(sözcük))

```

Bu defa da modülümüzesil()adlı başka bir fonksiyon ekledik. Bu fonksiyon,
sözlükten öğe silmemizi sağlayacak:

```python
>>> sözlük.sil('kitap')

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute 'sil'

```

Gördüğünüz gibi, bu kez bir hata mesajı aldık. Peki sizce neden? Elbette
değişiklik yaptıktan sonra modülü yeniden yüklemediğimizden… O halde önce
modülümüzü yeniden yükleyelim:

```python
>>> importlib.reload(sözlük)

```

Şimdi bu fonksiyonu kullanabiliriz:

```python
>>> sözlük.sil('kitap')

kitap kelimesi sözlükten silindi!

```

Bu noktada,importlibmodülününreload()fonksiyonunun çalışma sistemine
ilişkin birkaç önemli bilgi verelim.

importlibmodülününreload()fonksiyonu, bir modüle yeni eklenen öğeleri
yeniden yükleyerek, bunların etkileşimli kabukta kullanılabilir hale gelmesini
sağlar. Bunun ne demek olduğunu biliyoruz. Yukarıda bunun örneklerini vermiştik.

Eğer bir modüldeki bazı nitelik veya fonksiyonları silerseniz,importlibmodülününreload()fonksiyonu ile bu modülü yeniden yükledikten sonra bile
bu nitelik ve fonksiyonlar önbellekte tutulmaya devam eder. Örneğin, yukarıdakisözlükmodülünü önce içe aktaralım:

```python
>>> import sözlük

```

Şimdi modülün içeriğini kontrol edelim:

```python
>>> dir(sözlük)

['__builtins__', '__cached__', '__doc__', '__file__',
'__loader__', '__name__', '__package__', '__spec__',
'ara', 'ekle', 'sil', 'sözlük']

```

Modül dosyasındansil()adlı fonksiyonu çıkaralım. Yani modülümüzün son hali
şöyle olsun:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 return sözlük.get(sözcük, hata.format(sözcük))

def ekle(sözcük, anlam):
 mesaj = "{} kelimesi sözlüğe eklendi!"
 sözlük[sözcük] = anlam
 print(mesaj.format(sözcük))

```

Tekrar etkileşimli kabuğa dönüp,importlibmodülününreload()fonksiyonu
aracılığıyla modülümüzü yeniden yükleyelim:

```python
>>> import importlib
>>> importlib.reload(sözlük)

```

Şimdisözlükmodülünün içeriğini tekrar kontrol edelim:

```python
>>> dir(sözlük)

['__builtins__', '__cached__', '__doc__', '__file__',
'__loader__', '__name__', '__package__', '__spec__',
'ara', 'ekle', 'sil', 'sözlük']

```

Gördüğünüz gibi, bizsil()fonksiyonunu çıkarmış olduğumuz halde,dir(sözlük)çıktısında bu öğe görünmeye devam ediyor. Üstelik bu fonksiyon
halen kullanılabilir durumda!

```python
>>> sözlük.sil('programlama')

programlama kelimesi sözlükten silindi!

```

Ancak bu durumu rahatlıkla görmezden gelebilirsiniz. Ama eğer o öğenin orada
olması sizi rahatsız ediyorsa, şu komutla o öğeyi silebilirsiniz:

```python
>>> del sözlük.sil

```

Dediğimiz gibi, modülden silinen öğeler,reload()ile yeniden yüklendikten
sonra dahi kullanılır durumda kalmaya devam eder. Ama eğer modül içinde varolan
bir öğe üzerinde değişiklik yaparsanız o değişiklik,reload()sonrası
modülün görünümüne yansıyacaktır. Yani mesela, modülde halihazırda varolansil()fonksiyonu üzerinde bir değişiklik yaparsanız, bu değişiklikreload()ile yeniden yükleme sonrasında etkileşimli kabuğa yansıyacaktır.

### Üçüncü Şahıs Modülleri

Buraya kadar Python’daki kütüphane modüllerinden ve kendi yazdığımız modüllerden
söz ettik. Artık modüllerin ne olduğunu ve ne işe yaradığını gayet iyi
biliyoruz. Bu bölümde ise, yine bir ‘hazır modül’ türü olan üçüncü şahıs
modüllerinden bahsedeceğiz.

Üçüncü şahıs modülleri, başka Python programcıları tarafından yazılıp
hizmetimize sunulmuş programlardır. Bu yönüyle bunlar kütüphane modüllerine çok
benzer. Ama bu ikisi arasında önemli bir fark bulunur: Kütüphane modülleri
Python programlama dilinin bir parçasıdır. Dolayısıyla kütüphane modüllerini
kullanmak için herhangi bir ek yazılım indirmemiz gerekmez. Üçüncü şahıs
modülleri ise dilin bir parçası değildir. Bu modülleri kullanabilmek için,
öncelikle bunları modül geliştiricisinin koyduğu yerden bilgisayarımıza
indirmemiz gerekir.

Hatırlarsanız ilk derslerimizde Cx_Freeze adlı bir yazılımdan söz etmiştik. İşte
bu yazılım bir üçüncü şahıs modülüdür. Bu modülü kullanabilmek için öncelikle
ilgili yazılımı programımıza kurmamız gerekmişti.

Python için yazılmış üçüncü şahıs modüllerine çeşitli kaynaklardan
ulaşabilirsiniz. Bu tür modülleri bulabileceğiniz en geniş kaynakhttps://pypi.org/adresidir. Burada 60.000’in üzerinde modüle
ulaşabilirsiniz.

Peki bu modülleri nasıl kuracağız?

Eğer bir modülhttps://pypi.org/adresinde ise, bu modülü sistem
komut satırında şu şekilde kurabilirsiniz:

```python
pip3 install modül_adı

```

> **Not**
> Python’ın 2.7.9 ve 3.4.0 sürümlerinden itibaren, pip adlı yazılım
öntanımlı olarak Python kurulumuyla birlikte geliyor. Dolayısıyla Python2’deki
pip’i kullanmak istersenizpip2komutunu, Python3’teki pip’i kullanmak
isterseniz depip3komutunu kullanabilirsiniz.

Not

Python’ın 2.7.9 ve 3.4.0 sürümlerinden itibaren, pip adlı yazılım
öntanımlı olarak Python kurulumuyla birlikte geliyor. Dolayısıyla Python2’deki
pip’i kullanmak istersenizpip2komutunu, Python3’teki pip’i kullanmak
isterseniz depip3komutunu kullanabilirsiniz.

Örneğin amacınız Django adlı üçüncü şahıs modülünü kurmak ise bu modülü şu komut
ile kurabilirsiniz:

```python
pip3 install django

```

Eğer bir üçüncü şahıs modülünühttps://pypi.org/adresinden değil de
başka bir kaynaktan indiriyorsanız, kurulum için birkaç farklı seçenek olabilir.

Eğer indireceğiniz dosya Windows işletim sistemine uyumlu bir.exedosyasıysa,
bunu herhangi bir Windows programı gibi kurabilirsiniz.

Eğer indireceğiniz dosya.tar.gzveya.zipgibi sıkıştırılmış bir klasör
olarak iniyorsa öncelikle bu sıkıştırılmış klasörü açın. Eğer klasör içeriğindesetup.pyadlı bir dosya görürseniz bu dosyanın bulunduğu konumda bir komut
satırı açın ve şu komutu verin:

```python
python setup.py install

```

Tabii buradapythonkomutununpython3mü,py-3mü yoksa başka bir
şey mi olacağı tamamen sizin Python kurulumunu nasıl yaptığınıza bağlıdır.
Neticede siz oraya, Python’ı hangi komutla başlatıyorsanız onu yazacaksınız.
Yani eğer Python’ıpython3komutuyla başlatıyorsanız yukarıdaki komutu şöyle
vereceksiniz:

```python
python3 setup.py install

```

Aynı şekilde, GNU/Linux kullanıcılarının da bu komutu yetkili kullanıcı olarak
vermesi gerekecektir muhtemelen:

```python
sudo python3 setup.py install

```

Veya önce:

```python
su -

```

Ardından:

```python
python3 setup.py install

```

İndirip kurduğunuz bir üçüncü şahıs modülünü nasıl kullanacağınızı, indirdiğiniz
modülün belgelerine bakarak öğrenebilirsiniz.

> **Not**
> Paketler konusunu işlerken üçüncü şahıs modüllerinden daha ayrıntılı
bir şekilde söz edeceğiz.

Not

Paketler konusunu işlerken üçüncü şahıs modüllerinden daha ayrıntılı
bir şekilde söz edeceğiz.

### __all__ Listesi

Önceki başlıklar altında da ifade ettiğimiz gibi, farklı içe aktarma
yöntemlerini kullanarak, bir modül içindeki öğeleri farklı şekillerde içe
aktarabiliyoruz. Gelin isterseniz Python’ın içe aktarma mekanizmasını
anlayabilmek için ufak bir test yapalım.

Şimdi masaüstünde, içeriği aşağıdaki gibi olan,modül.pyadlı bir dosya
oluşturun:

```python
def fonk1():
 print('fonk1')

def fonk2():
 print('fonk2')

def fonk3():
 print('fonk3')

def fonk4():
 print('fonk4')

def fonk5():
 print('fonk5')

def _fonk6():
 print('_fonk6')

def __fonk7():
 print('__fonk7')

def fonk8_():
 print('fonk8_')

```

Daha sonra, masaüstünün bulunduğu konumda bir komut penceresi açarak Python’ın
etkileşimli kabuğunu çalıştırın ve orada şu komutu verip bumodül.pyadlı
dosyayı bir modül olarak içe aktarın:

```python
>>> import modül

```

Şimdi de şu komutu kullanarak modül içeriğini kontrol edin:

```python
>>> dir(modül)

```

Buradan şu çıktıyı alıyoruz:

```python
['__builtins__', '__cached__', '__doc__', '__file__', '__fonk7',
 '__loader__', '__name__', '__package__', '__spec__', '_fonk6',
 'fonk1', 'fonk2', 'fonk3', 'fonk4', 'fonk5', 'fonk8_']

```

Gördüğünüz gibi, modül içinde tanımladığımız bütün fonksiyonlar bu listede var.
Dolayısıyla bu fonksiyonlara şu şekilde erişebiliyoruz:

```python
>>> modül.fonk1()

fonk1

>>> modül.fonk2()

fonk2

>>> modül._fonk6()

_fonk6

>>> modül.__fonk7()

__fonk7

>>> modül.fonk8_()

fonk8_

```

Bu şekilde, istisnasız bütün fonksiyonlara erişim yetkisi elde ettiğimize
dikkatinizi çekmek isterim.

Şimdi etkileşimli kabuğu kapatıp tekrar açalım ve bu kez modülümüzü şu şekilde
içe aktaralım:

```python
>>> from modül import *

```

Bu şekilde, ismi_ile başlayanlar hariç bütün fonksiyonları, modül öneki
olmadan mevcut etki alanına aktardığımızı biliyoruz.

Kontrol edelim:

```python
>>> dir()

```

Buradan şu çıktıyı alıyoruz:

```python
['__builtins__', '__doc__', '__loader__', '__name__',
 '__package__', '__spec__', 'fonk1', 'fonk2', 'fonk3',
 'fonk4', 'fonk5', 'fonk8_']

```

Gördüğünüz gibi, gerçekten de ismi_ile başlayanlar hariç, bütün
fonksiyonlar, modül öneki olmadan kullanılmaya hazır bir şekilde mevcut etki
alanımız içinde görünüyor. Bunları şu şekilde kullanabileceğimizi biliyorsunuz:

```python
>>> fonk4()

fonk4

>>> fonk8_()

fonk8_

```

Elbette, ismi_ile başlayan fonksiyonları, doğrudan isimlerini kullanarak
içe aktarma imkanına sahipsiniz:

```python
>>> from modül import __fonk7
>>> from modül import _fonk6

```

Tabii, bu fonksiyonları içe aktarabilmek için bunların isimlerini biliyor
olmanız lazım…

Peki siz, yazdığınız bir programda yalnızca kendi belirlediğiniz isimlerin içe
aktarılmasını isterseniz ne yapacaksınız? İşte bunun için, başlıkta sözünü
ettiğimiz__all__adlı bir listeden yararlanabilirsiniz.

Şimdi biraz önce oluşturduğunuzmodül.pydosyasının en başına şu satırı
ekleyin:

```python
__all__ = ['fonk1', 'fonk2', 'fonk3']

```

Daha sonra etkileşimli kabukta modülünüzü şu şekilde içe aktarın:

```python
>>> from modül import *

```

Şimdi de içe aktarılan fonksiyonların neler olduğunu kontrol edin:

```python
>>> dir()

['__builtins__', '__doc__', '__loader__', '__name__', '__package__',
 '__spec__', 'fonk1', 'fonk2', 'fonk3']

```

Gördüğünüz gibi, yalnızca__all__listesi içinde belirttiğimiz fonksiyonlar
içe aktarıldı. Bu listeyi kullanarak, yıldızlı içe aktarmalarda nelerin içe
aktarılıp nelerin dışarıda bırakılacağını kontrol edebilirsiniz. Yalnız
unutmamanız gereken nokta, bu yöntemin öteki içe aktarma türlerinde hiçbir işe
yaramayacağıdır. Yani meselamodüladlı modülümüzüimportmodülşeklinde
içe aktarırsak__all__listesi dikkate alınmayacaktır.

Peki ya__all__listesini boş bırakırsak ne olur?

```python
__all__ = []

```

Tabii ki, bu şekilde yıldızlı aktarmalarda (modülün kendi varsayılan
fonksiyonları hariç) hiçbir fonksiyon içe aktarılmaz…

### Modüllerin Özel Nitelikleri

Python’da bütün modüllerin ortak olarak sahip olduğu bazı nitelikler vardır. Bu
niteliklerin hangileri olduğunu görmek için kesişim kümelerinden yararlanarak
şöyle bir kod yazabiliriz:

```python
import os, sys, random

set_os = set(dir(os))
set_sys = set(dir(sys))
set_random = set(dir(random))

print(set_os & set_sys & set_random)

```

Bu kodlar,os,sysverandommodüllerinin kesişim kümesini, yani her üç
modülde ortak olarak bulunan nitelikleri verecektir. Bu kodları
çalıştırdığımızda şu çıktıyı alıyoruz:

```python
{'__doc__', '__package__', '__loader__', '__name__', '__spec__'}

```

Demek ki hemoshemsyshem derandommodülünde ortak olarak bulunan
nitelikler bunlarmış… Eğer bu üç modülün bütün modülleri temsil etmiyor
olabileceğinden endişe ediyorsanız, bildiğiniz başka modülleri de bu kodlara
ekleyerek testinizin kapsamını genişletebilirsiniz.

Mesela bu kodlara bir desubprocessmodülünü ekleyelim:

```python
import os, sys, random, subprocess

set_os = set(dir(os))
set_sys = set(dir(sys))
set_random = set(dir(random))
set_subprocess = set(dir(subprocess))

print(set_os & set_sys & set_random & set_subprocess)

```

Yalnız burada şöyle bir şey dikkatinizi çekmiş olmalı: Kesişim kümesini bulmak
istediğimiz öğelere başka öğeler de eklemek istediğimizde her defasında birkaç
farklı işlem yapmak zorunda kalıyoruz. Bu da hem kodlarımızı hatalara açık hale
getiriyor, hem de aslında kolayca halledebileceğimiz bir işi gereksiz yere
uzatmamıza yol açıyor.

Gelin bu kodları biraz daha genel amaçlı bir hale getirelim. Zira ‘kodların
yeniden kullanılabilir özellikte olması’ (code reusability) programcılıkta
aranan bir niteliktir:

```python
modüller = ['os', 'sys', 'random']

def kesişim_bul(modüller):
 kümeler = [set(dir(__import__(modül))) for modül in modüller]
 return set.intersection(*kümeler)

print(kesişim_bul(modüller))

```

Eğer bu kodlara yeni bir modül eklemek istersek, yapmamız gereken tek şey en
baştakimodüllerlistesini güncellemek olacaktır. Mesela bu listeye bir desubprocessmodülünü ekleyelim:

```python
modüller = ['os', 'sys', 'random', 'subprocess']

def kesişim_bul(modüller):
 kümeler = [set(dir(__import__(modül))) for modül in modüller]
 return set.intersection(*kümeler)

print(kesişim_bul(modüller))

```

Gördüğünüz gibi, bu kodlar işimizi epey kolaylaştırdı. Sadece tek bir noktada
değişiklik yaparak istediğimiz sonucu elde ettik.

Bu arada,__import__fonksiyonu hariç, bu kodlardaki her şeyi daha önceki
derslerimizde öğrenmiştik. Ama gelin isterseniz biz yine de bu kodların
üzerinden şöyle bir geçelim.

Burada ilk yaptığımız iş, kullanmak istediğimiz modül adlarını tutması için bir
liste tanımlamak:

```python
modüller = ['os', 'sys', 'random', 'subprocess']

```

Bu listede modül adlarının birer karakter dizisi olarak gösterildiğine dikkat
edin. Zaten bu modülleri henüz içe aktarmadığımız için, bunları doğrudan
tırnaksız isimleriyle kullanamayız.

Daha sonra, asıl işi yapacak olankesişim_bul()adlı fonksiyonumuzu
tanımlıyoruz:

```python
def kesişim_bul(modüller):
 kümeler = [set(dir(__import__(modül))) for modül in modüller]
 return set.intersection(*kümeler)

```

Bu fonksiyon,modülleradlı tek bir parametre alıyor.

Fonksiyonumuzun gövdesinde ilk olarak şöyle bir kod yazıyoruz:

```python
kümeler = [set(dir(__import__(modül))) for modül in modüller]

```

Buradamodülleradlı listedeki her öğe üzerine sırasıyla__import__fonksiyonunu,dir()fonksiyonunu veset()fonksiyonunu uyguluyoruz. Daha
sonra elde ettiğimiz sonucu bir liste üreteci yardımıyla liste haline getiripkümelerdeğişkenine atıyoruz.

Gelelim__import__fonksiyonunun ne olduğuna…

Bir gömülü fonksiyon olan__import__fonksiyonu, modül adlarını içeren
karakter dizilerini kullanarak, herhangi bir modülü içe aktarmamızı sağlayan bir
araçtır. Bu fonksiyonunu şöyle kullanıyoruz:

```python
>>> __import__('os')
>>> __import__('sys')

```

Bu fonksiyonun parametre olarak bir karakter dizisi alıyor olmasının bize nasıl
bir esneklik sağladığına dikkatinizi çekmek isterim. Bu fonksiyon sayesinde
modül aktarma işlemini, kod parçaları içine programatik olarak yerleştirebilme
imkanı elde ediyoruz. Yani, modül aktarma işlemini mesela birfordöngüsü
içine alamıyorken:

```python
>>> modüller = ['os', 'sys', 'random']
>>> for modül in modüller:
... import modül
...
Traceback (most recent call last):
 File "<stdin>", line 2, in <module>
ImportError: No module named 'modül'

```

__import__fonksiyonu bize böyle bir işlem yapabilme olanağı sunuyor:

```python
>>> modüller = ['os', 'sys', 'random']
>>> for modül in modüller:
... __import__(modül)

<module 'os' from 'C:\\Python34\\lib\\os.py'>
<module 'sys' (built-in)>
<module 'random' from 'C:\\Python34\\lib\\random.py'>

```

Yalnız,__import__('os')gibi bir komut verdiğimizde, ‘os’ ismi doğrudan
kullanılabilir hale gelmiyor. Yani:

```python
>>> __import__('os')

```

…komutunu verdiğimizde, meselaosmodülünün bir niteliği olanname’i
kullanamıyoruz:

```python
>>> os.name

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
NameError: name 'os' is not defined

```

‘os’ ismini kullanabilmemiz için şöyle bir şey yazmış olmalıydık:

```python
>>> os = __import__('os')

```

Eğer__import__fonksiyonu yardımıyla içe aktardığımızosmodülünü bu
şekilde bir isme atamazsak,__import__('os')komutu ile içe aktarılan bütünosfonksiyon ve nitelikleri, bu komut bir kez çalıştıktan sonra unutulacaktır.
Eğer__import__fonksiyonunu bir isme atamadan, içe aktarılan modülün
niteliklerine erişmek isterseniz içe aktarma işlemi ile niteliğe erişme işlemini
aynı satırda gerçekleştirmeniz gerekir:

```python
>>> __import__('os').name

'nt'

```

__import__fonksiyonu çok sık kullanacağınız bir araç değildir. Ancak
özellikle tek satırda hem bir modülü içe aktarmanız, hem de hemen ardından başka
işlemler yapmanız gereken durumlarda bu fonksiyon işinize yarayabilir:

```python
>>> open('den.txt', 'w').write('merhaba'); __import__('subprocess').call('notepad.exe den.txt')

```

Gerekli modülleri içe aktardıktan ve kümemimizi tanımladıktan sonra da fonksiyon
tanımını şu kodla bitiriyoruz:

```python
return set.intersection(*kümeler)

```

Burada kümelerinintersection()metodundan faydalandık. Bu metodu önceki
derslerimizde ele almıştık. Bu metot yardımıyla birden fazla kümenin kesişimini
bulabiliyoruz.

Bu fonksiyonu normalde şöyle kullanıyorduk:

```python
>>> küme1.intersection(küme2)

```

Bu komut,küme1ileküme2adlı kümelerin kesişimini bulacaktır. Eğer bizim
kodlarımızda olduğu gibi küme ismi belirtmeksizin birden fazla kümenin
kesişimini bulmak isterseniz bu metodu doğrudan küme veri tipi (set) üzerine
uygulayabilirsiniz:

```python
>>> set.intersection(küme1, küme2)

```

Eğerintersection()metoduna parametreleri bir liste içinden atamak
isterseniz bu listeyi yıldız işleci yardımıyla çözmeniz gerekir:

```python
>>> liste = [küme1, küme2, küme3]
>>> set.intersection(*liste)

```

İşte bizim yukarıdareturnset.intersection(*kümeler)komutuyla yaptığımız
şey de tam olarak budur. Buradaintersection()metodunu doğrudansetveri
tipi üzerine uyguladık ve bu metodun parametrelerinikümeleradlı listeden
yıldız işleci yardımıyla çözdük.

Son olarak da, tanımladığımızkesişim_bul()fonksiyonunumodülleradlı
parametre ile çağırdık:

```python
print(kesişim_bul(modüller))

```

Bütün bu kodları çalıştırdıktan sonra ise şöyle bir çıktı elde ettik:

```python
{'__doc__', '__name__', '__loader__', '__spec__', '__package__'}

```

İşte bu bölümün konusu, bütün modüllerde ortak olan bu beş özel nitelik. İlk
olarak__doc__niteliği ile başlayalım.

#### __doc__ Niteliği

İsterseniz__doc__niteliğini tarif etmeye çalışmak yerine, bunu bir örnek
üzerinden anlatalım. Şimdi Python kurulum dizini içindeos.pydosyasının
bulunduğu konuma gidelim ve bu dosyayı açalım. Dosyayı açtığınızda, sayfanın en
başında şu karakter dizisini göreceksiniz:

```python
r"""OS routines for NT or Posix depending on what system we're on.

This exports:
 - all functions from posix, nt or ce, e.g. unlink, stat, etc.
 - os.path is either posixpath or ntpath
 - os.name is either 'posix', 'nt' or 'ce'.
 - os.curdir is a string representing the current directory ('.' or ':')
 - os.pardir is a string representing the parent directory ('..' or '::')
 - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
 - os.extsep is the extension separator (always '.')
 - os.altsep is the alternate pathname separator (None or '/')
 - os.pathsep is the component separator used in $PATH etc
 - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
 - os.defpath is the default search path for executables
 - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms. Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).
"""

```

Şimdi Python’ın etkileşimli kabuğunu açın ve şu komutları verin:

```python
>>> import os
>>> print(os.__doc__)

```

Bu komutları verdiğinizde, yukarıdaki karakter dizisinin çıktı olarak
verildiğini göreceksiniz. Teknik dilde, üç tırnak içinde gösterilen karakter
dizilerine belge dizisi (docstring) veya belgelendirme dizisi (documentation
string) adı verilir. Modüllerin__doc__niteliğini kullanarak, bir modül
dosyasının en başında bulunan belgelendirme dizilerine erişebiliriz.

Bir örnek daha verelim. Meselarandommodülüne bakalım:

```python
>>> import random
>>> print(random.__doc__)

```

os.pydosyası ile aynı konumda bulunanrandom.pydosyasını açtığınızda,
yukarıdaki komutlardan aldığınız çıktınınrandom.pydosyasının en başındaki
uzun karakter dizisi olduğunu göreceksiniz.

Çeşitli yazılımlar, bu belge dizilerini kullanarak, ilgili modüle ilişkin kısa
kılavuzlar oluşturur. Mesela Python’ınhelp()fonksiyonu bu belge
dizilerinden yararlanır:

```python
>>> help(os)

```

Siz de kendi yazdığınız modüllerde bu belge dizilerinden yararlanabilirsiniz.
Ancak aklınızda bulundurmanız gereken önemli nokta, bu belge dizilerini üç
tırnak içinde belirtmeniz gerektiğidir. Alt alta çift veya tek tırnak ile
tanımladığınız karakter dizilerine__doc__niteliği aracılığıyla erişmeye
çalıştığınızda sadece ilk satırdaki karakter dizisine ulaşırsınız. Yani:

```python
"satır1"
"satır2"
"satır3"

```

…şeklinde tanımladığınız karakter dizileri__doc__niteliği ile
çağrıldığında yalnızca “satır1” görüntülenecektir. Eğer bu üç satırın da
kapsama alanına girmesini istiyorsak yukarıdaki karakter dizilerini şöyle
tanımlamalıyız:

```python
'''
satır1
satır2
satır3
'''

```

#### __name__ Niteliği

Şöyle bir program yazdığımızı varsayalım:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 print(sözlük.get(sözcük, hata.format(sözcük)))

def ekle(sözcük, anlam):
 mesaj = "{} kelimesi sözlüğe eklendi!"
 sözlük[sözcük] = anlam
 print(mesaj.format(sözcük))

def sil(sözcük):
 try:
 sözlük.pop(sözcük)
 except KeyError as err:
 print(err, "kelimesi bulunamadı!")
 else:
 print("{} kelimesi sözlükten silindi!".format(sözcük))

print('1. Sözlükte kelime ara')
print('2. Sözlüğe kelime ekle')
print('3. Sözlükten kelime sil')
no = input('Yapmak istediğiniz işlemin numarasını girin: ')

if no == '1':
 sözcük = input('Aradığınız sözcük: ')
 ara(sözcük)

elif no == '2':
 sözcük = input('Ekleyeceğiniz sözcük: ')
 anlam = input('Eklediğiniz sözcüğün anlamı: ')
 ekle(sözcük, anlam)

elif no == '3':
 sözcük = input('Sileceğiniz sözcük: ')
 sil(sözcük)

else:
 print('Yanlış işlem')

```

sözlük.pyadını verdiğimiz bu programı normal bir şekilde komut satırında

```python
python sözlük.py

```

gibi bir komutla çalıştırdığımızda bize birtakım sorular sorulacak ve verdiğimiz
cevaplara göre sözlük üzerinde bazı işlemler yapılacaktır.

Hatırlarsanız, modüller konusunu anlatmaya başlarken, yazdığımız bütün
programların aslında birer modül olduğunu, dolayısıyla bunların başka
programların içine aktarılarak, sahip oldukları işlevlerden başka programlarda
da yararlananılabileceğini söylemiştik.

Yukarıdaki kodları, komut satırı üzerinde bağımsız bir program gibi
çalıştırabiliyoruz. Peki acaba biz bu programı doğrudan çalıştırmak değil de
başka bir programın içine aktarıp sahip olduğu işlevlerden yararlanmak istersek
ne yapacağız?

İşte bunun için__name__adlı bir nitelikten yararlanacağız.

Python’daki herhangi bir modülü içe aktardıktan sonra bu modül üzerinedir()fonksiyonunu uygularsanız, istisnasız her modülün__name__adlı bir niteliği
olduğunu görürsünüz.

__name__niteliği iki farklı değer alabilir: İçinde bulunduğu modülün adı
veya"__main__"adlı özel bir değer.

Eğer bir Python programı başka bir program içinden modül olarak içe
aktarılıyorsa,__name__niteliğinin değeri o modülün adı olacaktır.

Eğer bir Python programı doğrudan bağımsız bir program olarak çalıştırılıyorsa,__name__niteliğinin değeri bu defa"__main__"olacaktır.

Gelin isterseniz bu durumu bir örnek üzerinde somutlaştıralım. Mesela
masaüstündedeneme.pyadlı bir dosya oluşturup içine sadece şunu yazalım:

```python
print(__name__)

```

Şimdi önce bu dosyayı bağımsız bir program olarak çalıştıralım:

```python
python deneme.py

```

Programımızı bu şekilde çalıştırdığımızda alacağımız çıktı şu olacaktır:

```python
__main__

```

Demek ki__name__niteliğinin değeri"__main__"imiş…

Şimdi dedeneme.pydosyasının bulunduğu konumda Python’ın etkileşimli kabuğunu
çalıştıralım ve şu komut yardımıyla bu dosyayı bir modül olarak içe aktaralım:

```python
>>> import deneme

```

Bu defa şu çıktıyı aldık:

```python
deneme

```

Gördüğünüz gibi,__name__niteliğinin değeri bu kez de modül dosyasının adı
oldu.

İşte bu özellikten yararlanarak, yazdığınız programların bağımsız
çalıştırılırken ayrı, modül olarak içe aktarılırken ayrı davranmasını
sağlayabilirsiniz.

Gelin bu bilgiyi yukarıdakisözlük.pydosyasına uygulayalım.

Bu programı komut satırı üzerinde bağımsız bir program olarak çalıştırdığınızda
ne olacağını biliyorsunuz. Peki ya aynı programı bir modül olarak içe aktarırsak
ne olur?

Deneyelim:

```python
>>> import sözlük

Yapmak istediğiniz işlemin numarasını girin:

```

Gördüğünüz gibi, programımız doğrudan çalışmaya başladı. Ama biz bunu
istemiyoruz. Biz istiyoruz ki,sözlük.pybir modül olarak aktarıldığında
çalışmaya başlamasın. Ama biz onun içindeki nitelikleri kullanabilelim.

Bunun içinsözlük.pydosyasında şu değişikliği yapacağız:

```python
sözlük = {"kitap" : "book",
 "bilgisayar" : "computer",
 "programlama": "programming"}

def ara(sözcük):
 hata = "{} kelimesi sözlükte yok!"
 print(sözlük.get(sözcük, hata.format(sözcük)))

def ekle(sözcük, anlam):
 mesaj = "{} kelimesi sözlüğe eklendi!"
 sözlük[sözcük] = anlam
 print(mesaj.format(sözcük))

def sil(sözcük):
 try:
 sözlük.pop(sözcük)
 except KeyError as err:
 print(err, "kelimesi bulunamadı!")
 else:
 print("{} kelimesi sözlükten silindi!".format(sözcük))

#BURAYA DİKKAT!!!
if __name__ == '__main__':
 no = input('Yapmak istediğiniz işlemin numarasını girin: ')
 print('1. Sözlükte kelime ara')
 print('2. Sözlüğe kelime ekle')
 print('3. Sözlükten kelime sil')

 if no == '1':
 sözcük = input('Aradığınız sözcük: ')
 ara(sözcük)

 elif no == '2':
 sözcük = input('Ekleyeceğiniz sözcük: ')
 anlam = input('Eklediğiniz sözcüğün anlamı: ')
 ekle(sözcük, anlam)

 elif no == '3':
 sözcük = input('Sileceğiniz sözcük: ')
 sil(sözcük)

 else:
 print('Yanlış işlem')

```

Gördüğünüz gibi, çok basit birifdeyimi yardımıyla dosyamızın bağımsız bir
program olarak mı çalıştırıldığını yoksa bir modül olarak içe mi aktarıldığını
kontrol ettik. Eğer__name__niteliğinin değeri‘__main__’ise, yani
programımız bağımsız olarak çalıştırılıyorsaifbloğu içindeki kodları
işletiyoruz. Eğer bu niteliğin değeri başka bir şey ise (yani modülün adı ise),
bu durumda programımız bir modül olarak içe aktarılıyor demektir. Bu durumdaifbloğu içindeki kodları çalıştırmıyoruz…

Her şeyin yolunda olup olmadığını kontrol etmek içinsözlükmodülünü içe
aktaralım:

```python
>>> import sözlük

```

Bu kez, tam da istediğimiz şekilde, programımız doğrudan çalışmaya başlamadan
bize içindeki fonksiyonları kullanma imkanı sundu:

```python
>>> dir(sözlük)

['__builtins__', '__cached__', '__doc__', '__file__',
 '__loader__', '__name__', '__package__', '__spec__',
 'ara', 'ekle', 'sil', 'sözlük']

```

#### __loader__ Niteliği

Python’da içe aktarılan bütün modüllerin__loader__adlı bir niteliği
bulunur. Bu nitelik, ilgili modülü içe aktaran mekanizma hakkında bize çeşitli
bilgiler veren birtakım araçlar sunar:

```python
>>> import os
>>> yükleyici = os.__loader__

>>> dir(yükleyici)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',
 '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',
 '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__',
 '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',
 '__str__', '__subclasshook__', '__weakref__', '_cache_bytecode',
 'exec_module', 'get_code', 'get_data', 'get_filename', 'get_source',
 'is_package', 'load_module', 'name', 'path', 'path_mtime', 'path_stats',
 'set_data', 'source_to_code']

```

Mesela, içe aktardığınız bir modülün kaynak kodlarını görüntülemek için bu
modülden yararlanabilirsiniz:

```python
>>> import webbrowser
>>> yükleyici = webbrowser.__loader__
>>> kaynak = yükleyici.get_data(webbrowser.__file__)
>>> kaynak

```

Burada, daha önce öğrendiğimiz__file__niteliğini kullandığımıza dikkat
edin.__loader__niteliğininget_data()adlı metodu, parametre olarak,
sorgulayacağımız modülün dizin adresini ister. Bir modülün dizin adresini__file__niteliği yardımıyla elde edebileceğimizi biliyoruz. Dolayısıyla daget_data()metoduna parametre olarakwebbrowser.__file__kodunu
veriyoruz. Elde ettiğimiz şey ise, sorguladığımız modülün kaynak kodlarını
içeren bir bayt (bytes) veri tipi oluyor.

__loader__, günlük olarak kullanacağımız bir araç değil. Eğer yazdığınız
kodlarda bu niteliğin sunduğu olanaklara ihtiyaç duyarsanız, doğrudan bu nitelik
yerinepkgutiladlı bir modülü kullanabilirsiniz.

#### __spec__ Niteliği

__spec__niteliği de bize modüller hakkında çeşitli bilgiler sunan birtakım
araçları içinde barındırır. Mesela bir modülün ad ve konum bilgilerine ulaşmak
için bu niteliği kullanabiliriz:

```python
>>> import subprocess
>>> adı = subprocess.__spec__.name
>>> konumu = subprocess.__spec__.origin
>>> adı

'subprocess'

>>> konumu

'C:\\Pythonxy\\lib\\subprocess.py'

```

Tıpkı__loader__gibi, bu nitelik de günlük olarak kullanacağımız bir araç
değil. Bu niteliğin içindeki araçların sunduğu bilgileri başka yollardan da elde
edebileceğimizi biliyorsunuz.

#### __package__ Niteliği

Henüz bu niteliğin ne olduğunu anlayacak bilgiye sahip olmadığımız için, bu
niteliğin incelemesini ‘Paketler’ konusunu işlediğimiz bölüme bırakıyoruz.

Böylece modüller konusunu tamamlamış olduk. Bu bölümde modüllere ilişkin epey
bilgi verdik. Eğer modüller konusunda aklınıza yatmayan yerler varsa, hiç
ümitsizliğe kapılmadan okumaya devam edin. Birazdan ‘sınıflar’ konusunu
işlerken, modüllerden ve modüllerin çeşitli özelliklerinden de söz edeceğiz. O
zaman, burada anlamamış olabileceğiniz konuları çok daha net bir şekilde
anlayacaksınız.

## Nesne Tabanlı Programlama (OOP)

Bu bölümde, programlama faaliyetlerimizin önemli bir kısmını oluşturacak olan
nesne tabanlı programlama yaklaşımına bir giriş yaparak, bu yaklaşımın temel
kavramlarından biri olan sınıflara değineceğiz. Bu bölümde amacımız, sınıflar
üzerinden hem nesne tabanlı programlamayı tanımak, hem bu yaklaşıma ilişkin
temel bilgileri edinmek, hem de etrafımızda gördüğümüz nesne tabanlı yapıların
büyük çoğunluğunu anlayabilecek seviyeye gelmek olacaktır. Bu bölümü
tamamladıktan sonra, nesne tabanlı programlamayı orta düzeyde bildiğimizi iddia
edebileceğiz.

### Giriş

Şimdiye kadar Python programlama dili ile ilgili olarak gördüğümüz konulardan
öğrendiğimiz çok önemli bir bilgi var: Aslına bakarsak, bu programlama dilinin
bütün felsefesi, ‘bir kez yazılan kodların en verimli şekilde tekrar tekrar
kullanılabilmesi,’ fikrine dayanıyor.

Şimdi bir geriye dönüp baktığımızda, esasında bu fikrin izlerini ta ilk
derslerimize kadar sürebiliyoruz. Mesela değişkenleri ele alalım. Değişkenleri
kullanmamızdaki temel gerekçe, bir kez yazdığımız bir kodu başka yerlerde
rahatça kullanabilmek. Örneğin,isim='UzunİhsanEfendi'gibi bir
tanımlama yaptıktan sonra, buisimdeğişkeni aracılığıyla‘Uzun İhsan
Efendi’adlı karakter dizisini her defasında tekrar tekrar yazmak zorunda
kalmadan, kodlarımızın her yanında kullanabiliyoruz.

Aynı fikrin fonksiyonlar ve geçen bölümde incelediğimiz modüller için de geçerli
olduğunu bariz bir şekilde görebilirsiniz. Gömülü fonksiyonlar, kendi
tanımladığımız fonksiyonlar, hazır modüller, üçüncü şahıs modülleri hep belli
bir karmaşık süreci basitleştirme, bir kez tanımlanan bir prosedürün tekrar
tekrar kullanılabilmesini sağlama amacı güdüyor.

İşte bu fikir nesne tabanlı programlama ve dolayısıyla ‘sınıf’ (class) adı
verilen özel bir veri tipi için de geçerlidir. Bu bölümde, bunun neden ve nasıl
böyle olduğunu bütün ayrıntılarıyla ele almaya çalışacağız.

Bu arada, İngilizcedeObject Oriented Programmingolarak ifade edilen
programlama yaklaşımı, Türkçede ‘Nesne Tabanlı Programlama’, ‘Nesne Yönelimli
Programlama’ ya da ‘Nesneye Yönelik Programlama’ olarak karşılık bulur. Biz bu
karşılıklardan, adı ‘Nesne Tabanlı Programlama’ olanı tercih edeceğiz.

Unutmadan, nesne tabanlı programlamaya girmeden önce değinmemiz gereken bir şey
daha var. Eğer öğrendiğiniz ilk programlama dili Python ise, nesne tabanlı
programlamayı öğrenmenin (aslında öyle olmadığı halde) zor olduğunu düşünebilir,
bu konuyu biraz karmaşık bulabilirsiniz. Bu durumda da kaçınılmaz olarak kendi
kendinize şu soruyu sorarsınız: Acaba ben nesne tabanlı programlamayı öğrenmek
zorunda mıyım?

Bu sorunun kısa cevabı, eğer iyi bir programcı olmak istiyorsanız nesne tabanlı
programlamayı öğrenmek zorundasınız, olacaktır.

Uzun cevap ise şu:

Nesne tabanlı programlama, pek çok yazılım geliştirme yönteminden yalnızca
biridir. Siz bu yöntemi, yazdığınız programlarda kullanmak zorunda değilsiniz.
Nesne tabanlı programlamadan hiç yararlanmadan da faydalı ve iyi programlar
yazabilirsiniz elbette. Python sizi bu yöntemi kullanmaya asla zorlamaz. Ancak
nesne tabanlı programlama yaklaşımı program geliştirme alanında oldukça yaygın
kullanılan bir yöntemdir. Dolayısıyla, etrafta nesne tabanlı programlama
yaklaşımından yararlanılarak yazılmış pek çok kodla karşılaşacaksınız. Hiç
değilse karşılaştığınız bu kodları anlayabilmek için nesne tabanlı programlamayı
biliyor ve tanıyor olmanız lazım. Aksi halde, bu yöntem kullanılarak geliştirilmiş
programları anlayamazsınız.

Mesela, grafik bir arayüze sahip (yani düğmeli, menülü) programların ezici
çoğunluğu nesne tabanlı programlama yöntemiyle geliştiriliyor. Grafik arayüz
geliştirmenizi sağlayacak araçları tanımanızı, öğrenmenizi sağlayan kitaplar ve
makaleler de bu konuları hep nesne tabanlı programlama yaklaşımı üzerinden
anlatıyor.

> **Uyarı**
> Yalnız bu söylediğimizden, nesne tabanlı programlama sadece grafik
arayüzlü programlar geliştirmeye yarar gibi bir anlam çıkarmamalısınız. Nesne
tabanlı programlama, komut arayüzlü programlar geliştirmek için de kullanışlı
bir programlama yöntemidir.

Uyarı

Yalnız bu söylediğimizden, nesne tabanlı programlama sadece grafik
arayüzlü programlar geliştirmeye yarar gibi bir anlam çıkarmamalısınız. Nesne
tabanlı programlama, komut arayüzlü programlar geliştirmek için de kullanışlı
bir programlama yöntemidir.

Sözün özü, nesne tabanlı programlamadan kaçamazsınız! İyi bir programcı olmak
istiyorsanız, kendiniz hiç kullanmasanız bile, nesne tabanlı programlamayı
öğrenmek zorundasınız. Hem şimdi nesne tabanlı programlamaya dudak bükseniz
bile, bunu kullandıkça ve size sağladığı faydaları gördükçe onu siz de
seveceksiniz…

### Sınıflar

Nesne tabanlı programlamanın temelinde, yukarıdaki giriş bölümünde de adını
andığımız ‘sınıf’ (class) adlı bir kavram bulunur. Bu bölümde, bu temel
kavramı hakkıyla ele almaya çalışacağız.

Peki tam olarak nedir bu sınıf denen şey?

Çok kaba ve oldukça soyut bir şekilde tanımlayacak olursak, sınıflar, nesne
üretmemizi sağlayan veri tipleridir. İşte nesne tabanlı programlama, adından da
anlaşılacağı gibi, nesneler (ve dolayısıyla sınıflar) temel alınarak
gerçekleştirilen bir programlama faaliyetidir.

‘Hiçbir şey anlamadım!’ dediğinizi duyar gibiyim. Çünkü yukarıdaki tanım,
‘nesne’ ne demek, ‘sınıf’ ne anlama geliyor gibi sorulara cevap vermiyor. Yani
programcılık açısından ‘nesne’ ve ‘sınıf’ kelimelerini burada ne anlamda
kullandığımızı, yukarıdaki tanıma bakarak kestiremiyoruz. Eğer siz de bu
fikirdeyseniz okumaya devam edin…

### Sınıflar Ne İşe Yarar?

Buraya gelene kadar Python’da pek çok veri tipi olduğunu öğrendik. Mesela önceki
derslerimizde incelediğimiz listeler, demetler, karakter dizileri, sözlükler ve
hatta fonksiyonlar hep birer veri tipidir. Bu tiplerin, verileri çeşitli
şekillerde evirip çevirmemizi sağlayan birtakım araçlar olduğunu biliyoruz. İşte
sınıflar da, tıpkı yukarıda saydığımız öteki veri tipleri gibi, verileri
manipüle etmemizi sağlayan bir veri tipidir.

Peki bu bölümde ele alacağımız ‘sınıf’ (class) veri tipi ne işe yarar?

Dilerseniz bunu basit bir örnek üzerinde anlatmaya çalışalım.

Diyelim ki, kullanıcının girdiği bir kelimedeki sesli harfleri sayan bir kod
yazmak istiyorsunuz. Bu amacı gerçekleştirebilmek için yazabileceğiniz en basit
kod herhalde şu olacaktır:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

for harf in kelime:
 if harf in sesli_harfler:
 sayaç += 1

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, sayaç))

```

Düzgün bir şekilde çalışan, gayet basit kodlardır bunlar. Ayrıca amacımızı da
kusursuz bir şekilde yerine getirir. Üstelik kodlardaki bütün öğeler tek bir
isim/etki alanı (namespace,scope) içinde bulunduğu için, bunlara erişimde
hiçbir zorluk çekmeyiz. Yani meselasesli_harfler,sayaç,kelime,harf,mesajdeğişkenlerine kodlar içinde her yerden erişebiliriz.

> **Not**
> Eğer isim/etki alanı ile ilgili söylediğimiz şeyi anlamadıysanız
endişe etmeyin. Birazdan vereceğimiz örnekle durumu daha net kavrayacaksınız.

Not

Eğer isim/etki alanı ile ilgili söylediğimiz şeyi anlamadıysanız
endişe etmeyin. Birazdan vereceğimiz örnekle durumu daha net kavrayacaksınız.

Ancak bu kodların önemli bir dezavantajı, kodlarda benimsediğimiz yaklaşımın
genişlemeye pek müsait olmamasıdır. Daha doğrusu, yukarıdaki kodlara yeni kodlar
ekledikçe programımız karmaşık hale gelecek, kodları anlamak zorlaşacaktır.

Kod yapısını biraz olsun rahatlatmak için bazı önlemler alabiliriz. Mesela
kullanıcı tarafından girilen kelimedeki bir harfin sesli olup olmadığını
denetleyen kodları bir fonksiyon içine alarak, o kısmı daha belirgin hale
getirebiliriz:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

for harf in kelime:
 if seslidir(harf):
 sayaç += 1

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, sayaç))

```

Burada, kontrol ettiğimiz harfinsesli_harfleradlı değişken içinde bulunup
bulunmamasına göreTrueveyaFalseçıktısı veren,seslidir()adlı bir
fonksiyon tanımladık. Eğer kontrol ettiğimiz harfsesli_harflerdeğişkeni
içinde geçiyorsa, yani bu bir sesli harf ise,seslidir()fonksiyonuTrueçıktısı verecektir. Aksi durumda ise bu fonksiyondanFalseçıktısı alacağız.
Böylece sesli harf kontrolü yapmak istediğimiz her yerde yalnızcaseslidir()fonksiyonunu kullanabileceğiz. Bu da bize, bir kez yazdığımız kodları tekrar
tekrar kullanma imkanı verecek.

Eğer yukarıdaki kodları daha da genel amaçlı bir hale getirmek istersek, sayacı
artıran kodları da bir fonksiyon içine almayı düşünebiliriz:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

def artır():
 global sayaç
 for harf in kelime:
 if seslidir(harf):
 sayaç += 1
 return sayaç

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, artır()))

```

Hatırlarsanız, ilk başta yazdığımız kodların en büyük avantajının, kodlarda
geçen bütün öğelerin tek bir isim/etki alanında bulunması olduğunu söylemiştik.
Bu sayede bütün öğelere her yerden erişebiliyorduk. Yukarıdaki kodlarda ise
birden fazla isim/etki alanı var:
1. sesli_harfler,sayaç,kelimevemesajdeğişkenlerinin bulunduğu
global isim/etki alanı.
1. seslidir()fonksiyonunun lokal isim/etki alanı.
1. artır()fonksiyonunun lokal isim/etki alanı.

sesli_harfler,sayaç,kelimevemesajdeğişkenlerinin bulunduğu
global isim/etki alanı.

seslidir()fonksiyonunun lokal isim/etki alanı.

artır()fonksiyonunun lokal isim/etki alanı.

Bildiğiniz gibi, global isim alanında bulunan değişkenlere her yerdenulaşabiliyoruz. Ancak bunları her yerdendeğiştiremiyoruz. Yani mesela
global isim alanında bulunansayaçdeğişkeninin değerini,seslidir()fonksiyonu içinden görüntüleyebiliriz.

Bunu teyit edelim:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

def seslidir(harf):
 print('sayaç değişkeninin değeri şu anda: ', sayaç)
 return harf in sesli_harfler

def artır():
 global sayaç
 for harf in kelime:
 if seslidir(harf):
 sayaç += 1
 return sayaç

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, artır()))

```

Gördüğünüz gibi, global isim alanındakisayaçdeğişkeninin değeriniseslidir()fonksiyonu içinde kullanabildik. Ama eğer bu değişken üzerinde
değişiklik yapacaksak ilave adımlar atmak zorundayız. Dolayısıyla, meselaartır()fonksiyonunun etki alanından, global etki alanındakisayaçdeğişkeni üzerinde değişiklik yapabilmek içinglobaldeyimini kullanmamız
gerekiyor. Bu şekilde, global isim alanında bulunansayaçadlı değişkenin
değerini artırabiliyoruz.

Dikkat ederseniz,artır()fonksiyonunda iki tane global değişken var:sayaçvekelime. Ama biz bunlardan yalnızcasayaçdeğişkenini global
olarak belirledik. Öbür global değişkenimizkelimeiçin ise bu işlemi
yapmadık. Çünkükelimeadlı değişkeni değiştirmek gibi bir niyetimiz yok. Biz
bu değişkeni sadece kullanmakla yetiniyoruz. O yüzden bu değişkeni global olarak
belirlemek zorunda değiliz.

Ancak bildiğiniz gibi,globaldeyimini kullanmak pek tavsiye edilen bir şey
değil. Eğer siz de bu deyimi kullanmak istemezseniz, yukarıdaki kodları şu
şekilde yazmayı yeğleyebilirsiniz:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

def artır(sayaç):
 for harf in kelime:
 if seslidir(harf):
 sayaç += 1
 return sayaç

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, artır(sayaç)))

```

Gördüğünüz gibi, bu kodlardaglobaldeyimini kullanmak yerine,artır()fonksiyonuna verdiğimizsayaçparametresi üzerinden global isim alanıyla
iletişim kurarak,sayaçdeğişkenini manipüle edebildik. Sadece değerini
kullandığımız global değişkenkelimeiçin ise özel bir şey yapmamıza gerek
kalmadı.

Bu arada, tabii ki,artır()fonksiyonunda parametre olarak kullandığımız
kelimesayaçolmak zorunda değil. Kodlarımızı mesela şöyle de yazabilirdik:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

kelime = input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

def artır(n):
 for harf in kelime:
 if seslidir(harf):
 n += 1
 return n

mesaj = '{} kelimesinde {} sesli harf var.'
print(mesaj.format(kelime, artır(sayaç)))

```

Önemli olan,artır()fonksiyonunun, bizim global isim alanıyla iletişim
kurmamızı sağlayacak bir parametre alması. Bu parametrenin adının ne olduğunun
bir önemi yok.

Yukarıdaki kodlarda birkaç değişiklik daha yaparak, bu kodları iyice
genişletilebilir hale getirebiliriz:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

def kelime_sor():
 return input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

def artır(sayaç, kelime):
 for harf in kelime:
 if seslidir(harf):
 sayaç += 1
 return sayaç

def ekrana_bas(kelime):
 mesaj = "{} kelimesinde {} sesli harf var."
 print(mesaj.format(kelime, artır(sayaç, kelime)))

def çalıştır():
 kelime = kelime_sor()
 ekrana_bas(kelime)

çalıştır()

```

Bu kodlarda, fonksiyonlara verdiğimiz parametreler yardımıyla, farklı
fonksiyonların lokal etki alanlarında yer alan öğeler arasında nasıl iletişim
kurduğumuza dikkat edin. Bir önceki kodlarda global etki alanında bulunankelimedeğişkenini bu kezçalıştır()fonksiyonunun lokal etki alanı içine
yerleştirdiğimiz için,artır()fonksiyonu içindekikelimedeğişkeni boşa
düştü. O yüzden, bu değişkeniartır()fonksiyonuna bir parametre olarak
verdik veekrana_bas()fonksiyonu içinde bu fonksiyonu çağırırken, hemsayaçhem dekelimeargümanlarını kullandık.

Ayrıca, kullanıcıya kelime sorup, aldığı kelimeyi ekrana basan kod parçalarını,
yani programımızı başlatan kodlarıçalıştır()başlığı altında toplayarak bu
kısmı tam anlamıyla ‘modüler’, yani esnek ve takılıp çıkarılabilir bir hale
getirdik.

Gördüğünüz gibi, yazdığımız kodların olabildiğince anlaşılır ve yönetilebilir
olmasını sağlayabilmek için, bu kodları küçük birtakım birimlere böldük. Bu
şekilde hem hangi işlevin nerede olduğunu bulmak kolaylaştı, hem kodların
görünüşü daha anlaşılır oldu, hem de bu kodlara ileride yeni özellikler eklemek
basitleşti. Unutmayın, bir programcının görevi yalnızca çalışan kodlar yazmak
değildir. Programcı aynı zamanda kodlarının okunaklılığını artırmak ve bakımını
kolaylaştırmakla da yükümlüdür.

Bu bakımdan, programcı ile kod arasındaki ilişkiyi, yazar ile kitap arasındaki
ilişkiye benzetebilirsiniz. Tıpkı bir programcı gibi, yazarın da görevi aklına
gelenleri bir kağıda gelişigüzel boca etmek değildir. Yazar, yazdığı kitabın
daha anlaşılır olmasını sağlamak için kitabına bir başlık atmalı, yazdığı
yazıları alt başlıklara ve paragraflara bölmeli, ayrıca noktalama işaretlerini
yerli yerinde kullanarak yazılarını olabildiğince okunaklı hale getirmelidir.
Bir ana başlığı ve alt başlıkları olmayan, sadece tek bir büyük paragraftan
oluşan, içinde hiçbir noktalama işaretinin kullanılmadığı bir makaleyi okumanın
veya bu makaleye sonradan yeni bir şeyler eklemenin ne kadar zor olduğunu
düşünün. İşte aynı şey bir programcının yazdığı kodlar için de geçerlidir. Eğer
yazdığınız kodları anlaşılır birimlere bölmeden ekrana yığarsanız bu kodları ne
başkaları okuyup anlayabilir, ne de siz ileride bu kodlara yeni işlevler
ekleyebilirsiniz.

Python programlama dili, kodlarınızı olabildiğince anlaşılır, okunaklı ve
yönetilebilir hale getirmeniz için size pek çok araç sunar. Önceki derslerde
gördüğümüz değişkenler, fonksiyonlar ve modüller bu araçlardan yalnızca
birkaçıdır. İşte bu bölümde inceleyeceğimiz sınıflar da kodlarımızı
ehlileştirmek için kullanacağımız son derece faydalı araçlardır.

Birazdan, ‘sınıf’ denen bu faydalı araçları enine boyuna inceleyeceğiz. Ama
gelin isterseniz, anlatmaya devam etmeden önce, verdiğimiz son kodları biraz
daha kurcalayalım.

Hatırlarsanız, geçen bölümde, yazdığımız Python kodlarının aynı zamanda hem
bağımsız bir program olarak hem de bir modül olarak kullanılabileceğini
söylemiştik.

Mesela, yukarıdaki kodlarısayac.pyadlı bir dosyaya kaydettiğimizi
varsayarsak, bu programı komut satırı üzerindenpythonsayac.pygibi bir
kodla çalıştırabiliyoruz. Biz bu programı bu şekilde komut satırı üzerinden veya
üzerine çift tıklayarak çalıştırdığımızda, bu kodları bağımsız bir program
olarak çalıştırmış oluyoruz. Gelin bir de bu kodları bir modül olarak nasıl içe
aktaracağımızı inceleyelim.

Şimdi,sayac.pyprogramının bulunduğu dizin altında Python komut satırını
başlatalım ve orada şu komutu verereksayacmodülünü içe aktaralım:

```python
>>> import sayac

```

Bu komutu verdiğimiz anda,sayac.pyprogramı çalışmaya başlayacaktır. Ancak
bizim istediğimiz şey bu değil. Bizsayac.pyprogramının çalışmaya başlamasını
istemiyoruz. Bizim istediğimiz şey, busayac.pydosyasını bağımsız bir program
olarak değil, bir modül olarak kullanmak ve böylece bu modül içindeki nitelik ve
fonksiyonlara erişmek. Tam bu noktada şöyle bir soru aklımıza geliyor: Acaba bir
insan neden bir programı modül olarak içe aktarmak istiyor olabilir?

Bir Python dosyasına modül olarak erişmek istemenizin birkaç sebebi olabilir.
Mesela bir program yazıyorsunuzdur ve amacınız yazdığınız kodların düzgün
çalışıp çalışmadığını test etmektir. Bunun için, programınızı etkileşimli kabuk
ortamına bir modül olarak aktarıp, bu modülün test etmek istediğiniz kısımlarını
tek tek çalıştırabilirsiniz. Aynı şekilde, kendi yazdığınız veya başkası
tarafından yazılmış bir program içindeki işlevsellikten başka bir program içinde
de yararlanmak istiyor olabilirsiniz. İşte bunun için de, ilgili programı, başka
bir program içinden çağırarak, yani o programı öteki program içine bir modül
olarak aktararak, ilgili modül içindeki işlevleri kullanabilirsiniz.

Diyelim ki biz, yukarıda yazdığımızsayac.pyadlı dosya içindeki kodların
düzgün çalışıp çalışmadığını kontrol etmek istiyoruz. Bunun içinsayac.pydosyasındaki kodlarda şu değişikliği yapalım:

```python
sesli_harfler = 'aeıioöuü'
sayaç = 0

def kelime_sor():
 return input('Bir kelime girin: ')

def seslidir(harf):
 return harf in sesli_harfler

def artır(sayaç, kelime):
 for harf in kelime:
 if seslidir(harf):
 sayaç += 1
 return sayaç

def ekrana_bas(kelime):
 mesaj = "{} kelimesinde {} sesli harf var."
 print(mesaj.format(kelime, artır(sayaç, kelime)))

def çalıştır():
 kelime = kelime_sor()
 ekrana_bas(kelime)

if __name__ == '__main__':
 çalıştır()

```

Gördüğünüz gibi, buradaçalıştır()fonksiyonunuif__name__=='__main__'bloğuna aldık. Buna göre, eğer__name__niteliğinin değeri‘__main__’iseçalıştır()fonksiyonu işlemeye başlayacak. Aksi halde
herhangi bir şey olmayacak.

Şimdisayac.pyprogramını komut satırı üzerindenpythonsayac.pygibi bir
komutla çalıştırın. Programınız normal bir şekilde çalışacaktır. Çünkü,
bildiğiniz gibi, bir Python programı bağımsız bir program olarak
çalıştırıldığında__name__niteliğinin değeri‘__main__’olur.
Dolayısıyla daçalıştır()fonksiyonu işlemeye başlar.

Şimdi de etkileşimli kabuğu tekrar açın ve şu komutu vererek modülü içe
aktarın:

```python
>>> import sayac

```

Bu defa programımız çalışmaya başlamadı. Çünkü bu kez, programımızı bir modül
olarak içe aktardığımız için,__name__niteliğinin değeri‘__main__’değil,
ilgili modülün adı oldu (yani bizim örneğimizdesayac).

Böylece__name__niteliğinin farklı durumlarda farklı bir değere sahip
olmasından yararlanarak, programınızın farklı durumlarda farklı tepkiler
vermesini sağlamış olduk.

sayacmodülünü içe aktardıktan sonra, bu modülün içinde neler olduğunu nasıl
kontrol edebileceğinizi biliyorsunuz:

```python
>>> dir(sayac)

['__builtins__', '__cached__', '__doc__', '__file__', '__loader__',
 '__name__', '__package__', '__spec__', 'artır', 'ekrana_bas',
 'kelime_sor', 'sayaç', 'sesli_harfler', 'seslidir', 'çalıştır']

```

Bu listede,sayacmodülüne ait bütün nitelik ve fonksiyonları görebiliyoruz.
Bunları, başka modüllerde olduğu gibi kullanma imkanına sahibiz.

Mesela bu listede görünenseslidir()fonksiyonunu kullanalım:

```python
>>> sayac.seslidir('ö')

True

>>> sayac.seslidir('ç')

False

```

Gördüğünüz gibi,sayac.pyiçinde tanımladığımızseslidir()fonksiyonunu,
rastgele harflerin birer sesli harf olup olmadığını denetlemek için de
kullanabiliyoruz. Bu şekilde aynı zamandaseslidir()fonksiyonunun düzgün
bir şekilde çalışıp çalışmadığını, sesli olan ve olmayan harfleri başarılı bir
şekilde birbirinden ayırt edip edemediğini de test etmiş oluyoruz.

Devam edelim:

```python
>>> sayac.sesli_harfler

'aeıioöuü'

```

Modüllerin ne kadar faydalı araçlar olabileceğini bu örnek gayet net bir şekilde
gösteriyor. Eğer ileride sesli harfleri kullanmamızı gerektiren başka bir
program yazacak olursak, bu harfleri yeniden tanımlamak yerine,sayac.pydosyasından içe aktarabiliriz.

Bütün bu örnekler sayesinde, sınıfları daha iyi anlamamızı sağlayacak altyapıyı
oluşturmuş, bir yandan da eski bilgilerimizi pekiştirmiş olduk. Dilerseniz,
sınıfları anlatmaya geçmeden önce, yukarıda verdiğimiz kodları sınıflı bir yapı
içinde nasıl ifade edebileceğimizi de görelim.

Elbette aşağıdaki kodları anlamanızı şu aşamada sizden beklemiyoruz. Bu bölümün
sonuna vardığımızda, zihninizde her şey berraklaşmış olacak. Siz şimdilik sadece
aşağıdaki kodlara bakın ve hem okunaklılık hem de yönetilebilirlik bakımından bu
kodların bize ne gibi faydalar sağlıyor olabileceğine dair fikir yürütmeye
çalışın. Anlamadığınız kısımlar olursa bunları geçin gitsin. Anladığınız
kısımlar ise yanınıza kâr kalsın.

```python
class HarfSayacı:
 def __init__(self):
 self.sesli_harfler = 'aeıioöuü'
 self.sayaç = 0

 def kelime_sor(self):
 return input('Bir kelime girin: ')

 def seslidir(self, harf):
 return harf in self.sesli_harfler

 def artır(self):
 for harf in self.kelime:
 if self.seslidir(harf):
 self.sayaç += 1
 return self.sayaç

 def ekrana_bas(self):
 mesaj = "{} kelimesinde {} sesli harf var."
 sesli_harf_sayısı = self.artır()
 print(mesaj.format(self.kelime, sesli_harf_sayısı))

 def çalıştır(self):
 self.kelime = self.kelime_sor()
 self.ekrana_bas()

if __name__ == '__main__':
 sayaç = HarfSayacı()
 sayaç.çalıştır()

```

Hakkında herhangi bir fikre sahip olmadığınız bir kod parçasını anlamanın en iyi
yolu, anlamadığınız kısmı kodlardan çıkarıp, kodları bir de o şekilde
çalıştırmaktır. Mesela yukarıdaki__init__,selfveclassgibi öğelerin
ismini değiştirin, bunları kodlardan çıkarın veya başka bir yere koyun. Elde
ettiğiniz sonuçları gözlemleyerek bu kodlar hakkında en azından bir fikir sahibi
olabilirsiniz.

Gelin isterseniz, henüz yukarıdaki kodları anlayabilecek kadar sınıf bilgisine
sahip olmasak da, bu kodları şöyle bir üstünkörü gözden geçirerek, bu kodların
programcılık deneyimimiz açısından bize ne gibi bir katkı sunuyor olabileceğini
anlamaya çalışalım.

Yukarıdaki kodlarda dikkatimizi çeken ilk şey, bu kodların son derece derli
toplu görünüyor olmasıdır. Öyle ki,HarfSayacıadlı sınıf içindeki
fonksiyonlar sanki ipe dizilir gibi dizilmiş.

HarfSayacıadlı sınıf ile bu sınıf yapısı içinde yer alan fonksiyonlar
arasındaki ilişki gayet net bir şekilde görünüyor. Eğer ileride bu sayaca yeni
bir işlev eklemek istersek, neyi nereye yerleştirmemiz gerektiği çok açık.
Mesela ilerde bu kodlara sesli harflerle birlikte bir de sessiz harf denetim
işlevi eklemek istersek, gerekli değişiklikleri kolayca yapabiliriz:

```python
class HarfSayacı:
 def __init__(self):
 self.sesli_harfler = 'aeıioöuü'
 self.sessiz_harfler = 'bcçdfgğhjklmnprsştvyz'
 self.sayaç_sesli = 0
 self.sayaç_sessiz = 0

 def kelime_sor(self):
 return input('Bir kelime girin: ')

 def seslidir(self, harf):
 return harf in self.sesli_harfler

 def sessizdir(self, harf):
 return harf in self.sessiz_harfler

 def artır(self):
 for harf in self.kelime:
 if self.seslidir(harf):
 self.sayaç_sesli += 1
 if self.sessizdir(harf):
 self.sayaç_sessiz += 1
 return (self.sayaç_sesli, self.sayaç_sessiz)

 def ekrana_bas(self):
 sesli, sessiz = self.artır()
 mesaj = "{} kelimesinde {} sesli {} sessiz harf var."
 print(mesaj.format(self.kelime, sesli, sessiz))

 def çalıştır(self):
 self.kelime = self.kelime_sor()
 self.ekrana_bas()

if __name__ == '__main__':
 sayaç = HarfSayacı()
 sayaç.çalıştır()

```

Ayrıca sınıflı kodlarda, farklı etki alanları ile iletişim kurmak, sınıfsız
kodlara kıyasla daha zahmetsizdir. Sınıflı ve sınıfsız kodlarda fonksiyonlara
verdiğimiz parametreleri birbirleri ile kıyaslayarak bu durumu kendiniz de
görebilirsiniz.

Sınıflı yapıların daha pek çok avantajlı yönü vardır. İşte biz bu bölümde
bunları size tek tek göstermeye çalışacağız.

### Sınıf Tanımlamak

Nesne tabanlı programlama yaklaşımı, özellikle birtakım ortak niteliklere ve
davranış şekillerine sahip gruplar tanımlamak gerektiğinde son derece
kullanışlıdır. Mesela şöyle bir örnek düşünün: Diyelim ki çalıştığınız
işyerinde, işe alınan kişilerin kayıtlarını tutan bir veritabanınız var. Bir
kişi işe alındığında, o kişiye dair belli birtakım bilgileri bu veritabanına
işliyorsunuz. Mesela işe alınan kişinin adı, soyadı, unvanı, maaşı ve buna
benzer başka bilgiler…

Çalışmaya başlayacak kişileri temsil eden bir ‘Çalışan’ grubunu, bu grubun
nitelikleri ile faaliyetlerini tutacak yapıyı ve bu grubun bütün öğelerinin
taşıyacağı özellikleri nesne tabanlı programlama yaklaşımı ile kolayca
kodlayabilirsiniz.

Aynı şekilde, mesela yazdığınız bir oyun programı için, bir ‘Asker’ grubunu
nesne tabanlı programlama mantığı içinde tanımlayarak, bu grubun her bir
üyesinin sahip olacağı nitelikleri, kabiliyetleri ve davranış şekillerini
kodlayabilir; mesela askerlerin sağa sola nasıl hareket edeceklerini, hangi
durumlarda puan/enerji/güç kazanacaklarını veya kaybedeceklerini, bir asker ilk
kez oluşturulduğunda hangi özellikleri taşıyacağını ve aklınıza gelebilecek
başka her türlü özelliği tek tek belirleyebilirsiniz.

Amacınız ne olursa olsun, atmanız gereken ilk adım, ilgili sınıfı tanımlamak
olmalıdır. Zira fonksiyonlarda olduğu gibi, bir sınıfı kullanabilmek için de
öncelikle o sınıfı tanımlamamız gerekiyor. Mesela, yukarıda bahsettiğimiz işe
uygun olarak,Çalışanadlı bir sınıf tanımlayalım:

```python
class Çalışan:
 pass

```

Yukarıdaki, boş bir sınıf tanımıdır. Hatırlarsanız fonksiyonları tanımlamak içindefadlı bir ifadeden yararlanıyorduk. İşte sınıfları tanımlamak için declassadlı bir ifadeden yararlanıyoruz. Bu ifadenin ardından gelenÇalışankelimesi ise bu sınıfın adıdır.

Eğer arzu ederseniz, yukarıdaki sınıfı şu şekilde de tanımlayabilirsiniz:

```python
class Çalışan():
 pass

```

Yani sınıf adından sonra parantez kullanmayabileceğiniz gibi, kullanabilirsiniz
de. Her ikisi de aynı kapıya çıkar. Ayrıca sınıf adlarında, yukarıda olduğu gibi
büyük harf kullanmak ve birden fazla kelimeden oluşan sınıf adlarının ilk
harflerini büyük yazıp bunları birleştirmek adettendir. Yani:

```python
class ÇalışanSınıfı():
 pass

```

Veya parantezsiz olarak:

```python
class ÇalışanSınıfı:
 pass

```

Gördüğünüz gibi sınıf tanımlamak fonksiyon tanımlamaya çok benziyor.
Fonksiyonları tanımlarken nasıldefdeyimini kullanıyorsak, sınıfları
tanımlamak için declassdeyimini kullanıyoruz.

Örnek olması açısından, yukarıda bahsettiğimiz ‘Asker’ grubu için de bir sınıf
tanımlayalım:

```python
class Asker:
 pass

```

… veya:

```python
class Asker():
 pass

```

Python’da sınıfları nasıl tanımlayacağımızı öğrendiğimize göre, bu sınıfları
nasıl kullanacağımızı incelemeye geçebiliriz.

### Sınıf Nitelikleri

Yukarıda, boş bir sınıfı nasıl tanımlayacağımızı öğrendik. Elbette
tanımladığımız sınıflar hep boş kalmayacak. Bu sınıflara birtakım nitelikler
ekleyerek bu sınıfları kullanışlı hale getirebiliriz. Mesela:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'

```

Buradaunvanıvekabiliyetleriadlı iki değişken tanımladık. Teknik
dilde bu değişkenlere ‘sınıf niteliği’ (class attribute) adı verilir.

Biraz önce, sınıf tanımlamayı öğrenirken sınıf tanımlamanın fonksiyon
tanımlamaya çok benzediğini söylemiştik. Gerçekten de öyledir. Ancak
fonksiyonlarla sınıflar arasında (başka farkların dışında) çok önemli bir fark
bulunur. Bildiğiniz gibi, bir fonksiyonu tanımladıktan sonra, o fonksiyonun
işlemeye başlaması için, o fonksiyonun mutlaka çağrılması gerekir. Çağrılmayan
fonksiyonlar çalışmaz. Mesela yukarıdaki sınıfa benzeyen şöyle bir fonksiyon
tanımladığımızı düşünün:

```python
def çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'

 print(kabiliyetleri)
 print(unvanı)

```

Bu fonksiyonun çalışması için, kodlarımızın herhangi bir yerinde bu fonksiyonu
çağırmamız lazım:

```python
çalışan()

```

Ancak sınıflar farklıdır. Bunu görmek için yukarıdaki fonksiyonu bir sınıf
haline getirelim:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'

 print(kabiliyetleri)
 print(unvanı)

```

Bu kodları meseladeneme.pyadlı bir dosyaya kaydedip çalıştırdığınızda,unvanıvekabiliyetlerideğişkenlerinin değerinin ekrana
basıldığını göreceksiniz.

Aynı şey, yukarıdaki kodların bir modül olarak içe aktarıldığı durumlarda da
geçerlidir. Yani yukarıdaki kodlarındeneme.pyadlı bir dosyada bulunduğunu
varsayarsak, bu modülü şu komutla içe aktardığımızda, sınıfı kodlarımızın
herhangi bir yerinde çağırmamış olmamıza rağmen sınıf içeriği çalışmaya
başlayacaktır:

```python
>>> import deneme

[]
işçi

```

Eğer sınıf niteliklerinin ne zaman çalışacağını kendiniz kontrol etmek
isterseniz, bu nitelikleri sınıf dışında kullanabilirsiniz:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'

print(Çalışan.kabiliyetleri)
print(Çalışan.unvanı)

```

BuradaÇalışan()adlı sınıfın niteliklerine nasıl eriştiğimize dikkat edin.
Gördüğünüz gibi, sınıf niteliklerine erişmek için doğrudan sınıfın adını
parantezsiz bir şekilde kullanıyoruz. Eğer sınıf adlarını parantezli bir şekilde
yazarsak başka bir şey yapmış oluruz. Bundan biraz sonra bahsedeceğiz. Biz
şimdilik, sınıf niteliklerine erişmek için sınıf adlarını parantezsiz
kullanmamız gerektiğini bilelim yeter.

Hatırlarsanız, bu bölüme başlarken, nesne tabanlı programlama yaklaşımının,
özellikle birtakım ortak niteliklere ve davranış şekillerine sahip gruplar
tanımlamak gerektiğinde son derece kullanışlı olduğunu söylemiştik. Gelin
isterseniz yukarıdakiÇalışan()sınıfına birkaç nitelik daha ekleyerek bu
iddiamızı destekleyelim:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'
 maaşı = 1500
 memleketi = ''
 doğum_tarihi = ''

```

Burada bellikabiliyetleri,unvanı,maaşı,memleketivedoğum_tarihiolan birÇalışan()sınıfı tanımladık. Yani ‘Çalışan’ adlı bir grubun ortak
niteliklerini belirledik. Elbette her çalışanın memleketi ve doğum tarihi farklı
olacağı için sınıf içinde bu değişkenlere belli bir değer atamadık. Bunların
birer karakter dizisi olacağını belirten bir işaret olması için yalnızcamemleketivedoğum_tarihiadlı birer boş karakter dizisi tanımladık.

Yukarıda tanımladığımız sınıf niteliklerine, doğrudan sınıf adını kullanarak
erişebileceğimizi biliyorsunuz:

```python
print(Çalışan.maaşı)
print(Çalışan.memleketi)
print(Çalışan.doğum_tarihi)

```

Eğer isterseniz bu sınıfa yeni sınıf nitelikleri de ekleyebilirsiniz:

```python
Çalışan.isim = 'Ahmet'
Çalışan.yaş = 40

```

Gayet güzel…

Ancak burada şöyle bir sorun var: Biz yukarıdaki gibi doğrudan sınıf adını
kullanarak öğelere eriştiğimizde kodlarımız tek kullanımlık olmuş oluyor. Yani
bu şekilde ancak tek birÇalışan()nesnesi (‘nesne’ kavramına ilerde
değineceğiz), dolayısıyla da tek bir çalışan oluşturma imkanı elde edebiliyoruz.
Ama biz, mantıken, sınıf içinde belirtilen özellikleri taşıyan, Ahmet, Mehmet,
Veli, Selim, Selin ve buna benzer, istediğimiz sayıda çalışan
oluşturabilmeliyiz. Peki ama nasıl?

### Sınıfların Örneklenmesi

Biraz önce şöyle bir sınıf tanımlamıştık:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'
 maaşı = 1500
 memleketi = ''
 doğum_tarihi = ''

```

Daha önce de söylediğimiz gibi, sınıflar belli birtakım ortak özelliklere sahip
gruplar tanımlamak için biçilmiş kaftandır. Burada da, her bir çalışan için ortak
birtakım nitelikler tanımlayanÇalışan()adlı bir sınıf oluşturduk. Ancak
elbette bu sınıfın bir işe yarayabilmesi için, biraz önce de değindiğimiz gibi,
bu sınıfı temel alarak, bu sınıfta belirtilen nitelikleri taşıyan birden fazla
sınıf üyesi meydana getirebilmemiz lazım.

Şimdi dikkatlice bakın:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'
 maaşı = 1500
 memleketi = ''
 doğum_tarihi = ''

ahmet = Çalışan()

```

Burada sınıfımızıahmetadlı bir değişkene atadık.

İşte bu işleme teknik dilde ‘örnekleme’ veya ‘örneklendirme’ (instantiation)
adı verilir. Bu işlemi fonksiyon çağırma ile kıyaslayabiliriz: Python
programlama dilinde bir fonksiyonu kullanışlı hale getirme işlemine ‘çağırma’,
bir sınıfı kullanışlı hale getirme işlemine ise ‘örnekleme’ adı veriyoruz.

Örnekleme kavramını daha iyi anlayabilmek için başka bir sınıf daha
oluşturalım:

```python
class Asker():
 rütbesi = 'Er'
 standart_teçhizat = ['G3', 'kasatura', 'süngü', 'el bombası']
 gücü = 60
 birliği = ''

```

Burada da belli birtakım niteliklere sahipAsker()adlı bir sınıf
tanımladık. Bu sınıfın niteliklerine doğrudan sınıf adını kullanarak
erişebileceğimizi biliyorsunuz:

```python
Asker.rütbesi
Asker.standart_teçhizat
Asker.gücü
Asker.birliği

```

Ama bu sınıfın bir işe yarayabilmesi için, bu sınıfa bir ‘referans’ oluşturmamız
lazım, ki daha sonra bu sınıfa bu referans üzerinden atıfta bulunabilelim. Yani
bu sınıfı çağırırken buna bir isim vermeliyiz, ki bu isim üzerinden sınıfa ve
niteliklerine erişebilelim.

Mesela bu sınıfa daha sonra atıfta bulunabilmek amacıyla, bu sınıf içinmehmetadlı bir referans noktası oluşturalım:

```python
mehmet = Asker()

```

İşte, teknik olarak ifade etmemiz gerekirse, sınıfları bir isme atama işlemine
örnekleme (veya örneklendirme) adı veriyoruz.

Buradaahmetvemehmet, ait oldukları sınıfların birer ‘sureti’ veya başka
bir deyişle ‘örneği’dir (instance).mehmet’in,Asker()adlı sınıfın bir
örneği,ahmet’inseÇalışan()adlı sınıfın bir örneği olması demek,mehmet’in veahmet’in, ilgili sınıfların bütün özelliklerini taşıyan birer
üyesi olması demektir.

> **Uyarı**
> Bu bağlamda ‘örnek’ kelimesini ‘misal’ anlamında kullanmadığımıza
özellikle dikkatinizi çekmek isterim. Türkçede ‘örnek’ kelimesi ile
karşıladığımız ‘instance’ kavramı, nesne tabanlı programlamanın önemli teknik
kavramlarından biridir.

Uyarı

Bu bağlamda ‘örnek’ kelimesini ‘misal’ anlamında kullanmadığımıza
özellikle dikkatinizi çekmek isterim. Türkçede ‘örnek’ kelimesi ile
karşıladığımız ‘instance’ kavramı, nesne tabanlı programlamanın önemli teknik
kavramlarından biridir.

Biz bir sınıfı çağırdığımızda (yaniAsker()veyaÇalışan()komutunu
verdiğimizde), o sınıfı örneklemiş oluyoruz. Örneklediğimiz sınıfı bir değişkene
atadığımızda ise o sınıfın bir örneğini çıkarmış, yani o sınıfın bütün
özelliklerini taşıyan bir üye meydana getirmiş oluyoruz.

Bu arada, elbette bu teknik terimleri ezberlemek zorunda değilsiniz. Ancak nesne
tabanlı programlamaya ilişkin metinlerde bu terimlerle sık sık
karşılaşacaksınız. Eğer bu terimlerin anlamını bilirseniz, okuduğunuz şey
zihninizde daha kolay yer edecek, aksi halde, sürekli ne demek olduğunu
bilmediğiniz terimlerle karşılaşmak öğrenme motivasyonunuza zarar verecektir.

Esasında nesne tabanlı programlamayı öğrencilerin gözünde zor kılan şey, bu
programlama yaklaşımının özünden ziyade, içerdiği terimlerdir. Gerçekten de
nesne tabanlı programlama, pek çok çetrefilli teknik kavramı bünyesinde
barındıran bir sistemdir. Bu nedenle öğrenciler bu konuya ilişkin bir şeyler
okurken, muğlak kavramların arasında kaybolup konunun esasını gözden
kaçırabiliyor. Eğer nesne tabanlı programlamaya ilişkin kavramları hakkıyla
anlarsanız, bu yaklaşıma dair önemli bir engeli aşmışsınız demektir.

Öte yandan, nesne tabanlı programlamaya ilişkin kavramları anlamak sadece Türkçe
okuyup yazanlar için değil, aynı zamanda İngilizce bilip ilgili makaleleri özgün
dilinden okuyanlar için de zor olabilir. O yüzden biz bu bölümde, kavramların
Türkçeleri ile birlikte İngilizcelerini de vererek, İngilizce bilenlerin özgün
metinleri okurken konuyu daha iyi anlamalarını sağlamaya çalışacağız.
Dolayısıyla, bir kavramdan bahsederken onun aslının ne olduğunu da belirtmemiz,
İngilizce bilip de konuyu daha ileri bir düzeyde araştırmak isteyenlere kolaylık
sağlayacaktır.

Ne diyorduk? Eğer elimizde şöyle bir kod varsa:

```python
class Sipariş():
 firma = ''
 miktar = 0
 sipariş_tarihi = ''
 teslim_tarihi = ''
 stok_adedi = 0

jilet = Sipariş()

```

Buradaclass, sınıfı tanımlamamıza yarayan bir öğedir. Tıpkı fonksiyonlardakidefgibi, sınıfları tanımlamak için declassadlı bir parçacığı
kullanıyoruz.

Siparişise, sınıfımızın adı oluyor. Biz sınıfımızın adını parantezli veya
parantezsiz olarak kullanma imkanına sahibiz.

Sınıfın gövdesinde tanımladığımız şu değişkenler birer sınıf niteliğidir (class
attribute):

```python
firma = ''
miktar = 0
sipariş_tarihi = ''
teslim_tarihi = ''
stok_adedi = 0

```

jilet=Sipariş()komutunu verdiğimizde ise, biraz önce tanımladığımız
sınıfı örnekleyip (instantiation), bunujiletadlı bir örneğe (instance)
atamış oluyoruz. Yanijilet,Sipariş()adlı sınıfın bir örneği olmuş
oluyor. Bir sınıftan istediğimiz sayıda örnek çıkarabiliriz:

```python
kalem = Sipariş()
pergel = Sipariş()
çikolata = Sipariş()

```

Bu şekildeSipariş()sınıfını üç kez örneklemiş, yani bu sınıfın bütün
özelliklerini taşıyan üç farklı üye meydana getirmiş oluyoruz.

Bu sınıf örneklerini kullanarak, ilgili sınıfın niteliklerine (attribute)
erişebiliriz:

```python
kalem = Sipariş()

kalem.firma
kalem.miktar
kalem.sipariş_tarihi
kalem.teslim_tarihi
kalem.stok_adedi

```

Bildiğiniz gibi, eriştiğimiz bu nitelikler birer sınıf niteliği olduğu için,
sınıfı hiç örneklemeden, bu niteliklere doğrudan sınıf adı üzerinden de
erişebilirdik:

```python
Sipariş.firma
Sipariş.miktar
Sipariş.sipariş_tarihi
Sipariş.teslim_tarihi
Sipariş.stok_adedi

```

Özellikle, örneklenmesine gerek olmayan, yalnızca bir kez çalışacak sınıflarda,
sınıf niteliklerine örnekler üzerinden değil de doğrudan sınıf adı üzerinden
erişmek daha pratik olabilir. Ancak yukarıda olduğu gibi, tek bir sınıftan,
ortak niteliklere sahip birden fazla üye oluşturmamız gereken durumlarda sınıfı
bir örneğe atayıp, sınıf niteliklerine bu örnek üzerinden erişmek çok daha
akıllıca olacaktır. Ancak her koşulda sınıfların niteliklerine doğrudan sınıf
adları üzerinden erişmek yerine örnekler üzerinden erişmeyi tercih etmenizin de
hiçbir sakıncası olmadığını bilin.

Gelin şimdi yukarıda öğrendiklerimizi kullanarak ufak tefek uygulama çalışmaları
yapalım.

Sınıfımız şu olsun:

```python
class Sipariş():
 firma = ''
 miktar = 0
 sipariş_tarihi = ''
 teslim_tarihi = ''
 stok_adedi = 0

```

Bildiğiniz gibi, ufak tefek kod çalışmaları yapmak için Python’ın etkileşimli
kabuğu son derece uygun bir ortamdır. O halde yukarıdaki sınıfısipariş.pyadlı bir dosyaya kaydedelim, bu dosyanın bulunduğu konumda bir etkileşimli
kabuk ortamı açalım vesipariş.pydosyasını bir modül olarak içe aktaralım:

```python
>>> import sipariş

```

Böylecesiparişmodülü içindeki nitelik ve metotlara erişim sağladık. Bunu
teyit edelim:

```python
>>> dir(sipariş)

['Sipariş', '__builtins__', '__cached__', '__doc__', '__file__',
 '__loader__', '__name__', '__package__', '__spec__']

```

Sipariş()adlı sınıfı listenin en başında görebilirsiniz. O halde gelin bu
sınıfı örnekleyerek kullanılabilir hale getirelim:

```python
>>> gofret = sipariş.Sipariş()

```

ElbetteSipariş()adlı sınıfsiparişadlı modül içinde bulunduğundan, bu
sınıfasiparişönekiyle erişiyoruz. Tabii biz isteseydik modülü şu şekilde de
içe aktarabilirdik:

```python
>>> from sipariş import Sipariş

```

BöyleceSipariş()sınıfına öneksiz olarak erişebilirdik:

```python
>>> gofret = Sipariş()

```

Ancak mevcut isim alanını kirletmemek ve bu alanı nereden geldiği belli olmayan
birtakım nitelik ve metotlarla doldurmamak için bizimportmodül_adıbiçimini tercih ediyoruz. Aksi halde, bu kodları okuyanlar,Sipariş()adlı
sınıfınsiparişadlı bir modüle ait olduğunu anlamayacak, bu sınıfı ilk olarak
mevcut dosya içinde bulmaya çalışacaklardır. Ama biz modül adını sınıf adına
eklediğimizde modülün nereden geldiği gayet açık bir şekilde anlaşılabiliyor.
Böylece hem kodları okuyan başkalarının işini hem de birkaç ay sonra kendi
kodlarımıza tekrar bakmak istediğimizde kendi işimizi kolaylaştırmış oluyoruz.

Neyse… Lafı daha fazla dolandırmadan kaldığımız yerden devam edelim…

Sınıfımızı şu şekilde içe aktarmış ve örneklemiştik:

```python
>>> import sipariş
>>> gofret = sipariş.Sipariş()

```

Gelin şimdi bir degofretörneğinin (instance) içeriğini kontrol edelim:

```python
>>> dir(gofret)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
 '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'firma',
 'miktar', 'sipariş_tarihi', 'stok_adedi', 'teslim_tarihi']

```

Gördüğünüz gibi, sınıf içinde tanımladığımız bütün sınıf nitelikleri (firma,miktar,sipariş_tarihi,stok_adediveteslim_tarihi) bu liste içinde
var.

Bu sınıf niteliklerinden, adıfirmaolanı kullanarak siparişin hangi firmadan
yapılacağını belirleyebiliriz:

```python
>>> gofret.firma = 'Öz İstihza ve Şerikleri Gıda, Ticaret Anonim Şirketi'

```

Böylece, sınıf içindeki bir niteliğe yeni bir değer atamış olduk. İsterseniz
sipariş miktarını da belirleyelim:

```python
>>> gofret.miktar = 1000

```

Öteki sınıf niteliklerini de ihtiyacınıza göre ayarlayabilir, hatta bu sınıfa
yeni nitelikler de ekleyebilirsiniz.

Gelin isterseniz pratik olması bakımından bir örnek daha verelim.

Elimizde şöyle bir sınıf olsun:

```python
class Çalışan():
 kabiliyetleri = []
 unvanı = 'işçi'
 maaşı = 1500
 memleketi = ''
 doğum_tarihi = ''

```

Buradakabiliyetleri,unvanı,maaşı,memleketivedoğum_tarihiadlı
beş adet değişken tanımladık. Teknik dilde bu değişkenlere ‘sınıf niteliği’
(class attribute) adı verildiğini biliyorsunuz.

Çalışan()sınıfı içindeki niteliklere erişmek için birkaç tane örnek
çıkaralım:

```python
ahmet = Çalışan()
mehmet = Çalışan()
ayşe = Çalışan()

```

Bu şekildeÇalışan()sınıfının üç farklı örneğini oluşturmuş olduk. Bu
sınıfın niteliklerine, oluşturduğumuz bu örnekler üzerinden erişebiliriz:

```python
print(ahmet.kabiliyetleri)
print(ahmet.unvanı)

print(mehmet.maaşı)
print(mehmet.memleketi)

print(ayşe.kabiliyetleri)
print(ayşe.doğum_tarihi)

```

Çıkardığımız örnekler aracılığıyla sınıf nitelikleri üzerinde değişiklik de
yapabiliyoruz:

```python
ahmet.kabiliyetleri.append('prezantabl')

```

Şimdi burada bir duralım. Çünkü burada çok sinsi bir sorunla karşı karşıyayız.
Dikkatlice bakın.

Çalışan()sınıfı için birahmetörneği oluşturalım:

```python
ahmet = Çalışan()

```

Buna ‘prezantabl’ kabiliyetini ekleyelim:

```python
ahmet.kabiliyetleri.append('prezantabl')

```

Bu kabiliyetin eklendiğini teyit edelim:

```python
print(ahmet.kabiliyetleri)

```

ŞimdiÇalışan()sınıfının bir başka örneğini oluşturalım:

```python
selim = Çalışan()

```

Bu örneğin kabiliyetlerini kontrol edelim:

```python
print(selim.kabiliyetleri)

```

Gördüğünüz gibi, yalnızcaahmetörneğine eklemek istediğimiz ‘prezantabl’
kabiliyetiselimörneğine de eklenmiş. Ancak normal şartlarda arzu edilen bir
şey değildir bu. Zira bu durum aslında programımızdaki bir tasarım hatasına
işaret eder. Peki ama bu durumun sebebi nedir?

Hatırlarsanız, sınıf niteliklerinden bahsederken, bu niteliklerin önemli bir
özelliğinin, sınıf çağrılmadan çalışmaya başlamaları olduğunu söylemiştik. Sınıf
niteliklerinin bir başka önemli özelliği de, bu niteliklere atanan değerlerin ve
eğer yapılabiliyorsa bu değerler üzerinde sonradan yapılan değişikliklerin o
sınıfın bütün örneklerini etkiliyor olmasıdır. Eğer ilgili sınıf niteliği;
karakter dizisi, demet ve sayı gibi değiştirilemeyen (immutable) bir veri tipi
ise bu sınıf niteliği üzerinde zaten değişiklik yapamazsınız. Yaptığınız şey
ancak ilgili sınıf niteliğini yeniden tanımlamak olacaktır. Ancak eğer sınıf
niteliği, liste, sözlük ve küme gibi değiştirilebilir (mutable) bir veri tipi
ise bu nitelik üzerinde yapacağınız değişiklikler bütün sınıf örneklerine
yansıyacaktır. Yazdığınız program açısından bu özellik arzu ettiğiniz bir şey
olabilir veya olmayabilir. Önemli olan, sınıf niteliklerinin bu özelliğinin
farkında olmanız ve kodlarınızı bu bilgi çerçevesinde yazmanızdır. Mesela
yukarıdaki örnektekabiliyetlerilistesine eklenen öğelerin bütün örneklere
yansıması istediğimiz bir şey değil. Ama eğer sınıfımız şöyle olsaydı:

```python
class Çalışan():
 personel_listesi = []

```

Buradapersonel_listesiadlı bir sınıf niteliği tanımladık. Eğer bu listenin,
personele eklenen bütün elemanları barındırmasını planlıyorsak bu listenin her
örneklemede büyümesi elbette istediğimiz bir şey olacaktır.

Peki o halde biz değerinin her örnekte ortak değil de her örneğe özgü olmasını
istediğimiz nitelikleri nasıl tanımlayacağız? Elbette sınıf nitelikleri yerine
örnek nitelikleri denen başka bir kavramdan yararlanarak…

### Örnek Nitelikleri

Şimdiye kadar öğrendiklerimiz, sınıflarla faydalı işler yapmamız için pek
yeterli değildi. Sınıflar konusunda ufkumuzun genişleyebilmesi için, sınıf
niteliklerinin (class attributes) yanı sıra, nesne tabanlı programlamanın
önemli bir parçası olan örnek niteliklerinden (instance attributes) de söz
etmemiz gerekiyor. Hem örnek niteliklerini öğrendikten sonra, bunların sınıf
nitelikleri ile arasındaki farkları görünce sınıf niteliklerini de çok daha iyi
anlamış olacaksınız.

### __init__ Fonksiyonu ve self

Buraya gelene kadar, sınıflar ile ilgili verdiğimiz kod parçaları yalnızca sınıf
niteliklerini içeriyordu. Mesela yukarıda tanımladığımızÇalışan()sınıfı
içindekiunvanıvekabiliyetleriadlı değişkenlerin birer sınıf
niteliği olduğunu biliyoruz.

Sınıf nitelikleri dışında, Python’da bir de örnek nitelikleri bulunur.

Bildiğiniz gibi, Python’da sınıf niteliklerini tanımlamak için yapmamız gereken
tek şey, sınıf tanımının hemen altına bunları alelade birer değişken gibi
yazmaktan ibarettir:

```python
class Sınıf():
 sınıf_niteliği1 = 0
 sınıf_niteliği2 = 1

```

Örnek niteliklerini tanımlamak için ise iki yardımcı araca ihtiyacımız var:__init__()fonksiyonu veself.

Bu iki aracı şu şekilde kullanıyoruz:

```python
class Çalışan():
 def __init__(self):
 self.kabiliyetleri = []

```

Bu arada,__init__()fonksiyonunun nasıl yazıldığına dikkat ediyoruz.initkelimesinin sağında ve solunda ikişer adet alt çizgi (_) bulunduğunu gözden
kaçırmıyoruz. Ayrıca,__init__()fonksiyonunudefifadesine bitişik
yazmamaya da bilhassa özen gösteriyoruz.

‘init’ kelimesinin solunda ve sağında bulunan alt çizgiler sizi sakın
ürkütmesin. Aslında__init__(), alelade bir fonksiyondan başka bir şey
değildir. Bu fonksiyonun öteki fonksiyonlardan tek farkı, sınıflar açısından
biraz özel bir anlam taşıyor olmasıdır. Bu özel fonksiyonun görevi, sınıfımızı
örneklediğimiz sırada, yani meselaahmet=Çalışan()gibi bir komut
verdiğimiz anda oluşturulacak nitelikleri ve gerçekleştirilecek işlemleri
tanımlamaktır. Bu fonksiyonun ilk parametresi her zamanselfolmak zorundadır.
Bu açıklama ilk anda kulağınıza biraz anlaşılmaz gelmiş olabilir. Ama hiç endişe
etmeyin. Bu bölümün sonuna vardığınızda bu iki öğeyi, adınızı bilir gibi biliyor
olacaksınız.

Hatırlarsanız, sınıf niteliklerini anlatırken bunların önemli bir özelliğinin,
sınıfın çağrılmasına gerek olmadan çalışmaya başlaması olduğunu söylemiştik:

```python
class Çalışan():
 selam = 'merhaba'
 print(selam)

```

Bu kodları çalıştırdığımız anda ekrana ‘merhaba’ çıktısı verilecektir. Örnek
nitelikleri ise farklıdır:

```python
class Çalışan():
 def __init__(self):
 self.kabiliyetleri = []
 print(self.kabiliyetleri)

```

Bu kodları çalıştırdığınızda herhangi bir çıktı almazsınız. Bu kodların çıktı
verebilmesi için sınıfımızı mutlaka örneklememiz lazım:

```python
class Çalışan():
 def __init__(self):
 self.kabiliyetleri = []
 print(self.kabiliyetleri)

Çalışan()

```

Çünküself.kabiliyetleribir sınıf niteliği değil, bir örnek niteliğidir.
Örnek niteliklerine erişebilmek için de ilgili sınıfı mutlaka örneklememiz
gerekir. Ayrıca sınıf niteliklerinin aksine, örnek niteliklerine sınıf adları
üzerinden erişemeyiz. Yaniself.kabiliyetleriadlı örnek niteliğine erişmeye
yönelik şöyle bir girişim bizi hüsrana uğratacaktır:

```python
Çalışan.kabiliyetleri

```

Bu örnek niteliğine erişmek için örneklendirme mekanizmasından yararlanmamız
lazım:

```python
Çalışan().kabiliyetleri #parantezlere dikkat!

```

Gelin isterseniz, örneklendirme işlemini daha kullanışlı bir hale getirmek için,
örneklendirdiğimiz sınıfı bir örneğe atayalım, yani bu sınıfın bir örneğini
çıkaralım:

```python
ahmet = Çalışan()

```

ahmet=Çalışan()kodu yardımıyla,Çalışansınıfının bir örneğini
çıkardık ve bunaahmetadını verdik. İşte tam bu anda__init__()fonksiyonu çalışmaya başladı veahmetörneği için,kabiliyetleriadlı boş
bir örnek niteliği oluşturdu.

Peki yukarıda kodlarımızı yazarken__init__()fonksiyonuna parametre olarak
verdiğimiz vekabiliyetlerilistesinin başında kullandığımızselfkelimesi
ne oluyor?

Öncelikle bilmemiz gereken şey,selfkelimesinin, Python programlama dilinin
söz diziminin gerektirdiği bir öğe olduğudur. Bu kelime,Çalışan()adlı
sınıfın örneklerini temsil eder. Peki ‘self kelimesinin bir sınıfın örneklerini
temsil ediyor olması’ ne anlama geliyor?

Bildiğiniz gibi, bir sınıfın örneğini şu şekilde çıkarıyoruz:

```python
ahmet = Çalışan()

```

Buahmetörneğini kullanarak,Çalışan()sınıfının içindekikabiliyetleriadlı örnek niteliğine sınıf dışından erişebiliriz:

```python
print(ahmet.kabiliyetleri)

```

İşteselfkelimesi, yukarıdaki kodda yer alanahmetkelimesini temsil
ediyor. Yaniahmet.kabiliyetlerişeklinde bir kod yazabilmemizi sağlayan
şey,__init__()fonksiyonu içinde belirttiğimizselfkelimesidir. Eğer bu
kelimeyi kullanmadan şöyle bir kod yazarsak:

```python
class Çalışan():
 def __init__():
 kabiliyetleri = []

```

…artık aşağıdaki kodlar yardımıylakabiliyetleriniteliğine erişemeyiz:

```python
ahmet = Çalışan()
print(ahmet.kabiliyetleri)

```

Şimdi aynı kodları bir de şöyle yazalım:

```python
class Çalışan():
 def __init__(self):
 kabiliyetleri = []

ahmet = Çalışan()
print(ahmet.kabiliyetleri)

```

Burada__init__()fonksiyonunda ilk parametre olarakself’i belirttik. Amakabiliyetleriniteliğinin başınaselfeklemedik. Dolayısıyla yazdığımız
kodlar yine hata verdi. Çünkü,ahmet.kabiliyetlerişeklinde
ifade ettiğimiz kodlardakiahmetkelimesini karşılayacak herhangi bir
öğe sınıf içinde bulunmuyor…

Bu arada, örnek isimlerini (meselaahmet) yalnızca örnek niteliklerine erişmek
için kullanmıyoruz. Bunları aynı zamanda sınıf niteliklerine erişmek için de
kullanabiliyoruz. Dolayısıyla eğer yukarıdaki sınıf tanımı içinde,self.kabiliyetleriadlıörnek niteliği’nin yanısırapersoneladlı birsınıf niteliğide bulunsaydı:

```python
class Çalışan():
 personel = ['personel']

 def __init__(self):
 self.kabiliyetleri = []

```

Şu kodları yazdığımızda:

```python
ahmet = Çalışan()
print(ahmet.personel)

```

…o sınıf niteliğine erişebilirdik. Ancak eğer__init__()fonksiyonu
altındakikabiliyetleriniteliğine erişmek istiyorsak, bu niteliğin başınaselfkelimesini getirerek, bu niteliği birörnek niteliğihaline getirmeli
ve böylece,ahmet.kabiliyetlerikodundakiahmetkelimesini temsil edecek
bir öğeyi sınıf içinde oluşturmalıyız.

Bu süreç tam olarak şöyle işler:

Bizahmet.kabiliyetlerişeklinde bir komut verdiğimizde, Python ilk olarak
ilgili sınıfın__init__()fonksiyonu içindekabiliyetleriadlı bir örnek
niteliği arar. Elbette Python’ın bu örnek niteliğini bulabilmesi için,__init__()fonksiyonu içinde, bu fonksiyonun ilk parametresi ile aynı öneki
taşıyan bir niteliğin yer alması gerekir. Yani eğer__init__()fonksiyonunun
ilk parametresiselfise, Python bu fonksiyon içindeself.kabiliyetleriadlı
birörnek niteliğibulmaya çalışır. Eğer bulamazsa, Python bu kezkabiliyetleriadlı birsınıf niteliğiarar. Eğer onu da bulamazsa tabii ki
hata verir…

Gelin isterseniz bu mekanizmayı teyit edelim:

```python
class Çalışan():
 kabiliyetleri = ['sınıf niteliği']

 def __init__(self):
 self.kabiliyetleri = ['örnek niteliği']

```

Gördüğünüz gibi, burada aynı adı taşıyan bir sınıf niteliği ile bir örnek
niteliğimiz var. Python’da hem sınıf niteliklerine, hem de örnek niteliklerine
örnek isimleri üzerinden erişebileceğimizi söylemiştik. Yani eğer örneğimizin
ismiahmetise, hemkabiliyetleriadlı sınıf niteliğine hem deself.kabiliyetleriadlı örnek niteliğine aynı şekilde erişiyoruz:

```python
ahmet = Çalışan()
print(ahmet.kabiliyetleri)

```

Peki ama acaba yukarıdaki kodlar bize örnek niteliğini mi verir, yoksa sınıf
niteliğini mi?

Böyle bir durumda, yukarıda bahsettiğimiz mekanizma nedeniyle,self.kabiliyetlerişeklinde ifade ettiğimiz örnek niteliği,kabiliyetleriadlı sınıf niteliğini gölgeler. Bu yüzden deprint(ahmet.kabiliyetleri)komutu, örnek niteliğini, yaniself.kabiliyetlerilistesini verir. Yukarıdaki
kodları çalıştırarak siz de bu durumu teyit edebilirsiniz. Zira bu kodlar bize,self.kabiliyetlerilistesinin değeri olan ‘örnek niteliği’ çıktısını
verecektir…

Peki ya siz sınıf niteliği olankabiliyetlerilistesine erişmek isterseniz ne
olacak?

İşte bunun için, sınıf örneğini değil de, sınıf adını kullanacaksınız:

```python
class Çalışan():
 kabiliyetleri = ['sınıf niteliği']

 def __init__(self):
 self.kabiliyetleri = ['örnek niteliği']

#sınıf niteliğine erişmek için
#sınıf adını kullanıyoruz
print(Çalışan.kabiliyetleri)

#örnek niteliğine erişmek için
#örnek adını kullanıyoruz
ahmet = Çalışan()
print(ahmet.kabiliyetleri)

```

Ancak elbette, aynı adı taşıyan bir sınıf niteliği ile bir örnek niteliğini aynı
sınıf içinde tanımlamak daha baştan iyi bir fikir değildir, ama yazdığınız bir
sınıf yanlışlıkla aynı ada sahip sınıf ve örnek nitelikleri tanımlamanız
nedeniyle beklenmedik bir çıktı veriyorsa, siz Python’ın bu özelliğinden
haberdar olduğunuz için, hatanın nereden kaynaklandığını kolayca
kestirebilirsiniz.

Sözün kısası, Python’ın söz dizimi kuralları açısından, eğer bir örnek
niteliği tanımlıyorsak, bu niteliğin başına birselfgetirmemiz gerekir.
Ayrıca buselfkelimesini de, örnek niteliğinin bulunduğu fonksiyonun
parametre listesinde ilk sıraya yerleştirmiş olmalıyız. Unutmayın, örnek
nitelikleri sadece fonksiyonlar içinde tanımlanabilir. Fonksiyon dışında örnek
niteliği tanımlayamazsınız. Yani şöyle bir şey yazamazsınız:

```python
class Çalışan():
 self.n = 0

 def __init__(self):
 self.kabiliyetleri = []

```

Çünküselfkelimesi ancak ve ancak, içinde geçtiği fonksiyonun parametre
listesinde ilk sırada kullanıldığında anlam kazanır.

Bu noktada size çok önemli bir bilgi verelim: Python sınıflarında örnek
niteliklerini temsil etmesi için kullanacağınız kelimeninselfolması şart
değildir. Bunun yerine istediğiniz başka bir kelimeyi kullanabilirsiniz.
Mesela:

```python
class Çalışan():
 def __init__(falanca):
 falanca.kabiliyetleri = []

```

Dediğimiz gibi,selfkelimesi, bir sınıfın örneklerini temsil ediyor. Siz
sınıf örneklerini hangi kelimenin temsil edeceğini kendiniz de
belirleyebilirsiniz. Mesela yukarıdaki örnekte,__init__()fonksiyonunun ilk
parametresinifalancaolarak belirleyerek, örnek niteliklerininfalancakelimesi ile temsil edilmesini sağlamış olduk. Python’da bu konuya ilişkin kural
şudur: Sınıf içindeki bir fonksiyonun ilk parametresi ne ise, o fonksiyon
içindeki örnek niteliklerini temsil eden kelime de odur. Örneğin, eğer şöyle bir
sınıf tanımlamışsak:

```python
class XY():
 def __init__(a, b, c):
 a.örnek_niteliği = []

```

Burada__init__()fonksiyonunun ilk parametresiaolduğu için, örnek
niteliğini temsil eden kelime deaolur. Dolayısıylaörnek_niteliğiadlı
örnek niteliğimizin başına da önek olarak buakelimesini getiriyoruz.

__init__()fonksiyonunun ilk parametresiaolarak belirlendikten sonra,
bu fonksiyon içindeki bütün örnek nitelikleri, önek olarakakelimesini
alacaktır:

```python
class XY():
 def __init__(a, b, c):
 a.örnek_niteliği1 = []
 a.örnek_niteliği2 = 23
 a.örnek_niteliği3 = 'istihza'

```

ANCAK! Her ne sebeple olursa olsun, örnek niteliklerini temsil etmek içinselfdışında bir kelime kullanmayın. Python bu kelimeyi bize dayatmasa da,selfkullanımı Python topluluğu içinde çok güçlü ve sıkı sıkıya yerleşmiş bir
gelenektir. Bu geleneği kimse bozmaz. Siz de bozmayın.

Sözün özü, tek başınaselfkelimesinin hiçbir anlamının olmadığını asla
aklınızdan çıkarmayın. Bu kelimenin Python açısından bir anlam kazanabilmesi
için, ilgili fonksiyonun parametre listesinde ilk sırada belirtiliyor olması
lazım. Zaten bu yüzden, dediğimiz gibi,selfkelimesinin Python açısından bir
özelliği yoktur. Yani şöyle bir kod yazmamızın, Python söz dizimi açısından
hiçbir sakıncası bulunmaz:

```python
class Çalışan():
 def __init__(osman):
 osman.kabiliyetleri = []

```

Çünkü Python, örnek niteliklerini temsil eden kelimenin ne olduğuyla asla
ilgilenmez. Python için önemli olan tek şey, temsil işi için herhangi bir
kelimenin belirlenmiş olmasıdır. Tabii, biz, daha önce de ısrarla söylediğimiz
gibi, örnek nitelikleriniselfdışında bir kelime ile temsil etmeye teşebbüs
etmeyeceğiz ve kodlarımızı şu şekilde yazmaktan şaşmayacağız:

```python
class Çalışan():
 def __init__(self):
 self.kabiliyetleri = []

```

İşte yukarıdaki kodda gördüğümüzselfparametresi veselföneki,
birbirlerine bağımlı kavramlardır. Fonksiyonun ilk parametresi ne ise, örnek
niteliklerinin öneki de o olacaktır.

Bu arada, örnek niteliklerini anlatmaya başlamadan önce sınıf niteliklerine
ilişkin sinsi bir durumdan söz etmiştik hatırlarsanız. Buna göre, eğer elimizde
şöyle bir kod varsa:

```python
class Çalışan():
 kabiliyetleri = []

```

Biz bu sınıf içindekikabiliyetlerilistesine ekleme yaptığımızda, bu durum o
sınıfın bütün örneklerini etkiliyordu.

Yukarıdaki kodlarıdeneme.pyadlı bir dosyaya kaydettiğimizi varsayarsak:

```python
>>> import deneme
>>> ahmet = deneme.Çalışan()
>>> ahmet.kabiliyetleri.append('konuşkan')
>>> ahmet.kabiliyetleri

['konuşkan']

>>> mehmet = deneme.Çalışan()
>>> print(mehmet.kabiliyetleri)

['konuşkan']

```

İşte bu durumu önlemek için örnek metotlarından yararlanabiliyoruz:

```python
class Çalışan():
 def __init__(self):
 self.kabiliyetleri = []

```

Yukarıdaki kodları yinedeneme.pyadlı bir dosyaya kaydettiğimizi
varsayarsak:

```python
>>> import deneme
>>> ahmet = deneme.Çalışan()
>>> ahmet.kabiliyetleri.append('konuşkan')
>>> ahmet.kabiliyetleri

['konuşkan']

>>> mehmet = deneme.Çalışan()
>>> print(mehmet.kabiliyetleri)

[]

```

Gördüğünüz gibi,ahmetörneğine eklediğimiz ‘konuşkan’ öğesi, olması gerektiği
gibi,mehmetörneğinde bulunmuyor. Birazdan bu konu üzerine birkaç kelam daha
edeceğiz.

### Örnek Metotları

Buraya kadar sınıflar, örnekler, sınıf nitelikleri ve örnek nitelikleri
konusunda epey bilgi edindik. Gelin şimdi isterseniz bu öğrendiklerimizi
kullanarak az çok anlamlı bir şeyler yazmaya çalışalım. Böylece hem şimdiye
kadar öğrendiklerimizi gözden geçirmiş ve pekiştirmiş oluruz, hem de bu bölümde
ele alacağımız ‘örnek metotları’ (instance methods) kavramını anlamamız
kolaylaşır:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Sınıfımızı tanımladık. Gelin isterseniz bu kodları açıklamaya başlamadan önce
nasıl kullanacağımızı görelim.

Bildiğiniz gibi, Python kodlarını test etmenin en iyi yolu, bunları etkileşimli
kabuk üzerinde çalıştırmaktır. Özellikle bir program yazarken, tasarladığınız
sınıfların, fonksiyonların ve öteki öğelerin düzgün çalışıp çalışmadığını test
etmek için etkileşimli kabuğu sıklıkla kullanacaksınız.

O halde, yukarıdaki kodları barındıran dosyanın bulunduğu dizin altında bir
etkileşimli kabuk oturumu başlatalım ve dosya adınınçalışan.pyolduğunu
varsayarak kodlarımızı bir modül şeklinde içe aktaralım:

```python
>>> import çalışan

```

Daha sonra sınıfımızın iki farklı örneğini çıkaralım:

```python
>>> ç1 = çalışan.Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi

>>> ç2 = çalışan.Çalışan('Mehmet')

Mehmet adlı kişi personele eklendi

```

Bu şekildeçalışanadlı modül içindekiÇalışan()adlı sınıfı sırasıyla‘Ahmet’ve‘Mehmet’parametreleri ile çağırarakç1veç2adlı iki farklı
sınıf örneği oluşturmuş olduk. Bu arada, sınıfımızı örneklediğimiz anda__init__()fonksiyonunun devreye girdiğine dikkat ediyoruz.

personele_ekle()adlı fonksiyonuself.personele_ekle()şeklinde__init__()fonksiyonu içinden çağırdığımız için, sınıfımızı
örneklediğimiz anda hem personelin kendisi personel listesine eklendi, hem
de bu kişinin personele eklendiğine dair bir mesaj gösterildi.

Tanımladığımız sınıfın niteliklerine, çıkardığımız örnekler üzerinden
erişebiliriz:

```python
>>> ç1.isim

'Ahmet'

>>> ç2.isim

'Mehmet'

```

Yine bu örnekler üzerinden, bu nitelikleri değiştirebiliriz de:

```python
>>> ç1.isim = 'Mahmut'
>>> ç1.personel[0] = 'Mahmut'

```

Böylece ilk çalışanın ismini ‘Mahmut’ olarak değiştirdik:

```python
>>> ç1.isim

'Mahmut'

>>> ç1.personel

['Mahmut', 'Mehmet']

```

Tanımladığımız sınıf içindeki fonksiyonları kullanarak, çalışanlarımıza birkaç
kabiliyet ekleyelim:

```python
>>> ç1.kabiliyet_ekle('prezantabl')
>>> ç1.kabiliyet_ekle('konuşkan')

```

ç1örneğinin kabiliyetlerini görüntüleyelim:

```python
>>> ç1.kabiliyetleri_görüntüle()

Mahmut adlı kişinin kabiliyetleri:
prezantabl
konuşkan

```

Şimdi deç2örneğine bir kabiliyet ekleyelim ve eklediğimiz kabiliyeti
görüntüleyelim:

```python
>>> ç2.kabiliyet_ekle('girişken')
>>> ç2.kabiliyetleri_görüntüle()

Mehmet adlı kişinin kabiliyetleri:
girişken

```

Gördüğünüz gibi, bir sınıf örneğine eklediğimiz kabiliyet öteki sınıf
örneklerine karışmıyor. Bu, örnek niteliklerinin sınıf niteliklerinden önemli
bir farkıdır. Zira sınıf nitelikleri bir sınıfın bütün örnekleri tarafından
paylaşılır. Ama örnek nitelikleri her bir örneğe özgüdür. Bu özellikten biraz
sonra daha ayrıntılı olarak söz edeceğiz. Biz şimdilik okumaya devam edelim.

Sınıf örneklerimizin herhangi biri üzerinden personel listesine de
ulaşabileceğimizi biliyoruz:

```python
>>> ç1.personeli_görüntüle()

Personel listesi:
Mahmut
Mehmet

```

Gayet güzel…

Yukarıda anlattıklarımız sınıflar hakkında size epey fikir vermiş olmalı. Konuyu
daha da derinlemesine anlayabilmek için, artık bu sınıfı incelemeye geçebiliriz.

Sınıfımızı önümüze alalım:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Burada öncelikle her zamanki gibi sınıfımızı tanımlıyoruz:

```python
class Çalışan():
 ...

```

Daha sonra bu sınıfapersoneladlı bir sınıf niteliği ekliyoruz:

```python
class Çalışan():
 personel = []

```

Sınıf niteliklerinin özelliği, o sınıfın bütün örnekleri tarafından paylaşılıyor
olmasıdır. Yani herhangi bir örneğin bu nitelik üzerinde yaptığı değişiklik,
öteki örneklere de yansıyacaktır. Hele bir de bu sınıf niteliği, listeler gibi
değiştirilebilir (mutable) bir veri tipi ise, bu durum hiç de istemediğiniz
sonuçlar doğurabilir. Bununla ilgili bir örneği yukarıda vermiştik.
Hatırlarsanız,kabiliyetleriadlı, liste veri tipinde bir sınıf niteliği
oluşturduğumuzda, bu listeye eklediğimiz öğeler, hiç istemediğimiz halde öbür
örneklere de sirayet ediyordu. Elbette, sınıf niteliklerinin bu özelliği, o anda
yapmaya çalıştığınız şey açısından gerekli bir durum da olabilir. Mesela
yukarıdaki kodlarda, listelerin ve sınıf niteliklerinin bu özelliği bizim
amacımıza hizmet ediyor. Yukarıdaki sınıfı çalıştırdığımızda, eklenen her bir
kişiyi bupersonellistesine ilave edeceğiz. Dolayısıyla bu nitelik üzerinde
yapılan değişikliklerin bütün örneklere yansıması bizim istediğimiz bir şey.

Neyse… Lafı daha fazla uzatmadan, kodlarımızı açıklamaya kaldığımız yerden
devam edelim…

Sınıfımızı ve sınıf niteliğimizi tanımladıktan sonra__init__()adlı özel
fonksiyonumuzu oluşturuyoruz:

```python
def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

```

Bu fonksiyonun özelliği, sınıfın örneklenmesi ile birlikte otomatik olarak
çalıştırılacak olmasıdır. Biz burada,self.isimveself.kabiliyetleriadlı
iki adet örnek niteliği tanımladık. Bu örnek niteliklerine sınıfımızın her
tarafından erişebileceğiz.

Yukarıda, tanımladığımız sınıfı nasıl kullanacağımızı gösterirken,Çalışan()sınıfını şu şekilde örneklediğimizi hatırlıyorsunuz:

```python
>>> ç1 = çalışan.Çalışan('Ahmet')

```

Burada sınıfımızı‘Ahmet’adlı bir argümanla örneklediğimize dikkatinizi
çekmek isterim. İşte bu argüman, biraz önce__init__()fonksiyonunu
tanımlarken belirttiğimizisimparametresine karşılık geliyor. Dolayısıyla,
bir sınıfı çağırırken/örneklerken kullanacağımız argümanları, bu__init__()fonksiyonunun parametreleri olarak tanımlıyoruz.

Daha sonra buisimparametresini,__init__()fonksiyonunun gövdesi içinde
bir örnek niteliği haline getiriyoruz:

```python
self.isim = isim

```

Bunu yapmamızın gerekçesi,isimparametresini sınıfımızın başka bölgelerinde
de kullanabilmek.selfkelimesini parametremizin başına yerleştirerek, bu
parametreyi sınıfın başka yerlerinden de erişilebilir hale getiriyoruz.

isimparametresini,self.isimkodu yardımıyla bir örnek niteliğine
dönüştürdükten sonraself.kabiliyetleriadlı bir başka örnek niteliği daha
tanımlıyoruz. Bu liste, sınıf örneklerine eklediğimiz kabiliyetleri tutacak.

Bunun ardından şöyle bir kod görüyoruz:

```python
self.personele_ekle()

```

Burada,personele_ekle()adlı bir örnek metoduna (instance method) atıfta
bulunuyoruz. Örnek metotları, bir sınıfın örnekleri vasıtasıyla çağrılabilen
fonksiyonlardır. Bu fonksiyonların ilk parametresi her zamanselfkelimesidir.
Ayrıca bu fonksiyonlara sınıf içinde atıfta bulunurken de yineselfkelimesini
kullanıyoruz. Tıpkı yukarıdaki örnekte olduğu gibi…

Bir örnek metodu olduğunu söylediğimizpersonele_ekle()fonksiyonunu şu
şekilde tanımladık:

```python
def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

```

Burada, bir sınıf niteliği olanpersoneldeğişkenine nasıl eriştiğimize çok
dikkat etmenizi istiyorum. Daha önce de söylediğimiz gibi, sınıf niteliklerine
sınıf dışındayken
örnekler üzerinden erişebiliyoruz.selfkelimesi, bir sınıfın örneklerini
temsil ettiği için, bir sınıf niteliğine sınıf içinden erişmemiz gerektiğindeselfkelimesini kullanabiliriz.

Sınıf niteliklerine, örnekler dışında, sınıf adıyla da erişebileceğinizi
biliyorsunuz. Dolayısıyla isterseniz yukarıdaki kodları şöyle de
yazabilirdiniz:

```python
def personele_ekle(self):
 Çalışan.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

```

Bir öncekinden farklı olarak, bu defa sınıf niteliğine doğrudan sınıf adını
(Çalışan) kullanarak eriştik.

Ayrıca bu fonksiyonda, bir örnek niteliği olanself.isimdeğişkenine de
erişebiliyor olduğumuza dikkat edin. Unutmayın,selfsınıfların çok önemli bir
öğesidir. Bu öğeyi kullanarak hem örnek niteliklerine, hem sınıf niteliklerine,
hem de örnek metotlarına ulaşabiliyoruz. Tanımladığımız bupersonele_ekle()adlı örnek metodunu__init__()fonksiyonu içindenself.personele_ekle()kodu ile (yani yineselfkelimesini kullanarak) çağırdığımızı hatırlıyorsunuz.

personele_ekle()fonksiyonunun ardından arka arkaya üç fonksiyon daha
tanımladık:

```python
def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Bu fonksiyonlar da, tıpkıpersonele_ekle()gibi, birer örnek metodudur. Bu
örnek metotlarının da ilk parametrelerinin hepselfolduğuna dikkat ediyoruz.
Örnek metotlarına sınıf dışından örnek isimleri (ahmet,mehmetgibi)
aracılığıyla, sınıf içinden ise, örnek isimlerini temsil edenselfkelimesi
aracılığıyla eriştiğimizi biliyorsunuz.

Şimdi bir duralım…

Bu noktaya kadar epey konuştuk, epey örnek verdik. Sınıflar hakkında yeterince
bilgi sahibi olduğumuza göre, nihayet en başta verdiğimiz harf sayacı kodlarını
rahatlıkla anlayabilecek düzeye eriştik:

```python
class HarfSayacı:
 def __init__(self):
 self.sesli_harfler = 'aeıioöuü'
 self.sessiz_harfler = 'bcçdfgğhjklmnprsştvyz'
 self.sayaç_sesli = 0
 self.sayaç_sessiz = 0

 def kelime_sor(self):
 return input('Bir kelime girin: ')

 def seslidir(self, harf):
 return harf in self.sesli_harfler

 def sessizdir(self, harf):
 return harf in self.sessiz_harfler

 def artır(self):
 for harf in self.kelime:
 if self.seslidir(harf):
 self.sayaç_sesli += 1
 if self.sessizdir(harf):
 self.sayaç_sessiz += 1
 return (self.sayaç_sesli, self.sayaç_sessiz)

 def ekrana_bas(self):
 sesli, sessiz = self.artır()
 mesaj = "{} kelimesinde {} sesli {} sessiz harf var."
 print(mesaj.format(self.kelime, sesli, sessiz))

 def çalıştır(self):
 self.kelime = self.kelime_sor()
 self.ekrana_bas()

if __name__ == '__main__':
 sayaç = HarfSayacı()
 sayaç.çalıştır()

```

Gelin isterseniz bu kodlara da şöyle bir bakalım…

Burada sınıfımızı şu şekilde tanımladık:

```python
class HarfSayacı:
 ...

```

Sınıf adını parantezli bir şekilde yazabileceğimizi de biliyorsunuz:

```python
class HarfSayacı():
 ...

```

Daha sonra,__init__()fonksiyonu içinde dört adet örnek niteliği
tanımladık:

```python
self.sesli_harfler = 'aeıioöuü'
self.sessiz_harfler = 'bcçdfgğhjklmnprsştvyz'
self.sayaç_sesli = 0
self.sayaç_sessiz = 0

```

Bunların birer örnek niteliği olduğunu, başlarına getirdiğimizselfkelimesinden anlıyoruz. Çünkü bildiğiniz gibi,selfkelimesi, ilgili sınıfın
örneklerini temsil ediyor. Bir sınıf içinde örnek niteliklerine ve örnek
metotlarına hep buselfkelimesi aracılığıyla erişiyoruz.

Bu sınıf içinde, ilk parametreleriselfolan şu örnek metotlarını görüyoruz:

```python
def kelime_sor(self):
 ...

def seslidir(self, harf):
 ...

def sessizdir(self, harf):
 ...

def artır(self):
 ...

def ekrana_bas(self):
 ...

def çalıştır(self):
 ...

```

Sınıfla birlikte bütün örnek değişkenlerini ve örnek metotlarını tanımladıktan
sonra programımızı çalıştırma aşamasına geliyoruz:

```python
if __name__ == '__main__':
 sayaç = HarfSayacı()
 sayaç.çalıştır()

```

Buna göre, eğer programımız bağımsız olarak çalıştırılıyorsa öncelikleHarfSayacı()adlı sınıfı örneklendiriyoruz:

```python
sayaç = HarfSayacı()

```

Daha sonra dasayaçörneği üzerindenHarfSayacı()adlı sınıfınçalıştır()metoduna erişerek programımızı başlatıyoruz.

Böylece, Python’da nesne tabanlı programlama ve sınıflara dair öğrenmemiz
gereken bütün temel bilgileri edinmiş olduk. Şu ana kadar öğrendikleriniz
sayesinde, etrafta göreceğiniz sınıflı kodların büyük bölümünü anlayabilecek
durumdasınız. Bir sonraki bölümde, nesne tabanlı programlamanın ayrıntılarına
inmeye başlayacağız.

## Nesne Tabanlı Programlama (Devamı)

Geçen bölümde Python’da nesne tabanlı programlama konusunun temellerinden söz
etmiştik. Bu bölümde ise nesne tabanlı programlamanın ayrıntılarına inmeye
başlayacağız.

### Sınıf Metotları

Nesne tabanlı programlamaya giriş yaptığımız geçen bölümde şunlara değindik:
1. Sınıflar (classes)
1. Örnekler (instances)
1. Sınıf nitelikleri (class attributes)
1. Örnek nitelikleri (instance attributes)
1. Örnek metotları (instance methods)

Sınıflar (classes)

Örnekler (instances)

Sınıf nitelikleri (class attributes)

Örnek nitelikleri (instance attributes)

Örnek metotları (instance methods)

Bunlar nesne tabanlı programlamanın en temel kavramlarıdır. Bunları iyice
öğrendiyseniz, etrafta gördüğünüz kodların büyük bölümünü anlayabilecek kıvama
gelmişsiniz demektir.

Ama elbette nesne tabanlı programlama yalnızca bu temel kavramlardan ibaret
değil. Nesne tabanlı programlamanın derinlerine indikçe, bunların dışında başka
pek çok kavramla daha karşılaşacağız. Mesela sınıf metotları (class methods)
bu kavramlardan biridir. İşte bu bölümde, nesne tabanlı programlamanın ileri
düzey kavramlarının ilki olan bu sınıf metotlarından (class methods) söz
edeceğiz.

Dilerseniz ne ile karşı karşıya olduğumuzu anlayabilmek için basit bir örnek
üzerinden ilerleyelim.

Hatırlarsanız bir önceki bölümde şöyle bir kod parçası vermiştik:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Bu kodlarda, bir personel listesi oluşturmamızı, personele ekleme yapmamızı,
personeli görüntülememizi, personele yeni kabiliyet eklememizi ve eklediğimiz
kabiliyetleri görüntüleyebilmemizi sağlayan örnek metotları var. Gelin bu
kodlara bir de personel sayısını görüntülememizi sağlayacak bir başka örnek
metodu daha ekleyelim:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personel_sayısını_görüntüle(self):
 print(len(self.personel))

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Burada yeni olarakpersonel_sayısını_görüntüle()adlı bir örnek metodu
tanımladık. Bu metot, bir sınıf niteliği olanpersonel’e erişerek bunun
uzunluğunu ekrana basıyor. Böylece personelin kaç kişiden oluştuğunu öğrenmiş
oluyoruz.

Bu yeni örnek metodunu aşağıdaki şekilde kullanabiliriz.

Öncelikle kodlarımızı barındıran modülü içe aktaralım:

```python
>>> import çalışan

```

Daha sonra personel listesine birkaç çalışan ekleyelim:

```python
>>> ahmet = çalışan.Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi

>>> mehmet = çalışan.Çalışan('Mehmet')

Mehmet adlı kişi personele eklendi

>>> ayşe = çalışan.Çalışan('Ayşe')

Ayşe adlı kişi personele eklendi

```

Artık herhangi bir örnek değişkeni üzerinden personel sayısına erişebiliriz:

```python
>>> ayşe.personel_sayısını_görüntüle()

3

```

Ancak kodların çalışma mantığı açısından burada bir tutarsızlıktan söz
edebiliriz. Genel olarak bütün personele dair bilgi veren bir fonksiyonaahmet,mehmet,ayşegibi bireysel örnek değişkenleri üzerinden erişmek
kulağa sizce de biraz tuhaf gelmiyor mu? Neticede bu fonksiyon, aslında sınıfın
herhangi bir örneği ile özellikle veya doğrudan ilişkili değil. Yani bu
fonksiyon tek tek sınıf örneklerini değil, genel olarak sınıfın bütününü
ilgilendiriyor. Bu bakımdan,personel_sayısını_görüntüle()fonksiyonunun
örnek değişkenlerinden bağımsız bir biçimde kullanılabilmesi çok daha mantıklı
olacaktır.

Ayrıca, bir örnek metodu olanpersonel_sayısını_görüntüle()fonksiyonunu
örneklerden bağımsız olarak kullanamadığımız için, bu metot yardımıyla personel
sayısının 0 olduğu bir durumu görüntülememiz de mümkün olmuyor. Çünkü bu
fonksiyona erişebilmek için öncelikle sınıfı en az bir kez örneklemiş, yani
sınıfın en az bir adet örneğini çıkarmış olmamız gerekiyor. Bu durum da
kodlarımızın mantığı açısından son derece ciddi bir kısıtlamadır.

Yukarıda sıralanan gerekçeler doğrultusunda kodları hem daha tutarlı bir hale
getirmek hem de personel sayısının 0 olduğu durumu göstermemizi engelleyen
kısıtlamayı aşabilmek için şöyle bir şey deneyebilirsiniz:

```python
def personel_sayısını_görüntüle():
 print(len(Çalışan.personel))

class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Burada personel sayısını görüntüleyen fonksiyonu sınıftan ayırdık. Böylece şu
şekilde bir kullanım mümkün olabildi:

```python
>>> import çalışan
>>> çalışan.personel_sayısını_görüntüle()

0

```

personel_sayısını_görüntüle()adlı fonksiyonu sınıftan ayırıpmodül
düzeyinde çalışan bir fonksiyon(veya bir başka deyişleglobal düzeyde çalışan
bir fonksiyon) haline getirdiğimiz için, artık bu fonksiyonÇalışan()sınıfının herhangi bir örneğine bağımlı değil. Dolayısıyla bu fonksiyonu,Çalışan()sınıfı için bir örnek çıkarmak zorunda kalmadan da
kullanabiliyoruz. Bu da bize personel sayısının 0 olduğu durumu gösterebilme
imkanı tanıyor.

Bu fonksiyonu bir de birkaç örnek çıkardıktan sonra çalıştıralım…

Önce sınıfımızın birkaç örneğini çıkaralım:

```python
>>> ahmet = çalışan.Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi

>>> ayşe = çalışan.Çalışan('Ayşe')

Ayşe adlı kişi personele eklendi

>>> mehmet = çalışan.Çalışan('Mehmet')

Mehmet adlı kişi personele eklendi

```

Şimdi de personelin şu anda kaç kişiden oluştuğunu sorgulayalım:

```python
>>> çalışan.personel_sayısını_görüntüle()

3

```

Gördüğünüz gibi, bu şekilde kodlarımız biraz daha tutarlı bir görünüme kavuştu.
Ancak bu şekilde, bariz bir biçimdeÇalışan()sınıfı ile ilişkili olanpersonel_sayısını_görüntüle()fonksiyonunu sınıftan ayırmış ve kod
bütünlüğünü bozmuş olduk. Çünkü, her ne kadarpersonel_sayısını_görüntüle()fonksiyonuÇalışan()sınıfının herhangi bir örneği ile ilişkili olmasa da,
anlam açısından bu fonksiyonunÇalışan()sınıfına ait olduğu besbelli.
Ayrıca, yukarıdaki kodları barındıran modülün tamamını değil de,fromçalışanimportÇalışangibi bir komutla yalnızcaÇalışan()sınıfını içe
aktarırsak,personel_sayısını_görüntüle()fonksiyonu dışarıda kalacaktır:

```python
>>> from çalışan import Çalışan
>>> dir()

```

Gördüğünüz gibi,personel_sayısını_görüntüle()fonksiyonu listede yok.
Dolayısıyla, sınıfla sıkı sıkıya ilişkili olan bu fonksiyonu sınıftan
kopardığımız için, seçmeli içe aktarmalarda bu fonksiyon geride kalıyor ve
böylece bu fonksiyonu kullanamaz hale geliyoruz.

Seçmeli içe aktarmalarda bu fonksiyon aktarım işlemiyle birlikte gelmediği için,
ilgili fonksiyonu özel olarak içe aktarmamız gerekir:

```python
>>> from çalışan import personel_sayısını_görüntüle

```

Bu şekildeçalışanmodülü içindenpersonel_sayısını_görüntüle()adlı
fonksiyonu özel olarak elle içe aktarmış olduk. Artık bu fonksiyonu şöyle
kullanabiliriz:

```python
>>> personel_sayısını_görüntüle()

```

Ancak bu da, her zaman tercih etmeyeceğiniz bir kısıtlama olabilir. O halde bu
kısıtlamayı aşmak için gelin, ilgili fonksiyonu tekrar sınıf içine alalım:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 def personel_sayısını_görüntüle(self):
 print(len(self.personel))

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Yukarıdaki kodlarda ilgili fonksiyona bir örnek adıyla değil de, sınıf adıyla
erişmek için ilk etapta şu kodu denemek aklınıza gelmiş olabilir:

```python
>>> from çalışan import Çalışan
>>> Çalışan.personel_sayısını_görüntüle()

```

Ancak bu kod size şöyle bir hata mesajı verir:

```python
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: personel_sayısını_görüntüle() missing
1 required positional argument: 'self'

```

Çünkü burada sizÇalışan.personel_sayısını_görüntüle()komutunu vererek
aslında sınıfın bir metoduna (class method) erişmeye çalışıyorsunuz. Ancak
kodlarımızın içinde birsınıf metoduyok. Zira, yukarıda sınıf adıyla erişmeye
çalıştığımızpersonel_sayısını_görüntüle()fonksiyonu bir sınıf metodu
değil, bir örnek metodudur. Örnek metotlarına da sınıf adlarıyla erişmemizin
mümkün olmadığını, bu tür metotlara erişebilmek için sınıfı en az bir kez
örneklemiş olmamız gerektiğini biliyorsunuz.

Burada,__init__()vepersonel_sayısını_görüntüle()dışında şuörnek
metotlarıvar:personel_sayısını_görüntüle(),personele_ekle(),personeli_görüntüle(),kabiliyet_ekle(),kabiliyetleri_görüntüle(). Bunları birer örnek metodu yapan şeyin,selfkelimesi olduğunu biliyoruz…

Daha önce de söylediğimiz gibi, her ne kadar Python’da sınıf niteliklerine hem
örnekler hem de doğrudan sınıf adları üzerinden erişebilsek de örnek
niteliklerine ve örnek metotlarına yalnızca örnekler üzerinden erişebiliriz. Bir
metoda, sınıf adı ile erişebilmek için, ilgili metodu bir sınıf metodu olarak
tanımlamış olmamız gerekir. Peki ama nasıl?

### @classmethod Bezeyicisi ve cls

Bildiğiniz gibi, örnek metotlarını oluşturmak içinselfadlı bir kelimeden
yararlanıyorduk. Tanımladığımız örnek metotlarının parametre listesinde ilk
sıraya yerleştirdiğimiz bu kelimeyi kullanarak, sınıf içinde örnek metotlarına
erişebiliyoruz. İşte sınıf metotları için de benzer bir işlem yapacağız.

Çok basit bir örnek verelim:

```python
class Sınıf():
 sınıf_niteliği = 0

 def __init__(self, param1, param2):
 self.param1 = param1
 self.param2 = param2
 self.örnek_niteliği = 0

 def örnek_metodu(self):
 self.örnek_niteliği += 1
 return self.örnek_niteliği

 def sınıf_metodu(cls):
 cls.sınıf_niteliği += 1
 return cls.sınıf_niteliği

```

Buradaörnek_metodu()ilesınıf_metodu()arasındaki fark, ilkindeself, ikincisinde iseclskullanmamız. Ancak hatırlarsanız,selfkelimesinin Python açısından bir zorunluluk olmadığını söylemiştik. Tıpkıselfgibi, aslındaclskelimesi de Python açısından bir zorunluluk değildir. Yaniclsyerine de istediğimiz kelimeyi kullanabilirdik. Bu metotlarda önemli olan,
parametre listesinin ilk sırasını işgal eden kelimenin ne olduğudur. Dolayısıyla
yukarıdaki örnekte Python açısındanörnek_metodu()ilesınıf_metodu()arasında hiçbir fark bulunmaz. Python her iki metodu da birer örnek metodu
olarak değerlendirir. Bu iki örnek metodu arasındaki fark, ilkinde sınıf
örneklerini temsil edecek kelimeninself, ikincisinde iseclsolarak
belirlenmiş olmasıdır. Pythonselfveyaclskelimelerine özel bir önem
atfetmez. Ama Python topluluğu içinde, örnek metotları içinself, sınıf
metotları için iseclskullanmak çok güçlü bir gelenektir.

Sözün özü,sınıf_metodu()fonksiyonunun ilk parametresiniclsyapmış
olmamız bu metodun bir sınıf metodu olabilmesi için gereklidir, ama yeterli
değildir. Python’da bir sınıf metodu oluşturabilmek için bir parçaya daha
ihtiyacımız var:

```python
class Sınıf():
 sınıf_niteliği = 0

 def __init__(self, param1, param2):
 self.param1 = param1
 self.param2 = param2
 self.örnek_niteliği = 0

 def örnek_metodu(self):
 self.örnek_niteliği += 1
 return self.örnek_niteliği

 @classmethod
 def sınıf_metodu(cls):
 cls.sınıf_niteliği += 1
 return cls.sınıf_niteliği

```

İşte Python’da bir sınıf metodunu örnek metodundan ayıran asıl öğe, yukarıdaki
örnekte gördüğümüz@classmethodifadesidir. Python’da isminin önünde@işareti olan bu tür öğelere ‘bezeyici’ (decorator) adı verilir. Gördüğünüz
gibi,@classmethodbezeyicisi, yukarıdaki örnekte bir fonksiyonu sınıf
metoduna dönüştürme işlevi görüyor. İlerleyen derslerimizde bezeyicilerin başka
özelliklerinden de söz edeceğiz. Gelin isterseniz şimdi yukarıda öğrendiğimiz
özelliğiÇalışan()adlı sınıfa uygulayalım:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 @classmethod
 def personel_sayısını_görüntüle(cls):
 print(len(cls.personel))

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Yukarıdapersonel_sayısını_görüntüle()adlı fonksiyonun yanı sıra,personeli_görüntüle()adlı fonksiyonu da bir sınıf metodu haline getirdik.
Çünkü tıpkıpersonel_sayısını_görüntüle()fonksiyonu gibi,personeli_görüntüle()fonksiyonu da aslında tek tek örneklerden ziyade
sınıfın genelini ilgilendiriyor. Dolayısıyla bu fonksiyona da sınıf adı
üzerinden erişebilmek gayet makul ve mantıklı bir iştir.

Sınıf metotlarımızı başarıyla tanımladığımıza göre artık yukarıdaki sınıfı şu
şekilde kullanabiliriz:

```python
>>> from çalışan import Çalışan
>>> Çalışan.personel_sayısını_görüntüle()

0

```

Bir sınıf metodu olarak tanımladığımızpersonel_sayısını_görüntüle()fonksiyonu artık ilgili sınıfın herhangi bir örneğine bağımlı olmadığı için,
sınıfı örneklemek zorunda kalmadan, yalnızca sınıf adını kullanarakpersonel_sayısını_görüntüle()fonksiyonuna erişebiliyoruz. Bu da bize
personel sayısının 0 olduğu durumu görüntüleyebilme imkanı veriyor…

Ayrıca,personel_sayısını_görüntüle()adlı sınıf metodumuz, fiziksel olarak
da sınıfın içinde yer aldığı için, seçmeli içe aktarmalarda sınıfın öteki
öğeleriyle birlikte bu metot da aktarılacaktır:

```python
>>> from çalışan import Çalışan
>>> dir(Çalışan)

```

Listede sınıf metodumuzun da olduğunu görüyorsunuz.

Personele üye ekledikten sonra bu metodu nasıl kullanacağımızı biliyorsunuz:

```python
>>> ahmet = Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi

>>> mehmet = Çalışan('Mehmet')

Mehmet adlı kişi personele eklendi

>>> ayşe = Çalışan('Ayşe')

Ayşe adlı kişi personele eklendi

>>> Çalışan.personel_sayısını_görüntüle()

3

```

Gördüğünüz gibi, sınıf metodumuza doğrudan sınıf adını kullanarak
erişebiliyoruz. Elbette bu durum, sınıf metoduna örnek adları üzerinden de
erişmemize engel değil. Eğer arzu edersekpersonel_sayısını_görüntüle()adlı
sınıf metodunu şu şekilde de çağırabiliriz:

```python
>>> ayşe.personel_sayısını_görüntüle()

3

>>> ahmet.personel_sayısını_görüntüle()

3

>>> mehmet.personel_sayısını_görüntüle()

3

```

Ancak örnek metotlarına ve örnek niteliklerine atıfta bulunmak için örnek
adlarını kullanmak, sınıf metotları ve sınıf niteliklerine atıfta bulunmak için
ise sınıf adlarını tercih etmek daha akıllıca olabilir.

personel_sayısını_görüntüle()fonksiyonu için söylediğimiz bu sözler,personeli_görüntüle()fonksiyonu için de aynen geçerlidir.

Sözün özü, sınıfın herhangi bir örneğine bağlı olmayan bir işlem yapan, ama
anlamsal olarak da sınıfla ilişkili olduğu için sınıf dışında bırakmak
istemediğiniz fonksiyonları birer sınıf metodu olarak tanımlayabilirsiniz.

### Alternatif İnşacılar

Sınıf metotlarının, işimize yarayabilecek bir başka özelliği ise, bunların bir
‘alternatif inşacı’ (alternative constructor) olarak kullanılabilecek
olmasıdır. “Alternatif neyci?” diye sorduğunuzu rahatlıkla duyabiliyorum…

Gelin isterseniz ‘alternatif inşacı’ kavramını bir dizi örnek üzerinde
kabataslak da olsa açıklamaya çalışalım.

Şimdi elinizde şöyle bir kitap listesi olduğunu düşünün:

```python
liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

```

Bu liste, her bir kitap için, sırasıyla o kitabın ISBN numarasını, yazarını,
ismini ve yayınevini gösteren birer demetten oluşuyor. Amacımız, bu listeden
çeşitli ölçütlere göre sorgulama yapabilen bir program yazmak. Yazdığımız
program; isbn, isim, eser ve yayınevi ölçütlerine göre bu listeden veri
alabilmemizi sağlayacak.

İlk denememizi yapalım:

```python
liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

def sorgula(ölçüt=None, değer=None):
 for li in liste:
 if not ölçüt and not değer:
 print(*li, sep=', ')

 elif ölçüt == 'isbn':
 if değer == li[0]:
 print(*li, sep=', ')

 elif ölçüt == 'yazar':
 if değer == li[1]:
 print(*li, sep=', ')

 elif ölçüt == 'eser':
 if değer == li[2]:
 print(*li, sep=', ')

 elif ölçüt == 'yayınevi':
 if değer == li[3]:
 print(*li, sep=', ')

```

Burada öncelikle kitap listemizi tanımladık. Daha sonra da sorgulama işlemini
gerçekleştireceksorgula()adlı bir fonksiyon yazdık.

Bu fonksiyon toplam iki parametre alıyor:ölçütvedeğer. Bu parametrelerin
öntanımlı değerleriniNoneolarak belirledik. Böylece bu fonksiyonu herhangi
bir argüman vermeden de çalıştırabileceğiz.

Fonksiyon gövdesinde ilk yaptığımız iş, fonksiyon argümansız çalıştırıldığında,
yaniölçütvedeğeriçin herhangi bir değer belirlenmediğinde ne olacağını
ayarlamak:

```python
for li in liste:
 if not ölçüt and not değer:
 print(*li, sep=', ')

```

Eğerölçütvedeğerparametreleri için herhangi bir değer belirtilmemişse,
yani bunlarNoneolarak bırakılmışsa, kitap listesinin tamamını, her bir öğe
arasına birer virgül yerleştirerek ekrana basıyoruz.

Eğersorgula()fonksiyonu çağrılırkenölçütparametresine‘isbn’argümanı,değerparametresine ise bir ISBN değeri verilmişse şu işlemi
yapıyoruz:

```python
elif ölçüt == 'isbn':
 if değer == li[0]:
 print(*li, sep=', ')

```

Burada yaptığımız şey şu: Eğerölçüt‘isbn’ ise, fonksiyona verilendeğerargümanını, kitap listesi içindeki her bir demetin ilk sırasında arıyoruz. Çünkü
ISBN bilgileri demetlerin ilk sırasında yer alıyor. Eğer bu koşul sağlanırsa
listenin ilgili kısmını ekrana basıyoruz:

```python
if değer == li[0]:
 print(*li, sep=', ')

```

Bu mantığı kullanarak öteki ölçütler için de birer sorgu kodu yazıyoruz:

```python
elif ölçüt == 'yazar':
 if değer == li[1]:
 print(*li, sep=', ')

elif ölçüt == 'eser':
 if değer == li[2]:
 print(*li, sep=', ')

elif ölçüt == 'yayınevi':
 if değer == li[3]:
 print(*li, sep=', ')

```

Her birdeğer’i, listenin ilgili sırasında aradığımıza dikkat edin. Yazar
bilgisi demetlerin ikinci sırasında yer aldığı içinli[1]’i, aynı gerekçeyle
eser içinli[2]’yi, yayınevi için iseli[3]’ü sorguluyoruz.

Gelelim bu fonksiyonu nasıl kullanacağımıza…

Her zaman söylediğimiz gibi, Python’ın etkileşimli kabuğu mükemmel bir test
ortamıdır. O halde şimdi bu kodlarıklist.pyadlı bir dosyaya kaydedelim ve
dosyanın bulunduğu dizinde bir etkileşimli kabuk oturumu başlatarak modülümüzü
içe aktaralım:

```python
>>> import klist

```

Önceklistmodülü içindekisorgula()fonksiyonunu argümansız olarak
çağıralım:

```python
>>> klist.sorgula()

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis
975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki
9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

```

Tam da beklediğimiz gibi, fonksiyon argümansız çağrıldığında bütün kitap
listesini, her bir öğe arasında bir virgül olacak şekilde ekrana basıyor.

Şimdi de mesela ISBN numarasına göre birkaç sorgu işlemi gerçekleştirelim:

```python
>>> klist.sorgula('isbn', '9789754060409')

9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt , Cem

>>> klist.sorgula('isbn', '975872519X')

975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki

>>> klist.sorgula('isbn', '9789753424080')

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis

```

Burada,sorgula()fonksiyonunun ilk parametresine argüman olarak ‘isbn’
değerini verdik. Böylece programımız ISBN numarasına göre sorgu yapmak
istediğimizi anladı. Daha sonra da ikinci argüman olarak istediğimiz bir ISBN
numarasını yazdık ve sorgu işlemini tamamladık.

Bir de yayınevine göre sorgulama yapalım:

```python
>>> klist.sorgula('yayınevi', 'Metis')

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis

>>> klist.sorgula('yayınevi', 'İthaki')

975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki

>>> klist.sorgula('yayınevi', 'Cem')

9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

```

Gördüğünüz gibi, fonksiyonumuz gayet güzel çalışıyor…

Yukarıda verdiğimiz kodlar, bahsettiğimiz amaç için yazılabilecek tek alternatif
değildir elbette. Mesela yukarıdakiif-elseyapısını bir sözlük içine
yerleştirerek çok daha sade bir program elde edebiliriz.

Dikkatlice inceleyin:

```python
liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

def sorgula(ölçüt=None, değer=None):
 d = {'isbn' : [li for li in liste if değer == li[0]],
 'yazar' : [li for li in liste if değer == li[1]],
 'eser' : [li for li in liste if değer == li[2]],
 'yayınevi' : [li for li in liste if değer == li[3]]}

 for öğe in d.get(ölçüt, liste):
 print(*öğe, sep = ', ')

```

Burada bütünif-elsecümleciklerini birer liste üretecine dönüştürüp,dadlı sözlüğün anahtarları olarak belirledik. Artık sorgulama işlemlerini birif-elseyapısı içinde değil de, bir sözlük içinden gerçekleştireceğiz.

Hangi parametrenin hangi listeyi çağıracağını belirleyen sözlüğümüzü yazdıktan
sonra, sözlükleringet()metodunu kullanarak,ölçütargümanının değerine
göre sözlükten veri çekiyoruz. Eğer sözlükte bulunmayan birölçütdeğeri
verilirse tüm listeyi ekrana basıyoruz.

Bu arada, eğerdsözlüğü içindeki liste üreteçlerinin birbirini tekrar eder
bir yapıda olması sizi rahatsız ediyorsa, bu kısmı bir yardımcı fonksiyon
aracılığıyla sadeleştirebilirsiniz:

```python
liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

def bul(değer, sıra):
 return [li for li in liste if değer == li[sıra]]

def sorgula(ölçüt=None, değer=None):
 d = {'isbn' : bul(değer, 0),
 'yazar' : bul(değer, 1),
 'eser' : bul(değer, 2),
 'yayınevi' : bul(değer, 3)}

 for öğe in d.get(ölçüt, liste):
 print(*öğe, sep = ', ')

```

Burada bütün liste üreteçlerini tek birbul()fonksiyonu içinde oluşturarak,sorgula()fonksiyonu içindekidsözlüğüne gönderdik.

Bu kodları da aynı ilk program örneğinde olduğu gibi kullanıyoruz:

```python
>>> import klist
>>> klist.sorgula()

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis
975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki
9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

>>> klist.sorgula('yazar', 'Nietzsche')

9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

>>> klist.sorgula('eser', 'Sana Gül Bahçesi Vadetmedim')

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis

```

Yukarıdaki kodları yazmanın daha başka alternatifleri de var. Mesela, eğer arzu
ederseniz, yukarıdaki kodları bir sınıf yapısı içinde de ifade edebilirsiniz:

```python
class Sorgu():
 def __init__(self):
 self.liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

 def bul(self, değer, sıra):
 return [li for li in self.liste if değer == li[sıra]]

 def sorgula(self, ölçüt=None, değer=None):
 d = {'isbn' : self.bul(değer, 0),
 'yazar' : self.bul(değer, 1),
 'eser' : self.bul(değer, 2),
 'yayınevi' : self.bul(değer, 3)}

 for öğe in d.get(ölçüt, self.liste):
 print(*öğe, sep = ', ')

```

Burada kitap listesini bir örnek niteliği olarak tanımlamak suretiyle sınıfın
her yerinden kullanılabilir hale getirdik.

Ardından dabul()vesorgula()adlı fonksiyonları, birer örnek metodu
biçiminde sınıf içine yerleştirdik.

Bu sınıfı da şu şekilde kullanabiliriz:

```python
>>> import klist
>>> sorgu = klist.Sorgu()
>>> sorgu.sorgula()

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis
975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki
9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

>>> sorgu.sorgula('yazar', 'Evren')

975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki

```

Elbette, bu örnekte, ilk yazdığımız kodları bir sınıf yapısı içinde tarif
etmenin bize pek bir katkısı yok. Burada yaptığımız şey esasında bütün kodları
‘Sorgu’ adlı bir etki alanı içine taşımaktan fazlası değil. Ama böyle bir
imkanınızın da olduğunu bilmeniz her halükarda sizin için faydalı olacaktır.

Gelelim yukarıdaki kodları yazmanın son alternatifine:

```python
class Sorgu():
 def __init__(self, değer=None, sıra=None):
 self.liste = [('9789753424080', 'Greenberg', 'Sana Gül Bahçesi Vadetmedim', 'Metis'),
 ('975872519X', 'Evren', 'Postmodern Bir Kız Sevdim', 'İthaki'),
 ('9789754060409', 'Nietzsche', 'Böyle Buyurdu Zerdüşt', 'Cem')]

 if not değer and not sıra:
 l = self.liste
 else:
 l = [li for li in self.liste if değer == li[sıra]]

 for i in l:
 print(*i, sep=', ')

 @classmethod
 def isbnden(cls, isbn):
 cls(isbn, 0)

 @classmethod
 def yazardan(cls, yazar):
 cls(yazar, 1)

 @classmethod
 def eserden(cls, eser):
 cls(eser, 2)

 @classmethod
 def yayınevinden(cls, yayınevi):
 cls(yayınevi, 3)

```

Burada da, her bir ölçütü ayrı birer sınıf metodu olarak tanımladık. Böylece bu
ölçütleri yapısal olarak birbirinden ayırmış olduk. Yukarıdaki sınıfı şu şekilde
kullanabiliriz:

Önce modülümüzü içe aktaralım:

```python
>>> from klist import Sorgu

```

ISBN numarasına göre bir sorgu gerçekleştirelim:

```python
>>> Sorgu.isbnden("9789753424080")

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis

```

Gördüğünüz gibi, sınıf metodu yaklaşımı, gayet temiz bir sorgu kodu üretmemize
imkan tanıyor.

Bir de yazara ve esere göre sorgulayalım:

```python
>>> Sorgu.yazardan("Greenberg")

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis

>>> Sorgu.eserden("Postmodern Bir Kız Sevdim")

975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki

```

Bunlar da gayet güzel görünüyor.

Şimdi bir de bütün listeyi alalım:

```python
>>> hepsi = Sorgu()

9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis
975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki
9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem

```

Gördüğünüz gibi, sınıfı parametresiz olarak örneklediğimizde bütün listeyi elde
ediyoruz.

İşte ‘alternatif inşa’ denen işlem tam olarak budur. Yukarıdaki örnekteisbnden(),yazardan(),eserden()veyayınevinden()adlı sınıf
metotları,Sorgu()adlı sınıfı alternatif şekillerde inşa etmemizi sağlıyor[1].

Normal şartlarda, bir sınıfı,__init__()fonksiyonuna verdiğimiz
parametreler aracılığıyla inşa ediyoruz (birkaç sayfa sonra ‘inşa’ kavramından
daha ayrıntılı olarak bahsedeceğiz).

Mesela:

```python
class Giriş():
 def __init__(self, mesaj='Müşteri numaranız: '):
 cevap = input(mesaj)
 print('Hoşgeldiniz!')

```

Burada tanımladığımızGiriş()sınıfı, bir müşteri numarası aracılığıyla
sisteme giriş imkanı sağlıyor:

```python
>>> from sistem import Giriş #kodlarımız sistem.py dosyası içinde
>>> Giriş()

```

Eğer biz aynı zamanda bir parola ve TC Kimlik Numarası ile de giriş imkanı
sağlamak istersek, başka yöntemlerin yanı sıra, sınıf metotlarından da
yararlanabiliriz:

```python
class Giriş():
 def __init__(self, mesaj='Müşteri numaranız: '):
 cevap = input(mesaj)
 print('Hoşgeldiniz!')

 @classmethod
 def paroladan(cls):
 mesaj = 'Lütfen parolanızı giriniz: '
 cls(mesaj)

 @classmethod
 def tcknden(cls):
 mesaj = 'Lütfen TC kimlik numaranızı giriniz: '
 cls(mesaj)

```

Bu şekilde yukarıdaki sınıfı aşağıdaki gibi de inşa etme imkanına kavuşuyoruz:

```python
>>> Giriş.paroladan()

```

veya:

```python
>>> Giriş.tcknden()

```

Sınıf metotları içinde kullandığımızcls(mesaj)satırları,Giriş()adlı
sınıfı farklı bir parametre ile çağırmamızı sağlıyor. Gördüğünüz gibi, bu
sınıfınmesajparametresinin öntanımlı değeri‘Müşteri numaranız: ‘.
Sınıfımızı farklı bir şekilde çağırabilmek için,cls(mesaj)kodları
yardımıyla sınıfınmesajparametresini‘Lütfen parolanızı giriniz: ‘ve‘Lütfen TC kimlik numaranızı giriniz: ‘değerleri ile yeniden çalıştırıyoruz.

Daha önce de birkaç kez vurguladığımız gibi,clskelimesi Python açısından bir
zorunluluk değildir. Yani yukarıdaki sınıfı mesela şöyle de yazabilirdik:

```python
class Giriş():
 def __init__(self, mesaj='Müşteri numaranız: '):
 cevap = input(mesaj)
 print('Hoşgeldiniz!')

 @classmethod
 def paroladan(snf):
 mesaj = 'Lütfen parolanızı giriniz: '
 snf(mesaj)

 @classmethod
 def tcknden(snf):
 mesaj = 'Lütfen TC kimlik numaranızı giriniz: '
 snf(mesaj)

```

Ancak, tıpkıselfkelimesinde olduğu gibi,clsde Python topluluğu içinde
son derece yerleşik bir gelenektir. Bu geleneği bozmak isteyeceğinizi
zannetmiyorum.

İlk bakışta sınıf metotları size pek gerekli değilmiş gibi gelebilir. Ama eğer
bu metotların gerçek dünyadaki kullanımına ilişkin bir örnek verirsek belki
fikriniz değişir.

Sınıf metotlarının kullanımına ilişkin güzel bir örneğidatetimemodülünde
görebilirsiniz.

> **Ayrıca bakınız**
> Aşağıdaki örneği daha iyi anlayabilmek içindatetime Modülüvetime Modülübelgelerine
bakınız.

Ayrıca bakınız

Aşağıdaki örneği daha iyi anlayabilmek içindatetime Modülüvetime Modülübelgelerine
bakınız.

Bir standart kütüphane modülü olandatetime’ın kaynak dosyasını açarsanız
(kaynak dosyanın nerede olduğunu nasıl öğrenebilirim diye soran arkadaşlara
teessüflerimi iletiyorum…), oradadatesınıfının şöyle yazıldığını
göreceksiniz:

```python
class date:
 __slots__ = '_year', '_month', '_day'

 def __new__(cls, year, month=None, day=None):
 if (isinstance(year, bytes) and len(year) == 4 and
 1 <= year[2] <= 12 and month is None): # Month is sane
 # Pickle support
 self = object.__new__(cls)
 self.__setstate(year)
 return self
 _check_date_fields(year, month, day)
 self = object.__new__(cls)
 self._year = year
 self._month = month
 self._day = day
 return self

 @classmethod
 def fromtimestamp(cls, t):
 y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)
 return cls(y, m, d)

 @classmethod
 def today(cls):
 t = _time.time()
 return cls.fromtimestamp(t)

 @classmethod
 def fromordinal(cls, n):
 y, m, d = _ord2ymd(n)
 return cls(y, m, d)

```

Gördüğünüz gibi, burada üç tane sınıf metodu var:

```python
@classmethod
def fromtimestamp(cls, t):
 ...

@classmethod
def today(cls):
 ...

@classmethod
def fromordinal(cls, n):
 ...

```

Normal şartlardadatetimemodülü içindekidatesınıfını şu şekilde
kullanıyoruz:

```python
>>> import datetime
>>> bugün = datetime.date(2015, 6, 16)

```

Bu şekilde,datesınıfına sırasıyla yıl, ay ve gün bilgisi girerekbugünadlı bir tarih nesnesi oluşturmuş oluyoruz. Bu şekilde herhangi bir tarihi elle
oluşturabilirsiniz.

Eğer amacınız bugünün tarihini oluşturmaksa, yıl, ay ve gün bilgilerini
yukarıdaki gibidatesınıfına elle girebileceğiniz gibi,today()adlı
sınıf metodunu da kullanabilirsiniz:

```python
>>> bugün = datetime.date.today()

```

İşte böylece,datesınıfının size sunduğu bir alternatif inşacı
(today()) vasıtasıyla bugünün tarihini otomatik olarak elde etmiş oldunuz.

Aynı şekilde, eğer elinizde bir zaman damgası varsa ve siz bu zaman damgasından
bir tarih elde etmek istiyorsanız yinedatesınıfının sunduğu bir başka
alternatif inşacıdan yararlanabilirsiniz:

```python
>>> import time
>>> zaman_damgası = time.time()
>>> bugün = datetime.date.fromtimestamp(zaman_damgası)

```

Eğer elinizde tam sayı biçimli bir Gregoryen tarih verisi varsa bu veriyi
kullanarak da bir tarih nesnesi elde edebilirsiniz:

```python
>>> gregoryen = 735765
>>> bugün = datetime.date.fromordinal(gregoryen)

datetime.date(2015, 6, 16)

```

Uzun lafın kısası, alternatif inşacılar, bir sınıftan nesne oluşturmak için bize
alternatif yollar sunan son derece faydalı araçlardır. Bu arada, eğer bu bölümde
değindiğimiz bazı kavramları anlamakta zorlandıysanız hiç canınızı sıkmayın. Bir
sonraki bölümü işledikten sonra, burada anlatılanlar kafanıza çok daha sağlam
bir şekilde yerleşmiş olacak.

### Statik Metotlar

Python’da örnek metotları ve sınıf metotları dışında bir de statik metotlar
bulunur. Bildiğiniz gibi, örnek nitelikleri üzerinde işlem yapacağımız zaman
örnek metotlarını kullanıyoruz. Aynı şekilde sınıf nitelikleri üzerinde işlem
yapacağımız zaman ise sınıf metotlarından faydalanıyoruz. Örnek metotları içinde
herhangi bir örnek niteliğine erişmek istediğimizdeselfkelimesini
kullanıyoruz. Sınıf metotları içinde bir sınıf niteliğine erişmek için iseclskelimesini kullanıyoruz. İşte eğer bir sınıf içindeki herhangi bir
fonksiyonda örnek veya sınıf niteliklerinin hiçbirine erişmeniz gerekmiyorsa,
statik metotları kullanabilirsiniz.

### @staticmethod Bezeyicisi

Buraya gelene kadar öğrendiğimiz örnek ve sınıf metotlarını nasıl
kullanacağımızı biliyorsunuz:

```python
class Sınıf():
 sınıf_niteliği = 0

 def __init__(self, veri):
 self.veri = veri

 def örnek_metodu(self):
 return self.veri

 @classmethod
 def sınıf_metodu(cls):
 return cls.sınıf_niteliği

```

Buradaörnek_metodu(),selfyardımıyla örnek niteliklerine erişiyor.sınıf_metodu()iseclsyardımıyla sınıf niteliklerine erişiyor. Sınıf
metodu tanımlamak için ayrıca@classmethodbezeyicisini de kullanıyoruz. İşte
eğer sınıf içinde tanımlayacağınız fonksiyon herhangi bir örnek ya da sınıf
niteliği üzerinde herhangi bir işlem yapmayacaksa şöyle bir şey yazabilirsiniz:

```python
class Sınıf():
 sınıf_niteliği = 0

 def __init__(self, veri):
 self.veri = veri

 def örnek_metodu(self):
 return self.veri

 @classmethod
 def sınıf_metodu(cls):
 return cls.sınıf_niteliği

 @staticmethod
 def statik_metot():
 print('merhaba statik metot!')

```

Gördüğünüz gibi, statik metotları tanımlamak için@staticmethodbezeyicisini
kullanıyoruz. Statik metotlar, ilk parametre olarakselfveyaclsbenzeri
kelimeler almaz. Çünkü bu tür sınıfların örnek veya sınıf nitelikleri ile
herhangi bir işi yoktur.

Peki statik metotlar ne işe yarar?

Bu metotlar sınıf metotlarına çok benzer. Tıpkı sınıf metotlarında olduğu gibi,
anlamsal olarak sınıfla ilgili olan, ancak sınıf metotlarının aksine bu sınıfın
herhangi bir niteliğine erişmesine gerek olmayan fonksiyonları, sınıf dışına
atmak yerine, birer statik metot olarak sınıf içine yerleştirebiliriz.

Basit bir örnek verelim:

```python
class Mat():
 '''Matematik işlemleri yapmamızı sağlayan
 bir sınıf.'''

 @staticmethod
 def pi():
 return 22/7

 @staticmethod
 def karekök(sayı):
 return sayı ** 0.5

```

BuradaMat()adlı bir sınıf tanımladık. Bu sınıf içinde iki adet statik
metodumuz var:pi()vekarekök(). Gördüğünüz gibi, bu iki fonksiyon,
örnek ve sınıf metotlarının aksine ilk parametre olarakselfveyaclsalmıyor. Çünkü bu iki sınıfın da sınıf veya örnek nitelikleriyle herhangi bir
işi yok.

Statik metotları hem örnekler hem de sınıf adları üzerinden kullanabiliriz.

Yukarıdaki kodlarınmat.pyadlı bir dosyada yer aldığını varsayarsak:

```python
>>> from mat import Mat
>>> m = Mat()
>>> m.pi() #örnek üzerinden

3.142857142857143

>>> m.karekök(144) #örnek üzerinden

12.0

>>> Mat.pi() #sınıf üzerinden
3.142857142857143

>>> Mat.karekök(144) #sınıf üzerinden

12.0

```

Statik metotların özellikle sınıf adları üzerinden kullanılabilmesi, bu tür
metotları epey kullanışlı hale getirir. Böylece sınıfı örneklemek zorunda
kalmadan, sınıf içindeki statik metotlara ulaşabiliriz.

Elbette eğer isteseydik biz bu fonksiyonları şöyle de tanımlayabilirdik:

```python
class Mat():
 '''Matematik işlemleri yapmamızı sağlayan
 bir sınıf.'''

 def pi(self):
 return 22/7

 def karekök(self, sayı):
 return sayı ** 0.5

```

Burada bu iki fonksiyonu birer örnek metodu olarak tanımladık. Bu fonksiyonları
bu şekilde tanımladığımızda, bunlara örnekler üzerinden erişebiliriz:

```python
>>> from mat import Mat
>>> m = Mat()
>>> m.pi()

3.142857142857143

>>> m.karekök(144)

12.0

```

Ancak bildiğiniz gibi, örnek metotlarına sınıf adları üzerinden erişemeyiz:

```python
>>> Mat.pi()

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: pi() missing 1 required positional argument: 'self'

```

Aynı şekilde bunları sınıf metodu olarak da tanımlayabilirdik:

```python
class Mat():
 '''Matematik işlemleri yapmamızı sağlayan
 bir sınıf.'''

 @classmethod
 def pi(cls):
 return 22/7

 @classmethod
 def karekök(cls, sayı):
 return sayı ** 0.5

```

Bu metotları böyle tanımladığımızda, bu metotlara hem örnekler üzerinden hem de
sınıf adı üzerinden erişebiliriz:

```python
>>> from mat import Mat
>>> m = Mat()
>>> m.pi() #örnek üzerinden

3.142857142857143

>>> m.karekök(144) #örnek üzerinden

12.0

>>> Mat.pi() #sınıf üzerinden
3.142857142857143

>>> Mat.karekök(144) #sınıf üzerinden

12.0

```

Gördüğünüz gibi, kullanım açısından sınıf metotları ile statik metotlar aynı.
AncakMat()sınıfı içindeki fonksiyonları birer sınıf metodu olarak
tanımladığımızda gereksiz yereclsparametresi kullanmış oluyoruz. Fonksiyon
içinde herhangi bir yerde kullanılmadığı için, yukarıdaki örnekteclsparametresinin hiçbir amaca hizmet etmediğine dikkat edin.

Statik metotların çok sık kullanılan araçlar olmadığını da belirterek yolumuza
devam edelim.

Dipnotları:

Aslında burada inşa edilen şey sınıftan ziyade nesnedir. Bu durumu ve
‘nesne’ kavramını bir sonraki bölümde ayrıntılı olarak ele alacağız.

## Nesne Tabanlı Programlama (Devamı)

Bu bölümde de, temellerini geçen derslerimizde attığımız nesne tabanlı
programlama konusunu incelemeye devam edeceğiz. Bu bölümde uygulamaya yönelik
bazı örnekler yapmanın yanı sıra, nesne tabanlı programlamaya ilişkin bazı teorik
bilgiler de vereceğiz.

### Nesneler

Geçen bölümlerden birinde sınıfları tanımlarken, bunların, nesne üretmemizi
sağlayan bir veri tipi olduğuna dair muğlak bir laf etmiştik. İşte bu başlık
altında, o tanım içinde geçen ve nesne tabanlı programlamanın temelini oluşturan
‘nesne’ kavramı üzerine eğileceğiz.

### Nesne Nedir?

Programlamaya ilişkin kavramlar içinde, özellikle programlamaya yeni
başlayanların kafasını en fazla karıştıran kavram nedir diye sorsak, herhalde
alacağımız cevap ‘nesne’ olur. Hakikaten, sağda solda sürekli duyduğumuz bu
‘nesne’ denen şey, öteden beri yazılım geliştirici adaylarının zihnini
karıştırır durur.

Aslında ‘nesne’ (object) dedikleri, ilk bakışta uyandırdığı izlenimin aksine,
anlaması zor, gizemli bir kavram değildir. Dolayısıyla, nesne kavramına ilişkin
olarak öğrenmemiz gereken ilk şey, bunun abartılacak veya korkulacak bir şey
olmadığıdır. Peki ama tam olarak nedir bu nesne dedikleri?

Kabaca, Python’da belli birtakım metotlara ve/veya niteliklere sahip olan
öğelere nesne adı verilir. Yani ‘nesne’ kelimesi, içinde birtakım metot ve/veya
nitelikler barındıran öğeleri tanımlamak için kullanılan bir tabirden, basit bir
isimlendirmeden ibarettir.

Peki bir nesne oluşturmak için acaba ne yapmamız gerekiyor?

Hatırlarsanız, geçen bölümde, sınıfların nesne üretmemizi sağlayan veri tipleri
olduğunu söylemiştik. O halde gelin minik bir nesne üretelim:

```python
class Sınıf():
 pass

sınıf = Sınıf()

```

İşte bu kodlardakisınıf=Sınıf()komutu ile bir nesne üretmiş olduk.
Nesnemizin adı da ‘sınıf’. Teknik olarak ifade edersek,sınıförneği,Sınıf()adlı sınıfın bütün nitelik ve metotlarını bünyesinde barındıran bir
nesnedir. Mesela yukarıdaki kodlarınsınıf.pyadlı bir dosyada bulunduğunu
varsayarak şöyle bir deneme yapalım:

```python
>>> import sınıf
>>> snf = sınıf.Sınıf()

```

Bu şekilde, kodları içeren modülü içe aktarmış ve modül içindekiSınıf()adlı sınıfısnfadı ile örneklemiş olduk. Yani yukarıdaki kodlar yardımıylasnfadlı bir nesne oluşturduk. Bakalım bu nesne hangi nitelik ve/veya
metotlara sahipmiş:

```python
>>> dir(snf)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
 '__sizeof__', '__str__', '__subclasshook__', '__weakref__']

```

Gördüğünüz gibi, biz boş bir sınıf tanımlamış olsak da,snfnesnesi öntanımlı
olarak yine de bazı nitelik ve metotlara sahip. İşte Python’da, yukarıdaki gibi
birtakım nitelik ve metotlara sahip olan bu tür öğelere ‘nesne’ adı veriyoruz.

Bir de isterseniz yukarıdaki gibi boş bir sınıf tanımlamak yerine, sınıfımız
içinde kendimiz birtakım nitelik ve metotlar tanımlamayı da deneyelim:

```python
class Sınıf():
 sınıf_niteliği = 'sınıf niteliği'

 def __init__(self):
 self.örnek_niteliği = 'örnek niteliği'

 def örnek_metodu(self):
 print('örnek metodu')

 @classmethod
 def sınıf_metodu(cls):
 print('sınıf metodu')

 @staticmethod
 def statik_metot():
 print('statik metot')

```

Şimdi nesne içeriğini tekrar kontrol edelim:

```python
>>> import sınıf
>>> snf = sınıf.Sınıf()
>>> dir(snf)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
 '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
 'statik_metot', 'sınıf_metodu', 'sınıf_niteliği',
 'örnek_metodu', 'örnek_niteliği']

```

Gördüğünüz gibi, kendi tanımladığımız nitelik ve metotlar dasnfadlı nesne
içine eklenmiş…

İştesnfadlı sınıf örneğinin, yukarıda gösterilen birtakım durum ve
davranışlara sahip olmasından yola çıkarak,snförneğinin bir nesne olduğunu
söylüyoruz.

Yukarıdaki açıklamaların, ‘nesne’ kavramı hakkında en azından bir fikir sahibi
olmanızı sağladığını zannediyorum. Gördüğünüz gibi, nesne denen şey aslında
basit bir isimlendirmeden ibarettir: Python’da belli bir
durumu/niteliği/metodu/davranışı olan elemanlara/öğelere nesne (object) adı
veriyoruz. Peki o zaman, nesne denen şey basit bir adlandırmadan ibaretse nesne
tabanlı programlamanın etrafında koparılan bunca yaygaranın sebebi nedir?

Nesne tabanlı programlamayı bu kadar özel ve önemli kılan şeyin ne olduğunu
anlamak için gelin nesnelere biraz daha yakından bakalım.

### Basit Bir Oyun

Gelin isterseniz nesne denen kavramı daha iyi anlayabilmek, bir nesneyi nesne
yapan metot ve nitelikler arasındaki ilişkiyi daha net bir şekilde kavrayabilmek
için, komut satırı üzerinde çalışan çok basit bir oyun tasarlayalım. Bu şekilde
hem eski bilgilerimizi tekrar etmiş oluruz, hem teorik bilgilerimizi uygulama
sahasına dökmüş oluruz, hem de yeni şeyler öğrenmiş oluruz.

Oyunumuzun kodları şöyle:

```python
import time
import random
import sys

class Oyuncu():
 def __init__(self, isim, can=5, enerji=100):
 self.isim = isim
 self.darbe = 0
 self.can = can
 self.enerji = enerji

 def mevcut_durumu_görüntüle(self):
 print('darbe: ', self.darbe)
 print('can: ', self.can)
 print('enerji: ', self.enerji)

 def saldır(self, rakip):
 print('Bir saldırı gerçekleştirdiniz.')
 print('Saldırı sürüyor. Bekleyiniz.')

 for i in range(10):
 time.sleep(.3)
 print('.', end='', flush=True)

 sonuç = self.saldırı_sonucunu_hesapla()

 if sonuç == 0:
 print('\nSONUÇ: kazanan taraf yok')

 if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 self.darbele(rakip)

 if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 rakip.darbele(self)

 def saldırı_sonucunu_hesapla(self):
 return random.randint(0, 2)

 def kaç(self):
 print('Kaçılıyor...')
 for i in range(10):
 time.sleep(.3)
 print('\n', flush=True)

 print('Rakibiniz sizi yakaladı')

 def darbele(self, darbelenen):
 darbelenen.darbe += 1
 darbelenen.enerji -= 1
 if (darbelenen.darbe % 5) == 0:
 darbelenen.can -= 1
 if darbelenen.can < 1:
 darbelenen.enerji = 0
 print('Oyunu {} kazandı!'.format(self.isim))
 self.oyundan_çık()

 def oyundan_çık(self):
 print('Çıkılıyor...')
 sys.exit()

##################################

# Oyuncular
siz = Oyuncu('Ahmet')
rakip = Oyuncu('Mehmet')

# Oyun başlangıcı
while True:
 print('Şu anda rakibinizle karşı karşıyasınız.',
 'Yapmak istediğiniz hamle: ',
 'Saldır: s',
 'Kaç: k',
 'Çık: q', sep='\n')

 hamle = input('\n> ')
 if hamle == 's':
 siz.saldır(rakip)

 print('Rakibinizin durumu')
 rakip.mevcut_durumu_görüntüle()

 print('Sizin durumunuz')
 siz.mevcut_durumu_görüntüle()

 if hamle == 'k':
 siz.kaç()

 if hamle == 'q':
 siz.oyundan_çık()

```

Komut satırı üzerinde çalışan basit bir oyundur bu. Dilerseniz bu kodları
incelemeye başlamadan önce, bir dosyaya kaydedip çalıştırın. Karşınıza şöyle bir
ekran gelecek:

```python
Şu anda rakibinizle karşı karşıyasınız.
Yapmak istediğiniz hamle:
Saldır: s
Kaç: k
Çık: q

>

```

Programımız bize burada üç farklı seçenek sunuyor. Eğer rakibimize saldırmak
istiyorsak klavyedeki ‘s’ tuşuna; rakibimizden kaçmak istiyorsak klavyedeki ‘k’
tuşuna; yok eğer oyundan çıkmak istiyorsak da klavyedeki ‘q’ tuşuna basacağız.
Tercihinizi belirleyip neler olduğunu inceleyin ve oyunu iyice tanımaya çalışın.

Oyunu iyice anlayıp tanıdıktan sonra oyun kodlarını incelemeye geçebiliriz.

Yukarıda ilk olarakOyuncuadlı bir sınıf tanımladık:

```python
class Oyuncu():
 def __init__(self, isim, can=5, enerji=100):
 self.isim = isim
 self.darbe = 0
 self.can = can
 self.enerji = enerji

```

classkelimesinin sınıf tanımlamamızı sağlayan bir araç,Oyuncukelimesinin
ise tanımladığımız sınıfın adı olduğunu biliyoruz. Bu satırın hemen ardından
gelen__init__()fonksiyonu, sınıfımız örneklendiğinde neler olacağını
tanımladığımız yerdir. Bu sınıfın, örnekleme sırasında hangi parametreleri
alacağını da__init__()fonksiyonu içinde belirliyoruz. Parametre listesinde
gördüğümüz ilk öğe, yaniself, sınıfın o anki örneğini temsil ediyor.
Python’ın söz dizimi kuralları gereğince bu kelimeyi oraya yazmamız gerektiğini
biliyoruz.

Yukarıdaki fonksiyon,selfdışında toplam üç parametre alıyor:isim,canveenerji. Bunlardan ilki, yaniisimparametresinin öntanımlı bir değeri
yok. Dolayısıyla sınıfı çağırırken (yani örneklerken) bu parametrenin değerini
belirtmemiz gerekecek. Öteki iki parametre olancanveenerjiise birtakım
öntanımlı değerlere sahip. Dolayısıyla sınıfı örneklendirirken bu parametrelere
farklı bir değer atamadığımız sürece, bu parametreler, listede belirtilen
değerleri taşıyacak.

Parametre olarak belirlediğimiz değerleri sınıf içinde kullanabilmek için,
bunları__init__()fonksiyonunun gövdesinde birer örnek niteliğine
dönüştürüyoruz:

```python
self.isim = isim
self.darbe = 0
self.can = can
self.enerji = enerji

```

Burada ilave olarak bir de değeri 0 olanself.darbeadlı bir değişken
tanımladık. Bu da sınıfımızın örnek niteliklerinden biri olup, ilgili oyuncu
(yani sınıfın o anki örneği) darbe aldıkça bunun değeri yükselecektir.

Gelin isterseniz bu aşamada sınıfımızı örnekleyerek neler olup bittiğini daha
net anlamaya çalışalım:

```python
class Oyuncu():
 def __init__(self, isim, can=5, enerji=100):
 self.isim = isim
 self.darbe = 0
 self.can = can
 self.enerji = enerji

#Sınıfımızı örnekliyoruz
oyuncu = Oyuncu('Ahmet')

```

Buradaoyuncu=Oyuncu('Ahmet')komutunu verdiğimiz anda__init__()fonksiyonu çalışmaya başlıyor veoyuncuadlı nesne için sırasıyla şu
değişkenleri oluşturuyor:

```python
isim = 'Ahmet'
darbe = 0
can = 5
enerji = 100

```

Bu örnek niteliklerine nasıl ulaşabileceğinizi biliyorsunuz:

```python
print('İsim: ', oyuncu.isim)
print('Darbe: ', oyuncu.darbe)
print('Can: ', oyuncu.can)
print('Enerji: ', oyuncu.enerji)

```

Başta da söylediğimiz gibi,Oyuncu()sınıfını örnekleyerek meydana
getireceğiniz bütün sınıf örnekleri, yani nesneler,__init__()fonksiyonu
içinde tanımladığınız örnek niteliklerini taşıyacaktır:

```python
class Oyuncu():
 def __init__(self, isim, can=5, enerji=100):
 self.isim = isim
 self.darbe = 0
 self.can = can
 self.enerji = enerji

oyuncu1 = Oyuncu('Ahmet')
oyuncu2 = Oyuncu('Mehmet')
oyuncu3 = Oyuncu('Veli')
oyuncu4 = Oyuncu('Ayşe')

```

Buradaoyuncu1,oyuncu2,oyuncu3veoyuncu4olmak üzere dört farklı
nesne oluşturduk. Bu nesnelerin hangi niteliklere sahip olacağını iseOyuncu()sınıfının tanımı içinde belirttik. Yani sınıfımız tıpkı bir fabrika
gibi çalışarak, bizim için, aynı nitelikleri taşıyan dört farklı nesne üretti.

İşte nesne tabanlı programlamanın özünü oluşturan ‘nesne’ budur. Bir nesnenin
hangi niteliklere sahip olacağını belirleyen veri tipine sınıf (class) derken,
o sınıfın ortaya çıkardığı ürüne ise nesne (object) adını veriyoruz. Bunu şuna
benzetebilirsiniz: Eğer ‘İnsan’ bir sınıfsa, ‘Mahmut’ bu sınıfın bir örneğidir.
Dolayısıyla Mahmut, İnsan sınıfından üretilmiş bir nesnedir. Aynı şekilde eğer
‘Köpek’ bir sınıfsa, ‘Karabaş’ da bu sınıfın bir örneğidir. Yani Karabaş,
Köpek sınıfından üretilmiş bir nesnedir. Mahmut’un hangi özelliklere sahip
olacağını İnsan sınıfının nasıl tanımlandığı, Karabaş’ın hangi özelliklere
sahip olacağını ise Köpek sınıfının nasıl tanımlandığı belirler. İşte aynı
bunun gibi,Oyuncu()sınıfından üretilen nesnelerin hangi özelliklere sahip
olacağını daOyuncu()sınıfının nasıl tanımlandığı belirler.

Kodlarımızı incelemeye devam edelim…

```python
def mevcut_durumu_görüntüle(self):
 print('darbe: ', self.darbe)
 print('can: ', self.can)
 print('enerji: ', self.enerji)

```

Buradamevcut_durumu_görüntüle()adlı bir örnek metodu tanımladık. Örnek
metotlarının ilk parametresinin her zamanselfolması gerektiğini biliyoruz.

Tanımladığımız örnek metodunun görevi,Oyuncu()sınıfından oluşturduğumuz
nesnelerin (yani örneklerin) o ankidarbe,canveenerjidurumlarını
görüntülemek. Birer örnek niteliği olandarbe,canveenerjideğişkenlerineselfaracılığıyla eriştiğimize özellikle dikkat ediyoruz.

Gelelim sınıfımızın önemli örnek metotlarından biri olansaldır()fonksiyonunu incelemeye:

```python
def saldır(self, rakip):
 print('Bir saldırı gerçekleştirdiniz.')
 print('Saldırı sürüyor. Bekleyiniz.')

 for i in range(10):
 time.sleep(.3)
 print('.', end='', flush=True)

 sonuç = self.saldırı_sonucunu_hesapla()

 if sonuç == 0:
 print('\nSONUÇ: kazanan taraf yok')

 if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 self.darbele(rakip)

 if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 rakip.darbele(self)

```

Bu fonksiyon,selfdışında tek bir parametre alıyor. Fonksiyonu çalıştırırken
kullanacağımızrakipparametresi, saldırının kime karşı (yani sınıf
örneklerinden hangisine karşı) düzenleneceğini belirleyecek.

Fonksiyon gövdesinde ilk olarak şöyle bir kısım görüyoruz:

```python
print('Bir saldırı gerçekleştirdiniz.')
print('Saldırı sürüyor. Bekleyiniz.')

for i in range(10):
 time.sleep(.3)
 print('.', end='', flush=True)

```

Burada saldırının gerçekleştiğine dair kullanıcıyı bilgilendirdikten sonra şöyle
bir kod parçası yazdık:

```python
for i in range(10):
 time.sleep(.3)
 print('.', end='', flush=True)

```

Bu kodlardatimeadlı bir standart kütüphane modülününsleep()adlı bir
metodundan yararlandığımızı görüyorsunuz. Elbette bu modülü kullanabilmek için
öncelikle bu modülü içe aktarmış olmamız gerekiyor. Bu işlemi dosyanın en
başındaimporttimesatırı yardımıyla gerçekleştirdiğimizi görebilirsiniz.

Yukarıdaki satırlar, 300’er milisaniye aralıklarla, yan yana nokta işaretleri
yerleştirecektir. Dilerseniz etkileşimli kabukta bu kodları şu şekilde test
edebilirsiniz:

```python
>>> import time
>>> for i in range(10):
... time.sleep(.3)
... print('.', end='', flush=True)

```

print()fonksiyonu içinde kullandığımızendveflushparametrelerinin ne
olduğunu ve ne işe yaradığını ilk derslerimizden hatırlıyor olmalısınız. Eğer
hatırlamıyorsanız, bu parametreleri tek tek kodlardan çıkarıp, bu kodları bir de
öyle çalıştırın. Sonucun ne olduğunu takip ederek,endveflushparametrelerinin görevini daha iyi anlayabilirsiniz.

Bu kodların ardından şöyle bir satır yazdık:

```python
sonuç = self.saldırı_sonucunu_hesapla()

```

Burada,saldırı_sonucunu_hesapla()adlı bir örnek metodunu çağırdığımızı
görüyorsunuz:

```python
def saldırı_sonucunu_hesapla(self):
 return random.randint(0, 2)

```

Biraz öncetimeadlı bir standart kütüphane modülünü kullanmıştık. Şimdi iserandomadlı başka bir standart kütüphane modülünü kullanıyoruz. Elbette bu
modülü de kullanabilmek için öncelikle bu modülüimportrandomkomutuyla içe
aktarmış olmamız gerekiyor. Bu zorunluluğu da, tıpkıtimemodülünde olduğu
gibi, dosyanın en başında yerine getirmiştik.

Yukarıdarandommodülünü, 0 ile 2 arası rastgele sayılar üretmek için
kullandık.random.randint(0,2)komutu her çalıştığında 0, 1 ve 2
sayılarından birini rastgele üretecektir. Buradan elde ettiğimiz sonucusonuçadlı bir değişkene atayaraksaldır()fonksiyonu içinde şu şekilde
kullanıyoruz:

```python
sonuç = self.saldırı_sonucunu_hesapla()

if sonuç == 0:
 print('\nSONUÇ: kazanan taraf yok')

if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 self.darbele(rakip)

if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 rakip.darbele(self)

```

Eğerrandint()metodu 0 sayısını üretirse, rakibimize karşı
gerçekleştirdiğimiz saldırının sonuçsuz kaldığına hükmediyoruz:

```python
if sonuç == 0:
 print('\nSONUÇ: kazanan taraf yok')

```

Eğerrandint()metodu 1 sayısını üretirse, rakibimizi başarıyla
darbelediğimize, 2 sayısını üretirse de rakibimiz tarafından darbelendiğimize
hükmediyoruz:

```python
if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 self.darbele(rakip)

if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 rakip.darbele(self)

```

Saldırı sonucunda rakibimizi darbelediğimizde ve rakibimizden darbe yediğimizdedarbele()adlı bir başka örnek metodunu çağırdığımızı da gözden
kaçırmayın.

Bu arada, örnek metotlarına daselföneki ile eriştiğimize dikkatinizi çekmek
isterim. Ayrıca her ne kadar örnek metotlarını tanımlarken parantez listesi
içindeselfkelimesini belirtsek de, bu metotları çağırırken bunları argüman
olarak kullanmadığımıza da özellikle dikkat etmelisiniz. Yani biz bu metotları
şöyle tanımlıyoruz:

```python
def saldırı_sonucunu_hesapla(self):
 return random.randint(0, 2)

```

Burada parametre listesindeself’i görüyoruz. Ama bu fonksiyonları çağırırken
parantez içinde buself’i kullanmıyoruz:

```python
self.saldırı_sonucunu_hesapla()

```

self’i parantez içinde bir argüman olarak kullanmak yerine, bu kelimeyi
fonksiyon adının başına bir önek olarak takıyoruz.

Ne diyorduk? Evet,saldır()fonksiyonu içindedarbele()adlı bir
fonksiyona atıfta bulunduk. Yani saldırı sonucunda rakibimizi darbelediğimizde
ve rakibimizden darbe yediğimizdedarbele()adlı bir başka örnek
metodunu çağırdık:

```python
def darbele(self, darbelenen):
 darbelenen.darbe += 1
 darbelenen.enerji -= 1
 if (darbelenen.darbe % 5) == 0:
 darbelenen.can -= 1
 if darbelenen.can < 1:
 darbelenen.enerji = 0
 print('Oyunu {} kazandı!'.format(self.isim))
 self.oyundan_çık()

```

Bu fonksiyon içinde, herhangi bir darbe alma durumunda oyuncunundarbe,canveenerjimiktarlarında meydana gelecek değişiklikleri tanımlıyoruz.

Buna göre herhangi bir darbe alma durumunda aşağıdaki işlemler
gerçekleştirilecek:

Darbelenen oyuncunundarbedeğeri 1 birim artacak:

```python
darbelenen.darbe += 1

```

enerjideğeri 1 birim azalacak:

```python
darbelenen.enerji -= 1

```

Darbelenen oyuncu her 5 darbede 1cankaybedecek:

```python
if (darbelenen.darbe % 5) == 0:
 darbelenen.can -= 1

```

Burada her 5 darbede 1cankaybetme kriterini nasıl belirlediğimize dikkat
edin. Bildiğiniz gibi, oyuncu darbe yedikçedarbedeğişkeninin değeri artıyor.
Bu değer 5 sayısına ulaştığında,5%5işleminin sonucu 0 olacaktır. Yani bu
sayı 5’e bölündüğünde bölme işleminden kalan değer 0 olacaktır. 5’in tüm katları
için (5, 10, 15, 20 gibi…) bu durum geçerlidir. Eğerdarbedeğişkenin
ulaştığı değer 5’in katı değilse, bu sayı 5’e tam bölünmediği için, bölmeden
kalan değer 0 dışında bir sayı olur. Dolayısıyladarbedeğerinin ulaştığı
sayının 5’e bölünmesinden kalan değerin 0 olup olmadığını kontrol ederek
oyuncunun 5 darbede 1cankaybetmesini sağlayabiliyoruz.

Oyuncununcandeğeri 1’in altına düştüğünde iseenerjideğeri 0’a inecek ve
oyunu kimin kazandığı ilan edildikten sonra oyun kapatılacak:

```python
if darbelenen.can < 1:
 darbelenen.enerji = 0
 print('Oyunu {} kazandı!'.format(self.isim))
 self.oyundan_çık()

```

Buradaoyundan_çık()adlı bir örnek metoduna daha atıfta bulunduk:

```python
def oyundan_çık(self):
 print('Çıkılıyor...')
 sys.exit()

```

Gayet basit bir fonksiyon. Herhangi bir şekilde oyundan çıkmak gerektiğindesysmodülününexit()fonksiyonunu kullanarak oyunu terk ediyoruz.

İlerlemeden önce,darbele()fonksiyonunu kullandığımız kısma tekrar
bakalım:

```python
sonuç = self.saldırı_sonucunu_hesapla()

if sonuç == 0:
 print('\nSONUÇ: kazanan taraf yok')

if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 self.darbele(rakip)

if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 rakip.darbele(self)

```

Bildiğiniz gibi,darbele()fonksiyonu,selfdışında 1 adet parametre daha
alıyor. Bu parametre, darbeyi hangi oyuncunun alacağını gösteriyor. İşte bunu tespit etmek içindarbelenenadlı bir parametre belirledik. Gördüğünüz gibi,darbele()fonksiyonusaldır()adlı başka bir fonksiyonun içinden çağrılıyor.saldır()fonksiyonu darakipadlı bir parametre alıyor. İşte darbe alan
oyuncunun can ve enerji değerlerini yenilemek istediğimizde bu parametreyi,darbele()fonksiyonuna gönderiyoruz:

```python
self.darbele(rakip)

```

Burada darbelenen oyuncu karşı taraf. Yani rakibimiz bizden (self’den) darbe yemiş. Eğer
darbelenen kişi kendimizsek,rakipoyuncusunun bizi darbelemesini istiyoruz:

```python
rakip.darbele(self)

```

Pek çok kez söylediğimiz gibi,selfkelimesi mevcut sınıf örneğini temsil
eder. Dolayısıyla kendimize atıfta bulunmak istediğimiz durumlarda, yukarıda
olduğu gibiself’i kullanabiliriz.

Eğer arzu ederseniz,darbele()fonksiyonunu şöyle de yazabilirsiniz:

```python
def darbele(self):
 self.darbe += 1
 self.enerji -= 1
 if (self.darbe % 5) == 0:
 self.can -= 1
 if self.can < 1:
 self.enerji = 0
 print('Oyunu {} kazandı!'.format(self.isim))
 self.oyundan_çık()

```

Buradadarbelenenparametresini iptal ettik. Kimin durumunun yenileceğiniself’in kim olduğu belirleyecek:

```python
if sonuç == 1:
 print('\nSONUÇ: rakibinizi darbelediniz')
 rakip.darbele()

if sonuç == 2:
 print('\nSONUÇ: rakibinizden darbe aldınız')
 self.darbele()

```

Gördüğünüz gibi, eğer rakibi darbeleyip onun can ve enerji durumunu yenilemek
istiyorsak, ilgili fonksiyonurakip.darbele()şeklinde çağırıyoruz.
Kendimizin durumunu yenilemek istediğimizde iseself.darbele()komutunu
kullanıyoruz. Tabiidarbelefonksiyonunu bu şekilde tanımlayacaksak isminidarbe_alolarak belirlemek daha anlamlı olur.

Sınıfımızı tanımladığımıza göre artık bu sınıfı nasıl kullanacağımızı incelemeye
geçebiliriz:

```python
siz = Oyuncu('Ahmet')
rakip = Oyuncu('Mehmet')

```

Burada öncelikleOyuncu()sınıfı için iki farklı nesne/örnek oluşturuyoruz:

```python
siz = Oyuncu('Ahmet')
rakip = Oyuncu('Mehmet')

```

Bu iki nesne,Oyuncu()sınıfının bütün niteliklerini taşıyor. Nesneleri
oluştururken, zorunlu argüman olanisimdeğerini mutlaka belirtmemiz
gerektiğini unutmuyoruz.

Daha sonra birwhiledöngüsü içinde, oyunumuzun kullanıcı tarafından
görüntülenecek kısmını kodluyoruz:

```python
while True:
 print('Şu anda rakibinizle karşı karşıyasınız.',
 'Yapmak istediğiniz hamle: ',
 'Saldır: s',
 'Kaç: k',
 'Çık: q', sep='\n')

 hamle = input('\n> ')
 if hamle == 's':
 siz.saldır(rakip)

 print('Rakibinizin durumu')
 rakip.mevcut_durumu_görüntüle()

 print('Sizin durumunuz')
 siz.mevcut_durumu_görüntüle()

 if hamle == 'k':
 siz.kaç()

 if hamle == 'q':
 siz.oyundan_çık()

```

Oyunun nasıl oynanacağı konusunda kullanıcılarımızı bilgilendiriyoruz:

```python
print('Şu anda rakibinizle karşı karşıyasınız.',
 'Yapmak istediğiniz hamle: ',
 'Saldır: s',
 'Kaç: k',
 'Çık: q', sep='\n')

```

Kullanıcılarımızın klavyede hangi tuşa bastığını şu şekilde alıyoruz:

```python
hamle = input('\n> ')

```

Eğer kullanıcı ‘s’ tuşuna basarsa rakibimize saldırıyoruz:

```python
if hamle == 's':
 siz.saldır(rakip)

```

Saldırının ardından hem kendi durumumuzu hem de rakibimizin durumunu
görüntülüyoruz:

```python
print('Rakibinizin durumu')
rakip.mevcut_durumu_görüntüle()

print('Sizin durumunuz')
siz.mevcut_durumu_görüntüle()

```

Eğer kullanıcı ‘k’ tuşuna basarsa:

```python
if hamle == 'k':
 siz.kaç()

```

sınıf içinde tanımladığımızkaç()metodunu çalıştırıyoruz:

```python
def kaç(self):
 print('Kaçılıyor...')
 for i in range(10):
 time.sleep(.3)
 print('\n', flush=True)

 print('Rakibiniz sizi yakaladı')

```

Burada 300’er milisaniyelik aralıklarla‘\n’kaçış dizisini kullanarak bir
alt satıra geçiyoruz.

Kullanıcının ‘q’ tuşuna basması halinde ise oyundan derhal çıkıyoruz:

```python
if hamle == 'q':
 siz.oyundan_çık()

```

Bu örnek kodlar bize sınıflar ve nesneler hakkında epey bilgi verdi. Ayrıca bu
kodlar sayesinde önceki bilgilerimizi de pekiştirmiş olduk.

### Her Şey Bir Nesnedir

Belki sağda solda şu sözü duymuşsunuzdur: Python’da her şey bir nesnedir.
Gerçekten de (if,def,and,orgibi deyim ve işleçler hariç) Python’da
her şey bir nesnedir. Peki her şeyin nesne olması tam olarak ne anlama geliyor?

Hatırlarsanız nesnenin ne olduğunu tanımlarken, belli bir durumda bulunan ve
belli birtakım davranışları olan öğelere nesne adı verildiğini söylemiştik. İşte
Python’daki her şey, bu tanım doğrultusunda bir nesnedir.

Mesela, aşağıdaki komutu verdiğimiz anda bir nesne oluşturmuş oluyoruz:

```python
>>> 'istihza'

```

‘istihza’karakter dizisi,stradlı sınıfın…

```python
>>> type('istihza')

<class 'str'>

```

…bütün özelliklerini taşıyan bir nesnedir:

```python
>>> dir('istihza')

['__add__', '__class__', '__contains__', '__delattr__',
 '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
 '__getattribute__', '__getitem__', '__getnewargs__',
 '__gt__', '__hash__', '__init__', '__iter__', '__le__',
 '__len__', '__lt__', '__mod__', '__mul__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__',
 '__rmod__', '__rmul__', '__setattr__', '__sizeof__',
 '__str__', '__subclasshook__', 'capitalize', 'casefold',
 'center', 'count', 'encode', 'endswith', 'expandtabs',
 'find', 'format', 'format_map', 'index', 'isalnum',
 'isalpha', 'isdecimal', 'isdigit', 'isidentifier',
 'islower', 'isnumeric', 'isprintable', 'isspace',
 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip',
 'maketrans', 'partition', 'replace', 'rfind', 'rindex',
 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split',
 'splitlines', 'startswith', 'strip', 'swapcase',
 'title', 'translate', 'upper', 'zfill']

```

Aynı şekilde,['elma','armut']listesi de,listadlı sınıfın…

```python
>>> type(['elma', 'armut'])

<class 'list'>

```

…bütün özelliklerini taşıyan bir nesnedir:

```python
>>> dir(['elma', 'armut'])

['__add__', '__class__', '__contains__', '__delattr__',
 '__delitem__', '__dir__', '__doc__', '__eq__',
 '__format__', '__ge__', '__getattribute__', '__getitem__',
 '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
 '__iter__', '__le__', '__len__', '__lt__', '__mul__',
 '__ne__', '__new__', '__reduce__', '__reduce_ex__',
 '__repr__', '__reversed__', '__rmul__', '__setattr__',
 '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
 'append', 'clear', 'copy', 'count', 'extend', 'index',
 'insert', 'pop', 'remove', 'reverse', 'sort']

```

Hatta mesela 1 gibi alelade bir sayı bile, dış dünyayla iletişim kurmasını ve
dış dünyanın kendisiyle iletişim kurabilmesini sağlayan pek çok nitelik ve
metoda sahip bir nesnedir:

```python
>>> dir(1)

['__abs__', '__add__', '__and__', '__bool__', '__ceil__',
 '__class__', '__delattr__', '__dir__', '__divmod__',
 '__doc__', '__eq__', '__float__', '__floor__',
 '__floordiv__', '__format__', '__ge__', '__getattribute__',
 '__getnewargs__', '__gt__', '__hash__', '__index__',
 '__init__', '__int__', '__invert__', '__le__', '__lshift__',
 '__lt__', '__mod__', '__mul__', '__ne__', '__neg__',
 '__new__', '__or__', '__pos__', '__pow__', '__radd__',
 '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__',
 '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__',
 '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__',
 '__rshift__', '__rsub__', '__rtruediv__', '__rxor__',
 '__setattr__', '__sizeof__', '__str__', '__sub__',
 '__subclasshook__', '__truediv__', '__trunc__', '__xor__',
 'bit_length', 'conjugate', 'denominator', 'from_bytes',
 'imag', 'numerator', 'real', 'to_bytes']

```

İşte konuya bu noktadan baktığımızda, Python’da her şey bir nesnedir. Yani
Python’daki her şeyle, sahip oldukları metotlar ve nitelikler aracılığıyla
etkileşebilirsiniz.

Python’ın bu özelliğini bilmek, muhatap olduğunuz programlama dilini ve onun
kabiliyetlerini tanımak açısından önemlidir. Python’da her şeyin bir nesne
olduğunu anladığınız anda,{'a':0,'b':1}gibi bir kodla yalnızca basit
bir sözlük tanımlamadığınızı, bunun arkaplanında, bu sözlükle etkileşim
kurmanızı sağlayacak koca bir mekanizma bulunduğunu bilirsiniz.

### Birinci Sınıf Öğeler

Tıpkı ‘her şey bir nesnedir’ sözü gibi, yine sağda solda sıklıkla
duyabileceğiniz bir söz de Python’da nesnelerin ‘birinci sınıf öğeler’
olduğudur. Peki burada ‘birinci sınıf’ (first class) ifadesiyle kastedilen şey
tam olarak nedir?

Programlama dillerinde herhangi bir öğenin birinci sınıf bir öğe olması, o
öğenin, dil içindeki herhangi bir değer ile aynı kabiliyetlere sahip olması
anlamına gelir. ‘Bunun birinci sınıf olmakla ne alakası var?’ diye sorduğunuzu
duyar gibiyim…

Şöyle bir cümle kurduğunuzu düşünün: ‘Gelişmiş bir toplumda kadınlar birinci
sınıf vatandaşlardır.’ Bu cümleden, bir toplumun gelişmiş sayılabilmesi için
kadınların erkeklerle eşit haklara sahip olması gerektiğini anlıyoruz. Yani
kadınların birinci sınıf vatandaşlar olması, erkeklerle eşit haklara sahip
olması anlamına geliyor. İşte tıpkı bunun gibi, Python’daki sınıf yapılarının
‘birinci sınıf’ öğeler olması, bu yapıların, dil içindeki öteki değerlerle aynı
özelliklere ve kabiliyetlere sahip olması demektir. Yani Python’daki sınıflar şu
özelliklere sahiptir:
1. Başka bir fonksiyona veya sınıfa parametre olarak verilebilirler
1. Bir fonksiyondan döndürülebilirler
1. Bir değişkene atanabilirler

Başka bir fonksiyona veya sınıfa parametre olarak verilebilirler

Bir fonksiyondan döndürülebilirler

Bir değişkene atanabilirler

Yani, bir öğenin ‘birinci sınıf’ olması demek, dil içindeki başka öğelerle
yapabildiğiniz her şeyi o öğeyle de yapabilmeniz demektir.

Durumu biraz daha netleştirebilmek için, konu hakkında Guido Van Rossum’un ne
dediğine bir bakalım:

Python’a ilişkin hedeflerimden bir tanesi de, bu dili, bütün nesneler
“birinci sınıf” olacak şekilde tasarlamaktı. Bununla kastettiğim, dil içinde
kendisine bir isim verilebilen bütün nesnelerin (örn. tam sayılar, karakter
dizileri, fonksiyonlar, sınıflar, modüller, metotlar, vb.) eşit statüye
sahip olmasıdır. Yani, bütün nesnelerin değişkenlere atanabilmesi,
listelerin içine yerleştirilebilmesi, sözlükler içinde depolanabilmesi,
argüman olarak atanabilmesi vesaire…

kaynak:http://python-history.blogspot.com.tr/2009/02/first-class-everything.html

Gelin bütün bu tanımları somutlaştıran birkaç örnek verelim.

MeselaDeneme()adlı basit bir sınıf tanımlayalım:

```python
class Deneme():
 def __init__(self):
 self.değer = 0
 def metot(self):
 self.metot_değeri = 1

```

Yukarıdaki tanımlara göre, bu sınıfın birinci sınıf bir nesne olabilmesi için
başka bir fonksiyona veya sınıfa parametre olarak atanabilmesi gerekiyor.
Bakalım acaba gerçekten öyle mi?

```python
print(Deneme())

```

Gördüğünüz gibi, gerçekten de sınıfımızıprint()fonksiyonuna parametre
olarak atayabildik.

Yine yukarıdaki tanıma göre birinci sınıf nesnelerin bir fonksiyondan
döndürülebilmesi gerekiyor:

```python
def fonksiyon():
 return Deneme()

print(fonksiyon())

```

Bu testi de başarıyla geçtik.

Son olarak, bir nesnenin birinci sınıf olabilmesi için bir değişkene
atanabilmesi gerekiyor:

```python
değişken = Deneme()

```

Gördüğünüz gibi, Python için bu da oldukça basit bir görev.

İlk bakışta bu özellikten pek etkilenmemiş olabilirsiniz… Şöyle bir düşününce,
aslında çok da önemli bir özellik değilmiş gibi gelebilir bu size. Ancak başka
programlama dillerinin;
- Öğelerin kullanımına ilişkin çeşitli kısıtlamalar koyduğunu,
- Yani öğeler arasında ayrım yaptığını,
- Değişkenlerle fonksiyonların ve fonksiyonlarla sınıfların aynı haklara
sahip olmadığını,
- Mesela bir değişkeni veya herhangi bir değeri kullanabildiğiniz her yerde
fonksiyon veya sınıf kullanamadığınızı,
- Yani fonksiyonların ve/veya sınıfların birinci sınıf öğeler olmadığını

Öğelerin kullanımına ilişkin çeşitli kısıtlamalar koyduğunu,

Yani öğeler arasında ayrım yaptığını,

Değişkenlerle fonksiyonların ve fonksiyonlarla sınıfların aynı haklara
sahip olmadığını,

Mesela bir değişkeni veya herhangi bir değeri kullanabildiğiniz her yerde
fonksiyon veya sınıf kullanamadığınızı,

Yani fonksiyonların ve/veya sınıfların birinci sınıf öğeler olmadığını

gördüğünüzde Python’daki bu esneklik daha bir anlam kazanacaktır.

## Nesne Tabanlı Programlama (Devamı)

Geçen bölümlerde, nesne tabanlı programlamaya ilişkin hem temel, hem orta, hem
de ileri düzey sayılabilecek pek çok konuya değindik. Şimdiye kadar
öğrendiklerimiz, nesne tabanlı programlama yaklaşımı çerçevesinde yazılım
üretirken yönümüzü bulabilmemiz açısından büyük ölçüde yeterlidir. Ancak daha
önce de söylediğimiz gibi, nesne tabanlı programlama çok geniş kapsamlı bir
konudur ve içinde şimdiye kadar adını bile anmadığımız daha pek çok kavram
barındırır. İşte bu bölümde, geçen derslerimizde incelemeye fırsat
bulamadığımız, ancak nesne tabanlı programlamayı daha derinlemesine tanımak
bakımından bilmemizin iyi olacağı birtakım ileri düzey kavramlardan söz
edeceğiz.

Bu bölümde inceleyeceğimiz ilk konu ‘sınıf üyeleri’.

### Sınıf Üyeleri

Python’da bir sınıf içinde bulunan nitelikler, değişkenler, metotlar,
fonksiyonlar ve buna benzer başka veri tipleri, o sınıfın üyelerini meydana
getirir. Bir sınıfın üyelerini genel olarak üçe ayırarak inceleyebiliriz:
- Aleni üyeler (public members)
- Gizli üyeler (private members)
- Yarı-gizli üyeler (semi-private members).

Aleni üyeler (public members)

Gizli üyeler (private members)

Yarı-gizli üyeler (semi-private members).

Bu bölümde bu üç üye türünü ve bunların birbirinden farkını ele alacağız.
Öncelikle aleni üyelerden başlayalım.

#### Aleni Üyeler

Eğer bir sınıf üyesi dışarıya açıksa, yani bu üyeye sınıf dışındannormal
yöntemlerleerişilebiliyorsa bu tür üyelere ‘aleni üyeler’ adı verilir.
Programlama maceranız boyunca karşınıza çıkacak veri üyelerinin tamamına yakını
alenidir. Biz de bu kitapta şimdiye kadar yalnızca aleni üyeleri gördük.

Eğer bildiğiniz tek programlama dili Python ise, şu anda tam olarak neden
bahsediyor olduğumuza anlam verememiş olabilirsiniz. Dilerseniz durumu
zihninizde biraz olsun netleştirebilmek için basit bir örnek verelim.

Diyelim ki elimizde şöyle bir sınıf var:

```python
class Sınıf():
 sınıf_niteliği = 'sınıf niteliği'

 def örnek_metodu(self):
 print('örnek metodu')

 @classmethod
 def sınıf_metodu(cls):
 print('sınıf metodu')

 @staticmethod
 def statik_metot():
 print('statik metot')

```

Bu kodlarınsinif.pyadlı bir dosya içinde yer aldığını varsayarsak şöyle bir
şeyler yazabiliriz:

```python
>>> import sinif
>>> s = sinif.Sınıf()
>>> dir(s)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__module__',
 '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',
 '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
 'statik_metot', 'sınıf_metodu', 'sınıf_niteliği', 'örnek_metodu']

```

Burada öncelikle kodlarımızı barındıran modülü içe aktardık. Daha sonra, içe
aktardığımız modülün içindekiSınıf()adlı sınıfımızısörneğine atadık ve
ardındandir()komutunu kullanarak, içe aktardığımız bu sınıfın içeriğini
sorguladık.

Gördüğünüz gibi, içe aktardığımız sınıfın bütün öğeleri listede var. Yani biz bu
sınıf içindeki bütün öğelere normal yollardan erişme imkanına sahibiz:

```python
>>> s.statik_metot()

'statik metot'

>>> s.örnek_metodu()

'örnek metodu'

>>> s.sınıf_metodu()

'sınıf metodu'

>>> s.sınıf_niteliği

'sınıf niteliği'

```

İştedir()komutunun çıktısında görünen ve normal yollardan erişebildiğimiz
bütün bu öğeler birer aleni üyedir.

Yukarıda da ifade ettiğimiz gibi, program yazarken çoğu zaman yalnızca aleni
üyelerle muhatap olacaksınız. Ancak bazı durumlarda, yazdığınız bir sınıftaki
bütün sınıf üyelerinin dışarıya açık olmasını istemeyebilirsiniz. Eğer
kodlarınızda, sınıfın yalnızca iç işleyişini ilgilendiren, bu yüzden de
dışarıdan erişilmesine gerek olmadığını veya erişilirse problem çıkacağını
düşündüğünüz birtakım öğeler varsa bunları dışarıya kapatarak bir ‘gizli üye’
haline getirmek isteyebilirsiniz. Peki ama nasıl?

#### Gizli Üyeler

Python’da şimdiye kadar gördüğümüz ve yukarıda andığımız aleni üyelerin dışında,
bir de gizli üyeler bulunur. Aleni üyelerin aksine gizli üyeler dışarıya açık
değildir. Gizli üyelere, normal yöntemleri kullanarak sınıf dışından erişemeyiz.

Konuyu açıklığa kavuşturmak için, aleni üyeleri anlatırken verdiğimiz sınıf
örneğinde şu değişikliği yapalım:

```python
class Sınıf():
 __gizli = 'gizli'

 def örnek_metodu(self):
 print(self.__gizli)
 print('örnek metodu')

 @classmethod
 def sınıf_metodu(cls):
 print('sınıf metodu')

 @staticmethod
 def statik_metot():
 print('statik metot')

```

Burada__gizliadlı bir gizli sınıf niteliği tanımladık. Bu değişkenin
yalnızca baş tarafında iki adet alt çizgi olduğuna, ancak uç tarafında alt
çizgi bulunmadığına dikkat edin. İşte Python’da baş tarafında yukarıdaki gibi
iki adet alt çizgi olan, ancak uç tarafında alt çizgi bulunmayan (veya yalnızca
tek bir alt çizgi bulunan) bütün öğeler birer gizli üyedir. Dışarıya kapalı olan
bu gizli üyelere, normal yöntemleri kullanarak sınıf dışından erişemezsiniz.

İsterseniz deneyelim:

```python
>>> import sinif
>>> s = sinif.Sınıf()
>>> s.__gizli

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'Sınıf' object has no attribute '__gizli'

```

Gördüğünüz gibi, örnek adı üzerinden__gizliniteliğine erişemiyoruz. Bir de
sınıf adı üzerinden erişmeyi deneyelim:

```python
>>> sinif.Sınıf.__gizli

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: type object 'Sınıf' has no attribute '__gizli'

```

Bu şekilde de erişemedik. Çünkü dediğimiz gibi, başında çift alt çizgi olan,
ancak ucunda herhangi bir çizgi bulunmayan (veya tek bir alt çizgi bulunan) bu
gizli öğelerenormal yollardanerişemeyiz.

Dilerseniz gizli üye oluşturma kurallarını şöyle bir netleştirelim:

Bir üyenin gizli olabilmesi için başındaen aziki adet, ucunda daen
fazlabir adet alt çizgi bulunmalıdır. Yani şunlar birer gizli üyedir:

```python
>>> __gizli = 'gizli'
>>> __gizli_ = 'gizli'
>>> __gizli_üye = 'gizli'
>>> __gizli_üye_ = 'gizli'

```

Burada önemli bir noktaya dikkatinizi çekmek istiyorum: Gizli üyeler yalnızcasınıf dışınakapalıdır. Bu üyeleresınıf içindenrahatlıkla
erişebiliriz. Mesela yukarıdaki örnekte bu durumu görüyorsunuz.__gizliadlı
değişkeneörnek_metodu()içinden normal bir şekilde erişebiliyoruz:

```python
def örnek_metodu(self):
 print(self.__gizli)
 print('örnek metodu')

```

Bu durumda sınıf dışından buörnek_metodu()’na eriştiğimizde gizli üye olan__gizli’ye de erişmiş oluyoruz:

```python
>>> import sinif
>>> s = sinif.Sınıf()
>>> s.örnek_metodu()

'gizli'
'örnek metodu'

```

Buradaörnek_metodu(),__gizliadlı gizli üyeye erişmemiz için bize
aracılık etmiş oluyor.

Peki ama bir insan neden bu şekilde birtakım gizli üyeler tanımlamak istiyor
olabilir?

Hatırlarsanız geçen bölümde şöyle bir örnek vermiştik:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 @classmethod
 def personel_sayısını_görüntüle(cls):
 print(len(cls.personel))

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Buradapersoneladlı bir sınıf niteliğimiz var. Bu niteliğe sınıf içinde hempersonele_ekle()adlı örnek metodundan hem depersonel_sayısını_görüntüle()vepersoneli_görüntüle()adlı sınıf
metotlarından erişmek suretiyle bu nitelik üzerinde çeşitli işlemler yapıyoruz.

Esasında şöyle bir düşününce,personeladlı niteliğin yalnızca sınıfın iç
işleyişi açısından önem taşıdığını rahatlıkla söyleyebiliriz. Bu niteliğe sınıf
dışından doğrudan erişilerek personel üzerinde işlem yapılmaya çalışılması çok
mantıksız. Yani sınıfımızı kullanacak kişilerin şu tür bir kod yazması biraz
abes kaçacaktır:

```python
>>> from calisan import Çalışan
>>> Çalışan.personel.append('Ahmet')

```

Zira biz, kodlarımızın yapısı gereği, personel üzerindeki işlemlerin yalnızca
çeşitli fonksiyonlar/metotlar aracılığıyla yapılmasını istiyoruz.

Personele eleman ekleyecek kişilerin doğrudanpersonellistesine erişmesi,
kodlarımızın kullanım kurallarının bir bakıma ihlal edilmesi anlamına geliyor.
Çünkü biz personele eleman ekleme işlemleri için halihazırda ayrı bir metot
tanımlamış durumdayız. Eğer personele adam eklenecekse, bu işlem doğrudanpersonellistesi üzerinden değil,personele_ekle()adlı örnek metodu
üzerinden gerçekleştirilmeli. Yukarıdaki kodlarda bupersonele_ekle()metodu
doğrudan sınıfın kendi__init__()metodu tarafından kullanılıyor.
Dolayısıyla yukarıdaki sınıfı kullanmanın doğru yolu, ilgili sınıfı
örneklemektir:

```python
>>> from calisan import Çalışan
>>> ahmet = Çalışan('Ahmet')

```

Aynı şekilde personel listesini görüntülemek için de doğrudanpersonellistesine erişmeye çalışmayacağız. Yani şöyle bir şey yazmayacağız:

```python
>>> Çalışan.personel

```

Bunun yerine, bu iş için özel olarak tasarladığımızpersoneli_görüntüle()fonksiyonunu kullanacağız:

```python
>>> Çalışan.personeli_görüntüle()

```

İşte yukarıdaki kodlarda yer alanpersonellistesinin usulsüz bir şekilde
kullanılmasını önlemek amacıyla bu listeyi bir gizli üye haline
getirebilirsiniz:

```python
class Çalışan():
 __personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.personele_ekle()

 @classmethod
 def personel_sayısını_görüntüle(cls):
 print(len(cls.__personel))

 def personele_ekle(self):
 self.__personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 def personeli_görüntüle(self):
 print('Personel listesi:')
 for kişi in self.__personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Buradapersonellistesinin baş tarafına iki alt çizgi ekleyerek bunu sınıf
dışından, normal yollarla erişilmez hale getirdik:

```python
>>> Çalışan.__personel

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: type object 'Çalışan' has no attribute '__personel'

```

Gördüğünüz gibi, aslında sınıfımız içinde__personeladlı bir nitelik olmasına
rağmen, Python bu niteliğe sınıf dışından erişilmesine izin vermiyor. Eğer
amacımız personel üzerinde çeşitli işlemler yapmaksa, bu iş için sınıfın bize
sunduğu metotları kullanmamız gerekiyor:

```python
>>> Çalışan.personel_sayısını_görüntüle()

```

Bu tip durumlarda gizli üyeler epey işinize yarayabilir…

Bir örnek daha verelim.

Yukarıdaki kodlarda, tıpkıpersonellistesi gibi, aslındapersonele_ekle()fonksiyonu da dışarıdan erişilmesine gerek olmayan, hatta dışarıdan erişilirse
kafa karıştırıcı olabilecek bir sınıf üyesidir.

personele_ekle()adlı örnek metodu, sınıfımız içinde__init__()fonksiyonu tarafından kullanılıyor. Dolayısıyla sınıfımız örneklendiğindepersonele_ekle()metodu devreye girerek yeni elemanı personel listesine
ekliyor:

```python
>>> ayşe = Çalışan('Ayşe')

'Ayşe adlı kişi personele eklendi'

```

Öte yandan, bu fonksiyon aleni bir üye olduğu için, buna dışarıdan erişmemizin
önünde herhangi bir engel yok:

```python
>>> ayşe.personele_ekle()

'Ayşe adlı kişi personele eklendi'

```

Bu fonksiyon sınıf dışından çağrıldığında, kendisini çağıran örnek adını
personel listesine tekrar ekleyecektir:

```python
>>> Çalışan.personeli_görüntüle()

Ayşe
Ayşe

```

Yani yukarıdaki komut Ayşe adlı kişiyi personel listesine tekrar ekler.
Dolayısıyla bu fonksiyona sınıf dışından erişilmesi son derece mantıksız, son
derece yanlış ve hatta son derece kafa karıştırıcıdır. O yüzden, herhangi bir
sıkıntı yaşanmasını engellemek amacıyla bu fonksiyonu da bir gizli üye olarak
tanımlayabiliriz:

```python
class Çalışan():
 __personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.__personele_ekle()

 @classmethod
 def personel_sayısını_görüntüle(cls):
 print(len(cls.__personel))

 def __personele_ekle(self):
 self.__personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.__personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Bu şekildepersonele_ekle()fonksiyonunu da dışarıya kapatmış olduk. Artık
bu fonksiyon da, olması gerektiği gibi, yalnızca sınıf içinde kullanılabilecek.

Yukarıdaki örnekler, bazı durumlarda veri gizlemenin epey işimize
yarayabileceğini bariz bir biçimde gösteriyor. Ama elbette, yukarıdaki
işlemlerin hiçbiri zorunlu değildir. Yani siz, yazdığınız kodlarda hiçbir sınıf
üyesini gizlemek mecburiyetinde değilsiniz. Yukarıda gösterdiğimiz kullanımlar
tamamen tercih meselesidir. Zaten birkaç nadir durum dışında, Python’da
verilerinizi gizlemek zorunda da kalmazsınız. Ama tabii kendiniz Python’ın bu
özelliğinden yararlanmasanız da, sırf bu özellikten yararlanan başka
programcıların yazdığı kodları anlayabilmek için bile olsa bu özellikten
haberdar olmalısınız.

#### İsim Bulandırma

Gelin isterseniz gizli üyelere ilişkin ilginç bir özellikten söz edelim.

Python’da ‘gizli’ olarak adlandırdığımız öğeler aslında o kadar da gizli
değildir… Çünkü Python’da gerçek anlamda gizli ve dışarıya tamamen kapalı
üyeler bulunmaz. Peki bu ne anlama geliyor?

Bu şu anlama geliyor: Her ne kadar yukarıdaki örneklerde üyeleri dışarıya
kapatmak için kullandığımız alt çizgi işaretleri ilgili değişkeni gizlese de,
bunu tamamen erişilmez hale getirmez. Dediğimiz gibi, Python’da gerçek anlamda
dışa kapalı sınıf üyeleri bulunmadığı için biz bu üyelerebir şekildeerişme
imkanına sahibiz. Peki ama nasıl?

Python, kodlar içinde gizli bir üye ile karşılaştığında özel bir ‘isim
bulandırma’ (name mangling) işlemi gerçekleştirir ve ilgili gizli üyenin
görünüşünü değiştirir. Eğer Python’ın arkaplanda neler çevirdiğini bilirseniz,
gizli üyeye de erişebilirsiniz.

Örnek sınıfımız şöyleydi:

```python
class Sınıf():
 __gizli = 'gizli'

 def örnek_metodu(self):
 print(self.__gizli)
 print('örnek metodu')

 @classmethod
 def sınıf_metodu(cls):
 print('sınıf metodu')

 @staticmethod
 def statik_metot():
 print('statik metot')

```

Şimdi, bu sınıf içindeki gizli üyeye erişeceğiz.

Dikkatlice bakın:

```python
>>> import sinif
>>> s = sinif.Sınıf()
>>> s._Sınıf__gizli

'gizli'

```

Ne kadar da tuhaf, değil mi?

İşte Python, siz bir sınıf üyesini__gizlişeklinde tanımladığınızda, bu
öğe üzerinde şu işlemleri gerçekleştirir:

Öncelikle değişkenin baş tarafına bir alt çizgi ekler:

```python
_

```

Daha sonra, bu alt çizginin sağ tarafına bu gizli üyeyi barındıran sınıfın adını
iliştirir:

```python
_Sınıf

```

Son olarak da gizli üyeyi sınıf adının sağ tarafına yapıştırır:

```python
_Sınıf__gizli

```

Dolayısıyla_Sınıf__gizlikodunu kullanarak,__gizliadlı üyeye sınıf
dışından erişebilirsiniz.

Pratik olması bakımından bir örnek daha verelim. Mesela şu örneği ele alalım:

```python
class Çalışan():
 __personel = []

 def __init__(self, isim):
 self.isim = isim
 self.kabiliyetleri = []
 self.__personele_ekle()

 @classmethod
 def personel_sayısını_görüntüle(cls):
 print(len(cls.__personel))

 def __personele_ekle(self):
 self.__personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.__personel:
 print(kişi)

 def kabiliyet_ekle(self, kabiliyet):
 self.kabiliyetleri.append(kabiliyet)

 def kabiliyetleri_görüntüle(self):
 print('{} adlı kişinin kabiliyetleri:'.format(self.isim))
 for kabiliyet in self.kabiliyetleri:
 print(kabiliyet)

```

Burada__personele_ekle()adlı fonksiyon bir gizli üyedir. Dolayısıyla buna
dışarıdan normal yöntemlerle erişemeyiz.

Bunu test etmek için önce gerekli verileri oluşturalım:

```python
>>> from calisan import Çalışan
>>> ahmet = Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi.

```

Şimdiahmetörneği üzerinden bu gizli üyeye erişmeye çalışalım:

```python
>>> ahmet.__personele_ekle()

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'Çalışan' object has no attribute '__personele_ekle'

```

Gördüğünüz gibi, Python bu üyeye normal yollardan erişmemize izin vermiyor. Ama
biz biliyoruz ki, Python bu üyeyi gizlerken özel bir isim bulandırma işlemi
gerçekleştiriyor. Bu bulandırma işleminin nasıl gerçekleştirildiğini bildiğimize
göre gizli üyeye erişebiliriz.

Öncelikle örneğimizin adını yazalım. Zira gizli üyeye bu ad üzerinden
erişeceğiz:

```python
>>> ahmet.

```

Şimdi bulandırma işlemini uygulamaya geçebiliriz.

Öncelikle bir alt çizgi ekleyelim:

```python
>>> ahmet._

```

Daha sonra sınıf adını iliştirelim:

```python
>>> ahmet._Çalışan

```

Son olarak da gizli üyenin kendisini yazalım:

```python
>>> ahmet._Çalışan__personele_ekle()

Ahmet adlı kişi personele eklendi.

```

Gayet başarılı…

Yalnız buraya şöyle bir not düşelim: Her ne kadar Python bize gizli üyelere
erişme imkanı sunsa da, başkasının yazdığı kodları kullanırken, o kodlardaki
gizli üyelere erişmeye çalışmamak çoğu zaman iyi bir fikirdir. Nihayetinde eğer
bir programcı, bir sınıf üyesini gizlemişse bunun bir nedeni vardır. Eğer
erişmenizin istenmediği bir üyeye erişirseniz ve bunun sonucunda birtakım
sorunlarla karşılaşırsanız bu durum o programı yazan programcının değil, tamamen
sizin kabahatinizdir. Python programcılarının da sık sık söylediği gibi:
‘Neticede hepimiz, doğruyu yanlışı bilen, yetişkin insanlarız.’

#### Yarı-gizli Üyeler

Buraya kadar Python’a dair anlattığımız şeylerden, yerleşmiş adetlerin ve
geleneklerin Python açısından ne kadar önemli olduğunu anlamış olmalısınız. Daha
önce verdiğimiz örnekler, bu dildeki pek çok meselenin uzlaşma esası üzerinden
çözüme kavuşturulduğunu bize açık ve seçik olarak gösterdi. Mesela geçen
bölümlerde ele aldığımızselfveclskelimeleri tamamen uzlaşmaya dayalı
kavramlardır. Python topluluğu içinde,selfkelimesinin örnek metotları için,clskelimesinin ise sınıf metotları için kullanılması tamamen bir alışkanlık,
adet, gelenek ve uzlaşı meselesidir. Python’ın kendisi bize bu kelimeleri
dayatmaz. Ancak topluluk içinde süregelen kuvvetli gelenekler bizi başka
kelimeleri değil de yukarıdaki kelimeleri kullanmaya teşvik eder. Aynı şekilde
kod yazarken girinti sayısının dört boşluk olarak belirlenmiş olması da bir
gelenekten ibarettir. Yazdığınız kodlarda, aynı program içinde hep aynı sayıda
olmak şartıyla, istediğiniz sayıda boşluktan oluşan girintiler
kullanabilirsiniz. Ama Python’ın topluluk içi gelenekleri bizi dört boşlukluk
bir girintileme sistemi kullanmaya yöneltir.

İşte tıpkı yukarıdakiler gibi, Python’daki sınıf üyelerinin dışa açık veya dışa
kapalı olup olmaması da hep belli birtakım gelenekler üzerinden belirlenen bir
durumdur.

Bunun bir örneğini, yukarıda gizli üyeleri anlatırken vermiştik. Bir sınıf
içindeki herhangi bir niteliğin başında çift alt çizgi gördüğümüzde, o sınıfı
yazan kişinin, bu niteliğe sınıf dışından erişilmesini istemediğini anlıyoruz.
Python her ne kadar nitelikleri gizlememiz için bize özel bir mekanizma sunmuş
olsa da bu niteliğe erişmemizi tamamen engellemiyor, ancak ilgili sınıfı yazan
kişinin niyetine saygı göstereceğimizi varsayıyor.

Python’da sınıf üyelerinin gizliliği, yukarıda da gördüğümüz gibi, hem özel bir
mekanizma ile hem de topluluk içi gelenekler tarafından korunur.

Python’da bir de yalnızca topluluk içi gelenekler tarafından korunan
‘yarı-gizli’ üyeler (semi-private members) vardır. İşte bu bölümde, bir gizli
üye türü olan yarı-gizli üyelerden söz edeceğiz.

Yarı-gizli üyeler, herhangi bir özel mekanizma aracılığıyla değil de yalnızca
topluluk içi gelenekler tarafından korunan niteliklerdir. Herhangi bir üyeyi
yarı-gizli olarak işaretlemek için yapmamız gereken tek şey başına bir adet alt
çizgi yerleştirmektir. Örneğin:

```python
class Falanca():
 _yarıgizli = 'yarıgizli'

```

Buradaki_yarıgizliadlı niteliğe sınıf içinden veya dışından erişmemizi
engelleyen veya zorlaştıran hiçbir mekanizma bulunmaz. Ama biz bir sınıf içinde
tek alt çizgi ile başlayan bir öğe gördüğümüzde, bunun sınıfın iç işleyişine
ilişkin bir ayrıntı olduğunu, sınıf dışından bu öğeyi değiştirmeye kalkışmamamız
gerektiğini anlarız.

### @property Bezeyicisi

Yukarıda aleni, gizli ve yarı-gizli sınıf üyelerinden söz ettik. İsterseniz
özellikle yarı-gizli öğelerin kullanıldığı bir kod örneği vererek yukarıda
anlattıklarımızı somut bir örnek üzerinden netleştirmeye çalışalım.

Diyelim ki şöyle bir kod yazdık:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.personel:
 print(kişi)

```

Burada personel veritabanına kişi eklememizi ve veritabanındaki kişileri
görüntülememizi sağlayan birtakım metotlar var.

Bu metotları şöyle kullanıyoruz:

```python
>>> from calisan import Çalışan
>>> ç1 = Çalışan('Ahmet')

Ahmet adlı kişi personele eklendi

>>> ç2 = Çalışan('Mehmet')

Mehmet adlı kişi personele eklendi

>>> Çalışan.personeli_görüntüle()

Personel listesi:
Ahmet
Mehmet

```

Peki eğer kodlarımızı kullananlar personel listesindeki bir kişinin ismini
sonradan değiştirmek isterse ne yapacak?

Kodlarımız içinde, isim değişikliği yapılmasını sağlayan özel bir metot yok.
Dolayısıyla kodlarımızı kullananlar, doğrudanisimadlı örnek değişkenine
erişerek isim değişikliğini şu şekilde yapabilir:

```python
>>> ç1.isim = 'Selim'

```

Bu şekilde ‘Ahmet’ adlı kişinin ismini değiştirdik. Bunu teyit edelim:

```python
>>> print(ç1.isim)

Selim

```

Ancak burada şöyle bir sorun var. Bu isim değişikliği personel listesine
yansımadı. Kontrol edelim:

```python
>>> Çalışan.personeli_görüntüle()

Personel listesi:
Ahmet
Mehmet

```

Gördüğünüz gibi, ‘Ahmet’ ismi hâlâ orada duruyor. Bu sorunu gidermek için,
personel listesine de müdahale edilmesi gerekir:

```python
>>> kişi = Çalışan.personel.index('Ahmet')
>>> Çalışan.personel[kişi] = 'Selim'

```

Burada öncelikle listelerinindex()metodunu kullanarak, değiştirmek
istediğimiz kişininpersonellistesindeki sırasını bulduk. Daha sonra da bu
bilgiyi kullanarak listede gerekli değişikliği yaptık.

Personel listesini tekrar kontrol ettiğimizde her şeyin yolunda olduğunu
görebiliriz:

```python
>>> Çalışan.personeli_görüntüle()

Personel listesi:
Selim
Mehmet

```

Ancak bunun hiç kullanışlı bir yöntem olmadığı çok açık. Basit bir isim
değişikliği için, kullanıcılarımız bir sürü kod yazmak zorunda kalıyor.
Kullanıcılarımızın hayatını kolaylaştırmak için onlara pratik bir metot
sunabiliriz:

```python
class Çalışan():
 personel = []

 def __init__(self, isim):
 self.isim = isim
 self.personele_ekle()

 def personele_ekle(self):
 self.personel.append(self.isim)
 print('{} adlı kişi personele eklendi'.format(self.isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.personel:
 print(kişi)

 def isim_değiştir(self, yeni_isim):
 kişi = self.personel.index(self.isim)
 self.personel[kişi] = yeni_isim
 print('yeni isim:', yeni_isim)

```

Buradaisim_değiştir()adlı yeni bir fonksiyon tanımladık. Artık
kodlarımızdan istifade edenler yalnızca bu yeni fonksiyonu kullanarak, personele
önceden ekledikleri kişilerin ismini kolayca değiştirebilir:

```python
>>> from calisan import Çalışan
>>> ç1 = Çalışan('Ahmet')
>>> ç2 = Çalışan('Mehmet')
>>> ç3 = Çalışan('Selim')
>>> Çalışan.personeli_görüntüle()

Personel listesi:
Ahmet
Mehmet
Selim

>>> ç1.isim_değiştir('Emre')

yeni isim: Emre

>>> Çalışan.personeli_görüntüle()

Personel listesi:

Emre
Mehmet
Selim

```

Gördüğünüz gibi, kodlarımız gayet güzel çalışıyor. Bu noktadan sonra,eğer
arzu ederseniz, kullanıcılarınızınpersonelveself.isimadlı değişkenlere
doğrudan erişmesini engellemek için bunları tek alt çizgi veya çift alt çizgi
kullanarak gizleyebilirsiniz.

Çift alt çizgi ile:

```python
class Çalışan():
 __personel = []

 def __init__(self, isim):
 self.__isim = isim
 self.personele_ekle()

 def personele_ekle(self):
 self.__personel.append(self.__isim)
 print('{} adlı kişi personele eklendi'.format(self.__isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls.__personel:
 print(kişi)

 def isim_değiştir(self, yeni_isim):
 kişi = self.__personel.index(self.__isim)
 self.__personel[kişi] = yeni_isim
 print('yeni isim: ', yeni_isim)

```

Tek alt çizgi ile:

```python
class Çalışan():
 _personel = []

 def __init__(self, isim):
 self._isim = isim
 self.personele_ekle()

 def personele_ekle(self):
 self._personel.append(self._isim)
 print('{} adlı kişi personele eklendi'.format(self._isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls._personel:
 print(kişi)

 def isim_değiştir(self, yeni_isim):
 kişi = self._personel.index(self._isim)
 self._personel[kişi] = yeni_isim
 print('yeni isim: ', yeni_isim)

```

personelveself.isimadlı nitelikleri çift alt çizgi ile gizlediğimizde
Python’ın isim bulandırma mekanizmasını işleteceğini, tek alt çizgi ile
gizlediğimizde ise bu mekanizmanın işletilmeyeceğini biliyorsunuz.

Peki size şöyle bir soru sorayım:

Acaba, personel listesindeki bir ismi, mesela yalnızca şöyle bir komut vererek
değiştiremez miyiz?

```python
>>> ç1.isim = 'Emre'

```

Elbette değiştirebiliriz. Ancak bunun için özel bir araçtan yararlanmamız
gerekir. Bu iş için@propertyadlı özel bir bezeyiciyi kullanacağız.

Dikkatlice bakın:

```python
class Çalışan():
 _personel = []

 def __init__(self, isim):
 self._isim = isim
 self.personele_ekle()

 def personele_ekle(self):
 self._personel.append(self._isim)
 print('{} adlı kişi personele eklendi'.format(self._isim))

 @classmethod
 def personeli_görüntüle(cls):
 print('Personel listesi:')
 for kişi in cls._personel:
 print(kişi)

 @property
 def isim(self):
 return self._isim

 @isim.setter
 def isim(self, yeni_isim):
 kişi = self._personel.index(self.isim)
 self._personel[kişi] = yeni_isim
 print('yeni isim: ', yeni_isim)

```

Bu kodları çalıştırdığınızda, tıpkı yukarıda bahsettiğimiz gibi, herhangi bir
çalışanın ismini yalnızca şu şekilde değiştirebildiğinizi göreceksiniz:

```python
>>> ç1.isim = 'Emre'

```

Üstelik bu kod, isim değişikliğinin personel listesine de yansımasını sağlıyor:

```python
>>> Çalışan.personeli_görüntüle()

Emre

```

Birazdan bu kodları derinlemesine inceleyeceğiz. Ama isterseniz öncelikle şu@propertybezeyicisinden biraz söz edelim. Böylelikle yukarıdaki kodları
anlamamız kolaylaşır.

#### Metottan Niteliğe

Şimdiye kadar verdiğimiz örneklerden anlamış olabileceğiniz gibi, bir sınıf
içinde salt verileri tutan değişkenlere ‘nitelik’ adı veriyoruz. Mesela:

```python
class Falanca():
 nitelik = 'nitelik'

 def __init__(self):
 self.nitelik = 'nitelik'

```

Buradanitelikbir sınıf niteliği,self.nitelikise bir örnek niteliğidir.

Buna karşılık, bir sınıf içinde fonksiyon biçiminde yer alan ve bir işlemi veya
prosedürü yerine getiren öğelere ise metot adı veriyoruz. Mesela:

```python
class Falanca():
 def __init__(self):
 pass

 def örnek_fonk(self):
 pass

 @classmethod
 def sınıf_fonk(cls):
 pass

 @staticmethod
 def statik_fonk():
 pass

```

Buradaörnek_fonk()adlı fonksiyon bir örnek metodu,sınıf_fonk()adlı
fonksiyon bir sınıf metodu,statik_fonk()adlı fonksiyon ise bir statik
metottur. Metotlar ile niteliklerin gerçekleştirebilecekleri işlemlerin
karmaşıklığının birbirinden farklı olmasının yanı sıra, bunlar arasında kullanım
açısından da farklılık vardır. MeselaFalanca()sınıfı içindekinitelikadlı sınıf niteliğini şu şekilde kullanıyoruz:

```python
>>> Falanca.nitelik
>>> Falanca.nitelik = 'yeni değer'

```

Aynı sınıf içindekisınıf_fonk()adlı sınıf metoduna ise şöyle erişiyoruz:

```python
>>> Falanca.sınıf_fonk()

```

Niteliklerin aksine, metotlarda atama yoluyla değer değiştirme gibi bir şey söz
konusu değildir. Yani şuna benzer bir şey yazamayız:

```python
>>> Falanca.sınıf_fonk() = 'yeni değer'

```

Eğer metot bir parametre alıyorsa (yukarıdaki örneklerde metotlar parametre
almıyor), bu parametreyi kullanarak metotla iletişim kurabiliriz. Mesela:

```python
>>> Falanca.sınıf_fonk(yeni_değer)

```

Propertykelimesi (attributekelimesine benzer bir şekilde) İngilizcede
‘özellik, nitelik’ gibi anlamlara gelir. Kelime anlamına uygun olarak,@propertybezeyicisinin yaptığı en temel iş, bir metodu, nitelik gibi
kullanılabilecek hale getirmektir. Çok basit bir örnek verelim:

```python
class Program():
 def __init__(self):
 pass

 def versiyon(self):
 return '0.1'

```

Buradaversiyon()adlı bir örnek metodu tanımladık. Bu programı şöyle
kullanıyoruz:

```python
>>> program = Program()
>>> program.versiyon()

'0.1'

```

Şimdi programımızda şu değişikliği yapalım:

```python
class Program():
 def __init__(self):
 pass

 @property
 def versiyon(self):
 return '0.1'

```

Buradaversiyon()adlı metodu@propertybezeyicisi ile ‘bezedik’. Böylece
bu metodu bir ‘nitelik’ haline getirmiş olduk. Artık bunu şöyle kullanabiliriz:

```python
>>> program = Program()
>>> program.versiyon

'0.1'

```

versiyon()fonksiyonunu,@propertybezeyicisi yardımıyla bir niteliğe
dönüştürdüğümüz için, artık bu fonksiyonu parantezsiz kullandığımıza dikkat
edin.

Gördüğünüz gibi,@propertybezeyicisinin ilk görevi bir metodu niteliğe
dönüştürmek. Peki acaba neden bir metodu niteliğe dönüştürmek istiyor
olabiliriz?

Şöyle bir program yazdığınızı düşünün:

```python
class Program():
 def __init__(self):
 self.data = 0

```

Yazdığınız bu programı kullananlar, sınıf içindekidataniteliğine şu şekilde
erişiyor:

```python
>>> p = Program()
>>> p.data

0

```

Hatta duruma göre bu niteliği şu şekilde değişikliğe de uğratıyor:

```python
>>> p.data = 1

```

Günün birinde, ‘data’ kelimesi yerine ‘veri’ kelimesinin daha uygun olduğunu
düşünerek, ‘data’ kelimesini ‘veri’ olarak değiştirmek istediğinizi varsayalım.
Bunun için kodlarınızda şu değişikliği yapabilirsiniz:

```python
class Program():
 def __init__(self):
 self.veri = 0

```

Ancak bu şekilde, programınızı eskiden beri kullananların, sizin yazdığınız bu
programı temel alarak oluşturdukları programları bozmuş oldunuz… Çünkü eğer bu
programdan faydalanan birisi, yazdığı kodda eskiself.datadeğişkenini
kullanmışsa, yukarıdaki isim değişikliği yüzünden programı kullanılamaz hale
gelecektir. İşte bunu önlemek için@propertybezeyicisini kullanabilirsiniz.

Dikkatlice bakın:

```python
class Program():
 def __init__(self):
 self.veri = 0

 @property
 def data(self):
 return self.veri

```

Bu şekilde,self.dataniteliğine yapılan bütün çağrılardata()adlı metot
vasıtasıylaself.veriniteliğine yönlendirilecek. Böylece başkalarının bu
programı kullanarak yazdığı eski kodları bozmadan, programımızda istediğimiz
değişikliği yapmış olduk. Yani programımızda geriye dönük uyumluluğu (backwards
compatibility) sağlamış olduk.

Yukarıdaki kodlarda@propertybezeyicisini kullanarakdata()metodunu bir
niteliğe dönüştürdüğümüz için artık şöyle bir kullanım mümkün:

```python
>>> p = Program()
>>> p.data

0

>>> p.veri

0

```

Bu yapıda,self.veriüzerindeki değişikliklerself.dataniteliğine de
yansıyacaktır:

```python
>>> p.veri = 5
>>> p.data

5

```

#### Salt Okunur Nitelikler

@propertybezeyicisinin bir başka kabiliyeti de salt okunur nitelikler
oluşturabilmesidir.

Mesela yukarıdaki programı temel alarak şöyle bir şey deneyelim:

```python
>>> p = Program()
>>> p.data = 5

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: can't set attribute

```

Gördüğünüz gibi,dataniteliği üzerinde değişiklik yapamıyoruz. Dolayısıyla,
kodlarınızı kullananların değiştirmesini istemediğiniz, ‘salt okunur’ nitelikler
oluşturmak için@propertybezeyicisinden yararlanabilirsiniz.

#### Veri Doğrulaması

@propertybezeyicisinin üç önemli işlevi bulunur:
- Değer döndürmek
- Değer atamak
- Değer silmek

Değer döndürmek

Değer atamak

Değer silmek

Yukarıdaki örneklerde bu bezeyicinin değer döndürme işlevini görmüştük. Şimdi
ise bu bezeyicinin değer atama işlevini anlamaya çalışalım.

Bildiğiniz gibi,@propertybezeyicisinin ‘değer döndürme’ işlevini kullanarak,
bir niteliğe erişimi kısıtlayabiliyoruz. Örneğin, zamanında şöyle bir kod
yazdığımızı varsayalım:

```python
class Program():
 def __init__(self):
 self.sayı = 0

```

Daha sonra herhangi bir sebepten ötürü buradakiself.sayıniteliğine erişimi
kısıtlayıp bu niteliği üzerinde değişiklik yapılamaz hale getirmek istersek@propertybezeyicisinden yararlanabiliriz:

```python
class Program():
 def __init__(self):
 self._sayı = 0

 @property
 def sayı(self):
 return self._sayı

```

Gördüğünüz gibi, öncelikleself.sayıadlı niteliği, başına bir alt çizgi
getirerek normal erişime kapatmak istediğimizi belirttik. Bu kodları görenler,sayıniteliğinin yarı-gizli bir üye olduğunu anlayıp ona göre davranacak.
Ayrıca biraz sonra tanımlayacağımızsayı()fonksiyonuyla bu değişkenin
adının birbirine karışmaması için de bir önlem almış olacağız. Python’da bir
değişkenin adını değiştirmeden o değişkene erişimi kontrol altına almak
istediğimizde tek alt çizgi kullanmak tercih edilen bir yöntemdir.

Daha sonra dasayı()fonksiyonumuzu tanımlıyoruz:

```python
@property
def sayı(self):
 return self._sayı

```

Busayı()fonksiyonunu@propertyile bezediğimiz için, fonksiyon bir
niteliğe dönüştü vesayıdeğişkenini salt okunur hale getirdi. Eğer amacınız
değişkeni salt okunur hale getirmek değilse@propertyile bezediğimiz
fonksiyon için birsetterparametresi tanımlayabilirsiniz. Nasıl mı?
Dikkatlice inceleyin:

```python
class Program():
 def __init__(self):
 self._sayı = 0

 @property
 def sayı(self):
 return self._sayı

 @sayı.setter
 def sayı(self, yeni_değer):
 self._sayı = yeni_değer
 return self._sayı

```

@propertyile bezeyerek bir nitelik haline getirdiğiniz fonksiyonu yazılabilir
hale getirmek ve bu yazma işleminin nasıl olacağını belirlemek için özel bir.setterbezeyicisi ile bezenmiş yeni bir fonksiyon tanımlayabilirsiniz.

Biz yukarıda, yinesayıadını taşıyan,.setterile bezenmiş bir fonksiyon
daha tanımladık:

```python
@sayı.setter
def sayı(self, yeni_değer):
 self._sayı = yeni_değer
 return self._sayı

```

Yukarıdaki kodları çalıştırdığımızda,_sayıdeğişkeninesayıadı ile normal
bir şekilde erişip istediğimiz değişikliği yapabiliyoruz:

```python
>>> p = Program()
>>> p.sayı

0

>>> p.sayı = 5
>>> p.sayı

5

```

Gördüğünüz gibi, artıksayıdeğişkeni, kendisi için bir.setterbezeyicisi
tanımlamış olmamız sayesinde değişiklik kabul ediyor.

.setterbezeyicisini, bir niteliği yazılabilir hale getirmenin yanı sıra,
doğrulama işlemleri için de kullanabilirsiniz.

Basit bir örnek verelim:

```python
class Program():
 def __init__(self):
 self._sayı = 0

 @property
 def sayı(self):
 return self._sayı

 @sayı.setter
 def sayı(self, yeni_değer):
 if yeni_değer % 2 == 0:
 self._sayı = yeni_değer
 else:
 print('çift değil!')

 return self.sayı

```

Burada,self.sayıniteliğinin değerini çift sayılarla sınırlandırdık. Veri
doğrulama/kısıtlama işlemini.setterbezeyicisi içinden gerçekleştirdiğimize
dikkatinizi çekmek isterim. Buna göre, eğerself.sayıdeğişkenine girilen
değer bir çift sayı ise bu değişikliği kabul ediyoruz. Aksi halde ‘çift değil!’
uyarısı gösteriyoruz:

```python
>>> p = Program()
>>> p.sayı = 2
>>> p.sayı = 5

'çift değil!'

```

Bu arada,.setterdışında.deleteradlı özel bir@propertybezeyicisi daha
bulunur. Bunu da bir değeri silmek için kullanıyoruz:

```python
class Program():
 def __init__(self):
 self._sayı = 0

 @property
 def sayı(self):
 return self._sayı

 @sayı.setter
 def sayı(self, yeni_değer):
 if yeni_değer % 2 == 0:
 self._sayı = yeni_değer
 else:
 print('çift değil!')

 return self.sayı

 @sayı.deleter
 def sayı(self):
 del self._sayı

```

Gördüğünüz gibi,@propertybezeyicisini kullanırken üç ayrı metot
tanımlıyoruz:
- İlgili niteliğe nasıl ulaşacağımızı gösteren bir metot: Bu metodu@propertyile beziyoruz.
- İlgili niteliği nasıl ayarlayacağımızı gösteren bir metot: Bu metodu@metot_adı.setterşeklinde beziyoruz.
- İlgili niteliği nasıl sileceğimizi gösteren bir metot: Bu metodu@metot_adı.deleterşeklinde beziyoruz.

İlgili niteliğe nasıl ulaşacağımızı gösteren bir metot: Bu metodu@propertyile beziyoruz.

İlgili niteliği nasıl ayarlayacağımızı gösteren bir metot: Bu metodu@metot_adı.setterşeklinde beziyoruz.

İlgili niteliği nasıl sileceğimizi gösteren bir metot: Bu metodu@metot_adı.deleterşeklinde beziyoruz.

Bu bölümde nesne tabanlı programlamanın orta-ileri düzey sayılabilecek yönlerine
temas ettik. Artık nesne tabanlı programlamanın temellerinden biraz daha
fazlasını bildiğinizi rahatlıkla iddia edebilirsiniz.

## Nesne Tabanlı Programlama (Devamı)

Nesne tabanlı programlamaya giriş yaparken, bu programlama yaklaşımının oldukça
geniş kapsamlı bir konu olduğunu söylemiştik. Bu bölümde de bu geniş kapsamlı
konunun ileri düzey yönlerini ele almaya devam edeceğiz.

Ayrıca bu bölümü bitirdikten sonra, nesne tabanlı programlamanın yoğun bir
şekilde kullanıldığı ‘grafik arayüz tasarlama’ konusundan da söz edebileceğiz.
Böylece, bu zamana kadar gördüğümüz komut satırı uygulamalarından sonra, bu
bölümle birlikte ilk kez düğmeli-menülü modern arayüzleri tanımaya da
başlayacağız. Üstelik grafik arayüzlü programlar üzerinde çalışmak, nesne
tabanlı programlamanın özellikle karmaşık yönlerini çok daha kolay ve net bir
şekilde anlamamızı da sağlayacak.

### Miras Alma

Bu bölümde, yine nesne tabanlı programlamaya ait bir kavram olan ‘miras alma’dan
söz edeceğiz. Bütün ayrıntılarıyla ele alacağımız miras alma, nesne tabanlı
programlamanın en önemli konularından birisidir. Hatta nesne tabanlı
programlamayı faydalı bir programlama yaklaşımı haline getiren özelliklerin
başında miras alma gelir dersek çok da abartmış olmayız. Ayrıca miras alma
konusu, komut satırında çalışan programların yanı sıra grafik arayüzlü programlar
da yazabilmemizin önündeki son engel olacak. Bu bölümü tamamladıktan sonra,
grafik arayüzlü programlar yazmamızı sağlayacak özel modüllerin belgelerinden
yararlanabilmeye ve grafik arayüzlü programların kodlarını okuyup anlamaya
başlayabileceğiz.

Daha önce de söylediğimiz gibi, Python programlama dilinin temel felsefesi, bir
kez yazılan kodları en verimli şekilde tekrar tekrar kullanabilmeye dayanır.
Genel olarak baktığımızda dilin hemen hemen bütün öğeleri bu amaca hizmet edecek
şekilde tasarlanmıştır. İşte bu başlık altında ele alacağımız ‘miras alma’
kavramı da kodların tekrar tekrar kullanılabilmesi felsefesine katkı sunan bir
özelliktir.

İsterseniz miras alma konusunu anlatmaya basit bir örnekle başlayalım.

Diyelim ki bir oyun yazıyorsunuz. Bu oyun içinde askerler, işçiler, yöneticiler,
krallar, kraliçeler ve bunun gibi oyuncu türleri olacak. Bu oyuncuları ve
kabiliyetlerini mesela şöyle tanımlayabilirsiniz:

```python
class Asker():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 100

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class İşçi():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 70

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Yönetici():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 20

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

Burada asker, işçi ve yöneticinin her biri için ayrı bir sınıf tanımladık. Her
sınıfın bir ismi, rütbesi ve gücü var. Ayrıca her sınıf; hareket etme, puan
kazanma ve puan kaybetme gibi kabiliyetlere sahip.

Bu kodlarınoyuncular.pyadlı bir dosyada bulunduğunu varsayarsak, mesela bir
asker oluşturmak için yukarıdaki kodları şöyle kullanabiliriz:

```python
>>> import oyuncular
>>> asker1 = oyuncular.Asker('Mehmet', 'er')

```

Asker()sınıfınınisimverütbeparametrelerini belirtmek suretiyle bir
asker nesnesi oluşturduk. Tıpkı Python’da gördüğümüz başka nesneler gibi, bu
nesne de çeşitli nitelik ve metotlardan oluşuyor:

```python
>>> dir(asker1)

['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',
 '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'güç',
 'hareket_et', 'isim', 'puan_kaybet', 'puan_kazan', 'rütbe']

```

Bu nitelik ve metotları asker nesnesi üzerine nasıl uygulayacağımızı
biliyorsunuz:

```python
>>> asker1.isim

'Mehmet'

>>> asker1.rütbe

'er'

>>> asker1.güç

100

>>> asker1.hareket_et()

'hareket ediliyor...'

>>> asker1.puan_kazan()

'puan kazanıldı'

>>> asker1.puan_kaybet()

'puan kaybedildi'

```

Aynı şekilde ötekiİşçi()veYönetici()sınıflarını da örnekleyip
kullanabiliriz. Bu konuda bir problem yok. Ancak yukarıdaki kodları
incelediğinizde, aynı kodların sürekli tekrarlandığını göreceksiniz. Gördüğünüz
gibi, aynı nitelik ve metotları her sınıf için yeniden tanımlıyoruz. Bu durumun
Python’ın mantalitesine aykırı olduğunu tahmin etmek hiç zor değil. Peki acaba
yukarıdaki kodları nasıl daha ‘Pythonvari’ hale getirebiliriz?

Bu noktada ilk olarak taban sınıflardan söz etmemiz gerekiyor.

### Taban Sınıflar

Taban sınıflar (base classes) miras alma konusunun önemli kavramlarından
biridir. Dilerseniz taban sınıfın ne olduğu anlayabilmek için, yukarıda
verdiğimiz örneği temel alarak çok basit bir uygulama yapalım.

Öncelikle yukarıda verdiğimiz örneği tekrar önümüze alalım:

```python
class Asker():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 100

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class İşçi():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 70

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Yönetici():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 20

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

Bu örnekte,Asker(),İşçi()veYönetici()adlı sınıfların içeriğine
baktığımızda pek çok metot ve niteliğin aslında birbiriyle aynı olduğunu
görüyoruz. Gelin isterseniz bütün sınıflarda ortak olan bu nitelik ve metotları
tek bir sınıf altında toplayalım.

Asker(),İşçi()veYönetici()sınıflarının, yazdığımız programdaki
oyuncuları temsil ettiğini düşünürsek, ortak nitelik ve metotları barındıran
sınıfımızı daOyuncu()olarak adlandırmamız mantıksız olmayacaktır:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

İşte buradaOyuncu()adlı sınıf, bir ‘taban sınıf’ olarak adlandırılır.
Taban sınıf denen şey, birkaç farklı sınıfta ortak olan nitelik ve metotları
barındıran bir sınıf türüdür. İngilizcedebase classolarak adlandırılan taban
sınıflar, ayrıca üst sınıf (super class) veya ebeveyn sınıf (parent class)
olarak da adlandırılır. Biz bu makalede taban sınıf ismini tercih edeceğiz.

YukarıdakiOyuncu()adlı taban sınıf da,İşçi(),Asker(),Yönetici()gibi sınıfların hepsinde ortak olarak bulunacak nitelik ve
metotları barındıracak. Öteki bütün sınıflar, ortak nitelik ve metotlarını her
defasında tek tek yeniden tanımlamak yerine,Oyuncu()adlı bu taban sınıftan
devralacak. Peki ama nasıl? İşte bunu anlamak için de ‘alt sınıf’ adlı bir
kavrama değinmemiz gerekiyor.

### Alt Sınıflar

Bir taban sınıftan türeyen bütün sınıflar, o taban sınıfın alt sınıflarıdır.
(subclass). Alt sınıflar, kendilerinden türedikleri taban sınıfların metot ve
niteliklerini miras yoluyla devralır.

Anlattığımız bu soyut şeyleri anlamanın en kolay yolu somut bir örnek üzerinden
ilerlemektir. Mesela, biraz önce tanımladığımızOyuncu()adlı taban sınıftan
bir alt sınıf türetelim:

```python
class Asker(Oyuncu):
 pass

```

Kodlarımız tam olarak şöyle görünüyor:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 pass

```

BuradaAsker()sınıfını tanımlarken, bu sınıfın parantezleri içineOyuncu()sınıfının adını yazdığımıza dikkat edin. İşte bu şekilde bir
sınıfın parantezleri içinde başka bir sınıfın adını belirtirsek, o sınıf,
parantez içinde belirttiğimiz sınıfın bir alt sınıfı olmuş olur. Yani mesela
yukarıdaki gibiAsker()sınıfının parantezleri arasınaOyuncu()sınıfının adını yazdığımızda,Asker()adlı sınıf;
1. Oyuncu()adlı sınıfı miras almış,
1. Oyuncu()adlı sınıfın bütün metot ve niteliklerini devralmış,
1. Oyuncu()adlı sınıftan türemiş oluyor.

Oyuncu()adlı sınıfı miras almış,

Oyuncu()adlı sınıfın bütün metot ve niteliklerini devralmış,

Oyuncu()adlı sınıftan türemiş oluyor.

Bu sayedeOyuncu()sınıfında tanımlanan bütün nitelik ve metotlaraAsker()sınıfından da erişebiliyoruz:

```python
>>> import oyuncular
>>> asker1 = oyuncular.Asker('Ahmet', 'Er')
>>> asker1.isim

'Ahmet'

>>> asker1.rütbe

'Er'

>>> asker1.güç

0

>>> asker1.puan_kazan()

'puan kazanıldı'

```

Örnek olması açısından,Oyuncu()sınıfından türeyen (miras alan) birkaç alt
sınıf daha tanımlayalım:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 pass

class İşçi(Oyuncu):
 pass

class Yönetici(Oyuncu):
 pass

```

Tanımladığımız buİşçi()veYönetici()sınıfları da tıpkıAsker()sınıfı gibiOyuncu()adlı sınıftan miras aldığı için,Oyuncu()sınıfının
sahip olduğu tüm nitelik ve metotlara sahiptirler.

Buraya kadar anlattıklarımızı özetleyecek olursak, şu sınıf bir taban sınıftır:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

Bu taban sınıf, kendisinden türeyecek alt sınıfların ortak nitelik ve
metotlarını tanımlar.

Şu sınıflar ise, yukarıdaki taban sınıftan türeyen birer alt sınıftır:

```python
class Asker(Oyuncu):
 pass

class İşçi(Oyuncu):
 pass

class Yönetici(Oyuncu):
 pass

```

Bu alt sınıflar,Oyuncu()adlı taban sınıfın bütün nitelik ve metotlarını
miras yoluyla devralır. YaniOyuncu()adlı taban/ebeveyn/üst sınıfın nitelik
ve metotlarına,Asker(),İşçi()veYönetici()adlı alt sınıflardan
erişebiliriz:

```python
>>> asker1 = Asker('Ahmet', 'İstihkamcı')
>>> işçi1 = İşçi('Mehmet', 'Usta')
>>> yönetici1 = Yönetici('Selim', 'Müdür')
>>> asker1.hareket_et()

'hareket ediliyor...'

>>> işçi1.puan_kaybet()

'puan kaybedildi'

>>> yönetici1.puan_kazan()

'puan kazanıldı'

```

İşte bu mekanizmaya miras alma (inheritance) adı verilir. Miras alma
mekanizması, bir kez yazılan kodların farklı yerlerde kullanılabilmesini
sağlayan, bu bakımdan da programcıyı kod tekrarına düşmekten kurtaran oldukça
faydalı bir araçtır. İlerleyen sayfalarda miras alma mekanizmasının başka
faydalarını da göreceğiz.

### Miras Alma Türleri

Tahmin edebileceğiniz gibi, miras alma yalnızca bir sınıfın parantezleri arasına
başka bir sınıfı yazarak ilgili sınıfın bütün nitelik ve metotlarını kayıtsız
şartsız devralmaktan ibaret değildir. Bir sınıf, muhtemelen, miras aldığı
nitelik ve metotlar üzerinde birtakım değişiklikler de yapmak isteyecektir.
Esasında miras alma mekanizmasının işleyişi bakımından kabaca üç ihtimalden söz
edebiliriz:
1. Miras alınan sınıfın bütün nitelik ve metotları alt sınıfa olduğu gibi
devredilir.
1. Miras alınan sınıfın bazı nitelik ve metotları alt sınıfta yeniden
tanımlanır.
1. Miras alınan sınıfın bazı nitelik ve metotları alt sınıfta değişikliğe
uğratılır.

Miras alınan sınıfın bütün nitelik ve metotları alt sınıfa olduğu gibi
devredilir.

Miras alınan sınıfın bazı nitelik ve metotları alt sınıfta yeniden
tanımlanır.

Miras alınan sınıfın bazı nitelik ve metotları alt sınıfta değişikliğe
uğratılır.

Bu ihtimallerden ilkini zaten görmüştük. Bir sınıfın parantezleri arasına başka
bir sınıfın adını yazdıktan sonra eğer alt sınıfta herhangi bir değişiklik
yapmazsak, taban sınıftaki nitelik ve metotlar olduğu gibi alt sınıflara
aktarılacaktır.

Mesela:

```python
class Asker(Oyuncu):
 pass

```

BuradaAsker()sınıfı, miras aldığıOyuncu()sınıfının sanki bir kopyası
gibidir. DolayısıylaOyuncu()sınıfının bütün nitelik ve metotlarınaAsker()sınıfı altından da aynen erişebiliriz.

Yani yukarıdaki kod,Oyuncu()adlı sınıfın bütün nitelik ve metotlarınınAsker()sınıfı tarafından miras alınmasını sağlar. Bu şekilde,Oyuncu()sınıfı içinde hangi metot veya nitelik nasıl tanımlanmışsa,Asker()sınıfına
da o şekilde devredilir.

Taban sınıfımızın şu şekilde tanımlandığını biliyoruz:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

Dolayısıyla bu taban sınıfta hangi nitelik ve metotlar hangi değerlere sahipse
aşağıdakiAsker(),İşçi()veYönetici()sınıfları da o değerlere
sahip olacaktır:

```python
class Asker(Oyuncu):
 pass

class İşçi(Oyuncu):
 pass

class Yönetici(Oyuncu):
 pass

```

Ancak, dediğimiz gibi, miras almada tek seçenek bütün metot ve nitelikleri
olduğu gibi alt sınıflara aktarmak değildir. Zaten öyle olsaydı miras alma
mekanizmasının pek bir anlamı olmazdı. Biz miras aldığımız sınıflar üzerinde,
içinde bulunduğumuz durumun gerektirdiği birtakım değişiklikleri yapabilmeliyiz
ki bu mekanizmanın ilgi çekici bir yanı olsun.

Ayrıca eğer bir taban sınıfı alt sınıflara olduğu gibi aktaracaksanız, taban
sınıftan gelen metot ve nitelikler üzerinde herhangi bir değişiklik
yapmayacaksanız ve alt sınıflara da herhangi bir nitelik ilave etmeyecekseniz,
alt sınıflar tanımlamak yerine doğrudan taban sınıfın örneklerinden yararlanmak
daha akıllıca ve pratik bir tercih olabilir:

```python
>>> asker = Oyuncu('Ahmet', 'Er')
>>> işçi = Oyuncu('Mehmet', 'Usta')
>>> yönetici = Oyuncu('Selim', 'Müdür')

```

Burada asker, işçi ve yönetici için ayrı ayrı alt sınıflar tanımlamak yerine,
her biri için doğrudanOyuncu()sınıfını farklıisimverütbedeğerleriyle örnekleyerek istediğimiz şeyi elde ettik.

İlerleyen derslerde miras alma alternatiflerinden daha ayrıntılı bir şekilde söz
edeceğiz, ama dilerseniz şimdi konuyu daha fazla dağıtmadan miras alınan metot
ve niteliklerin alt sınıflar içinde nasıl yeniden tanımlanacağını, nasıl
değişikliğe uğratılacağını ve alt sınıflara nasıl yeni nitelik ve metotlar
ekleneceğini incelemeye geçelim ve ilk örneklerimizi vermeye başlayalım.

Hatırlarsanız bir önceki başlıkta şöyle bir kod yazmıştık:

```python
class Asker(Oyuncu):
 pass

```

BuradaOyuncu()sınıfını bütünüyle alt sınıfa aktardık. Peki ya biz bir
taban sınıfı olduğu gibi miras almak yerine, bazı nitelikleri üzerinde
değişiklik yaparak miras almak istersek ne olacak? Mesela taban sınıf içindeself.güçdeğeri 0. Biz bu değerinAsker(),İşçi()veYönetici()örnekleri için birbirinden farklı olmasını isteyebiliriz. Veya taban sınıfı
olduğu gibi miras almakla birlikte, alt sınıflardan herhangi birine ilave
nitelik veya nitelikler eklemek de isteyebiliriz. Diyelim ki bizAsker()sınıfı için, öteki sınıflardan farklı olarak, bir dememleketniteliği
tanımlamak istiyoruz. Peki bu durumda ne yapacağız?

İşte bunun içinAsker()sınıfını şu şekilde yazabiliriz:

```python
class Asker(Oyuncu):
 memleket = 'Arpaçbahşiş'

```

BuradaAsker()sınıfınamemleketadlı bir sınıf niteliği eklemiş olduk.
DolayısıylaAsker()sınıfı,Oyuncu()adlı taban sınıftan miras alınan
bütün nitelik ve metotlarla birlikte bir dememleketniteliğine sahip olmuş
oldu:

```python
>>> asker = Asker('Ahmet', 'binbaşı')
>>> asker.isim

'Ahmet'

>>> asker.memleket

'Arpaçbahşiş'

```

Elbette, bu niteliği öbür alt sınıflarda tanımlamadığımız için bu nitelik
yalnızcaAsker()sınıfına özgüdür.

Aynı şekilde, bir taban sınıftan türeyen bir alt sınıfa yeni bir sınıf metodu,
örnek metodu veya statik metot da ekleyebiliriz:

```python
class Asker(Oyuncu):
 memleket = 'Arpaçbahşiş'

 def örnek_metodu(self):
 pass

 @classmethod
 def sınıf_metodu(cls):
 pass

 @staticmethod
 def statik_metot():
 pass

```

Kural şu: Eğer alt sınıfa eklenen herhangi bir nitelik veya metot taban
sınıfta zaten varsa, alt sınıfa eklenen nitelik ve metotlar taban sınıftaki
metot ve niteliklerin yerine geçecektir. Yani diyelim ki taban sınıfımız şu:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

```

Bu sınıfın nitelik ve metotlarını miras yoluyla devralanAsker()sınıfımız
ise şu:

```python
class Asker(Oyuncu):
 pass

```

Şimdi bu sınıf içindehareket_et()adlı bir örnek metodu tanımlayalım:

```python
class Asker(Oyuncu):
 def hareket_et(self):
 print('yeni hareket_et() metodu')

```

Eğer taban sınıftahareket_et()adlı bir metot olmasaydı,Asker()adlı
alt sınıf, taban sınıftan miras alınan öteki metot ve niteliklerle birlikte bir
dehareket_et()adlı yeni bir örnek metoduna sahip olmuş olacaktı. Ancak
taban sınıfta zatenhareket_et()adlı bir örnek metodu olduğu için, alt
sınıfta tanımladığımız aynı adlı örnek metodu, taban sınıftaki metodun yerine
geçip üzerine yazıyor.

Buraya kadar her şey tamam. Artık bir taban sınıfa ait metodu alt sınıfa miras
yoluyla aktarırken nasıl yeniden tanımlayacağımızı öğrendik. Ayrıca alt
sınıflara nasıl yeni metot ve nitelik ekleyeceğimizi de biliyoruz. Ama mesela,self.isimveself.rütbedeğişkenlerini korurken, taban sınıf içinde 0 değeri
ile gösterilenself.güçdeğişkeniniAsker(),İşçi()veYönetici()sınıflarının her biri içinde nasıl farklı bir değerle göstereceğimizi
bilmiyoruz. Yaniself.güçdeğeriniAsker()sınıfı içinde 100,İşçi()sınıfı içinde 70,Yönetici()sınıfı içinde ise 50 ile göstermek istesek
nasıl bir yol takip etmemiz gerektiği konusunda bir fikrimiz yok. İsterseniz şu
ana kadar bildiğimiz yöntemleri kullanarak bu amacımızı gerçekleştirmeyi bir
deneyelim:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 self.güç = 100

class İşçi(Oyuncu):
 def __init__(self, isim, rütbe):
 self.güç = 70

class Yönetici(Oyuncu):
 def __init__(self, isim, rütbe):
 self.güç = 50

```

Burada taban sınıfın__init__()metodunu alt sınıflarda yeniden tanımladık.
Bu kodları bu şekilde yazıp çalıştırdığımızdaself.güçdeğerinin her bir alt
sınıf için istediğimiz değere sahip olduğunu görürüz. Ancak burada şöyle bir
sorun var. Bu kodları bu şekilde yazarakself.isimveself.rütbedeğişkenlerinin değerini maalesef kaybettik…

__init__()metodunun parametre listesineisimverütbeparametrelerini
yazdığımız halde bunları kodlarımız içinde herhangi bir şekilde kullanmadığımız
için, bu parametrelerin listede görünüyor olması bir şey ifade etmiyor. Yani alt
sınıflarda tanımladığımız__init__()metodu bizdenisimverütbeadlı
iki parametre bekliyor olsa da, bu parametrelerin değerini kodlar içinde
kullanmadığımız için bu parametrelere değer atamamız herhangi bir amaca hizmet
etmiyor.

Gelin bu söylediklerimizi kanıtlayalım:

```python
>>> import oyuncular
>>> asker = oyuncular.Asker('Ahmet', 'Er')
>>> asker.rütbe

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'Asker' object has no attribute 'rütbe'

>>> asker.isim

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'Asker' object has no attribute 'isim'

```

Bu sorunu çözmek için alt sınıflarımızı şu şekilde yazabiliriz:

```python
class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 100

class İşçi(Oyuncu):
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 70

class Yönetici(Oyuncu):
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 50

```

Buradaself.isimveself.rütbedeğişkenlerini her bir alt sınıf için tekrar
tanımladık. Bu küçük örnekte pek sorun olmayabilir, ama taban sınıfın__init__()metodunun içinde çok daha karmaşık işlemlerin yapıldığı
durumlarda yukarıdaki yaklaşım hiç de pratik olmayacaktır. Ayrıca eğer miras
alma işlemini, içeriğini bilmediğiniz veya başka bir dosyada bulunan bir
sınıftan yapıyorsanız yukarıdaki yöntem tamamen kullanışsız olacaktır. Ayrıca
aynı şeyleri tekrar tekrar yazmak miras alma mekanizmasının ruhuna tamamen
aykırıdır. Çünkü biz miras alma işlemini zaten aynı şeyleri tekrar tekrar
yazmaktan kurtulmak için yapıyoruz.

Bu arada, yukarıda yapmak istediğimiz şeyi şununla karıştırmayın: Biz elbette
taban sınıftaki bir niteliği, örnekleme sırasında değiştirme imkanına her
koşulda sahibiz. Yani taban ve alt sınıfların şöyle tanımlanmış olduğunu
varsayarsak:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 pass

class İşçi(Oyuncu):
 pass

class Yönetici(Oyuncu):
 pass

```

Her bir alt sınıfıngüçdeğişkenini şu şekilde değiştirebiliriz:

```python
>>> import oyuncular
>>> asker = oyuncular.Asker('Ahmet', 'Er')
>>> asker.güç

0

```

Gördüğünüz gibi şu anda askerin gücü 0. Bunu 100 yapalım:

```python
>>> asker.güç = 100
>>> asker.güç

100

```

Aynı şeyi ötekiİşçi()veYönetici()sınıflarının örnekleri üzerinde de
yapabiliriz. Ama bizim istediğimiz bu değil. Biz,Asker()sınıfını
örneklediğimiz anda gücü 100,İşçi()sınıfını örneklediğimiz anda gücü 70,Yönetici()sınıfını örneklediğimiz anda ise gücü 50 olsun istiyoruz.

İşte tam bu noktada imdadımıza yepyeni bir fonksiyon yetişecek. Bu yeni
fonksiyonun adısuper().

### super()

Hatırlarsanız, taban sınıflardan ilk kez bahsederken, bunlara üst sınıf da
dendiğini söylemiştik. Üst sınıf kavramının İngilizcesisuper class’tır. İşte
bu bölümde inceleyeceğimizsuper()fonksiyonunun adı da buradaki ‘super’,
yani ‘üst’ kelimesinden gelir. Miras alınan üst sınıfa atıfta bulunansuper()fonksiyonu, miras aldığımız birüstsınıfın nitelik ve metotları
üzerinde değişiklik yaparken, mevcut özellikleri de muhafaza edebilmemizi
sağlar.

Bir önceki başlıkta verdiğimiz örnek üzerindensuper()fonksiyonunu
açıklamaya çalışalım:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 self.güç = 100

```

Bu kodlarda,Oyuncu()adlı taban sınıfı miras alanAsker()sınıfı,__init__()metodu içindeself.güçdeğerini yeniden tanımlıyor. Ancak bu
şekilde taban sınıfın__init__()metodu silindiği için,self.isimveself.rütbedeğişkenlerini kaybediyoruz. İşte bu sorunu, üst sınıfa atıfta
bulunansuper()fonksiyonu ile çözebiliriz.

Dikkatlice bakın:

```python
class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 super().__init__(isim, rütbe)
 self.güç = 100

```

Burada__init__()metodu içinde şöyle bir satır kullandığımızı
görüyorsunuz:

```python
super().__init__(isim, rütbe)

```

İşte bu satırdasuper()fonksiyonu, tam da adının anlamına uygun olarak,
miras alınan üst sınıfın__init__()metodu içindeki kodların, miras alan alt
sınıfın__init__()metodu içine aktarılmasını sağlıyor. Böylece hem taban
sınıfın__init__()metodu içindekiself.isimveself.rütbeniteliklerini
korumuş, hem deself.güçadlı yeni bir nitelik ekleme imkanı elde etmiş
oluyoruz:

```python
>>> asker = oyuncular.Asker('Ahmet', 'Er')
>>> asker.isim

'Ahmet'

>>> asker.rütbe

'Er'

>>> asker.güç

100

```

Bu bilgiyi öteki alt sınıflara da uygulayalım:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 super().__init__(isim, rütbe)
 self.güç = 100

class İşçi(Oyuncu):
 def __init__(self, isim, rütbe):
 super().__init__(isim, rütbe)
 self.güç = 70

class Yönetici(Oyuncu):
 def __init__(self, isim, rütbe):
 super().__init__(isim, rütbe)
 self.güç = 20

```

Gördüğünüz gibi,super()fonksiyonu sayesinde taban sınıfın değiştirmek
istediğimiz niteliklerine yeni değerler atarken, değiştirmek istemediğimiz
nitelikleri ise aynı şekilde muhafaza ettik.

Bu arada eğer taban sınıfın__init__()metodundaki parametre listesini alt
sınıfta da tek tek tekrar etmek sizi rahatsız ediyorsa yukarıdaki kodları şöyle
de yazabilirsiniz:

```python
class Asker(Oyuncu):
 def __init__(self, *arglar):
 super().__init__(*arglar)
 self.güç = 100

class İşçi(Oyuncu):
 def __init__(self, *arglar):
 super().__init__(*arglar)
 self.güç = 70

class Yönetici(Oyuncu):
 def __init__(self, *arglar):
 super().__init__(*arglar)
 self.güç = 20

```

Yıldızlı parametreleri önceki derslerimizden hatırlıyor olmalısınız. Bildiğiniz
gibi, tek yıldızlı parametreler bir fonksiyonun bütün konumlu (positional)
argümanlarını, parametrelerin parantez içinde geçtiği sırayı dikkate alarak bir
demet içinde toplar. İşte yukarıda da bu özellikten faydalanıyoruz. Eğer taban
sınıfta isimli (keyword) argümanlar da olsaydı, o zaman da çift yıldızlı
argümanları kullanabilirdik.

Tek ve çift yıldızlı argümanlar genellikle şu şekilde gösterilir:

```python
class Asker(Oyuncu):
 def __init__(self, *args, **kwargs):
 super().__init__(*args, **kwargs)
 self.güç = 100

```

Böylece konumlu argümanları bir demet içinde, isimli argümanları ise bir sözlük
içinde toplamış oluyoruz. Bu da bizi üst (ya da taban) sınıfın parametre
listesini alt sınıflarda tekrar etme derdinden kurtarıyor.

Bu arada, miras alınan taban sınıfa atıfta bulunansuper()fonksiyonu,
Python programlama diline sonradan eklenmiş bir özelliktir. Bu fonksiyon
gelmeden önce taban sınıfa atıfta bulunabilmek için doğrudan o sınıfın adını
kullanıyorduk:

```python
class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 Oyuncu.__init__(self, isim, rütbe)
 self.güç = 100

```

veya:

```python
class Asker(Oyuncu):
 def __init__(self, *args):
 Oyuncu.__init__(self, *args)
 self.güç = 100

```

Gördüğünüz gibi, eski yöntemde taban sınıfın adını iki kez kullanmamız
gerekiyor. Ayrıca__init__()fonksiyonunun parametre listesinde ilk sıraya
yineselfkelimesini de eklemek zorunda kalıyoruz.

İsterseniz yukarıda gösterdiğimiz eski yöntemi kullanmaya devam edebilirsiniz
elbette. Ancaksuper()fonksiyonunu kullanmak eski yönteme göre biraz daha
pratiktir.

Yukarıdaki örneklerdesuper()fonksiyonunu__init__()metodu içinde
kullandık. Ancak elbettesuper()fonksiyonunu yalnızca__init__()fonksiyonu içinde kullanmak zorunda değiliz. Bu fonksiyonu başka fonksiyonlar
içinde de kullanabiliriz:

```python
class Oyuncu():
 def __init__(self, isim, rütbe):
 self.isim = isim
 self.rütbe = rütbe
 self.güç = 0

 def hareket_et(self):
 print('hareket ediliyor...')

 def puan_kazan(self):
 print('puan kazanıldı')

 def puan_kaybet(self):
 print('puan kaybedildi')

class Asker(Oyuncu):
 def __init__(self, isim, rütbe):
 super().__init__(isim, rütbe)
 self.güç = 100

 def hareket_et(self):
 super().hareket_et()
 print('hedefe ulaşıldı.')

```

Bu örneğin,super()fonksiyonunun nasıl işlediğini daha iyi anlamanızı
sağladığını zannediyorum. Gördüğünüz gibi, taban sınıfınhareket_et()adlı
metodunu alt sınıfta tanımladığımız aynı adlı fonksiyon içindesuper()fonksiyonu yardımıyla genişlettik, yani taban sınıfınhareket_et()adlı
fonksiyonuna yeni bir işlev ekledik:

```python
def hareket_et(self):
 super().hareket_et()
 print('hedefe ulaşıldı.')

```

Buradasuper().hareket_et()satırıyla taban sınıfınhareket_et()adlı
metodunu alt sınıfta tanımladığımız yenihareket_et()metodu içinde
çalıştırarak, bu metodun kabiliyetlerini yenihareket_et()metoduna
aktarıyoruz.

### object Sınıfı

Biz buraya gelinceye kadar Python’da sınıfları iki farklı şekilde
tanımlayabileceğimizi öğrendik:

```python
class Deneme():
 pass

```

veya:

```python
class Deneme:
 pass

```

Sınıf tanımlarken parantez kullansak da olur kullanmasak da. Eğer miras
alacağınız bir sınıf yoksa parantezsiz yazımı tercih edebilir, parantezli yazım
tarzını ise başka bir sınıftan miras aldığınız durumlar için saklayabilirsiniz:

```python
class AltSınıf(TabanSınıf):
 pass

```

Ancak sağda solda incelediğiniz Python kodlarında bazen şöyle bir sınıf
tanımlama şekli de görürseniz şaşırmayın:

```python
class Sınıf(object):
 pass

```

Python’ın 3.x öncesi sürümlerinde sınıflar yeni ve eski tip olmak üzere ikiye
ayrılıyordu. Bu sürümlerde eski tip sınıflar şöyle tanımlanıyordu:

```python
class Sınıf:
 pass

```

veya:

```python
class Sınıf():
 pass

```

Yeni tip sınıflar ise şöyle:

```python
class Sınıf(object):
 pass

```

Yani eski tip sınıflar öntanımlı olarak herhangi bir taban sınıftan miras
almazken, yeni tip sınıflarınobjectadlı bir sınıftan miras
alması gerekiyordu. Dolayısıyla, tanımladığınız bir sınıftaobjectsınıfını
miras almadığınızda, yeni tip sınıflarla birlikte gelen özelliklerden
yararlanamıyordunuz. Mesela önceki derslerde öğrendiğimiz@propertybezeyicisi yeni tip sınıflarla gelen bir özelliktir. Eğer Python 3 öncesi bir
sürüm için kod yazıyorsanız ve eğer@propertybezeyicisini kullanmak
istiyorsanız tanımladığınız sınıflarda açık açıkobjectsınıfını miras
almalısınız.

Python 3’te ise bütün sınıflar yeni tip sınıftır. Dolayısıylaobjectsınıfını
miras alsanız da almasanız da, tanımladığınız bütün sınıflar öntanımlı olarakobjectsınıfını miras alacaktır. Yani Python 3 açısından şu üç tanımlama
arasında bir fark bulunmaz:

```python
class Sınıf:
 pass

class Sınıf():
 pass

class Sınıf(object):
 pass

```

Bunların hepsi de Python 3 açısından birer yeni tip sınıftır. Daha doğrusu
Python 3’te bütün sınıflar bir yeni tip sınıf olduğu için, yukarıdaki sınıf
tanımlamaları hep aynı tipte sınıflara işaret eder. Python 2’de ise ilk iki
tanımlama eski tip sınıfları gösterirken, yalnızca üçüncü tanımlama yeni tip
sınıfları gösterir.

Geldik bir bölümün daha sonuna… Böylece miras almaya ilişkin temel konuları
incelemiş olduk. Bu bölümde öğrendiklerimiz sayesinde, etrafta gördüğümüz, miras
alma mekanizmasının kullanıldığı kodların çok büyük bir bölümünü anlayabilecek
duruma geldik. Bu mekanizmaya ilişkin olarak öğrenmemiz gerekenlerin geri
kalanını da bir sonraki bölümde, grafik arayüz tasarımı konusuyla birlikte ele
alacağız.

## Nesne Tabanlı Programlama (Devamı)

> **Uyarı**
> Bu makale yoğun bir şekilde geliştirilmekte, içeriği sık sık
güncellenmektedir.

Uyarı

Bu makale yoğun bir şekilde geliştirilmekte, içeriği sık sık
güncellenmektedir.

Geçen bölümde verdiğimiz bilgiler sayesinde miras alma konusunun temelini
oluşturan taban sınıf, alt sınıf ve türeme gibi kavramlarla birliktesuper()veobjectgibi araçların ne olduğunu ve ne işe yaradığını da öğrendik.
Dolayısıyla artık miras alma mekanizmasına dair daha renkli, daha teşvik edici
örnekler verebiliriz. Böylece, belki de gözünüze ilk bakışta pek de matah bir
şey değilmiş gibi görünen bu ‘miras alma’ denen mekanizmanın aslında ne kadar
önemli bir konu olduğuna sizleri ikna edebiliriz.

Bu bölümde ayrıca geçen bölümlerde incelemeye fırsat bulamasak da nesne tabanlı
programlama kapsamında incelememiz gereken başka konuları da ele alacağız.

Nesne tabanlı programlamadan ilk bahsettiğimiz derste, nesne tabanlı programlama
yaklaşımının grafik arayüz tasarımı için biçilmiş kaftan olduğundan söz etmiştik
hatırlarsanız. Bu bölümde inceleyeceğimiz konuların bazılarını grafik arayüz
tasarımı eşliğinde anlatacağız. Grafik arayüz programlamanın bize sunduğu
düğmeli-menülü görsel programların, nesne tabanlı programlamaya ilişkin soyut
kavramları somut bir düzleme taşımamıza imkan tanıması sayesinde, nesne tabanlı
programlamaya ilişkin çetrefilli konuları daha rahat anlama fırsatı
bulacağız.

### Tkinter Hakkında

Hatırlarsanız, önceki derslerimizde birkaç kez Tkinter adlı bir modülden söz
etmiştik. Tkinter, Python kurulumu ile birlikte gelen ve pencereli-menülü modern
programlar yazmamızı sağlayan grafik arayüz geliştirme takımlarından biridir.

Tkinter bir standart kütüphane paketi olduğu için, Python programlama dilini
kurduğunuzda Tkinter de otomatik olarak kurulur[1].

Elbette Python’da grafik arayüzlü programlar yazmamızı sağlayacak tek modül
Tkinter değildir. Bunun dışında PyQt, PyGI ve Kivy gibi alternatifler de
bulunur. Ancak Tkinter’in öteki alternatiflere karşı en büyük üstünlüğü hem
öbürlerine kıyasla çok daha kolay olması hem de Python’la birlikte gelmesidir.
PyQt, PyGI ve Kivy’yi kullanabilmek için öncelikle bunları bilgisayarınıza
kurmanız gerekir. Ayrıca Tkinter dışındaki alternatifleri kullanarak yazdığınız
programları dağıtırken, bu arayüz kütüphanelerini kullanıcılarınızın
bilgisayarına ya kendiniz kurmanız ya da kullanıcılarınızdan bu
kütüphaneleri kurmasını talep etmeniz gerekir.

Ben size, ilerde başka arayüz takımlarına geçiş yapacak da olsanız, Tkinter’i
mutlaka öğrenmenizi tavsiye ederim. Hem nesne tabanlı programlama hem de grafik
arayüz geliştirme kavramlarını öğrenmek açısından Tkinter son derece uygun bir
ortamdır.

Biz bu bölümde Tkinter modülünü kullanarak, prosedürel programlama, nesne
tabanlı programlama, sınıflar, miras alma ve nesne programlamaya ilişkin öteki
konular üzerine ufak tefek de olsa bazı çalışmalar yapacağız. Bu çalışmalar
sayesinde bir yandan öğrendiğimiz eski konulara ilişkin güzel bir pratik yapma
imkanı bulacağız, bir yandan Tkinter’in çalışmalarımızın sonucunu görsel bir
şekilde izleme imkanı sağlaması sayesinde nesne tabanlı programlamanın
çetrefilli kavramlarını anlamamız kolaylaşacak, bir yandan da ilk kez gördüğümüz
kodları anlama ve bunlar hakkında fikir yürütme kabiliyeti kazanacağız. Yani bir
taşla tamı tamına üç kuş vurmuş olacağız…

### Prosedürel Bir Örnek

Başta da söylediğimiz gibi, nesne tabanlı programlama, grafik arayüzlü
programlar geliştirmek için son derece uygun bir programlama yaklaşımıdır. Zaten
kendi araştırmalarınız sırasında da, etraftaki grafik arayüzlü programların
büyük çoğunluğunun nesne tabanlı programlama yaklaşımıyla yazıldığını
göreceksiniz. Biz de bu derste vereceğimiz Tkinter örneklerinde sınıflı yapıları
kullanacağız. Ancak dilerseniz Tkinter’in nasıl bir şey olduğunu daha kolay
anlayabilmek için öncelikle nesne tabanlı yaklaşım yerine prosedürel yaklaşımı
kullanarak birkaç küçük çalışma yapalım. Zira özellikle basit kodlarda,
prosedürel yapıyı anlamak nesne tabanlı programlama yaklaşımı ile yazılmış
kodları anlamaktan daha kolaydır. Ancak tabii ki kodlar büyüyüp karmaşıklaştıkça
sınıflı yapıları kullanmak çok daha akıllıca olacaktır.

O halde gelin isterseniz Tkinter modülünü nasıl kullanacağımızı anlamak için,
bir metin dosyası açıp içine şu kodları yazalım:

```python
import tkinter

pencere = tkinter.Tk()
pencere.mainloop()

```

Bu kodları herhangi bir Python programı gibi kaydedip çalıştırdığınızda boş bir
pencerenin açıldığını göreceksiniz. İşte böylece siyah komut satırından renkli
grafik arayüze geçiş yapmış oldunuz. Hadi hayırlı olsun!

Gördüğünüz gibi, bu kodlarda sınıfları kullanmadık. Dediğimiz gibi, ilk etapta
Tkinter’i daha iyi anlayabilmek için sınıflı yapılar yerine prosedürel bir
yaklaşımı benimseyeceğiz.

Burada öncelikle Tkinter modülünü içe aktardığımıza dikkat edin:

```python
import tkinter

```

Modülü bu şekilde içe aktardığımız için, modül içindeki nitelik ve metotlara
erişmek istediğimizde modülün adını kullanmamız gerekecek. Mesela yukarıda
modülün adını kullanarak,tkintermodülü içindekiTk()sınıfını
örnekledik:

```python
pencere = tkinter.Tk()

```

Dilerseniz içe aktarma işlemini şu şekilde yaparak işlerimizi biraz daha
kolaylaştırabiliriz:

```python
import tkinter as tk

```

Böylecetkintermodülünün nitelik ve metotlarına ‘tkinter’ yerine ‘tk’
önekiyle erişebiliriz:

```python
pencere = tk.Tk()

```

Yukarıdaki kodları yazdığımızda, yanitkintermodülününTk()sınıfını
örneklediğimiz anda aslında penceremiz oluştu. Ancak bu pencere örnekleme ile
birlikte oluşmuş olsa da, Tkinter’in iç işleyişi gereği, ‘ana döngü’ adlı bir
mekanizma çalışmaya başlamadan görünür hale gelmez. İşte bu özel ana döngü
mekanizmasını çalıştırmak ve böylece oluşturduğumuz pencereyi görünür hale
getirmek için,Tk()sınıf örneklerininmainloop()adlı bir metodunu
çalıştıracağız:

```python
pencere.mainloop()

```

Gördüğünüz gibi,Tk()sınıfınıpencereadıyla örnekledikten sonraTk()sınıfınınmainloop()adlı metodunapencereörneği üzerinden eriştik.

Bu ana döngü mekanizmasının benzerlerini Tkinter’in dışındaki öbür grafik arayüz
tasarım araçlarında da göreceksiniz.

Bu arada, yukarıdaki prosedürel örnekte bile, biz istemesek de sınıflarla
muhatap olduğumuza dikkatinizi çekmek isterim. Çünkü kullandığımıztkintermodülünün kendisi halihazırda birtakım sınıflardan oluşuyor. Dolayısıyla bu
modülü içe aktardığımızda, kodlarımızın içine pek çok sınıfı ister istemez dahil
etmiş oluyoruz. Esasında sırf bu durum bile, grafik arayüzlü programlarda neden
nesne tabanlı programlamanın tercih edildiğini gayet güzel gösteriyor bize.
Neticede, kullandığımız harici kaynaklardan ötürü her şekilde sınıflarla ve
nesne tabanlı yapılarla içli dışlı olacağımız için, kendi yazdığımız kodlarda da
nesne tabanlı yapılardan kaçmamızın hiçbir gerekçesi yok.

Neyse… Biz konumuza dönelim…

Yukarıda Tkinter modülünü kullanarak boş bir pencere oluşturduk. Gelin
isterseniz bu boş pencere üzerinde birtakım değişiklikler yapalım.

Öncelikletkintermodülümüzü içe aktaralım:

```python
import tkinter as tk

```

Şimdi bu modülünTk()adlı sınıfını örnekleyelim:

```python
pencere = tk.Tk()

```

Böylece penceremizi oluşturmuş olduk. Tkinter’le verdiğimiz ilk örnekte de
gördüğünüz gibi, Tkinter’le oluşturulan boş bir pencere öntanımlı olarak 200
piksel genişliğe ve 200 piksel yüksekliğe sahip olacaktır. Ancak isterseniz,Tk()sınıfınıngeometry()adlı metodunu kullanarak, pencere boyutunu
ayarlayabilirsiniz (Tk()sınıfının hangi metotlara sahip olduğunu görmek
içindir(pencere)komutunu verebileceğinizi biliyorsunuz):

```python
import tkinter as tk

pencere = tk.Tk()
pencere.geometry('200x70')

pencere.mainloop()

```

Kendi yazdığımız sınıflardaki nitelik ve metotlara nasıl erişiyorsak,Tk()sınıfının nitelik ve metotlarına da aynı şekilde eriştiğimize dikkat edin.
Neticede bizim yazdıklarımız da sınıftır,Tk()da sınıftır.Tk()sınıfının bizimkilerden tek farkı,Tk()sınıfının Python geliştiricilerince
yazılmış olmasıdır. Yazarları farklı olsa da bütün sınıflar aynı kurallara
tabidir. Dolayısıyla ilgili sınıfı kullanabilmek için önce sınıfımızı
örnekliyoruz, ardından da bu sınıf içinde tanımlı olan nitelik ve metotlara
noktalı gösterim tekniğini kullanarak ulaşıyoruz. Burada daTk()sınıf
örnekleriningeometry()metodunu kullanarak 200x200 yerine 200x70
boyutlarında bir pencere oluşturduk:

```python
pencere.geometry('200x70')

```

Şimdi bu boş pencereye bir etiket bir de düğme ekleyelim:

```python
import tkinter as tk

pencere = tk.Tk()
pencere.geometry('200x70')

etiket = tk.Label(text='Merhaba Zalim Dünya')
etiket.pack()

düğme = tk.Button(text='Tamam', command=pencere.destroy)
düğme.pack()

pencere.mainloop()

```

BuradatkintermodülününTk()sınıfına ek olarak, aynı modülünLabel()veButton()adlı iki sınıfını daha kullandık.Label()sınıfı etiketler,Button()sınıfı ise düğmeler oluşturmamızı sağlıyor. Bu sınıfların örnekleri
üzerinde çalıştırdığımızpack()metodunu ise, etiket ve düğmeleri pencere
üzerine yerleştirmek için kullanıyoruz.

Label()veButton()sınıflarınıntextadlı bir parametre aldığını
görüyorsunuz. Bu parametrenin değeri, etiket veya düğmenin üzerinde ne
yazacağını gösteriyor.

Bu kodları da tıpkı başka Python programlarını çalıştırdığınız gibi
çalıştırabilirsiniz.

Bu arada, Tkinter’de bir şeyi oluşturmanın ve görünür hale getirmenin iki farklı
işlem gerektirdiğine özellikle dikkat edin. Mesela üzerinde ‘Merhaba Zalim
Dünya’ yazan bir etiket oluşturmak için şu kodu kullanıyoruz:

```python
etiket = tk.Label(text='Merhaba Zalim Dünya')

```

Bu etiketi pencere üzerine yerleştirmek, yani görünür hale getirmek için ise şu
komutu kullanıyoruz:

```python
etiket.pack()

```

Aynı şekilde bir düğme oluşturmak için de şu komutu kullanıyoruz:

```python
düğme = tk.Button(text='Tamam', command=pencere.destroy)

```

Böylece üzerinde ‘Tamam’ yazan ve tıklandığında pencereyi kapatan bir düğme
oluşturmuş oluyoruz. Düğmenin üzerine tıklandığında ne olacağınıButton()sınıfınıncommandparametresi aracılığıyla belirledik. Bu parametreye,pencereörneğinindestroy()metodunu verdiğimizde pencereye kapatma
sinyali gönderilecektir. Yalnız bu metodu yazarken parantez işaretlerini
kullanmadığımıza dikkat edin. Eğer metodupencere.destroy()şeklinde
parantezli bir biçimde yazarsak, kapatma komutu daha düğmeye basmadan çalışacak
ve bu durumda düğmemiz düzgün işlemeyecektir.

Tıpkı etikette olduğu gibi, düğmemizi de pencere üzerine yerleştirmek, yani
görünür hale getirmek içinpack()metodundan yararlanıyoruz:

```python
düğme.pack()

```

Bunun,Tk()sınıfı ilemainloop()metodu arasındaki ilişkiye benzediğine
dikkatinizi çekmek isterim: Tıpkıpack()metoduna benzer bir şekilde,Tk()sınıfı yardımıyla da bir pencere oluşturduktan sonra, bu pencerenin
görünür hale gelebilmesi içinmainloop()metodunu çalıştırmamız gerektiğini
hatırlıyorsunuz.

Bu kodlarda Tkinter’e ilişkin ayrıntılardan ziyade, sınıflı yapıları kodlarımıza
nasıl dahil ettiğimize ve bunları nasıl kullandığımıza odaklanmanızı istiyorum.
Gördüğünüz gibi,tkintermodülünden içe aktardığımızTk(),Label()veButton()gibi sınıfların metot ve niteliklerini, mesela tıpkı karakter
dizilerinin metot ve niteliklerini kullanır gibi kullanıyoruz.

Yukarıdaki örnekte,tkintermodülünün sınıflarını, kodlarımız içine prosedürel
olarak dahil ettik. Yani her sınıfı, belli bir sıraya göre kodlarımız içinde
belirtip, bunları adım adım çalıştırdık. Prosedürel programlamada kodların
yazılış sırası çok önemlidir. Bunu kanıtlamak için çok basit bir örnek verelim:

```python
import tkinter as tk

pencere = tk.Tk()

def çıkış():
 etiket['text'] = 'Elveda zalim dünya...'
 düğme['text'] = 'Bekleyin...'
 düğme['state'] = 'disabled'
 pencere.after(2000, pencere.destroy)

etiket = tk.Label(text='Merhaba Zalim Dünya')
etiket.pack()

düğme = tk.Button(text='Çık', command=çıkış)
düğme.pack()

pencere.protocol('WM_DELETE_WINDOW', çıkış)

pencere.mainloop()

```

Burada her zamanki gibi öncelikle gerekli modülü içe aktardık:

```python
import tkinter as tk

```

Daha sonraTk()sınıfı yardımıyla penceremizi oluşturduk:

```python
pencere = tk.Tk()

```

Ardındançıkış()adlı bir fonksiyon tanımladık:

```python
def çıkış():
 etiket['text'] = 'Elveda zalim dünya...'
 düğme['text'] = 'Bekleyin...'
 düğme['state'] = 'disabled'
 pencere.after(2000, pencere.destroy)

```

Bu fonksiyon, pencere kapatılırken hangi işlemlerin yapılacağını belirliyor.
Buna göre, programdan çıkılırken sırasıyla şu işlemleri gerçekleştiriyoruz:
1. Etiketintextparametresini ‘Elveda zalim dünya…’ olarak değiştiriyoruz.
1. Düğmenintextparametresini ‘Bekleyin…’ olarak değiştiriyoruz.
1. Düğmeninstateparametresini ‘disabled’ olarak değiştirerek düğmeyi basılamaz
hale getiriyoruz.
1. 2000 milisaniye (yani 2 saniye) sonra isepencere.destroy()komutunu
işleterek pencerenin kapanmasını sağlıyoruz.

Etiketintextparametresini ‘Elveda zalim dünya…’ olarak değiştiriyoruz.

Düğmenintextparametresini ‘Bekleyin…’ olarak değiştiriyoruz.

Düğmeninstateparametresini ‘disabled’ olarak değiştirerek düğmeyi basılamaz
hale getiriyoruz.

2000 milisaniye (yani 2 saniye) sonra isepencere.destroy()komutunu
işleterek pencerenin kapanmasını sağlıyoruz.

çıkış()fonksiyonunu tanımladıktan sonraLabel()veButton()düğmeleri aracılığıyla etiket ve düğmelerimizi oluşturuyoruz:

```python
etiket = tk.Label(text='Merhaba Zalim Dünya')
etiket.pack()

düğme = tk.Button(text='Çık', command=çıkış)
düğme.pack()

```

Buna göre, düğmeye basıldığında,commandparametresinin değeri olançıkış()fonksiyonu çalışmaya başlayacak ve fonksiyon gövdesinde
tanımladığımız işlemler gerçekleşecek.

Bildiğiniz gibi, bir program penceresinde, o programı kapatmayı sağlayacak
düğmelerin yanı sıra, bir de en üst sağ (veya sol) köşede program penceresini
kapatan bir ‘X’ düğmesi bulunur. İşte bu ‘X’ düğmesine basıldığında da pencere
kapanmadan önceçıkış()fonksiyonunun çalışması için şu kodu yazıyoruz:

```python
pencere.protocol('WM_DELETE_WINDOW', çıkış)

```

protocol()de tıpkıgeometry()gibi,Tk()sınıfının metotlarından
biridir. Bu metoduWM_DELETE_WINDOWargümanıyla birlikte kullanarak, pencere
üzerindeki ‘X’ düğmesine basıldığında neler olacağını tanımlayabiliyoruz.

Son olarak da ana döngü mekanizmasını çalıştırıyoruz ve penceremizi görünür hale
getiriyoruz:

```python
pencere.mainloop()

```

Bu prosedürel kodları tekrar önümüze alalım:

```python
import tkinter as tk

pencere = tk.Tk()

def çıkış():
 etiket['text'] = 'Elveda zalim dünya...'
 düğme['text'] = 'Bekleyin...'
 düğme['state'] = 'disabled'
 pencere.after(2000, pencere.destroy)

etiket = tk.Label(text='Merhaba Zalim Dünya')
etiket.pack()

düğme = tk.Button(text='Çık', command=çıkış)
düğme.pack()

pencere.protocol('WM_DELETE_WINDOW', çıkış)

pencere.mainloop()

```

En başta da söylediğimiz gibi, bu kodlarda, satır sıraları çok önemlidir. Mesela
burada düğmeyi oluşturan kodlarlapencere.protocol()kodlarının çalışması
için bunların mutlakaçıkış()fonksiyonu tanımlandıktan sonra yazılması
gerekir. Eğer bu kodları şöyle yazarsanız:

```python
import tkinter as tk

pencere = tk.Tk()
pencere.protocol('WM_DELETE_WINDOW', çıkış)

def çıkış():
 etiket['text'] = 'Elveda zalim dünya...'
 düğme['text'] = 'Bekleyin...'
 düğme['state'] = 'disabled'
 pencere.after(2000, pencere.destroy)

etiket = tk.Label(text='Merhaba Zalim Dünya')
etiket.pack()

düğme = tk.Button(text='Çık', command=çıkış)
düğme.pack()

pencere.mainloop()

```

… programınız çalışmayacaktır.

Bu durum, programcıyı, istediği kod düzenini oturtmak konusunda epey kısıtlar.
Ama eğer nesne tabanlı programlama yaklaşımını kullanırsak kod akışını
belirlerken daha özgür olabiliriz. Ayrıca prosedürel yaklaşımda kodlar büyüdükçe
programınızın çorbaya dönme ihtimali nesne tabanlı programlama yaklaşımına göre
daha fazladır. Ancak elbette nesne tabanlı programlama yaklaşımını kullanmak tek
başına düzgün ve düzenli kod yazmanın teminatı değildir. Nesne tabanlı
programlama yaklaşımını kullanarak da gayet sebze çorbası kıvamında kodlar
yazabilirsiniz. En başta da söylediğimiz gibi, nesne tabanlı programlama bir
seçenektir. Eğer istemezseniz, nesne tabanlı programlama yaklaşımını kullanmak
zorunda değilsiniz. Ama elinizde böyle bir imkanınız olduğunu ve başkalarının da
bu yaklaşımdan yoğun bir şekilde faydalandığını bilmek çok önemlidir.

### Sınıflı Bir Örnek

Bir önceki başlıkta Tkinter’i kullanılarak prosedürel bir kod yazdık. Peki acaba
yukarıdaki kodları nesne tabanlı olarak nasıl yazabiliriz?

Dikkatlice bakın:

```python
import tkinter as tk

class Pencere(tk.Tk):
 def __init__(self):
 super().__init__()
 self.protocol('WM_DELETE_WINDOW', self.çıkış)

 self.etiket = tk.Label(text='Merhaba Zalim Dünya')
 self.etiket.pack()

 self.düğme = tk.Button(text='Çık', command=self.çıkış)
 self.düğme.pack()

 def çıkış(self):
 self.etiket['text'] = 'Elveda zalim dünya...'
 self.düğme['text'] = 'Bekleyin...'
 self.düğme['state'] = 'disabled'
 self.after(2000, self.destroy)

pencere = Pencere()
pencere.mainloop()

```

Bu kodlarda gördüğünüz bütün satırları anlayacak kadar nesne tabanlı programlama
bilgisine sahipsiniz. Ama gelin biz yine de bu kodları sizin için tek tek ve
tane tane açıklayalım.

Öncelikletkintermodülünütkadıyla içe aktarıyoruz:

```python
import tkinter as tk

```

Daha sonraPencere()adlı sınıfımızı tanımlamaya başlıyoruz:

```python
class Pencere(tk.Tk):
 ...

```

Burada öncelikleTk()sınıfını miras aldığımıza dikkat edin. Bu sayede bu
sınıfın içindeki bütün nitelik ve metotları kendi uygulamamız içinden
çağırabileceğiz.

Penceremiz oluşur oluşmaz pencere üzerinde bir etiket ile bir düğme olmasını
planlıyoruz. Pencere oluşur oluşmaz işletilecek kodları tanımlamak için bir__init__()metoduna ihtiyacımız olduğunu biliyorsunuz:

```python
class Pencere(tk.Tk):
 def __init__(self):
 ...

```

Ancak kendi__init__()metodumuzu tanımlarken,Tk()sınıfının kendi__init__()metodundaki işlemleri de gölgelemememiz lazım. Dolayısıyla
orijinal__init__()metodunu kendi__init__()metodumuza aktarmak içinsuper()fonksiyonundan yararlanacağız:

```python
class Pencere(tk.Tk):
 def __init__(self):
 super().__init__()

```

Artık taban sınıfın__init__()metodunu kendi tanımladığımız alt sınıfın__init__()metodu içinden özelleştirmeye başlayabiliriz. Öncelikle şu satırı
yazıyoruz:

```python
self.protocol('WM_DELETE_WINDOW', self.çıkış)

```

protocol()metodunun öntanımlı davranışı, pencerenin ‘X’ düğmesine
basıldığında programı sonlandırmaktır. İşte biz bu öntanımlı davranışı
değiştirmek içinprotocol()metodunu içeren kodu tekrar tanımlıyoruz ve
‘X’ düğmesine basıldığındaçıkış()fonksiyonunun çalışmasını sağlıyoruz.

Daha sonra normal bir şekilde etiketimizi ve düğmemizi tanımlıyoruz:

```python
self.etiket = tk.Label(text='Merhaba Zalim Dünya')
self.etiket.pack()

self.düğme = tk.Button(text='Çık', command=self.çıkış)
self.düğme.pack()

```

İki farklı yerde atıfta bulunduğumuzçıkış()fonksiyonumuz ise şöyle:

```python
def çıkış(self):
 self.etiket['text'] = 'Elveda zalim dünya...'
 self.düğme['text'] = 'Bekleyin...'
 self.düğme['state'] = 'disabled'
 self.after(2000, self.destroy)

```

Son olarak da şu kodları yazıp programımızı tamamlıyoruz:

```python
pencere = Pencere()
pencere.mainloop()

```

Elbette zevkler ve renkler tartışılmaz, ancak ben yukarıdaki kodları, prosedürel
kodlara göre çok daha düzgün, düzenli, anlaşılır ve okunaklı bulduğumu, bu
kodlara baktığımda, programı oluşturan parçaların prosedürel kodlara kıyasla
daha yerli yerinde olduğunu düşündüğümü söylemeden de geçmeyeceğim…

Eğer siz aksini düşünüyorsanız sizi prosedürel yolu tercih etmekten alıkoyan
hiçbir şeyin olmadığını da bilin. Ancak tabii ki bu, nesne tabanlı
programlamadan kaçabileceğiniz anlamına da gelmiyor! Unutmayın, bu yaklaşımı siz
kullanmasanız da başkaları kullanıyor.

### Çoklu Miras Alma

Python’da bir sınıf, aynı anda birden fazla sınıfı da miras alabilir. Eğer
yazdığınız bir uygulamada birden fazla taban sınıftan nitelik ve metot miras
almanız gerekirse bunu şu şekilde gerçekleştirebilirsiniz:

```python
class Sınıf(taban_sınıf1, taban_sınıf2):
 pass

```

Bu şekilde hemtaban_sınıf1hem detaban_sınıf2’de bulunan nitelik ve
metotlar aynı andaSınıfadlı sınıfa dahil olacaktır.

Ufak bir örnek verelim. Diyelim ki elimizde şu sınıflar var:

```python
class c1:
 sn1 = 'sn1'

 def __init__(self):
 self.ön1 = 'ön1'
 print(self.ön1)

 def örn_metot1(self):
 self.öm1 = 'öm1'
 return self.öm1

class c2:
 sn2 = 'sn2'

 def __init__(self):
 self.ön2 = 'ön2'
 print(self.ön2)

 def örn_metot2(self):
 self.öm2 = 'öm2'
 return self.öm2

class c3:
 sn3 = 'sn3'

 def __init__(self):
 self.ön3 = 'ön3'
 print(self.ön3)

 def örn_metot3(self):
 self.öm3 = 'öm3'
 return self.öm3

```

Burada üç farklı sınıf ve her bir sınıfın içinde de birer sınıf niteliği, birer__init__()metodu, birer örnek niteliği ve birer örnek metodu görüyoruz.

Şimdi bu üç sınıfı birden taban sınıf olarak miras alan dördüncü bir sınıf
tanımlayalım:

```python
class c4(c1, c2, c3):
 pass

```

Burada, taban sınıf vazifesi görecek sınıfların adınıc4sınıfının
parantezleri arasına tek tek yerleştirdiğimize dikkat edin. Bu şekildec1,c2vec3adlı sınıfları aynı anda miras almış oluyoruz. İşte bu
mekanizmaya Python’da çoklu miras alma (multiple inheritance) adı veriliyor.

Tek bir sınıfı miras aldığınızda hangi kurallar geçerliyse, birden fazla sınıfı
miras aldığınızda da temel olarak aynı kurallar geçerlidir. Ancak çoklu miras
almada birden fazla sınıf söz konusu olduğu için, miras alınan sınıfların da
kendi aralarında veya başka sınıflarla nitelik ve/veya metot alışverişi yapması
halinde ortaya çıkabilecek beklenmedik durumlara karşı dikkatli olmalısınız.
Ayrıca çoklu miras alma işlemi sırasında, aynı adı taşıyan metotlardan yalnızca
birinin miras alınacağını da unutmayın.

Örneğin:

```python
class c1:
 sn1 = 'sn1'

 def __init__(self):
 self.ön1 = 'ön1'
 print(self.ön1)

 def örn_metot1(self):
 self.öm1 = 'öm1'
 return self.öm1

 def ortak_metot(self):
 self.om = 'ortak metot_c1'
 return self.om

class c2:
 sn2 = 'sn2'

 def __init__(self):
 self.ön2 = 'ön2'
 print(self.ön2)

 def örn_metot2(self):
 self.öm2 = 'öm2'
 return self.öm2

 def ortak_metot(self):
 self.om = 'ortak metot_c2'
 return self.om

class c3:
 sn3 = 'sn3'

 def __init__(self):
 self.ön3 = 'ön3'
 print(self.ön3)

 def örn_metot3(self):
 self.öm3 = 'öm3'
 return self.öm3

 def ortak_metot(self):
 self.om = 'ortak metot_c3'
 return self.om

class c4(c1, c2, c3):
 def __init__(self):
 super().__init__()

```

Burada, aynı adı taşıyan__init__()veortak_metot()adlı metotlardan
yalnızca biri miras alınacaktır. Bunlardan hangisinin miras alınacağını az çok
tahmin etmişsinizdir. Evet, doğru bildiniz. Miras alma listesinde hangi sınıf
önde geliyorsa onun metotları miras alınacaktır:

```python
s = c4()
print(s.ortak_metot())

```

Gördüğünüz gibi,c4()sınıfı öncec1sınıfını miras aldığı için hepc1sınıfının metotları öncelik kazanıyor.

Eğer sınıflarıclassc4(c2,c3,c1):şeklinde miras alsaydık, bu kez dec2sınıfının metotları öncelik kazanacaktı.

Elbette, Python’ın sizin için belirlediği öncelik sırası yerine kendi
belirlediğiniz öncelik sırasını da dayatabilirsiniz:

```python
class c4(c1, c2, c3):
 def __init__(self):
 c2.__init__(self)

 def ortak_metot(self):
 return c3.ortak_metot(self)

```

Buradac2sınıfının__init__()metodu ilec3sınıfınınortak_metot’una miras önceliği verdik.

### Dahil Etme

Bir sınıftaki nitelik ve metotları başka bir sınıf içinde kullanmanın tek yolu
ilgili sınıf veya sınıfları miras almak değildir. Hatta bazı durumlarda, miras
alma iyi bir yöntem dahi olmayabilir. Özellikle birden fazla sınıfa ait nitelik
ve metotlara ihtiyaç duyduğumuzda, çoklu miras alma yöntemini kullanmak yerine,
dahil etme (composition) denen yöntemi tercih edebiliriz.

Peki nedir bu dahil etme denen şey? Adından da anlaşılacağı gibi, dahil etme
yönteminde, taban sınıfın nitelik ve metotlarını miras almak yerine, alt sınıf
içine dahil ediyoruz. Esasında biz bunun örneğini görmüştük. Şu kodu
hatırlıyorsunuz:

```python
import tkinter as tk

class Pencere(tk.Tk):
 def __init__(self):
 super().__init__()
 self.protocol('WM_DELETE_WINDOW', self.çıkış)

 self.etiket = tk.Label(text='Merhaba Zalim Dünya')
 self.etiket.pack()

 self.düğme = tk.Button(text='Çık', command=self.çıkış)
 self.düğme.pack()

 def çıkış(self):
 self.etiket['text'] = 'Elveda zalim dünya...'
 self.düğme['text'] = 'Bekleyin...'
 self.düğme['state'] = 'disabled'
 self.after(2000, self.destroy)

pencere = Pencere()
pencere.mainloop()

```

Burada aynı anda hem miras alma hem de dahil etme yönteminden yararlanıyoruz.
İlk önceTk()sınıfını miras aldık. Böylece bu sınıfın nitelik ve
metotlarına doğrudan erişim elde ettik. Etiket ve düğme oluşturmamızı sağlayanLabel()veButton()sınıflarını isePencere()sınıfımız içine dahil
ettik. Böylece bu sınıfların nitelik ve metotlarına sırasıylaself.etiketveself.düğmeadları altında erişim kazandık.

Miras alma ve dahil etme yöntemleri arasında tercih yaparken genel yaklaşımımız
şu olacak: Eğer yazdığımız uygulama, bir başka sınıfın türevi ise, o sınıfı
miras alacağız. Ama eğer bir sınıf, yazdığımız uygulamanın bir parçası ise o
sınıfı uygulamamıza dahil edeceğiz.

Yani mesela yukarıdaki örnekte temel olarak yaptığımız şey bir uygulama
penceresi tasarlamaktır. Dolayısıyla uygulama penceremiz,tk.Tk()sınıfının
doğrudan bir türevidir. O yüzden bu sınıfı miras almayı tercih ediyoruz.

Pencere üzerine etiket ve düğme yerleştirmemizi sağlayanLabel()veButton()sınıfları ise, uygulama penceresinin birer parçasıdır. Dolayısıyla
bu sınıfları uygulamamızın içine dahil ediyoruz.

Yukarıda anlattığımız iki farklı ilişki türü ‘olma ilişkisi’ (is-a
relationship) ve ‘sahiplik ilişkisi’ (has-a relationship) olarak
adlandırılabilir. Olma ilişkisinde, bir sınıf ötekinin türevidir. Sahip olma
ilişkisinde ise bir sınıf öteki sınıfın parçasıdır. Eğer iki sınıf arasında
‘olma ilişkisi’ varsa miras alma yöntemini kullanıyoruz. Ama eğer iki sınıf
arasında ‘sahiplik ilişkisi’ varsa dahil etme yöntemini kullanıyoruz.

Dipnotları:

GNU/Linux dağıtımlarında, dağıtımı geliştiren ekip genellikle
Tkinter paketini Python paketinden ayırdığı için, Tkinter’i ayrıca kurmanız
gerekebilir. Eğer Python’ın etkileşimli kabuğundaimporttkinterkomutunu
verdiğinizde bir hata mesajı alıyorsanızhttps://forum.yazbel.com/adresinden yardım isteyin. Eğer Windows kullanıyorsanız, böyle bir probleminiz
yok. Python’ı kurduğunuz anda Tkinter de emrinize amadedir.

## Nesne Tabanlı Programlama (Devamı)

Nesne tabanlı programlamaya ilişkin bu son bölümde önceki derslerde incelemeye
fırsat bulamadığımız ileri düzey konulardan söz edeceğiz.

### İnşa, İlklendirme ve Sonlandırma

Python’da bir sınıfın ömrü üç aşamadan oluşur:
1. İnşa (Construction)
1. İlklendirme (initialization)
1. Sonlandırma (destruction)

İnşa (Construction)

İlklendirme (initialization)

Sonlandırma (destruction)

Biz bundan önceki derslerimizde ilklendirme sürecinin nasıl yürüdüğünü
görmüştük. Bu dersimizde ise, ilklendirme sürecine de tekrar değinmekle
birlikte, özellikle inşa ve sonlandırma süreçlerini ele alacağız.

Önceki derslerimizden de bildiğimiz gibi, Python’da bir sınıfı ilklendirmek için__init__()adlı bir metottan yararlanıyoruz. Ancak, adının aksine,
ilklendirme, sınıfların oluşturulmasına ilişkin ilk basamak değildir. Python,
bir sınıfın ilklendirilmesinden önce o sınıfı inşa eder. Bu inşa işleminden
sorumlu metodun adı ise__new__()’dur. Gelin bu metodu yakından tanımaya
çalışalım.

#### __new__() Metodu

Bildiğiniz gibi, Python’da basit bir sınıfı şu şekilde tanımlıyoruz:

```python
class Sınıf():
 def __init__(self):
 print('merhaba sınıf!')

```

Burada__init__()metodu, sınıfımız örneklenir örneklenmez hangi işlemlerin
yapılacağını gösteriyor. Yani meselasınıf=Sınıf()gibi bir kod yardımıylaSınıf()adlı sınıfı örneklediğimiz anda ne olacağını bu__init__()metodu içinde tanımlıyoruz:

```python
>>> # Yukarıdaki kodların `sınıf.py` adlı bir dosyada olduğunu varsayalım
>>> import sınıf
>>> snf = sınıf.Sınıf()

merhaba sınıf!

```

Gördüğünüz gibi, tam da__init__()metodunda tanımladığımız şekilde,
sınıfımızı örneklediğimiz anda ekrana ‘merhaba sınıf’ çıktısı verildi.

Ancak yukarıda da belirttiğimiz gibi, bir sınıf örneklendiğinde çalışan ilk
metot aslında__init__()değildir. Python bu süreçte alttan alta__new__()adlı başka bir metodu çalıştırır. Gelin bunu kanıtlayalım:

```python
class Sınıf():
 def __new__(cls):
 pass

 def __init__(self):
 print('merhaba sınıf')

```

Bu sınıfı örneklediğinizde, bir önceki kodların aksine, ekrana ‘merhaba sınıf’
yazısı çıktı olarak verilmeyecektir. İşte bunun sebebi, Python’ın öntanımlı__new__()metodunun üzerine yazıp, o metodun işlevselliğini ortadan
kaldırmış olmanızdır. Eğer__new__()metodunun öntanımlı davranışını taklit
etmek isterseniz yukarıdaki kodları şu şekilde yazmalısınız:

```python
class Sınıf():
 def __new__(cls, *args, **kwargs):
 return object.__new__(cls, *args, **kwargs)

 def __init__(self):
 print('merhaba sınıf')

```

Burada yaptığımız şeyin aslında temel olarak basit bir miras alma işleminden
ibaret olduğunu görüyor olmalısınız. Bildiğiniz gibi, Python’daki bütün
sınıflar, eğer başka bir sınıfı miras olarak almıyorlarsa, otomatik olarakobjectsınıfını miras alırlar. Yani aslında yukarıdaki sınıf tanımını Python
şöyle görür:

```python
class Sınıf(object):
 ...

```

Buradaobjecttaban sınıf olmuş oluyor. Bu taban sınıfın__new__()metodunun sahip olduğu işlevselliğiSınıfadlı alt sınıfa aktarabilmek için
taban sınıfı kendi__new__()metodumuz içinde çağırıyoruz:

```python
class Sınıf():
 def __new__(cls, *args, **kwargs):
 return object.__new__(cls, *args, **kwargs)

```

İşte eğer bir sınıfın inşa edilme sürecinin nasıl işleyeceğini kontrol etmek
isterseniz bu__new__()metodunun üzerine yazarak metodu değişikliğe
uğratabilirsiniz:

```python
class Sınıf():
 def __new__(cls, *args, **kwargs):
 print('Yeni sınıf inşa edilirken lütfen bekleyiniz...')
 return object.__new__(cls, *args, **kwargs)

 def __init__(self):
 print('merhaba sınıf')

```

Ancak bu noktada şunu belirtmeden de geçmeyelim.__new__()metodu, sık sık
muhatap olmanız gereken bir metot değil.__new__()metodunu kullanarak
yapacağınız pek çok şeyi aslında doğrudan__init__()metodu aracılığıyla da
yapabilirsiniz.

## Paketler

> **Uyarı**
> Bu makale yoğun bir şekilde geliştirilmekte, içeriği sık sık
güncellenmektedir.

Uyarı

Bu makale yoğun bir şekilde geliştirilmekte, içeriği sık sık
güncellenmektedir.

Birkaç bölüm önce, Python’ın belkemiği olduğunu söylediğimiz modüller konusundan
söz etmiştik. Bu bölümde de yine modüllerle bağlantılı bir konuyu ele alacağız.
Konumuz Python’daki paketler.

### Paket Nedir?

Öncelikle paketin ne demek olduğunu anlamaya çalışarak başlayalım. Python’da bir
dizin yapısı içinde bir araya getirilen, birbiriyle bağlantılı modüllere paket
adı verilir. Dolayısıyla paketler modüllerden oluşur.

Python programlama dilinde paketler hem geniş bir yer tutar, hem de büyük bir
önem taşır. Hatta Python’ı bilmenin paketleri bilmek demek olduğunu söylersek
çok da abartmış olmayız. Mesela Python’la web programları yazmak için kullanılan
en gözde araçlardan biri olandjangoweb çatısı, aslında birtakım üçüncü şahıs
modüllerinin bir paket yapısı içinde bir araya getirilmiş halinden başka bir şey
değildir. Aynı şekilde Python’la Android ve iOS üzerinde çalışabilecek
programlar yazmak istersenizkivyadlı bir başka Python paketini öğrenmeniz
gerekir. Python programlama dilini kullanarak grafik arayüzlü yazılımlar
geliştirmemizi sağlayantkinterise standart kütüphanede bulunan pek çok
paketten yalnızca bir tanesidir.

Etraftadjango,kivyvetkintergibi pek çok kullanışlı paket
bulabilirsiniz. Mesela standart kütüphanede bulunansqlite3, Sqlite
veritabanları üzerinde çalışmamıza imkan tanıyan çeşitli modülleri içinde
barındıran bir Python paketidir. Yine standart kütüphanede bulunanurllibpaketi yardımıyla internet adresleri (URL’ler) üzerinde çeşitli işlemler
yapabilirsiniz. Python kurulum dizini içindekiLibklasörü altında pek çok
standart Python paketi görebilirsiniz.

Peki modüllerle paketleri birbirinden ayıran şey nedir?

Öncelikle, paketler modüllere kıyasla çok daha kapsamlı bir yapıdır. Zira bir
paket içinde (genellikle) birden fazla modül bulunur. Örneğin standart
kütüphanede bulunan ve tek biros.pydosyasından oluşanosbir modülken,
içinde pek çok farklı modülü barındırancollectionsbir pakettir. Tek bir
dosyadan oluştuğu ve bir dizin yapısı içinde yer almadığı için bir modülden içe
aktarma işlemi gerçekleştirmek son derece kolaydır. Paketlerden içe aktarma
yaparken uymamız gereken kurallar ise haliyle biraz daha karmaşıktır.

İkincisi, bütün paketler aynı zamanda birer modüldür, ancak bütün modüller birer
paket değildir. Örneğinvenvpaketinden bahsederken ‘venvmodülü’ demek
yanlış olmaz. Ancakosmodülünden bahsederken ‘ospaketi’ demek biraz abes
kaçacaktır.

Üçüncüsü, paketlerin__path__adlı özel bir niteliği bulunur. Modüllerde ise
bu nitelik bulunmaz. Örneğin:

```python
>>> import os
>>> os.__path__

AttributeError: 'module' object has no attribute '__path__'

```

osbir modül olduğu için,__path__niteliğine sahip değildir. Bir dejsonpaketine bakalım:

```python
>>> import json
>>> json.__path__

```

jsonise bir paket olduğu için,__path__niteliğine sahiptir. Birazdan
bu niteliğin ne işe yaradığını anlatacağız. Ama ondan önce öğrenmeniz gereken
başka şeyler var.

### Paket Türleri

Tıpkı fonksiyonlarda ve modüllerde olduğu gibi, paketlerin de türleri vardır.
Paketleri, kaynaklarına göre ikiye ayırabiliriz:
- Standart Paketler
- Üçüncü Şahıs Paketleri

Standart Paketler

Üçüncü Şahıs Paketleri

Bu türlerin ne anlama geldiğini isimlerine bakarak rahatlıkla anlayabiliyoruz.
Ama gelin isterseniz bunları kısaca gözden geçirelim.

Öncelikle standart paketlerden başlayalım.

#### Standart Paketler

Standart paketler, Python’ın standart kütüphanesinde bulunan paketlerdir. Tıpkı
gömülü fonksiyonlar ve standart modüller gibi, standart paketler de dilin bir
parçası olduklarından, bunlara erişebilmek için herhangi bir ek yazılım indirip
kurmamıza gerek kalmaz; bu paketler her an emrimize amadedir. Standart paketlere
Python kurulum dizini içindekiLibklasöründen erişebilirsiniz. Bir standart
paketin tam olarak hangi konumda bulunduğunu öğrenmek için ise ilgili paketin__path__niteliğini sorgulayabilirsiniz:

```python
>>> import urllib
>>> urllib.__path__

```

Eğer sorguladığınız şeyin bir__path__niteliği yoksa, paket sandığınız o
şey, aslında bir paket değildir. Örneğin:

```python
>>> import subprocess
>>> subprocess.__path__

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute '__path__'

```

Çünkü, bildiğiniz gibi, paketlerin aksine, modüllerin__path__adlı bir
niteliği bulunmaz.subprocessde bir paket değil, modül olduğu için__path__sorgusu hata verecektir.

Bir paketin__path__niteliğini sorguladığınızda çıktıda hangi dizini
görüyorsanız, o paketin bilgisayardaki konumu odur. Mesela yukarıda adını
andığımızurllibpaketinin__path__niteliğini sorgulayıp, karşımıza çıkan
klasöre gidelim. Paket dizininin içini açtığımızda karşımıza şu dosyalar
çıkacak:

```python
error.py
parse.py
request.py
response.py
robotparser.py
__init__.py

```

Daha önce de dediğimiz gibi, paketler modüllerden oluşur. İşteurllibpaketi
de yukarıda ismini gördüğümüz modüllerin birleşiminden oluşuyor. Python kurulum
dizini içindekiLibklasörü altında yer alan paketleri inceleyerek, hangi
paketin hangi modüllerden oluştuğunu kendiniz de görebilirsiniz.

#### Üçüncü Şahıs Paketleri

Python’da standart paketlerin dışında bir de üçüncü şahıs paketleri vardır.
Bunlar Python geliştiricileri haricindeki kişilerce yazılıp kullanımımıza
sunulmuş araçlardır. Bu paketler, standart paketlerin aksine dilin bir parçası
olmadığından, bu paketleri kullanabilmek için öncelikle bunları bilgisayarımıza
kurmamız gerekir. Meseladjango,kivyve ilk derslerimizden birinde
bahsettiğimizcx_freezebirer üçüncü şahıs paketidir.

Peki bu üçüncü şahıs paketlerini nereden bulabiliriz?

Hatırlarsanız Modüller konusunu işlerken ‘Üçüncü Şahıs Modüllerinden’ de söz
etmiştik. Üçüncü şahıs modüllerini bulabileceğimiz başlıca kaynağınhttps://pypi.orgadresi olduğunu ve buradan 60.000’in üzerinde
üçüncü şahıs Python modülüne ulaşabileceğimizi de ifade etmiştik. İşte orada
bahsettiğimiz üçüncü şahıs modülleri, aslında birer pakettir. Zira üçüncü şahıs
modülleri çoğunlukla birer paket biçiminde sunulur. Dolayısıyla üçüncü şahıs
modüllerine nereden ve nasıl ulaşıyorsak, üçüncü şahıs paketlerine de aynı
yerden ve aynı şekilde ulaşabiliriz. Ayrıca bir üçüncü şahıs paketini kurmadan
önce, ilgili paketin yardım dosyalarını veya websitesini incelemekte de fayda
var. Çünkü bazı üçüncü şahıs modüllerini kurabilmek için birtakım özel
gereksinimleri yerine getirmeniz gerekiyor olabilir. Bu tür bilgilere de ancak
ilgili paketi geliştiren kişi veya ekibin websitesinden ulaşabilirsiniz.

Bir üçüncü şahıs paketininhttps://pypi.orgadresindeki adını
öğrendikten sonra, bu paketi şu komutla kurabilirsiniz:

```python
pip3 install paket_adı

```

MeselarestructuredTextbiçimli metin dosyalarından şık ve kullanışlı
belgeler üretmemizi sağlayansphinxpaketi PyPI sitesinde bulunuyor.
Dolayısıyla bu paketi kurmak için şu komutu verebiliriz:

```python
pip3 install sphinx

```

Elbette, eğer bir GNU/Linux dağıtımı kullanıyorsanız, bu komutu root haklarıyla
çalıştırmanız gerektiğini söylememe herhalde gerek yok:

```python
sudo pip3 install sphinx

```

pip3adlı yazılım,sphinxpaketinin bütün dosyalarını PyPI sitesinden çekip
otomatik olarak bilgisayarımıza kuracaktır.

Bir üçüncü şahıs paketinipip3komutuyla kurmak yerine elle kurmayı da
tercih edebilirsiniz. Örnek olarak bu defadjangopaketini alalım. Bu paketin
en son sürümünühttps://pypi.org/project/Django/#filesadresinden indirebilirsiniz. Ayrıca arzu edersenizhttps://www.djangoproject.comadresine uğrayarak bu modülün resmi websitesine de gözatabilirsiniz.

İndirdiğiniztar.gzuzantılı sıkıştırılmış dosyayı açtığınızda karşısınıza pek
çok dizin ve bu dizinlerin içinde de pek çok Python dosyası çıkacak. Django,
geniş kapsamlı üçüncü şahıs paketlerine güzel bir örnektir.

Django paketini açıpdjango-masteradlı dizinin içine girdiğinizde, oradasetup.pyadlı bir dosya göreceksiniz. İştepip3komutu yerine, bu dosyayı
kullanarak da bu paketi bilgisayarımıza kurabiliriz.

Dikkatlice bakın:

```python
python3 setup.py install

```

Bu komutta iki önemli unsur var. Birincisi, komutu çalıştırdığımız Python
sürümü. Unutmayın, bir Python paketini hangi Python sürümü ile kurarsanız, o
paketi o sürüm ile kullanabilirsiniz. Ben yukarıdaki komutta, sizin Python
sürümünüzü başlatan komutunpython3olduğunu varsaydım. Eğer siz Python’ı
başlatmak için veya başka Python programlarını çalıştırmak için farklı bir komut
kullanıyorsanız,setup.pydosyasını da o komutla çalıştıracaksınız. Neticedesetup.pyde sıradan bir Python programıdır. Bu programıinstallparametresi
ile birlikte çalıştırarak Django paketini sisteminize kurmuş oluyorsunuz.
Kurulum tamamlandıktan sonra, kurulumun başarılı olup olmadığını test etmek için
Python komut satırında şu komutu verin:

```python
>>> import django

```

Eğer herhangi bir çıktı verilmeden alt satıra geçildiyse, bir üçüncü şahıs
paketi olandjango’yu bilgisayarınıza başarıyla kurmuşsunuz demektir. Bu
üçüncü şahıs modülünü nasıl kullanacağınızı öğrenmek için internet üzerindeki
sayısız makaleden ve kitaptan yararlanabilirsiniz.

### Paketlerin İçe Aktarılması

Modüllerle paketler arasındaki önemli bir fark, paketlerin modüllere kıyasla
daha karmaşık bir yapıda olmasıdır. Yalnızca tek bir dosyadan oluşan modüllerin
bu basit yapısından ötürü, bir modülden nitelik veya metot içe aktarmak çok
kolaydır. Mesela bir modül olanos’u şu şekilde içe aktarabiliriz:

```python
>>> import os

```

Eğerosmodülündennameniteliğini almak istersek şu komutu kullanabiliriz:

```python
>>> from os import name

```

osmodülü içindeki bütün nitelik ve metotları içe aktarmak istediğimizde
yıldızlı içe aktarma yönteminden yararlanabiliriz:

```python
>>> from os import *

```

Veya bu modül içindeki bir niteliği veya metodu başka bir isim altında da içe
aktarabiliriz:

```python
>>> from os import execv as exe

```

Gelelim paketlere…

#### import paket

Meselaurllibpaketini ele alalım. Tıpkıosmodülünde yaptığımız gibi,urllibpaketini de şu şekilde içe aktarabiliriz:

```python
>>> import urllib

```

Ancakosmodülünün aksine,urllibpaketini içe aktardığımızda mevcut isim
alanına herhangi bir nitelik veya metot otomatik olarak aktarılmaz. Örneğinosmodülünü içe aktardığımızda bu modülün içeriğinin,osöneki altında mevcut
isim alanına döküldüğünü biliyoruz:

```python
>>> dir(os)

```

Gördüğünüz gibi, modül içeriği kullanılabilir durumda. Listedeki nitelik ve
metotlaraosöneki ile erişebiliriz:

```python
>>> os.name
>>> os.listdir(os.getcwd())

```

gibi…

Ancakimportoskomutunun aksine,importurllibkomutu, paket içeriğini
otomatik olarak mevcut isim alanına aktarmaz:

```python
>>> import urllib
>>> dir(urllib)

['__builtins__', '__cached__', '__doc__', '__file__',
 '__loader__', '__name__', '__package__', '__path__',
 '__spec__']

```

Gördüğünüz gibi listede yalnızca standart metot ve nitelikler var. Bu listede
mesela paket içeriğinde olduğunu bildiğimizerror.py,parse.py,request.py,response.pyverobotparser.pygibi modülleri göremiyoruz. Eğer
paket içinde bulunan belirli bir modülü içe aktarmak istiyorsak bunu açık açık
belirtmeliyiz. Nasıl mı? Görelim…

#### import paket.modül

Meselaurllibpaketindenrequestmodülünü içe aktarmak
istersek şu komutu yazacağız:

```python
>>> import urllib.request

```

Bu modülü yukarıdaki şekilde içe aktardığımızda, modül içindeki nitelik ve
metotlaraurllib.requestönekiyle erişebiliriz:

```python
>>> urllib.request.urlopen('https://yazbel.com/')

```

#### from paket import modül

Yukarıda olduğu gibi,urllibpaketi içindekirequestmodülünüimportpaket.modülgibi bir komutla içe aktardığımızda ilgili modülün bütün nitelik
ve metotlarıurllib.requestismi altında içe aktarıldığından,urllibpaketi
içindekirequestmodülünün nitelik ve metotlarına ulaşabilmek için her
defasındaurllib.requestönekini kullanmamız gerekir. Eğer her defasında uzun
uzunurllib.requestyazmak istemiyorsanız paket içindeki modülü şu şekilde içe
aktarabilirsiniz:

```python
>>> from urllib import request

```

Böylecerequestmodülünün nitelik ve metotlarına yalnızcarequestönekiyle
erişebilirsiniz:

```python
>>> request.urlopen('https://yazbel.com/')

```

#### from paket.modül import nitelik_veya_metot

Peki bir paket içinde yer alan herhangi bir modül içindeki nitelik ve metotlara
öneksiz olarak erişmek istersek ne yapacağız? Python bize bu isteğimizi yerine
getirmemizi sağlayacak bir yol da sunar.

Dikkatlice bakın:

```python
from urllib.request import urlopen

```

Bu şekildeurllibpaketi içindekirequestmodülündenurlopenadlı metodu
doğrudan içe aktarmış olduk. Dolayısıyla bu metodu dümdüz kullanabiliriz:

```python
>>> urlopen('https://yazbel.com/')

```

Ancak, modüller konusunu işlerken öneksiz aktarmaya ilişkin söylediklerimizin
paketler için de geçerli olduğunu aklımızdan çıkarmıyoruz.

#### from paket.modül import *

Eğer bir paket içindeki bir modülün bütün nitelik ve metotlarını mevcut isim
alanına olduğu gibi aktarmak isterseniz şu içe aktarma yöntemini
kullanabilirsiniz:

```python
>>> from paket.modül import *

```

Bu bilgiyiurllibmodülüne uygulayalım:

```python
>>> from urllib.request import *

```

Bu şekildeurllibpaketi içindekirequestmodülünün bütün nitelik ve
metotlarını doğrudan mevcut isim alanına aktarmış olduk. Bu yöntemin büyük bir
rahatlık sunmakla birlikte önemli dezavantajlara da sahip olduğunu gayet iyi
bildiğinizden eminim.

### Kendi Oluşturduğumuz Paketler

Buraya kadar hep başkalarının yazdığı, hazır paketlerden söz ettik. Bu sayede
bir Python paketinin yapı olarak neye benzediğini ve nasıl kullanılacağını
kabataslak da olsa anlamış olduk. Elbette biz sadece başkalarının yazdığı
paketleri kullanmayacağız. Bir de bizim kendi yazdığımız Python paketleri
olacak.

Kendi oluşturduğumuz paketler, adı üzerinde, kendi kendimize yazıp meydana
getirdiğimiz paketlerdir. Bu paketleri iyice geliştirdikten ve başkaları için de
yararlı olabilecek hale getirdikten sonra, istersekhttps://pypi.orgadresindeki üçüncü şahıs paket deposuna yükleyebiliriz. Böylece kendi
geliştirdiğimiz paketler de, üçüncü şahıs Python paketleri arasına girmiş
olur…

İşte bu bölümde, bu tür paketleri nasıl yazacağımızı ele alacağız.

#### Paket Oluşturmak

Bir Python programı yazdığınızı düşünün. Programınızı ilk yazmaya başlarken
doğal olarak programınız tek bir dosyadan oluşacaktır. Ancak elbette programınız
büyüdükçe, bütün kodları tek bir dosyaya sıkıştırmak yerine, farklı işlevleri
farklı dosyalar içinde tanımlamanın daha mantıklı olduğunu farkedeceksiniz.
Mesela programın grafik arayüz kısmını bir dosyada tanımlarken, düğmelere,
menülere bağlayacağınız işlevleri bir başka dosyada tanımlamak isteyebilirsiniz.
Programınızın gerçekleştirdiği işlemleri küçük, mantıklı birimlere bölüp bunları
farklı modüllere taşımanız, programınızı çok daha rahat bir şekilde idare
etmenizi sağlayacaktır. Yani, yazdığınız programı birkaç modüle bölüp, bunları
bir paket yapısı içinde sunmanız hem kendiniz açısından, hem de kodlarınızı
okuyan başkaları açısından işleri epey kolaylaştıracaktır.

Python’da bir paket oluşturmak son derece kolaydır. Program kodlarını içeren.pydosyasını bir klasör içine koyduğunuz anda, o klasörün adını taşıyan bir
paket meydana getirmiş olursunuz.

Mesela bir sipariş takip programı yazdığımızı düşünelim. Ana klasörümüzün adınısiparistakipkoyalım. Bu klasör içinde dekomut.py,veritabani.pyvesiparis.pyadlı modüller olsun. Yani şöyle bir dosya-dizin yapısı
oluşturalım:

```python
+ siparistakip
|__ siparis.py
|__ komut.py
|__ veritabani.py

```

İşte bu şekilde basit bir dosya-dizin yapısı oluşturduğumuzda,siparistakipadlı bir Python paketi meydana getirmiş oluyoruz[1].

Gelin isterseniz,siparistakipdizininin gerçekten bir paket olduğunu teyit
edelim.

Öncelikle paketimizi içe aktaralım. Bunun içinsiparistakipdizininin
bulunduğu klasörde şu komutu verelim:

```python
>>> import siparistakip

```

Şimdi paket içeriğini kontrol edelim:

```python
>>> dir(siparistakip)

['__doc__', '__loader__', '__name__',
 '__package__', '__path__', '__spec__']

```

Gördüğünüz gibi, listede__path__adlı bir nitelik var. Bu niteliğin yalnızca
paketlerde bulunduğunu biliyorsunuz. Demek kisiparistakipgerçekten de bir
Python paketiymiş. Bunun dışında, listede gördüğünüz__package__niteliğini
kullanarak da bir modülün paket olup olmadığını kontrol edebilirsiniz:

```python
>>> siparistakip.__package__

'siparistakip'

```

Eğer test ettiğimiz modül bir paketse,__package__niteliği bize bir paket adı
verecektir. Yok eğer test ettiğimiz modül bir paket değil de alelade bir
modülse,__package__niteliği boş bir karakter dizisi döndürecektir. Meselaosmodülünün bir paket olmadığını biliyoruz:

```python
>>> import os
>>> os.__package__

''

```

Gördüğünüz gibi, bu modülün__package__niteliği boş bir karakter dizisi.
Ayrıca bu modül bir paket olmadığı için,__path__adlı bir nitelik de
barındırmıyor:

```python
>>> os.__path__

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute '__path__'

```

Dolayısıyla bütün işaretler, gerçekten desiparistakipadlı bir paket
oluşturduğumuzu gösteriyor…

#### İçe Aktarma İşlemleri

Standart paketleri anlatırken, bu paketlerin her konumdan içe aktarılabileceğini
söylemiştik. Aynı şey üçüncü şahıs paketleri için de geçerlidir. Çünkü gerek
Python geliştiricileri, gerekse üçüncü şahıs paketleri geliştirenler, bu
paketleri bize sunarken bunları Python’ınsys.pathçıktısına eklemişlerdir. O
yüzden standart ve üçüncü şahıs paketlerini içe aktarırken sorun yaşamayız.

Ancak tabii ki kendi yazdığımız paketlersys.pathlistesine ekli olmadığı
için, bunları içe aktarırken bazı noktalara dikkat etmeniz gerekir.

Mesela masaüstünde şu yapıya sahip bir paket oluşturalım:

```python
+ paket
|__ modul1.py
|__ modul2.py
|__ modul3.py
 + altdizin
 |__altmodul1.py
 |__altmodul2.py

```

Bu dizinde dosya içerikleri şöyle olsun:

modul1.py:

```python
isim1 = 'modul1'
print(isim1)

```

modul2.py:

```python
isim2 = 'modul2'
print(isim2)

```

modul3.py:

```python
isim3 = 'modul3'
print(isim3)

```

altmodul1.py:

```python
altisim1 = 'altmodul1'
print(altisim1)

```

altmodul2.py:

```python
altisim2 = 'altmodul2'
print(altisim2)

```

Şimdipaketadlı dizinin bulunduğu klasörde bir etkileşimli kabuk oturumu
açalım. Yalnız bu oturumupaketdizinin içinde değil, bir üst dizinde
açacaksınız. Yani o anda bulunduğunuz dizindedirveyalskomutu
verdiğinizdepaketadlı dizini görüyor olmanız lazım… Eğerdirveyalskomutunun çıktısındaaltdizinadlı dizini görüyorsanız yanlış yerdesiniz
demektir. Hemen bir üst dizine gidin.

Bulunduğumuz konumda şu komutu verelim:

```python
>>> import paket

```

Eğer hiçbir çıktı almadan bir alt satıra geçtiyseniz her şey yolunda demektir.
Eğer bir hata mesajı görüyorsanız, etkileşimli kabuk oturumunu yanlış konumda
açmışsınızdır. Oturumu doğru konumda açıp tekrar gelin…

Standart paketlerde ve üçüncü şahıs paketlerinde gördüğümüz gibi, bir paketi
yukarıdaki şekilde içe aktardığımızda, o pakete ait herhangi bir modül veya
nitelik otomatik olarak içe aktarılmıyor.dir(paket)komutu verdiğinizde
yalnızca standart niteliklerin içe aktarıldığını göreceksiniz:

```python
>>> dir(paket)

['__doc__', '__loader__', '__name__',
 '__package__', '__path__', '__spec__']

```

Gördüğünüz gibi, oluşturduğumuz paket, bir Python paketinin sahip olması gereken
bütün niteliklere sahip.

Şimdi bu paket içindekimodul1adlı modülü içe aktaralım:

```python
>>> from paket import modul1

modul1

```

Böylecemodul1adlı modülün içindeki değişkenin değerini almış olduk. Paket
içindeki öteki modülleri de aynı şekilde içe aktarabilirsiniz:

```python
>>> from paket import modul2

modul2

>>> from paket import modul3

modul3

```

Peki ya meselamodul1içindekiisim1değişkenini almak istersek ne
yapacağız?

Dikkatlice bakın:

```python
>>> from paket.modul1 import isim1

modul1

```

Gördüğünüz gibi,paketiçindekimodul1modülününisim1niteliğini
başarıyla aldık. Örnek olması açısından ötekileri de alalım:

```python
>>> from paket.modul2 import isim2

modul2

>>> from paket.modul3 import isim3

modul3

```

Buradaki temel mantığı kavradığınızı zannediyorum. Standart modülleri incelerken
bahsettiğimiz içe aktarma yöntemlerini tek tek yukarıdaki yapıya uygulayarak,
buraya kadar anlattıklarımızı anlayıp anlamadığınızı test edebilirsiniz.
Dilerseniz pratik yapmak açısından bir dealtdiziniçindeki modüllere
uzanalım.

Önceliklealtdizin’i içe aktaralım:

```python
>>> import paket.altdizin

```

Bu şekildepaketadlı paketinaltdizinadlı alt dizinini içe aktarmış olduk.
Artık bu alt dizin içindeki modüllere ve onların niteliklerine erişebiliriz.
Meselapaketadlı paketinaltdizinadlı alt dizini içindekialtmodul1adlı
modülünaltisim1niteliğini alalım:

```python
>>> paket.altdizin.altmodul1.altisim1

'altmodul1'

```

Gördüğünüz gibi,altisim1niteliğine erişmek için uzun bir yol gitmemiz
gerekiyor. Bu yolu kısaltmak isterseniz modülü şu şekilde içe aktarabilirsiniz:

```python
>>> from paket.altdizin import altmodul1

```

Artıkaltmodul1’in niteliklerine yalnızcaaltmodul1önekiyle
ulaşabilirsiniz:

```python
>>> altmodul1.altisim1

'altmodul1'

```

Hatta doğrudanaltisim1niteliğinin kendisini de alabilirsiniz:

```python
>>> from paket.altdizin.altmodul1 import altisim1
>>> altisim1

'altmodul1'

```

Gördüğünüz gibi, Python’ın içe aktarma mantığı gayet basit. Bulunduğunuz
konumdan itibaren, alt dizin ve modül adlarını sırasıyla kullanarak ve bunları
birbiriyle nokta işareti ile birleştirerek her bir modüle ve modül içindeki
niteliğe erişebiliyoruz.

#### İçe Aktarma Mantığı

Yukarıdaki örneklerden gördüğünüz gibi, Python’ın içe aktarma mekanizması gayet
basit bir şekilde işliyor. Ancak yine de bu durum sizin rehavete kapılmanıza yol
açmasın. Zira kimi zaman bu mekanizma hiç beklemediğiniz durumların ortaya
çıkmasına da yol açabilir.

Python’da paketler üzerinde çalışırken, Python programlama dilinin paketleri içe
aktarma mekanizmasını çok iyi anlamış olmalısınız. Eğer bu mekanizmayı hakkıyla
anlamadan paket yapmaya kalkışırsanız, Python’ın içe aktarma sırasında
verebileceği sürpriz hatalar size saç baş yoldurabilir. İşte bu bölümde
Python’ın paket içe aktarma mantığı üzerine eğilerek, engebeli yüzeyleri nasıl
aşabileceğimizi anlamaya çalışacağız.

##### İçe Aktarma İşleminin Konumu

Python’da herhangi bir içe aktarma işlemi yapacağımız zaman, unutmamamız gereken
en önemli konu, Python’ın bütün içe aktarma işlemlerini tek bir konumdan
gerçekleştirdiği gerçeğidir. Bunun ne demek olduğunu anlamak için çok basit bir
örnek verelim.

Yukarıda şöyle bir paket yapısı oluşturmuştuk:

```python
+ paket
|__ modul1.py
|__ modul2.py
|__ modul3.py
 + altdizin
 |__altmodul1.py
 |__altmodul2.py

```

Buradaaltmodul2.pydosyasının içine şunu yazalım:

```python
import altmodul1

```

Yani bu dosya ile aynı dizinde bulunanaltmodul1.pydosyasını,altmodul2.pydosyası içinden bir modül olarak içe aktaralım.

Şimdi, daha önce yaptığımız gibi,paketadlı dizinin bulunduğu klasörde bir
etkileşimli kabuk oturumu açalım ve şu komutu yazalım:

```python
>>> from paket.altdizin import altmodul2

```

Bu komut bize şöyle bir hata mesajı verecek:

```python
ImportError: No module named 'altmodul1'

```

Bu hatanın sebebi, Python’ınaltmodul1adlı modülü bulamıyor olmasıdır.
Halbuki bu modül,altmodul2ile aynı dizinde bulunuyor. O halde acaba Python
bu modülü neden bulamıyor?

Bunu anlamak için şöyle bir deneme yapalım:

Şimdialtmodul1.pyvealtmodul2.pydosyalarının bulunduğu konumda bir
etkileşimli kabuk oturumu başlatın ve şu komutu verin:

```python
>>> import altmodul2

```

Gördüğünüz gibi, bu defa Python herhangi bir hata mesajı vermeden,impportaltmodul1komutuylaaltmodul2.pydosyası içinden çağırdığımızaltmodul1modülünün içeriğini alabildi. Peki ama neden?

Başta da söylediğimiz gibi, Python bütün aktarma işlemlerini tek bir konumdan
yapar. Yani eğer siz bir modülü üst dizinden içe aktardıysanız, o üst dizinin
adı paket içindeki bütün aktarmalara önek olarak eklenecektir. Dolayısıylapaketadlı dizinin bulunduğu konumdanaltdiziniçindekialtmodul2.pydosyasını çağırdığınızda,altmodul2.pyiçindekiimportaltmodul1komutu,altmodul1.pydosyasını bulamayacaktır. Ama sizaltmodul2.pydosyasını kendi
dizini içinden çağırdığınızda,importaltmodul1komutu, aynı dizin içindekialtmodul1.pydosyasını bulabilecektir.

Bu okuduklarınız ilk bakışta size çok karmaşıkmış gibi gelebilir, ama aslında
biraz dikkat ederseniz bu sistemin hiç de öyle karmaşık olmadığını, aksine son
derece mantıklı olduğunu göreceksiniz.

Durumu daha da netleştirmek için şöyle bir şey yapalım:

altmodul2.pydosyasını açıp,importaltmodul1komutunu şöyle yazalım:

```python
from paket.altdizin import altmodul1

```

Bu değişikliği kaydettikten sonra tekrarpaketdizininin bulunduğu konumda bir
oturum açıp şu komutu verelim:

```python
>>> from paket.altdizin import altmodul2

```

İşte bu kez komutumuz başarıyla çalıştı vealtmodul1modülünü bulabildi…

Şimdi dealtmodul1.pyvealtmodul2.pydosyalarının bulunduğu konuma tekrar
dönüp burada yine bir etkileşimli kabuk oturumu başlatalım ve daha önce
verdiğimiz şu komutu tekrar verelim:

```python
>>> import altmodul2

```

O da ne! Geçen sefer hatasız çalışan kod bu defa hata verdi:

```python
ImportError: No module named 'paket'

```

Gördüğünüz gibi, modülü içe aktardığımız konumdan ötürü Python bu kez depaketadlı paketi bulamıyor.

Birazdan bütün bu sorunların kesin çözümünü vereceğiz. Ama ondan önce başka bir
konudan söz edelim.

##### Bağıl İçe Aktarma

Dediğimiz gibi, bir içe aktarma işleminin başarılı olabilmesi, o içe aktarma
işleminin yapıldığı konumun neresi olduğuna ve paket içinde bulunan öteki
modüllerdeki içe aktarmaların nasıl yazıldığına bağlıdır. Yani mesela normalde
aynı konumda bulunan iki modül birbirini yalnızcaimportmodül_adıgibi bir
komutla içe aktarabilecekken, eğer bu modüller üst dizinin bulunduğu konumdan
çağrılıyorsa, içe aktarma başarısız olabilir. Bunun bir örneğini yukarıda
görmüştük.altdiziniçinde bulunanaltmodul1.pydosyasını, aynı dizindekialtmodul2.pydosyasından içe aktarmak içinaltmodul2.pydosyasınaimportaltmodul1yazdığımızda, anapaketdizininin bulunduğu konumdanaltdiziniçindekialtmodul2.pydosyasınıfrompaket.altdizinimportaltmodul2gibi
bir komut ile içe aktarma girişimimiz başarısızlığa uğruyordu. Python’ın ilgili
modülü bulabilmesini sağlamak için,altmodul2.pydosyasınaimportaltmodul1yazmak yerinefrompaket.altdizinimportaltmodul1yazmıştık.
İşte aynı şeyi ‘bağıl içe aktarma’ (relative import) denen bir mekanizma
yardımıyla da gerçekleştirebiliriz.

Bu mekanizmada içe aktarma işlemi, içe aktaran modülün bulunduğu konuma göre
gerçekleşir. Bir örnek verelim…

altmodul2.pydosyasınaimportaltmodul1veyafrompaket.altdizinimportaltmodul1yerine şunu yazalım:

```python
from . import altmodul1

```

Buradafromkelimesinden sonra gelen nokta (.), içe aktaran modülle aynı
dizine atıfta bulunuyor. Yani bu şekildealtmodul2.py’nin bulunduğu dizine
atıfta bulunmuş, böylece bu dizinde bulunanaltmodul1adlı modülü içe
aktarabilmiş olduk.paketdizininden, hattaaltdizindizininden yapılacak
içe aktarma işlemleri bu komut sayesinde başarılı olacaktır.

Dediğimiz gibi, orada.işareti, içe aktaran modülle aynı dizini temsil
ediyor. Eğer oraya yan yana iki nokta (..) koyacak olursanız, bir üst dizine
atıfta bulunabilirsiniz. Mesela bir üst dizinde bulunanmodul3.pydosyasınıaltmodul2.pyveyaaltmodul1.pydosyasından içe aktarmak isterseniz, bu
dosyaların herhangi birine şu kodu yazabilirsiniz:

```python
from .. import modul3

```

Üç nokta yan yana koyduğunuzda ise (…) iki üst dizine atıfta bulunmuş
olursunuz. Ancak bu şekilde paketin dışına çıkamayacağınızı da unutmayın. Yani
meselapaketdizininin bulunduğu konuma göre bir üst dizinde bulunan, yani
paket dışındakifalanca.pyadlı bir modülü şu şekilde içe aktaramazsınız:

```python
from ... import falanca

```

Ama tabii eğer paketinizin dizin yapısı iki üst dizine çıkılmasına müsaade
ediyorsa yukarıdaki komut çalışacaktır. Yani elinizdeki, aşağıdakine benzer
yapıda bir pakette:

```python
+ paket
|__ modul1.py
|__ modul2.py
|__ modul3.py
 + altdizin
 |__altmodul1.py
 |__altmodul2.py
 + altaltdizin
 |__altaltmodul1.py
 |__altaltmodul2.py

```

altaltmodul1.pydosyasının bulunduğu konumdan itibaren iki üst dizine çıkarakmodul2.pydosyasını içe aktarabilirsiniz:

```python
from ... import modul2

```

Yukarıda gösterdiğimiz bağıl içe aktarma mekanizması, paket adı belirtmeden içe
aktarma işlemi gerçekleştirmenizi sağlar. Yani bu mekanizma sayesindefrompaketadi.modulimportaltmodulyerinefrom.importmodulgibi bir kod
yazarak, aynı dizin içinde veya üst dizinlerde bulunan modüllere atıfta
bulunabilirsiniz.

#### Paketlerin Yola Eklenmesi

Daha önce de birkaç kez vurguladığımız gibi, içe aktarma işlemlerinde Python
aradığımız modülü veya paketi bulabilmek içinsys.pathadlı listede görünen
dizinlerin içine bakar. Eğer içe aktarmak istediğiniz paket dizini bu listede
değilse, o paketi içe aktarabilmek için, komut satırını o dizinin bulunduğu
klasörde açmanız gerekir. Yani standart paketler ve üçüncü şahıs paketlerin
aksine,sys.path’e eklenmemiş bir paketi her yerden içe aktaramazsınız.

Peki bir paketisys.pathlistesine nasıl ekleyeceğiz?

Aslında bu sorunun cevabı çok basit. Bildiğiniz gibi,sys.pathaslında basit
bir listeden ibarettir. Dolayısıyla listeler üzerinde nasıl değişiklik
yapıyorsanız,sys.pathüzerinde de o şekilde değişiklik yapacaksınız.

Gelin isterseniz, yukarıda oluşturduğumuzpaketadlı paket üzerinden bir
uygulama yapalım.

Python’da bir paketisys.pathlistesine eklerken dikkat etmemiz gereken çok
önemli bir konu var: Bir paketisys.pathlistesine eklerken, paket adına
karşılık gelen dizini değil, paketi içeren dizini bu listeye eklemeliyiz. Yani
meselapaketadlı dizin masaüstündeyse, bizim listeye masaüstünün olduğu
dizini eklememiz gerekiyor, paketin olduğu dizini değil…

Dikkatlice bakın:

```python
>>> import os, sys
>>> kullanıcı = os.environ['HOME'] #Windows'ta os.environ['HOMEPATH']
>>> masaüstü = os.path.join(kullanıcı, 'Desktop')
>>> sys.path.append(masaüstü)

```

Böylece masaüstünün bulunduğu dizinisys.path’e eklemiş olduk. Burada
uyguladığımız adımlara şöyle bir bakalım.

Öncelikle gerekli modülleri içe aktardık:

```python
>>> import os, sys

```

Amacımız masaüstünün yolunusys.path’e eklemek. Dolayısıyla öncelikle
kullanıcı dizininin nerede olduğunu tespit etmemiz lazım. Bildiğiniz gibi,
kullanıcı dizinleri, bilgisayarı kuran kişinin ismine göre belirlendiği için,
bütün bilgisayarlarda bu değer farklı olur. Bu değerin ne olduğu tespit
edebilmek içinosmodülününenvironniteliğinden yararlanabiliriz. Bu
nitelik, işletim sistemine özgü çevre değişkenlerini tutar.

GNU/Linux’ta kullanıcı dizinini tutan çevre değişkeni ‘HOME’ anahtarı ile
gösterilir:

```python
>>> kullanıcı = os.environ['HOME']

```

Windows’ta ise ‘HOMEPATH’ anahtarını kullanıyoruz:

```python
>>> kullanıcı = os.environ['HOMEPATH']

```

Kullanıcı dizinini elde ettikten sonra, masaüstüne giden yolu bulabilmek için şu
komutu kullanıyoruz:

```python
>>> masaüstü = os.path.join(kullanıcı, 'Desktop')

```

Sıra geldi elde ettiğimiz tam dizin yolunusys.path’e eklemeye:

```python
>>> sys.path.append(masaüstü)

```

Gördüğünüz gibi, listelerinappend()metodu yardımıyla masaüstünün yolunusys.pathadlı listeye ekledik.

Artık masaüstünde bulunan paketleri rahatlıkla her yerden içe aktarabiliriz.

> **Not**
> osmodülü hakkında daha geniş bilgi içinos Modülübaşlıklı konuyu inceleyebilirsiniz.sysmodülü hakkında bilgi için isesys Modülübaşlığını ziyaret edebilirsiniz.

Not

osmodülü hakkında daha geniş bilgi içinos Modülübaşlıklı konuyu inceleyebilirsiniz.sysmodülü hakkında bilgi için isesys Modülübaşlığını ziyaret edebilirsiniz.

#### Paketlerde İsim Çakışmaları

##### __init__.py Dosyası

Dipnotları:

Daha önce Python’ın 2.x sürümlerini kullanmış olanlar, bu yapının
bir paket oluşturmak için yeterli olmadığını düşünebilir. Çünkü Python’ın 2.x
sürümlerinde bir paket oluşturabilmek için,siparistakipdizininin içinde__init__.pyadlı bir dosya daha oluşturmamız gerekiyordu. Ancak Python3’te
bu zorunluluk ortadan kaldırıldı. Eğer bu söylediğimiz şeyin ne anlama
geldiğini bilmiyorsanız, bu uyarıyı görmezden gelip yolunuza devam
edebilirsiniz.

## Önemli Standart Kütüphane Modülleri

Daha önce de söylediğimiz gibi, modüller Python programlama dilinin belkemiğini
oluşturur. Hatta Python’ı öğrenmek, bir bakıma modülleri öğrenmek demektir,
diyebiliriz. Biz her ne kadar bu noktaya gelene kadar Python’daki bütün temel
veri tiplerini ve fonksiyonları öğrenmiş olsak da modülleri öğrenmeden ve
bunları etkili bir şekilde nasıl kullanacağımızı bilmeden işe yarar programlar
yazamayız.

Mesela diyelim ki veritabanına kayıt yapan bir program yazacaksınız. İşte bu iş
için çeşitli modüllerden yararlanmanız gerekir.

Eğer MS Excel veya MS Word gibi dosya biçimleri üzerinde çalışmalar
yapacaksanız, bu dosyalar üzerinde işlem yapabilmenizi sağlayan birtakım
modülleri kullanmanız gerekir.

Aynı şekilde grafik bir arayüze sahip programlar geliştirebilmek için de bazı
standart modülleri veya üçüncü şahıs modüllerini kullanmalısınız.

Bu durum oyun programlama, taşınabilir cihaz programlama, ağ programlama, web
programlama ve başka programlama alanları için de geçerlidir.

Geçen bölümde, modüller konusundan söz ederken Python’daki standart kütüphane
modüllerine ve üçüncü şahıs modüllerine şöyle bir göz gezdirmiştik. Önümüzdeki
bir kaç bölüm boyunca ise bazı önemli standart modülleri ve üçüncü şahıs
modüllerini ayrıntılı olarak inceleyeceğiz. Bu sayede programcılık ufkumuz epey
bir genişlemiş olacak.

### Düzenli İfadeler

Düzenli ifadeler Python programlama dilinin en çetrefilli konularından biridir.
Öyle ki, düzenli ifadelerin Python içinde ayrı bir dil olarak düşünülmesi
gerektiğini söyleyenler dahi vardır. Ama bütün zorluklarına rağmen programlama
deneyimimizin bir noktasında mutlaka karşımıza çıkacak olan bu yapıyı
öğrenmemizde büyük fayda var. Düzenli ifadeleri öğrendikten sonra, elle
yapılması saatler sürecek bir işlemi saliseler içinde yapabildiğinizi
gördüğünüzde eminim düzenli ifadelerin ne büyük bir nimet olduğunu siz de
anlayacaksınız. Tabii her güzel şey gibi, düzenli ifadelerin nimetlerinden
yararlanabilecek düzeye gelmek de bir miktar kan, ter ve gözyaşı istiyor.

Peki, düzenli ifadeleri kullanarak neler yapabiliriz? Çok genel bir ifadeyle, bu
yapıyı kullanarak metinleri veya karakter dizilerini parmağımızda oynatabiliriz.
Örneğin bir web sitesinde dağınık halde duran verileri bir çırpıda
ayıklayabiliriz. Bu veriler, mesela, toplu halde görmek istediğimiz web
adreslerinin bir listesi olabilir. Bunun dışında, örneğin, çok sayıda belge
üzerinde tek adımda istediğimiz değişiklikleri yapabiliriz.

Ancak genel bir kural olarak, düzenli ifadelerden kaçabildiğimiz müddetçe
kaçmamız gerekir. Eğer Python’daki karakter dizisi metotları, o anda yapmak
istediğimiz şey için yeterli geliyorsa mutlaka o metotları kullanmalıyız. Çünkü
karakter dizisi metotları, düzenli ifadelere kıyasla hem daha basit, hem de çok
daha hızlıdır. Ama bir noktadan sonra karakter dizilerini kullanarak yazdığınız
kodlar iyice karmaşıklaşmaya başlamışsa, kodların her tarafıifdeyimleriyle
dolmuşsa, hatta basit bir işlemi gerçekleştirmek için yazdığınız kod sayfa
sınırlarını zorlamaya başlamışsa, işte o noktada artık düzenli ifadelerin
dünyasına adım atmanız gerekiyor olabilir. Ama bu durumda Jamie Zawinski’nin şu
sözünü de aklınızdan çıkarmayın:“Bazıları, bir sorunla karşı karşıya
kaldıklarında şunu der: ‘Evet, burada düzenli ifadeleri kullanmam gerekiyor.’
İşte onların bir sorunu daha vardır artık…”

Başta da söylediğim gibi, düzenli ifadeler bize zorlukları unutturacak kadar
büyük kolaylıklar sunar. Emin olun yüzlerce dosya üzerinde tek tek elle
değişiklik yapmaktan daha zor değildir düzenli ifadeleri öğrenip kullanmak…
Hem zaten biz de bu sayfalarda bu “sevimsiz” konuyu olabildiğince sevimli hale
getirmek için elimizden gelen çabayı göstereceğiz. Sizin de çaba göstermeniz,
bol bol alıştırma yapmanız durumunda düzenli ifadeleri kavramak o kadar da
zorlayıcı olmayacaktır. Unutmayın, düzenli ifadeler ne kadar uğraştırıcı olsa da
programcının en önemli silahlarından biridir. Hatta düzenli ifadeleri
öğrendikten sonra onsuz geçen yıllarınıza acıyacaksınız.

Şimdi lafı daha fazla uzatmadan işimize koyulalım.

#### Düzenli İfadelerin Metotları

Python’daki düzenli ifadelere ilişkin her şey bir modül içinde tutulur. Bu
modülün adıre. Tıpkıosmodülünde,sysmodülünde,tkintermodülünde ve
öteki bütün modüllerde olduğu gibi, düzenli ifadeleri kullanabilmemiz için de
öncelikle buremodülünü içe aktarmamız gerekecek. Bu işlemi nasıl
yapacağımızı çok iyi biliyorsunuz:

```python
>>> import re

```

Başta da söylediğimiz gibi, düzenli ifadeler bir programcının en önemli
silahlarından biridir. Şu halde silahımızın özelliklerine bakalım. Yani bu
yapının bize sunduğu araçları şöyle bir listeleyelim. Etkileşimli kabukta şu
kodu yazıyoruz:

```python
>>> dir(re)

```

Tabii yukarıdakidir(re)komutunu yazmadan önceimportreşeklinde
modülümüzü içe aktarmış olmamız gerekiyor.

Gördüğünüz gibi,remodülü içinde epey metot/fonksiyon var. Biz bu sayfada ve
ilerleyen sayfalarda, yukarıdaki metotların/fonksiyonların en sık
kullanılanlarını size olabildiğince yalın bir şekilde anlatmaya çalışacağız.
Eğer isterseniz, şu komutu kullanarak yukarıdaki metotlar/fonksiyonlar hakkında
yardım da alabilirsiniz:

```python
>>> help(metot_veya_fonksiyon_adı)

```

Bir örnek vermek gerekirse:

```python
>>> help(re.match)

Help on function match in module re:
match(pattern, string, flags=0)
 Try to apply the pattern at the start of the string,
returning a match object, or None if no match was found.

```

Ne yazık ki, Python’ın yardım dosyaları hep İngilizce. Dolayısıyla eğer
İngilizce bilmiyorsanız, bu yardım dosyaları pek işinize yaramayacaktır. Bu
arada yukarıdaki yardım bölümünden çıkmak için klavyedekiqdüğmesine basmanız
gerekir.

##### match() Metodu

Bir önceki bölümde metotlar hakkında yardım almaktan bahsederken ilk örneğimizimatch()metoduyla vermiştik, o haldematch()metodu ile devam edelim.

match()metodunu tarif etmek yerine, isterseniz bir örnek yardımıyla bu
metodun ne işe yaradığını anlamaya çalışalım. Diyelim ki elimizde şöyle bir
karakter dizisi var:

```python
>>> a = "python güçlü bir programlama dilidir."

```

Varsayalım ki biz bu karakter dizisi içinde ‘python’ kelimesi geçip geçmediğini
öğrenmek istiyoruz. Ve bunu da düzenli ifadeleri kullanarak yapmak istiyoruz.
Düzenli ifadeleri bu örneğe uygulayabilmek için yapmamız gereken şey, öncelikle
bir düzenli ifade kalıbı oluşturup, daha sonra bu kalıbı yukarıdaki karakter
dizisi ile karşılaştırmak. Biz bütün bu işlemlerimatch()metodunu
kullanarak yapabiliriz:

```python
>>> re.match("python", a)

```

Burada,‘python’şeklinde bir düzenli ifade kalıbı oluşturduk. Düzenli ifade
kalıplarımatch()metodunun ilk argümanıdır (yani parantez içindeki ilk
değer). İkinci argümanımız ise (yani parantez içindeki ikinci değer),
hazırladığımız kalıbı kendisiyle eşleştireceğimiz karakter dizisi olacaktır.

Klavyede ENTER tuşuna bastıktan sonra karşımıza şöyle bir çıktı gelecek:

```python
<_sre.SRE_Match object; span=(0, 6), match='python'>

```

Bu çıktı, düzenli ifade kalıbının karakter dizisi ile eşleştiği anlamına
geliyor. Yani aradığımız şey, karakter dizisi içinde bulunmuş.

Yukarıdaki çıktıda gördüğümüz ifadeye Python’cada eşleşme nesnesi (match
object) adı veriliyor. Çünkümatch()metodu yardımıyla yaptığımız şey
aslında bir eşleştirme işlemidir (matchkelimesi İngilizcede ‘eşleşmek’
anlamına gelir). Biz burada‘python’düzenli ifadesininadeğişkeniyle
eşleşip eşleşmediğine bakıyoruz. Yanire.match("python",a)ifadesi
aracılığıyla ‘python’ ifadesi ileadeğişkeninin tuttuğu karakter dizisinin
eşleşip eşleşmediğini sorguluyoruz. Bizim örneğimizde ‘python’adeğişkeninin
tuttuğu karakter dizisi ile eşleştiği için bize bir eşleşme nesnesi
döndürülüyor.

Bu çıktı, düzenli ifade kalıbının karakter dizisi ile eşleştiğini bildirmenin
yanı sıra, bize başka birtakım bilgiler daha veriyor. Mesela bu çıktıdakispanparametresi, aradığımız ‘python’ karakter dizisinin,adeğişkeninin 0. ila 6.
karakterleri arasında yer aldığını söylüyor bize. Yani:

```python
>>> a[0:6]

'python'

```

Ayrıca yukarıdaki çıktıda gördüğümüzmatchparametresi de bize eşleşen
ifadenin ‘python’ olduğu bilgisini veriyor.

Bir de şu örneğe bakalım:

```python
>>> re.match("Java", a)

```

Burada ENTER tuşuna bastığımızda hiç bir çıktı almıyoruz. Aslında biz görmesek
de Python burada “None” çıktısı veriyor. Eğer yukarıdaki komutu şöyle yazarsak
“None” çıktısını biz de görebiliriz:

```python
>>> print(re.match("Java", a))

None

```

Gördüğünüz gibi, ENTER tuşuna bastıktan sonra “None” çıktısı geldi. Demek ki
“Java” ifadesi, “a” değişkeninin tuttuğu karakter dizisi ile eşleşmiyormuş.
Buradan çıkardığımız sonuca göre, Pythonmatch()metodu yardımıyla
aradığımız şeyi eşleştirdiği zaman bir eşleşme nesnesi (match object)
döndürüyor. Eğer eşleşme yoksa, o zaman da “None” değerini döndürüyor.

Biraz kafa karıştırmak için şöyle bir örnek verelim:

```python
>>> a = "Python güçlü bir dildir"
>>> re.match("güçlü", a)

```

Burada “a” değişkeninde “güçlü” ifadesi geçtiği haldematch()metodu bize
bir eşleşme nesnesi döndürmedi. Peki ama neden?

Aslında bu gayet normal. Çünkümatch()metodu bir karakter dizisinin sadece
en başına bakar. Yani “Python güçlü bir dildir” ifadesini tutanadeğişkenine
re.match(“güçlü”, a) gibi bir fonksiyon uyguladığımızda,match()metoduadeğişkeninin yalnızca en başına bakacağı veadeğişkeninin en başında “güçlü”
yerine “python” olduğu için,match()metodu bize olumsuz yanıt veriyor.

Aslındamatch()metodunun yaptığı bu işi, karakter dizilerininsplit()metodu yardımıyla da yapabiliriz:

```python
>>> a.split()[0] == "python"

True

```

Demek kiadeğişkeninin en başında “python” ifadesi varmış. Bir de şuna
bakalım:

```python
>>> a.split()[0] == "güçlü"

False

```

Veya aynı işi sadecestartswith()metodunu kullanarak dahi yapabiliriz:

```python
>>> a.startswith("python")

```

Eğer düzenli ifadelerden tek beklentiniz bir karakter dizisinin en başındaki
veriyle eşleştirme işlemi yapmaksa,split()veyastartswith()metotlarını kullanmak daha mantıklıdır. Çünküsplit()vestartswith()metotlarımatch()metodundan çok daha hızlı çalışacaktır.

match()metodunu kullanarak birkaç örnek daha yapalım:

```python
>>> sorgu = "1234567890"
>>> re.match("1", sorgu)

<_sre.SRE_Match object; span=(0, 1), match='1'>

>>> re.match("1234", sorgu)

<_sre.SRE_Match object; span=(0, 4), match='1234'>

>>> re.match("124", sorgu)

```

İsterseniz şimdiye kadar öğrendiğimiz şeyleri şöyle bir gözden geçirelim:
1. Düzenli ifadeler Python’ın çok güçlü araçlarından biridir.
1. Python’daki düzenli ifadelere ilişkin bütün fonksiyonlarreadlı
bir modül içinde yer alır.
1. Dolayısıyla düzenli ifadeleri kullanabilmek için öncelikle buremodülünüimportrediyerek içe aktarmamız gerekir.
1. remodülünün içeriğinidir(re)komutu yardımıyla listeleyebiliriz.
1. match()metoduremodülü içindeki fonksiyonlardan biridir.
1. match()metodu bir karakter dizisinin yalnızca en başına bakar.
1. Eğer aradığımız şey karakter dizisinin en başında yer alıyorsa,match()metodu bir eşleştirme nesnesi döndürür.
1. Eğer aradığımız şey karakter dizisinin en başında yer almıyorsa,match()metodu “None” değeri döndürür.

Düzenli ifadeler Python’ın çok güçlü araçlarından biridir.

Python’daki düzenli ifadelere ilişkin bütün fonksiyonlarreadlı
bir modül içinde yer alır.

Dolayısıyla düzenli ifadeleri kullanabilmek için öncelikle buremodülünüimportrediyerek içe aktarmamız gerekir.

remodülünün içeriğinidir(re)komutu yardımıyla listeleyebiliriz.

match()metoduremodülü içindeki fonksiyonlardan biridir.

match()metodu bir karakter dizisinin yalnızca en başına bakar.

Eğer aradığımız şey karakter dizisinin en başında yer alıyorsa,match()metodu bir eşleştirme nesnesi döndürür.

Eğer aradığımız şey karakter dizisinin en başında yer almıyorsa,match()metodu “None” değeri döndürür.

Daha önce söylediğimiz gibi,match()metodu ile bir eşleştirme işlemi
yaptığımızda, eğer eşleşme varsa Python bize bir eşleşme nesnesi döndürecektir.
Döndürülen bu eşleşme nesnesi bizespanvematchparametreleri aracılığıyla,
eşleşen karakter dizisinin sorgu dizisi içindeki yerini ve eşleşen dizinin ne
olduğu söylüyor.spanparametresinin değerinespan()adlı bir metot
yardımıyla erişebiliyoruz. Örneğin:

```python
>>> import re
>>> sorgu = 'Bin kunduz'
>>> eşleşme = re.match('Bin', sorgu)
>>> eşleşme

<_sre.SRE_Match object; span=(0, 3), match='Bin'>

>>> eşleşme.span()
(0, 3)

```

Ancak,match()metodu ile bulunan şeyin ne olduğunu eşleşme nesnesininmatchparametresine bakarak görebilsek de, bu değeri bir kod yardımıyla
alamıyoruz. Çünkü eşleşme nesnelerininspan()metoduna benzeyen birmatch()metodu bulunmaz.

Ama istersek tabii ki bulunan şeyi de programatik olarak alma imkânımız var.
Bunun içingroup()adlı bir başka metottan yararlanacağız:

```python
>>> kardiz = "perl, python ve ruby yüksek seviyeli dillerdir."
>>> eşleşme = re.match("perl", kardiz)
>>> eşleşme.group()

'perl'

```

Burada,re.match("perl",kardiz)komutunu bir değişkene atadık.
Hatırlarsanız, bu fonksiyonu komut satırına yazdığımızda bir eşleşme nesnesi
elde ediyorduk. İşte burada değişkene atadığımız şey aslında bu eşleşme
nesnesinin kendisi oluyor. Bu durumu şu şekilde teyit edebilirsiniz:

```python
>>> type(eşleşme)

<class '_sre.SRE_Match'>

```

Gördüğünüz gibi,eşleşmedeğişkeninin tipi bir eşleşme nesnesi (match
object). İsterseniz bu nesnenin metotlarına bir göz gezdirebiliriz:

```python
>>> dir(eşleşme)

```

Dikkat ederseniz yukarıda kullandığımızgroup()metodu listede görünüyor. Bu
metot, doğrudan doğruya düzenli ifadelerin değil, eşleşme nesnelerinin bir
metodudur. Listedeki öbür metotları da sırası geldiğinde inceleyeceğiz. Şimdi
isterseniz bir örnek daha yapıp bu konuyu kapatalım:

```python
>>> iddia = "Adana memleketlerin en güzelidir!"
>>> nesne = re.match("Adana", iddia)
>>> nesne.group()

'Adana'

```

Peki, eşleştirmek istediğimiz düzenli ifade kalıbı bulunamazsa ne olur? Öyle bir
durumda yukarıdaki kodlar hata verecektir. Hemen bakalım:

```python
>>> nesne = re.match("İstanbul", iddia)
>>> nesne.group()

```

Hata mesajımız:

```python
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'NoneType' object has no attribute 'group'

```

Böyle bir hata, yazdığınız bir programın çökmesine neden olabilir. O yüzden
kodlarımızı şuna benzer bir şekilde yazmamız daha mantıklı olacaktır:

```python
>>> nesne = re.match("İstanbul", iddia)
>>> if nesne:
... print("eşleşen ifade:", nesne.group())
... else:
... print("eşleşme başarısız!")

```

Şimdi isterseniz bumatch()metoduna bir ara verip başka bir metodu
inceleyelim.

##### search() Metodu

Bir önceki bölümde incelediğimizmatch()metodu, karakter dizilerinin sadece
en başına bakıyordu. Ama istediğimiz şey tabii ki her zaman bununla sınırlı
olmayacaktır.match()metodunun, karakter dizilerinin sadece başına
bakmasını engellemenin yolları olmakla birlikte, bizim işimizi görecek çok daha
kullanışlı bir metodu vardır düzenli ifadelerin. Önceki bölümdedir(re)şeklinde gösterdiğimiz listeye tekrar bakarsanız, oradaremodülününsearch()adlı bir metodu olduğunu göreceksiniz. İşte bu yazımızda
inceleyeceğimiz metot busearch()metodu olacaktır.

search()metodu ilematch()metodu arasında çok önemli bir fark vardır.match()metodu bir karakter dizisinin en başına bakıp bir eşleştirme işlemi
yaparken,search()metodu karakter dizisinin genelinde bir arama işlemi
yapar. Yani biri eşleştirir, öbürü arar.

Hatırlarsanız,match()metodunu anlatırken şöyle bir örnek vermiştik:

```python
>>> a = "Python güçlü bir dildir"
>>> re.match("güçlü", a)

```

Yukarıdaki kod, karakter dizisinin başında bir eşleşme bulamadığı için bizeNonedeğeri döndürüyordu. Ama eğer aynı işlemi şöyle yaparsak, daha farklı bir
sonuç elde ederiz:

```python
 >>> a = "Python güçlü bir dildir"
 >>> re.search("güçlü", a)

<_sre.SRE_Match object; span=(7, 12), match='güçlü'>

```

Gördüğünüz gibi,search()metodu “güçlü” kelimesini buldu. Çünküsearch()metodu,match()metodunun aksine, bir karakter dizisinin sadece
baş tarafına bakmakla yetinmiyor, karakter dizisinin geneli üzerinde bir arama
işlemi gerçekleştiriyor.

Tıpkımatch()metodunda olduğu gibi,search()metodunda daspan()vegroup()metotlarından faydalanarak bulunan şeyin hangi aralıkta olduğunu ve
bu şeyin ne olduğunu görüntüleyebiliriz:

```python
>>> kardiz = "Python güçlü bir dildir"
>>> nesne = re.search("güçlü", kardiz)
>>> nesne.span()

(7, 12)

>>> nesne.group()

'güçlü'

```

Şimdiye kadar hep karakter dizileri üzerinde çalıştık. İsterseniz biraz da
listeler üzerinde örnekler verelim.

Şöyle bir listemiz olsun:

```python
>>> liste = ["elma", "armut", "kebap"]
>>> re.search("kebap", liste)

```

Ne oldu? Hata aldınız, değil mi? Bu normal. Çünkü düzenli ifadeler karakter
dizileri üzerinde işler. Bunlar doğrudan listeler üzerinde işlem yapamaz. O
yüzden bizim Python’a biraz yardımcı olmamız gerekiyor:

```python
>>> for i in liste:
... nesne = re.search("kebap", i)
... if nesne:
... print(nesne.group())
...
kebap

```

Hatta şimdiye kadar öğrendiklerimizle daha karmaşık bir şeyler de yapabiliriz:

```python
>>> import re
>>> from urllib.request import urlopen
>>> f = urlopen("https://python-istihza.yazbel.com/")
>>> for i in f:
... nesne = re.search(b'programlama', i)
... if nesne:
... print(nesne.group())
...
b'programlama'
b'programlama'

```

Gördüğünüz gibi, python-istihza.yazbel.com sayfasında kaç adet “programlama”
kelimesi geçiyorsa hepsi ekrana dökülüyor.

Bu arada, web sitesinde arama işlemi gerçekleştirirkenurllibpaketinin
içindekirequestmodülününurlopen()adlı fonksiyonunu kullandığımıza
dikkat edin. Ayrıcasearch()metoduna parametre olarak bir karakter dizisi
değil, bayt dizisi verdiğimizi de gözden kaçırmayın:

```python
re.search(b'programlama', i)

```

Siz isterseniz bu kodları biraz daha geliştirebilirsiniz:

```python
import re
from urllib.request import urlopen

kelime = input("python-istihza.yazbel.com'da aramak istediğiniz kelime: ")

f = urlopen("https://python-istihza.yazbel.com/")
data = str(f.read())

nesne = re.search(kelime, data)

if nesne:
 print("kelime bulundu:", nesne.group())
else:
 print("kelime bulunamadı!:", kelime)

```

Burada, kullanıcıdan aldığımız kelimeyisearch()metoduna göndermeden önce,
siteden okuduğumuz verileristr()metodu yardımıyla karakter dizisine
dönüştürdüğümüze dikkat edin. Böylece kullanıcıdan gelen karakter dizisini bayt
dizisine çevirmemize gerek kalmadı.

İlerde bilgimiz artınca daha yetkin kodlar yazabilecek duruma geleceğiz. Ama
şimdilik elimizde olanlar ancak yukarıdaki kodu yazmamıza müsaade ediyor.
Unutmayın, düzenli ifadeler sahasında ısınma turları atıyoruz daha…

##### findall() Metodu

Python komut satırında, yani etkileşimli kabukta,dir(re)yazdığımız zaman
aldığımız listeye tekrar bakarsak orada bir defindall()adlı bir metodun
olduğunu görürüz. İşte bu bölümdefindall()adlı bu önemli metodu incelemeye
çalışacağız.

Önce şöyle bir metin alalım elimize:

```python
metin = """Guido Van Rossum Python'ı geliştirmeye 1990 yılında başlamış... Yani
aslında Python için nispeten yeni bir dil denebilir. Ancak Python'un çok uzun
bir geçmişi olmasa da, bu dil öteki dillere kıyasla kolay olması, hızlı olması,
ayrı bir derleyici programa ihtiyaç duymaması ve bunun gibi pek çok nedenden
ötürü çoğu kimsenin gözdesi haline gelmiştir. Ayrıca Google'ın da Python'a özel
bir önem ve değer verdiğini, çok iyi derecede Python bilenlere iş olanağı
sunduğunu da hemen söyleyelim. Mesela bundan kısa bir süre önce Python'ın
yaratıcısı Guido Van Rossum Google'de işe başladı..."""

```

Bu metin içinde geçen bütün “Python” kelimelerini bulmak istiyoruz:

```python
print(re.findall("Python", metin))

['Python', 'Python', 'Python', 'Python', 'Python', 'Python']

```

Gördüğünüz gibi, metinde geçen bütün “Python” kelimelerini bir çırpıda liste
olarak aldık. Aynı işlemisearch()metodunu kullanarak yapmak istersek yolu
biraz uzatmamız gerekir:

```python
>>> liste = metin.split()
>>> for i in liste:
... nesne = re.search("Python", i)
... if nesne:
... print(nesne.group())
...
Python
Python
Python
Python
Python
Python

```

Gördüğünüz gibi, metinde geçen bütün “Python” kelimelerinisearch()metodunu
kullanarak bulmak için öncelikle “metin” adlı karakter dizisini, daha önce
karakter dizilerini işlerken gördüğümüzsplit()metodu yardımıyla bir liste
haline getiriyoruz. Ardından bu liste üzerinde birfordöngüsü kuraraksearch()vegroup()metotlarını kullanarak bütün “Python” kelimelerini
ayıklıyoruz. Eğer karakter dizisini yukarıdaki şekilde listeye dönüştürmezsek
şöyle bir netice alırız:

```python
>>> nesne = re.search("Python", metin)
>>> print(nesne.group())

Python

```

Bu şekilde metinde geçen sadece ilk “Python” kelimesini alabiliyoruz.

#### Metakarakterler

Şimdiye kadar düzenli ifadelerle ilgili olarak verdiğimiz örnekler sizi biraz
şaşırtmış olabilir. “Zor dediğin bunlar mıydı?” diye düşünmüş olabilirsiniz.
Haklısınız, zira “zor” dediğim, buraya kadar olan kısımda verdiğim örneklerden
ibaret değildir. Buraya kadar olan bölümde verdiğim örnekler işin en temel
kısmını gözler önüne sermek içindi. Şimdiye kadar olan bölümde, mesela, “python”
karakter dizisiyle eşleştirme yapmak için “python” kelimesini kullandık.
Esasında bu, düzenli ifadelerin en temel özelliğidir. Yani “python” karakter
dizisini bir düzenli ifade sayacak olursak (ki zaten öyledir), bu düzenli ifade
en başta kendisiyle eşleşecektir. Bu ne demek? Şöyle ki: Eğer aradığınız şey
“python” karakter dizisi ise, kullanmanız gereken düzenli ifade de “python”
olacaktır.

Diyoruz ki: “Düzenli ifadeler en başta kendileriyle eşleşirler”. Buradan şu
anlam çıkıyor: Demek ki bir de kendileriyle eşleşmeyen düzenli ifadeler var.
İşte bu durum, Python’daki düzenli ifadelere kişiliğini kazandıran şeydir. Biraz
sonra ne demek istediğimizi daha açık anlayacaksınız. Artık gerçek anlamıyla
düzenli ifadelere giriş yapıyoruz!

Öncelikle, elimizde aşağıdaki gibi bir liste olduğunu varsayalım:

```python
>>> liste = ["özcan", "mehmet", "süleyman", "selim",
... "kemal", "özkan", "esra", "dündar", "esin",
... "esma", "özhan", "özlem"]

```

Diyelim ki, biz bu liste içinden “özcan”, “özkan” ve “özhan” öğelerini
ayıklamak/almak istiyoruz. Bunu yapabilmek için yeni bir bilgiye
ihtiyacımız var: Metakarakterler.

Metakarakterler; kabaca, programlama dilleri için özel anlam ifade eden
sembollerdir. Örneğin daha önce gördüğümüz\nbir bakıma bir metakarakterdir.
Çünkü\nsembolü Python için özel bir anlam taşır. Python bu sembolü gördüğü
yerde yeni bir satıra geçer. Yukarıda “kendisiyle eşleşmeyen karakterler”
ifadesiyle kastettiğimiz şey de işte bu metakarakterlerdir. Örneğin, “a” harfi
yalnızca kendisiyle eşleşir. Tıpkı “istihza” kelimesinin yalnızca kendisiyle
eşleşeceği gibi… Ama mesela\tifadesi kendisiyle eşleşmez. Python bu
işareti gördüğü yerde sekme (tab) düğmesine basılmış gibi tepki verecektir. İşte
düzenli ifadelerde de buna benzer metakarakterlerden yararlanacağız. Düzenli
ifadeler içinde de, özel anlam ifade eden pek çok sembol, yani metakarakter
vardır. Bu metakarakterlerden biri de “[ ]” sembolüdür. Şimdi yukarıda
verdiğimiz listeden “özcan”, “özhan” ve “özkan” öğelerini bu sembolden
yararlanarak nasıl ayıklayacağımızı görelim:

```python
>>> re.search("öz[chk]an", liste)

```

Bu kodu böyle yazmamamız gerektiğini artık biliyoruz. Aksi halde hata
alırız. Çünkü daha önce de dediğimiz gibi, düzenli ifadeler karakter
dizileri üzerinde işlem yapabilir. Listeler üzerinde değil. Dolayısıyla
komutumuzu şu şekilde vermemiz gerekiyor:

```python
>>> for i in liste:
... nesne = re.search("öz[chk]an", i)
... if nesne:
... print(nesne.group())

```

Aynı işlemi şu şekilde de yapabiliriz:

```python
>>> for i in liste:
... if re.search("öz[chk]an",i):
... print(i)

```

Ancak, bu örnekte pek belli olmasa da, son yazdığımız kod her zaman
istediğimiz sonucu vermez. Mesela listemiz şöyle olsaydı:

```python
>>> liste = ["özcan demir", "mehmet", "süleyman",
... "selim", "kemal", "özkan nuri", "esra", "dündar",
... "esin", "esma", "özhan kamil", "özlem"]

```

Yukarıdaki kod bu liste üzerine uygulandığında, sadece almak istediğimiz
kısım değil, ilgisiz kısımlar da gelecektir.

Gördüğünüz gibi, uygun kodları kullanarak, “özcan”, “özkan” ve “özhan”
öğelerini listeden kolayca ayıkladık. Bize bu imkânı veren şey ise “[ ]”
adlı metakarakter oldu. Aslında “[ ]” metakarakterinin ne işe yaradığını
az çok anlamış olmalısınız. Ama biz yine de şöyle bir bakalım bu
metakaraktere:

“[ ]” adlı metakarakter, yukarıda verdiğimiz listedeki “öz” ile
başlayıp, “c”, “h” veya “k” harflerinden herhangi biri ile devam eden ve
“an” ile biten bütün öğeleri ayıklıyor. Gelin bununla ilgili bir örnek
daha yapalım:

```python
>>> for i in liste:
... nesne = re.search("es[mr]a",i)
... if nesne:
... print(nesne.group())

```

Gördüğünüz gibi, “es” ile başlayıp, “m” veya “r” harflerinden herhangi
biriyle devam eden ve sonunda da “a” harfi bulunan bütün öğeleri
ayıkladık. Bu da bize “esma” ve “esra” çıktılarını verdi…

Dediğimiz gibi, metakarakterler programlama dilleri için özel anlam
ifade eden sembollerdir. “Normal” karakterlerden farklı olarak,
metakarakterlerle karşılaşan bir bilgisayar normalden farklı bir tepki
verecektir. Yukarıda metakarakterlere örnek olarak “\n” ve “\t” kaçış
dizilerini vermiştik. Örneğin Python’da print(”\n”) gibi bir komut
verdiğimizde, Python ekrana “\n” yazdırmak yerine bir alt satıra
geçecektir. Çünkü “\n” Python için özel bir anlam taşımaktadır. Düzenli
ifadelerde de birtakım metakarakterlerin kullanıldığını öğrendik. Bu
metakarakterler, düzenli ifadeleri düzenli ifade yapan şeydir. Bunlar
olmadan düzenli ifadelerle yararlı bir iş yapmak mümkün olmaz. Bu giriş
bölümünde düzenli ifadelerde kullanılan metakarakterlere örnek olarak “[
]” sembolünü verdik. Herhangi bir düzenli ifade içinde “[ ]” sembolünü
gören Python, doğrudan doğruya bu sembolle eşleşen bir karakter dizisi
aramak yerine, özel bir işlem gerçekleştirecektir. Yani “[ ]” sembolü
kendisiyle eşleşmeyecektir…

Python’da bulunan temel metakarakterleri topluca görelim:

```python
[ ] . \* + ? { } ^ $ | ( )

```

Doğrudur, yukarıdaki karakterler, çizgi romanlardaki küfürlere benziyor.
Endişelenmeyin, biz bu metakarakterleri olabildiğince sindirilebilir
hale getirmek için elimizden gelen çabayı göstereceğiz.

Bu bölümde düzenli ifadelerin zor kısmı olan metakarakterlere,
okurlarımızı ürkütmeden, yumuşak bir giriş yapmayı amaçladık. Şimdi
artık metakarakterlerin temelini attığımıza göre üste kat çıkmaya
başlayabiliriz.

##### [ ] (Köşeli Parantez)

[ ] adlı metakaraktere önceki bölümde değinmiştik. Orada verdiğimiz
örnek şuydu:

```python
>>> for i in liste:
... nesne = re.search("öz[chk]an", i)
... if nesne:
... print(nesne.group())

```

Yukarıdaki örnekte, bir liste içinde geçen “özcan”, “özhan” ve “özkan”
öğelerini ayıklıyoruz. Burada bu üç öğedeki farklı karakterleri (“c”,
“h” ve “k”) köşeli parantez içinde nasıl belirttiğimize dikkat edin.
Python, köşeli parantez içinde gördüğü bütün karakterleri tek tek liste
öğelerine uyguluyor. Önce “öz” ile başlayan bütün öğeleri alıyor,
ardından “öz” hecesinden sonra “c” harfiyle devam eden ve “an” hecesi
ile biten öğeyi buluyor. Böylece “özcan” öğesini bulmuş oldu. Aynı
işlemi, “öz” hecesinden sonra “h” harfini barındıran ve “an” hecesiyle
biten öğeye uyguluyor. Bu şekilde ise “özhan” öğesini bulmuş oldu. En
son hedef ise “öz” ile başlayıp “k” harfi ile devam eden ve “an” ile
biten öğe. Yani listedeki “özkan” öğesi… En nihayetinde de elimizde
“özcan”, “özhan” ve “özkan” öğeleri kalmış oluyor.

Bir önceki bölümde yine “[ ]” metakarakteriyle ilgili olarak şu örneği
de vermiştik:

```python
>>> for i in liste:
... nesne = re.search("es[mr]a",i)
... if nesne:
... print(nesne.group())

```

Bu örneğin de “özcan, özkan, özhan” örneğinden bir farkı yok. Burada da
Python köşeli parantez içinde gördüğü bütün karakterleri tek tek liste
öğelerine uygulayıp, “esma” ve “esra” öğelerini bize veriyor.

Şimdi bununla ilgili yeni bir örnek verelim

Diyelim ki elimizde şöyle bir liste var:

```python
>>> a = ["23BH56","TY76Z","4Y7UZ","TYUDZ","34534"]

```

Mesela biz bu listedeki öğeler içinde, sayıyla başlayanları ayıklayalım.
Şimdi şu kodları dikkatlice inceleyin:

```python
>>> for i in a:
... if re.match("[0-9]",i):
... print(i)
...
23BH56
4Y7UZ
34534

```

Burada parantez içinde kullandığımız ifadeye dikkat edin. “0” ile “9”
arasındaki bütün öğeleri içeren bir karakter dizisi tanımladık. Yani
kısaca, içinde herhangi bir sayı barındıran öğeleri kapsama alanımıza
aldık. Burada ayrıca search() yerine match() metodunu kullandığımıza da
dikkat edin. match() metodunu kullanmamızın nedeni, bu metodun bir
karakter dizisinin sadece en başına bakması… Amacımız sayı ile
başlayan bütün öğeleri ayıklamak olduğuna göre, yukarıda yazdığımız kod,
liste öğeleri içinde yer alan ve sayı ile başlayan bütün öğeleri
ayıklayacaktır. Biz burada Python’a şu emri vermiş oluyoruz:

“Bana sayı ile başlayan bütün öğeleri bul! Önemli olan bu öğelerin
sayıyla başlamasıdır! Sayıyla başlayan bu öğeler ister harfle devam
etsin, ister başka bir karakterle… Sen yeter ki bana sayı ile başlayan
öğeleri bul!”

Bu emri alan Python, hemen liste öğelerini gözden geçirecek ve bize
“23BH56”, “4Y7UZ” ve “34534” öğelerini verecektir. Dikkat ederseniz,
Python bize listedeki “TY76Z” ve “TYUDZ” öğelerini vermedi. Çünkü
“TY76Z” içinde sayılar olsa da bunlar bizim ölçütümüze uyacak şekilde en
başta yer almıyor. “TYUDZ” öğesinde ise tek bir sayı bile yok…

Şimdi de isterseniz listedeki “TY76Z” öğesini nasıl alabileceğimize
bakalım:

```python
>>> for i in a:
... if re.match("[A-Z][A-Z][0-9]",i):
... print(i)

```

Burada dikkat ederseniz düzenli ifademizin başında “A-Z” diye bir şey
yazdık. Bu ifade “A” ile “Z” harfleri arasındaki bütün karakterleri
temsil ediyor. Biz burada yalnızca büyük harfleri sorguladık. Eğer küçük
harfleri sorgulamak isteseydik “A-Z” yerine “a-z” diyecektik. Düzenli
ifademiz içinde geçen birinci “A-Z” ifadesi aradığımız karakter dizisi
olan “TY76Z” içindeki “T” harfini, ikinci “A-Z” ifadesi “Y” harfini,
“0-9” ifadesi ise “7” sayısını temsil ediyor. Karakter dizisi içindeki
geri kalan harfler ve sayılar otomatik olarak eşleştirilecektir. O
yüzden onlar için ayrı bir şey yazmaya gerek yok. Yalnız bu söylediğimiz
son şey sizi aldatmasın. Bu “otomatik eşleştirme” işlemi bizim şu anda
karşı karşıya olduğumuz karakter dizisi için geçerlidir. Farklı
nitelikteki karakter dizilerinin söz konusu olduğu başka durumlarda
işler böyle yürümeyebilir. Düzenli ifadeleri başarılı bir şekilde
kullanabilmenin ilk şartı, üzerinde işlem yapılacak karakter dizisini
tanımaktır. Bizim örneğimizde yukarıdaki gibi bir düzenli ifade kalıbı
oluşturmak işimizi görüyor. Ama başka durumlarda, duruma uygun başka
kalıplar yazmak gerekebilir/gerekecektir. Dolayısıyla, tek bir düzenli
ifade kalıbıyla hayatın geçmeyeceğini unutmamalıyız.

Şimdi yukarıdaki kodu search() ve group() metotlarını kullanarak yazmayı
deneyin. Elde ettiğiniz sonuçları dikkatlice inceleyin. match() ve
search() metotlarının ne gibi farklılıklara sahip olduğunu kavramaya
çalışın… Sorunuz olursa bana nasıl ulaşacağınızı biliyorsunuz…

Bu arada, düzenli ifadelerle ilgili daha fazla şey öğrendiğimizde
yukarıdaki kodu çok daha sade bir biçimde yazabileceğiz.

##### . (Nokta)

Bir önceki bölümde “[]” adlı metakarakteri incelemiştik. Bu bölümde ise
farklı bir metakarakteri inceleyeceğiz. İnceleyeceğimiz metakarakter:
“.”

Bu metakarakter, yeni satır karakteri hariç bütün karakterleri temsil
etmek için kullanılır. Mesela:

```python
>>> for i in liste:
... nesne = re.match("es.a",i)
... if nesne:
... print(nesne.group())
...
esma
esra

```

Gördüğünüz gibi, daha önce “[]” metakarakterini kullanarak yazdığımız
bir düzenli ifadeyi bu kez farklı şekilde yazıyoruz. Unutmayın, bir
düzenli ifade birkaç farklı şekilde yazılabilir. Biz bunlar içinde en
basit ve en anlaşılır olanını seçmeliyiz. Ayrıca yukarıdaki kodu birkaç
farklı şekilde de yazabilirsiniz. Mesela şu yazım da bizim durumumuzda
geçerli bir seçenek olacaktır:

```python
>>> for i in liste:
... if re.match("es.a",i):
... print(i)

```

Tabii ki biz, o anda çözmek durumunda olduğumuz soruna en uygun olan
seçeneği tercih etmeliyiz…

Yalnız, unutmamamız gereken şey, bu “.” adlı metakarakterin sadece tek
bir karakterin yerini tutuyor olmasıdır. Yani şöyle bir kullanım bize
istediğimiz sonucu vermez:

```python
>>> liste = ["ahmet","kemal", "kamil", "mehmet"]
>>> for i in liste:
... if re.match(".met",i):
... print(i)

```

Burada “.” sembolü “ah” ve “meh” hecelerinin yerini tutamaz. “.”
sembolünün görevi sadece tek bir karakterin yerini tutmaktır (yeni satır
karakteri hariç). Ama biraz sonra öğreneceğimiz metakarakter yardımıyla
“ah” ve “meh” hecelerinin yerini de tutabileceğiz.

“.” sembolünü kullanarak bir örnek daha yapalım. Bir önceki bölümde
verdiğimiz “a” listesini hatırlıyorsunuz:

```python
>>> a = ['23BH56', 'TY76Z', '4Y7UZ', 'TYUDZ', '34534']

```

Önce bu listeye bir öğe daha ekleyelim:

```python
>>> a.append("1agAY54")

```

Artık elimizde şöyle bir liste var:

```python
>>> a = ['23BH56', 'TY76Z', '4Y7UZ', 'TYUDZ',
... '34534', "1agAY54"]

```

Şimdi bu listeye şöyle bir düzenli ifade uygulayalım:

```python
>>> for i in a:
... if re.match(".[0-9a-z]", i):
... print(i)
...
23BH56
34534
1agAY54

```

Burada yaptığımız şey çok basit. Şu özelliklere sahip bir karakter
dizisi arıyoruz:
1. Herhangi bir karakter ile başlayacak. Bu karakter sayı, harf veya
başka bir karakter olabilir.
1. Ardından bir sayı veya alfabedeki küçük harflerden herhangi birisi
gelecek.
1. Bu ölçütleri karşıladıktan sonra, aradığımız karakter dizisi
herhangi bir karakter ile devam edebilir.

Herhangi bir karakter ile başlayacak. Bu karakter sayı, harf veya
başka bir karakter olabilir.

Ardından bir sayı veya alfabedeki küçük harflerden herhangi birisi
gelecek.

Bu ölçütleri karşıladıktan sonra, aradığımız karakter dizisi
herhangi bir karakter ile devam edebilir.

Yukarıdaki ölçütlere uyan karakter dizilerimiz: “23BH56”, “34534”,
“1agAY54”

Yine burada da kendinize göre birtakım değişiklikler yaparak, farklı
yazım şekilleri ve farklı metotlar kullanarak ne olup ne bittiğini daha
iyi kavrayabilirsiniz. Düzenli ifadeleri gereği gibi anlayabilmek için
bol bol uygulama yapmamız gerektiğini unutmamalıyız.

##### * (Yıldız)

Bu metakarakter, kendinden önce gelen bir düzenli ifade kalıbını sıfır
veya daha fazla sayıda eşleştirir. Tanımı biraz karışık olsa da örnek
yardımıyla bunu da anlayacağız:

```python
>>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"]
>>> for i in yeniliste:
... if re.match("sa*t",i):
... print(i)

```

Burada “*” sembolü kendinden önce gelen “a” karakterini sıfır veya daha
fazla sayıda eşleştiriyor. Yani mesela “st” içinde sıfır adet “a”
karakteri var. Dolayısıyla bu karakter yazdığımız düzenli ifadeyle
eşleşiyor. “sat” içinde bir adet “a” karakteri var. Dolayısıyla bu da
eşleşiyor. “saat” ve “saaat” karakter dizilerinde sırasıyla iki ve üç
adet “a” karakteri var. Tabii ki bunlar da yazdığımız düzenli ifadeyle
eşleşiyor. Listemizin en son öğesi olan “falanca”da da ilk hecede bir
adet “a” karakteri var. Ama bu öğedeki sorun, bunun “s” harfiyle
başlamaması. Çünkü biz yazdığımız düzenli ifadede, aradığımız şeyin “s”
harfi ile başlamasını, sıfır veya daha fazla sayıda “a” karakteri ile
devam etmesini ve ardından da “t” harfinin gelmesini istemiştik.
“falanca” öğesi bu koşulları karşılamadığı için süzgecimizin dışında
kaldı.

Burada dikkat edeceğimiz nokta, “*” metakarakterinin kendinden önce
gelen yalnızca bir karakterle ilgileniyor olması… Yani bizim
örneğimizde “*” sembolü sadece “a” harfinin sıfır veya daha fazla
sayıda bulunup bulunmamasıyla ilgileniyor. Bu ilgi, en baştaki “s”
harfini kapsamıyor. “s” harfinin de sıfır veya daha fazla sayıda
eşleşmesini istersek düzenli ifademizi “s*a*t” veya “[sa]*t”
biçiminde yazmamız gerekir… Bu iki seçenek içinde “[sa]*t” şeklindeki
yazımı tercih etmenizi tavsiye ederim. Burada, daha önce öğrendiğimiz “[
]” metakarakteri yardımıyla “sa” harflerini nasıl grupladığımıza dikkat
edin…

Şimdi “.” metakarakterini anlatırken istediğimiz sonucu alamadığımız
listeye dönelim. Orada “ahmet” ve “mehmet” öğelerini listeden başarıyla
ayıklayamamıştık. O durumda bizim başarısız olmamıza neden olan kullanım
şöyleydi:

```python
>>> liste = ["ahmet", "kemal", "kamil", "mehmet"]
>>> for i in liste:
... if re.match(".met",i):
... print(i)

```

Ama artık elimizde “*” gibi bir araç olduğuna göre şimdi istediğimiz
şeyi yapabiliriz. Yapmamız gereken tek şey “.” sembolünden sonra “*”
sembolünü getirmek:

```python
>>> for i in liste:
... if re.match(".*met", i):
... print(i)

```

Gördüğünüz gibi “ahmet” ve “mehmet” öğelerini bu kez başarıyla
ayıkladık. Bunu yapmamızı sağlayan şey de “*” adlı metakarakter oldu…
Burada Python’a şu emri verdik: “Bana kelime başında herhangi bir
karakteri (“.” sembolü herhangi bir karakterin yerini tutuyor) sıfır
veya daha fazla sayıda içeren ve sonu da “met” ile biten bütün öğeleri
ver!”

Bir önceki örneğimizde “a” harfinin sıfır veya daha fazla sayıda bulunup
bulunmamasıyla ilgilenmiştik. Bu son örneğimizde ise herhangi bir
harfin/karakterin sıfır veya daha fazla sayıda bulunup bulunmamasıyla
ilgilendik. Dolayısıyla “.*met” şeklinde yazdığımız düzenli ifade,
“ahmet”, “mehmet”, “muhammet”, “ismet”, “kısmet” ve hatta tek başına
“met” gibi bütün öğeleri kapsayacaktır. Kısaca ifade etmek gerekirse,
sonu “met” ile biten her şey (“met” ifadesinin kendisi de dâhil olmak
üzere) kapsama alanımıza girecektir. Bunu günlük hayatta nerede
kullanabileceğinizi hemen anlamış olmalısınız. Mesela bir dizin içindeki
bütün “mp3” dosyalarını bu düzenli ifade yardımıyla listeleyebiliriz:

```python
>>> import os
>>> import re
>>> dizin = os.listdir(os.getcwd())
>>> for i in dizin:
... if re.match(".*mp3",i):
... print(i)

```

match() metodunu anlattığımız bölümde bu metodun bir karakter dizisinin
yalnızca başlangıcıyla ilgilendiğini söylemiştik. Mesela o bölümde
verdiğimiz şu örneği hatırlıyorsunuzdur:

```python
>>> a = "python güçlü bir dildir"
>>> re.match("güçlü", a)

```

Bu örnekte Python bize çıktı olarak “None” değerini vermişti. Yani
herhangi bir eşleşme bulamamıştı. Çünkü dediğimiz gibi, match() metodu
bir karakter dizisinin yalnızca en başına bakar. Ama geldiğimiz şu
noktada artık bu kısıtlamayı nasıl kaldıracağınızı biliyorsunuz:

```python
>>> re.match(".*güçlü", a)

```

Ama match() metodunu bu şekilde zorlamak yerine performans açısından en
doğru yol bu tür işler için search() metodunu kullanmak olacaktır.

Bunu da geçtiğimize göre artık yeni bir metakarakteri incelemeye
başlayabiliriz.

##### + (Artı)

Bu metakarakter, bir önceki metakarakterimiz olan “*” ile benzerdir.
Hatırlarsanız, “*” metakarakteri kendisinden önceki sıfır veya daha
fazla sayıda tekrar eden karakterleri ayıklıyordu. “+” metakarakteri ise
kendisinden önceki bir veya daha fazla sayıda tekrar eden karakterleri
ayıklar. Bildiğiniz gibi, önceki örneklerimizden birinde “ahmet” ve
“mehmet” öğelerini şu şekilde ayıklamıştık:

```python
>>> for i in liste:
... if re.match(".*met",i):
... print(i)

```

Burada “ahmet” ve “mehmet” dışında “met” şeklinde bir öğe de bu düzenli
ifadenin kapsamına girecektir. Mesela listemiz şöyle olsa idi:

```python
>>> liste = ["ahmet", "mehmet", "met", "kezban"]

```

Yukarıdaki düzenli ifade bu listedeki “met” öğesini de içine alacaktı.
Çünkü “*” adlı metakarakter sıfır sayıda tekrar eden karakterleri de
ayıklıyor. Ama bizim istediğimiz her zaman bu olmayabilir. Bazen de,
ilgili karakterin en az bir kez tekrar etmesini isteriz. Bu durumda
yukarıdaki düzenli ifadeyi şu şekilde yazmamız gerekir:

```python
>>> for i in liste:
... if re.match(".+met",i):
... print(i)

```

Burada şu komutu vermiş olduk: “ Bana sonu ‘met’ ile biten bütün öğeleri
ver! Ama bana ‘met’ öğesini yalnız başına verme!”

Aynı işlemi search() metodunu kullanarak da yapabileceğimizi
biliyorsunuz:

```python
>>> for i in liste:
... nesne = re.search(".+met",i)
... if nesne:
... nesne.group()
...
ahmet
mehmet

```

Bir de daha önce verdiğimiz şu örneğe bakalım:

```python
>>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"]
>>> for i in yeniliste:
... if re.match("sa*t",i):
... print(i)

```

Burada yazdığımız düzenli ifadenin özelliği nedeniyle “st” de kapsama
alanı içine giriyordu. Çünkü burada “*” sembolü “a” karakterinin hiç
bulunmadığı durumları da içine alıyor. Ama eğer biz “a” karakteri en az
bir kez geçsin istiyorsak, düzenli ifademizi şu şekilde yazmalıyız:

```python
>>> for i in yeniliste:
... if re.match("sa+t", i):
... print(i)

```

Hatırlarsanız önceki derslerimizden birinde köşeli parantezi anlatırken
şöyle bir örnek vermiştik:

```python
>>> a = ["23BH56", "TY76Z", "4Y7UZ", "TYUDZ", "34534"]
>>> for i in a:
... if re.match("[A-Z][A-Z][0-9]",i):
... print(i)

```

Burada amacımız sadece “TY76Z” öğesini almaktı. Dikkat ederseniz, öğenin
başındaki “T” ve “Y” harflerini bulmak için iki kez “[A-Z]” yazdık. Ama
artık “+” metakarakterini öğrendiğimize göre aynı işi daha basit bir
şekilde yapabiliriz:

```python
>>> for i in a:
... if re.match("[A-Z]+[0-9]",i):
... print(i)
...
TY76Z

```

Burada “[A-Z]” düzenli ifade kalıbını iki kez yazmak yerine bir kez
yazıp yanına da “+” sembolünü koyarak, bu ifade kalıbının bir veya daha
fazla sayıda tekrar etmesini istediğimizi belirttik…

“+” sembolünün ne iş yaptığını da anladığımıza göre, artık yeni bir
metakarakteri incelemeye başlayabiliriz.

##### ? (Soru İşareti)

Hatırlarsanız, “*” karakteri sıfır ya da daha fazla sayıda eşleşmeleri;
“+” ise bir ya da daha fazla sayıda eşleşmeleri kapsıyordu. İşte şimdi
göreceğimiz “?” sembolü de eşleşme sayısının sıfır veya bir olduğu
durumları kapsıyor. Bunu daha iyi anlayabilmek için önceden verdiğimiz
şu örneğe bakalım:

```python
>>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"]
>>> for i in yeniliste:
... if re.match("sa*t",i):
... print(i)
...
st
sat
saat
saaat

>>> for i in yeniliste:
... if re.match("sa+t",i):
... print(i)
...
sat
saat
saaat

```

“*” ve “+” sembollerinin hangi karakter dizilerini ayıkladığını
görüyoruz. Şimdi de “?” sembolünün ne yaptığına bakalım:

```python
>>> for i in yeniliste:
... if re.match("sa?t",i):
... print(i)
...
st
sat

```

Gördüğünüz gibi, “?” adlı metakarakterimiz, kendisinden önce gelen
karakterin hiç bulunmadığı (yani sıfır sayıda olduğu) ve bir adet
bulunduğu durumları içine alıyor. Bu yüzden de çıktı olarak bize sadece
“st” ve “sat” öğelerini veriyor.

Şimdi bu metakarakteri kullanarak gerçek hayatta karşımıza çıkabilecek
bir örnek verelim. Bu metakarakterin tanımına tekrar bakarsak, “olsa da
olur olmasa da olur” diyebileceğimiz durumlar için bu metakarakterin
rahatlıkla kullanılabileceğini görürüz. Şöyle bir örnek verelim: Diyelim
ki bir metin üzerinde arama yapacaksınız. Aradığınız kelime
“uluslararası”:

```python
metin = """Uluslararası hukuk, uluslar arası ilişkiler altında bir
disiplindir. Uluslararası ilişkilerin hukuksal boyutunu bilimsel bir
disiplin içinde inceler. Devletlerarası hukuk da denir. Ancak uluslar
arası ilişkilere yeni aktörlerin girişi bu dalı sadece devletlerarası
olmaktan çıkarmıştır."""

```

> **Not**
> Bu metinhttps://tr.wikipedia.org/wiki/Uluslararas%C4%B1_hukukadresinden alınıp üzerinde ufak değişiklikler yapılmıştır.

Not

Bu metinhttps://tr.wikipedia.org/wiki/Uluslararas%C4%B1_hukukadresinden alınıp üzerinde ufak değişiklikler yapılmıştır.

Şimdi yapmak istediğimiz şey “uluslararası” kelimesini bulmak. Ama
dikkat ederseniz metin içinde “uluslararası” kelimesi aynı zamanda
“uluslar arası” şeklinde de geçiyor. Bizim bu iki kullanımı da
kapsayacak bir düzenli ifade yazmamız gerekecek…

```python
>>> nesne = re.findall("[Uu]luslar ?arası", metin)
>>> for i in nesne:
... print(i)

```

Verdiğimiz düzenli ifade kalıbını dikkatlice inceleyin. Bildiğiniz gibi,
“?” metakarakteri, kendinden önce gelen karakterin (düzenli ifade
kalıbını) sıfır veya bir kez geçtiği durumları arıyor. Burada “?”
sembolünü “ “ karakterinden, yani “boşluk” karakterinden sonra
kullandık. Dolayısıyla, “boşluk karakterinin sıfır veya bir kez geçtiği
durumları” hedefledik. Bu şekilde hem “uluslar arası” hem de
“uluslararası” kelimesini ayıklamış olduk. Düzenli ifademizde ayrıca
şöyle bir şey daha yazdık: “[Uu]”. Bu da gerekiyor. Çünkü metnimiz
içinde “uluslararası” kelimesinin büyük harfle başladığı yerler de
var… Bildiğiniz gibi, “uluslar” ve “Uluslar” kelimeleri asla aynı
değildir. Dolayısıyla hem “u” harfini hem de “U” harfini bulmak için,
daha önce öğrendiğimiz “[]” metakarakterini kullanıyoruz.

##### { } (Küme Parantezi)

{ } adlı metakarakterimiz yardımıyla bir eşleşmeden kaç adet
istediğimizi belirtebiliyoruz. Yine aynı örnek üzerinden gidelim:

```python
>>> for i in yeniliste:
... if re.match("sa{3}t",i):
... print(i)
...
saaat

```

Burada “a” karakterinin 3 kez tekrar etmesini istediğimizi belirttik.
Python da bu emrimizi hemen yerine getirdi.

Bu metakarakterin ilginç bir özelliği daha vardır. Küme içinde iki
farklı sayı yazarak, bir karakterin en az ve en çok kaç kez tekrar
etmesini istediğimizi belirtebiliriz. Örneğin:

```python
>>> for i in yeniliste:
... if re.match("sa{0,3}t",i):
... print(i)
...
st
sat
saat
saaat

```

sa{0,3}t ifadesiyle, “a” harfinin en az sıfır kez, en çok da üç kez
tekrar etmesini istediğimiz söyledik. Dolayısıyla, “a” harfinin sıfır,
bir, iki ve üç kez tekrar ettiği durumlar ayıklanmış oldu. Bu sayı
çiftlerini değiştirerek daha farklı sonuçlar elde edebilirsiniz. Ayrıca
hangi sayı çiftinin daha önce öğrendiğimiz “?” metakarakteriyle aynı işi
yaptığını bulmaya çalışın…

##### ^ (Şapka)

^ sembolünün iki işlevi var. Birinci işlevi, bir karakter dizisinin en
başındaki veriyi sorgulamaktır. Yani aslında match() metodunun
varsayılan olarak yerine getirdiği işlevi bu metakarakter yardımıyla
açıkça belirterek yerine getirebiliyoruz. Şu örneğe bakalım:

```python
>>> a = ['23BH56', 'TY76Z', '4Y7UZ', 'TYUDZ',
... '34534', '1agAY54']
>>> for i in a:
... if re.search("[A-Z]+[0-9]",i):
... print(i)
...
23BH56
TY76Z
4Y7UZ
1agAY54

```

Bir de şuna bakalım:

```python
>>> for i in a:
... nesne = re.search("[A-Z]+[0-9]",i)
... if nesne:
... print(nesne.group())
...
BH5
TY7
Y7
AY5

```

Dikkat ederseniz, şu son verdiğimiz kod oldukça hassas bir çıktı verdi
bize. Çıktıdaki bütün değerler, aynen düzenli ifademizde belirttiğimiz
gibi, yan yana bir veya daha fazla harf içeriyor ve sonra da bir sayı
ile devam ediyor. Bu farklılığın nedeni, ilk kodlarda print(i) ifadesini
kullanmamız. Bu durumun çıktılarımızı nasıl değiştirdiğine dikkat edin.
Bir de şu örneğe bakalım:

```python
>>> for i in a:
... if re.match("[A-Z]+[0-9]",i):
... print(i)
...
TY76Z

```

Burada sadece “TY76Z” çıktısını almamızın nedeni, match() metodunun
karakter dizilerinin en başına bakıyor olması. Aynı etkiyi search()
metoduyla da elde etmek için, başlıkta geçen “^” (şapka) sembolünden
yararlanacağız:

```python
>>> for i in a:
... nesne = re.search("^[A-Z]+[0-9]",i)
... if nesne:
... print(nesne.group())
...
TY7

```

Gördüğünüz gibi, “^” (şapka) metakarakteri search() metodunun, karakter
dizilerinin sadece en başına bakmasını sağladı. O yüzden de bize sadece,
“TY7” çıktısını verdi. Hatırlarsanız aynı kodu, şapkasız olarak, şu
şekilde kullanmıştık yukarıda:

```python
>>> for i in a:
... nesne = re.search("[A-Z]+[0-9]",i)
... if nesne:
... print(nesne.group())
...
BH5
TY7
Y7
AY5

```

Gördüğünüz gibi, şapka sembolü olmadığında search() metodu karakter
dizisinin başına bakmakla yetinmiyor, aynı zamanda karakter dizisinin
tamamını tarıyor. Biz yukarıdaki koda bir “^” sembolü ekleyerek,
metodumuzun sadece karakter dizisinin en başına bakmasını istedik. O da
emrimize sadakatle uydu. Burada dikkatimizi çekmesi gereken başka bir
nokta da search() metodundaki çıktının kırpılmış olması. Dikkat
ettiyseniz, search() metodu bize öğenin tamamını vermedi. Öğelerin
yalnızca “[A-Z]+[0-9]” kalıbına uyan kısımlarını kesip attı önümüze.
Çünkü biz ona tersini söylemedik. Eğer öğelerin tamamını istiyorsak bunu
açık açık belirtmemiz gerekir:

```python
>>> for i in a:
... nesne = re.search("[A-Z]+[0-9].*",i)
... if nesne:
... print(nesne.group())
...
BH56
TY76Z
Y7UZ
AY54

```

Veya metodumuzun karakter dizisinin sadece en başına bakmasını istersek:

```python
>>> for i in a:
... nesne = re.search("^[A-Z]+[0-9].*",i)
... if nesne:
... print(nesne.group())
...
TY76Z

```

Bu kodlarda düzenli ifade kalıbının sonuna “.*” sembolünü eklediğimize
dikkat edin. Böylelikle metodumuzun sonu herhangi bir şekilde biten
öğeleri bize vermesini sağladık…

Başta da söylediğimiz gibi, “^” metakarakterinin, karakter dizilerinin
en başına demir atmak dışında başka bir görevi daha vardır: “Hariç”
anlamına gelmek… Bu görevini sadece “[]” metakarakterinin içinde
kullanıldığı zaman yerine getirir. Bunu bir örnekle görelim. Yukarıdaki
listemiz üzerinde öyle bir süzgeç uygulayalım ki, “1agAY54” öğesi
çıktılarımız arasında görünmesin… Bu öğeyi avlayabilmek için
kullanmamız gereken düzenli ifade şöyle olacaktır: [0-9A-Z][^a-z]+

```python
>>> for i in a:
... nesne = re.match("[0-9A-Z][^a-z]+",i)
... if nesne:
... print(nesne.group())

```

Burada şu ölçütlere sahip bir öğe arıyoruz:
1. Aradığımız öğe bir sayı veya büyük harf ile başlamalı
1. En baştaki sayı veya büyük harften sonra küçük harf GELMEMELİ (Bu
ölçütü “^” işareti sağlıyor)
1. Üstelik bu “küçük harf gelmeme durumu” bir veya daha fazla sayıda
tekrar etmeli… Yani baştaki sayı veya büyük harften sonra kaç tane
olursa olsun asla küçük harf gelmemeli (Bu ölçütü de “+” işareti
sağlıyor”)

Aradığımız öğe bir sayı veya büyük harf ile başlamalı

En baştaki sayı veya büyük harften sonra küçük harf GELMEMELİ (Bu
ölçütü “^” işareti sağlıyor)

Üstelik bu “küçük harf gelmeme durumu” bir veya daha fazla sayıda
tekrar etmeli… Yani baştaki sayı veya büyük harften sonra kaç tane
olursa olsun asla küçük harf gelmemeli (Bu ölçütü de “+” işareti
sağlıyor”)

Bu ölçütlere uymayan tek öğe “1agAY54” olacaktır. Dolayısıyla bu öğe
çıktıda görünmeyecek…

Burada, “^” işaretinin nasıl kullanıldığına ve küçük harfleri nasıl
dışarıda bıraktığına dikkat edin. Unutmayalım, bu “^” işaretinin “hariç”
anlamı sadece “[]” metakarakterinin içinde kullanıldığı zaman
geçerlidir.

##### $ (Dolar)

Bir önceki bölümde “^” işaretinin, karakter dizilerinin en başına demir
attığını söylemiştik. Yani bu sembol arama/eşleştirme işleminin karakter
dizisinin en başından başlamasını sağlıyordu. Bu sembol bir bakıma
karakter dizilerinin nasıl başlayacağını belirliyordu. İşte şimdi
göreceğimiz “dolar işareti” de ($) karakter dizilerinin nasıl biteceğini
belirliyor. Bu soyut açıklamaları somut bir örnekle bağlayalım:

```python
>>> liste = ["at", "katkı", "fakat", "atkı", "rahat",
... "mat", "yat", "sat", "satılık", "katılım"]

```

Gördüğünüz gibi, elimizde on öğelik bir liste var. Diyelim ki biz bu
listeden, “at” hecesiyle biten kelimeleri ayıklamak istiyoruz:

```python
>>> for i in liste:
... if re.search("at$",i):
... print(i)
...
at
fakat
rahat
mat
yat
sat

```

Burada “$” metakarakteri sayesinde aradığımız karakter dizisinin nasıl
bitmesi gerektiğini belirleyebildik. Eğer biz “at” ile başlayan bütün
öğeleri ayıklamak isteseydik ne yapmamız gerektiğini biliyorsunuz:

```python
>>> for i in liste:
... if re.search("^at",i):
... print(i)
...
at
atkı

```

Gördüğünüz gibi, “^” işareti bir karakter dizisinin nasıl başlayacağını
belirlerken, “$” işareti aynı karakter dizisinin nasıl biteceğini
belirliyor. Hatta istersek bu metakarakterleri birlikte de
kullanabiliriz:

```python
>>> for i in liste:
... if re.search("^at$",i):
... print(i)
...
at

```

Sonuç tam da beklediğimiz gibi oldu. Verdiğimiz düzenli ifade kalıbı ile
“at” ile başlayan ve aynı şekilde biten karakter dizilerini ayıkladık.
Bu da bize “at” çıktısını verdi.

##### \ (Ters Bölü)

Bu işaret bildiğimiz “kaçış dizisi”dir… Peki burada ne işi var?
Şimdiye kadar öğrendiğimiz konulardan gördüğünüz gibi, Python’daki
düzenli ifadeler açısından özel anlam taşıyan bir takım
semboller/metakarakterler var. Bunlar kendileriyle eşleşmiyorlar. Yani
bir karakter dizisi içinde bu sembolleri arıyorsak eğer, bunların
taşıdıkları özel anlam yüzünden bu sembolleri ayıklamak hemencecik
mümkün olmayacaktır. Yani mesela biz “$” sembolünü arıyor olsak, bunu
Python’a nasıl anlatacağız? Çünkü bu sembolü yazdığımız zaman Python
bunu farklı algılıyor. Lafı dolandırmadan hemen bir örnek verelim…

Diyelim ki elimizde şöyle bir liste var:

```python
>>> liste = ["10$", "25€", "20$", "10TL", "25£"]

```

Amacımız bu listedeki dolarlı değerleri ayıklamaksa ne yapacağız? Şunu
deneyelim önce:

```python
>>> for i in liste:
... if re.match("[0-9]+$",i):
... print(i)

```

Python “$” işaretinin özel anlamından dolayı, bizim sayıyla biten bir
karakter dizisi aradığımızı zannedecek, dolayısıyla da herhangi bir
çıktı vermeyecektir. Çünkü listemizde sayıyla biten bir karakter dizisi
yok… Peki biz ne yapacağız? İşte bu noktada “\” metakarakteri devreye
girecek… Hemen bakalım:

```python
>>> for i in liste:
... if re.match("[0-9]+\$",i):
... print(i)
...
10$
20$

```

Gördüğünüz gibi, “\” sembolünü kullanarak “$” işaretinin özel
anlamından kaçtık… Bu metakarakteri de kısaca anlattığımıza göre yeni
bir metakarakterle yolumuza devam edebiliriz…

##### | (Dik Çizgi)

Bu metakarakter, birden fazla düzenli ifade kalıbını birlikte
eşleştirmemizi sağlar. Bu ne demek? Hemen görelim:

```python
>>> liste = ["at", "katkı", "fakat", "atkı", "rahat",
... "mat", "yat", "sat", "satılık", "katılım"]
>>> for i in liste:
... if re.search("^at|at$",i):
... print(i)
...
at
fakat
atkı
rahat
mat
yat
sat

```

Gördüğünüz gibi “|” metakarakterini kullanarak başta ve sonda “at”
hecesini içeren kelimeleri ayıkladık. Aynı şekilde, mesela, renkleri
içeren bir listeden belli renkleri de ayıklayabiliriz bu metakarakter
yardımıyla…

```python
>>> for i in renkler:
... if re.search("kırmızı|mavi|sarı", i):
... print(i)

```

Sırada son metakarakterimiz olan “()” var…

##### ( ) (Parantez)

Bu metakarakter yardımıyla düzenli ifade kalıplarını gruplayacağız. Bu
metakarakter bizim bir karakter dizisinin istediğimiz kısımlarını
ayıklamamızda çok büyük kolaylıklar sağlayacak.

Diyelim ki bizhttps://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.htmladresindeki
bütün başlıkları ve bu başlıklara ait html dosyalarını bir liste halinde
almak istiyoruz. Bunun için şöyle bir şey yazabiliriz:

```python
import re
from urllib.request import urlopen

url = "https://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.html"
f = urlopen(url)

regex = 'href=".+html">.+</a>'

for i in f:
 nesne = re.search(regex, str(i, 'utf-8'))
 if nesne:
 print(nesne.group())

```

Burada yaptığımız şey şu:
1. Öncelikle “https://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.html” sayfasını urllib
modülü yardımıyla açtık. Amacımız bu sayfadaki başlıkları ve bu başlıklara ait
html dosyalarını listelemek
1. Ardından, bütün sayfayı taramak için basit bir for döngüsü kurduk
1. Düzenli ifade kalıbımızı şöyle yazdık:'<href=".+html">.+</a>'Çünkü bahsi geçen web sayfasındaki html uzantılı dosyalar bu şekilde
gösteriliyor. Bu durumu, web tarayıcınızdahttps://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.htmlsayfasını açıp
sayfa kaynağını görüntüleyerek teyit edebilirsiniz. (Firefox’ta
CTRL+U’ya basarak sayfa kaynağını görebilirsiniz)
1. Yazdığımız düzenli ifade kalıbı içinde dikkatimizi çekmesi gereken
bazı noktalar var: Kalıbın “(.+html)” kısmında geçen “+”
metakarakteri kendisinden önce gelen düzenli ifadenin bir veya daha
fazla sayıda tekrar eden eşleşmelerini buluyor. Burada “+”
metakarakterinden önce gelen düzenli ifade, kendisi de bir
metakarakter olan “.” sembolü… Bu sembol bildiğiniz gibi, “herhangi
bir karakter” anlamına geliyor. Dolayısıyla “.+” ifadesi şu demek
oluyor: “Bana bir veya daha fazla sayıda tekrar eden bütün
karakterleri bul!” Dolayısıyla burada “(.+html)” ifadesini birlikte
düşünürsek, yazdığımız şey şu anlama geliyor: “Bana ‘html’ ile biten
bütün karakter dizilerini bul!”
1. “https://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.html” adresinin
kaynağına baktığımız zaman aradığımız bilgilerin hep şu şekilde
olduğunu görüyoruz: href=”kitap_hakkinda.html”>Bu Kitap Hakkxc4xb1nda</a>
Dolayısıyla aslında düzenli ifade kalıbımızı yazarken yaptığımız şey,
düzenli ifademizi kaynakta görünen şablona uydurmak…
1. Ayrıca çıktıdaki Türkçe karakterlerin düzgün görünmesi için de bayt
dizilerini karakter dizisine dönüştürürken ‘utf-8’ kodlamasını kullandık.

Öncelikle “https://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.html” sayfasını urllib
modülü yardımıyla açtık. Amacımız bu sayfadaki başlıkları ve bu başlıklara ait
html dosyalarını listelemek

Ardından, bütün sayfayı taramak için basit bir for döngüsü kurduk

Düzenli ifade kalıbımızı şöyle yazdık:'<href=".+html">.+</a>'Çünkü bahsi geçen web sayfasındaki html uzantılı dosyalar bu şekilde
gösteriliyor. Bu durumu, web tarayıcınızdahttps://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.htmlsayfasını açıp
sayfa kaynağını görüntüleyerek teyit edebilirsiniz. (Firefox’ta
CTRL+U’ya basarak sayfa kaynağını görebilirsiniz)

Yazdığımız düzenli ifade kalıbı içinde dikkatimizi çekmesi gereken
bazı noktalar var: Kalıbın “(.+html)” kısmında geçen “+”
metakarakteri kendisinden önce gelen düzenli ifadenin bir veya daha
fazla sayıda tekrar eden eşleşmelerini buluyor. Burada “+”
metakarakterinden önce gelen düzenli ifade, kendisi de bir
metakarakter olan “.” sembolü… Bu sembol bildiğiniz gibi, “herhangi
bir karakter” anlamına geliyor. Dolayısıyla “.+” ifadesi şu demek
oluyor: “Bana bir veya daha fazla sayıda tekrar eden bütün
karakterleri bul!” Dolayısıyla burada “(.+html)” ifadesini birlikte
düşünürsek, yazdığımız şey şu anlama geliyor: “Bana ‘html’ ile biten
bütün karakter dizilerini bul!”

“https://web.archive.org/web/20121025012131/http://www.istihza.com/py2/icindekiler_python.html” adresinin
kaynağına baktığımız zaman aradığımız bilgilerin hep şu şekilde
olduğunu görüyoruz: href=”kitap_hakkinda.html”>Bu Kitap Hakkxc4xb1nda</a>
Dolayısıyla aslında düzenli ifade kalıbımızı yazarken yaptığımız şey,
düzenli ifademizi kaynakta görünen şablona uydurmak…

Ayrıca çıktıdaki Türkçe karakterlerin düzgün görünmesi için de bayt
dizilerini karakter dizisine dönüştürürken ‘utf-8’ kodlamasını kullandık.

Yukarıda verdiğimiz kodları çalıştırdığımız zaman aldığımız çıktı şu
şekilde oluyor:

```python
b'href="kitap_hakkinda.html">Bu Kitap Hakk\xc4\xb1nda</a>'
b'href="python_hakkinda.html">Python Hakk\xc4\xb1nda</a>'
...

```

Hemen hemen amacımıza ulaştık sayılır. Ama gördüğünüz gibi çıktımız
biraz karmaşık. Bunları istediğimiz gibi düzenleyebilsek iyi olurdu,
değil mi? Mesela bu çıktıları şu şekilde düzenleyebilmek hoş olurdu:

```python
Başlık: ANA SAYFA; Bağlantı: index.html

```

İşte bu bölümde göreceğimiz “( )” metakarakteri istediğimiz şeyi yapmada
bize yardımcı olacak.

Dilerseniz en başta verdiğimiz kodlara tekrar dönelim:

```python
import re
from urllib.request import urlopen

url = "http://belgeler.istihza.com/py3/index.html"
f = urlopen(url)

regex = 'href=".+html">.+</a>'

for i in f:
 nesne = re.search(regex, str(i, 'utf-8'))
 if nesne:
 print(nesne.group())

```

Şimdi bu kodlarda şu değişikliği yapıyoruz:

```python
import re
from urllib.request import urlopen

url = "http://belgeler.istihza.com/py3/index.html"
f = urlopen(url)

çıktı = "Başlık: {};\nBağlantı: {}\n"
regex = 'href="(.+html)">(.+)</a>'

for i in f:
 nesne = re.search(regex, str(i, 'utf-8'))
 if nesne:
 print(çıktı.format(nesne.group(2),
 nesne.group(1)))

```

Kodlarda yaptığımız değişikliklere dikkat edin ve anlamaya çalışın. Bazı
noktalar gözünüze karanlık göründüyse hiç endişe etmeyin, çünkü bir
sonraki bölümde bütün karanlık noktaları tek tek açıklayacağız. Burada
en azından, “( )” metakarakterini kullanarak düzenli ifadenin bazı
bölümlerini nasıl grupladığımıza dikkat edin.

Bu arada, elbette www.istihza.com sitesinde herhangi bir değişiklik
olursa yukarıdaki kodların istediğiniz çıktıyı vermeyeceğini
bilmelisiniz. Çünkü yazdığımız düzenli ifade istihza.com sitesinin sayfa
yapısıyla sıkı sıkıya bağlantılıdır.

#### Eşleşme Nesnelerinin Metotları

##### group() metodu

Bu bölümde doğrudan düzenli ifadelerin değil, ama düzenli ifadeler kullanılarak
üretilen eşleşme nesnelerinin bir metodu olangroup()metodundan
bahsedeceğiz. Esasında biz bu metodu önceki bölümlerde de kullanmıştık. Ama
burada bu metoda biraz daha ayrıntılı olarak bakacağız.

Daha önceki bölümlerden hatırlayacağınız gibi, bu metot düzenli ifadeleri
kullanarak eşleştirdiğimiz karakter dizilerini görme imkanı sağlıyordu. Bu
bölümde bu metodu “( )” metakarakteri yardımıyla daha verimli bir şekilde
kullanacağız. İsterseniz ilk olarak şöyle basit bir örnek verelim:

```python
>>> kardiz = "python bir programlama dilidir"
>>> nesne = re.search("(python) (bir) (programlama) (dilidir)", kardiz)
>>> print(nesne.group())

python bir programlama dilidir

```

Burada düzenli ifade kalıbımızı nasıl grupladığımıza dikkat edin.print(nesne.group())komutunu verdiğimizde eşleşen karakter dizileri ekrana
döküldü. Şimdi bu grupladığımız bölümlere tek tek erişelim:

```python
>>> nesne.group(0)

'python bir programlama dilidir'

```

Gördüğünüz gibi, “0” indeksi eşleşen karakter dizisinin tamamını veriyor. Bir de
şuna bakalım:

```python
>>> nesne.group(1)

'python'

```

Burada 1 numaralı grubun öğesi olan “python”u aldık. Gerisinin nasıl olacağını
tahmin edebilirsiniz:

```python
>>> nesne.group(2)

'bir'

>>> nesne.group(3)

'programlama'

>>> nesne.group(4)

'dilidir'

```

Bu metodun bize ilerde ne büyük kolaylıklar sağlayacağını az çok tahmin
ediyorsunuzdur. İsterseniz kullanabileceğimiz metotları tekrar listeleyelim:

```python
>>> dir(nesne)

```

Bu listedegroup()dışında bir degroups()adlı bir metodun olduğunu
görüyoruz. Şimdi bunun ne iş yaptığına bakalım.

##### groups() metodu

Bu metot, bize kullanabileceğimiz bütün grupları bir demet halinde sunar:

```python
>>> nesne.groups()

('python', 'bir', 'programlama', 'dilidir')

```

Şimdi isterseniz bir önceki bölümde yaptığımız örneğe geri dönelim:

```python
import re
from urllib.request import urlopen

url = "http://belgeler.istihza.com/py3/index.html"
f = urlopen(url)

çıktı = "Başlık: {};\nBağlantı: {}\n"
regex = 'href="(.+html)">(.+)</a>'

for i in f:
 nesne = re.search(regex, str(i, 'utf-8'))
 if nesne:
 print(çıktı.format(nesne.group(2),
 nesne.group(1)))

```

Bu kodlarda son satırı şöyle değiştirelim:

```python
import re
from urllib.request import urlopen

url = "http://belgeler.istihza.com/py3/index.html"
f = urlopen(url)

çıktı = "Başlık: {};\nBağlantı: {}\n"
regex = 'href="(.+html)">(.+)</a>'

for i in f:
 nesne = re.search(regex, str(i, 'utf-8'))
 if nesne:
 print(nesne.groups())

```

Gördüğünüz gibi şuna benzer çıktılar elde ediyoruz:

```python
('kitap_hakkinda.html', 'Bu Kitap Hakkında')
('python_hakkinda.html', 'Python Hakkında')
('temel_komut_satiri_bilgisi.html', 'Temel Komut Satırı Bilgisi')
('path.html', 'YOL (<em>PATH</em>) Kavramı')
('kurulum.html', 'Python Nasıl Kurulur?')
...
...
...

```

Demek ki (nesne.groups()) komutu bize “( )” metakarakteri ile daha önceden
gruplamış olduğumuz öğeleri bir demet olarak veriyor. Biz de bu demetin
öğelerine daha sonradan rahatlıkla erişebiliyoruz…

Böylece eşleştirme nesnelerinin en sık kullanılan iki metodunu görmüş olduk.
Bunları daha sonraki örneklerimizde de bol bol kullanacağız. O yüzden şimdilik
bu konuya ara verelim.

#### Özel Diziler

Düzenli ifadeler içinde metakarakterler dışında, özel anlamlar taşıyan
bazı başka ifadeler de vardır. Bu bölümde bu özel dizileri
inceleyeceğiz: Boşluk karakterinin yerini tutan özel dizi: \s

Bu sembol, bir karakter dizisi içinde geçen boşlukları yakalamak için
kullanılır. Örneğin:

```python
>>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"]
>>> for i in a:
... nesne = re.search("[0-9]\\s[A-Za-z]+",i)
... if nesne:
... print(nesne.group())
...
5 Ocak
4 Ekim

```

Yukarıdaki örnekte, bir sayı ile başlayan, ardından bir adet boşluk karakteri
içeren, sonra da bir büyük veya küçük harfle devam eden karakter dizilerini
ayıkladık. Burada boşluk karakterini “\s” simgesi ile gösterdiğimize dikkat
edin.

##### Ondalık Sayıların Yerini Tutan Özel Dizi: \d

Bu sembol, bir karakter dizisi içinde geçen ondalık sayıları eşleştirmek için
kullanılır. Buraya kadar olan örneklerde bu işlevi yerine getirmek için “[0-9]”
ifadesinden yararlanıyorduk. Şimdi artık aynı işlevi daha kısa yoldan, “\d”
dizisi ile yerine getirebiliriz. İsterseniz yine yukarıdaki örnekten gidelim:

```python
>>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"]
>>> for i in a:
... nesne = re.search("\d\s[A-Za-z]+",i)
... if nesne:
... print(nesne.group())
...
5 Ocak
4 Ekim

```

Burada, “[0-9]” yerine “\d” yerleştirerek daha kısa yoldan sonuca vardık.

##### Alfanümerik Karakterlerin Yerini Tutan Özel Dizi: \w

Bu sembol, bir karakter dizisi içinde geçen alfanümerik karakterleri ve buna ek
olarak “_” karakterini bulmak için kullanılır. Şu örneğe bakalım:

```python
>>> a = "abc123_$%+"
>>> print(re.search("\w*", a).group())

abc123_

```

“\w” özel dizisinin hangi karakterleri eşlediğine dikkat edin. Bu özel dizi şu
ifadeyle aynı anlama gelir:

```python
[A-Za-z0-9_]

```

Düzenli ifadeler içindeki özel diziler genel olarak bunlardan ibarettir. Ama bir
de bunların büyük harfli versiyonları vardır ki, önemli oldukları için onları da
inceleyeceğiz.

Gördüğünüz gibi;
1. “\s” özel dizisi boşluk karakterlerini avlıyor
1. “\d” özel dizisi ondalık sayıları avlıyor
1. “\w” özel dizisi alfanümerik karakterleri ve “_” karakterini
avlıyor

“\s” özel dizisi boşluk karakterlerini avlıyor

“\d” özel dizisi ondalık sayıları avlıyor

“\w” özel dizisi alfanümerik karakterleri ve “_” karakterini
avlıyor

Dedik ki, bir de bunların büyük harfli versiyonları vardır. İşte bu büyük harfli
versiyonlar da yukarıdaki dizilerin yaptığı işin tam tersini yapar. Yani:
1. “\S” özel dizisi boşluk olmayan karakterleri avlar
1. “\D” özel dizisi ondalık sayı olmayan karakterleri avlar. Yani
“[^0-9]” ile eşdeğerdir.
1. “\W” özel dizisi alfanümerik olmayan karakterleri ve “_” olmayan
karakterleri avlar. Yani[^A-Za-z0-9_]ile eşdeğerdir.

“\S” özel dizisi boşluk olmayan karakterleri avlar

“\D” özel dizisi ondalık sayı olmayan karakterleri avlar. Yani
“[^0-9]” ile eşdeğerdir.

“\W” özel dizisi alfanümerik olmayan karakterleri ve “_” olmayan
karakterleri avlar. Yani[^A-Za-z0-9_]ile eşdeğerdir.

“\D” ve “\W” dizilerinin yeterince anlaşılır olduğunu zannediyorum. Burada
sanırım sadece “S” dizisi bir örnekle somutlaştırılmayı hakediyor:

```python
>>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"]
>>> for i in a:
... nesne = re.search("\d+\S\w+",i)
... if nesne:
... print(nesne.group())
...
27Mart

```

Burada “\S” özel dizisinin listede belirtilen konumda boşluk içermeyen öğeyi
nasıl bulduğuna dikkat edin.

Şimdi bu özel diziler için genel bir örnek verip konuyu kapatalım…

Bilgisayarımızda şu bilgileri içeren “adres.txt” adlı bir dosya olduğunu
varsayıyoruz:

```python
esra : istinye 05331233445 esma : levent 05322134344 sevgi : dudullu
05354445434 kemal : sanayi 05425455555 osman : tahtakale 02124334444
metin : taksim 02124344332 kezban : caddebostan 02163222122

```

Amacımız bu dosyada yer alan isim ve telefon numaralarını “isim > telefon
numarası” şeklinde almak:

```python
import re
dosya = open("adres.txt")
for i in dosya.readlines():
 nesne = re.search("(\w+)\s+:\s(\w+)\s+(\d+)",i)
 if nesne:
 print("{} > {}".format(nesne.group(1), nesne.group(3)))

```

Burada formülümüz şu şekilde: “Bir veya daha fazla karakter” + “bir veya daha
fazla boşluk” + “’:’ işareti” + “bir adet boşluk” + “bir veya daha fazla sayı”

İsterseniz bu bölümü çok basit bir soruyla kapatalım. Sorumuz şu:

Elimizde şu adresteki yığın var:https://web.archive.org/web/20130511050633/http://www.istihza.com/denemeler/yigin.txt

Yapmanız gereken, bu yığın içindeki gizli mesajı düzenli ifadeleri
kullanarak bulmak…

#### Düzenli İfadelerin Derlenmesi

##### compile() metodu

En başta da söylediğimiz gibi, düzenli ifadeler karakter dizilerine göre
biraz daha yavaş çalışırlar. Ancak düzenli ifadelerin işleyişini
hızlandırmanın da bazı yolları vardır. Bu yollardan biri de compile()
metodunu kullanmaktır. “compile” kelimesi İngilizcede “derlemek”
anlamına gelir. İşte biz de bucompile()metodu yardımıyla düzenli ifade
kalıplarımızı kullanmadan önce derleyerek daha hızlı çalışmalarını
sağlayacağız. Küçük boyutlu projelerdecompile()metodu pek hissedilir
bir fark yaratmasa da özellikle büyük çaplı programlarda bu metodu
kullanmak oldukça faydalı olacaktır.

Basit bir örnekle başlayalım:

```python
>>> liste = ["Python2.7", "Python3.2", "Python3.3",
... "Python3.4", "Java"]
>>> derli = re.compile("[A-Za-z]+[0-9]\.[0-9]")
>>> for i in liste:
... nesne = derli.search(i)
... if nesne:
... print(nesne.group())
...
Python2.7
Python3.2
Python3.3
Python3.4

```

Burada öncelikle düzenli ifade kalıbımızı derledik. Derleme işlemini nasıl
yaptığımıza dikkat edin. Derlenecek düzenli ifade kalıbınıcompile()metodunda parantez içinde belirtiyoruz. Daha sonrasearch()metodunu
kullanırken ise, re.search() demek yerine,derli.search()şeklinde bir ifade
kullanıyoruz. Ayrıca dikkat edersenizderli.search()kullanımında parantez
içinde sadece eşleşecek karakter dizisini kullandık (i). Eğer derleme işlemi
yapmamış olsaydık, hem bu karakter dizisini, hem de düzenli ifade kalıbını yan
yana kullanmamız gerekecektir. Ama düzenli ifade kalıbımızı yukarıda derleme
işlemi esnasında belirttiğimiz için, bu kalıbı ikinci kez yazmamıza gerek
kalmadı. Ayrıca burada kullandığımız düzenli ifade kalıbına da dikkat edin.
Nasıl bir şablon oturttuğumuzu anlamaya çalışın. Gördüğünüz gibi, liste
öğelerinde bulunan “.” işaretini eşleştirmek için düzenli ifade kalıbı içinde
“\.” ifadesini kullandık. Çünkü bildiğiniz gibi, tek başına “.” işaretinin
Python açısından özel bir anlamı var. Dolayısıyla bu özel anlamdan kaçmak için
“\” işaretini de kullanmamız gerekiyor.

##### compile() ile Derleme Seçenekleri

Bir önceki bölümdecompile() metodunun ne olduğunu, ne işe yaradığını ve
nasıl kullanıldığını görmüştük. Bu bölümde ise “compile” (derleme) işlemi
sırasında kullanılabilecek seçenekleri anlatacağız.

###### re.IGNORECASE veya re.I

Bildiğiniz gibi, Python’da büyük-küçük harfler önemlidir. Yani eğer “python”
kelimesini arıyorsanız, alacağınız çıktılar arasında “Python” olmayacaktır.
Çünkü “python” ve “Python” birbirlerinden farklı iki karakter dizisidir. İştere.IGNORECASEveya kısacare.Iadlı derleme seçenekleri bize büyük-küçük
harfe dikkat etmeden arama yapma imkanı sağlar. Hemen bir örnek verelim:

```python
import re

metin = """Programlama dili, programcının bir bilgisayara ne yapmasını
istediğini anlatmasının standartlaştırılmış bir yoludur. Programlama
dilleri, programcının bilgisayara hangi veri üzerinde işlem yapacağını,
verinin nasıl depolanıp iletileceğini, hangi koşullarda hangi işlemlerin
yapılacağını tam olarak anlatmasını sağlar. Şu ana kadar 2500’den fazla
programlama dili yapılmıştır. Bunlardan bazıları: Pascal, Basic, C, C#,
C++, Java, Cobol, Perl, Python, Ada, Fortran, Delphi programlama
dilleridir."""

derli = re.compile("programlama",re.IGNORECASE)
print(derli.findall(metin))

```

Bu programı çalıştırdığımızda şu çıktıyı alıyoruz:

```python
['Programlama', 'Programlama', 'programlama', 'programlama']

```

> **Not**
> Bu metinhttps://tr.wikipedia.org/wiki/Programlama_diliadresinden
alınmıştır.

Not

Bu metinhttps://tr.wikipedia.org/wiki/Programlama_diliadresinden
alınmıştır.

Gördüğünüz gibi, metinde geçen hem “programlama” kelimesini hem de “Programlama”
kelimesini ayıklayabildik. Bunu yapmamızı sağlayan şey dere.IGNORECASEadlı
derleme seçeneği oldu. Eğer bu seçeneği kullanmasaydık, çıktıda yalnızca
“programlama” kelimesini görürdük. Çünkü aradığımız şey aslında “programlama”
kelimesi idi. Biz istersekre.IGNORECASEyerine kısacare.Iifadesini de
kullanabiliriz. Aynı anlama gelecektir…

###### re.DOTALL veya re.S

Bildiğiniz gibi, metakarakterler arasında yer alan “.” sembolü herhangi
bir karakterin yerini tutuyordu. Bu metakarakter bütün karakterlerin
yerini tutmak üzere kullanılabilir. Hatırlarsanız, “.” metakarakterini
anlatırken, bu metakarakterin, yeni satır karakterinin yerini
tutmayacağını söylemiştik. Bunu bir örnek yardımıyla görelim. Diyelim ki
elimizde şöyle bir karakter dizisi var:

```python
>>> a = "Ben Python,\nMonty Python"

```

Bu karakter dizisi içinde “Python” kelimesini temel alarak bir arama
yapmak istiyorsak eğer, kullanacağımız şu kod istediğimiz şeyi yeterince
yerine getiremeyecektir:

```python
>>> print(re.search("Python.*", a).group())

```

Bu kod şu çıktıyı verecektir:

```python
Python,

```

Bunun sebebi, “.” metakarakterinin“\n”(yeni satır) kaçış dizisini dikkate
almamasıdır. Bu yüzden bu kaçış dizisinin ötesine geçip orada arama yapmıyor.
Ama şimdi biz ona bu yeteneği de kazandıracağız:

```python
>>> derle = re.compile("Python.*", re.DOTALL)
>>> nesne = derle.search(a)
>>> if nesne:
... print(nesne.group())

```

re.DOTALLseçeneğini sadece re.S şeklinde de kısaltabilirsiniz…

#### Düzenli İfadelerle Metin/Karakter Dizisi Değiştirme İşlemleri

##### sub() metodu

Şimdiye kadar hep düzenli ifadeler yoluyla bir karakter dizisini nasıl
eşleştireceğimizi inceledik. Ama tabii ki düzenli ifadeler yalnızca bir karakter
dizisi “bulmak”la ilgili değildir. Bu araç aynı zamanda bir karakter dizisini
“değiştirmeyi” de kapsar. Bu iş için temel olarak iki metot kullanılır.
Bunlardan ilkisub()metodudur. Bu bölümdesub()metodunu inceleyeceğiz.

En basit şekliylesub()metodunu şu şekilde kullanabiliriz:

```python
>>> a = "Kırmızı başlıklı kız, kırmızı elma dolu sepetiyle \
... anneannesinin evine gidiyormuş!"
>>> derle = re.compile("kırmızı", re.IGNORECASE)
>>> print(derle.sub("yeşil", a))

```

Burada karakter dizimiz içinde geçen bütün “kırmızı” kelimelerini “yeşil”
kelimesiyle değiştirdik. Bunu yaparken de re.IGNORECASE adlı derleme
seçeneğinden yararlandık.

Elbettesub()metoduyla daha karmaşık işlemler yapılabilir. Bu noktada şöyle
bir hatırlatma yapalım. Busub()metodu karakter dizilerininreplace()metoduna çok benzer. Ama tabii kisub()metodu hem kendi başınareplace()metodundan çok daha güçlüdür, hem de beraber kullanılabilecek
derleme seçenekleri sayesindereplace()metodundan çok daha esnektir. Ama
tabii ki, eğer yapmak istediğiniz işreplace()metoduyla halledilebiliyorsa
en doğru yol,replace()metodunu kullanmaktır…

Şimdi busub()metodunu kullanarak biraz daha karmaşık bir işlem yapacağız.
Aşağıdaki metne bakalım:

```python
metin = """Karadeniz Ereğlisi denince akla ilk olarak kömür ve demir-çelik
gelir. Kokusu ve tadıyla dünyaya nam salmış meşhur Osmanlı çileği ise ismini
verdiği festival günleri dışında pek hatırlanmaz. Oysa Çin'den Arnavutköy'e
oradan da Ereğli'ye getirilen kralların meyvesi çilek, burada geçirdiği değişim
sonucu tadına doyulmaz bir hal alır. Ereğli'nin havasından mı suyundan mı
bilinmez, kokusu, tadı bambaşka bir hale dönüşür ve meşhur Osmanlı çileği
unvanını hak eder. Bu nazik ve aromalı çilekten yapılan reçel de likör de bir
başka olur. Bu yıl dokuzuncusu düzenlenen Uluslararası Osmanlı Çileği Kültür
Festivali'nde 36 üretici arasında yetiştirdiği çileklerle birinci olan Kocaali
Köyü'nden Güner Özdemir, yılda bir ton ürün alıyor. 60 yaşındaki Özdemir,
çileklerinin sırrını yoğun ilgiye ve içten duyduğu sevgiye bağlıyor: "Erkekler
bahçemize giremez. Koca ayaklarıyla ezerler çileklerimizi" Çileği toplamanın zor
olduğunu söyleyen Ayşe Özhan da çocukluğundan bu yana çilek bahçesinde
çalışıyor. Her sabah 04.00'te kalkan Özhan, çileklerini özenle suluyor. Kasım
başında ektiği çilek fideleri haziran başında meyve veriyor."""

```

> **Not**
> Bu metinhttps://web.archive.org/web/20161013002254/http://www.radikal.com.tr:80/haber.php?haberno=40130adresinden alınmıştır.

Not

Bu metinhttps://web.archive.org/web/20161013002254/http://www.radikal.com.tr:80/haber.php?haberno=40130adresinden alınmıştır.

Gelin bu metin içinde geçen “çilek” kelimelerini “erik” kelimesi ile
değiştirelim. Ama bunu yaparken, metin içinde “çilek” kelimesinin
“Çilek” şeklinde de geçtiğine dikkat edelim. Ayrıca Türkçe kuralları
gereği bu “çilek” kelimesinin bazı yerlerde ünsüz yumuşamasına uğrayarak
“çileğ-” şekline dönüştüğünü de unutmayalım.

Bu metin içinde geçen “çilek” kelimelerini “erik”le değiştirmek için
birkaç yol kullanabilirsiniz. Birinci yolda, her değişiklik için ayrı
bir düzenli ifade oluşturulabilir. Ancak bu yolun dezavantajı, metnin de
birkaç kez kopyalanmasını gerektirmesidir. Çünkü ilk düzenli ifade
oluşturulup buna göre metinde bir değişiklik yapıldıktan sonra, ilk
değişiklikleri içeren metnin, farklı bir metin olarak kopyalanması
gerekir (metin2 gibi…). Ardından ikinci değişiklik yapılacağı zaman,
bu değişikliğin metin2 üzerinden yapılması gerekir. Aynı şekilde bu
metin de, mesela, metin3 şeklinde tekrar kopyalanmalıdır. Bundan sonraki
yeni bir değişiklik de bu metin3 üzerinden yapılacaktır… Bu durum bu
şekilde uzar gider… Metni tekrar tekrar kopyalamak yerine, düzenli
ifadeleri kullanarak şöyle bir çözüm de üretebiliriz:

```python
import re

derle = re.compile("çile[kğ]", re.IGNORECASE)

def degistir(nesne):
 a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"}
 b = nesne.group().split()
 for i in b:
 return a[i]

print(derle.sub(degistir, metin))

```

Gördüğünüz gibi,sub()metodu, argüman olarak bir fonksiyon da alabiliyor.
Yukarıdaki kodlar biraz karışık görünmüş olabilir. Tek tek açıklayalım…

Öncelikle şu satıra bakalım:

```python
derle = re.compile("çile[kğ]", re.IGNORECASE)

```

Burada amacımız, metin içinde geçen “çilek” ve “çileğ” kelimelerini
bulmak. Neden “çileğ”? Çünkü “çilek” kelimesi bir sesli harften önce
geldiğinde sonundaki “k” harfi “ğ”ye dönüşüyor. Bu seçenekli yapıyı,
daha önceki bölümlerde gördüğümüz “[ ]” adlı metakarakter yardımıyla
oluşturduk. Düzenli ifade kalıbımızın hem büyük harfleri hem de küçük
harfleri aynı anda bulması için re.IGNORECASE seçeneğinden yararlandık.

Şimdi de şu satırlara bakalım:

```python
def degistir(nesne):
 a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"}
 b = nesne.group().split()
 for i in b:
 return a[i]

```

Burada, daha sonrasub()metodu içinde kullanacağımız fonksiyonu yazıyoruz.
Fonksiyonu,defdegistir(nesne)şeklinde tanımladık. Burada “nesne” adlı bir
argüman kullanmamızın nedeni, fonksiyon içindegroup()metodunu kullanacak
olmamız. Bu metodu fonksiyon içinde “nesne” adlı argümana bağlayacağız. Bu
fonksiyon, daha sonra yazacağımızsub()metodu tarafından çağrıldığında,
yaptığımız arama işlemi sonucunda ortaya çıkan “eşleşme nesnesi” fonksiyona
atanacaktır (eşleşme nesnesinin ne demek olduğunu ilk bölümlerden
hatırlıyorsunuz). İşte “nesne” adlı bir argüman kullanmamızın nedeni de, eşleşme
nesnelerinin bir metodu olangroup()metodunu fonksiyon içinde
kullanabilmek…

Bir sonraki satırda bir adet sözlük görüyoruz:

```python
a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"}

```

Bu sözlüğü oluşturmamızın nedeni, metin içinde geçen bütün “çilek” kelimelerini
tek bir “erik” kelimesiyle değiştiremeyecek olmamız… Çünkü “çilek” kelimesi
metin içinde pek çok farklı biçimde geçiyor. Başta da dediğimiz gibi, yukarıdaki
yol yerine metni birkaç kez kopyalayarak ve her defasında bir değişiklik yaparak
da sorunu çözebilirsiniz. (Mesela önce “çilek” kelimelerini bulup bunları “erik”
ile değiştirirsiniz. Daha sonra “çileğ” kelimelerini arayıp bunları “eriğ” ile
değiştirirsiniz, vb…) Ama metni tekrar tekrar oluşturmak pek performanslı bir
yöntem olmayacaktır. Bizim şimdi kullandığımız yöntem metin kopyalama
zorunluluğunu ortadan kaldırıyor. Bu sözlük içinde “çilek” kelimesinin alacağı
şekilleri sözlük içinde birer anahtar olarak, “erik” kelimesinin alacağı
şekilleri ise birer “değer” olarak belirliyoruz.

Sonraki satırda iki metot birden var:

```python
b = nesne.group().split()

```

Burada, fonksiyonumuzun argümanı olarak vazife gören eşleşme nesnesine ait
metotlardan biri olangroup() metodunu kullanıyoruz. Böylecederle=re.compile("çile[kğ]",re.IGNORECASE)satırı yardımıyla metin içinde
bulduğumuz bütün “çilek” ve çeşitlerini alıyoruz. Karakter dizilerininsplit() metodunu kullanmamızın nedeni isegroup()metodunun verdiği
çıktıyı liste haline getirip daha kolay manipüle etmek. Buradaforiinb:print(i)komutunu verirsenizgroup()metodu yardımıyla ne bulduğumuzu
görebilirsiniz:

```python
çileğ
çilek
çileğ
çilek
Çileğ
çilek
çilek
çilek
Çileğ
çilek
çilek
çilek

```

Bu çıktıyı gördükten sonra, kodlarda yapmaya çalıştığımız şey daha anlamlı
görünmeye başlamış olmalı… Şimdi sonraki satıra geçiyoruz:

```python
for i in b:
 return a[i]

```

Burada,group()metodu yardımıyla bulduğumuz eşleşmeler üzerinde bir for
döngüsü oluşturduk. Ardından dareturna[i]komutunu vererek “a” adlı sözlük
içinde yer alan öğeleri yazdırıyoruz. Bu arada, buradaki “i”nin yukarıda
verdiğimizgroup()çıktılarını temsil ettiğine dikkat edin.a[i]gibi
bir komut verdiğimizde aslında sırasıyla şu komutları vermiş oluyoruz:

```python
a["çilek"]
a["çileğ"]
a["çilek"]
a["Çileğ"]
a["çilek"]
a["çilek"]
a["çilek"]
a["Çileğ"]
a["çilek"]
a["çilek"]

```

Bu komutların çıktıları sırasıyla “erik”, “eriğ”, “erik”, “Eriğ”, “erik”,
“erik”, “erik”, “Eriğ”, “erik”, “erik” olacaktır. İşte bu return satırı bir
sonraki kod olanprint(derle.sub(degistir,metin))ifadesinde etkinlik
kazanacak. Bu son satırımız sözlük öğelerini tek tek metne uygulayacak ve meselaa["çilek"]komutu sayesinde metin içinde “çilek” gördüğü yerde “erik”
kelimesini yapıştıracak ve böylece bize istediğimiz şekilde değiştirilmiş bir
metin verecektir…

Bu kodların biraz karışık gibi göründüğünü biliyorum, ama aslında çok basit bir
mantığı var:group()metodu ile metin içinde aradığımız kelimeleri
ayıklıyor. Ardından da “a” sözlüğü içinde bunları anahtar olarak kullanarak
“çilek” ve çeşitleri yerine “erik” ve çeşitlerini koyuyor…

Yukarıda verdiğimiz düzenli ifadeyi böyle ufak bir metinde kullanmak çok
anlamlı olmayabilir. Ama çok büyük metinler üzerinde çok çeşitli ve
karmaşık değişiklikler yapmak istediğinizde bu kodların işinize
yarayabileceğini göreceksiniz.

##### subn() metodu

Bu metodu çok kısa bir şekilde anlatıp geçeceğiz. Çünkü bu metotsub()metoduyla neredeyse tamamen aynıdır. Tek farkı,subn()metodunun bir metin
içinde yapılan değişiklik sayısını da göstermesidir. Yani bu metodu kullanarak,
kullanıcılarınıza “toplam şu kadar sayıda değişiklik yapılmıştır” şeklinde bir
bilgi verebilirsiniz. Bu metot çıktı olarak iki öğeli bir demet verir. Birinci
öğe değiştirilen metin, ikinci öğe ise yapılan değişiklik sayısıdır. Yani
kullanıcıya değişiklik sayısını göstermek için yapmanız gereken şey, bu demetin
ikinci öğesini almaktır. Meselasub()metodunu anlatırken verdiğimiz
kodların son satırını şöyle değiştirebilirsiniz:

```python
ab = derle.subn(degistir, metin)
print("Toplam {} değişiklik yapılmıştır.".format(ab[1]))

```

Yani:

```python
import re

metin = """Karadeniz Ereğlisi denince akla ilk olarak kömür ve demir-çelik
gelir. Kokusu ve tadıyla dünyaya nam salmış meşhur Osmanlı çileği ise ismini
verdiği festival günleri dışında pek hatırlanmaz. Oysa Çin'den Arnavutköy'e
oradan da Ereğli'ye getirilen kralların meyvesi çilek, burada geçirdiği değişim
sonucu tadına doyulmaz bir hal alır. Ereğli'nin havasından mı suyundan mı
bilinmez, kokusu, tadı bambaşka bir hale dönüşür ve meşhur Osmanlı çileği
unvanını hak eder. Bu nazik ve aromalı çilekten yapılan reçel de likör de bir
başka olur. Bu yıl dokuzuncusu düzenlenen Uluslararası Osmanlı Çileği Kültür
Festivali'nde 36 üretici arasında yetiştirdiği çileklerle birinci olan Kocaali
Köyü'nden Güner Özdemir, yılda bir ton ürün alıyor. 60 yaşındaki Özdemir,
çileklerinin sırrını yoğun ilgiye ve içten duyduğu sevgiye bağlıyor: "Erkekler
bahçemize giremez. Koca ayaklarıyla ezerler çileklerimizi" Çileği toplamanın zor
olduğunu söyleyen Ayşe Özhan da çocukluğundan bu yana çilek bahçesinde
çalışıyor. Her sabah 04.00'te kalkan Özhan, çileklerini özenle suluyor. Kasım
başında ektiği çilek fideleri haziran başında meyve veriyor."""

derle = re.compile("çile[kğ]", re.IGNORECASE)

def degistir(nesne):
 a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"}
 b = nesne.group().split()
 for i in b:
 return a[i]

ab = derle.subn(degistir, metin)
print("Toplam {} değişiklik yapılmıştır.".format(ab[1]))

```

#### Sonuç

Böylelikle düzenli ifadeler konusunu bitirmiş olduk. Buradaki amacımız, size
düzenli ifadeler konusunda genel bir bakış sunabilmekti. Bu yazıları okuduktan
sonra kafanızda düzenli ifadelerle ilgili kabataslak da olsa bir resim oluştuysa
bu yazılar amacına ulaşmış demektir. Elbette düzenli ifadeler burada
anlattıklarımızdan ibaret değildir. Bu konunun üzerine eğildiğinizde aslında
düzenli ifadelerin dipsiz bir kuyu gibi olduğunu göreceksiniz. Esasında en başta
da dediğimiz gibi, düzenli ifadeler apayrı bir dil gibidir. Doğrusu şu ki,
düzenli ifadeler başlı başına bağımsız bir sistemdir. Hemen hemen bütün
programlama dilleri öyle ya da böyle düzenli ifadeleri destekler. Python’da
düzenli ifadeleri bünyesine adapte etmiş dillerden biridir. Bizim düzenli
ifadeler konusundaki yaklaşımımız, her zaman bunları “gerektiğinde” kullanmak
olmalıdır. Dediğimiz gibi, eğer yapmak istediğiniz bir işlemi karakter
dizilerinin metotları yardımıyla yapabiliyorsanız düzenli ifadelere girişmemek
en iyisidir. Çünkü karakter dizisi metotları hem daha hızlıdır hem de anlaması
daha kolaydır.

### datetime Modülü

Bu bölümde, zaman, saat ve tarihlerle ilgili işlemler yapmamızı sağlayan
önemli bir standart kütüphane modülünden söz edeceğiz. Bu modülün adıdatetime.

datetimemodülü; zaman, saat ve tarihlerle ilgili işlemler yapabilmemiz
için bize çeşitli fonksiyon ve nitelikler sunan bazı sınıflardan oluşur. Bu
modül içinde temel olarak üç farklı sınıf bulunur.

> **Not**
> ‘Sınıf’ kavramına çok takılmayın. İlerleyen derslerde sınıflardan
ayrıntılı olarak söz edeceğiz.

Not

‘Sınıf’ kavramına çok takılmayın. İlerleyen derslerde sınıflardan
ayrıntılı olarak söz edeceğiz.

datetimemodülü içinde yer alan bu üç sınıf şunlardır:
1. datesınıfı; tarihle ilgili işlemler yapabilmemizi sağlayan fonksiyon ve nitelikleri barındırır.
1. timesınıfı; zamanla/saatle ilgili işlemler yapabilmemizi sağlayan fonksiyon ve nitelikleri barındırır.
1. datetimesınıfı;datevetimesınıflarının birleşiminden ve ilave birkaç nitelik ve fonksiyondan oluşur.

datesınıfı; tarihle ilgili işlemler yapabilmemizi sağlayan fonksiyon ve nitelikleri barındırır.

timesınıfı; zamanla/saatle ilgili işlemler yapabilmemizi sağlayan fonksiyon ve nitelikleri barındırır.

datetimesınıfı;datevetimesınıflarının birleşiminden ve ilave birkaç nitelik ve fonksiyondan oluşur.

Buna göre,datetimeadlı sınıf hemdatesınıfını hem detimesınıfını
kapsadığı için,datetimemodülü ile işlem yapmak istediğinizde, çoğunlukla
yalnızcadatetimesınıfını kullanarak bütün işlerinizi halledebilirsiniz.

Dolayısıyla:

```python
>>> from datetime import datetime

```

Komutunu vererekdatetimemodülü içindekidatetimeadlı sınıfı içe
aktarmayı tercih edebilirsiniz.

Bakalımdatetimemodülünündatetimesınıfı içinde neler varmış:

```python
>>> dir(datetime)

['__add__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__',
'__forma t__', '__ge__', '__getattribute__', '__gt__', '__hash__',
'__init__', '__le__', '__lt__', '__ne__', '__new__', '__radd__',
'__reduce__', '__reduce_ex__', '__rep r__', '__rsub__', '__setattr__',
'__sizeof__', '__str__', '__sub__', '__subclass hook__', 'astimezone',
'combine', 'ctime', 'date', 'day', 'dst', 'fromordinal', 'fromtimestamp',
'hour', 'isocalendar', 'isoformat', 'isoweekday', 'max', 'microsecond',
'min', 'minute', 'month', 'now', 'replace', 'resolution', 'second',
'strftime', 'strptime', 'time', 'timestamp', 'timetuple', 'timetz', 'today',
'toord inal', 'tzinfo', 'tzname', 'utcfromtimestamp', 'utcnow', 'utcoffset',
'utctimetuple', 'weekday', 'year']

```

Elbette, eğer isterseniz doğrudandatetimemodülünü de içe
aktarabilirsiniz:

```python
>>> import datetime

```

Bu durumda,datetimemodülü içindekidatetimesınıfına erişmek için modül
adını da kullanmanız gerekir:

```python
>>> dir(datetime.datetime)

```

İşte biz bu bölümde, yukarıdaki komutun çıktısında gördüğümüz nitelik ve
fonksiyonlar arasından en önemli olanlarını inceleyeceğiz.

#### now()

datetimemodülünün içindekidatetimesınıfınınnow()adlı fonksiyonu,
bize içindeki bulunduğumuz andaki tarih, saat ve zaman bilgilerini verir.datetimemodülünüimportdatetimeşeklinde içe aktardığımızı varsayarsak
bunu şu şekilde kullanıyoruz:

```python
>>> an = datetime.datetime.now()

```

Bu fonksiyon bizedatetime.datetimeadlı özel bir sınıf nesnesi verir:

```python
>>> an

datetime.datetime(2014, 12, 5, 9, 54, 53, 867108)

```

Bu özel sınıfın da kendine özgü birtakım nitelikleri bulunur.

Meselayearadlı niteliği kullanarak içinde bulunduğumuz yılı
sorgulayabiliriz:

```python
>>> an.year

2014

```

Aynı şekilde aşağıdaki nitelikler de, içinde bulunduğumuz ana ilişkin çeşitli
bilgiler verir:

```python
>>> an.month #ay

12

>>> an.day #gün

5

>>> an.hour #saat

10

>>> an.minute #dakika

20

>>> an.second #saniye

33

>>> an.microsecond #mikrosaniye

337309

```

#### today()

Bu fonksiyonnow()ile aynı içeriğe ve işleve sahiptir.today()fonksiyonununowfonksiyonunu kullandığınız gibi kullanabilirsiniz:

```python
>>> bugün = datetime.datetime.today()

>>> bugün.year

2014

>>> bugün.month

12

>>> bugün.minute

35

>>> bugün.second

24

>>> bugün.microsecond

669774

```

#### ctime()

ctime()fonksiyonu, içinde bulunduğumuz ana ilişkin tarih ve zaman
bilgilerini içeren okunaklı bir karakter dizisi verir. Bu fonksiyona, parametre
olarak biraz önce oluşturduğumuza benzer birdatetime.datetimesınıfı vermemiz
gerekir. Yani:

```python
>>> an = datetime.datetime.now()
>>> tarih = datetime.datetime.ctime(an)
>>> tarih

'Fri Dec 5 10:30:35 2014'

```

Bu fonksiyon tarihleri İngilizce olarak gösterir. Yukarıdaki çıktıya göre tarih
5 Aralık Cuma 2014 saat 10:30:35.

#### strftime()

strftime()fonksiyonu, size tarih ve zaman bilgilerini ihtiyaçlarınız
doğrultusunda biçimlendirme imkanı sunar.

Bu fonksiyon toplam iki parametre alır. İlk parametre, tıpkıctime()fonksiyonunda olduğu gibi, birdatetime.datetimesınıfıdır. İkinci parametre
ise, tarih/zaman bilgisini içeren karakter dizisini nasıl biçimlendirmek
istediğimizi gösteren bir biçimlendiricidir. Yani:

```python
>>> an = datetime.datetime.now()
>>> tarih = datetime.datetime.strftime(an, '%c')
>>> tarih

'Fri 05 Dec 2014 12:53:21 PM '

```

Burada ilk parametre olarakandeğişkeninin tuttuğudatetime.datetimesınıfını, ikinci parametre olarak ise%cadlı biçimlendiriciyi kullandık.

%cdışında başka tarih biçimlendiricileri de bulunur:

hafta gününün kısaltılmış adı

hafta gününün tam adı

ayın kısaltılmış adı

ayın tam adı

tam tarih, saat ve zaman bilgisi

sayı değerli bir karakter dizisi olarak gün

belli bir tarihin, yılın kaçıncı gününe denk geldiğini gösteren 1-366 arası bir sayı

sayı değerli bir karakter dizisi olarak ay

belli bir tarihin yılın kaçıncı haftasına geldiğini gösteren 0-53 arası bir sayı

yılın son iki rakamı

yılın dört haneli tam hali

tam tarih bilgisi

tam saat bilgisi

Yukarıdaki biçimlendiricilerle ilgili birkaç örnek verelim:

```python
>>> datetime.datetime.strftime(an, '%Y') # Yıl

'2014'

>>> datetime.datetime.strftime(an, %'X') # Saat

'12:26:32'

>>> datetime.datetime.strftime(an, '%d') # Gün

'05'

```

strftime()fonksiyonu öntanımlı olarak İngilizce çıktı verecektir:

```python
>>> datetime.datetime.strftime(an, '%A')

'Friday'

>>> datetime.datetime.strftime(an, '%B')

'December'

```

Eğer isterseniz,localeadlı başka bir modülü kullanarak,strftime()modülünün, sisteminizdeki tanımlı dili kullanmasını sağlayabilirsiniz.

Bunun için önceliklelocalemodülünü içe aktaralım:

```python
>>> import locale

```

Ardından Python’ın kullanmasını istediğimiz yerel/dil bilgisini, sistemdeki
öntanımlı yerel/dil olarak ayarlayalım:

```python
>>> locale.setlocale(locale.LC_ALL, '')

'Turkish_Turkey.1254'

```

Bu çıktı bize sistemimizdeki tanımlı dilin/yerelin Türkçe olduğunu söylüyor.
Bu komutu verdikten sonra, artıkstrftime()fonksiyonu, ilgili dile/yerele
uygun bir çıktı verecektir:

```python
>>> datetime.datetime.strftime(an, '%B')

'Aralık'

>>> datetime.datetime.strftime(an, '%A')

'Cuma'

```

Eğer isterseniz, dili kendiniz de seçebilirsiniz. Mesela İtalyanca yapalım:

```python
>>> locale.setlocale(locale.LC_ALL, 'italian')

'Italian_Italy.1252'

>>> datetime.datetime.strftime(an, '%B')

'dicembre'

>>> datetime.datetime.strftime(an, '%A')

'venerdì'

```

> **Ayrıca bakınız**
> Yerel dil adları için Windows’tahttps://www.microsoft.com/en-us/download/details.aspx?id=55979adresine
bakabilirsiniz. GNU/Linux’ta ise, desteklenen yerel/dil adlarını görmek için
sistem komut satırındalocale-akomutunu verebilirsiniz.

Ayrıca bakınız

Yerel dil adları için Windows’tahttps://www.microsoft.com/en-us/download/details.aspx?id=55979adresine
bakabilirsiniz. GNU/Linux’ta ise, desteklenen yerel/dil adlarını görmek için
sistem komut satırındalocale-akomutunu verebilirsiniz.

Yukarıda gördüğünüz tarih biçimlendiricileri kullanarak istediğiniz
karmaşıklıktaki tarihleri oluşturabilirsiniz. Mesela:

```python
>>> datetime.datetime.strftime(an, '%d %B %Y')

'05 Aralık 2014'

```

Veya:

```python
>>> datetime.datetime.strftime(an, '%d.%m.%Y tarihinde buluşalım.')

```

‘05.12.2014 tarihinde buluşalım.’

Gördüğünüz gibi,strftime()fonksiyonu, tarihler üzerinde istediğimiz
karakter dizisi biçimlendirme işlemini uygulayabilmemizi sağlıyor.

#### strptime()

Diyelim ki elimizde, herhangi bir kaynaktan gelmiş şöyle bir karakter dizisi
var:

```python
>>> t = '27 Mayıs 2014'

```

Amacımız, tarih bilgisi içeren bu karakter dizisini gün, ay ve yıl öğelerine
ayırmak. Bunun için basitçe şöyle bir kod yazabiliriz:

```python
>>> gün, ay, yıl = t.split()
>>> gün

'27'

>>> ay

'Mayıs'

>>> yıl

'2014'

```

Peki eğer elimizdeki karakter dizisi şöyle bir şeyse ne yapacağız?

```python
>>> t = '27 Mayıs 2014 saat 12:34:44'

```

Bunun için detdeğişkeni üzerinesplit()metodunu uyguladıktan sonra
‘saat’ kelimesini listeden atmayı tercih edebiliriz:

```python
>>> gün, ay, yıl, saat = [i for i in t.split() if 'saat' not in i]
>>> gün

'27'

>>> ay

'Mayıs'

>>> yıl

'2014'

>>> saat

'12:34:44'

```

Yukarıdaki yöntemler, tarih bilgisi içeren karakter dizilerini ayıklamak için
geçerli ve uygun olsa da epey meşakkatlidir. Üstelik bu şekilde ayıkladığımız
verilerin kullanım alanı da oldukça kısıtlı olacaktır. Mesela bu verileridatetime.datetimetüründe verileri bekleyen uygulamalar içinde kullanamayız.

İşte böyle bir durumdastrptime()adlı fonksiyon devreye girerek,
tarih/zaman bilgisi içeren herhangi bir karakter dizisinidatetime.datetimetüründe bir nesneye dönüştürebilmemiz için bize bir yol sunar.

Şimdi dikkatlice bakın:

Elimizdeki karakter dizisi şu:

```python
>>> t = '27 Mayıs 2014 saat 12:34:44'

```

Şimdi bu karakter dizisinistrptime()fonksiyonunu kullanarak ayıklıyoruz:

```python
>>> z = datetime.datetime.strptime(t, '%d %B %Y saat %H:%M:%S')

datetime.datetime(2014, 5, 27, 0, 34, 44)

```

Gördüğünüz gibi,strptime()fonksiyonu iki parametre alıyor. İlk parametre,
ayıklamak istediğimiz, tarih-zaman bilgisi içeren karakter dizisi. İkinci
parametre ise, bu karakter dizisinin yapısını temsil eden tarih
biçimlendiricilerden oluşan başka bir karakter dizisi. Bu karakter dizisi,'27Mayıs2014saat12:34:44'adlı karakter dizisinin içindeki, tarih ve
saati gösteren kısımların her biri için bir biçimlendirici içeriyor:

```python
27 ==> %d
Mayıs ==> %B
2014 ==> %Y
12 ==> %H
34 ==> %M
44 ==> %S

```

Bu şekilde birdatetime.datetimenesnesi oluşturduktan sonra, artık bu
nesnenin öğelerine, herhangi birdatetime.datetimenesnesi gibi erişebiliriz:

```python
>>> z.month #ay

5

>>> z.day #gün

27

>>> z.year #yıl

2014

>>> z.hour #saat

12

>>> z.minute #dakika

34

>>> z.second #saniye

44

```

#### fromtimestamp()

Hatırlarsanızosmodülünü anlatırkenstat()adlı bir fonksiyondan söz
etmiştik. Bu fonksiyonun, dosyalar hakkında bilgi almamızı sağladığını
biliyorsunuz:

```python
>>> os.stat('dosya_adı')

```

Mesela bir dosyanın son değiştirilme tarihi öğrenmek için şöyle bir kod
kullanıyorduk:

```python
>>> os.stat('dosya_adı').st_mtime

```

st_mtimeniteliği bize şuna benzer bir çıktı veriyor:

```python
1417784445.8881965

```

Bu, içinde ayrıntılı tarih bilgisi barındıran bir zaman damgasıdır (timestamp).
İşte bu zaman damgasını anlamlı bir tarih bilgisine dönüştürebilmek içindatetimemodülünündatetimesınıfı içindekifromtimestamp()adlı
fonksiyondan yararlanacağız:

```python
>>> zaman_damgası = os.stat('dosya_adı').st_mtime
>>> tarih = datetime.datetime.fromtimestamp(zaman_damgası)
>>> tarih

datetime.datetime(2014, 12, 5, 15, 0, 45, 888196)

```

Bu şekilde birdatetime.datetimenesnesi elde ettikten sonra artık bu nesneyi
istediğimiz şekilde manipüle edebiliriz. Mesela:

```python
>>> datetime.datetime.strftime(tarih, '%c')

'12/05/14 15:00:45'

```

Demek ki1417784445.8881965zaman damgası, içinde ‘12/05/14 15:00:45’ tarihini
barındırıyormuş.

#### timestamp()

Eğerdatetime.datetimenesnelerinden bir zaman damgası üretmek isterseniztimestamp()fonksiyonunu kullanabilirsiniz:

```python
>>> tarih = datetime.datetime.now()
>>> zaman_damgası = datetime.datetime.timestamp(tarih)
>>> zaman_damgası

1417790594.558625

```

Eğer daha sonra bu zaman damgasını anlamlı bir tarihe dönüştürmeniz gerekirsefromtimestamp()fonksiyonunu kullanabileceğinizi biliyorsunuz:

```python
>>> tarih = datetime.datetime.fromtimestamp(zaman_damgası)

```

#### Tarihlerle İlgili Aritmetik İşlemler

datetimemodülünü kullanarak, tarihler arasında çıkarma-toplama gibi çeşitli
aritmetik işlemler de yapabilirsiniz. Bu bölümde bu işlemleri nasıl yapacağımızı
anlatacağız.

##### Belirli Bir Tarihi Kaydetmek

Python’dadatetimemodülünü kullanarak bugünün tarihini birdatetime.datetimesınıfı olarak nasıl alabileceğimizi biliyoruz:

```python
>>> datetime.datetime.now()

```

veya:

```python
>>> datetime.datetime.today()

```

Peki biz mesela bugünün değil de, geçmişteki veya gelecekteki belirli bir tarihi
almak istersek ne yapacağız?

Bu iş içinde yinedatetimemodülünündatetimeadlı sınıfından
yararlanacağız.

Diyelim ki 16 Şubat 2016, saat 13:45:32’yi birdatetimesınıfı olarak
kaydetmek istiyoruz. Bunun için şöyle bir kod kullanacağız:

```python
>>> tarih = datetime.datetime(2016, 2, 16, 13, 45, 32)

```

Gördüğünüz gibi, belirli bir tarihi birdatetime.datetimenesnesi olarak
kaydetmek istediğimizdedatetimesınıfına parametre olarak sırasıyla ilgili
tarihin yıl, ay, gün, saat, dakika ve saniye kısımlarını giriyoruz.

Bu arada, eğer isterseniz bu tarih için bir mikrosaniye de belirtebilirsiniz:

```python
>>> tarih = datetime.datetime(2016, 2, 16, 13, 45, 32, 5)

```

Böylece belirli bir tarihi birdatetimesınıfı olarak kaydetmiş olduk. Bu
sınıf,datetime.datetimenesnelerinin bütün özelliklerine sahiptir:

```python
>>> tarih.year #yıl

2016

>>> tarih.day #gün

16

>>> tarih.month #ay

2

```

##### İki Tarih Arasındaki Farkı Bulmak

Size şöyle bir soru sormama izin verin: Diyelim ki bugünün tarihi 9 Aralık 2014.
Doğum tarihimizin 27 Mayıs olduğunu varsayarsak, acaba 2015 yılındaki doğum
günümüze kaç gün kaldığını nasıl bulabiliriz?

Bunun için öncelikle bugünün tarihini birdatetime.datetimenesnesi olarak
alalım:

```python
>>> bugün = datetime.datetime.today()

```

Şimdi de doğumgünümüze denk gelen tarihi birdatetime.datetimenesnesi olarak
kaydedelim:

```python
>>> doğumgünü = datetime.datetime(2015, 5, 27)

```

Şimdi de bu iki tarih arasındaki farkı bulalım:

```python
>>> fark = doğumgünü - bugün
>>> fark

datetime.timedelta(168, 34694, 719236)

```

Buradan elde ettiğimiz şey birtimedeltanesnesi. Bu nesne, tarihler
arasındaki farkı gün, saniye ve mikrosaniye olarak tutan özel bir veri tipidir.
Yukarıdaki çıktıdan anladığımıza göre, 27 Mayıs 2015 tarihi ile 9 Aralık 2014
tarihi arasında 168 gün, 34694 saniye ve 719236 mikrosaniye varmış…

Yukarıdakitimedeltanesnesinin niteliklerine şu şekilde ulaşabilirsiniz:

```python
>>> fark.days #gün

168

>>> fark.seconds #saniye

34694

>>> fark.microseconds #mikrosaniye

719236

```

##### İleri Bir Tarihi Bulmak

Diyelim ki 200 gün sonra hangi tarihte olacağımızı bulmak istiyoruz. Tıpkı bir
önceki başlıkta tartıştığımız gibi, bu isteğimizi yerine getirmek için detimedeltanesnesinden yararlanacağız.

Önce bugünün tarihini bulalım:

```python
>>> bugün = datetime.datetime.today()

```

Şimdi 200 günlük farkı birtimedeltanesnesi olarak kaydedelim:

```python
>>> fark = datetime.timedelta(days=200)

```

Buradadatetimemodülününtimedelta()fonksiyonunundaysadlı
parametresini200değeri ile çağırdığımıza dikkat edin.daysadlı
parametrenin dışında,timedelta()fonksiyonu şu parametrelere de sahiptir:

```python
>>> fark = datetime.timedelta(days=200, seconds=40, microseconds=30)

```

Gördüğünüz gibi, gün dışında saniye (seconds) ve mikrosaniye (microseconds)
ayarlarını da yapabiliyoruz. Yukarıdaki belirlediğimiztimedeltanesnesi
doğrultusunda 200 gün, 40 saniye ve 30 mikrosaniye geleceğe gidelim:

```python
>>> gelecek = bugün + fark

>>> gelecek

datetime.datetime(2015, 6, 27, 14, 47, 32, 826771)

```

Bu tarihi anlamlı bir karakter dizisine dönüştürelim:

```python
>>> gelecek.strftime('%c')

'27.06.2015 14:47:32'

```

Demek ki bugünden 200 gün, 40 saniye ve 30 mikrosaniye sonrası 27 Haziran 2015,
saat 14:47:32’ye denk geliyormuş…

##### Geçmiş Bir Tarihi Bulmak

Geçmiş bir tarihi bulmak da, tahmin edebileceğiniz gibi, ileri bir tarihi
bulmaya çok benzer. Basit bir örnek verelim:

```python
>>> bugün = datetime.datetime.today()

```

Bugünden 200 gün geriye gidelim:

```python
>>> fark = datetime.timedelta(days=200)
>>> geçmiş = bugün - fark
>>> geçmiş

datetime.datetime(2014, 5, 23, 15, 5, 11, 487643)

>>> geçmiş.strftime('%c')

'23.05.2014 15:05:11'

```

Demek ki 200 gün öncesi 23 Mayıs 2014 imiş…

### math Modülü

math modülü matematiksel işlemler yapmanızı kolaylaştırmak için
yazılmış bir modüldür.

#### math.ceil()

Verilen ondalıklı sayıyı bir üst sayıya çevirir. Sayı eğer
tam sayı ise__ceil__fonksiyonundan yararlanır.

```python
>>> math.ceil(32.05)
33
>>> math.ceil(2.98)
3

```

#### math.copysign()

Aldığı iki parametreden ikincisinin işaretini birincisine verir.

```python
>>> math.copysign(25,-12)
-25.0
>>> math.copysign(-12,-15)
-12.0
>>> math.copysign(-245,54)
245.0

```

#### math.fabs()

Verilen değerin mutlak değerini alır. Gömülü fonksiyonlardanabs’den küçük bir farkı var. Çıktısını tam sayı olarak değil
ondalıklı sayı olarak döndürüyor.

```python
>>> math.fabs(-28)
28.0
>>> abs(-28)
28

```

#### math.factorial()

Verilen sayının faktoriyelini döndürüyor. Eğer verilen değer
pozitif tam sayı değilseValueErrorhatası veriyor.

```python
>>> math.factorial(5)
120
>>> math.factorial(-5)
Traceback (most recent call last):
 File "<pyshell#10>", line 1, in <module>
 math.factorial(-5)
ValueError: factorial() not defined for negative values

```

#### math.floor()

ceilfonksiyonunun tam tersi bir işleve sahip. Verilen ondalıklı
sayıyının bir altındaki tam sayıyı döndürür. Sayı eğer tam sayı ise__floor__fonksiyonundan faydalanır.intfonksiyonundan farkı
negatif sayılarda ortaya çıkıyor.

```python
>>> math.floor(25.42)
25
>>> math.floor(-12.25)
-13
>>> int(-12.25)
-12

```

#### math.fmod()

Verdiğiniz birinci parametrenin ikinci parametreye bölümünden kalanı buluyor.%operatöründen farkı negatif sayılarda ortaya çıkıyor.

```python
>>> math.fmod(45,2)
1.0
>>> math.fmod(45,14)
3.0
>>> math.fmod(45,-14)
3.0
>>> 45%-14
-11

```

#### math.frexp()

Bu fonksiyonxbilindiğinde aşağıdaki denkleminmveeparametrelerini
bulmaya yarıyor.mdeğerinin mutlak değeri 0,5 ve 1 arasında
bir değer alıyor.

```python
x = m * 2 ** e

```

Örnek:

```python
>>> math.frexp(1)
(0.5, 1)
>>> math.frexp(8)
(0.5, 4)

```

#### math.fsum()

sumfonksiyonuna çok benziyor.sumfonksiyonundaki bir açığı
kapatıyor.sumfonksiyonu ondalıklı sayılarla çalışırken
biraz sorun çıkarabiliyor.

```python
>>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
0.9999999999999999
>>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1])
1.0

```

#### math.gcd()

Verilen iki sayının EBOB’unu veriyor.

```python
>>> math.gcd(45,70)
5
>>> math.gcd(24,-24)
24
>>> math.gcd(36,12)
12

```

#### math.trunc()

intfonksiyonu ile aynı işi yapıyor.

```python
>>> math.trunc(15.12)
15
>>> math.trunc(-15.12)
-15
>>> math.trunc(0.24)
0
>>> int(0)
0
>>> int(-15.12)
-15

```

#### math.e

euler sabitini tutan bir değişken. Değeri:2.718281…

#### math.pi

pi sayısını tutan değişken. Değeri:3.141592….

#### math.tau

tau sabitini tutan değişken. Değeri pi sayısının iki katı.

```python
>>> math.pi*2==math.tau
True

```

#### math.exp()

euler sabitinin kuvvetini alır. Yani yaptığı iş şudur:math.e ** x

```python
>>> math.exp(2)
7.38905609893065

```

#### math.expm1()

math.expfonksiyonunun yaptığı işten tek farkı sonuçtan1çıkarmasıdır.

```python
>>> math.exp(12)
162754.79141900392
>>> math.expm1(12)
162753.79141900392

```

#### math.log()

Birinci değerin ikinci değere göre logaritmasını hesaplar.

```python
>>> math.log(10,10)
1.0
>>> math.log(25,5)
2.0
>>> math.log(5,25)
0.5

```

#### math.log1p()

Verilen sayının bir fazlasının e tabanına göre logaritmasını
hesaplar.

```python
>>> math.log1p(0)
0.0
>>> math.log1p(2)
1.0986122886681098

```

#### math.log2()

Verilen sayının2tabanında logaritmasını hesaplar.

```python
>>> math.log2(2)
1.0
>>> math.log2(42)
5.392317422778761

```

#### math.log10()

Verilen sayının10tabanında logaritmasını hesaplar.

```python
>>> math.log10(1000)
3.0
>>> math.log10(20)
1.3010299956639813

```

#### math.pow()

**ve gömülü fonksiyonlardanpowile aynı işi yapıyor. Yani
birinci sayının ikinci sayıya göre kuvvetini alıyor.

```python
>>> math.pow(2,5)
32.0
>>> math.pow(2,0)
1.0
>>> pow(2,5)
32
>>> pow(2,0)
1

```

#### math.sqrt()

Verilen sayının karekökünü hesaplar.

```python
>>> math.sqrt(16)
4.0
>>> math.sqrt(225)
15.0

```

#### math.degrees()

Verilen sayıyı radyandan dereceye çevirir.

```python
>>> math.degrees(1.5707963267948966)
90.0

```

#### math.radians()

Verilen sayıyı dereceden radyana çevirir.

```python
>>> math.radians(90)
1.5707963267948966

```

#### math.sin()

Radyan cinsinden verilen sayının sinüsünü hesaplar.

```python
>>> math.sin(math.radians(60))
0.8660254037844386

```

#### math.cos()

Radyan cinsinden verilen parametrenin kosinüsünü hesaplar.

#### math.tan()

Radyan cinsinden verilen parametrenin tanjantını hesaplar.

#### math.asin()

Verilen sinüs değerinden radyan cinsinde bir açı döndürür.

#### math.acos()

Verilen kosinüs değerinden radyan cinsinde bir açı döndürür.

#### math.atan()

Verilen tanjant değerinden radyan cinsinde bir açı döndürür.

#### math.atan2()

İlk değereyikinci değerexdersek şu işlemin
sonucunu döndürür:atan(y/x)

#### math.hypot()

İlk değerexikinci değereydersek şu işlemin
sonucunu döndürür:sqrt(x*x+y*y).

#### math.cosh()

Verilen değerin hiperbolik kosinüsünü döndürür.

#### math.sinh()

Verilen değerin hiperbolik sinüsünü döndürür.

#### math.tanh()

Verilen değerin hiperbolik tanjantını döndürür.

#### math.acosh()

Verilen hiperbolik kosinüs değerinin tersini döndürür.

#### math.asinh()

Verilen hiperbolik sinüs değerinin tersini döndürür.

#### math.atanh()

Verilen hiperbolik tanjant değerinin tersini döndürür.

#### math.gamma()

Bu fonksiyonfactorialfonksiyonuna çok benziyor. Farklarından biri
verilen sayının bir azının faktoriyelini hesaplamasıdır.
Ancak asıl fark sayı büyüdüğünde ortaya çıkıyor.

```python
>>> math.factorial(12)==math.gamma(13)
True
>>> math.factorial(12)
479001600
>>> math.gamma(13)
479001600.0
>>> math.factorial(35)==math.gamma(36)
False
>>> math.factorial(35)
10333147966386144929666651337523200000000
>>> math.gamma(36)
1.0333147966386145e+40

```

#### math.lgamma()

Bu fonksiyon daha önce öğrendiğimiz iki fonksiyonu birleştiriyor.

```python
>>> math.lgamma(45)==math.log(math.gamma(45))
True
>>> math.log(math.gamma(45))
125.3172711493569
>>> math.lgamma(45)
125.3172711493569

```

### random Modülü

Eğer yazdığınız programlarda, belirli bir aralıkta rastgele sayıların
üretilmesine ihtiyaç duyarsanız Python’ın standart kütüphanesinde bulunanrandomadlı bir modülü kullanabilirsiniz.

Tıpkı öteki modüllerde olduğu gibi,randommodülü de birtakım faydalı
nitelik ve fonksiyonları barındırır. Biz bu bölümde, bu nitelik ve fonksiyonlar
arasında en sık kullanılanları inceleyeceğiz.

Elbette bu modülü kullanabilmek için öncelikle modülümüzü içe aktarmamız
gerekiyor:

```python
import random

```

Bu işlemin ardından, bu modülün bize sunduğu bütün işlevlerden yararlanabiliriz.

#### random()

randommodülününrandom()adlı fonksiyonunu kullanarak,0.0ile1.0arasında rastgele bir kayan noktalı sayı üretebilirsiniz:

```python
>>> random.random()

0.8064301704207291

```

random()fonksiyonu, kendisini her çalıştırışınızda farklı bir kayan noktalı
sayı üretecektir:

```python
>>> random.random()

0.6825988062501599

```

Üretilen sayıların 0 ile 1 arasında olduğunu özellikle dikkatinizi çekmek
isterim.

Mesela bu fonksiyonu kullanarak, 0 ile 1 arası 10 tane sayı üretelim. Bu
sayıları gösterirken de noktadan sonra yalnızca dört basamak görüntülenmesine
izin verelim:

```python
>>> for i in range(10):
... print("{:.4f}".format(random.random()))
...
0.3094
0.5277
0.1588
0.2832
0.8742
0.9989
0.6847
0.5672
0.5529
0.9717

```

#### uniform()

Biraz önce gördüğümüzrandom()fonksiyonu, dikkat ederseniz herhangi bir
parametre almıyordu. Çünkü bu fonksiyonun tek görevi 0 ile 1 arası sayılar
üretmektir. Peki ya biz üreteceğimiz sayıların farklı bir aralıkta olmasını
istersek ne yapacağız?

İşte, belirli bir aralıkta kayan noktalı sayılar üretmek istediğimizde,random()yerineuniform()adlı bir fonksiyon kullanacağız. Dikkatlice
inceleyin:

```python
>>> random.uniform(0.5, 1.5)

```

Bu kod, her çalıştırılışında0.5ile1.5arası rastgele bir kayan noktalı
sayı üretecektir:

```python
>>> random.uniform(0.5, 1.5)

0.9624863371746406

>>> random.uniform(0.5, 1.5)

0.900446344810926

```

#### randint()

Şimdiye kadar öğrendiğimizrandom()veuniform()fonksiyonları bize
yalnızca kayan noktalı sayılar üretme imkanı veriyordu. Ancak elbette biz kimi
durumlarda kayan noktalı sayılar yerine tam sayılar üretmek de isteyebiliriz.
İşte böyle bir durumda,randommodülününrandint()adlı başka bir
fonksiyonunu kullanabiliriz.

Mesela45ile500arasında rastgele bir sayı üretmek isterseniz,randint()fonksiyonunu şu şekilde kullanabilirsiniz:

```python
>>> random.randint(45, 500)

```

Bu fonksiyon, her çalıştırılışında45ile500arasında rastgele bir tam sayı
üretecektir.

#### choice()

randommodülününchoice()adlı fonksiyonunu kullanarak, dizi niteliği
taşıyan veri tiplerinden rastgele öğeler seçebiliriz. Bu tanım biraz anlaşılmaz
gelmiş olabilir. O yüzden bunu bir örnekle açıklayalım.

Diyelim ki elimizde şöyle bir liste var:

```python
>>> liste = ['ali', 'veli', 'ahmet',
... 'mehmet', 'celal', 'selin', 'nihat']

```

Bildiğiniz gibi, listeler, dizi niteliği taşıyan veri tipleridir. Dolayısıylachoice()fonksiyonunu kullanarak bu diziden rastgele bir öğe seçebiliriz:

```python
>>> liste = ['ali', 'veli', 'ahmet', 'mehmet', 'celal', 'selin', 'nihat']

>>> random.choice(liste)

'ali'

>>> random.choice(liste)

'mehmet'

>>> random.choice(liste)

'selin'

```

Tıpkı bu örnekte olduğu gibi, karakter dizileri de dizi niteliği taşıyan bir
veri tipi olduğu için,choice()fonksiyonuna cevap verir:

```python
>>> kardiz = 'istihza'
>>> random.choice(kardiz)

'i'

```

Peki acaba bu ‘i’ harfi karakter dizisinin başındaki ‘i’ harfi mi, yoksa
ortasındaki ‘i’ harfi mi? Sizce bunu nasıl anlayabiliriz?

#### shuffle()

shuffle()fonksiyonunu kullanarak, dizi niteliği taşıyan veri tiplerindeki
öğeleri karıştırabilirsiniz (yani öğelerin sırasını karışık bir hale
getirebilirsiniz). Mesela:

```python
>>> l = list(range(10))

```

10 öğeli bir listemiz var. Bu listedeki öğeler0’dan10’a kadar düzgün bir
şekilde sıralanmış:

```python
>>> l

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

Şimdi bizshuffle()fonksiyonunu kullanarak öğeleri karıştıracağız:

```python
>>> random.shuffle(l)
>>> l

[8, 0, 7, 9, 1, 4, 6, 5, 3, 2]

```

Burada dikkat etmemiz gereken önemli nokta,shuffle()fonksiyonunun, özgün
listenin kendisi üzerinde değişiklik yapıyor oluşudur. Yani liste üzerindeshuffle()metodunu uyguladıktan sonra artık özgün listeyi kaybediyoruz.
Dolayısıyla elimizde artık öğeleri 0’dan 10’a kadar düzgün bir şekilde
sıralanmış liste yok. Onun yerine, öğeleri karıştırılmış bir liste var elimizde.

Liste üzerineshuffle()fonksiyonunu her uygulayışınızda özgün listenin
öğeleri bir daha karıştırılacaktır.

Peki size bir soru…

Elinizde şöyle bir liste var:

arkadaşlar = [‘ali’, ‘veli’, ‘mehmet’, ‘ahmet’, ‘serkan’, ‘selin’]

Görevimiz bu listenin öğelerini karıştırmak. Ama biz aynı zamanda özgünarkadaşlarlistesindeki öğe sıralamasını da kaybetmek istemiyoruz. Bunu nasıl
başarabiliriz?

#### randrange()

randrange()fonksiyonu, yukarıda öğrendiğimizrandint()fonksiyonu ile
aynı işi yapar. Yani her iki fonksiyon da, belli bir aralıkta rastgele
tamsayılar üretir. Ancak aralarında iki ufak fark bulunur.

İlk önce birincisine bakalım…

Dikkatlice inceleyin:

```python
>>> random.randrage(10)

```

5

Gördüğünüz gibi,randrange()fonksiyonunu tek parametre ile
kullanabiliyoruz. Yukarıdaki komutu eğerrandint()ile yazmak istersek şunu
yapmamız gerekir:

```python
>>> random.randint(0, 10)

```

randrange()fonksiyonundan farklı olarak,randint()fonksiyonunu iki
parametre ile kullanmamız gerekir. Eğer bu fonksiyona tek parametre verirsek
hata alırız:

```python
>>> random.randint(10)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: randint() missing 1 required positional argument: 'b'

```

Elbette, eğer istersekrandrange()fonksiyonunu da çift parametre ile
kullanarak, farklı bir sayı aralığı belirtme imkanına sahibiz:

```python
>>> random.randrange(10, 500)

```

Bu komut,10ile500arası rastgele tam sayılar üretecektir. Ayrıca bu komut
şununla da eşdeğerdir:

```python
>>> random.randint(10, 500)

```

Bu iki fonksiyon arasındaki ikinci fark ise, rastgele sayı üretilecek aralığın
son değeridir. Bu muğlak ifadeyi bir örnekle anlaşılır hale getirmeye
çalışalım:

```python
>>> random.randrange(10, 20)

```

Bu komut,10ile20arasında rastgele bir sayı üretir. Üretilecek en düşük
sayı10iken, en büyük sayı ise19olacaktır.20sayısı asla üretilmez.

Bir de şuna bakalım:

```python
>>> random.randint(10, 20)

```

Burada da yine10ile20arasında rastgele bir sayı üretilir. Tıpkırandrange()metodunda olduğu gibi, üretilecek en düşük sayı10’dur. Ancak
en büyük sayı20olacaktır.

Bu iki fonksiyonu kullanırken bu farklılığa dikkat etmemiz gerekir. Aksi halde
yazdığımız programlar hatalı çalışabilir.

Peki size bir soru: Acabarandint()ilerandrange()arasındaki bu farkı
nasıl kanıtlarsınız?

#### sample()

‘Sample’ kelimesi ‘numune’ anlamına gelir. İşte kelimenin bu anlamına paralel
olaraksample()fonksiyonu da, dizi niteliği taşıyan veri tiplerinden belli
sayıda numune alınabilmesini sağlar. Bakınız:

```python
>>> liste = range(100)

```

100 öğeli bir liste oluşturduk. Şimdi bu listeden 5 tane rastgele numune
alalım:

```python
>>> random.sample(liste, 5)

[56, 74, 2, 3, 80]

```

Gördüğünüz gibi,sample()fonksiyonunun ilk parametresi numune alınacak
diziyi, ikinci parametresi ise bu diziden kaç tane numune alınacağını
gösteriyor.

### Sqlite ile Veritabanı Programlama

#### Giriş

Bu bölümde, Python’daki ileri düzey konulardan biri olan veritabanı
programlamayı (database programming) inceleyeceğiz. Dilerseniz öncelikle
‘veritabanı’ denen şeyin ne olduğunu anlamaya çalışarak işe başlayalım.

Esasında veritabanı, hiçbirimizin yabancısı olduğu bir kavram değil. Biz bu
kelimeyi, teknik anlamının dışında, günlük hayatta da sıkça kullanıyoruz.
Veritabanı, herkesin bildiği ve kullandığı anlamıyla, içinde veri barındıran bir
‘şey’dir. Günlük kullanımda, hakikaten, içinde veri barındıran her şeye
veritabanı dendiğini duyarsınız.

Veritabanı kelimesinin günlük kullanımdaki anlamı dışında bir de teknik anlamı
vardır. Bizi esas ilgilendiren de zaten terimin teknik anlamıdır. Mesela
Vikipedi’de veritabanı şöyle tanımlanıyor:

Bilgisayar terminolojisinde, sistematik erişim imkânı olan, yönetilebilir,
güncellenebilir, taşınabilir, birbirleri arasında tanımlı ilişkiler
bulunabilen bilgiler kümesidir. Bir başka tanımı da, bir bilgisayarda
sistematik şekilde saklanmış, programlarca işlenebilecek veri yığınıdır.

Yukarıdaki tanım, veritabanının ne demek olduğunu gayet iyi ifade ediyor. Ama
esasında bizim veritabanı tanımı üzerinde fazlaca durmamıza gerek yok. Biz her
zaman olduğu gibi işin teknik boyutuyla değil, taktik boyutuyla ilgilenmeyi
tercih edeceğiz. O halde yavaş yavaş işe koyulmaya başlayalım.

Python’la veritabanı programlama işlemleri için pek çok alternatifimiz var.
Python’la hangi veritabanı sistemlerini kullanabileceğinizi görmek içinhttps://wiki.python.org/moin/DatabaseInterfacesadresindeki listeyi
inceleyebilirsiniz. Biz bunlar içinde, sadeliği, basitliği ve kullanım kolaylığı
nedeniyleSqliteadlı veritabanı yönetim sistemini ele alacağız.

#### Neden Sqlite?

Dediğimiz gibi, Python’da veritabanı işlemleri için kullanabileceğiniz pek çok
alternatif bulunur. Ama biz bütün bu alternatifler içinde Sqlite’ı tercih
edeceğiz. Peki neden Sqlite?

Sqlite’ın öteki sistemlere göre pek çok avantajı bulunur. Gelin isterseniz
Sqlite’ın bazı avantajlarına şöyle bir göz gezdirelim:
- Her şeyden önce Sqlite Python’un 2.5 sürümlerinden bu yana bu dilin bir
parçasıdır. Dolayısıyla eğer kullandığınız Python sürümü 2.5 veya üstü ise
Sqlite’ı Python’daki herhangi bir modül gibi içe aktarabilir ve kullanmaya
başlayabilirsiniz.
- Sqlite herhangi bir yazılım veya sunucu kurulumu gerektirmez. Bu sayede, bu
modülü kullanabilmek için öncelikle bir sunucu yapılandırmanıza da gerek
yoktur. Bazı veritabanlarını kullanabilmek için arka planda bir veritabanı
sunucusu çalıştırıyor olmanız gerekir. Sqlite’ta ise böyle bir şey
yapmazsınız.
- Sqlite, öteki pek çok veritabanı alternatifine göre basittir. Bu yüzden
Sqlite’ı çok kısa bir sürede kavrayıp kullanmaya başlayabilirsiniz.
- Sqlite özgür bir yazılımdır. Bu yazılımın baştan aşağı bütün kodları kamuya
açıktır. Dolayısıyla Sqlite kodlarının her zerresini istediğiniz gibi
kullanabilir, değişikliğe uğratabilir, satabilir ve ticari olan/olmayan bütün
uygulamalarınızda gönül rahatlığıyla kullanabilirsiniz.
- Sqlite’ın sade ve basit olması sizi yanıltmasın. Bu özelliklerine bakarak,
Sqlite’ın yeteneksiz bir veritabanı sistemi olduğunu düşünmeyin. Bugün
Sqlite’ı aktif olarak kullanan pek çok büyük ve tanınmış şirket bulunur.
Mesela, Adobe, Apple, Mozilla/Firefox, Google, Symbian ve Sun bu şirketlerden
bazılarıdır. Hatta GNOME masaüstü ortamının sevilen müzik ve video
çalarlarından Banshee’de de veritabanı olarak Sqlite kullanıldığını
söyleyelim.

Her şeyden önce Sqlite Python’un 2.5 sürümlerinden bu yana bu dilin bir
parçasıdır. Dolayısıyla eğer kullandığınız Python sürümü 2.5 veya üstü ise
Sqlite’ı Python’daki herhangi bir modül gibi içe aktarabilir ve kullanmaya
başlayabilirsiniz.

Sqlite herhangi bir yazılım veya sunucu kurulumu gerektirmez. Bu sayede, bu
modülü kullanabilmek için öncelikle bir sunucu yapılandırmanıza da gerek
yoktur. Bazı veritabanlarını kullanabilmek için arka planda bir veritabanı
sunucusu çalıştırıyor olmanız gerekir. Sqlite’ta ise böyle bir şey
yapmazsınız.

Sqlite, öteki pek çok veritabanı alternatifine göre basittir. Bu yüzden
Sqlite’ı çok kısa bir sürede kavrayıp kullanmaya başlayabilirsiniz.

Sqlite özgür bir yazılımdır. Bu yazılımın baştan aşağı bütün kodları kamuya
açıktır. Dolayısıyla Sqlite kodlarının her zerresini istediğiniz gibi
kullanabilir, değişikliğe uğratabilir, satabilir ve ticari olan/olmayan bütün
uygulamalarınızda gönül rahatlığıyla kullanabilirsiniz.

Sqlite’ın sade ve basit olması sizi yanıltmasın. Bu özelliklerine bakarak,
Sqlite’ın yeteneksiz bir veritabanı sistemi olduğunu düşünmeyin. Bugün
Sqlite’ı aktif olarak kullanan pek çok büyük ve tanınmış şirket bulunur.
Mesela, Adobe, Apple, Mozilla/Firefox, Google, Symbian ve Sun bu şirketlerden
bazılarıdır. Hatta GNOME masaüstü ortamının sevilen müzik ve video
çalarlarından Banshee’de de veritabanı olarak Sqlite kullanıldığını
söyleyelim.

Yukarıdaki sebeplerden ötürü, veritabanı konusunu Sqlite üzerinden anlatacağız.
O halde hemen yola koyulalım.

#### Sqlite’ın Yapısı

Bu bölümün en başında verdiğimiz veritabanı tanımından da anlaşılacağı gibi,
veritabanları, verileri sonradan kullanılmak üzere içinde tutan bir sistemdir.
Bütünilişkisel veritabanlarında
olduğu gibi, Sqlite da bu verileri tablo benzeri bir yapı içinde tutar. Yani
aslında bir Sqlite veritabanı içindeki veriler şöyle bir yapıya sahiptir:
| Sütun 1 | Sütun 2 | Sütun 3 | Sütun 4 | Sütun 5 |
| --- | --- | --- | --- | --- |
| Değer 1/1 | Değer 2/1 | Değer 3/1 | Değer 4/1 | Değer 5/1 |
| Değer 1/2 | Değer 2/2 | Değer 3/2 | Değer 4/2 | Değer 5/2 |
| Değer 1/3 | Değer 2/3 | Değer 3/3 | Değer 4/3 | Değer 5/3 |
| Değer 1/4 | Değer 2/4 | Değer 3/4 | Değer 4/4 | Değer 5/4 |

Sütun 1

Sütun 2

Sütun 3

Sütun 4

Sütun 5

Değer 1/1

Değer 2/1

Değer 3/1

Değer 4/1

Değer 5/1

Değer 1/2

Değer 2/2

Değer 3/2

Değer 4/2

Değer 5/2

Değer 1/3

Değer 2/3

Değer 3/3

Değer 4/3

Değer 5/3

Değer 1/4

Değer 2/4

Değer 3/4

Değer 4/4

Değer 5/4

Sqlite içinde oluşturulan yukarıdakine benzer her tablonun bir de ismi vardır.
Daha doğrusu, Sqlite ile bir tablo oluştururken, bu tabloya bir de ad vermemiz
gerekir. Mesela yukarıdaki tabloya ‘değerler’ adını verdiğimizi
varsayabilirsiniz.

Sqlite ile çalışırken veriler üzerinde yapacağımız işlemleri, yukarıdaki
tablonun adını ve bu tablodaki sütunları kullanarak gerçekleştireceğiz. Bu
yüzden Sqlite’ın yapısını anlamak büyük önem taşır. Gördüğünüz gibi, bu
veritabanı sisteminin yapısını anlamak da öyle zor bir iş değildir.

#### Yardımcı Araçlar

Veritabanları üzerinde yapacağımız çalışmalar sırasında, işlerimizi
kolaylaştırmak için bazı harici araçlara da ihtiyaç duyacağız. Gelin şimdi bu
araçları tanıyalım.

##### Sqlitebrowser

Sqlitebrowser, Sqlite veritabanlarının içeriğini grafik bir arayüz aracılığıyla
görüntüleyebilmemizi sağlayan bir program. Bu program sayesinde, veritabanı
üzerinde yaptığınız çalışmanın doğru sonuç verip vermediğini teyit edebilir,
elinizdeki veritabanının içeriğinde hangi verilerin olduğunu açık seçik
görebilirsiniz.

Bu programı indirmek için ziyaret etmemiz gereken adreshttps://sqlitebrowser.org/.

Eğer siz bir Windows kullanıcısı iseniz, sitedeki.exedosyasını indirip,
programı herhangi bir Windows programı gibi kurabilirsiniz.

GNU/Linux kullanıcılarının önünde ise her zaman olduğu gibi birkaç farklı
seçenek var. Öncelikle, bu program çoğu GNU/Linux dağıtımının paket deposunda
zaten bulunur. Dolayısıyla bu programı dağıtımınızın paket deposu aracılığıyla
rahatlıkla kurabilirsiniz. Mesela Ubuntu kullananlar şu komutla programı
kurabilir:

```python
sudo apt-get install sqlitebrowser

```

GNU/Linux kullanıcıları, eğer arzu ederlerse, programın kaynak kodlarını
sitesinden indirip programı kendileri derlemeyi de tercih edebilir. Bunun için
önceliklehttps://sqlitebrowser.org/adresine gidip.tar.gzuzantılı dosyayı
indirin.

Bu programı derlemeye geçmeden önce şu bağımlılıkları kurmamız gerekiyor:
1. cmake
1. libqt4-dev
1. libsqlite3-dev

cmake

libqt4-dev

libsqlite3-dev

Ubuntu’da ayrıcabuild-essentialpaketine de ihtiyacınız olacak. Ubuntu
kullanıcıları şu komutu vererek Sqlitebrowser programının bütün bağımlılıklarını
sistemlerine kurabilir:

```python
sudo apt-get install build-essential cmake libqt4-dev libsqlite3-dev

```

Bağımlılıkları kurduktan sonra, indirdiğiniz.tar.gzdosyasını aşağıdaki
komut yardımıyla açın:

```python
tar zxvf sqlitebrowser-3.7.0.tar.gz

```

Ben burada indirdiğiniz program sürümünün 3.7.0 olduğunu varsaydım. Sizin
indirdiğiniz sürüm farklıysa yukarıdaki komutu o sürüme göre vereceksiniz.

Daha sonra şu komutu vererek, açtığınız klasörün içine girin:

```python
cd sqlitebrowser-3.7.0

```

Yine, burada da klasör adı ve sürüm numarası sizde farklıysa komutu düzeltin.

Ardından sırasıyla şu komutları verin (cmakekomutunun yanındaki nokta
işaretine dikkat!!):

```python
cmake .

```

```python
make

```

```python
sudo make install

```

Böylece Sqlitebrowser programını sisteminize kurmuş oldunuz. Programın
kurulduğunu teyit etmek için şu komutu çalıştırın:

```python
sqlitebrowser

```

Eğer program penceresi açıldıysa her şey yolunda demektir. Eğer programı
çalıştıramadıysanız veya yukarıdaki komutları anlamakta ve işletmekte zorluk
çekiyorsanız paket deponuzdaki Sqlitebrowser sürümü ile yola devam etmenizi
tavsiye ederim. Ya da eğer arzu ederseniz,https://forum.yazbel.com/adresine
uğrayıp yardım talebinde bulunabilirsiniz.

##### Örnek Veritabanı

Sqlite’ı öğrenirken, içinde örnek veriler barındıran bir veritabanının elimizin
altında bulunması alıştırma yapabilmek açısından faydalı olacaktır. Bunun içinhttps://web.archive.org/web/20170511004853/http://www.istihza.com/denemeler/kitaplar.sqliteadresindeki örnek veritabanını bilgisayarınıza indirin. Veritabanı sorgu çalışmalarımızı
bu örnek veritabanı üzerinde gerçekleştireceğiz.

Şimdi mesela biraz önce indirip kurduğunuz Sqlitebrowser programını çalıştırın
veFile>Open Databaseyolunu takip ederek bukitaplar.sqliteadlı
veritabanı dosyasını açın. Eğer Sqlitebrowser programını Sqlite veritabanı
dosyaları ile ilişkilendirdiyseniz,kitaplar.sqlitedosyası üzerine çift
tıkladığınızda da bu veritabanı dosyası otomatik olarak Sqlitebrowser programı
ile açılacaktır. Ayrıca elbette veritabanı dosyası üzerine sağ tıklayıp,
‘Birlikte aç…’ seçeneğini kullanarak da Sqlitebrowser programını çalıştırmayı
deneyebilirsiniz.

Sqlitebrowser programını çalıştırıp,kitaplar.sqlitedosyasını da açtıktan
sonra, program penceresi üzerindeki ‘Browse Data’ sekmesine tıklayarak
veritabanının içinde ne tür verilerin olduğunu inceleyin. Gördüğünüz gibi,
Sqlitebrowser programı, veritabanı içindeki verileri görselleştirmek açısından
epey kolaylık sağlıyor. Birazdan bu verilere Python aracılığıyla nasıl
erişebileceğimizi de öğreneceğiz.

#### Yeni Bir Veritabanı Oluşturmak

Bu bölümdesqliteadlı bir modül aracılığıyla yeni bir veritabanını nasıl
oluşturacağımızı öğreneceğiz.

Yukarıdasqliteadlı bir modülden söz ettik. Dolayısıyla, tahmin
edebileceğiniz gibi, bu modülü kullanabilmek için öncelikle modülü içe
aktarmamız gerekiyor. Bu bölümün başında da söylediğimiz gibi, Sqlite, Python’ın
2.5 sürümünden bu yana dilin bir parçasıdır:

```python
>>> import sqlite3

```

Python’da Sqlite veritabanı sistemine ait modül ‘sqlite3’ adını taşır. Bu
yüzden, bu modülü içe aktarmak içinimportsqlite3ifadesini kullanmamız
gerekiyor. Eğer bu isim size çok uzun geliyorsa veya modül adında sayıların ve
harflerin birlikte bulunması nedeniyle hem sayı hem de harf girmeyi bir angarya
olarak görüyorsanız elbettesqlite3modülünü farklı bir adla da içe
aktarabileceğinizi biliyorsunuz. Mesela:

```python
>>> import sqlite3 as sql

```

Veya:

```python
>>> import sqlite3 as lite

```

Böylecesqlite3modülünü ‘sql’ veya ‘lite’ adıyla içe aktarmış olduk. Ancak
ben konuyu anlatırken, okur açısından kafa karışıklığına sebep olmamak için,
modülüimportsqlite3şeklinde içe aktarmışız gibi davranacağım.

Gelelim bu modül yardımıyla nasıl veritabanı oluşturulacağına… Bunun içinsqlite3modülününconnect()adlı metodundan yararlanacağız. Bu metodu şu
şekilde kullanıyoruz:

```python
>>> vt = sqlite3.connect('veritabanı_adı')

```

connect()metoduna verdiğimizvaritabanı_adıadlı argüman, kullanacağımız
veritabanının adıdır. Eğer belirtilen isimde bir veritabanı sistemde
bulunmuyorsa o adla yeni bir veritabanı oluşturulacaktır. Mesela:

```python
>>> vt = sqlite3.connect('deneme.sqlite')

```

Eğer bu komutu verdiğiniz dizin içindedeneme.sqliteadlı bir veritabanı
yoksa, bu ada sahip bir veritabanı oluşturulacaktır.

Bu arada, biz veritabanı dosyasının uzantısı olarak.sqlite’ı seçtik. Ama eğer
siz isterseniz kendinize uygun başka bir uzantı da belirleyebilirsiniz.
Veritabanı dosyasının uzantısının ne olması gerektiği konusunda kesin kurallar
bulunmaz..sqliteuzantısının yerine,.sqlite3,.dbveya.db3gibi
uzantıları tercih edenler de vardır. Hatta eğer siz isterseniz veritabanınızın
uzantısını.osmanolarak dahi belirleyebilirsiniz. Bu konuda herhangi bir
kısıtlama bulunmaz.

Yukarıdaki örnektedeneme.sqliteadını verdiğimiz bir veritabanı dosyasına,connect()metodu yardımıyla bağlandık. Elbette isteseydikconnect()metoduna argüman olarak tam dosya yolu da verebilirdik:

```python
>>> import sqlite3
>>> vt = sqlite3.connect('/home/istihza/test.sqlite') #GNU/Linux
>>> vt = sqlite3.connect('c:/users/fozgul/desktop/test.sqlite') #Windows

```

Bu komut yardımıyla sabit disk üzerinde bir Sqlite veritabanı dosyası oluşturmuş
oluyoruz. Ancak istersenizsqlite3ile geçici bir veritabanı da
oluşturabilirsiniz:

```python
>>> vt = sqlite3.connect(':memory:')

```

Oluşturduğunuz bu geçici veritabanı sabit disk üzerinde değil RAM (bellek)
üzerinde çalışır. Veritabanını kapattığınız anda da bu geçici veritabanı
silinir. Eğer arzu ederseniz, RAM üzerinde değil, disk üzerinde de geçici
veritabanları oluşturabilirsiniz. Bunun için de şöyle bir komut kullanıyoruz:

```python
>>> vt = sqlite3.connect('')

```

Gördüğünüz gibi, disk üzerinde geçici bir veritabanı oluşturmak için boş bir
karakter dizisi kullandık. Tıpkı:memory:kullanımında olduğu gibi, boş
karakter dizisiyle oluşturulan geçici veritabanları da veritabanı bağlantısının
kesilmesiyle birlikte ortadan kalkacaktır.

Geçici veritabanı oluşturmak, özellikle çeşitli testler veya denemeler
yaptığınız durumlarda işinize yarar. Sonradan nasıl olsa sileceğiniz, sırf test
amaçlı tuttuğunuz bir veritabanını disk üzerinde oluşturmak yerine RAM üzerinde
oluşturmayı tercih edebilirsiniz. Ayrıca, geçici veritabanları sayesinde,
yazdığınız bir kodu test ederken bir hatayla karşılaşırsanız sorunun veritabanı
içinde varolan verilerden değil, yazdığınız koddan kaynaklandığından da emin
olabilirsiniz. Çünkü, dediğimiz gibi, programın her yeniden çalışışında
veritabanı baştan oluşturulacaktır.

Dikkatinizi çekmek istediğim bir nokta da şudur: Gördüğünüz gibi Sqlite,
veritabanını o anda içinde bulunduğunuz dizin içinde oluşturuyor. Mesela MySQL
kullanıyor olsaydınız, oluşturulan veritabanlarının önceden tanımlanmış bir
dizin içine atıldığını görecektiniz. Örneğin GNU/Linux sistemlerinde, MySQL
veritabanları/var/lib/mysqlgibi bir dizinin içinde tutulur.

#### Varolan Bir Veritabanıyla Bağlantı Kurmak

Biraz önce,deneme.sqliteadlı yeni bir Sqlite veritabanı oluşturmak için
şöyle bir komut kullanmıştık:

```python
>>> vt = sqlite3.connect('deneme.sqlite')

```

Eğer bu komutu verdiğiniz dizin içindedeneme.sqliteadlı bir veritabanı
yoksa, bu ada sahip bir veritabanı oluşturulur. Eğer zaten bu adla bir
veritabanı dosyanız varsa,sqlite3bu veritabanına bağlanacaktır.
Dolayısıyla Sqlite’ta hem yeni bir veritabanı oluşturmak hem de mevcut bir
veritabanına bağlanmak için birbiriyle tamamen aynı kodları kullanıyoruz.

Mesela biraz öncehttps://web.archive.org/web/20170511004853/http://www.istihza.com/denemeler/kitaplar.sqliteadresinden
indirdiğimizkitaplar.sqliteadlı veritabanına bağlanalım.

Bu dosyanın bulunduğu konumda bir Python etkileşimli kabuk oturumu açtığımızı
varsayarsak:

```python
>>> vt = sqlite3.connect('kitaplar.sqlite')

```

komutunu kullanarakkitaplar.sqliteadlı veritabanıyla bağlantı kurabiliriz.

#### İmleç Oluşturma

Yukarıdaconnect()metodunu kullanarak hem Sqlite ile nasıl veritabanı
bağlantısı kuracağımızı hem de nasıl yeni bir veritabanı oluşturacağımızı
öğrendik.

connect()metodu, bir veritabanı üzerinde işlem yapabilmemizin ilk adımıdır.
Veritabanını oluşturduktan veya varolan bir veritabanı ile bağlantı kurduktan
sonra, veritabanı üzerinde işlem yapabilmek için sonraki adımda bir imleç
oluşturmamız gerekir.

İmleç oluşturmak içincursor()adlı bir metottan yararlanacağız:

```python
>>> im = vt.cursor()

```

İmleci oluşturduktan sonra artık önümüz iyice açılıyor. Böylece, yukarıda
oluşturduğumuzimnesnesininexecute()metodunu kullanarak SQL
komutlarını çalıştırabileceğiz. Nasıl mı? Hemen bakalım.

#### Tablo Oluşturma

Önceki bölümün sonunda söylediğimiz gibi, bir imleç nesnesi oluşturduktan sonra
bununexecute()metodunu kullanarak SQL komutlarını işletebiliyoruz.

Dilerseniz şimdi basit bir örnek yaparak neyin ne olduğunu anlamaya çalışalım.

Öncelikle gerekli modülü içe aktaralım:

```python
>>> import sqlite3

```

Şimdi de yeni bir veritabanı dosyası oluşturalım (veya varolan bir veritabanı
dosyasına bağlanalım):

```python
>>> vt = sqlite3.connect('veritabani.sqlite')

```

Bu veritabanı üzerinde işlem yapabilmek için öncelikle imlecimizi oluşturalım:

```python
>>> im = vt.cursor()

```

Şimdi de yukarıda oluşturduğumuz imlecinexecute()adlı metodunu kullanarak
veritabanı içinde bir tablo oluşturalım:

```python
>>> im.execute("CREATE TABLE adres_defteri (isim, soyisim)")

```

Hatırlarsanız, Sqlite veritabanı sisteminin tablo benzeri bir yapıya sahip
olduğunu ve bu sistemdeki her tablonun da bir isminin bulunduğunu söylemiştik.
İşte burada yaptığımız şey, ‘adres_defteri’ adlı bir tablo oluşturup, bu tabloya
‘isim’ ve ‘soyisim’ adlı iki sütun eklemekten ibarettir. Yani aslında şöyle bir
şey oluşturmuş oluyoruz:
| isim | soyisim |
| --- | --- |
| | |

isim

soyisim

Ayrıca oluşturduğumuz bu tablonun adının da ‘adres_defteri’ olduğunu
unutmuyoruz…

Bu işlemleri nasıl yaptığımıza dikkat edin. BuradaCREATETABLEadres_defteri(isim,soyisim)tek bir karakter dizisidir. Bu karakter dizisindekiCREATETABLEkısmı bir SQL komutu olup, bu komut bir tablo oluşturulmasını sağlar.

BuradaCREATETABLEifadesini büyük harflerle yazdık. Ancak bu ifadeyi siz
isterseniz küçük harflerle de yazabilirsiniz. Benim burada büyük harf
kullanmaktaki amacım SQL komutlarının, ‘adres_defteri’, ‘isim’ ve ‘soyisim’ gibi
öğelerden görsel olarak ayırt edilebilmesini sağlamak. YaniCREATETABLEifadesinin mesela ‘adres_defteri’ öğesinden kolayca ayırt edilebilmesini
istediğim için buradaCREATETABLEifadesini büyük harflerle yazdım.

Karakter dizisinin devamında(isim,soyisim)ifadesini görüyoruz. Tahmin
edebileceğiniz gibi, bunlar tablodaki sütun başlıklarının adını gösteriyor. Buna
göre, oluşturduğumuz tabloda ‘isim’ ve ‘soyisim’ adlı iki farklı sütun başlığı
olacak.

Bu arada, Sqlite tabloları oluştururken tablo adı ve sütun başlıklarında Türkçe
karakter kullanmaktan kaçınmak iyi bir fikirdir. Ayrıca eğer tablo adı ve sütun
başlıklarında birden fazla kelimeden oluşan etiketler kullanacaksanız bunları ya
birbirine bitiştirin ya da tırnak içine alın. Örneğin:

```python
import sqlite3

vt = sqlite3.connect('perso.sqlite')
im = vt.cursor()

im.execute("""CREATE TABLE 'personel dosyasi'
('personel ismi', 'personel soyismi', memleket)""")

```

Ayrıca,execute()metoduna parametre olarak verilen SQL komutlarının alelade
birer karakter dizisi olduğuna da dikkatinizi çekmek isterim. Bunlar
Python’daki karakter dizilerinin bütün özelliklerini taşır. Mesela bu karakter
dizisiniexecute()metoduna göndermeden önce bir değişkene atayabilirsiniz:

```python
import sqlite3

vt = sqlite3.connect('perso.sqlite')
im = vt.cursor()

sql = """CREATE TABLE 'personel dosyasi'
('personel ismi', 'personel soyismi', memleket)"""

im.execute(sql)

```

Bu kodları kullanarak oluşturduğunuzperso.sqliteadlı veritabanı dosyasının
içeriğini Sqlitebrowser programı yardımıyla görüntüleyip, gerçekten ‘personel
ismi’, ‘personel soyismi’ ve ‘memleket’ sütunlarının oluşup oluşmadığını kontrol
edin.

Bu arada, bu kodları ikinci kez çalıştırdığınızda şöyle bir hata mesajı
alacaksınız:

```python
sqlite3.OperationalError: table 'personel dosyasi' already exists

```

Bu hata mesajını almanız gayet normal. Bunun üstesinden nasıl geleceğinizi
öğrenmek için okumaya devam edin…

#### Şartlı Tablo Oluşturma

CREATETABLEkomutunu kullanarak tablo oluştururken şöyle bir problemle
karşılaşmış olabilirsiniz. Diyelim ki şu kodları yazdınız:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()
im.execute("CREATE TABLE personel (isim, soyisim, memleket)")

```

Bu kodları ilk kez çalıştırdığınızda, mevcut dizin altındavt.sqliteadlı bir
veritabanı dosyası oluşturulacak ve bu veritabanı içinde ‘isim’, ‘soyisim’ ve
‘memleket’ başlıklı sütunlara sahip, ‘personel’ adlı bir tablo meydana
getirilecektir.

Ancak aynı kodları ikinci kez çalıştırdığınızda şöyle bir hata mesajı ile
karşılaşacaksınız:

```python
sqlite3.OperationalError: table personel already exists

```

Buradaki sorun,vt.sqlitedosyası içinde ‘personel’ adlı bir tablonun zaten
bulunuyor olmasıdır. Bir veritabanı üzerinde işlem yaparken, aynı ada sahip iki
tablo oluşturamayız. Bu hatayı önlemek için şartlı tablo oluşturma yönteminden
yararlanacağız. Bunun için kullanacağımız SQL komutu şudur:CREATETABLEIFNOTEXISTS.

Örneğimizi bu yeni bilgiye göre tekrar yazalım:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()

sorgu = """CREATE TABLE IF NOT EXISTS personel
(isim, soyisim, memleket)"""

im.execute(sorgu)

```

Bu kodları kaç kez çalıştırırsanız çalıştırın, programınız hata vermeden
işleyecek; eğer veritabanında ‘personel’ adlı bir tablo yoksa oluşturacak,
bu adla zaten bir tablo varsa da sessizce yoluna devam edecektir.

#### Tabloya Veri Girme

Buraya kadar,sqlite3modülünü kullanarak nasıl bir veritabanı
oluşturacağımızı ve çeşitli sütünlardan oluşan bir tabloyu bu veritabanına nasıl
yerleştireceğimizi öğrendik. Şimdi de oluşturduğumuz bu sütun başlıklarının
altını dolduracağız.

Dikkatlice bakın:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')
im = vt.cursor()

tablo_yap = """CREATE TABLE IF NOT EXISTS personel
(isim, soyisim, memleket)"""

değer_gir = """INSERT INTO personel VALUES ('Fırat', 'Özgül', 'Adana')"""

im.execute(tablo_yap)
im.execute(değer_gir)

```

> **Uyarı**
> Bu kodları çalıştırdıktan sonra, eğer veritabanının içeriğini
Sqlitebrowser ile kontrol ettiyseniz verilerin veritabanına işlenmediğini
göreceksiniz. Endişe etmeyin; birazdan bunun neden böyle olduğunu açıklayacağız.

Uyarı

Bu kodları çalıştırdıktan sonra, eğer veritabanının içeriğini
Sqlitebrowser ile kontrol ettiyseniz verilerin veritabanına işlenmediğini
göreceksiniz. Endişe etmeyin; birazdan bunun neden böyle olduğunu açıklayacağız.

BuradaINSERTINTOtablo_adıVALUESadlı yeni bir SQL komutu daha
öğreniyoruz.CREATETABLEifadesi Türkçe’de “TABLO OLUŞTUR” anlamına
geliyor.INSERTINTOise “… İÇİNE YERLEŞTİR” anlamına gelir. Yukarıdaki
karakter dizisi içinde görünenVALUESise “DEĞERLER” demektir. Yani aslında
yukarıdaki karakter dizisi şu anlama gelir: “personel İÇİNE ‘Fırat’, ‘Özgül’ ve
‘Adana’ DEĞERLERİNİ YERLEŞTİR. Yani şöyle bir tablo oluştur”:
| isim | soyisim | memleket |
| --- | --- | --- |
| Fırat | Özgül | Adana |

isim

soyisim

memleket

Fırat

Özgül

Adana

Buraya kadar gayet güzel gidiyoruz. İsterseniz şimdi derin bir nefes alıp, şu
ana kadar yaptığımız şeyleri bir gözden geçirelim:
- Önceliklesqlite3modülünü içe aktardık. Bu modülün nimetlerinden
yararlanabilmek için bunu yapmamız gerekiyordu. “sqlite3” kelimesini her
defasında yazmak bize angarya gibi gelebileceği için bu modülü farklı bir adla
içe aktarmayı tercih edebiliriz. Meselaimportsqlite3assqlveyaimportsqlite3aslitegibi…
- sqlite3modülünü içe aktardıktan sonra bir veritabanına bağlanmamız veya
elimizde bir veritabanı yoksa yeni bir veritabanı oluşturmamız gerekiyor. Bunun
içinconnect()adlı bir fonksiyondan yararlanıyoruz. Bu fonksiyonu,sqlite3.connect('veritabanı_adı')şeklinde kullanıyoruz. Eğer içinde
bulunduğumuz dizinde, “veritabanı_adı” adlı bir veritabanı varsa Sqlite bu
veritabanına bağlanır. Eğer bu adda bir veritabanı yoksa, çalışma dizini altında
bu ada sahip yeni bir veritabanı oluşturulur. Özellikle deneme amaçlı işlemler
yapmamız gerektiğinde, sabit disk üzerinde bir veritabanı oluşturmak yerine RAM
üstünde geçici bir veritabanı ile çalışmayı da tercih edebiliriz. Bunun için
yukarıdaki komutu şöyle yazıyoruz:sqlite3.connect(':memory:'). Bu komutla
RAM üzerinde oluşturduğumuz veritabanı, bağlantı kesildiği anda ortadan
kalkacaktır.
- Veritabanımızı oluşturduktan veya varolan bir veritabanına bağlandıktan sonra
yapmamız gereken şey bir imleç oluşturmak olacaktır. Daha sonra bu imlece ait
metotlardan yararlanarak önemli işler yapabileceğiz. Sqlite’ta bir imleç
oluşturabilmek içindb.cursor()gibi bir komut kullanıyoruz. Tabii ben
burada oluşturduğunuz veritabanına “db” adını verdiğinizi varsayıyorum.
- İmlecimizi de oluşturduktan sonra önümüz iyice açılmış oldu. Şimdidir(im)gibi bir komut kullanarak imlecin metotlarının ne olduğunu inceleyebilirsiniz.
Tabii ben burada imlece “im” adını verdiğinizi varsaydım. Gördüğünüz gibi,
listedeexecute()adlı bir metot da var. Artık imlecin buexecute()metodunu kullanarak SQL komutlarını işletebiliriz.
- Yukarıda üç adet SQL komutu öğrendik. Bunlardan ilkiCREATETABLE. Bu komut
veritabanı içinde bir tablo oluşturmamızı sağlıyor. İkinci komutumuzCREATETABLEIFNOTEXISTS. Bu komut da bir tabloyu eğer yoksa oluşturmamızı
sağlıyor. Üçüncü komutumuz iseINSERTINTO...VALUES.... Bu komut,
oluşturduğumuz tabloya içerik eklememizi sağlıyor. Bunları şuna benzer bir
şekilde kullandığımızı hatırlıyorsunuz:

Önceliklesqlite3modülünü içe aktardık. Bu modülün nimetlerinden
yararlanabilmek için bunu yapmamız gerekiyordu. “sqlite3” kelimesini her
defasında yazmak bize angarya gibi gelebileceği için bu modülü farklı bir adla
içe aktarmayı tercih edebiliriz. Meselaimportsqlite3assqlveyaimportsqlite3aslitegibi…

sqlite3modülünü içe aktardıktan sonra bir veritabanına bağlanmamız veya
elimizde bir veritabanı yoksa yeni bir veritabanı oluşturmamız gerekiyor. Bunun
içinconnect()adlı bir fonksiyondan yararlanıyoruz. Bu fonksiyonu,sqlite3.connect('veritabanı_adı')şeklinde kullanıyoruz. Eğer içinde
bulunduğumuz dizinde, “veritabanı_adı” adlı bir veritabanı varsa Sqlite bu
veritabanına bağlanır. Eğer bu adda bir veritabanı yoksa, çalışma dizini altında
bu ada sahip yeni bir veritabanı oluşturulur. Özellikle deneme amaçlı işlemler
yapmamız gerektiğinde, sabit disk üzerinde bir veritabanı oluşturmak yerine RAM
üstünde geçici bir veritabanı ile çalışmayı da tercih edebiliriz. Bunun için
yukarıdaki komutu şöyle yazıyoruz:sqlite3.connect(':memory:'). Bu komutla
RAM üzerinde oluşturduğumuz veritabanı, bağlantı kesildiği anda ortadan
kalkacaktır.

Veritabanımızı oluşturduktan veya varolan bir veritabanına bağlandıktan sonra
yapmamız gereken şey bir imleç oluşturmak olacaktır. Daha sonra bu imlece ait
metotlardan yararlanarak önemli işler yapabileceğiz. Sqlite’ta bir imleç
oluşturabilmek içindb.cursor()gibi bir komut kullanıyoruz. Tabii ben
burada oluşturduğunuz veritabanına “db” adını verdiğinizi varsayıyorum.

İmlecimizi de oluşturduktan sonra önümüz iyice açılmış oldu. Şimdidir(im)gibi bir komut kullanarak imlecin metotlarının ne olduğunu inceleyebilirsiniz.
Tabii ben burada imlece “im” adını verdiğinizi varsaydım. Gördüğünüz gibi,
listedeexecute()adlı bir metot da var. Artık imlecin buexecute()metodunu kullanarak SQL komutlarını işletebiliriz.

Yukarıda üç adet SQL komutu öğrendik. Bunlardan ilkiCREATETABLE. Bu komut
veritabanı içinde bir tablo oluşturmamızı sağlıyor. İkinci komutumuzCREATETABLEIFNOTEXISTS. Bu komut da bir tabloyu eğer yoksa oluşturmamızı
sağlıyor. Üçüncü komutumuz iseINSERTINTO...VALUES.... Bu komut,
oluşturduğumuz tabloya içerik eklememizi sağlıyor. Bunları şuna benzer bir
şekilde kullandığımızı hatırlıyorsunuz:

```python
im.execute("CREATE TABLE personel (isim, soyisim, memleket)")
im.execute("INSERT INTO personel VALUES ('Fırat', 'Özgül', 'Adana')")

```

Burada bir şey dikkatinizi çekmiş olmalı. SQL komutlarını yazmaya başlarken çift
tırnakla başladık. Dolayısıyla karakter dizisini yazarken iç taraftakiFırat,ÖzgülveAdanadeğerlerini yazmak için tek tırnak kullanmamız gerekti.
Karakter dizileri içindeki manevra alanınızı genişletmek için, SQL komutlarını
üç tırnak içinde yazmayı da tercih edebilirsiniz. Böylece karakter dizisi
içindeki tek ve çift tırnakları daha rahat bir şekilde kullanabilirsiniz. Yani:

```python
im.execute("""CREATE TABLE personel (isim, soyisim, memleket)""")
im.execute("""INSERT INTO personel VALUES ("Fırat", "Özgül", "Adana")""")

```

Ayrıca üç tırnak kullanmanız sayesinde, uzun satırları gerektiğinde bölerek çok
daha okunaklı kodlar da yazabileceğinizi biliyorsunuz.

#### Verilerin Veritabanına İşlenmesi

Bir önceki bölümde bir Sqlite veritabanına nasıl veri gireceğimizi öğrendik. Ama
aslında iş sadece veri girmeyle bitmiyor. Verileri veritabanına “işleyebilmek”
için bir adım daha atmamız gerekiyor. Mesela şu örneğe bir bakalım:

```python
import sqlite3

vt = sqlite3.connect("vt.sqlite")

im = vt.cursor()
im.execute("""CREATE TABLE IF NOT EXISTS
 personel (isim, soyisim, sehir, eposta)""")

im.execute("""INSERT INTO personel VALUES
 ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""")

```

Burada önceliklevt.sqliteadlı bir veritabanı oluşturduk ve bu veritabanına
bağlandık. Ardından,vt.cursor()komutuyla imlecimizi de oluşturduktan
sonra, SQL komutlarımızı çalıştırıyoruz. Önce isim, soyisim, şehir ve eposta
adlı sütunlardan oluşan, “personel” adlı bir tablo oluşturduk. Daha sonra
“personel” tablosunun içine “Orçun”, “Kunek”, “Adana” ve “okunek@gmail.com”
değerlerini yerleştirdik.

Ancak her ne kadar veritabanına veri işlemiş gibi görünsek de aslında henüz
işlenmiş bir şey yoktur. İsterseniz bu durumu teyit etmek için Sqlitebrowser
programını kullanabilir, tabloya verilerin işlenmediğini kendi gözlerinizle
görebilirsiniz.

Biz henüz sadece verileri girdik. Ama verileri veritabanına işlemedik. Bu
girdiğimiz verileri veritabanına işleyebilmek içincommit()adlı bir
metottan yararlanacağız:

```python
>>> vt.commit()

```

Gördüğünüz gibi,commit()imlecin değil, bağlantı nesnesinin (yani buradavtdeğişkeninin) bir metodudur. Şimdi bu satırı da betiğimize ekleyelim:

```python
import sqlite3

vt = sqlite3.connect("vt.sqlite")

im = vt.cursor()
im.execute("""CREATE TABLE IF NOT EXISTS
 personel (isim, soyisim, sehir, eposta)""")

im.execute("""INSERT INTO personel VALUES
 ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""")

vt.commit()

```

Bu son satırı da ekledikten sonra Sqlite veritabanı içinde şöyle bir tablo
oluşturmuş olduk:
| isim | soyisim | şehir | eposta |
| --- | --- | --- | --- |
| Orçun | Kunek | Adana | okunek@gmail.com |

isim

soyisim

şehir

eposta

Orçun

Kunek

Adana

okunek@gmail.com

Eğervt.commit()satırını yazmazsak, veritabanı, tablo ve sütun başlıkları
oluşturulur, ama sütunların içeriği veritabanına işlenmez.

#### Veritabanının Kapatılması

Bir veritabanı üzerinde yapacağımız bütün işlemleri tamamladıktan sonra, prensip
olarak, o veritabanını kapatmamız gerekir. Mesela şu kodları ele alalım:

```python
import sqlite3

vt = sqlite3.connect("vt.sqlite")

im = vt.cursor()
im.execute("""CREATE TABLE IF NOT EXISTS
 personel (isim, soyisim, sehir, eposta)""")

im.execute("""INSERT INTO personel VALUES
 ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""")

vt.commit()
vt.close()

```

Burada bütün işlemleri bitirdikten sonra veritabanını kapatmak için,close()adlı bir metottan yararlandık:

```python
vt.close()

```

Bu şekilde, veritabanının ilk açıldığı andan itibaren, işletim sisteminin
devreye soktuğu kaynakları serbest bırakmış oluyoruz. Esasında programımız
kapandığında, açık olan bütün Sqlite veritabanları da otomatik olarak kapanır.
Ama yine de bu işlemi elle yapmak her zaman iyi bir fikirdir.

#### Bağlam Yöneticisi Kullanımı

Python’da bağlam yönetecisi(context manager) oluşturmak içinwithdeyimi kullanılır.
Pythonwithdeyimini kullanarak Sqlite ile işlem yaparken bir istisna ile karşılaşırsa
yapılan işlemlerin otomatik olarak geri alınmasını sağlar. Eğer işlem sorunsuz
gerçekleşirse herhangi bir etki yaratmaz. Aşağıda örnek koda bakalım:

```python
import sqlite3

con = sqlite3.connect(":memory:")
con.execute("CREATE TABLE personel(id INTEGER PRIMARY KEY, isim VARCHAR UNIQUE)")

# Başarılı şekilde, con.commit() çalıştırılır.
with con:
 con.execute("INSERT INTO personel(isim) VALUES(?)", ("Fırat",))

# Hata yakalanınca con.rollback() otomatik olarak çağırılır ve işlemler geri alınır.
try:
 with con:
 con.execute("INSERT INTO personel(isim) VALUES(?)", ("Fırat",))
except sqlite3.IntegrityError:
 print("Aynı ismi iki defa ekleyemezsiniz!")

# Bağlam yöneticisi olarak kullanılan bağlantı nesnesi yalnızca işlemleri gerçekleştirir
# veya geri alır, bu nedenle bağlantı nesnesi manuel olarak kapatılmalıdır.
con.close()

```

Not: Bağlam yöneticisi ne dolaylı olarak yeni bir işlem açar ne de
bağlantıyı kapatır. Kısaca işlem sonunda bağlantıyı kapatmanız gerekir.

#### Parametreli Sorgular

Şu ana kadar verdiğimiz örneklerde, veritabanına girilecek verileri tek tek elle
yerine koyduk. Örneğin:

```python
im.execute("""INSERT INTO personel VALUES
 ('Fırat', 'Özgül', 'Adana')""")

```

Ancak çoğu durumda veritabanına girilecek veriler harici kaynaklardan
gelecektir. Basit bir örnek verelim:

```python
import sqlite3

with sqlite3.connect('vt.sqlite') as vt:
 im = vt.cursor()

 veriler = [('Fırat', 'Özgül', 'Adana'),
 ('Ahmet', 'Söz', 'Bolvadin'),
 ('Veli', 'Göz', 'İskenderun'),
 ('Mehmet', 'Öz', 'Kilis')]

 im.execute("""CREATE TABLE IF NOT EXISTS personel
 (isim, soyisim, memleket)""")

 for veri in veriler:
 im.execute("""INSERT INTO personel VALUES
 (?, ?, ?)""", veri)

 vt.commit()

```

Burada veritabanına işlenecek veriler,verileradlı bir değişkenden geliyor.
Bu değişken içindeki verileri veritabanına nasıl yerleştirdiğimize dikkat edin:

```python
for veri in veriler:
 im.execute("""INSERT INTO personel VALUES
 (?, ?, ?)""", veri)

```

Ayrıca her bir sütunun (‘isim’, ‘soyisim’, ‘memleket’) altına gelecek her bir
değer için (mesela sırasıyla ‘Fırat’, ‘Özgül’, ‘Adana’) bir adet ‘?’ işareti
yerleştirdiğimizi de gözden kaçırmayın.

#### Tablodaki Verileri Seçmek

Yukarıda, bir veritabanına nasıl veri gireceğimizi ve bu verileri veritabanına
nasıl işleyeceğimizi gördük. İşin asıl önemli kısmı, bu verileri daha sonra
veritabanından (yani tablodan) geri alabilmektir. Şimdi bu işlemi nasıl
yapacağımıza bakalım.

Veritabanından herhangi bir veri alabilmek için ilk olarakSELECTveriFROMtablo_adıadlı bir SQL komutundan yararlanarak ilgili verileri seçmemiz
gerekiyor.

Dilerseniz önce bir tablo oluşturalım:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()

im.execute("""CREATE TABLE IF NOT EXISTS faturalar
(fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""")

```

Şimdi bu tabloya bazı veriler ekleyelim:

```python
im.execute("""INSERT INTO faturalar VALUES
("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")

```

Verileri veritabanına işleyelim:

```python
vt.commit()

```

Yukarıdaki kodlar bize şöyle bir tablo verdi:
| fatura | miktar | ilk_odeme_tarihi | son_odeme_tarihi |
| --- | --- | --- | --- |
| Elektrik | 45 | 23 Ocak 2010 | 30 Ocak 2010 |

fatura

miktar

ilk_odeme_tarihi

son_odeme_tarihi

Elektrik

45

23 Ocak 2010

30 Ocak 2010

Buraya kadar olan kısmı zaten biliyoruz. Bilmediğimiz ise bu veritabanından
nasıl veri alacağımız. Onu da şöyle yapıyoruz:

```python
im.execute("""SELECT * FROM faturalar""")

```

Burada özel bir SQL komutu olanSELECTveriFROMtablo_adıkomutundan
faydalandık. Burada joker karakterlerden biri olan “*” işaretini kullandığımıza
dikkat edin.SELECT*FROMfaturalarifadesi şu anlama gelir: “faturalar
adlı tablodaki bütün öğeleri seç!”

Burada “SELECT” kelimesi “SEÇMEK” demektir. “FROM” ise “…DEN/…DAN”
anlamı verir. Yani “SELECT FROM faturalar” dediğimizde “faturalardan seç”
demiş oluyoruz. Burada kullandığımız “*” işareti de “her şey” anlamına geldiği
için, “SELECT * FROM faturalar” ifadesi “faturalardan her şeyi seç” gibi bir
anlama gelmiş oluyor.

Verileri seçtiğimize göre, artık seçtiğimiz bu verileri nasıl alacağımıza
bakabiliriz. Bunun için defetchone(),fetchall()veyafetchmany()adlı metotlardan ya dafordöngüsünden yararlanacağız.

#### Seçilen Verileri Almak

Bu bölümde,SELECTsorgusu ile veritabanından seçtiğimiz verileri farklı
yollarla nasıl çekebileceğimizi/alabileceğimizi inceleyeceğiz.

##### fetchall() Metodu

Biraz önce şöyle bir program yazmıştık:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()

im.execute("""CREATE TABLE IF NOT EXISTS faturalar
(fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""")

im.execute("""INSERT INTO faturalar VALUES
("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")

vt.commit()

im.execute("""SELECT * FROM faturalar""")

```

Buradavt.sqliteadlı bir veritabanında ‘faturalar’ adlı bir tablo oluşturduk
ve bu tabloya bazı veriler girdik. Daha sonra daSELECTadlı SQL komutu
yardımıyla bu verileri seçtik. Şimdi de seçtiğimiz bu verileri veritabanından
alacağız.

Yukarıdaki programa şu satırı ekliyoruz:

```python
veriler = im.fetchall()

```

Burada da ilk defa gördüğümüz bir metot var:fetchall(). Gördüğünüz gibi,fetchall()imlecin bir metodudur. Yukarıda gördüğümüzSELECT*FROMfaturalarkomutu ‘faturalar’ adlı tablodaki bütün verileri seçiyordu.fetchall()metodu ise seçilen bu verileri alma işlevi görüyor. Yukarıda bizfetchall()metoduyla aldığımız bütün verileriverileradlı bir değişkene
atadık.

Artık bu verileri rahatlıkla yazdırabiliriz:

```python
print(veriler)

```

Dilerseniz betiğimizi topluca görelim:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()

im.execute("""CREATE TABLE IF NOT EXISTS faturalar
(fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""")

im.execute("""INSERT INTO faturalar VALUES
("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")

vt.commit()

im.execute("""SELECT * FROM faturalar""")

veriler = im.fetchall()

print(veriler)

```

Bu betiği ilk kez çalıştırdığımızda şöyle bir çıktı alırız:

```python
[('Elektrik', 45, '23 Ocak 2010', '30 Ocak 2010')]

```

Gördüğünüz gibi, veriler bir liste içinde demet halinde yer alıyor. Ama tabii
siz bu verileri istediğiz gibi biçimlendirecek kadar Python bilgisine
sahipsiniz. Ayrıca programı her çalıştırdığınızdaINSERTINTOsorgusu tekrar
işletileceği için verilerin tabloya tekrar tekrar yazılacağını, bu verileri
alırken de çıktı listesinin büyüyeceğini unutmayın. Peki eğer siz bir veritabanı
dosyasına verilerin yalnızca bir kez yazılmasını istiyorsanız ne yapacaksınız?
Yani mesela yukarıdaki kodlarda şu sorgu yalnızca tek bir kez işletilsin:

```python
im.execute("""INSERT INTO faturalar VALUES
("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")

```

Böylece veritabanını her çalıştırdığınızda("Elektrik",45,"23Ocak2010","30Ocak2010")satırı dosyaya tekrar tekrar yazdırılmasın.

Bunu şu kodlarla halledebilirsiniz:

```python
import sqlite3, os

dosya = 'vt.sqlite'
dosya_mevcut = os.path.exists(dosya)

vt = sqlite3.connect(dosya)
im = vt.cursor()

im.execute("""CREATE TABLE IF NOT EXISTS faturalar
(fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""")

if not dosya_mevcut:
 im.execute("""INSERT INTO faturalar VALUES
 ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")
 vt.commit()

im.execute("""SELECT * FROM faturalar""")

veriler = im.fetchall()
print(veriler)

```

Burada kodlarımızın en başındavt.sqliteadlı bir veritabanının mevcut olup
olmadığını kontrol ediyoruz (zira eğer ortada bir veritabanı dosyası yoksa, veri
de yok demektir):

```python
dosya_mevcut = os.path.exists(dosya)

```

Eğer böyle bir dosya mevcut değilse (dolayısıyla veri mevcut değilse)INSERTINTOsorgusu işletilerek gerekli veriler yerine yerleştirilecek:

```python
if not dosya_mevcut:
 im.execute("""INSERT INTO faturalar VALUES
 ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""")
 vt.commit()

```

Eğer böyle bir dosya zaten mevcutsa bu sorgu işletilemeyecek, onun yerine
doğrudanSELECTsorgusuna geçilecek. Böylece değerler veritabanına bir kez
işlendikten sonra, programımız aynı verileri tekrar tekrar veritabanına
yerleştirmeye çalışmayacak.

Bu arada, daha önce de belirttiğimiz gibi, tablo oluştururken sütun adlarında
boşluk (ve Türkçe karakter) kullanmak iyi bir fikir değildir. Meselailködemetarihiyerineilk_odeme_tarihiifadesini tercih edin. Eğer kelimeler
arasında mutlaka boşluk bırakmak isterseniz bütün kelimeleri tırnak içine alın.
Mesela:"ilkodemetarihi"veya"ilködemetarihi"gibi.

Yukarıda gördüğünüz gibi,fetchall()metodu, bir veritabanındanSELECTile seçtiğimiz bütün verileri önümüze getiriyor. Eğer seçilen verilerden kaç
tanesini almak istediğinizi kendiniz belirlemek istiyorsanızfetchall()yerinefetchone()veyafetchmany()metotlarından o anki amacınıza uygun
olanını kullanmayı tercih edebilirsiniz. Birazdanfetchone()vefetchmany()metotlarından da söz edeceğiz.

Gelin isterseniz şimdifetchall()metodunu kullanarak veritabanlarından veri
çekme konusunda biraz alıştırma yapalım. Bu alıştırmalar için, daha önce söz
ettiğimiz ve bilgisayarımıza indirdiğimizkitaplar.sqliteadlı örnek
veritabanını kullanacağız.

Öncelikle veritabanına bağlanalım ve bir imleç oluşturalım:

```python
>>> import sqlite3
>>> vt = sqlite3.connect('kitaplar.sqlite')
>>> im = vt.cursor()

```

Şimdi bu veritabanındaki tabloyu seçeceğiz. Peki ama seçeceğimiz tablonun adını
nereden bileceğiz? Hatırlarsanız, bir tablodaki bütün verileri seçebilmek için
şu SQL sorgusunu kullanıyorduk:

```python
"SELECT * FROM tablo_adı"

```

İşte bu sorguda ‘tablo_adı’ kısmına ne geleceğini bulabilmek için birkaç farklı
yöntemden yararlanabiliriz.

Bir veritabanında hangi tabloların olduğunu öğrenmek için Sqlitebrowser
programını kullanabiliriz. Bir veritabanı dosyasını Sqlitebrowser ile açtıktan
sonra, ‘Browse Data’ sekmesine gidip, ‘Table’ ifadesinin karşısında ne yazdığına
bakabiliriz.

Veritabanındaki tabloların adını öğrenmenin ikinci yolu şu komutları
kullanmaktır:

```python
>>> import sqlite3
>>> vt = sqlite3.connect('kitaplar.sqlite')
>>> im = vt.cursor()
>>> im.execute("SELECT name FROM sqlite_master")
>>> im.fetchall()

```

Burada şu satıra dikkat edin:

```python
>>> im.execute("SELECT name FROM sqlite_master")

```

Bütün Sqlite veritabanlarında, ilgili veritabanının şemasını gösteren
‘sqlite_master’ adlı bir tablo bulunur. İşte bu tabloyu sorgulayarak veritabanı
hakkında bilgi edinebiliriz. Yukarıdaki örnekte, bu ‘sqlite_master’ tablosunun
‘name’ (isim) niteliğini sorguladık. Bu sorgu bize şu cevabı verdi:

```python
>>> im.fetchall()

[('kitaplar',)]

```

Demek kikitaplar.sqliteadlı veritabanında ‘kitaplar’ adlı tek bir tablo
varmış.

Gelin şimdi bu bu tablodaki bütün verileri alalım:

```python
>>> im.execute("SELECT * FROM kitaplar")
>>> im.fetchall()

```

Bu şekilde tablo içinde ne kadar veri varsa hepsini ekrana yazdırdık. Ancak
tabii ki, bir veritabanının tamamını bir anda yazdırmak her zaman iyi bir fikir
olmayabilir. Eğer veritabanının içinde milyonlarca girdi varsa bütün verilerin
seçilip yazdırılması mantıklı olmayacaktır. Gelin o halde şimdi bizim seçilen
verilerin ne kadarını çekeceğimizi belirleyebilmemizi sağlayacak metotları
inceleyelim.

##### fetchone() Metodu

fetchone()metodu, bir veritabanından seçilen verilerin tek tek
alınabilmesine izin verir.

Bu metodun nasıl kullanılacağını ‘kitaplar.sqlite’ adlı örnek veritabanımız
üzerinden inceleyelim:

Önce veritabanına bağlanalım:

```python
>>> import sqlite3
>>> vt = sqlite3.connect('kitaplar.sqlite')
>>> im = vt.cursor()

```

Şimdi ‘kitaplar’ adlı tablodan bütün verileri seçelim:

```python
>>> im.execute("""SELECT * FROM kitaplar""")

<sqlite3.Cursor object at 0x003C2D20>

```

Artık seçtiğimiz verileri tek tek almaya başlayabiliriz:

```python
>>> im.fetchone()

('UZMANLAR İÇİN PHP', 'Mehmet Şamlı', '33,00 TL')

```

Bir tane daha alalım:

```python
>>> im.fetchone()

('ADOBE AİR', 'Engin Yöğen', '28,00 TL')

```

İki tane daha…

```python
>>> im.fetchone()

('WEB TASARIM REHBERİ', 'Mustafa Aydemir', '38,50 TL')

>>> im.fetchone()

('ORACLE 11g R2', 'Teoman Dinçel', '34,00 TL')

```

fetchone()’ın gayet faydalı bir metot olduğu her halinden belli…

##### fetchmany() Metodu

Bu metot, bir veritabanından seçtiğiniz verilerin istediğiniz kadarını
alabilmenize imkan tanır. Dikkatlice bakın:

```python
>>> im.fetchmany(5)

[('AS 3.0 İLE SUNUCU PROGRAMLAMA', 'Engin Yöğen', '24,00 TL'),
 ('HACKING INTERFACE', 'Hamza Elbahadır', '25,00 TL'),
 ('JAVA VE JAVA TEKNOLOJİLERİ', 'Tevfik Kızılören', '45,00 TL'),
 ('XML VE İLERİ XML TEKNOLOJİLERİ', 'Musa Çiçek', '24,50 TL'),
 ('GRAFİK&ANİMASYON', 'Anonim', '18,50 TL')]

```

Gördüğünüz gibi, beş öğeden oluşan bir liste elde ettik.

Böylece bir veritabanından seçilen verileri almanın farklı yöntemlerini öğrenmiş
olduk. Bu metotların dışında, eğer arzu edersenizfordöngüsünden yararlanarak
da veri çekebilirsiniz. Bunun için herhangi bir metot kullanmanıza gerek yok:

```python
>>> for veri in im:
... print(veri)

```

Gördüğünüz gibi,fordöngüsünü doğrudan imleç üzerinde kuruyoruz.

Eğer amacınız alınacak verilerin sayısını sınırlamaksa yinefordöngüsünden vefetchone()metodundan birlikte yararlanabilirsiniz:

```python
>>> for i in range(5):
... print(im.fetchone())

```

Biraz sonra veri süzmeyi öğrendiğimizde, bir veritabanından veri seçip almanın
daha verimli yollarını göreceğiz.

#### Veri Süzme

Daha önce bir Sqlite veritabanında belli bir tablo içindeki bütün verileri
seçmek için şu SQL komutunu kullanmamız gerektiğini öğrenmiştik:

```python
SELECT * FROM tablo_adi

```

Ancak amacımız çoğu zaman bir tablo içindeki bütün verileri seçmek olmayacaktır.
Programcılık maceramız boyunca genellikle yalnızca belli ölçütlere uyan verileri
seçmek isteyeceğiz. Zira içinde milyonlarca veri barındırabilecek olan
veritabanlarındaki verilerin tamamını seçmek akıl kârı değildir.

Verileri süzme işiniWHEREadlı bir SQL komutu yardımıyla
gerçekleştireceğiz. Bu SQL komutunun sözdizimi şöyle:

```python
SELECT * FROM tablo_adı WHERE sütun_başlığı = aranan_veri

```

Gördüğünüz gibi, bu sorguyu gerçekleştirebilmek için tablodaki sütun
başlıklarını bilmemiz gerekiyor.

Önceki sayfalarda,kitaplar.sqliteadlı veritabanımızdaki tabloların adını
nasıl öğrenebileceğimizi anlatmıştık. Hatırlarsanız bu iş için şu komutu
kullanıyorduk:

```python
>>> im.execute("SELECT name FROM sqlite_master")

```

Bu şekilde, bütün Sqlite veritabanlarında bulunan ‘sqlite_master’ adlı özel bir
tablonun ‘name’ niteliğini sorgulayarak, elimizdeki veritabanında bulunan
tabloların adını elde edebiliyoruz. Adını öğrendiğimiz tablodaki sütun
başlıklarını elde etmek için yine buna benzer bir komuttan yararlanacağız.
Dikkatlice bakın:

```python
>>> im.execute("SELECT sql FROM sqlite_master").fetchone()

('CREATE TABLE "kitaplar"
(\n\t`KitapAdi`\tTEXT,\n\t`Yazar`\tTEXT,\n\t`Fiyati`\tTEXT\n)',)

```

‘sqlite_master’ adlı tablonun ‘sql’ niteliğini sorguladığımızda, ilgili tabloyu
oluşturmak için kullanılan SQL komutunu görüyoruz. Bu komuta dikkatli
bakarsanız, tablonun ‘KitapAdi’, ‘Yazar’ ve ‘Fiyati’ olmak üzere üç sütundan
oluştuğunu göreceksiniz. Elbette sütun adlarını öğrenmek için Sqlitebrowser
programını da kullanabileceğinizi artık biliyorsunuz.

Sütun adlarını öğrendiğimize göre gelin şimdi yazar adına göre veritabanında bir
sorgu yapalım:

```python
>>> im.execute("SELECT * FROM kitaplar WHERE Yazar = 'Fırat Özgül'")

```

Burada sorguyu nasıl kurduğumuza dikkat edin. Bu sorgunun ilk kısmı olanSELECT*FROMkitaplarifadesini zaten daha önce öğrenmiştik. Yeni olan
kısımWHEREYazar='FıratÖzgül'. Burada da anlaşılmayacak bir şey yok. Bu
şekilde, veritabanındaki ‘kitaplar’ tablosunun ‘Yazar’ sütununda ‘Fırat Özgül’
bulunan bütün kayıtları seçiyoruz.

Şimdi de seçtiğimiz bu verileri alalım:

```python
>>> im.fetchall()

('HERYÖNÜYLE PYTHON', 'Fırat Özgül', '34,00 TL')

```

Gayet başarılı… Bu arada, verileri almak içinfetchall()yerinefordöngüsü kullanabileceğinizi de biliyorsunuz:

```python
>>> for s in im:
... print(s)
...
('HERYÖNÜYLE PYTHON', 'Fırat Özgül', '34,00 TL')

```

İmleç üzerindefordöngüsü kurabildiğimize göre yıldızlı parametrelerden de
yararlanabileceğimizi tahmin etmişsinizdir:

```python
>>> print(*im)

('HERYÖNÜYLE PYTHON', 'Fırat Özgül', '34,00 TL')

```

#### Veritabanı Güvenliği

Python’da veritabanları ve Sqlite konusunda daha fazla ilerlemeden önce çok
önemli bir konudan bahsetmemiz gerekiyor. Tahmin edebileceğiniz gibi, veritabanı
denen şey oldukça hassas bir konudur. Bilgiyi bir araya toplayan bu sistem,
içerdeki bilgilerin değerine ve önemine de bağlı olarak üçüncü şahısların
iştahını kabartabilir. Ancak depoladığınız verilerin ne kadar değerli ve önemli
olduğundan bağımsız olarak veritabanı güvenliğini sağlamak, siz programcıların
asli görevidir.

Peki veritabanı yönetim sistemleri acaba hangi tehditlerle karşı karşıya?

SQL komutlarını işleten bütün veritabanları için günümüzdeki en büyük
tehditlerden birisi hiç kuşkusuz kötü niyetli kişilerin veritabanınıza SQL
komutu sızdırma (SQL injection) girişimleridir.

Şimdi şöyle bir şey düşünün: Diyelim ki siz bir alışveriş karşılığı birine
100.000 TL’lik bir çek verdiniz. Ancak çeki verdiğiniz kişi bu çek üzerindeki
miktarı tahrif ederek artırdı ve banka da tahrif edilerek artırılan bu miktarı
çeki getiren kişiye (hamiline) ödedi. Böyle bir durumda epey başınız
ağrıyacaktır.

İşte böyle tatsız bir durumla karşılaşmamak için, çek veren kişi çekin
üzerindeki miktarı hem rakamla hem de yazıyla belirtmeye özen gösterir. Ayrıca
rakam ve yazılara ekleme yapılmasını da engellemek için rakam ve yazıların
sağına soluna “#” gibi işaretler de koyar. Böylece çeki alan kişinin, kendisine
izin verilenden daha fazla bir miktarı yazmasını engellemeye çalışır.

Yukarıdakine benzer bir şey veritabanı uygulamalarında da karşımıza çıkabilir.
Şimdi şu örneğe bakalım:

```python
import sqlite3

#vt.sqlite adlı bir veritabanı dosyası oluşturup
#bu veritabanına bağlanıyoruz.
db = sqlite3.connect("vt.sqlite")

#Veritabanı üzerinde istediğimiz işlemleri yapabilmek
#için bir imleç oluşturmamız gerekiyor.
im = db.cursor()

#imlecin execute() metodunu kullanarak, veritabanı içinde
#"kullanicilar" adlı bir tablo oluşturuyoruz. Bu tabloda
#kullanıcı_adi ve parola olmak üzere iki farklı sütun var.
im.execute("""CREATE TABLE IF NOT EXISTS kullanicilar
 (kullanici_adi, parola)""")

#Yukarıda oluşturduğumuz tabloya yerleştireceğimiz verileri
#hazırlıyoruz. Verilerin liste içinde birer demet olarak
#nasıl gösterildiğine özellikle dikkat ediyoruz.
veriler = [
 ("ahmet123", "12345678"),
 ("mehmet321", "87654321"),
 ("selin456", "123123123")
 ]

#veriler adlı liste içindeki bütün verileri kullanicilar adlı
#tabloya yerleştiriyoruz. Burada tek öğeli bir demet
#tanımladığımıza dikkat edin: (i,)
for i in veriler:
 im.execute("""INSERT INTO kullanicilar VALUES %s""" %(i,))

#Yaptığımız değişikliklerin tabloya işlenebilmesi için
#commit() metodunu kullanıyoruz.
db.commit()

#Kullanıcıdan kullanıcı adı ve parola bilgilerini alıyoruz...
kull = input("Kullanıcı adınız: ")
paro = input("Parolanız: ")

#Burada yine bir SQL komutu işletiyoruz. Bu komut, kullanicilar
#adlı tabloda yer alan kullanici_adi ve parola adlı sütunlardaki
#bilgileri seçiyor.
im.execute("""SELECT * FROM kullanicilar WHERE
kullanici_adi = '%s' AND parola = '%s'"""%(kull, paro))

#Hatırlarsanız daha önce fetchall() adlı bir metottan
#söz etmiştik. İşte bu fetchone() metodu da ona benzer.
#fetchall() bütün verileri alıyordu, fetchone() ise
#verileri tek tek alır.
data = im.fetchone()

#Eğer data adlı değişken False değilse, yani bu
#değişkenin içinde bir değer varsa kullanıcı adı
#ve parola doğru demektir. Kullanıcıyı içeri alıyoruz.
if data:
 print("Programa hoşgeldin {}!".format(data[0]))

#Aksi halde kullanıcıya olumsuz bir mesaj veriyoruz.
else:
 print("Parola veya kullanıcı adı yanlış!")

```

Bu örnekte henüz bilmediğimiz bazı kısımlar var. Ama siz şimdilik bunları
kafanıza takmayın. Nasıl olsa bu kodlarda görünen her şeyi biraz sonra tek tek
öğreneceğiz. Siz şimdilik sadece işin özüne odaklanın.

Yukarıdaki kodları çalıştırdığınızda, eğer kullanıcı adı ve parolayı doğru
girerseniz ‘Programa hoşgeldin’ çıktısını göreceksiniz. Eğer kullanıcı adınız
veya parolanız yanlışsa bununla ilgili bir uyarı alacaksınız.

Her şey iyi hoş, ama bu kodlarda çok ciddi bir problem var.

Dediğimiz gibi, bu kodlar çalışırken (teoride) eğer kullanıcı, veritabanında
varolan bir kullanıcı adı ve parola yazarsa sisteme kabul edilecektir. Eğer
doğru kullanıcı adı ve parola girilmezse sistem kullanıcıya giriş izni
vermeyecektir. Ama acaba gerçekten öyle mi?

Şimdi yukarıdaki programı tekrar çalıştırın. Kullanıcı adı ve parola
sorulduğunda da her ikisi için şunu yazın:

```python
x' OR '1' = '1

```

O da ne! Program sizi içeri aldı… Hem de kullanıcı adı ve parola doğru
olmadığı halde… Hatta şu kodu sadece kullanıcı adı kısmına girip parola
kısmını boş bırakmanız da sisteme giriş hakkı elde etmenize yetecektir.:

```python
x' OR '1' = '1' --

```

İşte yukarıda gösterdiğimiz bu işleme “SQL sızdırma” (SQL injection) adı verilir.
Kullanıcı, tıpkı en başta verdiğimiz tahrif edilmiş çek örneğinde olduğu gibi,
sistemin zaaflarından yararlanarak, elde etmeye hakkı olandan daha fazlasına
erişim hakkı elde ediyor.

Burada en basit şekliyle bool işleçlerinden biri olanor’dan yararlanıyoruz.or’un nasıl işlediğini gayet iyi biliyorsunuz, ama ben yine de birkaç
örnekleor’un ne olduğunu ve ne yaptığını size hatırlatayım. Şu örneklere
bakın:

```python
>>> a = 21

>>> a == 22

False

>>> b = 13

>>> b == 13

True

>>> if a == 22 and b == 13:
... print("Merhaba!")
...

>>> if a == 22 or b == 13:
... print("Merhaba!")
...
Merhaba!

```

Örneklerden de gördüğünüz gibi,andişlecininTruesonucunu verebilmesi
için her iki önermenin de doğru olması gerekir. O yüzdena==22andb==13gibi bir ifadeFalsedeğeri veriyor. AncakorişlecininTruesonucu
verebilmesi için iki önermeden sadece birinin doğru olması yeterlidir. Bu
yüzden, sadeceb==13kısmıTrueolduğu haldea==22orb==13ifadesiTruesonucu veriyor… İşte biz de yukarıdaki SQL sızdırma
girişimindeor’un bu özelliğinden faydalanıyoruz.

Dilerseniz neler olup bittiğini daha iyi anlayabilmek için, sızdırılan kodu
doğrudan ilgili satıra uygulayalım:

```python
im.execute("""SELECT * FROM kullanicilar WHERE
kullanici_adi = 'x' OR '1' = '1' AND parola = 'x' OR '1' = '1'""")

```

Sanırım bu şekilde neler olup bittiği daha net görülüyor. Durumu biraz daha
netleştirmek için Python’ı yardıma çağırabiliriz:

```python
>>> kullanici_adi = 'ahmet123'

>>> parola = '12345678'

>>> kullanici_adi == 'x'

False

>>> '1' == '1'

True

>>> kullanici_adi == 'x' or '1' == '1'

True

>>> parola == 'x'

False

>>> (kullanici_adi == 'x' or '1' == '1') and (parola == 'x' or '1' == '1')

True

```

'1'=='1'ifadesi her zamanTruedeğeri verecektir. Dolayısıyla
kullanıcı adının ve parolanın doğru olup olmaması hiçbir önem taşımaz. Yani her
zamanTruedeğerini vereceği kesin olan ifadeler yardımıyla yukarıdaki gibi
bir sızdırma girişiminde bulunabilirsiniz.

Yukarıda yaptığımız şey, ‘%s’ ile gösterilen yerlere kötü niyetli bir SQL komutu
sızdırmaktan ibarettir. Burada zaten başlangıç ve bitiş tırnakları olduğu için
sızdırılan kodda başlangıç ve bitiş tırnaklarını yazmıyoruz. O yüzden sızdırılan
kod şöyle görünüyor:

```python
x' OR '1' = '1

```

Gördüğünüz gibi, x’in başındaki ve 1’in sonundaki tırnak işaretleri koymuyoruz.

Peki yukarıda verdiğimiz şu kod nasıl çalışıyor:

```python
x' OR '1' = '1' --

```

Python’da yazdığımız kodlara yorum eklemek için “#” işaretinden yararlandığımızı
biliyorsunuz. İşte SQL kodlarına yorum eklemek için de “–” işaretlerinden
yararlanılır. Şimdi dilerseniz yukarıdaki kodu doğrudan ilgili satıra
uygulayalım ve ne olduğunu görelim:

```python
im.execute("""SELECT * FROM kullanicilar WHERE
kullanici_adi = 'x' OR '1'='1' --AND parola = '%s'""")

```

Burada yazdığımız “–” işaretiANDparola='%s'kısmının sistem tarafından
yorum olarak algılanmasını sağlıyor. Bu yüzden kodların bu kısmı işletilmiyor.
Dolayısıyla da sisteme giriş yapabilmek için sadece kullanıcı adını girmemiz
yeterli oluyor. Burada ayrıca kodlarımızın çalışması için 1’in sonuna bir adet
tırnak yerleştirerek kodu kapattığımıza dikkat edin. Çünkü normal bitiş tırnağı
yorum tarafında kaldı.

Dikkat ederseniz SQL sızdırdığımızda “ahmet123” adlı kullanıcının hesabını ele
geçirmiş olduk. Peki neden ötekiler değil de “ahmet123”? Bunun sebebi,
“ahmet123” hesabının tablonun en başında yer alması. Eğer tablonun başında
“admin” diye bir hesap olmuş olsaydı, veritabanına azami düzeyde zarar verme
imkanına kavuşacaktınız.

Peki SQL sızdırma girişimlerini nasıl önleyeceğiz? Bu girişime karşı
alabileceğiniz başlıca önlem “%s” işaretlerini kullanmaktan kaçınmak olacaktır.
Bu işaret yerine “?” işaretini kullanacaksınız. Yani yukarıdaki programı şöyle
yazacağız:

```python
import sqlite3

db = sqlite3.connect("vt.sqlite")

im = db.cursor()

im.execute("""CREATE TABLE IF NOT EXISTS kullanicilar
 (kullanici_adi, parola)""")

veriler = [
 ("ahmet123", "12345678"),
 ("mehmet321", "87654321"),
 ("selin456", "123123123")
 ]

for i in veriler:
 im.execute("""INSERT INTO kullanicilar VALUES (?, ?)""", i)

db.commit()

kull = input("Kullanıcı adınız: ")
paro = input("Parolanız: ")

im.execute("""SELECT * FROM kullanicilar WHERE
kullanici_adi = ? AND parola = ?""", (kull, paro))

data = im.fetchone()

if data:
 print("Programa hoşgeldin {}!".format(data[0]))
else:
 print("Parola veya kullanıcı adı yanlış!")

```

Dediğimiz gibi, SQL sızdırma girişimlerine karşı alabileceğiniz başlıca önlem
“%s” işaretleri yerine “?” işaretini kullanmak olmalıdır. Bunun dışında, SQL
komutlarını işletmeden önce bazı süzgeçler uygulamak da güvenlik açısından
işinize yarayabilir. Örneğin kullanıcıdan alınacak verileri alfanümerik
karakterlerle [http://www.istihza.com/blog/alfanumerik-ne-demek.html/]
(arşiv linki) sınırlayabilirsiniz:

```python
if kull.isalnum() and paro.isalnum():
 im.execute("""SELECT * FROM kullanicilar WHERE
 kullanici_adi = '%s' AND parola = '%s'"""%(kull, paro))

```

Böylece kullanıcının bazı “tehlikeli” karakterleri girmesini engelleyebilir,
onları sadece harf ve sayı girmeye zorlayabilirsiniz.

Her halükarda unutmamamız gereken şey, güvenliğin çok boyutlu bir kavram
olduğudur. Birkaç önlemle pek çok güvenlik açığını engelleyebilirsiniz, ancak
bütün güvenlik açıklarını bir çırpıda yamamak pek mümkün değildir. Bir programcı
olarak sizin göreviniz, yazdığınız programları güvenlik açıklarına karşı sürekli
taramak ve herhangi bir açık ortaya çıktığında da bunu derhal kapatmaya
çalışmaktır.

#### Bölüm Soruları
1. Bir veritabanı dosyasının var olup olmadığını nasıl tespit edersiniz?
1. Bir veritabanı içinde belli bir tablonun var olup olmadığını tespit edin.
Eğer yoksa o tabloyu oluşturun, varsa herhangi bir işlem yapmayın.
1. Sqlite ile test amaçlı bir veritabanı oluşturun. Bu veritabanı dosyası,
programınız kapanır kapanmaz ortadan kaybolmalı.
1. Aşağıdaki kodların istenen veritabanını, tabloyu, satır ve sütunları
oluşturup oluşturmadığını teyit edin:importsqlite3vt=sqlite3.connect('vt.sqlite')im=vt.cursor()im.execute("CREATE TABLE kullanıcılar (ad, soyad, doğumtarihi, eposta)")vt.commit()vt.close()Eğer veritabanı içeriği beklediğiniz gibi değilse sebebini açıklayın.
1. Sqlite ile bir veritabanının oluşturulması ve bu veritabanına birtakım
bilgiler girilebilmesi için sırasıyla hangi işlemlerin yapılması gerekir?
1. Aşağıdaki resimde yapılmaya çalışılan şey nedir?
1. sqlite3.connect('kitaplar.sqlite')boş bir veritabanının mı
oluşturulduğunu yoksa varolankitaplar.sqliteadlı bir veritabanı dosyasına
mı bağlandığınızı nasıl teyit edersiniz?
1. Sqlitebrowser programını ne şekilde kurdunuz? Eğer Ubuntu dışında bir
GNU/Linux dağıtımına bu programı kurduysanız, programın kurulum aşamalarını
anlatın.
1. cmakekomutu ile birlikte kullandığımız.(nokta) işaretinin anlamı
nedir?
1. Yazdığınız bir programı kullanan kişilerin, programınızı ilk kez
çalıştırdıklarında karşılarında görmeleri gereken verileri veritabanına
yerleştirmek için nasıl bir yöntem takip edebilirsiniz? Kullanıcılarınız
programınızı ikinci kez çalıştırdığında bu verileri görmemeli.
1. Bir önceki soruda uyguladığınız yöntemin herhangi bir kısıtlaması var mı? Bu
yöntem hangi durumlarda işe yaramaz?
1. Bir veritabanındaki bütün tabloların adını nasıl listelersiniz?

Bir veritabanı dosyasının var olup olmadığını nasıl tespit edersiniz?

Bir veritabanı içinde belli bir tablonun var olup olmadığını tespit edin.
Eğer yoksa o tabloyu oluşturun, varsa herhangi bir işlem yapmayın.

Sqlite ile test amaçlı bir veritabanı oluşturun. Bu veritabanı dosyası,
programınız kapanır kapanmaz ortadan kaybolmalı.

Aşağıdaki kodların istenen veritabanını, tabloyu, satır ve sütunları
oluşturup oluşturmadığını teyit edin:

```python
import sqlite3

vt = sqlite3.connect('vt.sqlite')

im = vt.cursor()
im.execute("CREATE TABLE kullanıcılar (ad, soyad, doğumtarihi, eposta)")

vt.commit()
vt.close()

```

Eğer veritabanı içeriği beklediğiniz gibi değilse sebebini açıklayın.

Sqlite ile bir veritabanının oluşturulması ve bu veritabanına birtakım
bilgiler girilebilmesi için sırasıyla hangi işlemlerin yapılması gerekir?

Aşağıdaki resimde yapılmaya çalışılan şey nedir?

sqlite3.connect('kitaplar.sqlite')boş bir veritabanının mı
oluşturulduğunu yoksa varolankitaplar.sqliteadlı bir veritabanı dosyasına
mı bağlandığınızı nasıl teyit edersiniz?

Sqlitebrowser programını ne şekilde kurdunuz? Eğer Ubuntu dışında bir
GNU/Linux dağıtımına bu programı kurduysanız, programın kurulum aşamalarını
anlatın.

cmakekomutu ile birlikte kullandığımız.(nokta) işaretinin anlamı
nedir?

Yazdığınız bir programı kullanan kişilerin, programınızı ilk kez
çalıştırdıklarında karşılarında görmeleri gereken verileri veritabanına
yerleştirmek için nasıl bir yöntem takip edebilirsiniz? Kullanıcılarınız
programınızı ikinci kez çalıştırdığında bu verileri görmemeli.

Bir önceki soruda uyguladığınız yöntemin herhangi bir kısıtlaması var mı? Bu
yöntem hangi durumlarda işe yaramaz?

Bir veritabanındaki bütün tabloların adını nasıl listelersiniz?

### os Modülü

Bildiğiniz gibi, işletim sistemlerinin çalışma mantığı birbirinden farklıdır.
Örneğin Windows ve GNU/Linux işletim sistemleri aynı işi birbirlerinden farklı
şekillerde yaparlar. Mesela Windows’ta bir dizin içinde hangi klasör ve
dosyaların olduğunu öğrenmek içindirkomutunu kullanırız. GNU/Linux’ta ise
aynı işlev içinlsadlı bir komut vardır.

Aynı şekilde, iki işletim sistemi arasında dizin ayraçları konusunda da
farklılık bulunur. Windows’ta dizinleri birbirinden ayırmak için ters taksim
(\) işareti kullanılırken, GNU/Linux’ta aynı iş için düz taksim (/)
işareti kullanılır.

> **Not**
> Düz taksim işaretini Windows da kabul eder, ancak Windows’un doğal
dizin ayracı ters taksimdir.

Not

Düz taksim işaretini Windows da kabul eder, ancak Windows’un doğal
dizin ayracı ters taksimdir.

İşte biz hem Windows’ta, hem de GNU/Linux’ta çalışacak bir program yazmak
istediğimizde bu farklılıkları göz önünde bulundurmamız ve farklı durumların
her biri için ayrı kodlar yazmamız gerekirken,osmodülü bizi bu zahmetten
kurtarır ve bize ortak bir arayüz üzerinden farklı işletim sistemleri ile
tutarlı bir şekilde iletişim kurabilmemizi sağlayacak pek çok fonksiyon ve
nitelik sunar.

Bu nitelik ve fonksiyonların neler olduğunudir(os)komutuyla
görebileceğinizi biliyorsunuz.

Bu bölümde,osmodülünün sunduğu bu fonksiyon ve niteliklerin en
önemlilerini ve en yaygın kullanılanlarını olabildiğince ayrıntılı bir şekilde
ele almaya çalışacağız.

> **Not**
> Buradaosmodülünüimportoskomutuyla içe aktarmış olduğunuz
varsayılmaktadır.

Not

Buradaosmodülünüimportoskomutuyla içe aktarmış olduğunuz
varsayılmaktadır.

#### os.name

osmodülünün, önceki derslerde şöyle bir değinip geçtiğimiznameniteliği,
kullanıcılarımızın, yazdığımız kodları hangi işletim sisteminde çalıştırdığı
konusunda bize bilgi verir.

Bu niteliği şöyle kullanıyoruz:

```python
>>> os.name

```

Eğer kodlarımız Windows işletim sistemi üzerinde çalıştırılmışsa buradan şu
çıktıyı alırız:

```python
'nt'

```

MacOS ve GNU/Linux işletim sistemleri ise bu komuta şu cevabı verir:

```python
'posix'

```

Dolayısıylaos.nameniteliğini kullanarak farklı işletim sistemlerinde
farklı çalışan programlar yazabiliriz.

#### os.sep

osmodülününsepniteliği, kodlarımızın çalıştığı işletim sisteminin dizin
ayracının ne olduğunu bize gösterir.

Eğer bu niteliği Windows işletim sistemi üzerinde kullanırsak şu çıktıyı
alırız:

```python
>>> os.sep

'\\'

```

MacOS ve GNU/Linux işletim sistemleri ise bu komuta şu cevabı verir:

```python
>>> os.sep

'/'

```

Peki bu nitelik ne işe yarar?

Bu niteliği kullanarak, farklı işletim sistemlerine özgü dizin yolları
oluşturabilirsiniz. Mesela:

```python
>>> liste = ['aylar', 'mayıs', 'test']
>>> os.sep.join(liste)

```

Burada karakter dizilerininjoin()metodunuos.sepile birlikte
kullandığımıza dikkat edin.

Bu komutu Windows’ta verdiğinizde şu çıktıyı alırsınız:

```python
'aylar\\mayıs\\test'

```

Aynı komutu GNU/Linux’ta verdiğinizde ise şu çıktıyı:

```python
'aylar/mayıs/test'

```

Yani yukarıdaki komutu Windows’ta verdiğinizde Python şu komutu almış gibi
davranır:

```python
>>> liste = ['aylar', 'mayıs', 'test']
>>> '\\'.join(liste)

```

GNU/Linux’ta ise şu komutu:

```python
>>> liste = ['aylar', 'mayıs', 'test']
>>> '/'.join(liste)

```

Böylece yazdığınız programlarda hangi işletim sisteminin hangi dizin ayracını
kullandığını düşünmenize gerek kalmaz; bunu sizin yerinize Python düşünür…

#### os.getcwd()

osmodülününgetcwd()fonksiyonu bize o anda içinde bulunduğumuz dizinin
adını verir:

```python
>>> os.getcwd()

'/home/istihza/Desktop' #GNU/Linux

```

veya:

```python
>>> os.getcwd()

'C:\\Documents and Settings\\fozgul' #Windows

```

#### os.chdir()

osmodülününchdir()fonksiyonu bize bir dizinden başka bir dizine geçme
imkanı verir.

Mesela GNU/Linux’ta, o anda bulunduğumuz dizinden/usr/binadlı dizine geçmek
için şu komutu kullanabiliriz:

```python
>>> os.chdir('/usr/bin/')

```

veya Windows’taC:\Documents and Settings\fozgul\Desktopadlı dizine geçmek
için şunu:

```python
>>> os.chdir('C:\\Documents and Settings\\fozgul\\Desktop')

```

Gördüğünüz gibi, gitmek istediğimiz dizin adınıos.chdir()fonksiyonuna
parametre olarak vermemiz yeterli oluyor.

#### os.listdir()

osmodülününlistdir()fonksiyonu, bize bir dizin içindeki dosya ve
klasörleri listeleme imkanı verir.listdir(),osmodülünün en kullanışlı
fonksiyonlarından biridir.

Mesela o anda içinde bulunduğumuz dizindeki dosya ve klasörleri listelemek
istersek bu fonksiyonu şöyle kullanabiliriz:

```python
>>> mevcut_dizin = os.getcwd()
>>> os.listdir(mevcut_dizin)

```

Eğer farklı bir dizinin içeriğini listelemek istersek, parametre olarak o
dizinin adını yazmamız yeterli olacaktır:

```python
>>> os.listdir('/var/www')

```

Gördüğünüz gibi,os.listdir()komutunun çıktısı liste türünde bir veri
tipidir. Dolayısıyla listelerle yapabildiğiniz her şeyi bununla da
yababilirsiniz. Mesela bu liste üzerinde bir döngü kurabilirsiniz:

```python
>>> for i in os.listdir(os.getcwd()):
... print(i)

```

Ya da bir dizin içindeki, belli bir uzantıya sahip dosyaları süzebilirsiniz:

```python
>>> for i in os.listdir(os.getcwd()):
... if i.endswith('.doc'):
... print(i)

```

Bu kodlar bize, adı.docile biten bütün dosyaları listeleyecektir.

Bu arada karakter dizilerininendswith()adlı metodunu hatırlıyorsunuz,
değil mi?

#### os.curdir

Çoğu işletim sisteminde mevcut dizini göstermek için ‘.’ adlı karakter dizisi
kullanılır. Örneğin:

```python
>>> os.listdir(os.getcwd())

```

gibi bir komut yerine şu komutu da kullanabilirsiniz:

```python
>>> os.listdir('.')

```

listdir()fonksiyonuna parametre olarak verdiğimiz ‘.’ karakter dizisi o
anda içinde bulunduğumuz dizini temsil eder.

Eğer bu karakter dizisini elle yazmak istemiyorsanızosmodülü içindekicurdiradlı nitelikten de yararlanabilirsiniz:

```python
>>> os.listdir(os.curdir)

```

Bu aradaos.getcwd()ileos.curdir’i birbirine karıştırmamalısınız. Bu
ikisi aynı şey değildir.os.getcwd()çıktı olarak o anda içinde bulunduğumuz
dizinin adını verir.os.curdirise, bir işletim sisteminde, o anda içinde
bulunulan dizini temsil eden karakter dizisi ne ise onun değerini barındırır. Bu
değer çoğu işletim sisteminde ‘.’ adlı karakter dizisidir.

#### os.pardir

Tıpkı ‘.’ karakter dizisi gibi, çoğu işletim sisteminde bir üst dizini göstermek
için ‘..’ adlı karakter dizisi kullanılır. Örneğin:

```python
>>> os.listdir('..')

```

komutu, o anda içinde bulunduğunuz dizindeki değil, bir üst dizindeki dosya ve
dizin adlarını listeleyecektir. Yine tıpkıos.curdirniteliğinde olduğu gibi,
eğer bu karakter dizisini kendiniz elle yazmak istemezseniz, bu karakter
dizisini içinde barındıranos.pardiradlı bir nitelikten yararlanabilirsiniz:

```python
>>> os.listdir(os.pardir)

```

Bu komut,os.listdir('..')ile aynı çıktıyı verir.

#### os.startfile()

> **Uyarı**
> Bu fonksiyon yalnızca Windows’ta çalışır. GNU/Linux işletim
sistemlerinde bu fonksiyon tanımlı değildir.

Uyarı

Bu fonksiyon yalnızca Windows’ta çalışır. GNU/Linux işletim
sistemlerinde bu fonksiyon tanımlı değildir.

osmodülü içindekistartfile()adlı fonksiyonun görevi bilgisayarımızda
bulunan herhangi bir dosyayı, ilişkilendirilmiş olduğu programla açmaktır.

Hemen bir örnek verelim.

O anda içinde bulunduğumuz dizindedeneme.txtadlı bir dosya olduğunu
varsayalım. Şimdi de şu komutu verelim:

```python
>>> os.startfile('deneme.txt')

```

İşletim sisteminiz.txtuzantılı dosyaları hangi programla ilişkilendirmişse,startfile()fonksiyonudeneme.txtadlı dosyayı o programla açacaktır.
Windows’ta.txtdosyaları genellikle Notepad programıyla ilişkilendirildiği
için yukarıdaki komutu verdiğinizde muhtemelendeneme.txtdosyasının içeriği
Notepad programı aracılığıyla görüntülenecektir.

Aynı şekilde, o anda bulunduğuz dizin içindedeneme.docxadlı bir dosyanın
olduğunu varsayalım ve şu komutu verelim:

```python
>>> os.startfile('deneme.docx')

```

Bu komut dadeneme.docxdosyasının Microsoft Word adlı yazılımla açılmasını
sağlayacaktır.

Eğerstartfile()fonksiyonuna parametre olarak bir dosya değil de dizin adı
verecek olursanız, o dizin Windows Explorer ile açılır. Mesela içinde
bulunduğumuz dizini Windows Explorer ile açalım:

```python
>>> os.startfile(os.curdir)

```

Bunun yerine şu komutu kullanabileceğinizi de biliyorsunuz:

```python
>>> os.startfile('.')

```

veya:

```python
>>> os.startfile(os.getcwd())

```

Bu üç komut da aynı işlevi yerine getirir.

Peki bir üst dizini açmak istersek ne yapacağız?

Dikkatlice bakın:

```python
>>> os.startfile(os.pardir)

```

veya:

```python
>>> os.startfile('..')

```

Her iki komut da Windows Explorer yardımıyla bir üst dizinin görüntülenmesini
sağlayacaktır.

Elbettestartfile()fonksiyonuna parametre olarak belirli bir dizinin adını
da verebilirsiniz:

```python
>>> os.startfile(r"C:\Documents and Settings\fozgul")

```

os.startfile()oldukça faydalı bir fonksiyondur. Hatta bu fonksiyonu sadece
dosyaları açmak için değil, internet sayfalarını açmak için dahi
kullanabilirsiniz:

```python
>>> os.startfile('www.istihza.com')

```

Ancak bu komutun yalnızca Windows’ta çalışacağını unutmayın. O yüzden bunun
yerine, daha önce öğrendiğimizwebbrowsermodülünü kullanmak daha doğru
olacaktır.

#### os.mkdir()

osmodülününmkdir()fonksiyonu yeni dizinler oluşturabilmemizi sağlar.

Örneğin:

```python
>>> os.mkdir('yenidizin')

```

Bu komut, o anda içinde bulunduğumuz dizin içinde ‘yenidizin’ adlı bir dizin
oluşturacaktır.

Elbette eğer dizini o anda içinde bulunduğunuz dizin içinde değil de farklı bir
konumda oluşturmak isterseniz, o konumun açık adresini belirtebilirsiniz:

```python
>>> os.mkdir('/home/istihza/Desktop/yenidizin')

```

veya:

```python
>>> os.mkdir(r'C:\Documents and Settings\fozgul\yenidizin')

```

Eğer oluşturmaya çalıştığınız dizin zaten varsaos.mkdir()hata verecektir:

```python
>>> os.mkdir(r'C:\Documents and Settings\fozgul\yenidizin')

FileExistsError: [WinError 183] Halen varolan bir
dosya oluşturulamaz: 'yenidizin'

```

#### os.makedirs()

os.makedirs()fonksiyonu biraz önce öğrendiğimizos.mkdir()fonksiyonuna
çok benzese de aralarında önemli farklar bulunur.

Biraz önceos.mkdir()fonksiyonunu anlatırken şöyle bir örnek vermiştik:

```python
>>> os.mkdir(r'C:\Documents and Settings\fozgul\yenidizin')

```

Bu komutun çalışabilmesi için, bilgisayarımızda halihazırdaC:Documents and
Settingsfozgul` yolunun varolması gerekir. Eğer bu yolu oluşturan dizinlerden
herhangi biri mevcut değilse, ``mkdir()`fonksiyonuyenidizinadlı dizini
oluşturamaz. Bu fonksiyonun çalışabilmesi için, varolmayan bütün dizinleri tek
tek oluşturmanız gerekir.

os.makedirs()iseos.mkdir()fonksiyonunun aksine, varolmayan üst ve alt
dizinleri de oluşturma yeteneğine sahiptir. Örneğin:

```python
>>> os.makedirs('/home/istihza/Desktop/aylar/mayıs/ödeme/')

```

Bu komut sırasıylaaylar,mayısveödemeadlı dizinleri iç içe
oluşturacaktır. Yanios.makedirs()komutununödemeadlı dizini oluşturması
içinaylarvemayısadlı dizinlerin önceden varolması zorunlu değildir. Bu
dizinler varolsa da olmasa daos.makedirs()komutuödemedizinini
oluşturabilir. Amaos.mkdir()fonksiyonu böyle değildir. Eğeros.mkdir()fonksiyonuylaödemedizinini oluşturmak isterseniz, öncelikleaylarvemayısadlı dizinleri oluşturmanız gerekir.

#### os.rename()

osmodülününrename()adlı fonksiyonunu kullanarak dizinlerin adlarını
değiştirebiliriz. Bu fonksiyon iki parametre alır:

```python
>>> os.rename('dizinin_şimdiki_adı', 'dizinin_yeni_adı')

```

Mesela mevcut çalışma dizininde ‘deneme’ adlı bir dizin varsa, bu dizinin adını
‘test’ olarak değiştirmek için şu komutu verebiliriz:

```python
>>> os.rename('deneme', 'test')

```

Eğer zaten ‘test’ adlı bir dizin varsa (ve içi boşsa), yukarıdaki komut
GNU/Linux’ta ‘test’ adlı dizinin üzerine yazacak, Windows’ta ise hata
verecektir.

#### os.replace()

osmodülününreplace()fonksiyonu biraz önce öğrendiğimizrename()fonksiyonu gibi çalışır:

```python
>>> os.replace('deneme', 'test')

```

Bu komut, tıpkırename()fonksiyonunda olduğu gibi,denemeadlı dizinin
adınıtestolarak değiştirecektir.

Eğertestadlı bir dizin zaten varsa,replace()fonksiyonu, hem Windows’ta
hem de GNU/Linux’ta, varolan butestdizininin üzerine yazmaya çalışır.
GNU/Linux’ta çoğu durumda bunu başarır, ancak Windows’ta yine de çeşitli izin
hataları ile karşılaşabilirsiniz.

#### os.remove()

osmodülününremove()adlı fonksiyonu, bilgisayarımızdaki dosyaları
silmemizi sağlar:

```python
>>> os.remove('dosya_adı')

```

Yalnız bu komutu çok dikkatli kullanmalısınız. Çünkü bu komut, silme işleminden
önce herhangi bir soru sormadan, dosyayı doğrudan siler.

#### os.rmdir()

osmodülününrmdir()fonksiyonu, içi boş bir dizini silmek için
kullanılır:

```python
>>> os.rmdir('dizin_adı')

```

Eğer silmeye çalıştığınız dizin içinde herhangi bir başka dizin veya dosya varsa
bu fonksiyon hata verecektir.

Mesela şöyle bir dizin yapısı düşünelim:

```python
|___ anadizin
 |___ dizin1
 |___ dizin2
 |___ dizin3
 |___ dizin4

```

Bu arada, bu dizin yapısını kolayca oluşturmak için ne yapmanız gerektiğini
biliyorsunuz:

```python
>>> os.makedirs('anadizin/dizin1/dizin2/dizin3/dizin4')

```

Anadizin altındayken şu komutlar hata verecektir:

```python
>>> os.rmdir('anadizin')
>>> os.rmdir(r'anadizin/dizin1')
>>> os.rmdir(r'anadizin/dizin1/dizin2/dizin3')

```

Çünkü bu dizinlerinin hiçbirinin içi boş değil; her birinin içinde birer dizin
var. Ama şu komut başarılı olacaktır:

```python
>>> os.rmdir(r'anadizin/dizin1/dizin2/dizin3/dizin4')

```

Bu şekilde yukarı doğru ilerleyerek sırayla bütün dizinleri silebilirsiniz:

```python
>>> os.rmdir(r'anadizin/dizin1/dizin2/dizin3/')
>>> os.rmdir(r'anadizin/dizin1/dizin2/')
>>> os.rmdir(r'anadizin/dizin1')
>>> os.rmdir(r'anadizin/')

```

#### os.removedirs()

osmodülününremovedirs()fonksiyonu, içi boş dizin yollarını silmemizi
sağlar. Peki bu ne demek?

Diyelim ki elimizde şöyle bir dizin yapısı var:

```python
|___ anadizin
 |___ dizin1
 |___ dizin2
 |___ dizin3
 |___ dizin4

```

Anadizin altından şu komutu verdiğimizde:

```python
>>> os.removedirs('anadizin/dizin1/dizin2/dizin3/dizin4')

```

Eğer bütün dizinlerin içi boşsa,anadizin’dendizin4’e kadar olan bütün
dizinler (anadizinvedizin4dahil) silinecektir.

#### os.stat()

osmodülününstat()fonksiyonu dosyalar hakkında bilgi almamızı sağlar.
Bu fonksiyonu kullanarak bir dosyanın boyutunu, oluşturulma tarihini,
değiştirilme tarihini ve erişilme tarihini sorgulayabiliriz.

stat()fonksiyonunu şöyle kullanıyoruz:

```python
>>> dosya = os.stat('dosya_adı')
>>> dosya

```

Buradan şuna benzer bir çıktı alırız:

```python
os.stat_result(st_mode=33279, st_ino=17732923532961356,
st_dev=1745874298, st_nlink=1, st_uid=0, st_gid=0,
st_size=495616, st_atime=1416488851, st_mtime=1415275662,
st_ctime=1415275658)

```

Bu, kendi içinde birtakım nitelikler barındıran özel bir veri tipidir. Bu veri
tipinin barındırdığı nitelikleri görmek için, her zaman olduğu gibidir()fonksiyonundan yararlanabilirsiniz:

```python
dir(dosya)

```

Burada özellikle işimize yarayacak olan nitelikler şunlardır:

dosyaya en son erişilme tarihi

dosyanın oluşturulma tarihi (Windows’ta)

dosyanın son değiştirilme tarihi

dosyanın boyutu

Mesela bir dosyanın boyutunu öğrenmek içinst_sizeniteliğini şu şekilde
kullanabiliriz:

```python
>>> dosya = os.stat('dosya_adı')
>>> dosya.st_size

```

Bu fonksiyon bize ‘bayt’ cinsinden bir çıktı verir. Bunu kilobayta çevirmek
için, bu değeri 1024’e bölebilirsiniz:

```python
>>> dosya.st_size / 1024

```

osmodülününstat()fonksiyonunu kullanarak bir dosyanın oluşturulma,
erişilme ve değiştirilme tarihlerini de elde edebilirsiniz:

```python
>>> dosya = os.stat('dosya_adı')
>>> dosya.st_ctime #oluşturulma tarihi
>>> dosya.st_atime #erişilme tarihi
>>> dosya.st_mtime #değiştirme tarihi

```

> **Uyarı**
> GNU/Linux’ta bir dosyanın ne zaman oluşturulduğunu öğrenmek mümkün
değildir. Dolayısıyladosya.st_ctimekomutu yalnızca Windows’ta bir dosyanın
oluşturulma tarihi verir. Bu komutu GNU/Linux’ta verdiğimizde elde edeceğimiz
şey dosyanın son değiştirilme tarihidir.

Uyarı

GNU/Linux’ta bir dosyanın ne zaman oluşturulduğunu öğrenmek mümkün
değildir. Dolayısıyladosya.st_ctimekomutu yalnızca Windows’ta bir dosyanın
oluşturulma tarihi verir. Bu komutu GNU/Linux’ta verdiğimizde elde edeceğimiz
şey dosyanın son değiştirilme tarihidir.

Bu arada, yukarıdaki komutların çıktısı size anlamsız gelmiş olabilir. Birazdan,datetimeadlı bir modülü öğrendiğimizde bu anlamsız görünen sayıları anlamlı
tarih bilgilerine nasıl dönüştüreceğimizi de anlatacağız.

#### os.system()

osmodülününsystem()fonksiyonu Python içinden sistem komutlarını veya
başka programları çalıştırabilmemizi sağlar. Mesela:

```python
>>> os.system('notepad.exe')

```

#### os.urandom()

osmodülününurandom()fonksiyonu rastgele bayt dizileri elde etmek için
kullanılabilir:

```python
>>> os.urandom(12)

```

Bu komut, 12 bayttan oluşan rastgele bir dizi oluşturur. Buradan elde ettiğiniz
rastgele değeri kriptografik çalışmalarda veya rastgele parola üretme
işlemlerinde kullanabilirsiniz.

#### os.walk()

Hatırlarsanız önceki sayfalardaosmodülü içindekilistdir()adlı bir
fonksiyondan söz etmiştik. Bu fonksiyon, bir dizinin içeriğini listeleme imkanı
veriyordu bize. Mesela o anda içinde bulunduğumuz dizinde hangi dosya ve
alt dizinlerin olduğunu öğrenmek için şöyle bir komut kullanabiliyorduk:

```python
>>> os.listdir('.')

['build.py', 'gtk', 'kitap', 'make.bat', 'Makefile',
 'meta_conf.py', 'py2', 'py3', 'theme', 'tk2', '__pycache__']

```

Gördüğünüz gibi bu fonksiyon yalnızca kendisine parametre olarak verilen dizinin
içeriğini listeliyor. Örneğin yukarıdaki çıktıda görünengtk,kitap,py2,py3,theme,tk2ve__pycache__birer dizin. Amalistdir()fonksiyonu bu dizinlerin de içine girip buradaki içeriği listelemeye çalışmıyor.
Eğer biz meselathemedizininin içeriğini de listelemek istersek bunu açıkça
belirtmemiz gerekir:

```python
>>> os.listdir('theme')

['layout.html', 'localtoc.html', 'pydoctheme',
 'sidebar.html', 'static']

```

Veyathemedizini içindekistaticadlı dizine de erişmek istersek bunu da şu
şekilde açık açık ifade etmemiz gerekir:

```python
>>> os.listdir('theme/static')

['basic.css', 'copybutton.js', 'py.png', 'sidebar.js']

```

Peki ya biz o anda içinde bulunduğumuz dizinden itibaren içe doğru bütün
dizinleri otomatik olarak taramak istersek ne yapacağız?

Bunun içinlistdir()fonksiyonunu kullanarak özyinelemeli (recursive) bir
fonksiyon yazabilirsiniz:

```python
import os

def tara(dizin):
 başlangıç = os.getcwd()
 dosyalar = []
 os.chdir(dizin)

 for öğe in os.listdir(os.curdir):
 if not os.path.isdir(öğe):
 dosyalar.append(öğe)
 else:
 dosyalar.extend(tara(öğe))

 os.chdir(başlangıç)
 return dosyalar

```

> **Not**
> Bu kodlarda henüz öğrenmediğimiz tek şeyos.path.isdir()fonksiyonu. Bu fonksiyon, kendisine parametre olarak verilen bir değerin
dizin olup olmadığını tespit etmemizi sağlıyor.

Not

Bu kodlarda henüz öğrenmediğimiz tek şeyos.path.isdir()fonksiyonu. Bu fonksiyon, kendisine parametre olarak verilen bir değerin
dizin olup olmadığını tespit etmemizi sağlıyor.

Yukarıdaki kodlarda öncelikle o anda içinde bulunduğumuz dizinin konumunubaşlangıçadlı bir değişkene atıyoruz. Çünkü daha sonra buraya dönmemiz
gerekecek:

```python
başlangıç = os.getcwd()

```

Ardındandosyalaradlı bir liste oluşturuyoruz:

```python
dosyalar = []

```

Bu liste, dizinler içindeki bütün dosyaları içinde barındıracak.

Daha sonra,tara()fonksiyonuna parametre olarak verilendizinadlı
dizinin içine giriyoruz:

```python
os.chdir(dizin)

```

Bu dizinin içine girdikten sonra, mevcut dizin içindeki bütün öğelerilistdir()fonksiyonu ile tek tek tarıyoruz:

```python
for öğe in os.listdir(os.curdir):
 ...

```

Eğer tarama sırasında karşılaştığımız öğe bir dizin değil ise:

```python
if not os.path.isdir(öğe):
 ...

```

Bu öğeyi, doğrudan en başta tanımladığımızdosyalaradlı listeye
gönderiyoruz:

```python
dosyalar.append(öğe)

```

Ama eğer tarama sırasında karşılaştığımız öğe bir dizin ise:

```python
else:
 ...

```

tara()fonksiyonunun en başına dönüp, tanımladığımız bütün işlemleri bu
dizin üzerine özyinelemeli olarak uyguluyoruz ve elde ettiğimiz öğeleridosyalaradlı listeyeextend()metodu ile işliyoruz:

```python
dosyalar.extend(tara(öğe))

```

Burada nedenappend()değil deextend()kullandığımızı anlamak için,
yukarıdaki kodu bir deappend()ile yazıp elde ettiğiniz çıktıyı
değerlendirebilirsiniz.

fordöngüsünden çıktıktan sonra da tekrar en baştaki konuma dönebilmek için
aşağıdaki komutu çalıştırıyoruz:

```python
os.chdir(başlangıç)

```

Eğer bu şekilde başa dönmezsek, dizin yapısı içindeki ilk alt dizine girildikten
sonra programımız o konumda takılı kalacağı için öteki üst dizinlerin içini
tarayamaz. Bunun ne demek olduğunu anlamak için kodları bir deos.chdir(başlangıç)kodu olmadan çalıştırmayı deneyebilirsiniz.

Yukarıdaki yöntem doğru olsa da, Python’da bir dizini en dibe kadar taramanın en
iyi yolu değildir. Python bize bu iş için özel bir fonksiyon sunar. İşte, bu
bölümde ele alacağımız bu fonksiyonun adıwalk().

Walkkelimesi İngilizcede ‘yürümek’ anlamına gelir.walk()fonksiyonu da,
kelimenin bu anlamına uygun olarak, dizinler içinde ‘yürünmesini’ sağlar. Gelin
bunu biraz açıklayalım.

Şöyle bir durum düşünün: Sabit diskinizde, bir dizin içinde pek çok alt dizine
dağılmış bir sürü dosya var. Yani şunun gibi:

```python
+anadizin
 |dosya.txt
 |dosya.doc
 |dosya.xls
 |dosya.jpeg
 +resimler
 |resim1.jpeg
 |resim2.jpeg
 |resim3.jpeg
 |resim4.jpeg
 +başkadosyalar
 |dosya.pdf
 |dosya.zip
 |dosya.mp3
 |dosya.ogg
 |dosya.jpeg

```

Siz bu iç içe geçmiş dosya yığını içinden, sonu.jpegile bitenleri tek bir
yerde toplamak istiyorsunuz. Elbette, eğer isterseniz bu.jpegdosyalarını tek
tek elle bulup istediğiniz yere taşıyabilirsiniz. Ama bu yöntem bir Python
programcısına yakışmaz, değil mi?

Python programcıları bu tür angaryaları kendi yapmak yerine Python’a yaptırmayı
tercih eder. O yüzden biz de bu işi yapmak için Python’dan yararlanacağız.

osmodülününwalk()fonksiyonunu kullanarak bu görevi rahatlıkla yerine
getirebilirsiniz.

Peki ama nasıl?

Öncelikle şu kodlar yardımıyla, yukarıdaki sözünü ettiğimiz dosya-dizin yapısını
oluşturalım. Böylece daha somut bir yapı üzerinde çalışma imkanı elde etmiş
oluruz:

```python
import os

uzantılar = ['txt', 'doc', 'xls',
 'jpeg', 'pdf', 'zip',
 'mp3', 'ogg', 'jpeg']

şablon1 = ['{}.{}'.format('dosya', i) for i in uzantılar[:4]]
şablon2 = ['resim{}.{}'.format(i, uzantılar[-1]) for i in range(1, 5)]
şablon3 = ['{}.{}'.format('dosya', i) for i in uzantılar[4:]]

dosyalar = [('anadizin', şablon1),
 ('resimler', şablon2),
 ('başkadosyalar', şablon3)]

os.makedirs(os.sep.join([dosya[0] for dosya in dosyalar]))

for dizin, şablon in dosyalar:
 for s in şablon:
 open(os.sep.join([dizin, s]), 'w')
 os.chdir(dizin)

```

Bu kodlarda, şu ana kadar görmediğimiz, öğrenmediğimiz hiçbir şey yok. Bu
kodları rahatlıkla anlayabilecek kadar Python bilgisine sahipsiniz.

Dosya-dizin yapımızı oluşturduğumuza göre,osmodülününwalk()fonksiyonunu bu yapı üzerinde nasıl kullanacağımıza geçebiliriz.

Şimdi ‘anadizin’ adlı klasörün bulunduğu dizin içinde etkileşimli kabuğu
başlatalım ve şu komutları verelim:

```python
>>> for i in os.walk('anadizin'):
... print(i)

```

Buradan şu çıktıyı alacağız:

```python
('anadizin', ['resimler'], ['dosya.doc', 'dosya.jpeg',
 'dosya.txt', 'dosya.xls'])
('anadizin\\resimler', ['başkadosyalar'], ['resim1.jpeg',
 'resim2.jpeg', 'resim3.jpeg', 'resim4.jpeg'])
('anadizin\\resimler\\başkadosyalar', [], ['dosya.jpeg',
 'dosya.mp3', 'dosya.ogg', 'dosya.pdf', 'dosya.zip'])

```

İnceleme kolaylığı açısından bu çıktının ilk kısmını ele alalım:

```python
('anadizin', ['resimler'], ['dosya.doc', 'dosya.jpeg',
 'dosya.txt', 'dosya.xls'])

```

Gördüğünüz gibi, burada üç öğeli bir demet var. Çıktının diğer kısımlarını da
incelerseniz aynı yapıyı göreceksiniz. Dolayısıylaos.walk()komutu bize şu
üç öğeden oluşan bir demet verir:

```python
(kökdizin, altdizinler, dosyalar)

```

Yukarıdaki çıktıyı incelediğinizde bu yapıyı rahatlıkla görebilirsiniz:

```python
kökdizin => 'anadizin'
altdizinler => ['resimler']
dosyalar => ['dosya.doc', 'dosya.jpeg',
 'dosya.txt', 'dosya.xls']

kökdizin => 'anadizin\\resimler'
altdizinler => ['başkadosyalar']
dosyalar => ['resim1.jpeg', 'resim2.jpeg',
 'resim3.jpeg', 'resim4.jpeg']

kökdizin => 'anadizin\\resimler\\başkadosyalar'
altdizinler => []
dosyalar => ['dosya.jpeg', 'dosya.mp3',
 'dosya.ogg', 'dosya.pdf',
 'dosya.zip']

```

Mesela bu üç öğeli demet içinden yalnızca dosyaları almak isterseniz şöyle bir
komut verebilirsiniz:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... print(dosyalar)

```

Burada,os.walk('anadizin')komutunun bize sunduğu üç öğeli demetin her bir
öğesini, şu satır yardımıyla tek tekkökdizin,altdizinlervedosyalaradlı değişkenlere atıyoruz:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... ...

```

Sonra da bu üçlü içinden,dosyalaradlı değişkeni ekrana yazdırıyoruz:

```python
>>> print(dosyalar)

```

Bu da bize şöyle bir çıktı veriyor:

```python
['dosya.doc', 'dosya.jpeg', 'dosya.txt', 'dosya.xls']
['resim1.jpeg', 'resim2.jpeg', 'resim3.jpeg', 'resim4.jpeg']
['dosya.jpeg', 'dosya.mp3', 'dosya.ogg', 'dosya.pdf', 'dosya.zip']

```

Gördüğünüz gibi, bu çıktıda ‘anadizin’ ve bunun altındaki bütün dizinlerde yer
alan bütün dosyalar var. Bu konunun başındawalk()fonksiyonunu tanımlarken
dediğimiz gibi,walk()fonksiyonu gerçekten de dizinler içinde ‘yürünmesini’
sağlıyor.

Bu fonksiyonu daha iyi anlamak için birkaç deneme daha yapalım:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... print(altdizinler)
...
['resimler']
['başkadosyalar']

```

Bu da bize ‘anadizin’ içindeki alt dizinlerin isimlerini veriyor.

Bir dekökdizindeğişkeninin ne olduğuna bakalım:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... print(kökdizin)
...
anadizin
anadizin\resimler
anadizin\resimler\başkadosyalar

```

Burada da o üçlü değişkenler arasındankökdizin’i yazdırdık ve gördük ki bu
değişken bize bütün kök dizinlere ilişkin yol bilgilerini, yani dizinlerin
adresini veriyor. Dolayısıylakökdizindeğişkeni iledosyalardeğişkenini
birleştirerek bir dosyanın tam adresini elde edebiliriz.

Dikkatlice bakın:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... for dosya in dosyalar:
... print(os.sep.join([kökdizin, dosya]))
...
anadizin\dosya.doc
anadizin\dosya.jpeg
anadizin\dosya.txt
anadizin\dosya.xls
anadizin\resimler\resim1.jpeg
anadizin\resimler\resim2.jpeg
anadizin\resimler\resim3.jpeg
anadizin\resimler\resim4.jpeg
anadizin\resimler\başkadosyalar\dosya.jpeg
anadizin\resimler\başkadosyalar\dosya.mp3
anadizin\resimler\başkadosyalar\dosya.ogg
anadizin\resimler\başkadosyalar\dosya.pdf
anadizin\resimler\başkadosyalar\dosya.zip

```

Bildiğiniz gibi,dosyadeğişkeninin bize verdiği veri tipi bir listedir. O
yüzden bu listenin öğelerini tek tek alabilmek için bu liste üzerinde de birfordöngüsü kurduğumuza dikkat edin.

Eğer yukarıdaki dizinler içinde yer alan bütün.jpegdosyalarını listelemek
istersek de şöyle bir kod yazabiliriz:

```python
>>> for kökdizin, altdizinler, dosyalar in os.walk('anadizin'):
... for dosya in dosyalar:
... if dosya.endswith('.jpeg'):
... print(dosya)
...
dosya.jpeg
resim1.jpeg
resim2.jpeg
resim3.jpeg
resim4.jpeg
dosya.jpeg

```

Gördüğünüz gibi,os.walk()fonksiyonu gayet pratik ve kullanışlı bir araç.

#### os.environ

osmodülününenvironadlı niteliği, kullandığımız işletim sistemindeki
çevre değişkenleri hakkında bilgi edinmemizi sağlar.

Bu nitelik alelade bir sözlüktür. Dolayısıyla bu sözlüğün içinde neler olduğunu
şu kodlarla görebilirsiniz:

```python
>>> for k, v in os.environ.items():
... print(k.ljust(10), v)

```

Sözlük içindeki istediğiniz bir değere nasıl erişeceğinizi biliyorsunuz:

```python
>>> os.environ['HOMEPATH']

'\\Documents and Settings\\fozgul'

>>> os.environ['USERNAME']

'FOZGUL'

```

Yalnız, Windows ve GNU/Linux işletim sistemlerinde çevre değişkenleri ve
bunların adları birbirinden farklı olduğu için, doğal olarakenvironniteliği
de farklı işletim sistemlerinde farklı çıktılar verir. Birden fazla işletim
sistemi üzerinde çalışacak şekilde tasarladığımız programlarda bu duruma dikkat
etmeliyiz. Örneğin Windows’ta kullanıcı adını veren çevre değişkeni ‘USERNAME’
iken, GNU/Linux’ta bu değişken ‘USER’ olarak adlandırılır.

#### os.path

osmodülü üzerindedir()fonksiyonunu uyguladığınızda, oradapathadlı
bir niteliğin olduğunu göreceksiniz. Bu nitelik, kendi içinde pek çok önemli
fonksiyon ve başka nitelik barındırır.

Şimdi bu bölümdeos.pathadlı bu niteliğin içeriğini inceleyeceğiz.

##### os.path.abspath()

abspath()fonksiyonu, bir dosyanın tam yolunun ne olduğunu söyler:

```python
>>> os.path.abspath('falanca.txt')

```

##### os.path.dirname()

dirname()fonksiyonu, bir dosya yolunun dizin kısmını verir:

```python
>>> os.path.dirname('/home/istihza/Desktop/falanca.txt')

'/home/istihza/Desktop'

```

Bu fonksiyonuabspath()fonksiyonu ile birlikte kullanabilirsiniz:

```python
>>> os.path.dirname(os.path.abspath('falanca.txt'))

'/home/istihza/Desktop'

```

##### os.path.exists()

exists()fonksiyonu bir dosya veya dizinin varolup olmadığını kontrol eder:

```python
>>> os.path.exists('/home/istihza/Desktop/falanca.txt')

```

Eğer böyle bir dosya varsa yukarıdaki kodTrueçıktısı, yoksaFalseçıktısı verir.

##### os.path.expanduser()

expanduser()fonksiyonu bilgisayardaki kullanıcıya ait dizinin adresini
verir:

```python
>>> os.path.expanduser('~')

'C:\\Documents and Settings\\fozgul'

```

veya:

```python
>>> os.path.expanduser('~')

'/home/istihza'

```

Bu fonksiyonu kullanarak, Windows’ta belirli bir kullanıcı ismi ve dizini de
oluşturabilirsiniz:

```python
>>> os.path.expanduser('~denizege')

'C:\\Documents and Settings\\denizege'

```

##### os.path.isdir()

isdir()fonksiyonu, kendisine parametre olarak verilen öğenin bir dizin olup
olmadığını sorgular:

```python
>>> os.path.isdir('/home/istihza')

```

Eğer parametre bir dizin iseTrue, eğer bir dosya iseFalseçıktısı
alınır.

##### os.path.isfile()

isfile()fonksiyonu, kendisine parametre olarak verilen öğenin bir dosya
olup olmadığını sorgular:

```python
>>> os.path.isfile('/home/istihza/falance.txt')

```

Eğer parametre bir dosya iseTrue, eğer bir dizin iseFalseçıktısı
alınır.

##### os.path.join()

join()fonksiyonu, kendisine verilen parametrelerden, ilgili işletim
sistemine uygun yol adresleri oluşturur:

```python
>>> os.path.join('dizin1', 'dizin2', 'dizin3') #Windows

'dizin1\\dizin2\\dizin3'

>>> os.path.join('dizin1', 'dizin2', 'dizin3')

'dizin1/dizin2/dizin3'

```

##### os.path.split()

split()fonksiyonu, bir yol adresinin son kısmını baş kısmından ayırır:

```python
>>> os.path.split('/home/istihza/Desktop')

('/home/istihza', 'Desktop')

```

Bu fonksiyonu kullanarak dosya adlarını dizin adlarından ayırabilirsiniz:

```python
>>> dizin, dosya = os.path.split('/home/istihza/Desktop/falanca.txt')
>>> dizin

'/home/istihza/Desktop'

>>> dosya

'falanca.txt'

```

##### os.path.splitext()

splitext()fonksiyonu dosya adı ile uzantısını birbirinden ayırmak için
kullanılır:

```python
>>> dosya, uzantı = os.path.splitext('falanca.txt')
>>> dosya

'falanca'

>>> uzantı

'.txt'

```

Gördüğünüz gibi, kendi içinde pek çok nitelik ve fonksiyon barındıranos.path,
kullandığımız işletim sistemine uygun şekilde dizin işlemleri yapabilmemizi
sağlayan son derece faydalı bir araçtır.

Gelin isterseniz şimdi biraz buos.pathniteliğinin bazı önemli
özelliklerinden söz edelim.

Hatırlarsanız önceki derslerimizde, modüllerin kaynak dosyalarını görmemizi
sağlayan__file__adlı bir araçtan söz etmiştik. Mesela bu aracıosmodülü üzerinde uyguladığımızda şuna benzer bir çıktı alıyorduk:

```python
>>> os.__file__

'C:\\Python\\lib\\os.py'

```

Demek kiosmodülünün kaynak kodları bu dizin içinde yer alıyormuş…

Normalde__file__niteliğini yalnızca modül adlarına uygulayabilirsiniz.
Modüllerin nitelik ve fonksiyonları üzerinde__file__aracı kullanılamaz:

```python
>>> os.name.__file__

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'str' object has no attribute '__file__'

>>> os.walk.__file__

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
AttributeError: 'function' object has no attribute '__file__'

```

Amaosmodülününpathniteliği için durum biraz farklıdır:

```python
>>> os.path.__file__

```

Eğer bu komutu Windows’ta verdiyseniz şu çıktıyı alırsınız:

```python
'C:\Python37\lib\ntpath.py'
```

Ama eğer bu komutu GNU/Linux’ta verdiyseniz şuna benzer bir çıktı alırsınız:

```python
'/home/python37/lib/python3.7/posixpath.py'
```

Gördüğünüz gibi,__file__,os.pathüzerinde kullanılabiliyor. Yukarıdaki
çıktılardan anladığımıza göreos.pathniteliği Windows’tantpath,
GNU/Linux’ta iseposixpathadlı bir modüle atıfta bulunuyor.

Dolayısıyla aslında bizos.pathniteliğini kullanırken, eğer Windows’ta isekntpathadlı bir modülü, ama eğer GNU/Linux’ta isekposixpathadlı bir
modülü içe aktarmış oluyoruz.

Eğeros.pathadlı ortak bir arayüz olmasaydı, yukarıdaos.pathbaşlığı
altında incelediğimiz araçları kullanabilmek için, kullandığımız işletim
sistemine göreposixpathveyantpathmodüllerinden uygun olanını
kendimiz elle içe aktarmak zorunda kalacaktık:

```python
if os.name == 'nt':
 import ntpath as path

else:
 import posixpath as path

```

Ama Python programlama dilinin bizeos.pathadlı niteliği sunmuş olması
sayesinde Windows işletim sistemi içinntpath, GNU/Linux işletim sistemi
için iseposixpathmodülünü ayrı ayrı içe aktarmamıza gerek kalmıyor. Bütün
işi bizim yerimize Python hallediyor. Böylece farklı işletim sistemlerine
ilişkin birbirinden farklı işlemleri,os.pathadlı tek bir arayüz üzerinden
gerçekleştirebiliyoruz.

### time Modülü

timemodülü, bir önceki bölümde öğrendiğimizdatetimemodülüne benzer.
Hatta bu iki modülün aynı işi yapan ortak nitelik ve fonksiyonları vardır.
Ancakdatetimemodülünden farklı olaraktimemodülünü daha çok saatle
ilgili işlemleri yapmak için kullanacağız.

Her zaman olduğu gibi, bu modülü kullanabilmek için de öncelikle modülü içe
aktarmamız gerekiyor:

```python
>>> import time

```

Modülü içe aktardığımıza göre, artık modülün içeriğinden yararlanabiliriz.

#### gmtime()

Python’da (ve başka programlama dillerinde), zaman-tarih hesaplamalarında
‘zamanın başlangıcı’ (EPOCH) diye bir kavram bulunur. ‘Zamanın başlangıcı’, bir
işletim sisteminin, tarih hesaplamalarında sıfır noktası olarak aldığı tarihtir.
Kullandığınız işletim sisteminin hangi tarihi ‘zamanın başlangıcı’ olarak kabul
ettiğini bulmak için şu komutu verebilirsiniz:

```python
>>> time.gmtime(0)

```

Buradan şu çıktıyı alıyoruz:

```python
time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0,
tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)

```

Bu,struct_timeadlı özel bir veri tipidir. Bu veri tipi içindeki niteliklere
şu şekilde ulaşabilirsiniz:

```python
>>> epoch = time.gmtime(0)
>>> epoch.tm_year #yıl

1970

>>> epoch.tm_mon #ay

1

>>> epoch.tm_mday #gün

1

```

Demek ki zamanın başlangıcı 1 Ocak 1970 tarihi olarak alınıyormuş… İşte
bilgisayarımız, içinde bulunduğumuz zaman ve saati, bu başlangıç zamanından bu
yana geçen saniyeleri hesaplayarak bulur.

gmtime()fonksiyonunu parametresiz olarak kullandığınızda, o anda içinde
bulunduğunuz tarih ve saat bilgisini elde edersiniz.

time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10,
tm_hour=12, tm_min=5, tm_sec=33, tm_wday=2, tm_yday=344,
tm_isdst=0)

Ancak bu çıktı, özellikle saat kısmı konusunda her zaman doğru olmayabilir.
Çıktının birkaç saat saptığını görebilirsiniz.

#### time()

time()fonksiyonu,epok’tan itibaren, o anda içinde bulunduğumuz ana
kadar geçen toplam saniye miktarını verir:

```python
>>> time.time()

1418213083.726988

```

Elde ettiğiniz bu değeri,gmtime()fonksiyonunu kullanarak anlamlı bir tarih
değerine dönüştürebilirsiniz:

```python
>>> time.gmtime(time.time())

time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10,
tm_hour=12, tm_min=9, tm_sec=19, tm_wday=2, tm_yday=344,
tm_isdst=0)

```

Ancak bu çıktı da özellikle saat kısmında sapmalara uğrayabilir.

#### localtime()

Tıpkıgmtime()fonksiyonundan olduğu gibi, anlık tarih ve zaman bilgisini
birstruct_timenesnesi olarak almak içinlocaltime()fonksiyonunu da
kullanabiliriz. Bu fonksiyon bize yerel saati doğru bir şekilde verecektir:

```python
>>> time.localtime()

time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10,
tm_hour=14, tm_min=24, tm_sec=21, tm_wday=2, tm_yday=344, tm_isdst=0)

```

Bu nesnenin içindeki yıl, ay ve gün gibi bilgilere tek tek nasıl
erişebileceğinizi biliyorsunuz.

#### asctime()

Başta da söylediğimiz gibi,timemodülü,datetimemodülüne benzer.
Bunların aynı işi gören çeşitli fonksiyonları vardır. Bir örnek verelim.

Hatırlarsanız, bugünün tarihini bir karakter dizisi olarak almak içindatetimemodülünü şu şekilde kullanabiliyorduk:

```python
>>> import datetime
>>> an = datetime.datetime.now()
>>> datetime.datetime.ctime(an)

'Wed Dec 10 13:56:22 2014'

```

Yukarıdaki işlemitimemodülününasctime()fonksiyonunu kullanarak da
yapabiliriz:

```python
>>> import time
>>> time.asctime()

'Wed Dec 10 13:58:31 2014'

```

asctime()fonksiyonu tercihe bağlı bir parametre de alabilir. İsterseniz bu
fonksiyona 9 öğeli bir demet veya birstruct_timenesnesi verebilirsiniz.

Yukarıda,gmtime()fonksiyonunun birstruct_timenesnesi ürettiğini
öğrenmiştik. Dolayısıyla bu nesneyiasctime()fonksiyonuna parametre olarak
verebilirsiniz:

```python
>>> time.asctime(time.gmtime())

'Wed Dec 10 12:14:29 2014'

>>> time.asctime(time.gmtime(0))

'Thu Jan 1 00:00:00 1970'

```

Aynı şekildelocaltime()fonksiyonunun da bize birstruct_time()nesnesi
verdiğini biliyoruz. Dolayısıyla bu fonksiyon daasctime()fonksiyonuna
parametre olarak verilebilir:

```python
>>> time.asctime(time.localtime())

'Wed Dec 10 14:28:05 2014'

```

Veya, sırasıyla yıl, ay, gün, saat, dakika, saniye, haftanın günü, yılın günü,
gün ışığından yararlanma durumu değerini içeren bir demet de
oluşturabilir, daha sonra bunuasctime()fonksiyonuna parametre olarak
verebilirsiniz:

```python
>>> demet = (2014, 5, 27, 13, 45, 23, 0, 0, 0)
>>> time.asctime(demet)

```

Ancak özellikle haftanın günü, yılın günü ve gün ışığından yararlanma durumu
bilgilerini doğru tahmin etmek zor olduğu için, bu demeti elle oluşturmanızı pek
tavsiye etmem.

#### strftime()

Hatırlarsanızdatetimemodülünü anlatırken,datetimesınıfı içindekistrftime()adlı bir fonksiyondan söz etmiştik. Bu fonksiyonun, tarih-saat
bilgisi içeren karakter dizilerini manipüle edebilmemizi sağladığını
biliyorsunuz.

Bu fonksiyonu şöyle kullanıyorduk:

```python
>>> import datetime
>>> an = datetime.datetime.now()
>>> datetime.datetime.strftime(an, '%c')

'10.12.2014 14:57:48'

```

İşte yukarıdaki işlemi,timemodülününstrftime()fonksiyonunu
kullanarak biraz daha pratik bir şekilde gerçekleştirebiliriz:

```python
>>> import time
>>> time.strftime('%c')

'10.12.2014 14:58:02'

```

datetimemodülünü incelerken gördüğümüz tarih biçimlendiricileritimemodülü için de geçerlidir:

hafta gününün kısaltılmış adı

hafta gününün tam adı

ayın kısaltılmış adı

ayın tam adı

tam tarih, saat ve zaman bilgisi

sayı değerli bir karakter dizisi olarak gün

belli bir tarihin, yılın kaçıncı gününe denk geldiğini gösteren 1-366 arası bir sayı

sayı değerli bir karakter dizisi olarak ay

belli bir tarihin yılın kaçıncı haftasına geldiğini gösteren 0-53 arası bir sayı

yılın son iki rakamı

yılın dört haneli tam hali

tam tarih bilgisi

tam saat bilgisi

> **Uyarı**
> Sistem yerelininlocalemodülü aracılığıyla Türkçeye ayarlanmış
olması gerektiğini unutmuyoruz:

Uyarı

Sistem yerelininlocalemodülü aracılığıyla Türkçeye ayarlanmış
olması gerektiğini unutmuyoruz:

```python
import locale
locale.setlocale(locale.LC_ALL, 'turkish')

```

#### strptime()

timemodülününstrptime()fonksiyonunun yaptığı iş,datetimemodülünündatetimesınıfınınstrptime()fonksiyonunun yaptığı işe çok
benzer:

```python
>>> import datetime
>>> t = '27 Mayıs 1980'
>>> tarih = datetime.datetime.strptime(t, '%d %B %Y')
>>> tarih

datetime.datetime(1980, 5, 27, 0, 0)

```

Burada ‘27 Mayıs 1980’ tarihini,strptime()fonksiyonu yardımıyla birdatetimenesnesine dönüştürdük. Aynı şeyi şu şekilde de yapabiliriz:

```python
>>> import time
>>> t = '27 Mayıs 1980'
>>> tarih = time.strptime(t, '%d %B %Y')
>>> tarih

time.struct_time(tm_year=1980, tm_mon=5, tm_mday=27,
tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=148,
tm_isdst=-1)

```

Gördüğünüz gibi,timemodülününstrptime()fonksiyonudatetimemodülü içindekistrptime()fonksiyonunun aksine birstruct_timenesnesi
veriyor.

#### sleep()

sleep()fonksiyonu,timemodülünün en sık kullanılan araçlarından bir
tanesidir. Bu fonksiyonu kullanarak kodlarımızın işleyişini belli sürelerle
kesintiye uğratabiliriz.

Basit bir örnek verelim:

```python
>>> for i in range(10):
... time.sleep(1)
... print(i)

```

Bu kodları çalıştırdığınızda, 0’dan 10’a kadar olan sayılar ekrana basılırken
her bir sayı arasına 1’er saniyelik duraklamalar eklendiğini göreceksiniz. Eğer
arzu ederseniz bu süreyi 1 saniyenin de altına çekebilirsiniz:

```python
>>> for i in range(10):
... time.sleep(0.5)
... print(i)

```

Gördüğünüz gibi,sleep()fonksiyonuna0.5parametresini vererek, duraklama
süresinin 500 milisaniye olmasını sağladık.

timemodülününsleep()fonksiyonunu, kodlarınız arasına duraklama
eklemek istediğiniz her durumda kullanabilirsiniz.

### curses Modülü

#### curses Nedir?

Curses kütüphanesi, metin tabanlı terminaller için terminalden bağımsız bir ekran boyama ve klavye kullanımı kolaylığı sağlar. Bu tip terminaller, VT100s, Linux konsolu ve çeşitli programlar tarafından simüle edilmiş terminallerdir. Ekran terminalleri imleci hareket ettirmek, ekranı kaydırmak ve alanları silmek gibi bazı genel işlemleri yapabilmek için çeşitli kontrol kodlarını destekler. Farklı terminaller geniş ölçüde değişik kodlar kullanırlar ve genellikle kendi küçük tuhaflıkları vardır.

Curses kütüphanesi oldukça temel işlevsellikler sunar, programcıya, örtüşmeyen çoklu metin pencerelerini içeren ekranların soyutlanmasını sağlar. Bir pencerenin içerikleri çeşitli şekillerde değişebilir - bir metin girme, bu metni silme, bu metnin görüntüsünü değiştirme - ve Curses kütüphanesi doğru çıktıyı oluşturabilmek için terminale hangi kontrol kodlarının gönderilmesi gerektiğini çözer. Curses; düğmeler, onay kutuları, veya diyaloglar gibi kullanıcı arayüzü konseptleri sağlamaz; eğer bu gibi özelliklere ihtiyacınız varsa, Urwid gibi bir kullanıcı arayüzü kütüphanesini kullanmayı düşünün.

Curses kütüphanesi ilk olarak BSD Unix için yazılmıştır; AT&T’nin Unix’in sonraki System V sürümleri için bir çok geliştirme ve yeni işlev eklendi. BSD curses artık muhafaza edilmiyor, AT&T’nin açık kaynak uygulama arayüzü olan ncurses onun yerine getirildi. Eğer Linux veya FreeBSD gibi açık kaynak Unix kullanıyorsanız, sisteminiz neredeyse kesinlikle ncurses kullanıyor demektir. Madem hali hazırdaki bir çok ticari Unix sürümü System V kodu üzerine temellenmiş, burada bahsedilen bütün işlevler büyük olasılıkla kullanılabilir olacaktır. Bazı tescilli Unixlerin taşıdığı eski curses sürümleri her özelliği desteklemeyebilir.

#### Python Curses Modülü

Python modülü, curses tarafından sağlanan C işlevleri üzerinde basit bir sarıcıdır; eğer C’de curses programlamaya zaten aşinaysanız, bu bilgiyi Python’a taşımak gerçekten kolaydır. En büyük fark, Python arayüzeyininaddstr(),mvaddstr()vemvwaddstr()gibi değişik C işlevlerini tek biraddstr()metodunda birleştirerek işleri daha kolay yoldan halletmesidir. Bunu birazdan biraz daha ayrıntılı bir şekilde göreceğiz.

#### Bir Curses Uygulamasını Başlatma ve Sonlandırma

Curses ile bir şey yapmadan önce, curses ilklendirilmelidir. Bu ilklendirme işlemiinitscr()işlevini çağırarak yapılır. Bu işlev terminal tipini belirler, gerekli bütün kurulum kodlarını terminale gönderir ve çeşitli iç veri yapılarını oluşturur. Eğer başarılı olursa,initscr()tüm ekranı temsil eden bir pencere geri döndürür; bu ekrana genellikle C değişkenine karşılık gelen isimden sonra stdscr ismi verilmiştir:

```python
import curses
stdscr = curses.initscr()

```

Genellikle curses uygulamaları tuşları okuyabilmek ve onları sadece belli koşullar altında görüntüleyebilmek için tuşların ekranda otomatik olarak yansımasını devre dışı bırakır. Bunun içinnoecho()işlevini çağırmak gerekir:

```python
curses.noecho()

```

Uygulamaların , Enter tuşuna basılmasına ihtiyaç duyulmadan, anında tuşlara tepki vermesi gerekecektir; buna cbreak modu denir, ve tampon girdi moduna zıttır:

```python
curses.cbreak()

```

Terminaller genellikle imleç tuşları veya Page Up ve Home gibi gezinme tuşlarını çoklu kaçış dizisi olarak geri dönderir. Uygulamanızı bazı serileri beklemek ve buna göre işlemek için yazabilecekken, curses bunu sizin yapar;curses.KEY_LEFTgibi bir özel karakteri geri dönderir. Curses’in bu işlemi yapabilmesi için keypad modunu aktif hale getirmelisiniz:

```python
stdscr.keypad(True)

```

Bir curses uygulamasını sonlandırmak yeni bir tanesini başlatmaktan çok daha kolaydır. Aşağıdakileri, curses’e uygun hale getirilmiş terminal ayarlarını tersine çevirmek için çağırmanız gerekebilir:

```python
curses.nocbreak()
stdscr.keypad(False)
curses.echo()

```

Ardından terminalin ilk işletim modunu yüklemek içinendwin()’i çağırın:

```python
curses.endwin()

```

Şimdi yavaş yavaş örnekler üzerinde curses modülünü daha iyi anlamaya çalışalım.

#### Örnekler:

#### Örnek-1:

Ekranın ortasına bir “hello world!” yazısı yerleştirelim.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses

ekran = curses.initscr()
boyutlar = ekran.getmaxyx()
ekran.addstr(int(boyutlar[0]/2), int(boyutlar[1]/2 - 6), "hello world!",
 curses.A_BOLD)
ekran.refresh()
ekran.getch()
curses.endwin()

```

Kodların Açıklamaları:

Önce gerekli modül programın içine aktarılır:

```python
import curses

```

Curses ile işlem yapmadan önce mutlaka ekranın tanıtılması gerekiyor:

```python
ekran = curses.initscr()

```

Yazıyı ekrana yerleştirmek için satır ve sütun numaralarını yazabileceğimiz gibi, Terminal ekran boyutunun ölçülerini referans alarak bazı özel durumlarda ne yapılması gerektiğini belirtebiliriz:

```python
boyutlar = ekran.getmaxyx()

```

Diyelim yazıyı terminal ekranının tam ortasına yerleştirmek istiyoruz, o zaman sütun ve satır parametrelerine ekran ölçülerinin yarısını değer olarak verebiliriz. Ancak“hello world!”ifadesi 12 karakterden oluştuğu için, bu karakter uzunluğunun yarısını satır değerinden çıkarırız:

```python
ekran.addstr(int(boyutlar[0]/2), int(boyutlar[1]/2 - 6), "hello world!",
 curses.A_BOLD)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

Karakterleri yakalayalım:

```python
ekran.getch()

```

Herhangi bir tuşa basılınca ekran sonlansın:

```python
curses.endwin()

```

#### Örnek-2:

Sürekli y ekseninin ortasında bulunan ama x ekseni boyunca hareket eden bir “hello world!” yazısı oluşturalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time

ekran = curses.initscr()
boyutlar = ekran.getmaxyx()
for i in range(boyutlar[1] - len("hello world!")):
 ekran.clear()
 ekran.addstr(int(boyutlar[0]/2), i, "hello world!", curses.A_BOLD)
 ekran.refresh()
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Modülleri programın içine aktaralım:

```python
import curses
import time

```

Her zamanki gibi önce ekran tanıtılır:

```python
ekran = curses.initscr()

```

Yine ekranımızın maksimum boyutlarını tanımlayalım:

```python
boyutlar = ekran.getmaxyx()

```

Yazının terminal ekranında, bir animasyon gibi hareket etmesini istiyorsak, bir for döngüsü içinde sütun ve satırları anlık olarak değiştirebiliriz:

```python
for i in range(boyutlar[1] - len("hello world!")):

```

Ekranı temizleyelim:

```python
ekran.clear()

```

Sürekli y ekseninin ortasında olan ve x ekseninin i parametresine göre değişen“hello world!”yazısını kalın harflerle ekrana hareketli bir şekilde bastıralım:

```python
ekran.addstr(int(boyutlar[0]/2), i, "hello world!", curses.A_BOLD)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

time.sleep()fonksiyonunu tanımlamadığınızda ne olacağını görmek için fonksiyonu yoruma alın:

```python
time.sleep(0.05)

```

Ve programdan terminali eski haline getirecek şekilde çıkalım:

```python
curses.endwin()

```

#### Örnek-3:

x ve y eksenleri boyunca hareket eden bir “hello world!” yazısı oluşturalım. Dilerseniz bu uygulamayı bir ekran koruyucu olarak da kullanabilirsiniz.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time

ekran = curses.initscr()
boyutlar = ekran.getmaxyx()
ekran.nodelay(1)
q = -1
x, y = 0, 0
dusey, yatay = 1, 1
while q < 0:
 ekran.clear()
 ekran.addstr(y, x, "hello world!", curses.A_BOLD)
 ekran.refresh()
 y += dusey
 x += yatay
 if y == boyutlar[0] - 1:
 dusey = -1
 elif y == 0:
 dusey = 1
 if x == boyutlar[1] - len("hello world!") - 1:
 yatay = -1
 elif x == 0:
 yatay = 1
 q = ekran.getch()
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Bu örnekte kullanacağımız gerekli modülleri programın içine aktaralım:

```python
import curses
import time

```

Her zamanki gibi önce ekranı tanıtalım:

```python
ekran = curses.initscr()

```

Ekranın maksimum boyutlarını alalım:

```python
boyutlar = ekran.getmaxyx()

```

nodelay()’in parametresi1 (True)olursa yazımız ekranda hareket edebilir,0 (False)olursa da yazı sabit bir şekilde durur:

```python
ekran.nodelay(1)

```

Döngü değişkenini tanımlıyoruz. Bu değişken basılan her tuşu temsil edecek. Böylece herhangi bir tuşa bastığımızda programdan çıkabiliriz:

```python
q = -1

```

Döngüyle birlikte değişecek olan ekran satır ve sütun değerlerini ilk etapta 0 olarak belirliyoruz:

```python
x, y = 0, 0

```

Satır ve sütunların değerleri, biri düşey diğeri yataya müdahele edecek değişkenlere göre değiştirilecek. Bu yüzdenduseyveyatayisminde iki tane değişken oluşturalım:

```python
dusey, yatay = 1, 1

```

Şimdi döngümüzü oluşturmaya geçelim:

```python
while q < 0:

```

Döngü her başa sardığında ekran temizlensin:

```python
ekran.clear()

```

Ekrandaki yazı hep kalın harflerle“hello world!”yazısı olsun:

```python
ekran.addstr(y, x, "hello world!", curses.A_BOLD)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

Döngüyle birliktexvey’nin değerleriduseyveyataydeğişkenlerine göre artırılır:

```python
y += dusey
x += yatay

```

Şayetymaksimum değerine ulaşırsa,duseydeğişkeni -1’e eşitlenir. Böylece negatif y yönünde hareket edebiliriz:

```python
if y == boyutlar[0] - 1:
 dusey = -1

```

Şayetyminimum değerine ulaşırsa,dusey’ değişkeni 1’e eşitlenir. Böylece pozitif y yönünde hareket edebiliriz:

```python
elif y == 0:
 dusey = 1

```

Şayetxmaksimum değerine ulaşırsa,yataydeğişkeni -1’e eşitlenir. Böylece negatif x yönünde hareket edebiliriz:

```python
if x == boyutlar[1] - len("hello world!") - 1:
 yatay = -1

```

Şayetxminimum değerine ulaşırsa,yataydeğişkeni 1’e eşitlenir. Böylece pozitif x yönünde hareket edebiliriz:

```python
elif x == 0:
 yatay = 1

```

Ekranda bir tuşa bastığımız zaman programdan çıkabilmemiz için,qdeğişkeninin bütün harfleri temsil etmesini sağlayalım:

```python
q = ekran.getch()

```

Ekrandaki yazının hareketliliğitime.sleep()fonksiyonu ile biraz azaltalım:

```python
time.sleep(0.05)

```

Ve normal terminal ekranına geri dönelim:

```python
curses.endwin()

```

#### Örnek-4

‘asdw’ tuşlarıyla hareket eden bir “hello world!” yazısı oluşturalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time

ekran = curses.initscr()
curses.noecho()
boyutlar = ekran.getmaxyx()
ekran.nodelay(1)
q = -1
x, y = 0, 0
while q != ord("q"):
 ekran.clear()
 ekran.addstr(y, x, "hello world!", curses.A_BOLD)
 ekran.refresh()
 q = ekran.getch()
 if q == ord("w") and y > 0:
 y -= 1
 elif q == ord("s") and y < boyutlar[0] - 1:
 y += 1
 elif q == ord("a") and x > 0:
 x -= 1
 elif q == ord("d") and x < boyutlar[1] - len("hello world!") - 1:
 x += 1
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Bu örnekte kullanacağımız modülleri içe aktaralım:

```python
import curses
import time

```

Yine her zamanki gibi önce ekranı oluşturalım:

```python
ekran = curses.initscr()

```

Bastığımız tuş ekrana yansımasın diye,curses.noecho()fonksiyonunu kullanacağız. Farkı görmek için bu fonksiyonu yoruma alın:

```python
curses.noecho()

```

Yine ekran boyutlarını alalım:

```python
boyutlar = ekran.getmaxyx()

```

Hareketi sağlamak içinnodelay()fonksiyonunun değerini 1 olarak ayarlayalım:

```python
ekran.nodelay(1)

```

Her tuşu temsil edecek olanqdeğişkenimizi tanımlayalım:

```python
q = -1

```

Bu sefer ekrandaki yazının değişen konumlarınıxveydeğerlerine göre belirleyelim. Başlangıç
değerlerini 0, 0 yazıyoruz:

```python
x, y = 0, 0

```

Şimdi döngümüzü oluşturmaya geçelim.qtuşuna basılmadığı sürece döngü devam etsin:

```python
while q != ord("q"):

```

Döngü her başa sardığındaclear()ile yine ekranı temizleyelim:

```python
ekran.clear()

```

Ekranın y, x konumuna “hello world!” stringini kalın harfli olacak şekilde ekleyelim:

```python
ekran.addstr(y, x, "hello world!", curses.A_BOLD)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

qtuşunun bütün tuşları temsil etmesini sağlayalım:

```python
q = ekran.getch()

```

Şayet kullanıcıwtuşuna basarsa vey’nin değeri 0’dan büyükse,y’nin değeri 1 birim azalsın:

```python
if q == ord("w") and y > 0:
 y -= 1

```

Şayet kullanıcıstuşuna basarsa vey’nin değeri maksimum değerinden küçükse,y’nin değeri 1 birim artırılsın:

```python
elif q == ord("s") and y < boyutlar[0] - 1:
 y += 1

```

Şayet kullanıcıatuşuna basarsa vex’in değeri 0’dan büyükse,x’in değeri 1 birim azalsın:

```python
elif q == ord("a") and x > 0:
 x -= 1

```

Şayet kulanıcıdtuşuna basarsa vex’in değeri maksimum değerinden küçükse;x’in değeri 1 birim artırılsın:

```python
elif q == ord("d") and x < boyutlar[1] - len("hello world!") - 1:
 x += 1

```

time.sleep()’i niye kullandığımızı merak ediyorsanız, bu kodu yoruma ekleyin ve farkı gözlemleyin:

```python
time.sleep(0.05)

```

Ve bizi programdan terminali bozmadan çıkaracak olan komutu yazmayı unutmuyoruz:

```python
curses.endwin()

```

#### Örnek-5:

“asdw” tuşlarıyla hareket eden ve “1, 2, 3” tuşlarıyla renk değiştiren bir “hello world!” yazısı oluşturalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time

ekran = curses.initscr()
curses.start_color()
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
curses.noecho()
boyutlar = ekran.getmaxyx()
ekran.nodelay(1)
g = 1
q = -1
x, y = 0, 0
while q != ord("q"):
 ekran.clear()
 ekran.addstr(y, x, "hello world!", curses.color_pair(g))
 ekran.move(boyutlar[0] - 1, boyutlar[1] - 1)
 ekran.refresh()
 q = ekran.getch()
 if q in range(49, 52):
 g = int(chr(q))
 if q == ord("w") and y > 0:
 y -= 1
 elif q == ord("s") and y < boyutlar[0] - 1:
 if y == boyutlar[0] - 2 and x == boyutlar[1] - \
 len("hello world!"):
 pass
 else:
 y += 1
 elif q == ord("a") and x > 0:
 x -= 1
 elif q == ord("d") and x < boyutlar[1] - len("hello world!"):
 if y == boyutlar[0] - 1 and x == boyutlar[1] - \
 len("hello world!") - 1:
 pass
 else:
 x += 1
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Her zamanki gibi kullanacağımız modülleri programın içine aktaralım:

```python
import curses
import time

```

Yine önce ekranı tanımlıyoruz:

```python
ekran = curses.initscr()

```

Herhangi bir renklendirme işlemine geçmeden önce renklendirmeyi başlatmamız gerekiyor:

```python
curses.start_color()

```

Şimdi renk çiftlerini sıralarını belirterek oluşturmaya geçebiliriz:

```python
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)

```

Yine bastığımız herhangi bir tuş ekranda yansıma oluşturmasın:

```python
curses.noecho()

```

Maksimum ekran boyutlarını bir değişkene kaydedelim:

```python
boyutlar = ekran.getmaxyx()

```

Yine ekrandaki harekette bir gecikme olmaması içinnodelay()’in parametresini 1 olarak ayarlıyoruz:

```python
ekran.nodelay(1)

```

Yukarıda tanımladığımız renk çiftlerini kullanabilmek için bir değişken tanımlayalım. Bu değişken sayesinde renk çiftlerine, sıra numarası sayesinde erişebileceğiz:

```python
g = 1

```

Şimdi de her zamanki gibi her tuşu temsil edecekqdeğişkenimizi tanımlayalım:

```python
q = -1

```

Ekrana yazıyı yinexveydeğerlerine göre yerleştireceğiz. 0’a 0“hello world!”yazısının başlangıç değerleri olsun:

```python
x, y = 0, 0

```

Döngümüzü tanımlayalım. Döngüqtuşuna basılmadığı sürece devam etsin:

```python
while q != ord("q"):

```

Her zamanki gibi ekranımızı tamamen temizleyelim:

```python
ekran.clear()

```

Ekranınyvexkonumuna“hello world!”yazısını yerleştirelim. Aşağıdakicurses.color_pair(g)’dekigbirazdan tanımlayacağımız tuşlara bastığımızda renk değiştirmeye yarayacak:

```python
ekran.addstr(y, x, "hello world!", curses.color_pair(g))

```

İmleci ekranın en sonuna götürelim. Bu fonksiyonu kullanmadığımız zaman oluşacak olan farkı görebilmek için fonksiyonu yoruma alın:

```python
ekran.move(boyutlar[0] - 1, boyutlar[1] - 1)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

qbütün tuşları temsil ediyor olsun:

```python
q = ekran.getch()

```

chr(49)’danchr(52)’ye kadar olan karakterler 1, 2 ve 3’tür. Şayet kullanıcı bu tuşlara basarsagdeğişkeni değişecek ve böylece“hello world!”yazımız farklı renklere sahip olacak:

```python
if q in range(49, 52):
 g = int(chr(q))

```

Şayet kullanıcıwtuşuna basarsa vey’nin değeri 0’dan büyükse,ydeğişkeninin değeri 1 birim azalsın:

```python
if q == ord("w") and y > 0:
 y -= 1

```

Şayet kullanıcıstuşuna basarsa vey’nin değeri maksimum değerin 1 birim eksiğinden küçükse:

```python
elif q == ord("s") and y < boyutlar[0] - 1:

```

Yukarıdaki koşul altında şayetymaksimum değerinden 2 birim küçükse vex’de maksimum değere ulaşmışsa, hiç bir işlem yapılmasın:

```python
if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"):
 pass

```

Aksi taktirde,ydeğişkeninin değeri 1 birim artsın:

```python
else:
 y += 1

```

Şayet kullanıcıatuşuna basarsa vex’in değeri 0’dan büyükse,xdeğişkeninin değeri 1 birim azalsın:

```python
elif q == ord("a") and x > 0:
 x -= 1

```

Şayet kullanıcıdtuşuna basarsa vex’in değeri maksimum değerden küçükse:

```python
elif q == ord("d") and x < boyutlar[1] - len("hello world!"):

```

Şayet yukarıdaki koşul altınday’nin vex’in değerleri max değerlerinden 1 birim küçüğüne eşitse; hiç bir işlem yapılmasın:

```python
if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1:
 pass

```

Aksi taktirde,xdeğişkeninin değeri 1 birim artırılsın:

```python
else:
 x += 1

```

time.sleep()’in neden kullanıldığını öğrenmek için bu fonksiyonun başına yorum satırı işareti getirin:

```python
time.sleep(0.05)

```

Ve programdan çıkıldığında terminal tekrar eski haline getirilsin:

```python
curses.endwin()

```

#### Örnek-6:

“asdw” tuşlarıyla hareket eden, “1, 2, 3” tuşlarıyla renkleri değişen, “b” tuşu ile kalınlaşıp inceleşen ve “r” tuşuyla arka plan rengi ön plan rengi haline gelen bir “hello world!” yazısı oluşturalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time
ekran = curses.initscr()
curses.start_color()
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
curses.noecho()
boyutlar = ekran.getmaxyx()
ekran.nodelay(1)
bold = 0
reverse = 0
b = [curses.A_NORMAL, curses.A_BOLD]
r = [curses.A_NORMAL, curses.A_REVERSE]
g = 1
q = -1
x, y = 0, 0
while q != ord("q"):
 ekran.clear()
 ekran.addstr(y, x, "hello world!",
 curses.color_pair(g) | b[bold] | r[reverse])
 ekran.move(boyutlar[0] - 1, boyutlar[1] - 1)
 ekran.refresh()
 q = ekran.getch()
 if q in range(49, 52):
 g = int(chr(q))
 elif q == 98:
 bold = 1 - bold
 elif q == 114:
 reverse = 1 - reverse
 if q == ord("w") and y > 0:
 y -= 1
 elif q == ord("s") and y < boyutlar[0] - 1:
 if y == boyutlar[0] - 2 and x == boyutlar[1] - \
 len("hello world!"):
 pass
 else:
 y += 1
 elif q == ord("a") and x > 0:
 x -= 1
 elif q == ord("d") and x < boyutlar[1] - len("hello world!"):
 if y == boyutlar[0] - 1 and x == boyutlar[1] - \
 len("hello world!") - 1:
 pass
 else:
 x += 1
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Yine örnek uygulamamızda kullanacağımız modülleri içe aktaralım:

```python
import curses
import time

```

Gördüğünüz gibi ilk olarak hep ekranı tanımlıyoruz:

```python
ekran = curses.initscr()

```

Örnek uygulamada renk kullanacağız yine. Bu yüzden renk çiftlerini tanımlamadan önce aşağıdaki fonksiyonu kesin kullanmamız gerekiyor:

```python
curses.start_color()

```

Şimdi 3 tane renk çifti oluşturalım:

```python
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)

```

Bastığımız tuşlar yine ekranda yansıma oluşturmasın:

```python
curses.noecho()

```

Ekranın maksimumxveydeğerlerini alalım:

```python
boyutlar = ekran.getmaxyx()

```

Animasyonumuzun ekranda görüntülenmesinin gecikmemesi için yinenodelay()’in parametresini 1 olarak ayarlıyoruz:

```python
ekran.nodelay(1)

```

Bu sefer kalınlaştırma işlemini bir tuş yardımıyla yapacağız. Bunun içinboldisimli bir değişken oluşturalım ve değerini 0 yapalım:

```python
bold = 0

```

“hello world!”yazısının arka plan rengini ön plana, ön plan rengini ise arka plana çevirmek içinreverseisminde bir değişken oluşturalım ve değerini 0 yapalım:

```python
reverse = 0

```

btuşuna basılınca iki ayrı işlem yapılsın: Metin kalınlaştırılmışsa inceltilsin, yok eğer inceltilmişse kalınlaştırılsın. Bu işlem için bir liste oluşturalım:

```python
b = [curses.A_NORMAL, curses.A_BOLD]

```

Aynı şekildereverseişlemi için de birbirinin tersi olan değişkenleri barındıran bir liste oluşturalım:

```python
r = [curses.A_NORMAL, curses.A_REVERSE]

```

Tanımladığımız renk çiftlerini kullanabilmek için yinegisimli bir değişken kullanacağız ve bu değişkenin değerini 1 olarak belirleyelim:

```python
g = 1

```

Yine ekrandaki her tuşu temsil eden birqdeğişkeni oluşturalım:

```python
q = -1

```

xvey’nin başlangıç değerlerini belirtelim:

```python
x, y = 0, 0

```

Yineqtuşuna basılınca sonlanan bir döngü oluşturalım:

```python
while q != ord("q"):

```

Ekranı temizleyelim yine:

```python
ekran.clear()

```

“hello world!yazısını ilgili tuşlara basılınca aktif hale gelecek biçimlendirme özellikleriyle birlikte ekrana ekleyelim:

```python
ekran.addstr(y, x, "hello world!",
 curses.color_pair(g) | b[bold] | r[reverse])

```

İmleci ekranın sağ alt köşesine yerleştirelim:

```python
ekran.move(boyutlar[0] - 1, boyutlar[1] - 1)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

qbütün tuşları temsil etsin:

```python
q = ekran.getch()

```

chr(49)’danchr(52)’ye kadar olan karakterler 1, 2 ve 3’tür. Şayet kullanıcı bu tuşlara basarsagdeğişkeni değişecek ve böylece“hello world!”yazımız farklı renklere sahip olacak:

```python
if q in range(49, 52):
 g = int(chr(q))

```

Kullanıcıbtuşuna basarsa,bolddeğişkeninin değerini1 - boldyapalım. Böylecebold0 ikenbold1 olur,bold1 iken debold0 olur. Bu şekilde yukarıda tanımladığımızblistesinin iki elemanını da aktif hale getirmiş oluruz:

```python
elif q == 98:
 bold = 1 - bold

```

Kullanıcı “r” tuşuna basarsa,reverse’in değeini1 - reverseyapalım. Yine aynı şekildereverse0 ikenreverse1 olur,reverse1 iken dereverse0 olur. Böylece yukarıda tanımladığımızrlistesinin iki elemanını da aktif hale getiririz:

```python
elif q == 114:
 reverse = 1 - reverse

```

Eğer kullanıcıwtuşuna basarsa vey’nin değeri 0’dan büyükse,ydeğişkeninin değeri 1 birim azaltılsın:

```python
if q == ord("w") and y > 0:
 y -= 1

```

Şayet kullanıcıstuşuna basarsa vey’nin değeri maksimum değerin 1 birim eksiğinden küçükse:

```python
elif q == ord("s") and y < boyutlar[0] - 1:

```

Yukarıdaki koşul altında, şayety, maksimum değerinden 2 birim küçükse vex’de maksimum değere ulaşmışsa, hiç bir işlem yapılmasın:

```python
if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"):
 pass

```

Aksi taktirde,ydeğişkeninin değeri 1 birim artırılsın:

```python
else:
 y += 1

```

Şayet kullanıcıatuşuna basarsa vex’in değeri 0’dan büyükse,xdeğişkeninin değeri 1 birim azaltılsın:

```python
elif q == ord("a") and x > 0:
 x -= 1

```

Şayet kullanıcıdtuşuna basarsa vex’in değeri maksimum değerden küçükse:

```python
elif q == ord("d") and x < boyutlar[1] - len("hello world!"):

```

Yukarıdaki koşul altında, şayety’nin vex’in değerleri maksimum değerlerinden 1 birim küçüğüne eşitse, hiç bir işlem yapılmasın:

```python
if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1:
 pass

```

Aksi taktirde,xdeğişkeninin değeri 1 birim artırılsın:

```python
else:
 x += 1

```

Yine butime.sleep()fonksiyonunun burada neden kullanıldığını görmek için, fonksiyonu yoruma alın ve aradaki farka bakın:

```python
time.sleep(0.05)

```

Ve programı yine terminali bozmayacak şekilde sonlandıralım:

```python
curses.endwin()

```

#### Örnek-7:

Yön tuşlarıyla hareket eden, “1, 2, 3” tuşlarıyla renkleri değişen, “b” tuşu ile kalınlaşıp inceleşen ve “r” tuşuyla arka plan rengi ön plan rengi haline gelen bir “hello world!” yazısı oluşturalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses
import time

ekran = curses.initscr()
ekran.keypad(1)
curses.start_color()
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
curses.noecho()
boyutlar = ekran.getmaxyx()
ekran.nodelay(1)
bold = 0
reverse = 0
b = [curses.A_NORMAL, curses.A_BOLD]
r = [curses.A_NORMAL, curses.A_REVERSE]
g = 0
q = -1
x, y = 0, 0
while q != ord("q"):
 ekran.clear()
 ekran.addstr(y, x, "hello world!",
 curses.color_pair(g)| b[bold] | r[reverse])
 ekran.move(boyutlar[0] -1, boyutlar[1] - 1)
 ekran.refresh()
 q = ekran.getch()
 if q in range(48, 52):
 g = int(chr(q))
 elif q == 98:
 bold = 1 - bold
 elif q == 114:
 reverse = 1 - reverse
 if q == curses.KEY_UP and y > 0:
 y -= 1
 elif q == curses.KEY_DOWN and y < boyutlar[0] - 1:
 if y == boyutlar[0] - 2 and x == boyutlar[1] - \
 len("hello world!"):
 pass
 else:
 y += 1
 elif q == curses.KEY_LEFT and x > 0:
 x -= 1
 elif q == curses.KEY_RIGHT and x < boyutlar[1] - len("hello world!"):
 if y == boyutlar[0] - 1 and x == boyutlar[1] - \
 len("hello world!") - 1:
 pass
 else:
 x += 1
 time.sleep(0.05)
curses.endwin()

```

Kodların Açıklamaları:

Yine örnek uygulamamızda kullanacağımız modülleri içe aktaralım:

```python
import curses
import time

```

Yine önce ekranı tanımlayalım:

```python
ekran = curses.initscr()

```

Şimdi de yön tuşlarının kullanılabilmesi içinkeypad()fonksiyonunu değeriTrueolacak şekilde çağıralım:

```python
ekran.keypad(1)

```

Örnek uygulamada renk kullanacağız yine. Bu yüzden renk çiftlerini tanımlamadan önce aşağıdaki fonksiyonu kesin kullanmamız gerekiyor:

```python
curses.start_color()

```

Şimdi 3 tane renk çifti oluşturalım:

```python
curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)

```

Bastığımız tuşlar yine ekranda yansıma oluşturmasın:

```python
curses.noecho()

```

Ekranın maksimumxveydeğerlerini alalım:

```python
boyutlar = ekran.getmaxyx()

```

Animasyonumuzun ekranda görüntülenmesinin gecikmemesi için yinenodelay()’in parametresini 1 olarak ayarlıyoruz:

```python
ekran.nodelay(1)

```

Bu sefer de kalınlaştırma işlemini bir tuş yardımıyla yapacağız. Bunun içinboldisimli bir değişken oluşturalım ve değerini 0 yapalım:

```python
bold = 0

```

“hello world!”yazısının arka plan rengini ön plana, ön plan rengini ise arka plana çevirmek içinreverseisminde bir değişken oluşturalım ve değerini 0 yapalım:

```python
reverse = 0

```

btuşuna basılınca iki ayrı işlem yapılsın: Metin kalınlaştırılmışsa inceltilsin, yok eğer inceltilmişse kalınlaştırılsın. Bu işlem için bir liste oluşturalım:

```python
b = [curses.A_NORMAL, curses.A_BOLD]

```

Aynı şekildereverseişlemi için de birbirinin tersi olan değişkenleri barındıran bir liste oluşturalım:

```python
r = [curses.A_NORMAL, curses.A_REVERSE]

```

Tanımladığımız renk çiftlerini kullanabilmek için yinegisimli bir değişken kullanacağız ve bu değişkenin değerini 1 olarak belirleyelim:

```python
g = 1

```

Yine ekrandaki her tuşu temsil eden birqdeğişkeni oluşturalım:

```python
q = -1

```

xvey’nin başlangıç değerlerini belirtelim:

```python
x, y = 0, 0

```

Yineqtuşuna basılınca sonlanan bir döngü oluşturalım:

```python
while q != ord("q"):

```

Ekranı temizleyelim yine:

```python
ekran.clear()

```

“hello world!yazısını, ilgili tuşlara basılınca aktif hale gelecek biçimlendirme özellikleriyle birlikte ekrana ekleyelim:

```python
ekran.addstr(y, x, "hello world!",
 curses.color_pair(g) | b[bold] | r[reverse])

```

İmleci ekranın sağ alt köşesine yerleştirelim:

```python
ekran.move(boyutlar[0] - 1, boyutlar[1] - 1)

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

qbütün tuşları temsil etsin:

```python
q = ekran.getch()

```

chr(49)’danchr(52)’ye kadar olan karakterler 1, 2 ve 3’tür. Şayet kullanıcı bu tuşlara basarsagdeğişkeni değişecek ve böylece“hello world!”yazımız farklı renklere sahip olacak:

```python
if q in range(49, 52):
 g = int(chr(q))

```

Kullanıcıbtuşuna basarsa,bolddeğişkeninin değerini1 - boldyapalım. Böylecebold0 ikenbold1 olur,bold1 iken debold0 olur. Bu şekilde yukarıda tanımladığımızblistesinin iki elemanını da aktif hale getirmiş oluruz:

```python
elif q == 98:
 bold = 1 - bold

```

Kullanıcı “r” tuşuna basarsa,reverse’in değeini1- reverseyapalım. Yine aynı şekildereverse0 ikenreverse1 olur,reverse1 iken dereverse0 olur. Böylece yukarıda tanımladığımızrlistesinin iki elemanını da aktif hale getiririz:

```python
elif q == 114:
 reverse = 1 - reverse

```

Eğer kullanıcı yukarı ok tuşuna basarsa vey’nin değeri 0’dan büyükse;ydeğişkeninin değeri 1 birim azaltılsın:

```python
if q == curses.KEY_UP and y > 0:
 y -= 1

```

Şayet kullanıcı aşağı ok tuşuna basarsa vey’nin değeri maksimum değerin 1 birim eksiğinden küçükse:

```python
elif q == curses.KEY_DOWN and y < boyutlar[0] - 1:

```

Yukarıdaki koşul altında, şayety, maksimum değerinden 2 birim küçükse vex’de maksimum değere ulaşmışsa, hiç bir şey yapılmasın:

```python
if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"):
 pass

```

Aksi taktirde;ydeğişkeninin değeri 1 birim artırılsın:

```python
else:
 y += 1

```

Şayet kullanıcı sol ok tuşuna basarsa vex’in değeri 0’dan büyükse,xdeğişkeninin değeri 1 birim azaltılsın:

```python
elif q == curses.KEY_LEFT and x > 0:
 x -= 1

```

Şayet kullanıcı sağ ok tuşuna basarsa vex’in değeri maksimum değerden küçükse:

```python
elif q == curses.KEY_RIGHT and x < boyutlar[1] - len("hello world!"):

```

Yukarıdaki koşul altında, şayety’nin vex’in değerleri maksimum değerlerinden 1 birim küçüğüne eşitse, hiç bir şey yapılmasın:

```python
if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1:
 pass

```

Aksi taktirdexdeğişkeninin değeri 1 birim artırılsın:

```python
else:
 x += 1

```

Yine butime.sleep()fonksiyonunun burada neden kullanıldığını görmek için, fonksiyonu yoruma alın ve aradaki farka bakın:

```python
time.sleep(0.05)

```

Ve programı yine terminali bozmayacak şekilde sonlandıralım:

```python
curses.endwin()

```

#### Örnek-8:

Bu örnekte ekrana hazır bir metin eklemek yerine Türkçe karakterler eklemeye çalışalım. Ve ayrıca eklediğimiz karakterleri silmek veya bir alt satıra geçmek için yeni işlemler tanımlayalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import curses

ekran = curses.initscr()
ekran.keypad(1)
curses.start_color()
curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)
curses.noecho()
boyutlar = ekran.getmaxyx()
q = -1
x, y = 0, 0
xy = []
karakterler = []

def karakter_ekle(karakter, num1, num2):
 global x, y
 ekran.addstr(y, x, karakter, curses.color_pair(1))
 x += 1
 karakterler.remove(num1)
 karakterler.remove(num2)

while q != 27:
 q = ekran.getch()
 ekran.refresh()
 karakterler.append(q)
 if boyutlar[1] - x == 1:
 xy.append((y, x - 1))
 y += 1
 x = 0
 if q == 263:
 if x == 0:
 if y != 0:
 y -= 1
 try:
 x = xy[len(xy) - 1][1]
 xy.pop(len(xy) - 1)
 except IndexError:
 x = boyutlar[1] - 1
 ekran.delch(y, x)
 else:
 pass
 else:
 ekran.delch(y, x - 1)
 x -= 1
 elif q == 10:
 xy.append(curses.getsyx())
 ekran.addstr(y, x, chr(10), curses.color_pair(1))
 y += 1
 x = 0
 elif q == 261:
 if boyutlar[1] - x == 1:
 y += 1
 x = 0
 else:
 x += 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 elif q == 260:
 if x == 0:
 if y != 0:
 y -= 1
 x = 78
 else:
 pass
 else:
 x -= 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 elif q == 259:
 if y != 0:
 y -= 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 else:
 pass
 elif q == 258:
 if y != boyutlar[0] - 1:
 y += 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 else:
 pass
 elif q == 195:
 ekran.addstr(y, x, "", curses.color_pair(1))
 elif q == 196:
 ekran.addstr(y, x, "", curses.color_pair(1))
 elif q == 197:
 ekran.addstr(y, x, "", curses.color_pair(1))
 elif q == 167:
 karakter_ekle("\u00e7", 195, 167)
 elif q == 159:
 if 196 in karakterler:
 karakter_ekle("\u011f", 196, 159)
 elif 197 in karakterler:
 karakter_ekle("\u015f", 197, 159)
 elif q == 177:
 karakter_ekle("\u0131", 196, 177)
 elif q == 182:
 karakter_ekle("\u00f6", 195, 182)
 elif q == 188:
 karakter_ekle("\u00fc", 195, 188)
 elif q == 135:
 karakter_ekle("\u00c7", 195, 135)
 elif q == 158:
 if 196 in karakterler:
 karakter_ekle("\u011e", 196, 158)
 elif 197 in karakterler:
 karakter_ekle("\u015e", 197, 158)
 elif q == 176:
 karakter_ekle("\u0130", 196, 176)
 elif q == 150:
 karakter_ekle("\u00d6", 195, 150)
 elif q == 156:
 karakter_ekle("\u00dc", 195, 156)
 else:
 ekran.addstr(y, x, chr(q), curses.color_pair(1))
 x += 1
curses.endwin()

```

Kodların Açıklamaları:

Her zamanki gibi önce gerekli modülü programın içine aktarıyoruz:

```python
import curses

```

Bildiğiniz gibi curses ile işlem yapmaya geçmeden önce ekranı tanıtmamız gerekiyor:

```python
ekran = curses.initscr()

```

Bu çalışmada tanımlanmamasına rağmenBACKSPACEgibi bazı özel klavye tuşlarını kullanacağımız için öncekeypad()fonksiyonunu çağırmalıyız:

```python
ekran.keypad(1)

```

Yine bildiğiniz gibi yazıları renklendirmek için önce renklendiriciyi başlatmamız gerekiyor:

```python
curses.start_color()

```

Şimdi bir tek tane renk çifti oluşturalım:

```python
curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE)

```

Bastığımız tuşların ekranda yansıma oluşturmaması içincurses.noecho()fonksiyonunu kullanalım:

```python
curses.noecho()

```

Ekranın maksimum boyutlarını bir değişkene atayalım:

```python
boyutlar = ekran.getmaxyx()

```

Yine her tuşu temsil edecekqdeğişkenimizi tanımlayalım:

```python
q = -1

```

Şimdi de satır ve sütun değeri olarak kullanacağımız değişkenleri tanımlayalım:

```python
x, y = 0, 0

```

Her bir satırı bir liste içinde tutacağız. Her satırda hangi sütunda kaldığımızı bilmemiz gerekiyor çünkü karakter silme işleminde bize lazım olacak:

```python
xy = []

```

Türkçe karakterlerin olduğu tuşlara bastığımız sırada, q’nun 1’den fazla değeri olur. MeselaEntertuşu için konuşacak olursak karakter değeri 10’dur.elif q == 10:durumunda yapılması gerekeni rahatça belirleyebiliriz. Ama aynı durum Türkçe karakterler için geçerli değildir. Örneğinçtuşuna basılınca yapılması gereken işlemleri belirtmek için şöyle bir koşul tanımlamamız gerekir:elif q == 196:durumunda bir şey yap. Sonra daelif q == 159:durumunda bir şey yap. Çünküçharfine bastığımız zaman iki tane karakter değeri oluşur. Bunlardan birisi196diğeri159’dur. Aynı durum diğer Türkçe karakterler için de geçerlidir. Meselaıharfine basınca oluşan karakter değerleri196ve177olur. O halde karakter değerlerinden birisinin196olduğu birden fazla tuş var. İşte bu tuş kombinasyonlarını birbirlerinden ayırmak için bir liste kullanacağız:

```python
karakterler = []

```

Türkçe karakterleri bir fonksiyon yardımıyla ekrana eklemeye çalışalım. Buradakikarakterparametresi, Türkçe harfin unicode kodu; num1 ve num2 parametreleri ise karakterin değerleridir:

```python
def karakter_ekle(karakter, num1, num2):

```

Fonksiyonumuzun içine global alandakix, veydeğişkenlerini çekelim:

```python
global x, y

```

Global alandan aldığımız ekrana aity,xkonumuna karakteri ekleyelim:

```python
ekran.addstr(y, x, karakter, curses.color_pair(1))

```

Her Türkçe karakteri ekledikten sonra, x’in konumunu 1 birim artıralım ki yeni girilecek karakter için kullanılabilir yeni bir hücre oluşsun:

```python
x += 1

```

Daha sonra da karakterler listesinden bu tuşu temsil eden değerleri silelim ki, bir sonraki Türkçe
karakteri ekrana eklemek istediğimizde sorun çıkmasın:

```python
karakterler.remove(num1)
karakterler.remove(num2)

```

Şimdi de,ESCtuşuna basılmadığı sürece çalışan bir döngü oluşturalım:

```python
while q != 27:

```

qbütün tuşları temsil etsin:

```python
q = ekran.getch()

```

Ekranı tazeleyelim:

```python
ekran.refresh()

```

Her tuşa bastığımızda karakterler listesineqdeğeri eklensin:

```python
karakterler.append(q)

```

Eğer bir satırın sonuna gelinmişse,xysatır listesine bu satırı ekleyelim:

```python
if boyutlar[1] - x == 1:
 xy.append((y, x - 1))

```

Aynı zamanda y değişkeninin değeri 1 birim artsın ki bir alt satıra, x değişkeninin değeri de 0’a eşitlensin ki satır başına geçelim:

```python
y += 1
x = 0

```

Eğer kullanıcıBACKSPACEtuşuna basarsa ve koşul altında eğerxdeğişkeninin değeri 0’a eşitse:

```python
if q == 263:
 if x == 0:

```

Yukarıdaki her iki koşulun altında eğerydeğişkeninin değeri 0’a eşit değilse,ydeğişkeninin değeri 1 birim azaltılsın:

```python
if y != 0:
 y -= 1

```

Ayrıca x’in değeri bir önceki satırın bittiği x değerine eşitlenmeye çalışılsın ve satır listesinden bir önceki satır silinsin:

```python
try:
 x = xy[len(xy) - 1][1]
 xy.pop(len(xy) - 1)

```

Bu işlem yapılırken bir sıra hatası oluşmasını bekliyoruz, bu durumda x’in değeri maksimum x değerine eşitlensin:

```python
except IndexError:
 x = boyutlar[1] - 1

```

Her halükarda ekranın y, x konumundan bu karakter silinsin:

```python
ekran.delch(y, x)

```

BACKSPACEtuşuna basıldığı koşulun altında, eğerxdeğikeninin değeri 0’a eşitse ve eğerydeğişkeninin değeri de 0’a eşitse, hiç bir işlem yapılmasın:

```python
else:
 pass

```

BACKSPACEtuşuna basıldığı koşulun altında ve eğerxdeğikeninin değeri 0’a eşit değilse, ekranıny,x - 1konumundan bu karakter silinsin vexdeğişkeninin değeri 1 birim azaltılsın:

```python
else:
 ekran.delch(y, x - 1)
 x -= 1

```

Eğer kullanıcıentertuşuna basarsa:xysatır listesine o andakiy,xdeğerlerini ekleyelim, ekrana“n”kaçış dizisi eklensin,ydeğikeninin değeri 1 birim artırılsın vexdeğişkeninin değeri 0’a eşitlensin yani yeni satırın başına geçilsin:

```python
elif q == 10:
 xy.append(curses.getsyx())
 ekran.addstr(y, x, chr(10), curses.color_pair(1))
 y += 1
 x = 0

```

Eğer kullanıcı sağ ok tuşuna basarsa vexdeğişkeni maksimum değerine ulaştıysa,ydeğişkenin değeri 1 birim artırılsın vexdeğişkeninin değeri 0’a eşitlensin. Yani yeni bir satıra geçilsin. Yok eğerxdeğişkeni maksimum değerine ulaşmadıysa,xdeğişkeninin değeri 1 birim artırılsın ve ekrana boş bir string verisi eklensin:

```python
elif q == 261:
 if boyutlar[1] - x == 1:
 y += 1
 x = 0
 else:
 x += 1
 ekran.addstr(y, x, "", curses.color_pair(1))

```

Eğer kullanıcı sol ok tuşuna basarsa,xdeğişkeninin değeri 0’a eşitse veydeğişkeninin değeri 0’a eşit değilse,ydeğişkeninin değeri 1 birim azaltılsın,xdeğişkeninin değeri 78 olarak ayarlansın, şayet hemxhem de*y* değişkeninin değeri 0’a eşitse hiç bir işlem yapılmasın.xdeğişkeninin değeri 0’a eşit değilse,xdeğişkenin değeri 1 birim azaltılsın ve ekranınyxkonumuna boş bir string eklensin:

```python
elif q == 260:
 if x == 0:
 if y != 0:
 y -= 1
 x = 78
 else:
 pass
 else:
 x -= 1
 ekran.addstr(y, x, "", curses.color_pair(1))

```

Eğer kullanıcı yukarı ok tuşuna basarsa veydeğişkeninin değeri 0’a eşit değilse,ydeğişkeninin değeri 1 birim azaltılsın ve ekranınyxkonumuna boş bir string yerleştirilsin. Eğerydeğişkeninin değeri 0’a eşitse, hiç bir işlem yapılmasın:

```python
elif q == 259:
 if y != 0:
 y -= 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 else:
 pass

```

Eğer kullanıcı aşağı ok tuşuna basarsa veydeğişkeni maksimum değerine eşit değilse,ydeğişkeninin değeri 1 birim artırılsın ve ekranınyxkonumuna boş bir string yerleştirilsin. Eğerydeğişkeni ekranın maksimumydeğerine gelmişse, hiç bir işlem yapılmasın:

```python
elif q == 258:
 if y != boyutlar[0] - 1:
 y += 1
 ekran.addstr(y, x, "", curses.color_pair(1))
 else:
 pass

```

Aşağıdaki kodlar Türkçe karakterleri eklemekle ilgilidir. Daha önce belirtildiği gibi Türkçe karakterler iki tane karakter değerine sahip oluyor. Dolayısıyla bir karakteri ekledikten sonra o karakterin değerlerini karakterler listesinden bir karışılıklık olmaması için silmek gerekiyor. Aşağıda tanımlanmış olan 3 koşul da Türkçe karakterlerin 1. değerleridir, bu üç sayısal değerden birisi bütün Türkçe karakterlerde ortak olarak bulunuyor:

```python
elif q == 195:
 ekran.addstr(y, x, "", curses.color_pair(1))
elif q == 196:
 ekran.addstr(y, x, "", curses.color_pair(1))
elif q == 197:
 ekran.addstr(y, x, "", curses.color_pair(1))

```

Aşağıdaki kodlarda hangi koşullarda ekrana Türkçe karakterlerin ekleneceği tanımlanmıştır. Türkçe karakterler doğrudan unicode karakteri olarak eklenecektir:

Küçük“ç”harfinin eklenmesini sağlayan koşul:

```python
elif q == 167:
 karakter_ekle("\u00e7", 195, 167)

```

Küçük“ğ”ve küçük“ş”harflerinin eklenmesini sağlayan koşullar:

```python
elif q == 159:
 if 196 in karakterler:
 karakter_ekle("\u011f", 196, 159)
 elif 197 in karakterler:
 karakter_ekle("\u015f", 197, 159)

```

Küçük“ı”harfininin eklenmesini sağlayan koşul:

```python
elif q == 177:
 karakter_ekle("\u0131", 196, 177)

```

Küçük“ö”harfinin eklenmesini sağlayan koşul:

```python
elif q == 182:
 karakter_ekle("\u00f6", 195, 182)

```

Küçük“ü”harfinin eklenmesini sağlayan koşul:

```python
elif q == 188:
 karakter_ekle("\u00fc", 195, 188)

```

Büyük“Ç”harfinin eklenmesini sağlayan koşul:

```python
elif q == 135:
 karakter_ekle("\u00c7", 195, 135)

```

Büyük“Ğ” ve büyük“Ş”harflerinin eklenmesini sağlayan koşullar:

```python
elif q == 158:
 if 196 in karakterler:
 karakter_ekle("\u011e", 196, 158)
 elif 197 in karakterler:
 karakter_ekle("\u015e", 197, 158)

```

Büyük“İ”harfinin eklenmesini sağlayan koşul:

```python
elif q == 176:
 karakter_ekle("\u0130", 196, 176)

```

Büyük“Ö”harfinin eklenmesini sağlayan koşul:

```python
elif q == 150:
 karakter_ekle("\u00d6", 195, 150)

```

Büyük“Ü”harfinin eklenmesini sağlayan koşul:

```python
elif q == 156:
 karakter_ekle("\u00dc", 195, 156)

```

Ve son koşulumuzda Türkçe karakterler haricinde herhangi bir karakterin ekrana nasıl eklenmesi gerektiği tanımlanmıştır. Bu koşulda karakteryxkonumuna eklenir vexdeğişkeninin değeri 1 birim artırılır:

```python
else:
 ekran.addstr(y, x, chr(q), curses.color_pair(1))
 x += 1

```

#### Örnek-9:

Bu örnektedef,if,elsegibi bazı özel kelimelerin diğer kelimelerden farklı renge sahip olması için uğraşalım. Örneğindef’idefine’den veya“def”den ayırt etmeye çalışalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import curses
import keyword

ekran = curses.initscr()
curses.start_color()
curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)
curses.noecho()
q = -1
karakterler = ""
while q != ord("q"):
 q = ekran.getch()
 ekran.addstr(chr(q), curses.color_pair(1))
 karakterler += chr(q)
 for kw in keyword.kwlist:
 regex1 = re.search("[^'\"]\s{}\s$".format(kw), karakterler)
 regex2 = re.search("^{}\s$".format(kw), karakterler)
 if regex1 or regex2:
 ekran.addstr("{}{} ".format("\b" * (len(kw) + 1), kw),
 curses.color_pair(2))
 karakterler = ""
curses.endwin()

```

Kodların Açıklamaları:

Bu örnekte kullanacağımız modülleri programın içine aktaralım:

```python
import re
import curses
import keyword

```

Her zamanki gibi ekranı tanıtıyoruz:

```python
ekran = curses.initscr()

```

Renklendirme işlemine geçmeden önce bildiğiniz gibi renk başlatıcıyı çalıştırıyoruz:

```python
curses.start_color()

```

Bu örnekte bir çift Python’a özgü özel karakterler için, bir çift de diğer karakterler için toplam iki çift renk tanımlayalım:

```python
curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK)

```

Karakterlerin ekranda yansımasını istemiyoruz diyelim:

```python
curses.noecho()

```

Her karakteri temsil edecek bir karakter seçelim. Ve değerini -1 yapalım (değerinin ne olduğu bu örnekte pek önemli değil):

```python
q = -1

```

Python’a özgü karakterleri diğer karakterlerden ayırt edebilmek için bir tane string verisi oluşturalım:

```python
karakterler = ""

```

qdeğişkeninin“q”’ya eşit olmadığı durumda çalışacak döngüyü tanımlayalım:

```python
while q != ord("q"):

```

qdeğişkeni her karakteri temsil etsin:

```python
q = ekran.getch()

```

Basılan her tuşun karakteri ekrana 1. sıradaki renkle birlikte eklensin:

```python
ekran.addstr(chr(q), curses.color_pair(1))

```

Eklenen her bir karakter,karakterlerdeğişkenine de eklensin:

```python
karakterler += chr(q)

```

keyword.kwlist listesi içindeki Python’a özgü her bir özel ifade için, iki tane düzenli ifade oluşturalım:

```python
for kw in keyword.kwlist:
 regex1 = re.search("[^'\"]\s{}\s$".format(kw), karakterler)
 regex2 = re.search("^{}\s$".format(kw), karakterler)

```

Eğer yazdığımız yazı regex1’e veya regex2’ye uyuyorsa, ekrana bu yazı farklı bir renkle yazılsın. Buradaki“b” * (len(kw) + 1)kod parçasıkwile temsil edilen kwlistteki her bir özel ifadeden sonra yeni eklenecek karakterin nereye eklenmesi gerektiğini belirtir. Mesela kwlistteki üç harflik bir özel ifade için 4. hücreye yeni bir karakter eklenmesini sağlar. Eğer bu kod parçasını yazıyı ekrana eklerken yazmazsak, yeni eklenen karakterler, özel karakterlerin üzerine yazılır:

```python
if regex1 or regex2:
 ekran.addstr("{}{} ".format("\b" * (len(kw) + 1), kw),
 curses.color_pair(2))

```

Vekarakterlerstringimizin değerini boş bir string verisine eşitleyelim ki bir sonraki karakter için tekrar kullanabilelim:

```python
karakterler = ""

```

Ve son olarak program kapandığında terminali eski haline getirmek içincurses.endwin()fonksiyonumuzu çağıralım:

```python
curses.endwin()

```

### threading Modülü

Kaynak Kodu:https://hg.python.org/cpython/file/3.5/Lib/threading.py

Bu modül; düşük seviyeli_threadmodülü üzerine, yüksek seviyeli iş parçacığı yürütüm ara yüzleri inşa eder. Ayrıcaqueuemodülüne de bakınız.

dummy_threadingmodülü,_thread’in kayıp olmasından ötürüthreading’in kullanılamadığı durumlar için sağlanmıştır.

Not:Aşağıda listelenmemişken, Python 2.x serilerindeki bu modülün bazı metotlarının ve fonksiyonlarının kullandığı camelCase isimler hala bu modül tarafından desteklenmektedir.

Bu modül aşağıdaki fonksiyonları tanımlar:

threading.active_count()

Hazır çalışmakta olan iş parçacığı (Thread) nesnelerinin sayısını geri döndürür. Geri dönen değerenumerate()tarafından döndürülen listenin uzunluğuna eşittir.

threading.current_thread()

Çağıranın kontrol dizesine karşılık gelen iş parçacığı nesnesini geri döndürür. Eğer çağıranın kontrol dizesithreadingmodülü vasıtasıyla oluşturulmamışsa, işlevselliği sınırlandırılmış bir kukla (dummy) iş parçacığı (thread) nesnesi geri döndürülür.

threading.get_ident()

Şimdiki iş parçacığının (Thread’in) iş parçacığı tanımlayıcısını (thread identifier’ı) geri döndürür. Bu, sıfır olmayan bir tam sayıdır. Değerinin doğrudan bir anlamı yoktur; sihirli bir çerez olarak kullanılmak üzere tasarlanmıştır, örneğin iş parçacıklarına özgü verilerden oluşan bir sözlüğü dizinlemek için.

Sürüm 3.3.’de gelmiştir.

threading.enumerate()

Hazır çalışmakta olan bütün iş parçacığı (Thread) nesnelerinin listesini geri döndürür. Liste daemonic (kullanıcının doğrudan kontrolünde olmayıp arka planda çalışan) iş parçacıklarını,current_thread()tarafından oluşturulmuş dummy (kukla) iş parçacıklarını ve ana iş parçacığını içerir. Listeye sonlandırılmış iş parçacıkları ve henüz başlatılmamış iş parçacıkları dâhil edilmez.

threading.main_thread()

Ana iş parçacığı (main-thread) nesnesini geri döndürür. Normal durumlarda, ana iş parçacığı Python yorumlayıcısı tarafından başlatılmış olan iş parçacığıdır.

Sürüm 3.4.’de gelmiştir.

threading.settrace(func)

Threading modülünden başlatılan bütün iş parçacıkları için bir tane izleyici fonksiyon ayarlar. Func yazan yere, her bir iş parçacığı için,run()metodu çağrılmadan önce,sys.settrace()gelecektir.

threading.setprofile(func)

Threading modülünden başlatılan bütün iş parçacıkları için bir tane kesit fonksiyonu ayarlar. Func yazan yere, her bir iş parçacığı için,run()metodu çağrılmadan önce,sys.setprofile()gelecektir.

threading.stack_size([size])

Yeni iş parçacıkları oluştururken, kullanılan iş parçacığı yığın boyutunu geri döndürür. Seçeneğe bağlı olansizeargümanı daha sonradan oluşturulacak iş parçacıkları için yığın boyutunu belirtir ve -platform kullanımında veya ön tanımlı ayar olarak- değeri 0 veya 32,768 (32 KiB)’den büyük pozitif bir tamsayı olmalıdır. Eğersizeargümanı tanımlanmazsa, değeri 0 olur. Eğer iş parçacığının yığın boyutunun değiştirilmesi desteklenmezse, birRuntimeErrorhatası yükseltilir. Eğer tanımlanmış yığın boyutu geçersiz ise,ValueErrorhatası yükseltilir ve yığın boyutu değiştirilmemiş olur. 32 KiB, yorumlayıcıya yeterli yığın alanı temin etmek için yığın boyutunun desteklenen geçerli minimum değeridir. Bazı platformların, yığın boyutunun değeri üzerinde, kendilerine özgü bir takım sınırlamaları vardır. Örneğin yığın boyutunun 32 KiB’den büyük olmasının gerekliliği veya sistem hafıza sayfası boyutunun katlarının paylaştırılmasının gerekliliği gibi - platform belgesi daha fazla bilgi vermesi için referans gösterilebilir - (4 KiB’lik sayfalar yaygındır; yığın boyutunun 4096’nın katları olarak kullanılması, daha özel bilgilerin olmaması durumunda önerilen bir yaklaşımdır.) Kullanılabilen platformlar: Windows, POSIX iş parçacığı ile çalışan sistemler.

Bu modül ayrıca aşağıdaki sabiti de tanımlar:

threading.TIMEOUT_MAX

Lock.acquire(),RLock.acquire(),Condition.wait()vb. gibi engelleyici fonksiyonların zaman aşımı parametreleri için maksimum değere izin verilir.

Sürüm 3.2’de gelmiştir.

Bu modül aşağıdaki kısımda ayrıntıları verilen birkaç sınıfı tanımlar.

Bu modülün tasarımı yaklaşık olarak Java’nın threading modeli üzerine temellenmiştir. Ancak bununla birlikte, Java’daki her nesnenin temel davranışında olan kilit ve durum değişkenleri, Python’da ayrı nesnelerdir. Python’daki Thread sınıfı Java’daki Thread sınıfının davranışını bir alt set olarak destekler; şimdilik ne bir öncelik, ne bir iş parçacığı grubu vardır. İş parçacıkları yok edilemez, durdurulamaz, yasaklanamaz, devam ettirilemez ve sonlandırılamaz. Java’nın Thread sınıfının statik metotları, uygulandığında, modül düzeyindeki fonksiyonlarla eşleştirilir.
Aşağıda açıklanmış metotların hepsi otomatik olarak çalıştırılır.

#### Yerel İş Parçacığı (Thread-Local) Verisi

Yerel iş parçacığı (thread-local) verisi, değeri iş parçacığı olarak belirlenmiş bir değerdir. Yerel iş parçacığı verisini yönetmek için, sadece yerel sınıftan (veya bir alt sınıftan) bir tane örnek oluşturulur ve özellikler bu sınıfta tutulur:

```python
yerel_veri = threading.local()
yerel_veri.x = 1

```

Ayrı iş parçacıkları için örneğin değeri değişik olacaktır.

class threading.local

Yerel iş parçacığı verisini temsil eden sınıftır.

Daha fazla ayrıntı ve geniş örnekler için,_threading_localmodülünün belge dizisine bakın.

#### İş Parçacığı (Thread) Nesneleri

İş parçacığı (thread) sınıfı, ayrı iş parçacıklarını kontrol eden bir etkinliği temsil eder. Bu etkinliği belirtmek için iki yol vardır: yapıcıya, çağrılabilir bir nesne atamak veya bir alt sınıftarun()metodunu iptal etmek. Yapıcı dışında hiçbir metot bir alt sınıfta iptal edilmemelidir. Başka bir deyişle, bu sınıfın sadece__init__()verun()metotları iptal edilir.

Bir iş parçacığı (thread) nesnesi oluşturulduğunda, bu nesnenin etkinliği, iş parçacığınınstart()metodu çağrılarak başlatılmalıdır. Bu ayrılmış bir iş parçacığının kontrolündekirun()metodunu çalıştırır.

Bir iş parçacığı (thread) başlatıldığında, iş parçacığı ‘canlanmış’ olarak kabul edilir. Normalde bu iş parçacığınınrun()metodu sonlandığında, iş parçacığının canlılığı da sonlanır - veya yürütülemeyen bir beklenti yükseltilir-. İş parçacığının canlı olup olmadığınıis_alive()metodu test eder.

Diğer iş parçacıkları, bir iş parçacığınınjoin()metodunu çağırabilir. Bu metot, çağrılan iş parçacığını,join()metodu çağrılan iş parçacığı sonlana kadar engeller.

Bir iş parçacığının bir ismi vardır ve ismi yapıcıya atanabilir ve ‘name’ özelliği vasıtasıyla okunabilir veya değiştirilebilir.

Bir iş parçacığıdaemon iş parçacığı (=daemon thread)olarak işaretlenir. Bu işaretin önemi, sadece daemon iş parçacığı kaldığında bütün Python programının sonlanmasıdır. İşaretin başlangıç değeri, oluşturulmuş olan iş parçacığından miras alınır. İşaret, daemon özelliği (property) veya daemon’un yapıcı argümanı tarafından ayarlanabilir.

Not:Daemon iş parçacıkları bilgisayar kapatıldığında ani bir şekilde sonlanır. Açılmış dosyalar, veritabanı hareketleri gibi birçok kaynak, düzgün bir şekilde serbest bırakılmayabilir. Eğer iş parçacıklarının düzgün bir şekilde durmasını istiyorsanız, onları non-daemonic (daemonic olmayacak şekilde) ayarlayın ve Event gibi uygun bir sinyal mekanizması kullanın.

Python programında bir tane ana iş parçacığı (main-thread) nesnesi vardır ve bu nesne başlangıçtaki iş parçacığının kontrol edilmesine yarar. Bu nesne bir daemon iş parçacığı değildir.

Kukla iş parçacığı nesnelerinin (dummy thread objects) oluşturulma ihtimali vardır. Bunlar yabancı olarak kabul edilebilecek, kontrolleri threading modülünün dışında olan C kodları gibi iş parçacıklarıdır. Kukla iş parçacıklarının sınırlı işlevsellikleri vardır; daima canlı ve daemonic özelliktedirler vejoin()ve diğerleri ile kullanılamazlar. Yabancı iş parçacıklarının sonlandırılmalarının saptanmasının imkânsız olduğu sürece asla silinemezler.

daemon=None)

Bu yapıcı her zaman anahtar kelime argümanlarıyla birlikte çağrılmalıdır. Argümanlar şunlardır:

group:Değeri,Noneolmalıdır.ThreadGroupClassuygulandığında, gelecekteki genişletme için saklanır.

target:Değeri,run()metodu tarafından çalıştırılan, çağrılabilir bir nesnedir. Değeri ön tanımlı olarakNoneolur ve değeriNoneolursa hiçbir şeyin çağrılmayacağı anlamına gelir.

name:İş parçacığının ismidir. Ön tanımlı değeri özel olarak “Thread-N” biçiminden yapılmıştır. Buradaki N’nin değeri küçük ondalık bir sayıdır.

args:Hedefin yürütülmesi için demet veri tipinde bir argümandır. Ön tanımlı olarak boş bir demet verisidir.

kwargs:Hedefin yürütülmesi için sözlük veri tipinde bir anahtar kelime argümanıdır. Ön tanımlı olarak boş bir sözlük verisidir.

daemon:Eğer değeriNonedeğilse, daemon, bir iş parçacığının bariz bir şekilde daemonic olup olmadığını ayarlar. Şayet değeri ön tanımlı olarak bırakılırsa (yani değeriNoneolursa), daemonic özellik o andaki aktif iş parçacığından miras alınır.

Eğer bir alt sınıf yapıcıyı iptal ederse, iş parçacığı ile bir işlem yapmadan önce, temel sınıfın yapıcısının (Thread.__init__()’in) çalıştırılmış olduğundan emin olunması gerekir.

Sürüm 3.3.’de değiştirildi. Daemon argümanı eklendi.

start()

İş parçacığının etkinliğini başlatır.

Her bir iş parçacığı için bir kez çağrılması gerekir. Ayrılmış iş parçacığı kontrolü içinde,run()metodunun çalıştırılmasını ayarlar.

Bir iş parçacığı için, bu metot birden çok çağrıldığında, birRuntimeErrorhatası yükseltir.

run()

İş parçacığının etkinliğini temsil eder.

Bu metodu, bir alt sınıfta iptal edebilirsiniz. Standartrun()metodu,targetargümanı olarak bilinen nesnenin yapıcısına atanmış çağrılabilir nesneyi, varsaargsve kwargs* argümanlarından alınan ardışık ve anahtar kelimeli argümanlarla birlikte sırasıyla çalıştırır.

join(timeout=None)

İş parçacığı sonlana kadar bekler. Bu;join()metodu çağrılan iş parçacığı ya normal olarak, ya yürütülemeyen bir beklenti vasıtasıyla ya da seçeneğe bağlı zaman aşımı gerçekleşip sonlana kadar, çağrılan başka bir iş parçacığını bloke eder.

timeout(zaman aşımı) argümanı hazır olduğunda ve değeriNoneolmadığında, işlemin zaman aşımını saniye olarak belirten, kayan noktalı bir sayı olmalıdır.join()her zamanNonedeğerini geri döndürdüğü için, bir zaman aşımının gerçekleşip gerçekleşmediğine karar vermek içinjoin()sonrasındais_alive()metodunu çağırın. Şayet iş parçacığı halen canlı ise,join()’in çağrılması zaman aşımına uğrar.

timeout argümanı hazır olmadığında ve değeriNoneolmadığında, işlem, iş parçacığı sonlana kadar bloke olacaktır.

Bir iş parçacığı için birçok kezjoin()metodu çağrılabilir.

Bir girişim, hali hazırdaki iş parçacığını bir çıkmaza sokarsa,join()metodu birRuntimeErrorhatası yükseltir. Aynı hata, bir iş parçacığı başlatılmadan öncejoin()metodu çağrılırsa da yükseltilir.

Name

Sadece tanımlama amaçları için bir karakter dizisi (string) kullanılır. Bir anlamı yoktur. Çoklu iş parçacıklarına aynı isim verilebilir. Başlangıç ismi yapıcı tarafından ayarlanır.

getName()

setName()

İsim için eski program uygulama ara yüzü alıcısı/ayarlayıcısı. Name özelliği (property) yerine doğrudan bunu kullanın.

ident

İş parçacığının tanıtlayıcısıdır veya eğer bir iş parçacığı başlatılmamışsa değeriNone’dır. Değeri sıfır olmayan bir tamsayıdır. Daha fazla bilgi için_thread.get_ident()fonksiyonuna bakın. İş parçacığı tanıtlayıcıları, bir iş parçacığı sonlandığında ve başka bir tanesi oluşturulduğunda geri dönüştürülebilir. İş parçacığı sonlandıktan sonra bile tanıtlayıcı kullanılabilir.

is_alive()

Bir iş parçacığının aktif olup olmadığının öğrenilmesini sağlar.

Bu metot;run()metodunun başlamasından önce verun()metodunun sonlanmasına kadarTruedeğerini geri döndürür.enumerate()modül fonksiyonu bütün canlı iş parçacıklarının bir listesini geri döndürür.

daemon

Bir iş parçacığının, bir daemon iş parçacığı olup olmadığının belirleyen bir boolean (TrueveyaFalse) değeridir. Bu özellikstart()metodu çağrılmadan önce ayarlanmalıdır aksi halde birRuntimeErrorhatası yükseltilir. Başlangıçtaki değeri, oluşturulan iş parçacığından miras alınır; ana iş parçacığı bir daemon iş parçacığı değildir, böylece ana iş parçacığı içinde oluşturulan bütün iş parçacıklarının daemon değeri ön tanımlı olarakFalseolur.

Geriye, cansız, daemon olmayan iş parçacıkları kaldığında, bütün Python programı sonlandırılır.

isDaemon()

setDaemon()

Daemonun eski alıcı/ayarlayıcı program uygulama ara yüzü; bir özellik olarak kullanmak yerine doğrudan bunu kullanın.

CPython Uygulaması Hakkında Ayrıntı:CPython’da, Global Yorumlayıcı Kilidinden (Global Interpreter Lock) ötürü yalnızca bir adet iş parçacığı bir kere Python kodunu çalıştırabilir (belirli performans odaklı kütüphanelerin bu kısıtlamanın üstesinden gelmesine rağmen). Eğer uygulamanızın çok çekirdekli makinelerin hesaplama kaynaklarından daha fazla yararlanmasını istiyorsanızmultiprocessing’i veyaconcurrent.futures.ProcessPoolExecutor’u kullanmanız tavsiye edilir. Yine de çoklu girdi/çıktı görevlerini eş zamanlı olarak çalıştırmak istiyorsanız,threadingbunun için halen uygun bir modeldir.

#### Lock (Kilit) Nesneleri

Bir ilkel kilit, kilitlendiğinde belirli bir iş parçacığına ait olmayan, bir eşzamanlama ilkelidir. Bu kilit, Python’da, doğrudan_threaduzantı modülünden uyarlanan, hali hazırda kullanılabilir olan en düşük seviyedeki eşzamanlama ilkelidir.

Bir ilkel kilitin “kilitli (=locked)” ve “kilitli değil (=unlocked)” olmak üzere iki tane durumu vardır. Bu kilit oluşturulurken “kilitli değil” durumundadır. Kilidin iki tane temel metodu vardır;acquire()verelease(). Kilidin durumu “kilitli değil” olduğunda,acquire()durumu “kilitli” hale çevirir ve acil olarak geri döndürülür. Kilidin durumu “kilitli” olduğunda, bir başka iş parçacığındarelease()çağrılıp, durumu “kilitli değil” şeklinde değiştirene kadar,acquire()iş parçacığını bloke eder, daha sonraacquire()çağrısı kilidi “kilitli” şeklinde sıfırlar ve geri döndürür.release()metodu, kilit sadece “kilitli” durumda iken çağrılmalıdır; bu metot, kilidin durumunu “kilitli değil” diye değiştirir ve acil olarak geri döndürülür. Şayet bir girişim kilitli olmayan bir kilidi serbest bırakmaya çalışırsa, bir adetRuntimeErrorhatası yükseltilir.

Kilitler ayrıca içerik yönetim protokolünü de desteklerler.

Birden fazla iş parçacığıacquire()ile bloke edilip, kilit durumlarının “kilitli değil” şeklinde değişmesi beklendiğinde, sadece bir iş parçacığının kilidi,release()çağrısıyla “kilitli değil” durumuna getirilir; bekleyen iş parçacıklarından hangisinin getirileceği tanımlı değildir ve uygulamalara bağlı olarak değişiklik gösterebilir.

Tüm metotlar otomatik olarak yürütülür.

Class threading.Lock

Sınıf, ilkel kilit nesnelerini uyarlar. Bir kez bir iş parçacığına kilit kazandırıldığında, sonraki girişimler, kilit serbest bırakılana kadar, iş parçacığını bloke eder; herhangi bir iş parçacığı kilidi serbest bırakabilir.

Sürüm 3.3.’de değiştirildi. Kurucu fonksiyondan bir sınıfa değiştirildi.

acquire(blocking=True, timeout=-1)

Bloklayan veya bloklamayan bir kilit kazandırır.

blockingargümanıTrueolarak (ön tanımlı değerdir) çağrıldığında, kilit serbest bırakalana kadar iş parçacığını bloke eder ve sonra kilidi tekrar “kilitli” konuma getirir veTruedeğerini geri döndürür.

blockingargümanıFalseolarak çağrıldığında, iş parçacığını bloke etmez. Şayet bir çağrıblocking’iTrueolarak ayarlarsa, iş parçacığını bloke eder ve acil olarakFalsedeğerini geri döndürür; diğer türlü, kilidi “kilitli” duruma getirir veTruedeğerini döndürür.

Kayan noktalıtimeout(zaman aşımı) argümanı pozitif bir değer alarak çağrıldığında, en çoktimeoutargümanında belirtilen değere kadar, kilitlenemediği sürece iş parçacığını bloke eder.timeoutargümanının -1 olması sınırsız bir bekleme süresi olacağını belirtir. Blocking argümanıFalseayarlandığında, birtimeoutargümanı belirlemek yasaklanmıştır.

İş parçacığı başarıyla kilitlenmişse, geri dönen değerTrueolur, şayet başarıyla kilitlenmemişseFalseolur (örneğin zaman aşımına uğramışsa).

Sürüm 3.2.’de değiştirildi.timeoutparametresi yenidir.

Sürüm 3.2.’de değiştirildi. Kilitleme POSIX’te sinyaller tarafından şimdi iptal edilebilir.

release()

Bir kilidi serbest bırakır. Bu metot, kilitlenmiş bir iş parçacığı hariç her iş parçacığından çağrılabilir.

Kilit “kilitli” duruma getirildiğinde, onu “kilitli değil” şeklinde değiştirir ve geri döndürür. Eğer başka iş parçacıkları, kilitlerinin “kilitli değil” şeklinde değişmelerini bekleyerek bloke edilmişse, ilerlemek için kesin olarak bir tanesine izin verin.

Kilitli olmayan bir kilit çağrıldığında, birRuntimeErrorhatası yükseltilir.

Bu metot ile geri dönen bir değer yoktur.

#### Rlock (Yeniden Girilir Kilit) Nesneleri

Bir yeniden girilir kilit, aynı iş parçacığı tarafından bir çok kere kullanıma sokulabilen bir eş zamanlama ilkelidir. Dahili olarak, bu kilit, ilkel kilitlerin kullandığı kilitli/kilitli değil durumuna ilaveten “sahip olunan iş parçacığı” ve “recursion (öz yineleme)” kavramlarını kullanır. Kilitli durumda, bazı iş parçacıkları bu kilide sahip olurken; kilitli olmadığı durumda, hiçbir iş parçacığı bu kilide sahip değildir.
Kilidi kilitlemek için, iş parçacığı bu kilidinacquire()metodunu çağırır; bu işlem iş parçacığının kilide sahip olduğunu bir kez geri döndürür. Kilidi açmak için, iş parçacığı kilidinrelease()metodunu çağırır.acquire()/release()çağrı çiftleri iç içe geçebilir; sadece sonrelease()çağrısı (en dıştaki çağrı çiftinden olanrelease()) kilidi “kilitli değil” duruma getirir veacquire()ile bloklanmış diğer iş parçacığının ilerlemesi için izin verir.

Yeniden girilir kilitler ayrıca içerik yönetim protokolünü desteklerler.

Class threading.Rlock

Bu sınıf yeniden girilir kilit nesnelerini uygular. Bir yeniden girilir kilit, onu edinmiş bir iş parçacığı tarafından serbest bırakılmalıdır. Bir iş parçacığı bir kez yeniden girilir bir kilidi edindiğinde, aynı iş parçacığı kilidi engellemeden tekrar edinebilir; iş parçacığı, kilidi her edinmesine karşılık bir kez onu serbest bırakmalıdır.

Rlock’ın, platform tarafından desteklenen,Rlocksınıfının elle tutulur en etkili versiyonunu geri döndüren bir kurucu fonksiyonu olduğunu not edin.

acquire(blocking=True, timeout=-1)

Bloklayan ve bloklamayan bir kilit edinin.

Argümansız çağrıldığında: Eğer bu iş parçacığı zaten kilide sahipse, öz-yineleme seviyesini 1 derece artırır ve ani bir şekilde geri döndürür. Diğer türlü, eğer başka bir iş parçacığı bu kilide sahipse, kilit çözülene kadar iş parçacığını engeller. Eğer bir kez -hiç bir iş parçacığının sahibi olmadığı- bir kilit açılmışsa, sahibini yakalar, öz-yineleme değerini 1 olarak ayarlar ve geri döndürülür. Eğer birden fazla iş parçacığı kilit açılana kadar engelleniyorsa, her seferinde sadece bir tane iş parçacığı bu kilide sahip olacaktır. Bu durumda geri dönen bir değer olmaz.

blockingargümanıTrueolarak ayarlanıp çağrılırsa, argümansız çağrıldığında yaptıklarının aynısını yapar veTruedeğeri geri döndürülür.

blockingargümanıFalseolarak ayarlanıp çağrılırsa, iş parçacığını bloke etmez. Eğer argümanı olmayan bir çağrı engellenirse, hızlı bir şekildeFalsedeğeri geri döndürülür; diğer türlü, argümansız çağrıldığında yaptıklarının aynısını yapar veTruedeğeri geri döndürülür.

timeoutargümanı pozitif bir kayan noktalı sayı olarak ayarlanıp çağrılırsa, iş parçacığıtimeoutargümanında belirlenen saniye kadar kilidi tekrar edinemediği sürece engellenir. Kilit edinilmişseTruedeğerini geri döner,timeoutzamanı dolmuşsaFalsedeğeri geri döner.

Sürüm 3.2.’de değiştirildi.timeoutparametresi yenidir.

release()

Bir kilidi serbest bırakır, öz yineleme (recursion) seviyesini azaltır. Öz yineleme değeri, azaltımdan sonra sıfır olursa, (hiç bir iş parçacığı tarafından sahip olunmayan) kilidi “kilitli değil” şeklinde sıfırlar ve diğer iş parçacıkları kilidin açılmasını beklemek için engellenirse, bu iş parçacıklarından kesinlikle bir tanesine işlenmesi için izin verir. Eğer öz yineleme seviyesi azaltımdan sonra halen sıfır olmamışsa, kilit “kilitli” duruma gelir ve çağrılan iş parçacığı tarafından sahiplenilir.

Bu yöntemi sadece çağrılan iş parçacığı bir kilide sahip olduğu zaman çağırın. Eğer kilit, açık durumda ise, bu yöntemi çağırmak birRuntimeErrorhatası yükseltir.

Geri dönen bir değer yoktur.

#### Condition (Durum) Nesneleri

Bir durum değişkeni her zaman bir kilitle ilişkilidir; bu değişken içeri aktarılabilir veya varsayılan olarak bir tane oluşturulabilir. Bir tanesini içeri aktarmak, bir kaç durum nesnesi aynı kilidi ortaklaşa kullandığında kullanışlıdır. Kilit, durum nesnesinin bir parçasıdır: onu ayrı olarak izleyemezsiniz.

Bir durum nesnesi, içerik yönetim protokolüne uyar: Ekli engelleme süresi için durum değişkeniniwithdeyimi ile birlikte kullanmak ilgili kilidi elde edilmesini sağlar.acquire()verelease()yöntemleri ayrıca bahsi geçen kilitle ilgili olan yöntemleri çağırır.

Diğer yöntemler tutulan kilitle birlikte çağrılmalıdır.wait()yöntemi kilidi serbest bırakır ve sonra iş parçacığı onunotify()veyanotify_all()ile çağırıp uyandırana kadar, iş parçacığını engeller. Bir kez uyandırıldığında,wait()onu yeniden edinir ve geri döndürür. Ayrıca bir zaman aşımı süresi belirlemek de mümkündür.

notify()yöntemi, eğer iş parçacıklarının herhangi biri bekliyorsa, durum değişkenini bekleyen iş parçacıklarından birisini uyandırır.notify_all()yöntemi ise durum değişkenini bekleyen bütün iş parçacıklarını uyandırır.

Not:notify()venotify_all()yöntemleri kilitleri serbest bırakmaz; bu,notify()veyanotify_all()’u çağırmış ve sonunda kilidin sahiplğinden feragat eden bir iş parçası veya iş parçacıkları uyandırıldığında,wait()çağrısı ile acil olarak geri döndürülmeyecekleri anlamına gelir.

Durum nesneleri kullanan tipik programlama stillinde kilit, bazı paylaşılan durumlara erişimi senkronize etmek için kullanılır; belirli durum değişimleriyle ilgili olan iş parçacıkları,notify()veyanotify_all()’u çağırırken, bekleyenler için olası istenilen bir duruma göre durumu değiştirdiklerinde, istenen durumu görene kadar tekrar tekrarwait()yöntemini çağırır. Örneğin; takip eden kod, sınırsız bir tampon kapasitesine sahip genel bir üretici-tüketici durumudur:

```python
# Bir item'i tüketir
with cv:
 while not an_item_is_available():
 cv.wait()
 get_an_available_item()

# Bir item'i üretir
with cv:
 make_an_item_available()
 cv.notify()

```

whiledöngüsü uygulamanın durumunu kontrol etmek için gereklidir, çünküwait()keyfi olarak uzun bir sürede geri dönebilir venotify()çağrısını bildiren koşul, hiç bir zaman doğru olmayabilir. Bu çoklu iş parçacığı programlamaya özgü bir durumdur.wait_for()yöntemi durum kontrolünü otomatik hale getirmek ve zaman aşımı hesaplamalarını kolaylaştırmak için kullanılır:

```python
# Bir item'i tüketir
with cv:
 cv.wait_for(an_item_is_available)
 get_an_available_item()

```

Sadece bir veya bir kaç bekleyen iş parçacığının, durum değişmesiyle ilgili olup olmamadıklarına görenotify()venotify_all()arasında seçim yapın. Örneğin, tipik bir üretici-tüketici durumunda, bir itemi tampona eklemek sadece bir tüketici iş parçacığının uyandırılmasını gerektirir.

class threading.Condition(lock=None)

Bu sınıf durum değişkeni nesnelerini sağlar. Bir durum değişkeni bir veya birden çok iş parçacığının, başka bir iş parçacığı tarafından onaylanana kadar, beklemesine izin verir.

Eğerlockargümanı veriliyse ve değeriNonedeğilse, birLockveyaRLocknesnesi olmalıdır ve temel kilit olarak kullanılmalıdır.Diğer türlü, yeni birRLocknesnesi oluşturulur ve temel kilit olarak kullanılır.

Sürüm 3.3’de değiştirildi: Kurucu fonksiyondan bir sınıfa değiştirildi.

acquire(*args)

Temel kilidi edinir. Bu yöntem temel kilit üzerinde ilgili yöntemi çağırır; geri dönen değer, yöntem neyi geri döndürüyorsa o olur.

release()

Temel kilidi serbest bırakır. Bu yöntem temel kilit üzerinde ilgili yöntemi çağırır; geri dönen bir değeri yoktur.

wait(timeout=None)

Onaylanana veya zaman aşımına uğrayana kadar bekler. Eğer çağıran iş parçacığı bu kilidi edinmemişse, bu yöntem çağrıldığında birRuntimeErrorhatası yükseltilir.

Bu yöntem temel kilidi serbest bırakır ve sonra başka bir iş parçacığının içindeki aynı durum değişkeni içinnotify()veyanotify_all()çağrısı tarafından uyandırılana kadar veya seçime bağlı zaman aşımı gerçekleşene kadar iş parçacığını engeller. Bir kez uyandırıldığında veya zaman aşımına uğradığında, kilidi yeniden edinir ve geri döndürür.

timeoutargümanı belirlenmiş ve değeriNoneolmadığında, değeri, işlemin zaman aşımı süresini saniyelerle belirten kayan noktalı bir sayı olmalıdır.

Temel kilitRLockolduğunda,release()yöntemi kullanılarak serbest bırakılamaz, çünkü bu durum birden çok kez öz yinelemeli olarak elde edildiğinden kilidi açmaz. Bunun yerine,RLocksınıfının iç arayüzü, öz yinelemeli olarak bi çok defa elde edilse bile gerçekten kitler. Sonra diğer bir iç arayüz, kilit yeniden edinildiğinde ön yineleme seviyesini yeniden düzenlemek için kullanılır.

Belirli bir zaman aşımına uğramadığı sürece, geri dönen değerTrueolur, bu durumda ise geri dönen değerFalseolur.

Sürüm 3.2’de değiştirildi: Önceden yöntem hepNonedeğerini geri döndürüyordu.

wait_for(predicate, timeout=None)

Bir durum doğru değerlendirene kadar bekler,predicate (=yüklem)sonucu bir boolean değer olarak yorumlanacak olan, çağrılabilir bir şey olmalıdır.timeoutargümanı maksimum bekleme zamanı olarak sağlanmıştır.

Bu araç yöntemiwait()’i yüklem sağlanana kadar veya zaman aşımı oluşana kadar tekrar tekrar çağırabilir. Geri dönen değer yüklemin son geri dönen değeridir ve yöntem zaman aşımına uğrarsaFalseolarak değerlendirilir.

timeoutözelliğini yok saymak, bu yöntemi çağırmak kabaca aşağıdakini yazmakla eşdeğerdir:

```python
while not predicate():
 cv.wait()

```

Bu yüzden, aynı kuralwait()ile aynı şekilde kullanılır: Kilit çağrıldığında tutulur ve geri döndürmede yeniden elde edilir. Yüklem, tutulan kilit ile değerlendirilir.

Sürüm 3.2’de gelen yeni bir özellik.

notify(n=1)

Ön-tanımlı olarak, varsa bu durumu bekleyen bir iş parçacığını uyandırır. Eğer çağrılan iş parçacığı bu yöntem çağrıldığında daha önce kilidi edinmemişse, birRuntimeErrorhatası yükseltilir.

Bu yöntem en fazlantane durum değişkenini bekleyen iş parçacığını uyandırır; hiç bir iş parçacığı beklemiyorsa, işlem yapılmaz.

Hali hazırdaki uygulama, eğer en azntane iş parçacığı bekliyorsa, kesinliklentane iş parçacığını uyandırır. Ancak, bu davranışa
güvenmek pek güvenilir değildir. İleride, iyileştirilmiş bir uygulama zaman zamanntaneden fazla iş parçacığı uyandırabilir.

Not:Uyandırılmış bir iş parçacığı, kilidi yeniden elde edinceye kadarwait()tarafından geri dönmez.notify()kilidi serbest bırakmıyorsa, çağıranı serbest bırakmalıdır.

notify_all()

Bu durumu bekleyen bütün iş parçacıklarını uyandırır. Bu yöntemnotify()gibi davranır, fakat bir tanesi yerine, bekleyen bütün iş parçacıklarını uyandırır. Eğer bu yöntem çağrıldığında, çağıran iş parçacığı kilidi daha önce edinmemişse, birRuntimeErrorhatası yükseltilir.

#### Semaphore Nesneleri

Bu, bilgisayar bilimi tarihindedeki en eski senkronizasyon ilkellerinden biridir, Hollandalı bilgisayar bilimcisi Edsger W. Dijkstra tarafından icat edilmiştir (acquire()verelease()yerineP()veV()isimlerini kullanıyordu.).

Bir semafor, heracquire()çağrısında azaltılan ve herrelease()çağrısında artırılan içsel bir sayacı yönetir. Sayaç sıfırın altına hiç
bir zaman inemez;acquire()bu sayacın sıfır olduğunu bulursa, iş parçacığını başka bir iş parçacığırelease()’i çağırana kadar engeller.

Semaforlar ayrıca içerik yönetim protokülünü desteklerler.

class threading.Semaphore(value=1)

Bu sınıf semafore nesnelerini uygular. Bir semaforrelease()’in çağrılma sayısından,acquire()’in çağrılma sayısını çıkartan ve bir başlangıç değerini eklemekle temsil edilen bir sayacı yönetir.acquire(), sayacı negatif bir sayı yapmadan geri döndürene kadar, eğer gerekliyse iş parçacığını engelleyebilir. Eğer verili değilse,valueargümanının değeri ön-tanımlı olarak 1’dir.

Seçeneğe bağlı argüman, iç sayacın başlangıc değerini verir; ön-tanımlı olarak değeri 1’dir. Eğervalueargümanının değerine 1’den az bir sayı verilirse,ValueErrorhatası yükseltilir.

Sürüm 3.3’de değiştirildi. Kurucu fonksiyondan bir sınıfa değiştirildi.

acquire(blocking=True, timeout=None)

Bir semafor elde eder.

Argümanlar olmadan çağrıldığında: eğer iç sayaç girişte sıfırdan büyükse, onu bir birim azaltır ve acilen geri döner. Eğer girişte değeri sıfır ise, başka bir iş parçacığırelease()’i çağırıp değerini sıfırdan daha büyük bir sayı yapana kadar, engeller. Bu uygun bir kilitleyici ile birlikte yapılır böylece bir çokacquire()çağrıları engellenir,release()bunlardan kesinlikle bir tanesini uyandıracaktır. Uygulama bir tanesini rastgele seçer, böylece engellenmiş iş parçacıkları uyandırıldığında oluşan düzene güvenmemek gerekir.Truedeğeri geri döner (veya süresiz olarak engeller).

blockingargümanıFalseolarak ayarlanmış bir şekilde çağrılırsa, iş parçacığını engellemez. Eğer argümansız bir çağrı iş parçacığını engellerse, acil olarakFalsedeğerini geri döndürür; diğer türlü, argümansız olarak çağrıldığının aynısını yapar veTruedeğerini geri döndürür.

timeoutargümanıNone’dan farklı bir şey olacak şekilde çağrılırsa, en fazlatimeoutargümanındaki belirtilen saniye kadar iş parçacığını engeller. Eğer bu arada elde etme başarılı bir şekilde tamamlanmamışsa,Falsedeğerini geri döndürür. Diğer türlü,Truedeğerini geri döndürür.

release()

Bir semaforu serbest bırakır, iç sayacı bir birim artırır. Girişte sıfır olduğunda ve diğer bir iş parçacığı, sayacın tekrar sıfırdan büyük bir sayı olmasını beklediğinde, bu iş parçacığını uyandırır.

class threading.BoundedSemaphore(value=1)

Bu sınıf, bağlanmış semafor nesnesini uygular. Bağlanmış semafor, hali hazırdaki değerin, ilk değeri aşmadığından emin olmak için kontrol eder. Eğer aşmışsa,ValueErrorhatası yükseltilir. Bir çok durumda semaforlar sınırlı kapasiteli kaynakları korumak için kullanılır. Eğer semafor birden fazla kez serbest bırakılmışsa, bu bir bug olduğuna işarettir. Eğer verili değilse,valueargümanının ön-tanımlı değeri 1’dir.

Sürüm 3.3’de değiştirildi. Kurucu fonksiyondan sınıfa değiştirildi.

Semafor Örneği

Semaforlar genellikle sınırlı kapasiteli kaynakları korumak için kullanılır, örneğin, bir veritabanı sunucusunda. Kaynağın boyutunun sabit olduğu hangi durumda olursa olsun, bağlanmış bir semafor kullansanız iyi olur. Çalışan iş parçacıklarını oluşturmadan önce, ana iş parçacığınız semaforu başlatacaktır:

```python
maxconnections = 5
# ...
pool_sema = BoundedSemaphore(value=maxconnections)

```

Bir kez oluşturulduğunda, çalışan iş parçacıkları semafor’unacquire()verelease()yöntemlerini, sunucuya bağlanmaya ihtiyaç duyduklarında çağırır:

```python
with pool_sema:
 conn = connectdb()
 try:
 # ... bağlantıyı kullan ...
 finally:
 conn.close()

```

Bağlanmış semaforun kullanılması, elde edildiğinden daha fazla serbest bırakılması gibi bir programlama hatasını tespit edememe şansını azaltır.

#### Event (Olay) Nesneleri

Bu, iş parçacıkları arasındaki iletişim için en basit mekanizmadır: Bir iş parçacığı bir olayı sinyal eder ve diğer iş parçacığı da bunu bekler.

Bir olay nesnesiset()yöntemi ile değeriTrueolan veclear()yöntemiyle de değeriFalseolan bir iç işareti yönetir.wait()yöntemi işaretin değeriTrueolana kadar iş parçacığını engeller.

class threading.Event

Bu sınıf olay nesnelerini uygular. Bir olay,set()yöntemi ile değeriTrueolan vclear()yöntemiyle de değeriFalseolan bir işareti yönetir.wait()yöntemi iş parçacığını, işaretin değeriTrueolana kadar engeller. İşaretin değeri ilk olarakFalse’dur.

Sürüm 3.3’de değiştirildi. Kurucu bir fonksiyondan bir sınıfa değiştirildi.

is_set()

Sadece iç işaretTrueolduğundaTruedeğerini geri döndürür.

set()

İç işaretiTrueolaak ayarlar.Trueolmasını bekleyen bütün iş parçacıkları uyandırılır.wait()’i çağıran iş parçacığı, bir kez işaretTrueolursa, bir daha engellenmeyecektir.

clear()

İç işaretiFalseolarak sıfırlar. Sonradan,wait()’i çağıran iş parçacıkları,set(), iç işareti tekrarTrueyapana kadar engellenecektir.

wait(timeout=None)

İç işaretTrueolana kadar iş parçacığını engeller. Eğer girişte iç işaretTrueolursa, acil olarak geri döner. Diğer türlü, başka bir iş parçacığı, işaretiTrueyapmak içinset()’i çağırana kadar veya seçime bağlıtimeoutsüresi dolana kadar, iş parçacığını engeller.

timeoutargümanı kullanılarak çağrıldığında ve değeriNoneolmadığında, değeri, işlemin zaman aşımı süresini saniyelerle belirten kayan noktalı bir sayı olmalıdır.

Bu yöntem, ancak iç işaretin değeriTrueolarak ayarlanmışsa,Truedeğerini geri döndürür,wait()çağrısından önce veya çağrı başladıktan sonra,timeoutdeğeri verilmemişse ve işlem zaman aşımına uğramamışsa her zamanTruedeğerini geri döndürür.

Sürüm 3.1’de değiştirildi: Daha önceden, bu yöntem her zamanNonedeğerini geri döndürürdü.

#### Timer (Zamanlayıcı) Nesneleri

Bu sınıf, sadece belirli bir zaman geçtikten sonra çalıştırılan bir eylemi, -bir zamanlayıcıyı- temsil eder.Timer,Thread’in bir alt sınıfı olup, ayrıca özel bir iş parçacığı oluşturma işlevi örneğidir.

Zamanlayıcılar, tıpkı iş parçacıkları gibistart()yöntemi çağrılarak başlatılır. Zamanlayıcı (eylemi başlamadan önce)cancel()yöntemi çağrılarak durdurulabilir. Zamanlayıcının eyleminin gerçekleşmesininden önce bekleyeceği aralık, kullanıcının tanımladığı aralık olmayabilir.

Örneğin:

```python
def hello():
 print("hello, world")

t = Timer(30.0, hello)
t.start() # 30 saniye sonra, "hello, world" yazısı ekrana bastırılacak.

```

class threading.Timer(interval, function, args=None, kwargs=None)

interval (=aralık)argümanında belirtilen saniyelerden sonra,argsargümanları vekwargsanahtar argümanlarıyla birlikte çalışan bir fonksiyonun atandığı bir zamanlayıcı oluşturur. Eğerargs,None(ön-tanımlı değeri bu) ise, boş bir liste kullanılacaktır. Eğerkwargs,Noneise (ön-tanımlı değeri bu) ise, boş bir sözlük kullanılacaktır.

Sürüm 3.3’de değiştirildi: Kurucu fonksiyondan sınıfa değiştirildi.

cancel()

Zamanlayıcıyı durdurur ve zamanlayıcının eyleminin çalıştırılmasını iptal eder. Bu sadece eğer zamanlayıcı halen kendi bekleme evrendiseyse çalışır.

#### Barrier (Engel) Nesneleri

Sürüm 3.2’de gelen yeni bir özelliktir.

Bu sınıf, birbirini bekleme ihtiyacında olan sabit sayıdaki iş parçacıklarının kullanması için basit senkronizasyon ilkelleri sağlar. Her bir iş parçacığıwait()yöntemini çağırarak engeli aşmaya çalışır ve bütün iş parçacıkları aynı çağrıyı yapana kadar da iş parçacıkları engellenir. Bu noktada bütün iş parçacıkları aynı anda serbest bırakılır.

Engel aynı sayıdaki iş parçacıkları için bir çok kez tekrar kullanılabilir.

Aşağıdaki örnek, bir istemci ve sunucu iş parçacını senkronize etmek için basit bir yoldur:

```python
b = Barrier(2, timeout=5)

def server():
 start_server()
 b.wait()
 while True:
 connection = accept_connection()
 process_server_connection(connection)

def client():
 b.wait()
 while True:
 connection = make_connection()
 process_client_connection(connection)

```

class threading.Barrier(parties, action=None, timeout=None)

Bir partide bulunan değişik sayıdaki iş parçacığı için bir engel nesnesi oluşturur.actionargümanı yazıldığında, iş parçacıklarından biri tarafından, serbest bırakıldığı zaman çağrılan, çağrılabilir bir şeydir.timeoutargümanı belirtilmediği zaman değeriwait()yöntemi için ön tanımlı değeridir.

wait(timeout=None)

Engeli geçer. İş parçacıkları partisi engele doğru bu fonksiyonu çağırmışsa, aynı anda hepsi birden serbest bırakılır. Eğer birtimeoutdeğeri belirlenirse, sınıf yapıcısına verilmiş herhangi bir tercih için kullanılır.

Geri dönen değer, 0 ile parti sayısının 1 eksiği arasında bir tamsayıdır, her bir iş parçacığı için değişebilir. Bu, bir takım özel idare işleri yapacak olan bir iş parçacığını seçmek için kullanılabilir. Örneğin:

```python
i = barrier.wait()
if i == 0:
 # Sadece bir iş parçacığı bunu bastırmaya ihtiyaç duyar.
 print("engel geçildi")

```

Eğer yapıcıya bir taneactionsağlanmışsa, iş parçacıklarından bir tanesi serbest bırakılmadan önce onu çağırmış olacaktır. Bu çağrım bir hata yükseltirse, engel kırılan durumun içine yerleştirilir.

Eğer çağrı zaman aşımına uğrarsa, engel kırılan durumun içine yerleştirilir.

Bu yöntem, beklenildiği gibi, eğer engel kırılmışsa veya iş parçacığı beklerken sıfırlanmışsa,BrokenBarrierErrorhatası yükseltebilir.

reset()

Engeli ön-tanımlı değerine, boş duruma geri döndürür. Onu bekleyen her iş parçacığıBrokenBarrierErrorhatasını alır.

Durumu bilinmeyen bazı iş parçacıkları olduğunda, bu fonksiyonun bazı dış senkronizasyonlara ihtiyaç duyabileceğini not edin. Eğer bir engel kırıldığında, onu terk edip, yeni bir tane oluşturmak daha iyi bir yoldur.

abort()

Bir engeli kırılmış bir duruma sokar. Bu, canlı veya ileride çağrılacak bütün çağrılarıBrokenBarrierErrorhatasıyla başarısızlığa uğramaları içinwait()’i yöntemini çağırır. Bunu, eğer uygulamayı çıkmazdan kurtarmak için, iptal edilmeye ihtiyaç duyuyorsa kullanın.

Bu, iş parçacıklarından bir tanesinin ters gitmesine karşı hassas birtimeoutdeğeri ile oluşturulmuş bir engeli otomatik olarak korumak için tercih edilebilir.

parties

Engeli geçmesi gereken iş parçacığı sayısıdır.

n_waiting

Hali hazırda engelde bekleyen iş parçacığı sayısıdır.

broken

Eğer engel kırılan durumun içindeyse, değeriTrueolan bir boolean verisidir.

exception threading.BrokenBarrierError

Bu beklenti,RuntimeError’un bir alt sınıfıdır,Barriernesnesi sıfırlandığında veya kırıldığında yükseltilir.

#### Kilitleri, Durumları ve Semaforlarıwithdeyimi ile birlikte kullanmak

Bu modül tarafından sağlanan,acquire()verelease()fonksiyonuna sahip bütün nesneler içerik yönetimi olarakwithdeyimi için kullanılabilir.acquire()yöntemi, engellemeye girildiğinde,release()yöntemi de engellemeden çıkıldığında çağrılacaktır. Bundan ötürü aşağıdaki kodlar:

```python
with some_lock:
 # Bir şeyler yap...

```

şu işlemin dengidir:

```python
some_lock.acquire()
try:
 # Bir şeyler ya...
finally:
 some_lock.release()

```

Hali hazırda,Lock,RLockCondition,SemaphoreveBoundedSemapgorenesneleriwithdeyimi içerik yönetimi olarak kullanılabilir.

#### Örnekler:

Örnek-1:

Thread’ı kullanmanın en kolay yolu; onu bir hedef fonksiyonuyla örnekleyip,start()fonksiyonunu çağırarak çalıştırmaktır.

Kodlar:

```python
#/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading

def f(): # Thread'in iş fonksiyon.
 print("iş")

for i in range(4):
 t = threading.Thread(target=f)
 t.start()

```

Kodların Açıklamaları:

Yukarıdaki kodlarda,fisminde bir tane fonksiyon oluşturulmuş ve içine “iş” string verisini ekrana yazdıran birprint()fonksiyonu dahil edilmiştir. Daha sonrafordöngüsünü kullanarak, dört tane iş parçacığı nesnesi örneği oluşturulmuştur. Bütün iş parçacıklarının hedef fonksiyonu,f’tir. Ve bu program çalıştırıldığında dört kere ekrana “iş” yazısı yazdırılır.

Örnek-2:

Bir iş parçacığı oluşturmak ve hangi işi yapacağını söylemek için argüman atamak kullanılacak yollardan birisidir. İkinci örnektethread’in sonradan bastıracağı bir sayı argümanı fonksiyonda tanımlanmıştır.

Kodlar:

```python
#/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading

def f(sayi):
 print("iş {}".format(sayi))

for i in range(4):
 t = threading.Thread(target=f, args=(i, ))
 t.start()

```

Kodların Açıklamaları:

Bir iş parçacığı oluştururken, iş parçacığının etkin olacağı fonksiyonun eğer bir fonksiyon parametresi varsa, onuargsparametresine yazarak, iş parçacığının hedefi olmasını sağlayabiliriz.

Örnek-3:

İş parçacıklarını adlanırmak veya tanıtmak için Örnek-2’de olduğu gibi argümanları kullanmak oldukça gereksizdir. Ancak bu demek değildir ki argüman kullanmak gereksizdir. Sadece iş parçacığının ismini belirtirken bu yöntemi kullanmak gereksizdir demek istiyorum. Yoksa argümanlara ihtiyaç duyacağımız çok fazla durumla karşılaşmamız mümkün. Şundan bahsetmek istiyorum; herThreadörneğinin ismiyle birlikte, iş parçacığı oluşturulduğunda değişen, rastgele bir değeri vardır.Thread’leri isimlendirmek, sunucu işlemleriyle, birçok farklı hizmet işlerinin birlikte yürütülmesinde kolaylık sağlar.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import time

def f():
 print(threading.currentThread().getName(), "Başlıyor")
 time.sleep(2)
 print(threading.currentThread().getName(), "Bitiyor")

def g():
 print(threading.currentThread().getName(), "Başlıyor")
 time.sleep(5)
 print(threading.currentThread().getName(), "Bitiyor")

t1 = threading.Thread(name="Birinci servis", target=f)
t2 = threading.Thread(name="İkinci servis", target=g)
t3 = threading.Thread(target=f)
t4 = threading.Thread(target=g)

t1.start()
t2.start()
t3.start()
t4.start()

```

Kodların Açıklamaları:

Bu örnekteki şu kısma bir bakalım:

```python
def f():
 print(threading.currentThread().getName(), "Başlıyor")
 time.sleep(2)
 print(threading.currentThread().getName(), "Bitiyor")

```

f()fonksiyonu çağrıldığında, ismi neyse o şekilde “filanca Başlıyor” şeklinde bir yazı ekrana bastırılacak. Sonra 2 saniye bekledikten sonra “filanca Bitiyor” şeklinde bir yazı ekrana bastırılacak.

Ancak bu durumu iş parçacığı nesnesini tanımlarken değiştirebiliyoruz. Yani:

```python
t1 = threading.Thread(name="Birinci servis", target=f)
t2 = threading.Thread(name="İkinci servis", target=g)

```

yukarıda olduğu gibi iş parçacığını tanımladığımızda, t1 ve t2 iş parçacıklarına kendimiz isim vermiş oluyoruz. Bu isimleri vermediğimizde iş parçacığının ismiThread-1şeklinde bir isme sahip olur. t3 ve t4 isimli iş parçacıklarınınnameargümanının yazılmamış olduğuna dikkat edin. Bu iki iş parçacığının ismimleri dolayısıylaThread-1veThread-2olacaktır.

Örnek-4:

Şimdi gelin threading’i daha rahat anlayabileceğimiz bir örnek oluşturalım. Bildiğiniz gibi herhangi birtkinteruygulamasını çalıştırabilmemiz içinmainloop()fonksiyonunu çağırmamız gerekiyor. Ve bu fonksiyon, programı sonlandıran herhangi bir işlem tanımlanmamışsa, sürekli çalışır durumda oluyor. Peki biz aynı anda bir tanesitkinter’e ait olan iki tane döngüyü aynı anda çalıştıramaz mıyız? Elbette çalıştırabiliriz, işte cevabı:

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

try:
 import Tkinter as tk
except ImportError:
 import tkinter as tk
import threading

root = tk.Tk()
entry = tk.Entry(master=root)
entry.grid(row=0, column=0)

def f():
 button = tk.Button(master=root, text="Button")
 while True:
 if entry.get() == "":
 button.grid_forget()
 else:
 button.grid(row=1, column=0)

t1 = threading.Thread(target=f)
t1.daemon = True
t1.start()
t1.join(1)
root.mainloop()

```

Kodların Açıklamaları:

Bu örneği çalıştırdığınızda, göreceksiniz ki,entrywidgetine yazı yazdığınızdabuttonwidgeti beliriyor,entrywidgeti boş olduğunda ise ortadan kayboluyor. Bu işlem basit bir denetleme işlemidir ve tahmin edeceğiniz gibi fonksiyonun içindekiwhiledöngüsü bu işe yarıyor.t1isimlithreadingörneğini oluşturduktan sonra onundaemonözelliğinin değeriniTrueolarak değiştirdiğimizi görüyorsunuz. Bu işlemi yapmaktaki amacımız, programı sonlandırdığımızda, geriye sadecedaemoniciş parçacıklarının kalmasını sağlamak ve böylece programdan çıkmamızı sağlamak. Eğer budaemonözelliğini aktif hale getirmemiş olsaydık,tkinterpenceresini kapattığımız halde, programın sonlanmadığını görürdük.t1.join(1)kodu da, bu iş parçacığının 1 saniye sonrası sonlanmasını istediğimizi belirtir.

Örnek-5:

Şimdi deLocknesnesiyle alakalı bir örnek yapalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading

def f():
 print("f fonksiyonu")

def g():
 print("g fonksiyonu")

def h():
 print("h fonksiyonu")

t1 = threading.Thread(target=f)
t2 = threading.Thread(target=g)
t3 = threading.Thread(target=h)
lock = threading.Lock()
lock.acquire()
t1.start()
lock.acquire(blocking=True, timeout=3)
t2.start()
lock.acquire(blocking=True, timeout=1)
t3.start()

```

Kodların Açıklamaları:

Önce gerekli modülü programın içine aktardık:

```python
import threading

```

Sonra farklı iş parçacıklarının çağıracağı üç tane fonksiyon tanımladık:

```python
def f():
 print("f fonksiyonu")

def g():
 print("g fonksiyonu")

def h():
 print("h fonksiyonu")

```

Daha sonra fonksiyonları iş parçacıklarının hedefihaline getirdik:

```python
t1 = threading.Thread(target=f)
t2 = threading.Thread(target=g)
t3 = threading.Thread(target=h)

```

Sonra kilit nesnemizi oluşturduk ve kilit nesnemizinacquire()fonksiyonunu argümansız olarak çağırdık. Eğer argümanlı çağırsaydık da değişen bir şey olmazdı, çünkü kilit bir sonrakiacquire()fonksiyonunu çağırdığımız zaman engellemeye başlayacak:

```python
lock = threading.Lock()
lock.acquire()

```

t1isimli iş parçacığını başlattık; engellenmeden çalışmaya başladı:

```python
t1.start()

```

Ve şimdilock.acquire()yönteminiblockingvetimeoutargümanlarıyla birlikte çağıralım. Bu yöntemit1.start()’ı çağırmadan önce ikinci kez çağırsaydık o zaman,t1iş parçacığı da engellenecekti.timeoutparametresine3yazalım. Yani 3 saniyeliğine diğer işlemleri engellesin:

```python
lock.acquire(blocking=True, timeout=3)

```

Üç saniye geçtikten sonra t2 iş parçacığını başlatalım:

```python
t2.start()

```

lock.acquire()fonksiyonunu bir kez daha çağırabiliriz, bu kez 1 saniyeliğine diğer görevleri engellesin:

```python
lock.acquire(blocking=True, timeout=1)

```

Ve son olarak dat3iş parçacığını başlatalım:

```python
t3.start()

```

Yukarıdaki örnekte, ekrana önce “f fonksiyonu” yazıldı, “f fonksiyonu” yazısı ekrana yazdırıldıktan üç saniye sonra ekrana “g fonksiyonu” yazıldı, ve “g fonksiyonu” ekrana yazdırıldıktan bir saniye sonra da “h fonksiyonu” ekrana yazıldı.

Örnek-6:Şimdi deacquire()yöntemini bir kez yazarak, bu yöntemden sonra gelen işlemlerin engellenmediği bir örnek yazalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading

class Thread(threading.Thread):
 def __init__(self, lock):
 threading.Thread.__init__(self)
 self.lock = lock

 def run(self):
 self.lock.acquire()
 print("{} kilidi edindi.".format(self.name))
 # self.lock.acquire(blocking=True, timeout=3)
 self.lock.release()
 print("{} kilidi serbest bıraktı.".format(self.name))

__lock__ = threading.Lock()
t1 = Thread(lock=__lock__)
t2 = Thread(lock=__lock__)
t1.start()
t2.start()

```

Kodların Açıklamaları:

Her zamanki gibi önce modülümüzü programın içine aktaralım:

```python
import threading

```

Şimdi dethreading.Thread’i miras alan bir sınıf oluşturalım. Ve bu sınıfınlockisminde bir tane de özelliği olsun:

```python
class Thread(threading.Thread):
 def __init__(self, lock):
 threading.Thread.__init__(self)
 self.lock = lock

```

Bildiğiniz gibithreading.Thread()’inrun()isimli bir yöntemi var. Bu yöntemioverrideyapalım, yani modülünrun()yöntemi yerine bizim yazacağımızrun()yöntemi kullanılsın. Bu yöntem, ilk olarakself.lock.acquire()fonksiyonunu çağırsın. Hemen altında, iş parçacığının kilidi edindiğine dair mesajı ekrana yazdıranprint()fonksiyonunu çağıralım. Bir altındaki yoruma alınmış# self.lock.acquire(blocking=True, timeout=3)kısmı, yorumdan çıkarırsanız, alttaki işlemlerin çalışabilmesi için üç saniye beklemek zorunda kalırsınız.self.lock.release()ile de kilidi serbest bırakıyoruz. verun()fonksiyonunun son satırında da kilidin serbest bırakıldığına dair mesajı ekrana bastıran bir print()` fonksiyonu çağıralım:

```python
def run(self):
 self.lock.acquire()
 print("{} kilidi edindi.".format(self.name))
 # self.lock.acquire(blocking=True, timeout=3)
 self.lock.release()
 print("{} kilidi serbest bıraktı.".format(self.name))

```

Sınıfı oluşturduk, örnekleri oluşturmadan önce kilidimizi oluşturalım:

```python
__lock__ = threading.Lock()

```

Şimdi de iş parçacıklarımızı oluşturup onları başlatalım:

```python
t1 = Thread(lock=__lock__)
t2 = Thread(lock=__lock__)
t1.start()
t2.start()

```

Örnek-7:

Şimdi deRLockile ilgili bir örnek yapalım.LockileRLockarasındaki en belirgin fark,Lock’ın kilidini bir başka iş parçacığı açabilir olması, oysaRLock’ın kilidini, kilidi edinmiş olan iş parçacığının açması gerekir.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading

class Thread(threading.Thread):
 def __init__(self, lock):
 threading.Thread.__init__(self)
 self.lock = lock

 def run(self):
 self.lock.acquire(blocking=True, timeout=3)
 print("{} çalışıyor.".format(self.name))
 self.lock.acquire(blocking=True, timeout=1)
 print("{} çalışması bitti.".format(self.name))

__lock__ = threading.RLock()
t1 = Thread(lock=__lock__)
t2 = Thread(lock=__lock__)
t1.start()
t2.start()

```

Kodların Açıklamaları:

Her zamanki gibi öncethreadinmodülünü programın içine aktarıyoruz:

```python
import threading

```

lockparametresi olan vethreading.Thread()sınıfını miras alan bir sınıf oluşturuyoruz:

```python
class Thread(threading.Thread):
 def __init__(self, lock):
 threading.Thread.__init__(self)
 self.lock = lock

```

Yinerun()yönteminioverrideedelim. Burun()fonksiyonu altında çağırdığımız ilk fonksiyonself.lock.acquire(blocking=True, timeout=3)fonksiyonudur. Bu fonksiyon kilidi edinecek olan ilk iş parçacığına uygulanmaz. Bir sonraki satırda, iş parçacığının çalıştığına dair ekrana bir yazı yazdırıyoruz (print(“{} çalışıyor.”.format(self.name))). Onun da altında kilidiself.lock.acquire(blocking=True, timeout=1)fonksiyonu ile bir daha ediniyoruz. Bir iş parçacığı RLock kilidini ikinci kez kendi işlemlerini engellemeden elde edebilir. Verun()yönteminin son satırında da çalışmanın bittiğine dair ekrana bir yazı yazdırıyoruz (print(“{} çalışması bitti.”.format(self.name))):

```python
def run(self):
 self.lock.acquire(blocking=True, timeout=3)
 print("{} çalışıyor.".format(self.name))
 self.lock.acquire(blocking=True, timeout=1)
 print("{} çalışması bitti.".format(self.name))

```

Sınıfı oluşturduk, örnekleri oluşturmadan önce kilidimizi oluşturalım:

```python
__lock__ = threading.RLock()

```

Şimdi de iş parçacıklarımızı oluşturup onları başlatalım:

```python
t1 = Thread(lock=__lock__)
t2 = Thread(lock=__lock__)
t1.start()
t2.start()

```

Not:Bu örnekte RLock kilidine sahip olan iş parçacığıt1’dir. Dolayısıyla kilidi sadece o açabilir. Bu örneği çalıştırdığınızda,t1iş parçacığının kilit edindiğini ama serbest bırakmadığını görüyoruz. Eğert1bu kilidi serbest bıraksaydı, iş parçacıkları arasında bekleme süresi olmayacaktı.

Örnek-8:

Şimdi deCondition()ile ilgili bir örnek yapalım. Bu örnekte bir üretici bir de tüketici iş parçacığı oluşturacağız.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time
import threading

class Uretici(threading.Thread):
 def __init__(self, condition, liste):
 threading.Thread.__init__(self)
 self.condition = condition
 self.liste = liste

 def run(self):
 count = 1
 while count < 10:
 self.condition.acquire()
 print("{} condition'u edindi.".format(self.name))
 self.liste.append(count)
 print("{} listeye {} tarafından eklendi."
 .format(count, self.name))
 self.condition.notify()
 print("condition {} tarafından bildirildi.".format(self.name))
 self.condition.release()
 print("condition {} tarafından serbest bırakıldı."
 .format(self.name))
 count += 1
 time.sleep(0.5)

class Tuketici(threading.Thread):
 def __init__(self, condition, liste):
 threading.Thread.__init__(self)
 self.condition = condition
 self.liste = liste

 def run(self):
 while True:
 self.condition.acquire()
 print("{} condition'u edindi.".format(self.name))
 while True:
 if self.liste:
 sayi = self.liste.pop()
 print("{}, {} {}".format(
 sayi, self.name,
 "tarafından listeden düşürüldü."))
 break
 print("condition {} {}".format(
 self.name, "tarafından bekletiliyor."))
 self.condition.wait()
 self.condition.release()
 print("condition {} {}".format(
 self.name,
 "tarafından serbest bırakıldı."))

__condition__ = threading.Condition()
__liste__ = []
t1 = Uretici(condition=__condition__, liste=__liste__)
t2 = Tuketici(condition=__condition__, liste=__liste__)
t1.start()
t2.start()

```

Kodların Açıklamaları:

Her zamanki gibi önce gerekli modülleri programın içine aktarıyoruz:

```python
import time
import threading

```

Şimdi,threading.Threadsınıfının özelliklerini miras alan bir üretici sınıf tanımlayalım; bu sınıftan bir örnek türetilmek istendiği zaman kullanıcıconditionargümanını velisteargümanını girmek zorunda kalsın:

```python
class Uretici(threading.Thread):
 def __init__(self, condition, liste):
 threading.Thread.__init__(self)
 self.condition = condition
 self.liste = liste

```

Bu sınıfın bir tanerun()metodu zaten mevcut ama biz burun()metodunu değiştirelim:

```python
def run(self):

```

Burun()yönteminde aşağıdakiler yapılsın:
1. countisimli daha sonraself.liste’ye eklenmek üzere bir değişken tanımlayalım:count=1
1. Bir tane döngü oluşturalım, bu döngücount, 10’dan küçük olduğu sürece devam etsin:whilecount<10:
1. Döngü içinde iş parçacığıCondition’u edinsin ve ekrana daCondition’u elde ettiğine dair bir yazı yazdırılsın:self.condition.acquire()print("{}condition'u edindi.".format(self.name))
1. İş parçacığı şimdi decountdeğişkeniniself.liste’ye eklesin ve ekrana bu işlemle ilgili bir yazı yazdırılsın:self.liste.append(count)print("{}listeye{}tarafından eklendi.".format(count,self.name))
1. Sonra, iş parçacığı, durumunu bildirsin ve bildirildiğine dair ekrana bir yazı yazdırılsın:self.condition.notify()print("condition{}tarafından bildirildi.".format(self.name))
1. Şimdi de iş parçacığıCondition’u serbest bıraksın ve serbest bıraktığına dair ekrana bir yazı yazdıralım:self.condition.release()print("condition{}tarafından serbest bırakıldı.".format(self.name))
1. countdeğişkenini 1 birim artıralım vetime.sleep(0.5)fonksiyonunu çağırarak işlemler arasında biraz zaman geçmesini bekleyelim:count+=1time.sleep(0.5)

countisimli daha sonraself.liste’ye eklenmek üzere bir değişken tanımlayalım:

```python
count = 1

```

Bir tane döngü oluşturalım, bu döngücount, 10’dan küçük olduğu sürece devam etsin:

```python
while count < 10:

```

Döngü içinde iş parçacığıCondition’u edinsin ve ekrana daCondition’u elde ettiğine dair bir yazı yazdırılsın:

```python
self.condition.acquire()
print("{} condition'u edindi.".format(self.name))

```

İş parçacığı şimdi decountdeğişkeniniself.liste’ye eklesin ve ekrana bu işlemle ilgili bir yazı yazdırılsın:

```python
self.liste.append(count)
print("{} listeye {} tarafından eklendi."
 .format(count, self.name))

```

Sonra, iş parçacığı, durumunu bildirsin ve bildirildiğine dair ekrana bir yazı yazdırılsın:

```python
self.condition.notify()
print("condition {} tarafından bildirildi.".format(self.name))

```

Şimdi de iş parçacığıCondition’u serbest bıraksın ve serbest bıraktığına dair ekrana bir yazı yazdıralım:

```python
self.condition.release()
print("condition {} tarafından serbest bırakıldı."
 .format(self.name))

```

countdeğişkenini 1 birim artıralım vetime.sleep(0.5)fonksiyonunu çağırarak işlemler arasında biraz zaman geçmesini bekleyelim:

```python
count += 1
time.sleep(0.5)

```

Şimdi de,threading.Threadsınıfının özelliklerini miras alan bir tüketici sınıf tanımlayalım; yine bu sınıftan bir örnek türetilmek istendiği zaman kullanıcıconditionargümanını velisteargümanını girmek zorunda kalsın:

```python
class Tuketici(threading.Thread):
 def __init__(self, condition, liste):
 threading.Thread.__init__(self)
 self.condition = condition
 self.liste = liste

```

Bu sınıfın da bir tanerun()metodu zaten mevcut ama biz burun()metodunu değiştirelim:

```python
def run(self):

```

Burun()yönteminde aşağıdakiler yapılsın:
1. Sonsuz bir döngü oluşturalım, bu döngü içerisindeki tüketici iş parçacığıCondition’u elde etsin ve elde ettiğine dair bilgiyi ekrana yazdıralım:whileTrue:self.condition.acquire()print("{}condition'u edindi.".format(self.name))
1. Bir tane daha sonsuz döngü oluşturalım, Bu döngüde de bir koşul oluşturalım, koşulumuzself.listeTruedeğeri veriyorsa olsun ve bu koşul altındasayiisimli bir değişkeniself.liste’den düşürelim. Ekrana da iş parçacığının bu sayıyı listeden düşürdüğünün bilgisini yazdıralım, sonra da bu koşul altındaki döngüden çıkılsın:whileTrue:ifself.liste:sayi=self.liste.pop()print("{},{}{}".format(sayi,self.name,"tarafından listeden düşürüldü."))break
1. Yine ikinci döngünün içindeyken her zamanCondition’u bekletelim ve beklediğine dair yazı ekrana yazdırılsın, şayet bunu yapmazsak, döngü başa sardığında iş parçacığıCondition’u tekrar edinir ve program orada donup kalır:print("condition{}{}".format(self.name,"tarafından bekletiliyor."))self.condition.wait()
1. İlk döngümüzün içindeCondition’u serbest bırakalım. Bu örnekteCondition()`u serbest bırakmazsak, bir sorunla karşılaşmayız. Ama iki tane tüketici olduğu durumlarda `whiledöngüsünü kırabilecek bir durum oluşturabiliriz ve döngü kırıldıktan sonra iş parçacığı kilidi hala tutmaya devam ediyor olabilir, bu yüzden kilidi serbest bırakmak gerekir:self.condition.release()print("condition{}{}".format(self.name,"tarafından serbest bırakıldı."))

Sonsuz bir döngü oluşturalım, bu döngü içerisindeki tüketici iş parçacığıCondition’u elde etsin ve elde ettiğine dair bilgiyi ekrana yazdıralım:

```python
while True:
 self.condition.acquire()
 print("{} condition'u edindi.".format(self.name))

```

Bir tane daha sonsuz döngü oluşturalım, Bu döngüde de bir koşul oluşturalım, koşulumuzself.listeTruedeğeri veriyorsa olsun ve bu koşul altındasayiisimli bir değişkeniself.liste’den düşürelim. Ekrana da iş parçacığının bu sayıyı listeden düşürdüğünün bilgisini yazdıralım, sonra da bu koşul altındaki döngüden çıkılsın:

```python
while True:
 if self.liste:
 sayi = self.liste.pop()
 print("{}, {} {}".format(
 sayi, self.name,
 "tarafından listeden düşürüldü."))
 break

```

Yine ikinci döngünün içindeyken her zamanCondition’u bekletelim ve beklediğine dair yazı ekrana yazdırılsın, şayet bunu yapmazsak, döngü başa sardığında iş parçacığıCondition’u tekrar edinir ve program orada donup kalır:

```python
print("condition {} {}".format(
 self.name, "tarafından bekletiliyor."))
self.condition.wait()

```

İlk döngümüzün içindeCondition’u serbest bırakalım. Bu örnekteCondition()`u serbest bırakmazsak, bir sorunla karşılaşmayız. Ama iki tane tüketici olduğu durumlarda `whiledöngüsünü kırabilecek bir durum oluşturabiliriz ve döngü kırıldıktan sonra iş parçacığı kilidi hala tutmaya devam ediyor olabilir, bu yüzden kilidi serbest bırakmak gerekir:

```python
self.condition.release()
print("condition {} {}".format(
 self.name,
 "tarafından serbest bırakıldı."))

```

Ve son olarakCondition(),Uretici(),Tüketici()sınıflarından birer örnek ve boş bir liste oluşturalım.Condition()sınıfından oluşturduğumuz örnek ve listeyiUretici()veTuketici()sınıflarından oluşturduğumuz örneklere argüman olarak yazalım. Sonra da iş parçacıklarını çalıştıralım:

```python
__condition__ = threading.Condition()
__liste__ = []
t1 = Uretici(condition=__condition__, liste=__liste__)
t2 = Tuketici(condition=__condition__, liste=__liste__)
t1.start()
t2.start()

```

Not:Bu örneği çalıştırdığımızdaUretici()sınıf örneği boş listeye 9 tane eleman ekleyecek veTuketici()sınıf örneği ise listeye eklenen bu elemanları tek tek silecek. Ve son olarakTuketici()sınıfı kendisini beklemeye alacak.

Örnek-9:

Şimdi deSemaphore()nesnesiyle alakalı bir örnek yapalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time
import threading

semaphore = threading.Semaphore()

def f():
 print("f fonksiyonu başlıyor.")
 semaphore.acquire()
 print("f fonksiyonu semaforu edindi.")
 for i in range(5):
 print("f fonksiyonu '{}' itemini işliyor.".format(i))
 time.sleep(1)
 semaphore.release()
 print("f fonksiyonu semaforu serbest bırakıyor.")
 print("f fonksiyonu bitiyor.")

def g():
 print("g fonksiyonu başlıyor")
 while not semaphore.acquire():
 print("Semafor henüz kullanılamıyor.")
 time.sleep(1)
 else:
 print("g fonksiyonu semaforu edindi.")
 for i in range(5):
 print("g fonksiyonu '{}' itemini işliyor.".format(i))
 time.sleep(1)
 semaphore.release()
 print("g fonksiyonu semaforu serbest bırakıyor.")

t1 = threading.Thread(target=f)
t2 = threading.Thread(target=g)
t1.start()
t2.start()

```

Not:Bu örnekte kullanılanSemaphore()nesnesi yerine,Lock(),RLock,Condition()veBoundedSemaphore()nesnelerini de kullanabilirsiniz. Bu örnekBoundedSemaphore()veCondition()nesneleri için pek uygun bir örnek olmasa da,Lock(),RLocknesneleri için bu örneği kullanmakta bir sakınca yok.

Kodların Açıklamaları:

Önce modüllerimizi programın içine aktaralım:

```python
import time
import threading

```

ŞimdiSemaphore()nesnesinden bir tane örnek oluşturalım:

```python
semaphore = threading.Semaphore()

```

Bu örnektef()veg()isimli iki tane fonksiyon kullanacağız. Öncef()fonksiyonunu oluşturalım, fonksiyon çağrılır çağrılmaz, ekrana bir yazı yazdırılsın:

```python
def f():
 print("f fonksiyonu başlıyor.")

```

Daha sonra iş parçacığı semaforu edinsin ve elde ettiğine dair bir yazı ekrana yazdırılsın:

```python
semaphore.acquire()
print("f fonksiyonu semaforu edindi.")

```

Şimdi de fonksiyon içinde basit bir işlem tanımlayalım:

```python
for i in range(5):
 print("f fonksiyonu '{}' itemini işliyor.".format(i))
 time.sleep(1)

```

İş parçacığı semaforu serbest bıraksın ve serbest bıraktığına dair ekrana bir yazı yazdırılsın, son olarak da fonksiyonun çalışmasının bittiğine dair ekrana bir yazı yazdırılsın:

```python
semaphore.release()
print("f fonksiyonu semaforu serbest bırakıyor.")
print("f fonksiyonu bitiyor.")

```

Şimdi deg()fonksiyonunu oluşturalım. Fonksiyon çağrıldığında, fonksiyonun başladığına dair bir yazı ekrana yazdırılsın:

```python
def g():
 print("g fonksiyonu başlıyor")

```

İş parçacığı bu kilidi edinmediği sürece ekrana bir yazı yazdırılsın. Ancakacquire()fonksiyonununblockingargümanınıFalseyapmadığımız için bu yazı ekrana yazdırılmayacaktır. İsterseniz bir deacquire(blocking=None)yazarak örneği bir daha çalıştırın:

```python
while not semaphore.acquire():
 print("Semafor henüz kullanılamıyor.")
 time.sleep(1)

```

Eğer iş parçacığı semaforu edindiyse aşağıdaki işlemler yapılsın:

```python
else:
 print("g fonksiyonu semaforu edindi.")
 for i in range(5):
 print("g fonksiyonu '{}' itemini işliyor.".format(i))
 time.sleep(1)

```

Son olarak bu iş parçacığı da semaforu serbest bıraksın:

```python
semaphore.release()
print("g fonksiyonu semaforu serbest bırakıyor.")

```

Örnek-10:

Şimdi deBoundedSemaphore()ile ilgili bir örnek yapalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import time

def f(item, bs):
 bs.acquire()
 time.sleep(1)
 print(item)
 bs.release()

bounded_semaphore = threading.BoundedSemaphore(value=2)
for i in range(10):
 t = threading.Thread(target=f, args=(i, bounded_semaphore))
 t.start()

```

Kodların Açıklamaları:

Yine her zamanki gibi önce modülleri programın içine aktaralım:

```python
import threading
import time

```

Şimdi de bir tanef()fonksiyonu tanımlayalım. Bu fonksiyonunitemvebsisminde iki tane argümanı olsun.itemargümanını for listesindeki her bir eleman için,bsargümanını da semaphore için kullanacağız:

```python
def f(item, bs):

```

Fonksiyonu çağıran iş parçacığı bağlanmış semaforu elde etsin, sonra 1 saniye bekleyelim vefordöngüsünün elemanını ekrana yazdıralım, son olarak da bağlanmış semaforu serbest bırakalım:

```python
bs.acquire()
time.sleep(1)
print(item)
bs.release()

```

Şimdiglobalalanda bir tane bağlanmış semafor oluşturalım vevalueargümanına 2 yazalım:

```python
bounded_semaphore = threading.BoundedSemaphore(value=2)

```

Son olarak bir tanefordöngüsü içinde 10 tane iş parçacığı oluşturalım. Bu iş parçacıklarınınargsargümanında, listenin o sıradaki elemanı ve tanımladığımız bağlanmış semafor olsun:

```python
bounded_semaphore = threading.BoundedSemaphore(value=2)
for i in range(10):
 t = threading.Thread(target=f, args=(i, bounded_semaphore))
 t.start()

```

Not:Bu örneği çalıştırdığınızda, ekrana sayıların ikişer ikişer yazdırıldığını göreceksiniz. Bunun olmasını sağlayan, bağlanmış semaforunvaluedeğerinin 2 olarak yazılmasıdır.

Örnek-11:

Şimdi deEvent()ile alakalı bir örnek yapalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time
import threading

class Uretici(threading.Thread):
 def __init__(self, event, liste):
 threading.Thread.__init__(self)
 self.event = event
 self.liste = liste

 def run(self):
 count = 1
 while count < 10:
 self.liste.append(count)
 print("{} listeye {} tarafından eklendi."
 .format(count, self.name))
 self.event.set()
 print("event {} tarafından ayarlandı.".format(self.name))
 self.event.clear()
 print("event {} tarafından temizlendi.".format(self.name))
 count += 1
 time.sleep(0.5)

class Tuketici(threading.Thread):
 def __init__(self, event, liste):
 threading.Thread.__init__(self)
 self.event = event
 self.liste = liste

 def run(self):
 while True:
 if self.liste:
 sayi = self.liste.pop()
 print("{}, {} tarafından listeden düşürüldü."
 .format(sayi, self.name))
 self.event.wait()

__event__ = threading.Event()
__liste__ = []
t1 = Uretici(event=__event__, liste=__liste__)
t2 = Tuketici(event=__event__, liste=__liste__)
t1.start()
t2.start()

```

Kodların Açıklamaları:

Modüllerimi programın içine aktaralım:

```python
import time
import threading

```

ŞimdiUreticiisminde,eventvelisteargümanlarına sahip,threading.Thread()sınıfından türetilmiş bir sınıf oluşturalım:

```python
class Uretici(threading.Thread):
 def __init__(self, event, liste):
 threading.Thread.__init__(self)
 self.event = event
 self.liste = liste

```

Bu sınıfarun()isminde bir tane fonksiyon ekleyelim. Bildiğiniz gibi bu fonksiyonthreading.Thread()sınıfına ait olan bir fonksiyon, dolayısıyla burada yine yazacağımız fonksiyon, orjinal fonksiyonun üzerine yazılacak:

```python
def run(self):

```

Fonksiyondacountisminde bir tane değişken kullanacağız. Bu değişken 10’dan küçük olduğu sürecewhiledöngüsü çalışmaya devam edecek:

```python
count = 1
while count < 10:

```

Şimdi listemizecountdeğişkenini ekleyelim ve ekranacount’un listeye eklendiğine dair bir yazı yazdıralım:

```python
self.liste.append(count)
print("{} listeye {} tarafından eklendi."
 .format(count, self.name))

```

ŞimdiEvent()sınıfının önceset()fonksiyonunu sonra daclear()fonksiyonunu çağıralım, her bir işlem için ekrana bir yazı yazdıralım:

```python
self.event.set()
print("event {} tarafından ayarlandı.".format(self.name))
self.event.clear()
print("event {} tarafından temizlendi.".format(self.name))

```

countdeğişkeni 1 birim artsın vetime.sleep(0.5)fonksiyonu ile 0.5 saniye bekleyelim:

```python
count += 1
time.sleep(0.5)

```

Şimdi de benzer şekildeTuketicisınıfımızı oluşturalım:

```python
class Tuketici(threading.Thread):
 def __init__(self, event, liste):
 threading.Thread.__init__(self)
 self.event = event
 self.liste = liste

```

Bu sınıfınrun()metodunda da tanımlayalım:

```python
def run(self):

```

Yine bir döngü oluşturalım veself.listemevcut olduğu sürece, listedensayiismindeki değişken düşürülsün ve ekrana bu sayının düşürüldüğüne dair bir yazı yazdırılsın:

```python
while True:
 if self.liste:
 sayi = self.liste.pop()
 print("{}, {} tarafından listeden düşürüldü."
 .format(sayi, self.name))

```

VeEvent()sınıfınınwait()fonksiyonunu çağıralım. Bu fonksiyon, yapacak hiç bir işlem kalmadığında beklemeye devam edilmesini sağlayacak:

```python
self.event.wait()

```

Event(),Uretici()veTuketici()sınıflarından birer örnek oluşturalım ayrıca boş bir liste tanımlayalım son olarak da iş parçacıklarımızı başlatalım:

```python
__event__ = threading.Event()
__liste__ = []
t1 = Uretici(event=__event__, liste=__liste__)
t2 = Tuketici(event=__event__, liste=__liste__)
t1.start()
t2.start()

```

Not:Bu örneği çalıştırdığınızda,Uretici()9 tane elemanı listeye eklerken,Tuketici()’de bu listeye eklenen elemanları listeden silecek. Listeden silinecek bir şey kalmayınca daTuketici()kendisini beklemeye alacak.

Örnek-12:

Şimdi deBarrier()nesnesiyle alakalı bir örnek yapalım.

Kodlar:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time
import random
import threading

def f(b):
 time.sleep(random.randint(2, 10))
 print("{} iş parçacığının uyandırıldığı tarih: {}"
 .format(threading.current_thread().getName(), time.ctime()))
 b.wait()
 print("{} iş parçacığının engeli geçtiği tarih: {}"
 .format(threading.current_thread().getName(), time.ctime()))

barrier = threading.Barrier(3)
for i in range(3):
 t = threading.Thread(target=f, args=(barrier,))
 t.start()

```

Kodların Açıklamaları:

Her zamanki gibi önce gerekli modülleri programın içine aktaralım:

```python
import time
import random
import threading

```

Şimdibargümanına sahip,fisminde bir tane fonksiyon oluşturalım. Bu fonksiyonda öncetime.sleep(random.randint(2, 10))fonksiyonunu çağırarak 2 ile 10 saniye arasında belirsiz bir süre bekleneceğini belirtelim. Daha sonra ekrana iş parçacığının uyandırıldığı tarih ekrana yazdırılsın, sonra daBarrier()nesnemizinwait()yöntemini çağıralım, son olarak da iş parçacığının engeli geçtiği tarih ekrana yazdırılsın:

```python
def f(b):
 time.sleep(random.randint(2, 10))
 print("{} iş parçacığının uyandırıldığı tarih: {}"
 .format(threading.current_thread().getName(), time.ctime()))
 b.wait()
 print("{} iş parçacığının engeli geçtiği tarih: {}"
 .format(threading.current_thread().getName(), time.ctime()))

```

Fonksiyonu oluşturduktan sonrabarrierisminde bir taneBarrier()nesnesi örneği oluşturalım. Bu nesnenin argümanına 3 vermemizin sebebi, 3 tane iş parçacığı ile çalışıyor olmamızdır:

```python
barrier = threading.Barrier(3)

```

Son olarak birfordöngüsü oluşturalım, bufordöngüsü 3 tanethreading.Thread()örneği üretsin ve döngü içinde bu örnekleri başlatalım:

```python
barrier = threading.Barrier(3)
for i in range(3):
 t = threading.Thread(target=f, args=(barrier,))
 t.start()

```

Not:Barrier()nesnesinin özelliğine göre, oluşturulan bu iş parçacıklarının uyandırılma zamanları farklı olsa da, iş parçacıkları aynı anda engeli aşarlar.

### sched modülü

Bu modülün amacı belirli fonksiyonları sırayla çalıştırmaktır.
Modülün içinde scheduler diye bir sınıf mevcut.
(Sınıfın adı dikkat ettiyseniz küçük harfle başlıyor.)
Bu modülü kullanmadan önceschedulersınıfından bir örnek
oluşturmalısınız:

```python
import sched
s=sched.scheduler()

```

Örneğimizi bu şekilde oluşturabiliriz. Ancak bu şekilde
oluşturmamız bize daha sonra sorun teşkil edebilir.
Bu sınıfın iki tane parametresi var. Bunlardan ilki:timefunc.
Bu parametrenin varsayılan değeritime.monotonic. Örnek oluşturulurken
bu parametreyitime.timeolarak ayarlayalım. Bunun sebebini
birazdan açıklayacağım. İkinci ve son parametre isedelayfunc.
Bu parametrenin varsayılan değeritime.sleep. Bu parametreyi de
kodun okunaklılığı açısından belirtelim. Sonuç olarak örneğimizi
şu şekilde tanımlayalım:

```python
import sched, time
s=sched.scheduler(time.time, time.sleep)

```

Şimdi sıra bu örneğin metodlarında.

#### scheduler.enter()

Bu metod çalıştırılacak fonksiyonların sıraya eklenmesini sağlıyor.
5 tane parametresi var. İlki bekleme süresini belirliyor.
İkincisi önceliğini belirliyor. Eğer aynı zamanda çalışacak
fonksiyonlar varsa önceliğine göre çalıştırılır. Üçüncüsü
çalışacak fonksiyon. Diğer ikisi isimli parametre. Bunlardanargumentolan eğer varsa demet olarak fonksiyonun parametrelerini alıyor.
Diğerinin adı da tahmin edeceğiniz üzerekwargs. Değeri de
sözlük olarak fonksiyonun isimli parametreleri.

schedulersınıfınındelayfuncparametresi burada kullanılıyor.

#### scheduler.enterabs()

Bu metodentermetodundan çok da farklı değil. Tek farkı ilk
değeri bekleme süresini değil çalışacağı süreyi belirliyor.

schedulersınıfınıntimefuncparametresi burada kullanılıyor.

#### scheduler.cancel()

enterveyaenterabsile sıraya eklenmiş fonksiyonları
sıradan çıkarmayı sağlıyor.

#### scheduler.empty()

Eğer sırada herhangi bir fonksiyon yoksaTruedöndürür.
Eğer fonksiyon varsaFalsedöndürür.

#### scheduler.run()

Sıradaki fonksiyonları hazırlandığı şekilde çalıştırır.
Tek parametresi olanblockingeğerFalseise ilk çalışacak
fonksiyonun çalışmasına kalan süreyi döndürür.

#### scheduler.queue

Bu değişkenschedulernesnelerinin sahip olduğu ve bizim
kullanabileceğimiz tek değişken. Daha önce sıraya eklenmişEventnesnelerini tutuyor.

#### Örnekler

Anlatım biraz kafa karıştırıcı oldu. Ancak şimdi birkaç
Örnek yaparak mantığını kavramanızı sağlayalım.

```python
>>> import sched,time
>>> s=sched.scheduler(time.time,time.sleep)
>>> def zamanı_yazdır(sıra):
 print(f"Zaman: {time.time()} ,{sıra}")

>>> def farklı_zamanları_yazdır():
 print(time.time())
 s.enter(10,1,zamanı_yazdır,argument=("Birinci",))
 s.enter(5,1,zamanı_yazdır,argument=("İkinci",))
 s.enter(5,2,zamanı_yazdır,argument=("Üçüncü",))
 s.enter(5,1,zamanı_yazdır,argument=("Dördüncü",))
 s.run()
 print(time.time())

>>> farklı_zamanları_yazdır()
1532176259.627274
Zaman: 1532176264.6953058 ,İkinci
Zaman: 1532176264.6953058 ,Dördüncü
Zaman: 1532176264.6953058 ,Üçüncü
Zaman: 1532176269.6955397 ,Birinci
1532176269.7111597

```

Çalışmaya başladıktan 5 saniye sonra “İkinci”, “Üçüncü” ve “Dördüncü”
çalıştı. “İkinci” ve “Dördüncü”nün sırası aynıydı. O yüzden
tanımlanma sıralarına bakıldı. “Üçüncü”nün öncelik sırası
2 olduğu için onlardan daha sonra yazıldı. “Birinci” onlardan 5
saniye sonra yani çalışmaya başladıktan 10 saniye sonra çalıştı.

Bir başka örnek:

```python
import sched,time
s=sched.scheduler(time.time,time.sleep)
yazdırılacak_değer="Merhaba Dünya"
def değiştir():
 global yazdırılacak_değer
 yazdırılacak_değer="Merhaba Zalim Dünya"

def yazdır():
 print(yazdırılacak_değer)

suan=time.time()
if(s.empty()):
 s.enterabs(suan+5,1,yazdır)
 s.enterabs(suan+6,2,değiştir)
 s.enterabs(suan+6,1,yazdır)
 s.enter(10,1,yazdır)
s.run()

```

ifbloğunda eğer sıra boşsa çalışmasını söyledik.
Sıra boş olduğu için altındaki fonksiyonlar çalışacaktır.
İlk önce 5 saniye sonra bir kereyazdırfonksiyonu çalışacaktır.
Daha sonra çalışmaya başladıktan 6 saniye sonra ikinciyazdırfonksiyonu çalışacaktır. Çıktısı ilkiyle aynı olur.
Ancak hemen sonra çalışandeğiştirfonksiyonu ileyazdırılacak_değerdeğiştiği için 10. saniyede çalışanyazdırfonksiyonu
farklı bir çıktı veriyor.

Şu şekilde fantastik bir döngü oluşturulabilir:

```python
import sched,time
s=sched.scheduler(time.time,time.sleep)
suan=time.time()
def çıktı():
 global suan
 suan+=2
 print(suan)
 s.enterabs(suan,1,çıktı)

s.enter(5,1,çıktı)
s.run()

```

Her iki saniyede bir aynı kod çalışacaktır.
Eğer2’yi değiştirirseniz süreyi de düzenlemiş olursunuz.

### json Modülü

JSON farklı diller arasında iletişimi sağlamak için geliştirilmiş
basit bir veri formatıdır. Bu veri formatı Python’daki sözlük ve
listelere çok benzer. İki tür kullanımı vardır. Birincisi anahtar-değer mantıyla çalışır.

```python
{
 "Ad": "Fırat",
 "Soyad": "Özgül"
}

```

JSON ifadelerinde her öğe arasında virgül olmalıdır. Anahtar ve değer ikilisi
arasında ise iki nokta kullanılır.

İkinci kullanımı ise liste tipine çok benzer. Bu kullanımda
anahtar-değer değil, sadece değer verilir.

```python
{
 "Fırat",
 "Özgül"
}

```

JSON modülünde 4 ana fonksiyon bulunuyor. Bunlardan ikisi
Python ile JSON oluşturmaya yararken diğer ikisi JSON
verilerini çözmeye yarar. JSON oluşturan fonksiyonlar şu
ikisidir:
1. json.dump
1. json.dumps

json.dump

json.dumps

JSON verilerini çözen iki fonksiyon ise şunlardır:
1. json.load
1. json.loads

json.load

json.loads

#### json.dump ve json.dumps

Bu iki fonksiyonu birlikte yazmak istedim. Çünkü ikisinin
parametreleri neredeyse aynı. Aralarındaki fark ise şu:

dumpfonksiyonu çıktıyı illaki bir dosya içine aktarır.
Yani size al bu senin istediğin JSON çıktısı demez. Bunu diyendumpsfonksiyonudur.dumpsfonksiyonustrtipinde
bir değer döndürürkendumpfonksiyonu hiçbir değer döndürmez.

O yüzden python.org sitesinden alınan şu örneklerdedumpyerinedumpsfonksiyonu kullanılmış.Eğerdumpfonksiyonunu
kullanacaksanız JSON’a dönüşmesini istediğiniz ifadeden sonra
dosyayı bulunduran değişkeni yazın.

```python
>>> import json
>>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
'["foo", {"bar": ["baz", null, 1.0, 2]}]'
>>> print(json.dumps("\"foo\bar"))
"\"foo\bar"
>>> print(json.dumps('\u1234'))
"\u1234"
>>> print(json.dumps('\\'))
"\\"
>>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
{"a": 0, "b": 0, "c": 0}
>>> from io import StringIO
>>> io = StringIO()
>>> json.dump(['streaming API'], io)
>>> io.getvalue()
'["streaming API"]'

```

Bu fonksiyonların birkaç parametresi var. Şimdi sıra bunların
ne işe yaradığını öğrenmekte.

skipkeys

Normalde Python, JSON oluştururken anahtar veya değer basit tipte
(str,int,float…) değilseTypeErrorhatası verir.
Eğer bu parametreTrue(VarsayılanFalse) ise hata vermek yerine o ikiliyi atlar.

ensure_ascii

Eğer bu parametreTrue(varsayılan olarak) ise çıktıda ASCII
tablosuna uymayan karakterlerden kaçınır.Falseise buna dikkat etmez.

```python
>>> import json
>>> json.dumps(["üzüm"],ensure_ascii=True)
'["\\u00fcz\\u00fcm"]'
>>> json.dumps(["üzüm"],ensure_ascii=False)
'["üzüm"]'

```

indent

Eğer negatif olmayan bir tamsayı veya bir karakter dizisi ise
girintileme sayesinde daha güzel bir çıktı almanızı sağlar.
Eğer 0, negatif sayı veya boş karakter dizisi(“”) ise her öğeyi yeni
satıra basar. None(varsayılan) ise dip dibe bir çıktı verir.
Pozitif bir sayı verildiğinde onu boşluk sayısı kabul ederek
girintileme yapar. Karakter dizisi ifadesine şu ikisi yeterince açık
bir örnek:\t,\n

> **Not**
> Karakter dizisi kullanımı 3.2 sürümü itibari ile başladı.

Not

Karakter dizisi kullanımı 3.2 sürümü itibari ile başladı.

```python
>>> print(json.dumps({"Özellikler":{"Hız":150,"Ses":"10db"}},indent=None))
{"\u00d6zellikler": {"H\u0131z": 150, "Ses": "10db"}}
>>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent=4))
{
 "Ozellikler": {
 "Hiz": 150,
 "Ses": "10db"
 }
}
>>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent="\n"))
{

"Ozellikler": {

"Hiz": 150,

"Ses": "10db"

}
}
>>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent=0))
{
"Ozellikler": {
"Hiz": 150,
"Ses": "10db"
}
}

```

separators

Bu parametre verilen değeri öğeler arasında ayraç olarak
kullanır. Verilen değer tuple tipinde olmalıdır. Varsayılan olarak
şu kullanılır:(“,”, “: “)Ancak indent parametresiNonedeğerindeyse ilk virgül değeri de iki
nokta gibi sonuna boşluk alır. Yani şu şekilde olur:(”, “, “: “)

```python
>>> json.dumps({"Elma":42,"Armut":25,"kiraz":65},separators=("?","!"))
'{"Elma"!42?"Armut"!25?"kiraz"!65}'

```

#### json.load ve json.loads

Bu iki fonksiyon da dump ve dumps gibi birbirine çok benziyor.
Hatta farkları bile neredeyse aynı. load fonksiyonu sadece
dosyadaki JSON verilerini Python verisine çevirirken
loads fonksiyonu veriyi parametre olarak alıyor. dump
ve dumps’da olduğu gibi parametreleri tamamen aynı.

Buraya birkaç örnek kod yazalım.

```python
>>> json.loads('{"mezuniyet": "üniversite", "Bölüm": "Tıp"}')
{'mezuniyet': 'üniversite', 'Bölüm': 'Tıp'}
>>> json.loads('["\\u00fcz\\u00fcm"]')
['üzüm']

```

Şimdi de sıra fonksiyonların aldığı parametrelerde.

object_hook

Döndürülen değerin veri tipini değiştirmenizi sağlar. Bunu
bir kod ile açıklayalım.

```python
>>> json.loads('{"mezuniyet": "üniversite", "Bölüm": "Tıp"}',object_hook=list)
['mezuniyet', 'Bölüm']

```

Gördüğünüz gibi çıktıyı liste tipinde verdi. Ancak bunu
yapmak için sadece anahtarları aldı.

object_pairs_hook

object_pairs_hook, object_hook ile benzer görevler yapıyor.
İkisi arasında öncelik object_pairs_hook’da. Eğer anahtar değer
ilişkisinden oluşan bir JSON verisiyse object_pairs_hook
değilse object_hook parametresi kullanılır.

```python
>>> json.loads('{"Ad": "Fırat", "Soyad": "Özgül"}',object_pairs_hook=str)
"[('Ad', 'Fırat'), ('Soyad', 'Özgül')]"
>>> json.loads('["Fırat", "Özgül"]',object_pairs_hook=dict,object_hook=list)
['Fırat', 'Özgül']

```

parse_int

int tipindeki değerlerin Python koduna dönüştürülürken hangi
tipin kullanılması gerektiğini belirler. Bunu bir kodla
açıklamak daha kolay olur sanıyorum:

```python
>>> json.loads('{"Satılan": 54, "Kalan": 46}',parse_int=float)
{'Satılan': 54.0, 'Kalan': 46.0}

```

parse_float

parse_int parametresinin yaptığını float tipindeki sayılar
için yapar.

```python
>>> json.loads('[23, 45.2, "yazbel", 512.128]',parse_int=bool,parse_float=list)
[True, ['4', '5', '.', '2'], 'yazbel', ['5', '1', '2', '.', '1', '2', '8']]

```

### timeit Modülü

Kaynak Kodu:https://github.com/python/cpython/blob/3.5/Lib/timeit.pyBelge Kaynağı:https://docs.python.org/3.5/library/timeit.html

Bu modül küçük kod parçalarının çalışma sürelerini ölçmeyi sağlar. Hem komut satırı arayüzüne hem de çağrılabilir bir arayüze sahiptir. Çalışma sürelerini ölçmek için birçok ortak tuzaktan kaçınır. Tim Peters’in O’Reilly tarafından yayımlanan Python Cookbook kitabının “Algoritmalar” bölümünün girişine de göz atın.

#### Temel Örnekler

Takip eden örnek, komut satırı arayüzünün üç değişik deyimi nasıl karşılaştırdığını gösteriyor:

```python
python3 -m timeit '"-".join(str(n) for n in range(100))'
10000 loops, best of 3: 29 usec per loop

python3 -m timeit '"-".join([str(n) for n in range(100)])'
10000 loops, best of 3: 25.3 usec per loop

python3 -m timeit '"-".join(map(str, range(100)))'
10000 loops, best of 3: 20 usec per loop

```

Bu, Python arayüzünden şu kodlarla gerçekleştirilebilir:

```python
import timeit

timeit.timeit('"-".join(str(n) for n in range(100))', number=10000)
0.30339929000001575

timeit.timeit('"-".join([str(n) for n in range(100)])', number=10000)
0.2637243290000697

timeit.timeit('"-".join(map(str, range(100)))', number=10000)
0.2151021940001101

```

timeit sadece komut satırı arayüzü kullanıldığında yineleme sayısını otomatik olarak belirleyecektir. Örnekler bölümünde gelişmiş örnekler bulabilirsiniz.

#### Python Arayüzü

Modül, üç kolaylık fonksiyonu ve bir topluluk sınıfı tanımlar:

timeit.timeit(stmt=’pass’, setup=’pass’, timer=<default timer>, number=1000000, globals=None)

Verili ifadeyle, kurulum koduyla ve timer fonksiyonuyla bir Timer örneği oluşturun ve onuntimeit()yöntemini çalıştırma sayıları ile çalıştırın. İsteğe bağlı globals bağımsız değişkeni, kodun çalıştırılacağı ad alanını belirtir.

Sürüm 3.5’de değiştirildi: İsteğe bağlı globals bağımsız değişkeni eklendi.

timeit.repeat(stmt=’pass’, setup=’pass’, timer=<default timer>, repeat=3, number=1000000, globals=None)

Verili ifadeyle, kurulum koduyla ve timer fonksiyonuyla bir Timer örneği oluşturun ve onunrepeat()yöntemini tekrarlanma sayısı ve çalıştırma sayıları ile çalıştırın. İsteğe bağlı globals bağımsız değişkeni, kodun çalıştırılacağı ad alanını belirtir.

Sürüm 3.5’de değiştirildi: İsteğe bağlı globals bağımsız değişkeni eklendi.

timeit.default_timer()

Her zamantime.perf_counter()olan varsayılan zamanlayıcı

Sürüm 3.3’de değiştirildi: Şimdi varsayılan sayıcıtime.perf_counter()

class timeit.Timer(stmt=’pass’, setup=’pass’, timer=<timer function>, globals=None)

Küçük kod parçalarının çalışma hızının zamanlaması için sınıf.

Yapıcı; zamanlamanın yapılması için bir ifade, kurulum için fazladan bir ifade ve zamanlama fonksiyonu alır. Her ifadenin varsayılan değeripassolur; timer fonksiyonu platforma bağımlıdır (docstringmodülüne bakınız). Ayrıcastmtvesetup, birbirlerinden ‘;’ işareti ile ayrılan çok sayıda ifadeyi içerebilir veya çok satır başı olan dizi değişkenlerini içermedikçe yeni satırları içerebilir. Deyim varsayılan olarak timeit’in ad alanında yürütülecektir; bu davranış, global alana bir isim alanı geçirerek kontrol edilebilir.

Birinci ifadenin çalışma hızını ölçmek içintimeit()yöntemini kullanın.repeat(),timeit()yöntemini bir çok kez çağırmak ve sonuç listesini geri döndürmek için bir kolaylıktır.setupparametresinin çalışma zamanı, bütün çalışma zamanından hariç tutulmuştur.

stmtvesetupparametreleri argümansız çağrılabilen nesneler alabilir. Bu, çağrıları, sonradantimeit()fonksiyonuyla çalıştırılacak şekilde, timer fonksiyonunun içine gömer. Bu durumda ilave fonksiyon çağrıları nedeniyle zamanlama yükünün biraz daha fazla olacağını unutmayın.

Sürüm 3.5’de değiştirildi: İsteğe bağlı olarak globals parametresi eklendi.

timeit(number=1000000)

Ana ifadenin zaman sayısıyla ilgili çalışmaları. Bu, bir kez setup ifadesini çalıştırır ve sonra ana ifadeyi birkaç kez çalıştırmak için, float tipinde saniyelerle ölçülen zamanı geri döndürür. Döngünün kaç kez tekrar edileceğini argüman belirler, varsayılan değeri bir milyondur. Ana ifade, setup ifadesi ve timer fonksiyonu yapıcıya geçirilmek için kullanılırlar.

Not:Varsayılan olarak,timeit()fonksiyonu zamanlama süresincegarbage collection’u etkisiz bırakır. Bu yaklaşımın avantajı, bağımsız zamanlamaları daha çok karşılaştırılabilir yapmaktır. Dezavantajı ise, garbage collection (çöp toplayıcısı), ölçüm esnasında fonksiyonun performansının önemli bir parçası olabilir. Böylece garbage collection (çöp toplayıcısı)setupdeğişkeninin (stringinin) ilk ifadesi olarak yeniden aktif edilebilir. Örneğin:

```python
timeit.Timer("for i in range(10): oct(i)", "gc.enable()").timeit()

```

repeat(repeat=3, number=1000000)

timeit()’i bir kaç kez çağırır.

Butimeit()’i tekrar çağıran, sonuçları listeleyen bir kolaylık fonksiyonudur. Birinci argümantimeit()’in kaç kez çağrılacağını belirler. İkinci parametre isetimeit()’in argümanıdır.

Not:Sonuç vektörlerinden alınan değerlerin aritmetik ortalamasını ve standart sapmasını rapor olarak sunmada cazip bir yöntemdir. Ancak bu çok kullanışlı değildir. Tipik bir durumda, en küçük değer, makinenin verili kod parçasını ne kadar hızlı şekilde çalıştırdığına dair zayıf bir göstergedir; sonuç vektörleri içindeki yüksek değerler Python’ın hızının değişkenliğinden kaynaklanmaz, ancak diğer işlemlerin tutarlı zamanlama çalışmasına karışmasından kaynaklanır. Yani en düşük değer sizin ilgilenmeniz gereken tek değer olabilir. Ondan sonra, bütün vektöre bakıp istatistik yerine sağ duyuya başvurabilirsiniz.

print_exc(file=name)

Zamanlama kodunun geri izini bastırmaya yardımcı olur.

Tipik kullanım:

```python
t = Timer(...) #try/except bloğunun dışında
try:
 t.timeit(...) # ya da t.repeat(...)
except Exception:
 t.print_exc()

```

Standart geri izinin avantajı, derlenen şablondaki kaynak çizgilerinin görüntülenecek olmasıdır. İsteğe bağlıfileargümanı geri izinin nereye gönderileceğini belirler, varsayılan değerisys.stderr’dir.

#### Komut Satırı Arayüzü

Bir program olarak komut satırı arayüzünden çağrılırken şu yapı kullanılır:

```python
python -m timeit [-n N] [-r N] [-u U] [-s S] [-t] [-c] [-h] [statement ...]

```

Takip eden seçenekler:

```python
-n N, --number=N

 İfadenin kaç kez çalıştırılacağını belirler.

-r N, --repeat=N

 timer'ın kaç kez tekrar edileceğini (varsayılan değeri 3) belirler.

-s S, --setup=S

 Bir kez ilksel olarak çalıştırılacak ifadeyi (varsayılan değeri `pass`) belirler.

-p, --process

 Duvar saati zamanını değil de, işlem zamanını ölçer. Varsayılan değeri `time.perf_counter()` yerine `time.process_time()`'dir.

 Sürüm 3.3'de gelmiş yeni bir özellik.

-t, --time

 (onaylanmamış) `time.time()`'ı kullanır.

-u, --unit=U

 Zamanlayıcı çıktısının zaman birimini belirler; usec, msec veya sec birimleri seçilebilir.

 Sürüm 3.5'de gelmiş yeni bir özellik.

-c, --clock

 (onaylanmamış) `time.clock()`'u kullanır.

-v --verbose

 Ham zamanlama sonuçlarını bastırır, daha fazla basamak kesinliği için tekrarlar.

-h -help

 Kısa bir kullanım mesajı bastırır ve sonlanır.

```

Çok satırlı ifadeler, her bir satırı ayrı bir ifade argümanı olacak şekilde verilebilir; girintili çizgiler, bir argümanın tırnak işaretleri içine alınarak ve önde gelen boşluklarla kullanılabilir.

Şayet-ndeğeri girilmezse, uygun döngü sayısı, toplam süre 0.2 saniye olana kadar onun üstleri olacak şekilde hesaplanır.

default_timer()ölçümleri makinede çalışan diğer programlar tarafından etkilenebilir, bu yüzden hassas ölçüm yapmak gerektiğinde en iyisi, zamanlamayı bir kaç kez tekrar etmek ve en uygun zamanı seçmektir.-rseçeneği bu işlem için uygundur; varsayılan üç yineleme sayısı bir çok durumda yeterlidir. CPU süresini ölçmek içintime.process_time()’ı kullanabilirsiniz.

Not:Bir geçiş ifadesi çalıştırmakla ilgili belirli bir temel yük vardır. Buradaki kod bunu gizlemeye çalışmaz fakat siz bunun farkında olmalısınız. Temel yük, programı argümansız çağırarak ölçülebilir ve Python sürümleri arasında farklılıklar gösterir.

#### Örnekler

Sadece başlangıçta bir kez çalıştırılmak üzere bir setup (kurulum) ifadesi kullanılabilir:

```python
python -m timeit -s 'text = "sample string"; char="g"' 'char in text'
10000000 loops, best of 3: 0.0482 usec per loop

python -m timeit -s 'text = "sample string"; char="g"' 'text.find(char)'
10000000 loops, best of 3: 0.178 usec per loop

```

Python arayüzü için:

```python
import timeit

timeit.timeit('char in text', setup='text = "sample string"; char = "g"')
0.048954748002870474

timeit.timeit('text.find(char)', setup='text = "sample string"; char = "g"')
0.2300617519977095

```

Aynı işlem timer() sınıfını ve metotlarını kullanarak da yapılabilir:

```python
import timeit

t = timeit.Timer('char in text', setup='text = "sample string"; char = "g"')
t.timeit()
0.049284196000371594
t.repeat()
[0.051710191000893246, 0.04452369999853545, 0.04527571799917496]

```

Sonraki örnekler çok satırlı ifadelerin zaman ölçümünün nasıl yapılacağını gösterir. Aşağıdaki örnekte,hasattr()vetry/except’in maliyeti, nesne özelliklerinin nasıl kaybedilip ortaya konduğunu test etmek için karşılaştırılmıştır:

```python
python -m timeit 'try:' ' str.__bool__' 'except AttributeError:' ' pass'
1000000 loops, best of 3: 0.99 usec per loop

python -m timeit 'if hasattr(str, "__bool__"): pass'
1000000 loops, best of 3: 0.476 usec per loop

python -m timeit 'try:' ' int.__bool__' 'except AttributeError:' ' pass'
1000000 loops, best of 3: 0.966 usec per loop

python -m timeit 'if hasattr(int, "__bool__"): pass'
1000000 loops, best of 3: 0.479 usec per loop

```

Python arayüzü için:

```python
import timeit

# özellik kayıp
s = """\
try:
 str.__bool__
except AttributeError:
 pass
"""

timeit.timeit(stmt=s, number=100000)
0.08558237599936547

s = "if hasattr(str, '__bool__'): pass"
timeit.timeit(stmt=s, number=100000)
0.0541383109994058

# özellik mevcut
s = """\
try:
 int.__bool__
except AttributeError:
 pass
"""

timeit.timeit(stmt=s, number=100000)
0.011753970000427216

s = "if hasattr(int, '__bool__'): pass"
timeit.timeit(stmt=s, number=100000)
0.016129147999890847

```

timeit()’i tanımladığınız fonksiyonda kullanmak için önemli bir ifade içeren bir setup parametresi geçirebilirsiniz:

```python
def test():
 """Test fonksiyonu"""
 L = [i for i in range(100)]

if __name__ == '__main__':
 import timeit
 print(timeit.timeit("test()", setup="from __main__ import test"))
 4.163065000997449

```

Bir diğer seçenek şimdiki global ad alanı içerisinde çalıştırılacakglobals()’i genel alan parametrelerine geçirmektir. Bu bireysel olarak içe aktarmaları belirtmeye göre daha kolaydır:

```python
def f(x):
 return x**2

def g(x):
 return x**4

def h(x):
 return x**8

import timeit
print(timeit.timeit('[func(42) for func in (f,g,h)]', globals=globals()))
1.632076413003233

```

timeit’i kullanarak benzer işlemleri yapan kodlardan hangisinin daha performanslı olduğunu görebilirsiniz:

```python
python -m timeit '"a" + "b"'
100000000 loops, best of 3: 0.0183 usec per loop

python -m timeit '"{}.{}".format("a", "b")'
1000000 loops, best of 3: 0.215 usec per loop

python -m timeit '"%s%s" %("a", "b")'
10000000 loops, best of 3: 0.117 usec per loop

python -m timeit '"".join(("a", "b"))'
10000000 loops, best of 3: 0.109 usec per loop

```

Python arayüzü için:

```python
import timeit

timeit.timeit('"a" + "b"', number=1000000)
0.018340642998737167

timeit.timeit('"{}{}".format("a", "b")', number=1000000)
0.3770097929991607

timeit.timeit('"%s%s" %("a", "b")', number=1000000)
0.2078534940010286

timeit.timeit('"".join(("a", "b"))', number=1000000)
0.1585119779992965

```

### sys Modülü

Tıpkıosmodülü gibi,sysde Python programlama dilindeki önemli
standart kütüphane modüllerinden biridir. Bu modül, kullandığınız Python sürümü
ile ilgili bilgi edinmenizi ve kullandığınız Python sürümü ile çeşitli işlemler
yapabilmenizi sağlar.

Bütün modüllerde olduğu gibi, bu modülü de şu komutla içe aktarıyoruz:

```python
>>> import sys

```

Bu modülün içinde hangi nitelik ve fonksiyonların olduğunu görmek için şu
komutu kullanabileceğinizi biliyorsunuz:

```python
>>> dir(sys)

```

Gördüğünüz gibi bu modül içinde de epeyce fonksiyon ve nitelik var. Biz bu
bölümde,sysmodülünün en yaygın kullanılan, en önemli fonksiyon ve
niteliklerini ele alacağız.

İlk olarakexit()fonksiyonu ile başlayalım…

#### sys.exit()

sysmodülününexit()fonksiyonunu kullanarak, programınızın işleyişini
durdurabilir, programınızı kapanmaya zorlayabilirsiniz. Basit bir örnek
verelim:

```python
import sys

sayı = input('Bir sayı girin: ')

if int(sayı) < 0:
 print('çıkılıyor...')
 sys.exit()

else:
 print(sayı)

```

Eğer kullanıcı 0’dan küçük bir sayı girerse programımızsys.exit()komutunun
etkisiyle çalışmayı durdurup kapanacaktır.

#### sys.argv

sysmodülününargvniteliği, yazdığımız program çalıştırılırken
kullanılan parametreleri bir liste halinde tutar.

Gelin isterseniz bunun ne demek olduğunu bir örnek üzerinde gösterelim.

Şimdi mesela masaüstündedeneme.pyadlı bir dosya oluşturun ve içine şunları
yazın:

```python
import sys
print(sys.argv)

```

Bu programı şu komutla çalıştırın:

```python
python deneme.py

```

Programı çalıştırdığınızda şuna benzer bir çıktı alacaksınız:

```python
['deneme.py']

```

Gördüğünüz gibi,sys.argvkomutu bize bir liste veriyor. Bu listenin ilk
öğesi, yazdığımız programın adı. Yanideneme.py.

Şimdi aynı programı bir de şu şekilde çalıştıralım:

```python
python deneme.py parametre

```

Bu defa programımız bize şu çıktıyı verecek:

```python
['deneme.py', 'parametre']

```

Gördüğünüz gibi,sys.argvkomutu, programın ismi ile birlikte, bu programa
parametre olarak verilen değerleri de bir liste halinde saklıyor. Bu oldukça
önemli ve kullanışlı bir özelliktir. Bu özellikten pek çok farklı şekillerde
yararlanabilirsiniz.

Mesela:

```python
import sys

def çık():
 print('Çıkılıyor...')
 sys.exit()

if len(sys.argv) < 2:
 print('Gerekli parametreleri girmediniz!')
 çık()

elif len(sys.argv) > 2:
 print('Çok fazla parametre girdiniz!')
 çık()

elif sys.argv[1] in ['-v', '-V']:
 print('Program sürümü: 0.8')

else:
 mesaj = 'Girdiğiniz parametre ({}) anlaşılamadı!'
 print(mesaj.format(sys.argv[1]))
 çık()

```

Burada öncelikle modülümüzü içe aktardık:

```python
import sys

```

Bunu yapmadan, o modülü kullanamayacağımızı biliyorsunuz.

Ardındançık()adlı bir fonksiyon tanımladık:

```python
def çık():
 print('Çıkılıyor...')
 sys.exit()

```

Programı sonlandırmak istediğimizde bu fonksiyonu kullanacağız.

Daha sonra şöyle birifbloğu oluşturduk:

```python
if len(sys.argv) < 2:
 print('Gerekli parametreleri girmediniz!')
 çık()

```

Eğersys.argvlistesinin uzunluğu 2’den düşükse, programımız herhangi bir
parametre olmadan, yalnızca ismiyle çalıştırılmış demektir. Bu durumda
kullanıcıya ‘Gerekli parametreleri girmediniz!’ mesajını gösterip programı
sonlandırıyoruz.

Sonraki kod bloğumuz şöyle:

```python
elif len(sys.argv) > 2:
 print('Çok fazla parametre girdiniz!')
 çık()

```

Eğersys.argvlistesi 2’den büyükse, programımız birden fazla parametre ile
çalıştırılmış demektir. Bu durumda kullanıcıya ‘Çok fazla parametre girdiniz!’
mesajını gösterip yine programı sonlandırıyoruz.

Bir sonraki kodlarımız şöyle:

```python
elif sys.argv[1] in ['-v', '-V']:
 print('Program sürümü: 0.8')

```

Eğersys.argvlistesinin ikinci öğesi-vveya-Vise programımızın
sürüm bilgisini veriyoruz.

Son olarak da şu bloğu yazıyoruz:

```python
else:
 mesaj = 'Girdiğiniz parametre ({}) anlaşılamadı!'
 print(mesaj.format(sys.argv[1]))
 çık()

```

Kullanıcının-vveya-Vdışında bir parametre girmesi durumunda ise, girilen
parametrenin anlaşılamadığı konusunda kullanıcıyı bilgilendirip programdan
çıkıyoruz.

Aşağıda, programımızın hangi komutlara hangi karşılıkları verdiğini
görüyorsunuz:

```python
C:\Users\fozgul\Belgelerim> python deneme.py
Gerekli parametreleri girmediniz!
Çıkılıyor...

C:\Users\fozgul\Belgelerim> python deneme.py -a
Girdiğiniz parametre (-a) anlaşılamadı!
Çıkılıyor...

C:\Users\fozgul\Belgelerim> python deneme.py -a -b
Çok fazla parametre girdiniz!
Çıkılıyor...

C:\Users\fozgul\Belgelerim> python deneme.py -v
Program sürümü: 0.8

C:\Users\fozgul\Belgelerim> python deneme.py -V
Program sürümü: 0.8

```

#### sys.executable

Eğer, yazdığınız bir programda, programınızın çalıştığı sistemdeki Python’ın
çalıştırılabilir dosyasının adını ve yolunu öğrenmeniz gerekirse bu niteliği
kullanabilirsiniz:

```python
>>> sys.executable

C:\Python37python.exe
```

#### sys.getwindowsversion()

Bu fonksiyon, kullanılan Windows sürümüne ilişkin bilgi verir:

```python
>>> sys.getwindowsversion()

sys.getwindowsversion(major=5, minor=1, build=2600,
platform=2, service_pack='Service Pack 3')

```

> **Uyarı**
> Bu fonksiyon yalnızca Windows’ta çalışır. GNU/Linux’ta bu fonksiyon
tanımlı değildir.

Uyarı

Bu fonksiyon yalnızca Windows’ta çalışır. GNU/Linux’ta bu fonksiyon
tanımlı değildir.

Bu fonksiyon kendi içinde de bazı nitelikler barındırır. Bunları görmek için şu
komutu kullanabilirsiniz:

```python
>>> ver = sys.getwindowsversion()
>>> dir(ver)

['__add__', '__class__', '__contains__', '__delattr__',
 '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
 '__getattribute__', '__getitem__', '__getnewargs__',
 '__gt__', '__hash__', '__init__', '__iter__', '__le__',
 '__len__', '__lt__', '__mul__', '__ne__', '__new__',
 '__reduce__', '__reduce_ex__', '__repr__', '__rmul__',
 '__setattr__', '__sizeof__', '__str__', '__subclasshook__',
 'build', 'count', 'index', 'major', 'minor', 'n_fields',
 'n_sequence_fields', 'n_unnamed_fields', 'platform',
 'product_type', 'service_pack', 'service_pack_major',
 'service_pack_minor', 'suite_mask']

```

Bu niteliklere erişmek için şu söz dizimini kullanabilirsiniz:

```python
>>> ver.service_pack()

```

#### sys.path

Modüllerkonusunu işlerkensysmodülününpathniteliğinden söz
etmiştik. O yüzden orada söylediklerimizi tekrarlamayacağız.

#### sys.platform

osmodülünü incelerken öğrendiğimiznameniteliği gibi,sysmodülününplatformadlı niteliği de, kodlarımızın çalıştığı işletim sistemi hakkında
bize bilgi verir:

```python
>>> sys.platform

```

Eğer bu komutu GNU/Linux’ta verirseklinuxçıktısı, Windows’ta verirsekwin32çıktısı, Mac OS X’te verirsekdarvinçıktısı alırız.

#### sys.prefix

sysmodülününprefixniteliği Python’ın hangi dizine kurulduğunu
gösterir:

```python
>>> sys.prefix

'/home/local/python'

```

Veya:

```python
>>> sys.prefix

'C:\\Python'

```

#### sys.ps1

sysmodülününps1niteliği, etkileşimli kabuktaki ‘>>>’ işaretini tutar:

```python
>>> sys.ps1

'>>> '

```

Eğer isterseniz bu işareti değiştirebilirsiniz:

```python
>>> sys.ps1 = '+++ '

```

Bu komutu verdikten sonra ‘>>>’ işaretinin ‘+++’ olarak değiştiğini
göreceksiniz.

#### sys.ps2

Etkileşimli kabukta Python bizden girdiğimiz kodların devamını beklediğini
göstermek için ‘…’ işaretini kullanır:

```python
>>> a = 5
>>> if a == 5:
...

```

sysmodülününps2niteliği, işte etkileşimli kabuktaki devam satırlarında
gördüğümüz bu ‘…’ işaretini tutar:

```python
>>> sys.ps2

'... '

```

Eğer isterseniz bu işareti değiştirebilirsiniz:

```python
>>> sys.ps1 = '--- '

```

Bu komutu verdikten sonra ‘…’ işaretinin ‘—’ olarak değiştiğini
göreceksiniz.

#### sys.version

sysmodülününversionniteliği kullandığınız Python sürümüne ilişkin
ayrıntılı bilgi verir:

```python
>>> sys.version

'3.7.0 (default, 19.08.2024, 12:24:55)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux'
```

#### sys.version_info

sysmodülününversion_infoniteliği de kullandığınız Python sürümüne
ilişkin bilgi verir:

```python
>>> sys.version_info

sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel='final', serial=0)
```

Bu nitelik kendi içinde birtakım başka nitelikler de barındırır:

```python
>>> dir(sys.version_info)

['count', 'index', 'major', 'micro', 'minor',
 'n_fields', 'n_sequence_fields', 'n_unnamed_fields',
 'releaselevel', 'serial']

```

Bu niteliklere nasıl ulaşacağınızı biliyorsunuz:

```python
>>> sys.version_info.major #büyük sürüm numarası
>>> sys.version_info.minor #küçük sürüm numarası
>>> sys.version_info.micro #minik sürüm numarası

```

#### sys.winver

sysmodülününwinverniteliği Python’ın büyük sürüm numarasıyla küçük
sürüm numarasını verir:

```python
>>> sys.winver

3.7
```

> **Uyarı**
> Bu nitelik yalnızca Windows’ta çalışır; GNU/Linux’ta tanımlı
değildir.

Uyarı

Bu nitelik yalnızca Windows’ta çalışır; GNU/Linux’ta tanımlı
değildir.

#### sys.stdout

Önceki derslerimizden de bildiğiniz gibistdout, ‘standart çıktı konumu’, yani
programlarımızın çıktılarını standart olarak verdikleri konum anlamına geliyor.

Python’da yazdığımız programlar çıktılarını standart olarak komut satırına
verir. Yani mesela:

```python
>>> print('merhaba zalim dünya')

```

komutunu verdiğimizde, bu komutun çıktısı komut ekranında görünecektir.

Python’da standart çıktı konumununun neresi olacağı bilgisisysmodülününstdoutadlı niteliği içinde tutulur:

```python
>>> import sys
>>> sys.stdout

<_io.TextIOWrapper name='<stdout>' mode='w' encoding='cp1254'>

```

Standart çıktı konumuna yazmanın en yaygın yolununprint()komutunu
kullanmak olduğunu biliyoruz. Bu komut, standart çıktı konumu neresi ise oraya
yazacaktır.

Standart çıktı konumuma yazmanın başka bir yolu da doğrudansys.stdoutniteliğininwrite()metodunu kullanmaktır.

Dikkatlice bakın:

```python
>>> sys.stdout.write('merhaba zalim dünya')

```

print()komutundan farklı olaraksys.stdout.write()fonksiyonu şöyle bir
çıktı verir:

```python
merhaba zalim dünya19

```

Burada, çıktının sonundaki19sayısı ‘merhaba zalim dünya’ karakter dizisinin
uzunluğunu gösteriyor.sys.stdout.write()fonksiyonu etkileşimli kabukta
kullanıldığında böyle bir çıktı verir. Ama eğer bu kodları bir dosyaya yazıp
çalıştırırsanız sonraki19sayısı görünmez.

Bu arada, her ne kadarprint()vesys.stdout.write()birbirine benzese
de aralarında önemli farklar bulunur. Örneğinprint()fonksiyonu parametre
olarak her türlü veri tipini alabilir. Ancaksys.stdout.write()fonksiyonu
parametre olarak yalnızca karakter dizisi alabilir:

```python
>>> sys.stdout.write(12)

Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: must be str, not int

```

Dolayısıylasys.stdout.write()fonksiyonuna parametre olarak vereceğiniz
değeri öncelikle karakter dizisine çevirmeniz gerekir:

```python
>>> sys.stdout.write(str(12))

122

```

> **Not**
> Sondaki2sayısının ‘12’ karakter dizisinin uzunluğunu gösterdiğini
söylemiştik. Bu kodları dosyaya yazıp çalıştırdığınızda yalnızca12çıktısı alırsınız.

Not

Sondaki2sayısının ‘12’ karakter dizisinin uzunluğunu gösterdiğini
söylemiştik. Bu kodları dosyaya yazıp çalıştırdığınızda yalnızca12çıktısı alırsınız.

print()ilesys.stdout.write()arasındaki önemli bir fark da,print()fonksiyonu yazma işleminden sonra bir sonraki satıra geçerken,sys.stdout.write()fonksiyonunun geçmemesidir.

> **Uyarı**
> sys.stdout.write()fonksiyonu etkileşimli kabuktan
çalıştırıldığında ve dosyadan çalıştırıldığında birbirinden farklı çıktılar
verir. O yüzden aşağıdaki örnekleri dosyaya yazıp çalıştırmanızı tavsiye
ederim.

Uyarı

sys.stdout.write()fonksiyonu etkileşimli kabuktan
çalıştırıldığında ve dosyadan çalıştırıldığında birbirinden farklı çıktılar
verir. O yüzden aşağıdaki örnekleri dosyaya yazıp çalıştırmanızı tavsiye
ederim.

Mesela şu örneğe bakalım:

```python
for i in 'istihza':
 print(i)

```

Bu komut şu çıktıyı verir:

```python
i
s
t
i
h
z
a

```

Gördüğünüz gibi,print()fonksiyonu, döngüye giren her öğeyi yeni satıra
basıyor.

Bir desys.stdout.write()fonksiyonunun ne yaptığına bakalım:

```python
import sys

for i in 'istihza':
 sys.stdout.write(i)

```

Bu komutlar ise şu çıktıyı verir:

```python
istihza

```

Gördüğünüz gibi,sys.stdout.write()fonksiyonu öğelerin hepsini aynı satıra
bastı. Eğer öğelerin ayrı satırlara basılmasını istiyorsanız bunu açıkça
belirtmelisiniz:

```python
import sys

for i in 'istihza':
 sys.stdout.write(i+'\n')

```

sys.stdout.write()fonksiyonunun otomatik olarak satır başı karakterini
basmıyor oluşunu kullanarak kronometre benzeri bir program yazabilirsiniz:

```python
import sys

sayaç = 0

while True:
 sys.stdout.write(str(sayaç)+'\r')
 sayaç += 1

```

Burada, önceki derslerimizde öğrendiğimiz kaçış dizilerinden\r’yi
kullanarak, her öğenin ekrana basılmasının ardından satırın en başına
dönülmesini sağladık. Böylece öğeler yan yana değil de birbirlerinin üstüne
basılmış oldu.

Bu arada, eğer yukarıdaki kodlar herhangi bir çıktı vermeden bekliyorsa, kodları
şu şekilde yazın:

```python
import sys

sayaç = 0

while True:
 sys.stdout.write(str(sayaç)+'\r')
 sys.stdout.flush()
 sayaç += 1

```

Burada eklediğimizsys.stdout.flush()satırı, Python’ın tamponda beklettiği
verileri çıktıya göndermesini sağlar. Siz bu ‘flush’ kavramınıprint()fonksiyonundan hatırlıyor olmalısınız (print()fonksiyonununflushparametresi).

Hatırlarsanız, ‘flush’ kavramının yanısıra,print()fonksiyonunu işlerken
öğrendiğimiz bir başka kavram da standart çıktı konumunun değiştirilmesi idi.print()fonksiyonuna verdiğimizfileparametresi yardımıyla
programlarımızın standart olarak çıktı verdiği konumu değiştirebiliyorduk:

```python
f = open('çıktılar.txt', 'w')
print('merhaba zalim dünya', file=f)

```

Buradaçıktılar.txtadlı bir dosya oluşturduk ve bunuprint()fonksiyonununfileparametresine atayarak, çıktıları komut satırı yerineçıktılar.txtadlı dosyaya gönderdik.

Aynı işlemisys.stdoutaracılığıyla da yapabileceğimizi biliyorsunuz:

```python
import sys

f = open('çıktılar.txt', 'w'):
sys.stdout = f
sys.stdout.write('merhaba zalim dünya')

```

Gerçi bu sizin bilmediğiniz bir şey değil. Zira siz bunuprint() Fonksiyonukonusunu işlerken de görmüştünüz…

#### sys.stderr

Önceki bölümde gördüğümüz şu kodları tekrar önümüze alalım:

```python
import sys

f = open('çıktılar.txt', 'w')
sys.stdout = f
sys.stdout.write('merhaba zalim dünya')

```

Bu kodlar, bildiğiniz gibi, çıktı olarak verilmek istenen değerlerinçıktılar.txtadlı bir dosyaya yönlendirilmesini sağlıyor. Ancak kodlarımızı bu
şekilde yazdığımızda sadece normal değerler yönlendirilecektir. Mesela çalışma
esnasında ortaya çıkan hatalar yine komut ekranına basılmaya devam edecektir:

```python
import sys

f = open('çıktılar.txt', 'w')
sys.stdout = f
sys.stdout.write(1/0)

```

Bu kodları çalıştırdığınızda, standart çıktı konumu yönlendirilmiş olmasına
rağmen, hata mesajı komut satırına basılacaktır:

```python
Traceback (most recent call last):
 File "deneme.py", line 5, in <module>
 sys.stdout.write(1/0)
ZeroDivisionError: division by zero

```

Çünkü Python’da hata mesajlarının öntanımlı olarak basıldığı yer komut
satırıdır. Nasıl çıktıların standart olarak basıldığı yeri teknik olarak
‘standart çıktı konumu’ (Standard Output - stdout) olarak adlandırıyorsak,
hataların standart olarak basıldığı yeri de teknik olarak ‘standart hata
konumu’ (Standard Error - stderr) olarak adlandırıyoruz.

Tıpkıstdout’u manipüle edebildiğimiz gibi,stderr’i de manipüle
edebiliriz:

```python
import sys

f =open('hatalar.txt', 'w')
sys.stderr = f
sys.stderr.write(1/0)

```

Bu durumda, programımızın işleyişi sırasında ortaya çıkan hatalarhatalar.txtadlı bir dosyaya yönlendirilecektir.

Bu bilgiyi kullanarak şöyle bir kod da yazabiliriz:

```python
import sys

çıktılar = open('çıktılar.txt', 'w')
hatalar = open('hatalar.txt', 'w')
sys.stdout = çıktılar
sys.stderr = hatalar

print('normal çıktı')
print('hata mesajı: ', 1/0)

```

Bu kodları çalıştırdığınızda, hata mesajı üretmeden başarıyla tamamlanan
çıktılarınçıktılar.txtadlı dosyaya, hata mesajlarının isehatalar.txtadlı
dosyaya yönlendirildiğini göreceksiniz.

#### sys.stdin

Python’da üç adet standart konum bulunur:
1. Standart çıktı konumu -stdout
1. Standart hata konumu -stderr
1. Standart girdi konumu -stdin

Standart çıktı konumu -stdout

Standart hata konumu -stderr

Standart girdi konumu -stdin

İlk ikisini zaten görmüştük. Üçüncüsünü de şimdi ele alacağız.

Bildiğiniz gibi Python’da kullanıcıdan veri almak içininput()fonksiyonunu
kullanıyoruz:

```python
sayı = input('Lütfen bir sayı girin: ')

```

Bu fonksiyonun görevi, standart girdi konumuna girilen verileri okumaktır.
Python’daki standart girdi konumu (genellikle) komut satırı olduğu için,input()fonksiyonu verileri komut satırından okur.

Python’da standart girdi konumunu tutan değişkensys.stdin’dir. Dolayısıyla
eğer isterseniz, verileri kullanıcıdaninput()fonksiyonu yerine doğrudansys.stdinniteliği aracılığıyla da alabilirsiniz:

```python
>>> import sys
>>> sys.stdin.read()

```

Bu komutları verdiğinizde, komut satırı sizden veri almaya hazır hale gelir. Bu
şekilde istediğiniz kadar veriyi komut satırına girebilirsiniz. Veri girişini
durdurmak istediğinizde ise Windows’taCTRL+C, GNU/Linux’ta iseCTRL+Dtuşlarına basmanız gerekir. Bu şekilde komut satırını terkettiğinizde, girmiş
olduğunuz değerler bir karakter dizisi olarak ekrana basılacaktır.

sys.stdinniteliği, bize veri okumak için üç farklı fonksiyon sunar:
1. sys.stdin.read()
1. sys.stdin.readline()
1. sys.stdin.readlines()

sys.stdin.read()

sys.stdin.readline()

sys.stdin.readlines()

read()fonksiyonu birden fazla satır içeren verilerin girilmesine müsaade
eder ve çıktı olarak bir karakter dizisi verir:

```python
>>> sys.stdin.read()
(Girdi)
Fırat
Özgül
Adana
(Çıktı)
'Fırat\nÖzgül\nAdana\n'

```

readline()fonksiyonu tek bir satır içeren verilerin girilmesine müsaade
eder ve çıktı olarak bir karakter dizisi verir:

```python
>>> sys.stdin.readline()
(Girdi)
Fırat
(Çıktı)
'Fırat\n'

```

readlines()fonksiyonu birden fazla satır içeren verilerin girilmesine
müsaade eder ve çıktı olarak bir liste verir:

```python
>>> sys.stdin.readlines()
(Girdi)
Fırat
Özgül
Adana
(Çıktı)
['Fırat\n', 'Özgül\n', 'Adana\n']

```

Gelin istersenizsys.stdinniteliğinin nasıl kullanılabileceğine ilişkin
birkaç örnek verelim:

```python
import sys

with open('kayıtlar.txt', 'w') as kayıtlar:
 while True:
 satırlar = sys.stdin.readline()
 if satırlar.strip() == ':q':
 break
 else:
 kayıtlar.write(satırlar)

```

Buradakayıtlar.txtadlı bir dosya oluşturduk öncelikle. Daha sonra dareadline()fonksiyonu aracılığıyla kullanıcıdan aldığımız bütün verileri bu
dosyaya yazdık. Kullanıcının programdan çıkabilmesini sağlamak için de ‘:q’ tuş
kombinasyonunu ayarladık. Böylece komut satırından çalışan basit bir metin
düzenleyici yazmış olduk!

Tıpkısys.stdoutvesys.stderrkonumlarını değiştirdiğimiz gibi,sys.stdinkonumunu da değiştirebiliriz. Böylece verileri komut satırı
aracılığıyla değil, mesela bir dosya aracılığıyla alabiliriz.

Aşağıdaki örneği dikkatlice inceleyin:

```python
import sys

f = open('oku.txt')

sys.stdin = f

while True:
 satırlar = sys.stdin.readline()
 if satırlar.strip() == ':q':
 break
 else:
 sys.stdout.write(satırlar)

```

Bu kodları yazdıktan sonra, bu kodların bulunduğu dizindeoku.txtadlı bir
dosya oluşturun. Ardından programınızı çalıştırın. Programınız şu anda sizden
veri girmenizi bekliyor. Verilerioku.txtadlı dosyaya gireceksiniz.

oku.txtadlı dosyayı açıp bir şeyler yazın. Veri girerken dosyayı her
kaydedişinizde dosya içindeki verilerin komut satırına düştüğünü göreceksiniz.
Veri girişini tamamladıktan sonra dosyanın en son satırına ‘:q’ yazıp dosyayı
kaydettiğiniz anda da programınız kapanacaktır.

### argparse Modülü

#### Giriş

Yazdığımız her uygulama grafik arayüzüne sahip olmaz. Bazı uygulamalar komut satırına daha uygundur ve bu uygulamalar bazı parametrelere ihtiyaç duyar. argparse modülü kullanıcıdan aldığımız parametreler için yardım mesajları, nasıl kullanıldığına yönelik mesajları üretir. Ayrıca bu modül kullanıcı geçersiz parametre girerse uygun hata mesajını bastırır.

##### Ayrıştırıcı Oluşturmak

İlk olarak modülümüzü dahil etmemiz gerekiyor. Modülümüzü dahil ettikten sonra ayrıştırıcımız için nesne oluşturuyoruz.:

```python
import argparse

```

ArdındanArgumentParserüzerinden yeni bir nesne oluşturuyoruz.:

```python
ayristirici = argparse.ArgumentParser(description='Bu uygulama bazı işler yapıyor.')

```

Artık argümanlar ekleyebiliriz.

##### Argüman Eklemek

ArgumentParsernesnesine gerekli tüm bilgileri verdikten sonra,add_argument()fonksiyonu ile argümanları ekleyebiliriz.

Örnek:

```python
ayristirici.add_argument('-i', '--ilk_arguman', nargs='+', required=False, help="Bu ilk argümandır")
ayristirici.add_argument('-a', '--ikinci_arguman', required=False, help="Bu ikinci argümandır")

```

İki argümanımızı eklemiş olduk. Şimdiayristirici.print_help()ile çıktımızı bastıralım ve inceleyelim.

Not: Normal şartlarda argparse modülü komut satırı için uygundur ancak etkileşimli kabukta çalışırken sonuçları
görmek için argparse modülünün print_help() fonksiyonunu kullanacağız.

##### Argüman Ayrıştırmak

ArgumentParsernesnesiparse_args()fonksiyonu yardımıyla argümanları ayrıştırmamıza sağlar.
Etkileşimli kabuğumuza:

```python
ayristirici.parse_args(['-a', '7'])

```

yazalım ve çıktımızı inceleyelim.

Çıktımız:

```python
Namespace(ikinci_arguman='7')

```

parse_argsfonksionuna biz ‘-a’ parametresine vermemize rağmen ayrıştırıcımız bize argümanin ikinci ismini ve ona atadığımız değeri -7- verdi.

#### ArgumentParser Nesnesi

Temel olarakArgumentParsernesnemizin yapısı:

```python
class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True)

```

Yeni birArgumentParsernesnesi oluşturulduğunda alacağı tüm argümanlar anahtar kelime -keyword- olarak iletilmeli.

##### Argümanlar ve Açıklamaları
- prog: Uygulamanın adı (varsayılan: sys.argv[0])
- usage: Uygulamanın kullanım amacını açıklayan bir metin. (varsayılan: Uygulamaya eklenen parametrelerden oluşur)
- description: Argüman yardımından önce ekrana çıkar açıklama metni (varsayılan:None)
- epilog: Argüman yardımından sonra ekrana çıkan açıklama metni (varsayılan:None)
- parents: Farklı bir ArgumentParser nesnesinin sahip olduğu argümanları dahil eder.
- formatter_class: Yardım çıktılarını kişiselleştirir.
- prefix_chars: İsteğe bağlı argümanların önüne konulan karakteri ayarlar. (varsayılan:-)
- fromfile_prefix_chars: Ek argümanların okunması gereken dosyayı önekleyen karakter kümesi. (varsayılan:None)
- argument_default: Argümanlar için global değer. (varsayılan:None)
- conflict_handler: Çakışan argümanlar için çözüm stratejisi. (genellikle gereksiz)
- add_help: -h / –help seçeneğini ayrıştırıcıya ekler. (varsayılan:True)
- allow_abbrev: Kısaltmalar net değilse uzun seçeneklerin kısaltılmasını sağlar. (Varsayılan:None)

prog: Uygulamanın adı (varsayılan: sys.argv[0])

usage: Uygulamanın kullanım amacını açıklayan bir metin. (varsayılan: Uygulamaya eklenen parametrelerden oluşur)

description: Argüman yardımından önce ekrana çıkar açıklama metni (varsayılan:None)

epilog: Argüman yardımından sonra ekrana çıkan açıklama metni (varsayılan:None)

parents: Farklı bir ArgumentParser nesnesinin sahip olduğu argümanları dahil eder.

formatter_class: Yardım çıktılarını kişiselleştirir.

prefix_chars: İsteğe bağlı argümanların önüne konulan karakteri ayarlar. (varsayılan:-)

fromfile_prefix_chars: Ek argümanların okunması gereken dosyayı önekleyen karakter kümesi. (varsayılan:None)

argument_default: Argümanlar için global değer. (varsayılan:None)

conflict_handler: Çakışan argümanlar için çözüm stratejisi. (genellikle gereksiz)

add_help: -h / –help seçeneğini ayrıştırıcıya ekler. (varsayılan:True)

allow_abbrev: Kısaltmalar net değilse uzun seçeneklerin kısaltılmasını sağlar. (Varsayılan:None)

###### prog argümanı

ArgumentParsernesnesi varsayılan olaraksys.argv[0]çıktısını uygulama ismi olarak kullanır. Bu genellikle tercih edilen bir yöntemdir çünkü çoğu zaman uygulama ismi ile dosya ismi aynı olur.

ilkuygulama.pyisimli bir dosya oluşturalım ve içine kodlarımızı yazalım:

```python
import argparse
ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', help='foo yardım')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--foo FOO]

optional arguments:
-h, --help show this help message and exit
--foo FOO foo help

```

Gördüğümüz gibi uygulama ismimiz ekrana çıktı ancak biz uygulamamızın ismini farklı kullanmak istiyorsak? O zamanArgumentParsernesnesineprogparametresini uygulama ismini verelim:

```python
import argparse
ayristirici = argparse.ArgumentParser(prog='Bu benim ilk uygulamam')
ayristirici.add_argument('--foo', help='foo yardım')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: Bu benim ilk uygulamam [-h] [--foo FOO]

optional arguments:
-h, --help show this help message and exit
--foo FOO foo yardım

```

Uygulamamızın ismi değişti.

###### usage argümanı

Yazdığımız uygulamaya kullanıcı için küçük bir açıklama eklemek isteyebiliriz. Bu işlem içinusageargümanı bize yetişiyor.

Hemen kodumuzu deneyelim.:

```python
import argparse
ayristirici = argparse.ArgumentParser(usage='Bu uygulama şimdilik tek parametre alıyor. ')
ayristirici.add_argument('--parametre', help='parametre yardım')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: Bu uygulama şimdilik tek parametre alıyor.
optional arguments:
-h, --help show this help message and exit
--parametre PARAMETRE
 parametre yardım

```

Eğer bizusageparametresini kullanmasaydık o zaman uygulamamız varsayılan olarak tüm parametrelerin sıralı halini kullanacaktı.:

```python
usage: ilkprogram.py [-h] [--parametre PARAMETRE]
optional arguments:
-h, --help show this help message and exit
--parametre PARAMETRE
 parametre yardım

```

###### description argümanı

descriptionargümanı ile uygulamamız için kısa bilgi ve nasıl çalıştığı hakkında açıklama sunar.
Yardım mesajı ve parametreler arasında açıklama sunar.

Kodumuzu yazalım:

```python
import argparse
ayristirici = argparse.ArgumentParser(description='Uygulama hakkında açıklama metni')
ayristirici.add_argument('--parametre', help='parametre yardım')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--parametre PARAMETRE]

Uygulama hakkında açıklama metni

optional arguments:
-h, --help show this help message and exit
--parametre PARAMETRE
 parametre yardım

```

Varsayılan olarak çıktımız belli bir alana sığdırılır ancak bunu değiştirmek isterseniz `formatter_class` argümanı kullanılır.

###### epilog argümanı

Yazdığımız bazı uygulamalar daha fazla açıklamaya ihtiyaç duyabilir. Bunun içinepilogparametresini kullanırız.

Örnek:

```python
import argparse
ayristirici = argparse.ArgumentParser(epilog='Uygulama hakkında ikinci açıklama')
ayristirici.add_argument('--parametre', help='parametre yardım')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--parametre PARAMETRE]

optional arguments:
-h, --help show this help message and exit
--parametre PARAMETRE
 parametre yardım

Uygulama hakkında ikinci açıklama

```

Varsayılan olarak çıktımız belli bir alana sığdırılır ancak bunu değiştirmek isterseniz `formatter_class` argümanı kullanılır.

###### parents argümanı

Bazı durumlarda, argüman ayrıştırıcılar ortak argüman kümesini paylaşabilir. Argüman tanımlarını tekrarlamak yerine ortak argümanları bir kere tanımlayarak tanımlayıpparentsargümanı ile farklı ayrıştırıcılarda kullanabiliriz.parentsargümanıArgumentParsernesnesi alır.
Python dosyamızı açalım ve bu kodu yazalım:

```python
import argparse
ana_ayristirici = argparse.ArgumentParser(add_help=False)
ana_ayristirici.add_argument('--ilk_arguman')
ana_ayristirici.add_argument('--ikinci_arguman')

ikinci_ayristirici = argparse.ArgumentParser(parents=[ana_ayristirici])
ikinci_ayristirici.add_argument('ucuncu_arguman')
print(ikinci_ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--ilk_arguman ILK_ARGUMAN]
 [--ikinci_arguman IKINCI_ARGUMAN]
 ucuncu_arguman
positional arguments:
ucuncu_arguman

optional arguments:
 -h, --help show this help message and exit
 --ilk_arguman ILK_ARGUMAN
 --ikinci_arguman IKINCI_ARGUMAN

```

parentsargümanı ileana_ayristiricimızın argümanlarınıikinci_ayristirimizda kullanmış olduk.

NOT: Ana ayrıştırıcımıza `add_help=False` eklememiz gerekir çünkü her iki ayrıştırıcımız `-h/–help` argümanına sahip olur ve bu çakışma sebebiyle uygulamamız `raise` hatası verir.

add_helpargümanını kaldırıp kodumuzu çalıştıralım:

```python
Traceback (most recent call last):
 File "ilkprogram.py", line 7, in <module>
 ikinci_ayristirici = argparse.ArgumentParser(parents=[ana_ayristirici])
 File "/usr/lib/python3.7/argparse.py", line 1681, in __init__
 self._add_container_actions(parent)
 File "/usr/lib/python3.7/argparse.py", line 1450, in _add_container_actions
 group_map.get(action, self)._add_action(action)
 File "/usr/lib/python3.7/argparse.py", line 1580, in _add_action
 action = super(_ArgumentGroup, self)._add_action(action)
 File "/usr/lib/python3.7/argparse.py", line 1390, in _add_action
 self._check_conflict(action)
 File "/usr/lib/python3.7/argparse.py", line 1529, in _check_conflict
 conflict_handler(action, confl_optionals)
 File "/usr/lib/python3.7/argparse.py", line 1538, in _handle_conflict_error
 raise ArgumentError(action, message % conflict_string)
argparse.ArgumentError: argument -h/--help: conflicting option strings: -h, --help

```

###### formatter_class argümanı

ArgumentParsernesnesi alternatif bir biçimlendirme sınıfı tanımlayıp, yardım mesajlarını kişiselleştirilmesine izin verir.
Şimdilik dört sınıfa sahiptir.:

```python
class argparse.RawDescriptionHelpFormatter
class argparse.RawTextHelpFormatter
class argparse.ArgumentDefaultsHelpFormatter
class argparse.MetavarTypeHelpFormatter

```

RawDescriptionHelpFormatterveRawTextHelpFormattermetinsel açıklamaların nasıl görüneceği üzerinde daha fazla kontrol sağlar.
Varsayılan olarakArgumentParsernesnesidescriptionveepilogiçin satır kaydırma özelliğine sahiptir.

Kodumuzu deneyelim:

```python
import argparse

ayristirici = argparse.ArgumentParser(
 description='''Uzunca bir açıklama
 yazıyoruz ve alt satıra inelim.''',
 epilog='''
 Uygulama sonu açıklama
 metnimiz.''')
ayristirici.print_help()

```

Çıktımız:

```python
usage: ilkprogram.py [-h]

Uzunca bir açıklama yazıyoruz ve alt satıra inelim.

optional arguments:
 -h, --help show this help message and exit

Uygulama sonu açıklama metnimiz.

```

Görüldüğü üzere biz alt satıra inmiş olsak bile çıktımız aynı satırda görünüyor. Şimdi uygulamamızaformatter_classparametresineRawDescriptionHelpFormatterekleyelim.
Kodumuzu bu şekilde değiştirelim:

```python
import argparse
import textwrap

ayristirici = argparse.ArgumentParser(
 formatter_class=argparse.RawDescriptionHelpFormatter,
 epilog=textwrap.dedent('''\
 Uygulama sonu açıklama
 metnimiz. Burası ikinci satırımız.'''))
ayristirici.print_help()

```

Çıktımızı inceleyelim:

```python
usage: ilkprogram.py [-h]

optional arguments:
 -h, --help show this help message and exit

Uygulama sonu açıklama
metnimiz. Burası ikinci satırımız.

```

Görüldüğü üzere yazdığımız açıklama metni ikinci satıra geçti.

RawTextHelpFormatter maintains whitespace for all sorts of help text, including argument descriptions. However, multiple
new lines are replaced with one. If you wish to preserve multiple blank lines, add spaces between the newlines.

ArgumentDefaultsHelpFormattersınıfı ile argümanların varsayılan değerleri hakkında bilgi eklenebilir.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(
 formatter_class=argparse.ArgumentDefaultsHelpFormatter)
ayristirici.add_argument('--ilk_arguman', type=int, default=81, help='Bu argüman varsayılan değeri 81!')
ayristirici.add_argument('ikinci_argüman', default=[1, 2, 3], help='İkinci argüman yardim mesajı!')
ayristirici.print_help()

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--ilk_arguman ILK_ARGUMAN] ikinci_argüman

positional arguments:
 ikinci_argüman İkinci argüman yardim mesajı! (default: [1, 2, 3])

optional arguments:
 -h, --help show this help message and exit
 --ilk_arguman ILK_ARGUMAN
 Bu argüman varsayılan değeri 81! (default: 81)

```

Çıktımıza baktığımız zaman yardım mesajlarının yanında varsayılan olarak aldığı değerleri bize gösteriyor.

MetavarTypeHelpFormattersınıfı ile argümanın alacağı değerin tipini ekrana basılır.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(
 formatter_class=argparse.MetavarTypeHelpFormatter)
ayristirici.add_argument('--a', type=int)
ayristirici.add_argument('--ikinci_argüman', type=dict)
ayristirici.print_help()

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--a int] [--ikinci_argüman dict]

optional arguments:
 -h, --help show this help message and exit
 --a int
 --ikinci_argüman dict

```

Çıktımıza baktığımızda hangi argümanın alacağı değer tipi argümanın yanında görünür.

###### prefix_chars argümanı

Genellikle komut satırı uygulamalrında argümanlar-ön ekini alır. (Örnek :-f/–arguman) Ayrıştırıcımız bazı durumlarda farklı veya ek ön eklere ihtiyaç duyabilir.
Örneğin:+fveya/argumanArgumentParsernesnemizi oluştururkenprefix_charsargümanını kullanarak bu isteğimizi sağlarız.
Örnek Kod:

```python
import argparse

ayristirici = argparse.ArgumentParser(prefix_chars='-+')
ayristirici.add_argument('+f')
ayristirici.add_argument('++arguman')
ayristirici.print_help()

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [+f F] [++arguman ARGUMAN]

optional arguments:
 -h, --help show this help message and exit
 +f F
 ++arguman ARGUMAN

```

###### fromfile_prefix_chars argümanı

Bazı zamanlar örneğin uzun argüman listelerini içeren bir uygulama yazdığımız zaman, argümanları komut satırında yazmak yerine
bir dosya içerisinde tutmak daha mantıklı olur.ArgumentParsernesnesinefromfile_prefix_charsargümanı verildiği zaman
daha sonra belirtilen karakterlerden herhangi biriyle başlayan argümanlar dosya olarak kabul edilir ve içerdikleri argümanlar ile değiştirilir.
Kodumuzu yazalım:

```python
import argparse

with open('args.txt', 'w') as fp:
 fp.write('-i\nbar')
ayristirici = argparse.ArgumentParser(fromfile_prefix_chars='@')
ayristirici.add_argument('-i')
print(ayristirici.parse_args(['@args.txt']))

```

Kodumuzu satır satır inceleyelim.
- with open(…satırındaargs.txtdosyasınıwmodunda açıyoruz.
- fp.write…satırındaiargümanını ekliyoruz veiargümanınabarparametresini dosyamıza yazıyoruz.
- Üçüncü satırımızdaayristiricinesnemizi oluşturuyoruz.
- Ardındaniargümanını ekliyoruz.
- Bu satırdaparse_argskomutu ile argümanımızı ve alacağı değerini döndürüyoruz.

with open(…satırındaargs.txtdosyasınıwmodunda açıyoruz.

fp.write…satırındaiargümanını ekliyoruz veiargümanınabarparametresini dosyamıza yazıyoruz.

Üçüncü satırımızdaayristiricinesnemizi oluşturuyoruz.

Ardındaniargümanını ekliyoruz.

Bu satırdaparse_argskomutu ile argümanımızı ve alacağı değerini döndürüyoruz.

Bir dosyadan okunan argümanlar varsayılan
olarak her satırda bir tane olmalı ve komut satırındaki
orijinal dosya başvuru argümanı ile aynı yerdeymiş gibi ele alınmalıdır.
Bu nedenle örnekte, [‘@args.txt’] ifadesi [‘-i’, ‘bar’] ifadesine eşdeğer olarak kabul edilir.

###### argument_default argümanı

Genellikle, argüman varsayılanları, varsayılan olarakadd_argument()fonksiyonu veya belirli bir ad-değer çiftleri kümesiyleset_defaults()fonksiyonunun çağrılmasıyla belirlenir.
Ancak bazı durumlarda bağımsız değişkenler için tek bir ayrıştırıcıyı varsayılan olarak belirlemek yararlı olablir.
Örneğinparse_args()çağrıldığında, nitelik oluşturmayı global olarak bastırmak içinargument_default=SUPPRESS’i kullanırız.
Örnek Kod:

```python
import argparse

ayristirici = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
ayristirici.add_argument('--arguman')
ayristirici.add_argument('-ikinci_arguman')
print(ayristirici.parse_args(['--arguman', '1', '-ikinci_arguman', 'python']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(arguman='1', ikinci_arguman='python')
Namespace()

```

Çıktımıza baktığımız zamanparse_args()fonksiyonuna değer verildiğinde bize ad alanı (namespace) olarak argümanımızı ve aldığı değeri döndürüyor.
İlk ad alanımız istediğimiz gibi çıktıyı verdi ikincisi ise boş şimdiargument_default=argparse.SUPPRESS’i kaldıralım ve çıktıyı tekrar kontrol edelim.

Yeni Çıktımız:

```python
Namespace(arguman='1', ikinci_arguman='python')
Namespace(arguman=None, ikinci_arguman=None)

```

Görüldüğü üzere ikinci çıktımız bu sefer argümanın isimlerini ve değerlerini verdi ancak değerleri olmadığı içinNoneolarak döndü.

###### allow_abbrev argümanı

Normal şartlardaparse_args()fonksiyonuna argüman listesi verdiğiniz zaman uzun seçeneklerin kısaltmalarını kabul eder. Eğer bu özelliği devre dışı
bırakmak istersenizallow_abbrev=Falseşeklinde kullanabilirsiniz.

Örnek Kod:

```python
import argparse

ayristirici = argparse.ArgumentParser(allow_abbrev=True)
ayristirici.add_argument('--foobar')
ayristirici.add_argument('--foonley')
print(ayristirici.parse_args(['--foon', 'Argüman Değeri']))

```

Bu kodumuzdaallow_abbrevdeğeriTrueçıktımıza baktığımız zaman:

```python
Namespace(foobar=None, foonley='Argüman Değeri')

```

parse_args()fonksiyonuna–foondeğeri vermemize rağmen Python devamını tamamladı ve–foonleyargümanına değeri atadı şimdiallow_abbrevdeğeriniFalseyapalım.

Çıktımız:

```python
usage: ilkprogram.py [-h] [--foobar FOOBAR] [--foonley FOONLEY]
ilkprogram.py: error: unrecognized arguments: --foon Argüman Değeri

```

Görüldüğü üzereilkprogram.py: error: unrecognized argumentshatası verdi. Bu hatanın sebebi kısaltma olarak verdiğimiz argümanı Python tanımadı.

###### conflict_handler argümanı

ArgumentParsernesnesi varsayılan olarak aynı argümanların kullanımına izin vermez. Eğer aynı argümanları kullanmaya denerseniz hata verecektir.
Örnek:

```python
import argparse

ayristirici= argparse.ArgumentParser()
ayristirici.add_argument('-i', '--ilk_argüman', help='eski argümanın yardım metni')
ayristirici.add_argument('--ilk_argüman', help='yeni argümanın yardım metni')

```

Çıktımız:

```python
Traceback (most recent call last):
...
 raise ArgumentError(action, message % conflict_string)
argparse.ArgumentError: argument --ilk_argüman: conflicting option string: --ilk_argüman

```

İki argüman aynı olduğu için uygulamamız hata verdi.
Bazen (örneğinparentsargümanını kullandığımız zaman) Aynı argümanların eskisini geçersiz kılmak (üstüne yazmak) kullanışlı olablir. Bu özelliği kullanmak içinconflict_handlerargümanınaresolvedeğerini veriyoruz.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(conflict_handler='resolve')
ayristirici.add_argument('-i', '--ilk_argüman', help='eski argümanın yardım metni')
ayristirici.add_argument('--ilk_argüman', help='yeni argümanın yardım metni')

print(ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [-i ILK_ARGÜMAN] [--ilk_argüman ILK_ARGÜMAN]

optional arguments:
-h, --help show this help message and exit
-i ILK_ARGÜMAN eski argümanın yardım metni
--ilk_argüman ILK_ARGÜMAN
 yeni argümanın yardım metni

```

NOT:`ArgumentParser` nesnesi yalnızca yeni verilen argümanın üzerine yazılır. Eğer eski argüman birden farklı seçeneği varsa (`-i/–ilk_argüman` gibi) yeni eklediğiniz hangi argüman ise onun üzerine yazılır. Çıktımıza baktığımız zaman sadece `–ilk_argüman` üzerine yazıldı `-i` argümanının üzerine yazılma olmadı.

###### add_help argümanı

ArgumentParsernesnesi varsayılan olarak ayrıştırıcıların yardım mesajlarını sade şekilde ekrana yazdırır.
Örnek kodumuzu bir metin dosyasına yazıp ardından, terminalde dosyamızın bulunduğu dizinde terminalimizdepython3 ilkprogram.py -hşeklinde komutunu çalıştıralım:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('-i', help='Yardım metni')
ayristirici.parse_args()

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [-i I]

optional arguments:
 -h, --help show this help message and exit
 -i I Yardım metni

```

Görüldüğü üzere argümanlarımız hakkında basitçe bir yardim belgesi ekrana çıktı.
Bazı durumlarda yardım metinlerini devre dışı bırakmak isteyebiliriz. Bu durumdaadd_helpargümanınaFalsedeğerini veririz.
Az önce yazdığımız kodu bu şekilde değiştirip terminalden tekrar çalıştıralım.:

```python
import argparse

ayristirici = argparse.ArgumentParser(add_help=False)
ayristirici.add_argument('-i', help='Yardım metni')
ayristirici.parse_args()

```

Çıktımız:

```python
usage: ilkprogram.py [-i I]
ilkprogram.py: error: unrecognized arguments: -h

```

Artık yardım metni yok.

Yardım seçeneği genellikle `-h / –help`’dir. Bunun istisnası, eğer `prefix_chars` argümanı kullanılmışsa ve `-` içermezse,bu durumda `-h / –help` geçerli değildir. Bu durumda, prefix_chars içindeki ilk karakter yardım seçeneklerini ön ek olarak kullanılır:

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(prefix_chars='+/')
ayristirici.print_help()

```

Çıktı:

```python
usage: ilkprogram.py [+h]

optional arguments:
 +h, ++help show this help message and exit

```

#### add_argument() Fonksiyonu

```python
ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])

```

##### Parametreler ve açıklamaları
- name veya flags: İsim veya seçenek tanımlamak için oluşturulan dizi. Örnek:-s,–silveyasil.
- action: Komut satırında rastlanırsa yapılacak eylem.
- nargs: Kullanılması gereken komut satırı argümanlarının sayısı.
- const: Bazı eylem ve nargs seçeneklerinin seçimlerinin gerektirdiği sabit bir değer.
- default: Komut satırında argüman bulunmazsa varsayılan değer.
- type: Argümanın dönüştürüleceği değer türü.
- choices: Argümanlar için izin verilen değerlerin bir aralığı ayarlar.
- required: Argümanın ihmal edilip edilmeyeceği için kullanılır. (yalnızca isteğe bağlı)
- help: Argümanın yaptığı hakkında açıklama.
- metavar: Kullanım mesajlarındaki argüman için bir isim.
- dest:parse_args()tarafından döndürülen nesneye eklenecek niteliğin adı.

name veya flags: İsim veya seçenek tanımlamak için oluşturulan dizi. Örnek:-s,–silveyasil.

action: Komut satırında rastlanırsa yapılacak eylem.

nargs: Kullanılması gereken komut satırı argümanlarının sayısı.

const: Bazı eylem ve nargs seçeneklerinin seçimlerinin gerektirdiği sabit bir değer.

default: Komut satırında argüman bulunmazsa varsayılan değer.

type: Argümanın dönüştürüleceği değer türü.

choices: Argümanlar için izin verilen değerlerin bir aralığı ayarlar.

required: Argümanın ihmal edilip edilmeyeceği için kullanılır. (yalnızca isteğe bağlı)

help: Argümanın yaptığı hakkında açıklama.

metavar: Kullanım mesajlarındaki argüman için bir isim.

dest:parse_args()tarafından döndürülen nesneye eklenecek niteliğin adı.

###### name veya flags (isim veya bayrak)

Add_argument()fonksiyonu , -f veya –foo gibi isteğe bağlı bir argüman mı yoksa konumsal bir argüman mı olduğunu bilmesi gerekir.Add_argument()fonksiyonuna iletilen ilk argümanlar bu nedenle bir dizi bayrak veya basit bir argüman adı olmalıdır.
Örneğin isteğe bağlı argüman eklemek için:

```python
parser.add_argument('-f', '--foo')

```

Eğer konumsal argüman eklemek istersek:

```python
parser.add_argument('bar')

```

Bu şekilde ekleyebiliriz.

Parse_args()fobksiyonu çağrıldığında, isteğe bağlı argümanlar-ön eki tarafından tanımlanır ve kalan argümanların konumsal olduğu varsayılır:
Kodları yazalım.:

```python
import argparse

ayristirici = argparse.ArgumentParser(prog='PROG')
ayristirici.add_argument('-f', '--foo')
ayristirici.add_argument('bar')
print(ayristirici.parse_args(['BAR']))
print(ayristirici.parse_args(['BAR', '--foo', 'FOO']))
print(ayristirici.parse_args(['--foo', 'FOO']))

```

Çıktımız:

```python
Namespace(bar='BAR', foo=None)
Namespace(bar='BAR', foo='FOO')
usage: PROG [-h] [-f FOO] bar
PROG: error: the following arguments are required: bar

```

Çıktımıza baktığımız zamanbarargümanı konumsal olduğu için ve sonparse_args()fonksiyonunda kullanmadığımız için uygulamamız hata verdi.

###### action

ArgumentParsernesnesi,argüman eylemleri ile ilişkilendirir.
Bu eylemler, kendisiyle ilişkilendirilmiş komut satırı argümanları ile hemen hemen
her şeyi yapabilir, ancak çoğu eylem yalnızcaparse_args()fonksiyonunun döndürdüğü nesneye bir nitelik ekler.Actionanahtar sözcüğü argümanı, komut satırı argümanlarının nasıl ele alınması gerektiğini belirtir. Bazı sağlanan eylemler:
- store- Bu sadece argümanın değerini saklar. Bu varsayılan eylemdir. Örneğin:importargparseayristirici=argparse.ArgumentParser()ayristirici.add_argument('--arguman')print(ayristirici.parse_args('--arguman 1'.split()))

store- Bu sadece argümanın değerini saklar. Bu varsayılan eylemdir. Örneğin:

```python
import argparse

 ayristirici = argparse.ArgumentParser()
 ayristirici.add_argument('--arguman')
 print(ayristirici.parse_args('--arguman 1'.split()))

```

Çıktımız:

```python
Namespace(arguman='1')

```
- store_const-constanahtar sözcüğü argümanı tarafından belirtilen değeri saklar.store_consteylemi, genellikle bir tür bayrak belirten isteğe bağlı değişkenlerle birlikte kullanılır.

store_const-constanahtar sözcüğü argümanı tarafından belirtilen değeri saklar.store_consteylemi, genellikle bir tür bayrak belirten isteğe bağlı değişkenlerle birlikte kullanılır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--arguman', action='store_const', const=42)
print(ayristirici.parse_args(['--arguman']))

```

Çıktımız:

```python
Namespace(arguman=42)

```
- store_truevestore_false- Bunlar, sırasıylaTrueveFalsedeğerlerini depolamak için kullanılanstore_costdurumlarıdır.

store_truevestore_false- Bunlar, sırasıylaTrueveFalsedeğerlerini depolamak için kullanılanstore_costdurumlarıdır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--arguman', action='store_true')
ayristirici.add_argument('-i', action='store_false')
ayristirici.add_argument('-y', action='store_false')
print(ayristirici.parse_args('--arguman -i'.split()))

```

Çıktımız:

```python
Namespace(arguman=True, i=False, y=True)

```
- append- Liste saklar ve her argüman değerini listeye ekler. Bir seçeneğin birden çok kez belirtilmesine izin vermek için kullanışlıdır.

append- Liste saklar ve her argüman değerini listeye ekler. Bir seçeneğin birden çok kez belirtilmesine izin vermek için kullanışlıdır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--arguman', action='append')
print(ayristirici.parse_args('--arguman 1 --arguman 2'.split()))

```

Çıktımız:

```python
Namespace(arguman=['1', '2'])

```
- append_const- Bir listeyi depolar veconstanahtar sözcüğü argümanı tarafından belirtilen değeri listeye ekler. (constanahtar sözcüğü argümanı varsayılan olarakNone`dır) `append_constgenellikle birden fazla argüman sabitlerini aynı listeye kaydetmesi gerektiğinde kullanışlıdır.

append_const- Bir listeyi depolar veconstanahtar sözcüğü argümanı tarafından belirtilen değeri listeye ekler. (constanahtar sözcüğü argümanı varsayılan olarakNone`dır) `append_constgenellikle birden fazla argüman sabitlerini aynı listeye kaydetmesi gerektiğinde kullanışlıdır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--str', dest='types', action='append_const', const=str)
ayristirici.add_argument('--dict', dest='types', action='append_const', const=dict)
print(ayristirici.parse_args('--str --dict'.split()))

```

Çıktımız:

```python
Namespace(types=[<class 'str'>, <class 'dict'>])

```
- count- Anahtar kelime argümanının kullanılma sayısını sayar. Bu ayrıntı düzeylerini artırmak için kullanışlıdır.

count- Anahtar kelime argümanının kullanılma sayısını sayar. Bu ayrıntı düzeylerini artırmak için kullanışlıdır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--say', '-s', action='count')
print(ayristirici.parse_args(['-sss']))

```

Çıktımız:

```python
Namespace(say=3)

```
- help- Geçerli ayrıştırıcıdaki tüm seçenekler için eksiksiz yardım mesajı yazdırır ve sonra uygulama sonlanır.
- version- Sürüm bilgisi yazdırır.

help- Geçerli ayrıştırıcıdaki tüm seçenekler için eksiksiz yardım mesajı yazdırır ve sonra uygulama sonlanır.

version- Sürüm bilgisi yazdırır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(prog='PROG')
ayristirici.add_argument('--v', action='version', version='%(prog)s 2.0')
print(ayristirici.parse_args(['--v']))

```

Çıktımız:

```python
PROG 2.0

```

###### nargs

ArgumentParsernesnesi her argümanı tek bir işlem ile ilişkilendirir.nargsanahtar sözcüğü bir argümanı farklı sayıda argümanı tek bir işlem ile ilişkilendirir.
- N (tam sayı) - N argümanları komut satırından bir liste halinde alınır.

N (tam sayı) - N argümanları komut satırından bir liste halinde alınır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', nargs=3)
ayristirici.add_argument('bar', nargs=1)
print(ayristirici.parse_args('c --foo a b d'.split()))

```

Çıktımız:

```python
Namespace(bar=['c'], foo=['a', 'b', 'd'])

```

nargs=1 bir adet liste elemanı listeler. Bu varsayılan değerden farklıdır
- ?Komut satırından bir argüman alınacak ve tek bir öğe olarak üretilecektir. Eğer komut satırında argüman yoksa, varsayılan değer üretilir.

?Komut satırından bir argüman alınacak ve tek bir öğe olarak üretilecektir. Eğer komut satırında argüman yoksa, varsayılan değer üretilir.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', nargs='?', const='c', default='d')
ayristirici.add_argument('-b', nargs='?', default='d')
print(ayristirici.parse_args(['-b', '--foo', 'YY']))
print(ayristirici.parse_args(['-b', '--foo']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(b=None, foo='YY')
Namespace(b=None, foo='c')
Namespace(b='d', foo='d')

```

nargs=’?’bir kullanım alanı daha vardır. Bu alan isteğe bağlı dosya girdi ve çıktılarıdır.
Python Etkileşimli Kabuğumuzda Kodumuzu Yazalım:

```python
import argparse
import sys
parser = argparse.ArgumentParser()
parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
 default=sys.stdin)
parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),
 default=sys.stdout)
parser.parse_args(['input.txt', 'output.txt'])
parser.parse_args([])

```

Çıktımız:

```python
Namespace(infile=<_io.TextIOWrapper name='input.txt' encoding='UTF-8'>,
 outfile=<_io.TextIOWrapper name='output.txt' encoding='UTF-8'>)
Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>,
 outfile=<_io.TextIOWrapper name='<stdout>' encoding='UTF-8'>)

```
- *- Mevcut tüm komut satırı argümanları bir liste halinde toplanır. Genel olaraknargs=’*’ile birden fazla konumsal argüman almanın bir anlamı olmadığını unutmayın. Ancak birden fazla isteğe bağlı argümanınargs=’*’ile almak mümkündür.

*- Mevcut tüm komut satırı argümanları bir liste halinde toplanır. Genel olaraknargs=’*’ile birden fazla konumsal argüman almanın bir anlamı olmadığını unutmayın. Ancak birden fazla isteğe bağlı argümanınargs=’*’ile almak mümkündür.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', nargs='*')
ayristirici.add_argument('--bar', nargs='*')
ayristirici.add_argument('baz', nargs='*')
print(ayristirici.parse_args('a b --foo x y --bar 1 2'.split()))

```

Çıktımız:

```python
Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])

```

Çıktımızı incelediğimiz zamanbazbizim konumsal argümanımızdır diğerleri ise isteğe bağlı argümandır. Eğerbazargümanındannargs=’*’kaldırırsak:

```python
usage: ilkprogram.py [-h] [--foo [FOO [FOO ...]]] [--bar [BAR [BAR ...]]] baz
ilkprogram.py: error: unrecognized arguments: b

```

Şeklinde hata verir.
- +-*gibi davranır. Mevcut tüm komut satırı argümanları bir liste halinde toplanır. Ayrıca, en az bir komut satırı argümanı yoksa, bir hata mesajı oluşturulur.

+-*gibi davranır. Mevcut tüm komut satırı argümanları bir liste halinde toplanır. Ayrıca, en az bir komut satırı argümanı yoksa, bir hata mesajı oluşturulur.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(prog='PROG')
ayristirici.add_argument('foo', nargs='+')
print(ayristirici.parse_args(['a', 'b']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(foo=['a', 'b'])

usage: PROG [-h] foo [foo ...]
PROG: error: the following arguments are required: foo

```

Çıktımıza baktığımız zamanparse_args()fonksiyonuna liste halinde değer gönderince bize ad alanını döndürüyor. Ancak boş bir liste gönderince hata veriyor.
- argparse.REMAINDER- Kalan tüm komut satırı argümanları bir liste halinde toplanır. Diğer komut satırı yardımcılarını gönderilen komut satırı yardımcıları için kullanışlıdır.

argparse.REMAINDER- Kalan tüm komut satırı argümanları bir liste halinde toplanır. Diğer komut satırı yardımcılarını gönderilen komut satırı yardımcıları için kullanışlıdır.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(prog='PROG')
ayristirici.add_argument('--foo')
ayristirici.add_argument('command')
ayristirici.add_argument('args', nargs=argparse.REMAINDER)
print(ayristirici.parse_args('--foo B cmd --arg1 XX ZZ'.split()))

```

Çıktımız:

```python
Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')

```

Eğernargsanahtar sözcüğü sağlanmazsa, kullanılan argümanların sayısıactiontarafından belirlenir. Genellikle bu, tek bir komut satırı argümanının kullanılacağı ve tek bir öğenin
üretileceği anlamına gelir.

###### const

‘const` argümanı komut satırından okunamayan ancak ‘ArgumentParser()` için gerekli sabit değerleri tutar. En yaygın iki kullanımı vardır.
- add_argument()fonksiyonuaction=’store_const’veyaaction=’append_cost’ile çağrıldığı zaman bu iki eylemconstdeğeriniparse_args()tarafından döndürülen nesnenin niteliklerine ekler.
- add_argument()fonksiyonu isteğe bağlı karakter dizisi (-fveya–foogibi) venargs=’?’ile çağrıldığı zaman sıfır veya bir komut satırı argümanı tarafından takip edilebilecek isteğe bağlı argüman oluşturur. Komut satırı argümanları ayrıştırılırken isteğe bağlı seçenek dizesi bağımsız değişken ile karşılaşmazsaconstdeğeri kabul edilir.

add_argument()fonksiyonuaction=’store_const’veyaaction=’append_cost’ile çağrıldığı zaman bu iki eylemconstdeğeriniparse_args()tarafından döndürülen nesnenin niteliklerine ekler.

add_argument()fonksiyonu isteğe bağlı karakter dizisi (-fveya–foogibi) venargs=’?’ile çağrıldığı zaman sıfır veya bir komut satırı argümanı tarafından takip edilebilecek isteğe bağlı argüman oluşturur. Komut satırı argümanları ayrıştırılırken isteğe bağlı seçenek dizesi bağımsız değişken ile karşılaşmazsaconstdeğeri kabul edilir.

###### default

Tüm isteğe bağlı argümanlar ve bazı konumsal argümanlar komut satırında bazen atlanabilir.defaultanahtar sözcüğü argümanı ile eğer argüman değer almazsa varsayılan bir değer atanabilir. Varsayılan olarakdefaultNonedeğerine sahiptir.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', default=42)
print(ayristirici.parse_args(['--foo', '2']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(foo='2')
Namespace(foo=42)

```

İlkparse_args()fonksiyonunda değer atadığımız içinfooargümanının yeni değeri‘2’oluyor ancak ikinciparse_args()fonksiyonunda değer olmadığı için varsayılan değerimiz42ekrana çıkıyor.defaultdeğeri karakter dizisi (string) ise ayrıştırıcı değeri argüman gibi ayırır. Eğer değerin tipi değiştirilmek istenirsetypekullanılır.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', default=42, type=int)
print(ayristirici.parse_args(['--foo', '2']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(foo=2)
Namespace(foo=42)

```

Görüldüğü üzere ilk değerimiz karakter dizisi yerine artık tam sayı (int) oldu.

###### type

ArgumentParser()nesnesi varsayılan olarak komut satırından okuduğu değerleri karakter dizisi (string) olarak alır. Bazı durumlarda farklı tiplerde değişkenlere ihtiyaç duyarız. Bunun içintypekullanılır.
Şimdi uygulamamızı çalıştırdığımız dizineargs.txtdosyası oluşturalım ve kodumuzu çalıştıralım.
Kod:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici .add_argument('foo', type=int)
ayristirici .add_argument('bar', type=open)
print(ayristirici .parse_args('2 args.txt'.split()))

```

Çıktımız:

```python
Namespace(bar=<_io.TextIOWrapper name='args.txt' mode='r' encoding='UTF-8'>, foo=2)

```

Çıktıya baktığımız zamanbarargümanının dosya hakkında bilgiler içeren bir takım detaylar var vefooise tam sayı değerine sahip.

###### choices

Bazen argümanlar belirli değerler ile sınırlandırmak gerekir. Bu durumdachoiceskullanılır. Eğer kullanıcı geçerli argüman verdiyse uygulama devam edeğer ancak
verilen argüman geçersiz ise hata mesajı döner.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('oyun', choices=['tas', 'kagit', 'makas'])
print(ayristirici.parse_args(['kagit']))
print(ayristirici.parse_args(['ates']))

```

Çıktı:

```python
Namespace(oyun='kagit')
usage: ilkprogram.py [-h] {tas,kagit,makas}
ilkprogram.py: error: argument oyun: invalid choice: 'ates' (choose from 'tas', 'kagit', 'makas')

```

Çıktımıza baktığımız zaman ilk argümanımız geçerli olduğu için bir hata almadık. Ancak ikinci argümanımız geçersiz olduğundan dolayı uygulamamız bize geçerli argümanlar arasında seçim yapmamızı söylüyor.

###### required

argparsemodülü genellikle-fveya–foogibi isteğe bağlı seçimler ile çalışır ancak bazı durumlarda zorunlu argümanlar vermek gerekebilir. Böyle durumlardarequired=Truekullanılır.

Örnek Kod:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', required=True)
print(ayristirici.parse_args(['--foo', 'Degisken']))
print(ayristirici.parse_args([]))

```

Çıktımız:

```python
Namespace(foo='Degisken')
usage: ilkprogram.py [-h] --foo FOO
ilkprogram.py: error: the following arguments are required: --foo

```

Çıktımızı incelediğimiz zaman bir değişken atadığımız için uygulama hatasız çalıştı ancak ikincisinde değişken olmadığı için hata verdi.

NOT:Zorunlu seçimler genellikle kötü form olarak kabul edilir. Çünkü bu parametreler özünde isteğe bağlıdır ve kullanıcılar isteğe bağlı olmasını ister. Mümkün olduğunca kullanmamak gerekir.

###### help

helpdeğeri karakter dizisi olarak değer alır ve bu değer argümanlar hakkında yardım metinleri içerir. Kullanıcı yardım istediğinde bulununca (genellikle-hveya–help) yardım metinleri görünür.

Örnek Kod:

```python
import argparse

ayristirici= argparse.ArgumentParser()
ayristirici.add_argument('--foo', help='foo için yardım metni')
ayristirici.add_argument('bar', help='bar için yardım metni')
print(ayristirici.parse_args(['-h']))

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--foo FOO] bar

positional arguments:
 bar bar için yardım metni

optional arguments:
 -h, --help show this help message and exit
 --foo FOO foo için yardım metni

```

helpçeşitli formatlama yöntemlerini içerir. Bu sayede değerlerinizi farklı yerlerde kullanabilirsiniz.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser(prog='merhaba dünya')
ayristirici.add_argument('bar', default=42,
 help='bar argümanı için yardım metni ayrıca bu uygulamannın adı: %(prog)s (varsayılan değeri: %('
 'default)s)')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: merhaba dünya [-h] bar

positional arguments:
 bar bar argümanı için yardım metni ayrıca bu uygulamannın adı:
 merhaba dünya (varsayılan değeri: 42)

optional arguments:
 -h, --help show this help message and exit

```

Görüldüğü üzere uygulamamızın adı ve varsayılan değerimiz ekrana basıldı.

###### metavar

ArgumentParser()nesnesi yardım metinlerini oluşturduğu zaman, beklenen her argümana atıfta bulunmak için bir yola ihtiyaç duyar. Varsayılan olarakArgumentParser()nesnesidestdeğerini her nesnenin “ismi” olarak kullanır.
Varsayılan olarak, konumsal argüman eylemleri içindestdeğeri doğrudan kullanılır ve isteğe bağlı argüman eylemleri içindestdeğeri büyük harfe dönüştürülür.
Örnek Kod:

```python
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('--foo')
parser.add_argument('bar')
print(parser.parse_args('X --foo Y'.split()))
print(parser.print_help())

```

Çıktımız:

```python
Namespace(bar='X', foo='Y')
usage: ilkprogram.py [-h] [--foo FOO] bar

positional arguments:
 bar

optional arguments:
 -h, --help show this help message and exit
--foo FOO

```

Ayrıcametavaralternatif isim belirtebilir.

Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', metavar='YYY')
ayristirici.add_argument('bar', metavar='XXX')
print(ayristirici.print_help())

```

Çıktımız:

```python
usage: ilkprogram.py [-h] [--foo YYY] XXX

positional arguments:
 XXX

optional arguments:
 -h, --help show this help message and exit
 --foo YYY

```

Konumsal argümanımızın ismimetavarile değişti.

NOT:`metavar` yalnızca ekran ismini değiştirir, `parse_args()` ile kontrol ettiğiniz zaman `dest` değerini kullandığını görebilirsiniz.

###### dest

destile argümanlara kişiselleştirilmiş isimler verebilirsiniz.
Örnek:

```python
import argparse

ayristirici = argparse.ArgumentParser()
ayristirici.add_argument('--foo', dest='bar')
print(ayristirici.parse_args('--foo XXX'.split()))

```

Çıktımız:

```python
Namespace(bar='XXX')

```

Bu yardım sayfasıhttps://docs.python.org/3/library/argparse.htmlreferans alınarak hazırlanmıştır.

## Üçüncü Taraf Modüller

### Colorama Modülü

Colorama modülü, konsol penceresindeki yazıları renklendirmeyi ve stil vermeyi sağlar.

#### Kurulum

Varsayılan python’a colorama modülünü kurmak için bilgisayarınızın komut satırına şunları girin:

pip install colorama

> **Not**
> Bu komutları Windows ortamında verebilmek için python’u yola eklemeniz gerekir. Python kurulum aşamasında altta bulunan add to Path seçeneğini işaretlediyseniz python yola eklenmiştir.

Not

Bu komutları Windows ortamında verebilmek için python’u yola eklemeniz gerekir. Python kurulum aşamasında altta bulunan add to Path seçeneğini işaretlediyseniz python yola eklenmiştir.

#### Kullanım

Colorama modülünü anlayabilmek için basit bir örnek yapalım:

```python
from colorama import Fore, Back, Style, init
init(autoreset=True)
print(Fore.RED + 'sade kırmızı yazı')
print(Back.GREEN + 'Yeşil arkaplan')
print(Style.DIM + 'Python')
print(Style.RESET_ALL)
print('Tekrar normal haline döndü')

```

Gördüğünüz üzere colorama modülünün Fore, Back ve Style sınıflarının belirlenmiş nitelikleri ile herhangi bir karakter dizimizi birleştirip yazdırdığımızda niteliğe göre renkli yazılar elde ediyoruz. Fore yazının kendisi, Back arka planı, Style ise stilini ilgilendirir.

Peki neden init fonksiyonunu çağırdık?

İnit bildiğiniz üzere “initalization” (ilklendirme) sözcüğünün kısaltılmışıdır. Buradaki kullanımı da sözcük anlamıyla uyumludur. Yani bizim renklendirme işlemimizde birtakım ayarları yapmamız için bir başlangıçtır. Bunu yapmamız zorunludur. Yapmazsak kodlarımız renklenmeyecek, sadece renk kodu ekrana bastırılacaktır.

Bu noktada bir detaya değinelim: Bu Fore, Back ve Style sınıflarının belirlenmiş nitelikleri aslında alelade bir karakter dizisidir:

```python
print('\033[31m' + 'sade kırmızı yazı')
print('\033[30m') # Ve yeniden öntanımlı renge döndük

```

Gördüğünüz gibi yukarıdakiyle aynı sonucu elde ettik.

Şimdi Fore, Back ve Style sınıflarının en çok kullanılan renk niteliklerini görelim:

Fore: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.

Back: BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, RESET.

Style: DIM, NORMAL, BRIGHT, RESET_ALL

##### Colorama modülünün termcolor modülü ile kullanımı

Termcolor modülü colorama modülünü kullanırken işimiz çok kolaylaştırır.

```python
from colorama import init
from termcolor import colored
#termcolor modülü colorama kullandığı için ilklendirme şarttır
init()

#İlk parametremiz karakter dizimiz, ikinci parametremiz rengi, üçüncü ise arkaplan rengidir.
print(colored('Hello, World!', 'green', 'on_red'))
# colored fonksiyonundan dönen değeri kullanabilmek için yazdırmamız gerekir.

```

> **Not**
> termcolor modülü yüklü gelmemektedir, kurulum aşamasındaki kodlarda colorama yerine termcolor yazarak kurabilirsiniz.

Not

termcolor modülü yüklü gelmemektedir, kurulum aşamasındaki kodlarda colorama yerine termcolor yazarak kurabilirsiniz.

Termcolor modülü ile daha fazla bilgi için:https://pypi.org/project/termcolor/

#### İnit fonksiyonun argümanları

İnit fonksiyonunun birçok isimli argümanı bulunur:

##### autoreset=False

```python
from colorama import Fore, init
init(autoreset=True)
print(Fore.RED + "Bu kırmızı olur ama;")
print("Bunun rengi default'tur")

```

```python
from colorama import Fore, init
init(autoreset=False) #Böyle yapsak da değişmez: init()
#çünkü bu zaten öntanımlıdır
print(Fore.RED+"Artık bundan sonra yazdırılan her şey değiştirilmediği sürece kırmızıdır")
print("mesela bu kırmızı")

```

Diğerlerine ihtiyacınızın olmayacağını düşündüğümüz için buraya yazmadık.
Diğer argümanları colorama PyPI sayfasında görebilirsiniz.

### django Paketi

Bu belgeler Django frameworkunu anlatan resmi başlatıcının
çevirisidir. Kaynağı:

https://docs.djangoproject.com/en/2.0/intro/tutorial01/

#### İLK DJANGO PROJENİ YAZ, part 1

Bir örnekle öğrenmeye başlayalım. Bu örnekte basit bir anket uygulaması oluşturacağız.
Uygulama iki kısımdan oluşacak:
1. Anketlerin oylanması için herkese açık bir site
1. Anketleri düzenlemek veya ekleyip silmek için bir admin paneli

Anketlerin oylanması için herkese açık bir site

Anketleri düzenlemek veya ekleyip silmek için bir admin paneli

Senin Djangoyu yüklediğini varsayıyoruz. Komut isteminde aşağıdaki komutu çalıştırarak Djangonun yüklü olup olmadığına ve Django sürümüne ulaşabilirsin:

```python
python -m django --version

```

Eğer Django yüklüyse yüklü olan versiyonu görmelisin. Eğer değilse “No module named django” yazısı ile karşılaşmalısın.

##### Bir proje oluştur

Komut satırında cd komutuyla komutunuzu saklamak istediğiniz dizine gidin ve aşağıdaki kodu çalıştırın:

```python
django-admin startproject mysite

```

Bu kod bulunduğunuz dizinde mysite dizinini yaratacak.
Şimdistartprojectkomutunun oluşturduklarına bakalım:

```python
mysite/
 manage.py
 mysite/
 __init__.py
 settings.py
 urls.py
 wsgi.py

```

En dışardakimysite/dizini, projeniz için sadece bir kapsayıcıdır. Adı Django için önemli değil. Beğendiğiniz herhangi bir şeyle yeniden adlandırabilirsiniz.manage.py: Komut satırından django projesiyle etkileşime geçmenizi sağlayan bir programdır.
İçeridekimysite/dizini , projeniz için gerçek bir python paketidir.mysite/init.py: Boş bir python dosyasıdır. mysite/ dizininin python paketi olmasını sağlar.mysite/setting.py: Django projesinin ayarları ile ilgili bir dosya.mysite/urls.py: Projeniz için URL’leri barındıran dosya.mysite/wsgi.py: WSGI uyumlu web sunucuları için projenize hizmet edecek bir giriş noktası.

##### Geliştirme sunucusu

Şimdi django projemizin çalışıp çalışmadığını kontrol edelim. Komut satırında dışarıdakimysitedizinine gidin ve aşağıdaki kodu çalıştırın:

```python
python manage.py runserver

```

Çıktı olarak şunu görmelisin:

```python
Performing system checks...

System check identified no issues (0 silenced).

You have unapplied migrations; your app may not work properly until they are applied.
Run 'python manage.py migrate' to apply them.

April 29, 2018 - 15:50:53
Django version 2.0, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

```

> **Not**
> Veritabanıyla ilgili uyarıyı dikkate almayın.

Not

Veritabanıyla ilgili uyarıyı dikkate almayın.

Django geliştirme sunucusunu başlattınız.

##### Kullanılan portu değiştirme

runserverkomutu geliştirme sunucusu için standart olarak 8000 portunu kullanır.
Eğer bu portu değiştirmek isterseniz bunu komuta argüman olarak verin. Mesela aşağıdaki komut 8080 portunda geliştirme sunucusunu çalıştırıyor:

```python
python manage.py runserver 8080

```

Eğer sunucunun IP adresini değiştirmek isterseniz port ile birlikte belirtin. Örnek olarak kullanılabilir tüm IP’leri dinlemek istiyorsanız şu kodu çalıştırın:

```python
python manage.py runserver 0:8000

```

Yukarıda yazdığımız kodda 0’ın anlamı 0.0.0.0 (Yani bir kısaltma).

##### Bir anket uygulaması oluşturalım

Artık proje ortamımız kuruldu. Çalışmaya başlayabiliriz.
Django’da yazdığımız her uygulama bir python paketinden oluşur ve Django’da uygulamanın dizini otomatik olarak oluşturulur. Bu sayede dizin oluşturmakla uğraşacağımız zamanda kod yazabiliriz.
Bir uygulama oluşturmak için komut satırındamanage.pyile aynı dizine gelin ve şu komutu yazın:

```python
python manage.py startapp polls

```

pollsisimli bir dizin oluşturulacak. Bakaklım içinde neler var:

```python
polls/
 __init__.py
 admin.py
 apps.py
 migrations/
 __init__.py
 models.py
 tests.py
 views.py

```

Bu dizin anket uygulamamızın merkezi olacak.

##### İlk view’ımızı yazalım

Hadi yazmaya başlayalım. Şimdipolls/views.pyaçın ve şu kodları yazın:

```python
from django.http import HttpResponse
def index(request):
 return HttpResponse("Hello, world. You're at the polls index.")

```

Bu Django’da yazılabilecek en basit view. Artık bu view ı çağırabilmek için bir URL haritasına ihtiyacımız var ve URL haritası için de URL şemasına.
polls dizinindeurls.pyisimli bir dosya oluşturarak uygulamanın URL şemasını da oluşturmuş oluruz.(Dosya Gezgininden kendiniz urls.py isimli bir python modülü oluşturun.) Uygulama dizini son olarak şöyle görünmeli:

```python
polls/
 __init__.py
 admin.py
 apps.py
 migrations/
 __init__.py
 models.py
 tests.py
 views.py
 urls.py

```

Şimdi de yeni oluşturduğumuz polls dizinindeki urls.py dosyasında şu kodlar yazılı olmalı:

```python
from django.urls import path
from . import views

urlpatterns = [
 path('', views.index, name='index'),
]

```

Burada oluşturduğumuz URL şemasını gerçek Url şemasında tanıtmanın vakti geldi. Bunun için mysite dizinindeki urls.py dosyasında include fonksiyonunu içe aktarıp url listesini aktarmada kullanacağız. Sonuç olarak mysite dizinindeki urls.py dosyanız şu hale gelmeli:

```python
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
 path('polls/', include('polls.urls')),
 path('admin/', admin.site.urls),
]

```

Artık index view’ını bir dizine bağladınız. Test etmenin vakti geldi. Komut satırında şu kodu çalıştırın:

```python
python manage.py runserver

```

include()fonksiyonu diğer URL şemalarına ulaşmamıza izin verir. Django include ile karşılaştığında eşleşen URL’yi kalan işlemler için verilen URL şemasına gönderir.

#### İLK DJANGO PROJENİ YAZ, part 2

##### Veritabanı Kurulumu

Şimdimysite/settings.pydosyasını açın. Önce TIME_ZONE
değeriniEurope/Istanbulyaparak İstanbul’a ayarlayın.

> **Not**
> Dosyanın en başındaki INSTALLED_APPS ayarına dikkat edin.
Projenizde kullandığınız uygulamaları tutar. Yeni bir uygulama
kullanacağınız zaman bu listeye eklemelisiniz.

Not

Dosyanın en başındaki INSTALLED_APPS ayarına dikkat edin.
Projenizde kullandığınız uygulamaları tutar. Yeni bir uygulama
kullanacağınız zaman bu listeye eklemelisiniz.

Varsayılan olarak gelen uygulamalar şunlardır:

```python
django.contrib.admin --> Yönetici panelini oluşturur.
django.contrib.auth --> Bir kimlik doğrulama sistemi.
django.contrib.contenttypes --> İçerik türleri için bir framework.
django.contrib.sessions --> Bir oturum frameworku
django.contrib.messages --> Bir mesajlaşma frameworku
django.contrib.staticfiles --> Statik dosyaları yönetmek için bir framework.

```

Bu uygulamalardan bazıları en az bir veritabanı kullanıyor.
Ancak bu veritabanlarının kullanılabilmesi için bir
tablo oluşturmalıyız. O tablo da şu komutla oluşuyor:

```python
python manage.py migrate

```

##### Model oluşturalım

Şimdi modellerimizi tanımlayacağız.
Anket uygulamamızda iki tane model olacak: Question(Soru), Choice(Seçenek).
Question modeli bir soru ve yayınlama tarihi içerecek. Choice modeli ise iki alandan
oluşacak: Bir yazı alanı ve oy çetelesi. Her Choice bir Question ile ilişkili olacak.
Şimdipolls/models.pydosyasını şu şekilde düzenleyin:

```python
from django.db import models

class Question(models.Model):
 question_text = models.CharField(max_length=200)
 pub_date = models.DateTimeField('date published')

class Choice(models.Model):
 question = models.ForeignKey(Question, on_delete=models.CASCADE)
 choice_text = models.CharField(max_length=200)
 votes = models.IntegerField(default=0)

```

Burada iki model oluşturduk. Bu modeller django.db.models.Model
sınıfını miras alıyor ve veritabanı alanını temsil eden
değişkenlere sahip. Bu veritabanı alanlarının her biri bir
Field sınıfı ile ilişkili. Mesela CharField karakter
dizilerini , DateTimeField tarih ve zamanı veritabanına
eklemek için. Bu sistem Django’nun, her alanın hangi veri
tipini tuttuğunu anlamasını sağlar. Bazı Field sınıfları
zorunlu olarak parametreye ihtiyaç duyuyor. Buna en iyi
örnek olan CharField sınıfı max_length değeri olmadan
çalışmıyor.Field sınıfları isteğe bağlı parametrelere de
sahip.Mesela votes değerinin default parametresi-ki biz
bu örnekte 0 olarak ayarladık-buna bir örnek.Son olarak
ForeignKey kullanarak her Choice örneğini bir Question
örneği ile ilişkilendirdik.

##### Modellerin Aktifleştirilmesi

Model kodları Django’ya bazı bilgiler verir.
Django bu bilgilerle şunları yapabilir:
1. Uygulama için bir veritabanı şeması oluşturmak.
1. Question ve Choice nesneleri için bir veritabanı erişim API’ı oluşturmak.

Uygulama için bir veritabanı şeması oluşturmak.

Question ve Choice nesneleri için bir veritabanı erişim API’ı oluşturmak.

Fakat önce polls uygulamasını projeye yüklemeliyiz.
Projeye yüklemek içinsetting.pydosyasını açıp
INSTALLED_APPS ayarını düzenlemeliyiz. Bu listeyepolls/apps.pydosyasındaki PollsConfig sınıfını referans
olarak ekleyelim.setting.pydosyasındaki INSTALLED_APPS
son hali şöyle olmalı:

```python
INSTALLED_APPS = [
 'polls.apps.PollsConfig',
 'django.contrib.admin',
 'django.contrib.auth',
 'django.contrib.contenttypes',
 'django.contrib.sessions',
 'django.contrib.messages',
 'django.contrib.staticfiles',
]

```

Artık Django, polls isimli uygulamamızı projeye eklediğimizi biliyor.
Şimdi farklı bir komutu çalıştıralım:

```python
python manage.py makemigrations polls

```

Talimatlara benzer şeyler görmelisiniz:

```python
Migrations for 'polls':
 polls/migrations/0001_initial.py:
 - Create model Choice
 - Create model Question
 - Add field question to choice

```

makemigrationskomutu ile ürettiğimiz modellerde değişiklik
yaptığımızı (Aynı zamanda yeni modeller ürettiğimizi de) ve
değişikliklerin migration olarak depolanmasını istediğimizi
söyledik. Migrationlar senin modellerindeki değişiklerin
depolanma şeklidir(ve bu yüzden veritabanı şeması).
İstersen yeni modelinin migrationını okuyabilirsin.
Migrationpolls/migrations/0001_inital.pyisimli dosyada.
Endişelenmeyin, bu dosyayı her zaman okumak zorunda değilsiniz.
“migrate” komutu, senin veritabanı
şemanı otomatik olarak yönetmek için migrationları çalıştırır.
Birazdan bu konuya tekrar geleceğiz. Ama önce migrationın çalıştırdığı
SQL dosyasına bakalım. “sqlmigrate” komutuna migration adını
parametre olarak verin ve SQL çıktısını alın:

```python
python manage.py sqlmigrate polls 0001

```

İngilizce yönerge tarzında bir şeyler görüyor olmalısın:

```python
BEGIN;
--
-- Create model Choice
--
CREATE TABLE "polls_choice" (
 "id" serial NOT NULL PRIMARY KEY,
 "choice_text" varchar(200) NOT NULL,
 "votes" integer NOT NULL
);
--
-- Create model Question
--
CREATE TABLE "polls_question" (
 "id" serial NOT NULL PRIMARY KEY,
 "question_text" varchar(200) NOT NULL,
 "pub_date" timestamp with time zone NOT NULL
);
--
-- Add field question to choice
--
ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL;
ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT;
CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id");
ALTER TABLE "polls_choice"
ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id"
 FOREIGN KEY ("question_id")
 REFERENCES "polls_question" ("id")
 DEFERRABLE INITIALLY DEFERRED;

COMMIT;

```
- Çıktı kullandığınız veritabanına göre değişir.
Yukarıdaki örnek PostgreSQL için yazılmıştır.
- Tablo adı, uygulamanın adını ve modelin adını
(küçük harflerle) kullanarak otomatik olarak oluşturulur .
(Bu davranış geçersiz kılınabilir.)
- Birincil anahtarlar(ID) otomatik olarak eklenir.
(Bu da geçersiz kılınabilir.)
- Düzenlenirken Django, foreign key alanının adına “_id”
ekler.(Evet, bunu da geçersiz kılabilirsiniz.)
- Kullandığınız veritabanına göre düzenlenmiştir. Bu yüzden
auto_increment(MySQL), serial(PostgreSQL) gibi veritabanına
özgü alan türleri otomatik olarak ayarlanır. Aynı şey alan
adlarının alıntılanması için de geçerlidir.
- sqlmigratekomutu aslında veritabanındaki migrationları
çalıştırmaz. Sadece onları senin görebileceğin SQL kodları
halinde ekrana yazdırır. Bu Djangonun yaptıklarını
kontrol etmek veya SQL kodlarını düzenlemek için kullanışlıdır.

Çıktı kullandığınız veritabanına göre değişir.
Yukarıdaki örnek PostgreSQL için yazılmıştır.

Tablo adı, uygulamanın adını ve modelin adını
(küçük harflerle) kullanarak otomatik olarak oluşturulur .
(Bu davranış geçersiz kılınabilir.)

Birincil anahtarlar(ID) otomatik olarak eklenir.
(Bu da geçersiz kılınabilir.)

Düzenlenirken Django, foreign key alanının adına “_id”
ekler.(Evet, bunu da geçersiz kılabilirsiniz.)

Kullandığınız veritabanına göre düzenlenmiştir. Bu yüzden
auto_increment(MySQL), serial(PostgreSQL) gibi veritabanına
özgü alan türleri otomatik olarak ayarlanır. Aynı şey alan
adlarının alıntılanması için de geçerlidir.

sqlmigratekomutu aslında veritabanındaki migrationları
çalıştırmaz. Sadece onları senin görebileceğin SQL kodları
halinde ekrana yazdırır. Bu Djangonun yaptıklarını
kontrol etmek veya SQL kodlarını düzenlemek için kullanışlıdır.

Eğer bunu ilgi çekici bulduysan bir de şunu çalıştır:python manage.py check.
Bu kod projende herhangi bir problem olup olmadığını veritabanıyla
uğraşmadan kontrol eder. Şimdimigratekomutunu tekrar
çalıştırıp modelleri veritabanında oluştur:

```python
python manage.py migrate

```

migratekomutu daha önce uygulanmayan tüm migrationları alır
(Django, veritabanınızda django_migrations adlı özel bir tablo
kullanarak hangi uygulamaların uygulandığını izler) ve bunları
veritabanınıza karşı çalıştırır - temel olarak modelinize yaptığınız
değişiklikleri veritabanındaki şema ile senkronize eder.
Migrationlar çok güçlüdür ve zamanla, projenizi geliştirirken, veritabanınızı
veya tablolarınızı silmenize ve yenilerini oluşturmanıza gerek kalmadan
modellerinizi değiştirmenize izin verir -
veri kaybetmeden veritabanınızı canlı hale getirme konusunda
uzmanlaşmıştır. Eğiticinin daha sonraki bir bölümünde bunları
daha ayrıntılı bir şekilde ele alacağız, ancak şimdilik, model
değişikliklerini yapmak için üç adımlı kılavuzu hatırlayın:
- Modeli değiştirin (models.pyde)
- python manage.py makemigrationskomutunu çalıştırarak bu değişiklikler için migration oluşturun.
- python manage.py migratekomutunu çalıştırarak bu değişiklikleri veritabanına uygulayın.

Modeli değiştirin (models.pyde)

python manage.py makemigrationskomutunu çalıştırarak bu değişiklikler için migration oluşturun.

python manage.py migratekomutunu çalıştırarak bu değişiklikleri veritabanına uygulayın.

##### API ile oynayalım

Şimdi etkileşimli kabuğa atlayıp Django’nun sunduğu API ile uğraşalım.
Etkileşimli kabuğu çağırmak için şu komutu kullanın:

```python
python manage.py shell

```

Basitçepythonyazmak yerine bunu kullanıyoruz.
Çünkü manage.py dosyası kullanacağımız django dosyalarını içe aktarıyor.
Kabuğa girdikten sonra veritabanı API’ını keşfedin:

```python
>>> from polls.models import Choice, Question # Az önce yazdığımız model sınıflarını içe aktar.

#Henüz sistemde Question nesnesi yok.
>>> Question.objects.all()
<QuerySet []>

# Yeni bir Question nesnesi oluştur.
# Varsayılan ayarlar dosyasında saat dilimleri desteği etkinleştirilmiştir, bu nedenle
# Django pub_date değişkeni için tzinfo ile bir tarih bekler. timezone.now()'ı kullanın.
# datetime.datetime.now () yerine ve doğru olanı yapacağız.
>>> from django.utils import timezone
>>> q = Question(question_text="What's new?", pub_date=timezone.now())

# Oluşturduğumuz nesneyi veritabanına kaydedelim. Bunun için save() metodunu kullanmalısın.
>>> q.save()

# Şimdi bir ID'ye sahip.
>>> q.id
1

# Python ile model alan değerlerine erişin.
>>> q.question_text
"What's new?"
>>> q.pub_date
datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>)

# Öznitelikleri değiştirip save() metodunu çağıralım.
>>> q.question_text = "What's up?"
>>> q.save()

# objects.all(), veritabanındaki tüm Questionları görüntüler.
>>> Question.objects.all()
<QuerySet [<Question: Question object (1)>]>

```

Bir dakika! <Question: Question object (1)> bu nesne
ilişkisi hiç yararlı değil. Question modeline (polls/models.pydosyasında)
__str__() metodunu ekleyelim(Choice modeline de):

```python
from django.db import models

class Question(models.Model):
 # ...
 def __str__(self):
 return self.question_text

class Choice(models.Model):
 # ...
 def __str__(self):
 return self.choice_text

```

Modellerinize, yalnızca etkileşimli komut istemiyle
çalışırken kendi rahatlığınız için değil, aynı zamanda nesnelerin
temsillerinin Django’nun otomatik olarak oluşturulan yöneticisi
boyunca kullanılmasından dolayı__str__()yöntemlerini eklemeniz
önemlidir. Bunların normal Python yöntemleri olduğunu unutmayın.
Bunu kanıtlamak için özel bir yöntem ekleyelim:

```python
#polls/models.py
import datetime

from django.db import models
from django.utils import timezone

class Question(models.Model):
 # ...
 def was_published_recently(self):
 return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

```

Python standart kütüphanesinden datetime modülünü ve Django’nun
saat dilimleri ile ilgili kütüphanesinden timezone modülünü içe
aktaralım.

Bu yaptığımız değişiklikleri kaydetmek için şu komutla yeni bir
kabuk açalım::python manage.py shell

```python
>>> from polls.models import Choice, Question

# Eklediğimiz __str__() fonksiyonunun çalıştığından emin olalım.
>>> Question.objects.all()
<QuerySet [<Question: What's up?>]>

# Django'nun içinde veritabanı araması için zengin bir API var.
>>> Question.objects.filter(id=1)
<QuerySet [<Question: What's up?>]>
>>> Question.objects.filter(question_text__startswith='What')
<QuerySet [<Question: What's up?>]>

# Bu yıl paylaşılan question nesnelerini bulalım.
>>> from django.utils import timezone
>>> current_year = timezone.now().year
>>> Question.objects.get(pub_date__year=current_year)
<Question: What's up?>

# Veritabanında olmayan bir ID değerini parametre olarak verirseniz
# size bir hata çıktısı verecektir.
>>> Question.objects.get(id=2)
Traceback (most recent call last):
 ...
DoesNotExist: Question matching query does not exist.

# Birincil anahtar aramalarda en çok kullanılan ifadedir, bundan dolayı
# Django birincil anahtar aramaları için bir kısayola sahip.
# Sonraki örnek şu kodla aynı :Question.objects.get(id=1).
>>> Question.objects.get(pk=1)
<Question: What's up?>

# Yazdığımız metodun da çalıştığından emin olalım.
>>> q = Question.objects.get(pk=1)
>>> q.was_published_recently()
True

# Question nesnemize birkaç Choice nesnesi oluşturalım.
>>> q = Question.objects.get(pk=1)

# Bu Question nesnesine hiçbir Choice nesnesi bağlı değil(şimdilik)
>>> q.choice_set.all()
<QuerySet []>

# 3 Choice nesnesi oluşturalım.
>>> q.choice_set.create(choice_text='Not much', votes=0)
<Choice: Not much>
>>> q.choice_set.create(choice_text='The sky', votes=0)
<Choice: The sky>
>>> c = q.choice_set.create(choice_text='Just hacking again', votes=0)

# Choice nesnelerinin Question nesnelerine erişimi var.
>>> c.question
<Question: What's up?>

# Ve tam tersi: Question nesnelerinin de Choice nesnelerine erişimi var.
>>> q.choice_set.all()
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
>>> q.choice_set.count()
3

# API, ihtiyaç duyduğunuz kadarıyla ilişkileri otomatik olarak takip eder.
# İlişkileri ayırmak için çift alt çizgi kullanın.
# Bu, istediğiniz kadar derin bir seviyede çalışır. Sınır yok.
# Bir Question nesnesi için bu yıl yayımlanan tüm Choice nesnelerini bulalım.
# (Yukarıda oluşturduğumuz current_year değişkenini kullanalım).
>>> Choice.objects.filter(question__pub_date__year=current_year)
<QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

# delete() fonksiyonunu kullanarak bir Choice nesnesini silelim.
>>> c = q.choice_set.filter(choice_text__startswith='Just hacking')
>>> c.delete()

```

##### Yönetici Paneli

###### Bir yönetici kullanıcısı oluşturalım

Yönetici paneline giriş yapmak için bir süper kullanıcıya ihtiyacımız
var. Komut satırında şu kodu çalıştıralım:

```python
python manage.py createsuperuser

```

İstediğiniz kullanıcı adını girin ve entera basın:

```python
Username: admin

```

Sizden email adresi istenecektir. Doldurmak istemezseniz boş bırakın:

```python
Email address: admin@example.com

```

Son olarak şifrenizi girin. Sizden iki kere şifre isteyecek
(İkincisi doğrulama için).

```python
Password: **********
Password (again): *********
Superuser created successfully.

```

###### Geliştirme Sunucusunu Başlatın

Django’da yönetici paneli varsayılan olarak aktiftir. Geliştirme
sunucusunu başlatalım ve onu biraz araştıralım:

```python
python manage.py runserver

```

Şimdi tarayıcınızı açın ve yerel alan adınızda “/admin/” sayfasına
gidin.(Mesela şöylehttp://127.0.0.1:8000/admin/) Şöyle bir
yönetici sayfası görüyor olmalısın:

###### Yönetici Paneline Giriş yapalım

Şimdi oluşturduğun süper kullanıcı ile yönetici paneline giriş yap.
Yönetici panelinin anasayfasını görüyor olmalısın:

Birkaç düzenlenebilen içerik türü görmelisiniz: gruplar ve
kullanıcılar. Django tarafından gönderilen kimlik doğrulama
çerçevesidjango.contrib.authtarafından sağlanmıştır.

###### Anket uygulamamızı yönetici panelinden kontrol edelim

Fakat bizim anket uygulamamız nerede? Yönetici panelinin
anasayfasında gözükmüyor.

Bu sorunu çözmek için yapmanız gereken tek şey:
Yönetici paneline Question nesnelerimizin yönetici panelinden
düzenlenebildiğini söylemek. Bunu yapmak içinpolls/admin.pydosyasını açıp şu kodla düzenlemek:

```python
from django.contrib import admin
from .models import Question
admin.site.register(Question)

```

###### Yönetici panelinin işlevselliğini keşfedelim

Question nesnelerini kaydettiğimize göre yönetici panelinin
anasayfası şu şekilde gözükmeli:

Questionyazısına tıkla. Şimdi Question nesnelerinin değiştirme
sayfasındasın. Bu sayfa veritabanındaki tüm Question nesnelerini
gösterir ve değiştirmek için birini seçmeni sağlar. Şu an daha
önce oluşturduğumuz “What’s up?” nesnesi var:

Düzenlemek için “What’s up?” nesnesine tıkla:

Burada birkaç not:
- Bu form Question modelinden otomatik olarak oluşturulur.
- Farklı model alanlarına karşılık olarak uygun HTML etiketleri kullanılır.
- DateTimeField alanı için “Bugün” veya “Şimdi” gibi kısayollar bulunur.

Bu form Question modelinden otomatik olarak oluşturulur.

Farklı model alanlarına karşılık olarak uygun HTML etiketleri kullanılır.

DateTimeField alanı için “Bugün” veya “Şimdi” gibi kısayollar bulunur.

Alt tarafta birkaç ayar bulunuyor:
- Save – Değişiklikleri kaydeder ve değişiklik listesi sayfasına nesne tipini ekler.
- Save and continue editing – Değişiklikleri kaydeder ve sayfayı yeniden yükler.
- Save and add another – Değişiklikleri kaydeder ve yeni bir yükleme sayfası açar.
- Delete – Gösterilen nesneyi siler.

Save – Değişiklikleri kaydeder ve değişiklik listesi sayfasına nesne tipini ekler.

Save and continue editing – Değişiklikleri kaydeder ve sayfayı yeniden yükler.

Save and add another – Değişiklikleri kaydeder ve yeni bir yükleme sayfası açar.

Delete – Gösterilen nesneyi siler.

“Date Published” değeri, part 1’de oluşturduğunuz zamanla uyuşmuyorsa
muhtemelen TIME_ZONE ayarı için doğru değeri ayarlamamışsınız.
Değiştirin, sayfayı yeniden yükleyin ve doğru değerin görünüp görünmediğini
kontrol edin.

“Today” ve “Now” kısayollarını tıklayarak “Date Published” değerini değiştirin.
Ardından “Save and continue editing” i tıklayın. Daha sonra sağ üstteki
“History”yi tıklayın. Bu nesnede yapılan tüm değişiklikleri, değişikliği yapan
kişinin değişiklik yaptığı zaman ve kullanıcı adıyla listeleyen bir sayfa görürsünüz:

#### İLK DJANGO PROJENİ YAZ, part 3

##### Genel Bakış

Görünüm, genellikle belirli bir işleve hizmet eden ve belirli
bir şablona sahip olan Django uygulamanızdaki bir Web sayfası
türüdür. Örneğin, bir blog uygulamasında aşağıdaki viewları (viyıvları)
kullanabilirsiniz:
- Blog ana sayfası –> Son birkaç gönderiyi gösterir.
- Gönderi detay sayfası –> Gönderiye özel sayfa
- Yıl tabanlı arşiv sayfası –> Tüm ayları, belirli bir yıldaki gönderilerle birlikte görüntüler.
- Ay tabanlı arşiv sayfası –> Tüm günleri, belirli bir ay içindeki gönderilerle birlikte görüntüler.
- Gün tabanlı arşiv sayfası –> Belirtilen güne ait tüm kayıtları görüntüler.
- Yorum eylemi –> Belirli bir girdiye yorum gönderilmesini sağlar.

Blog ana sayfası –> Son birkaç gönderiyi gösterir.

Gönderi detay sayfası –> Gönderiye özel sayfa

Yıl tabanlı arşiv sayfası –> Tüm ayları, belirli bir yıldaki gönderilerle birlikte görüntüler.

Ay tabanlı arşiv sayfası –> Tüm günleri, belirli bir ay içindeki gönderilerle birlikte görüntüler.

Gün tabanlı arşiv sayfası –> Belirtilen güne ait tüm kayıtları görüntüler.

Yorum eylemi –> Belirli bir girdiye yorum gönderilmesini sağlar.

Anket uygulamamızda aşağıdaki dört viewa sahip olacağız:
- Soru dizin sayfası –> Son birkaç soruyu gösterir.
- Soru detay sayfası –> Bir soru metni görüntüler (sonuçsuz ancak oy kullanacak biçimdedir.).
- Soru sonuç sayfası –> Sorunun sonucunu gösterir.
- Oylama eylemi –> Belirli bir soruda belirli bir seçim için oylama yapar.

Soru dizin sayfası –> Son birkaç soruyu gösterir.

Soru detay sayfası –> Bir soru metni görüntüler (sonuçsuz ancak oy kullanacak biçimdedir.).

Soru sonuç sayfası –> Sorunun sonucunu gösterir.

Oylama eylemi –> Belirli bir soruda belirli bir seçim için oylama yapar.

Django’da web sayfaları ve diğer içerikler viewlara gönderilir.
Her view basit bir Python fonksiyonu ile ilişkilidir (veya sınıf temelli
viewlarda bir metotla). Django, istenen URL’yi (Alan adından sonra URL’nin
bir bölümü) inceleyerek bir view seçecektir .

Web’de bulunduğunuz süre içinde “ME2 / Siteler / dirmod.asp?
Sid = & type = gen & mod = Core + Sayfalar & gid = A6CD4967199
A42D9B65B1B” gibi güzelliklerle karşılaşmış olabilirsiniz.
Django’nun bize bundan daha zarif URL kalıpları sağladığını
bilmekten memnun olacaksınız.

Bir URL deseni basitçe genel bir URL formudur. Örneğin:/newsarchive/<year>/<month>/.

Bir URL’den viewa ulaşmak için Django,URLconfsolarak
bilinen şeyi kullanır. Bir URLconf, URL modellerini viewlara
eşler.

##### Birkaç view yazalım

Şimdipools/views.pydosyasına birkaç view daha ekleyelim.
Bu viewlar biraz farklı çünkü birer argümanları var:

```python
def detail(request, question_id):
 return HttpResponse("You're looking at question %s." % question_id)

def results(request, question_id):
 response = "You're looking at the results of question %s."
 return HttpResponse(response % question_id)

def vote(request, question_id):
 return HttpResponse("You're voting on question %s." % question_id)

```

Yeni viewlarımızıpools.urlsdosyasına path fonksiyonuyla
çağırarak ekleyelim:

```python
from django.urls import path

from . import views

urlpatterns = [
 # ex: /polls/
 path('', views.index, name='index'),
 # ex: /polls/5/
 path('<int:question_id>/', views.detail, name='detail'),
 # ex: /polls/5/results/
 path('<int:question_id>/results/', views.results, name='results'),
 # ex: /polls/5/vote/
 path('<int:question_id>/vote/', views.vote, name='vote'),
]

```

Tarayıcınıza “/polls/34/” sayfasına göz atın.detailfonksiyonu
çalışacak ve URL’de tanımladığınız ID her neyse onu gösterecektir.
“/Polls/34/results/” ve “/Polls/34/vote/” sayfalarını da deneyin.
Bunlar sonuç ve oylama sayfalarını gösterecektir.

Birisi sitenizden “/polls/34/” sayfasını istediğinde Djangomysite.urlsmodülünü çalıştırır. ÇünküROOT_URLCONFayarında
bu modül belirtilmiştir.urlpatternsisimli değişkeni bulur ve
desenleri sırayla geçirir. “polls/” eşleşmesini bulduktan sonra
eşleşen metni(“polls/”) çıkarır ve geri kalan metni(“34/”) işlemin
devamı içinpolls.urlsdosyasındaki URLconf’a gönderir.
Orada “<int:question_id>/” ile eşleşir vedetailviewı
şöyle bir çıktıyla çalışır:

```python
detail(request=<HttpRequest object>, question_id=34)

```

question_id=34kısmı<int:question_id>kısmından geliyor.
Küçüktür ve büyüktür işaretleri kullanmak URL’nin bir kısmını
yakalar ve viewa isimli parametre olarak yollar.:question_id>kısmı parametrenin ismini tanımlar.<int:kısmı ise yakalanması
gereken veri türünü belirtir.

URL’nin sonuna.htmlgibi ifadeler eklemeye gerek yok.
İsterseniz böyle bir şey yapabilirsiniz:

```python
path('polls/latest.html', views.index),

```

Fakat bunu yapmayın. Çok saçma.

##### Gerçekten bir şeyler yapan viewlar yazalım

Her view iki şeyi yapmak ile sorumludur:HttpResponsenesnesiyle
istenen sayfayı döndürmek veHttp404gibi bir hata oluşturmak.
Gerisi size kalmış.

Viewın bir veritabanındaki kayıtları okuyabilir.
Sayfa kalıplarını(template) kullanabilir(Django’nun ve 3. taraf
bir sayfa kalıbı). PDF, XML çıktısı veya ZIP dosyası oluşturabilir.
İstediğin Python kütüphanesini kullanabilir.

Pratik olduğu için Django’nun kendi veritabanı API’ını kullanalım.
İşte son 5 soruyu yayınlanma tarihine göre aralarına virgül
koyarak sıralayıp sunan bir index viewı:

```python
#polls/views.py
from django.http import HttpResponse

from .models import Question

def index(request):
 latest_question_list = Question.objects.order_by('-pub_date')[:5]
 output = ', '.join([q.question_text for q in latest_question_list])
 return HttpResponse(output)

# Diğer viewlar(detail, results, vote) değişmedi.

```

Burada bir problem var: Sayfanın düzeni viewdaki sabit koddan
ibaret. Eğer sayfanın görünüşünü değiştirmek istersen Python
kodunu düzenleyeceksiz. Django’nun sayfa kalıbı sistemi, viewın
kullanabileceği bir sayfa kalıbı oluşturarak tasarımı Python’dan
ayırır.

İlk öncepollsklasöründe birtemplatesklasörü oluştur.
Django sayfa kalıplarını burada arayacak.

ProjendekiTEMPLATESayarı Django’nun sayfa kalıplarını neye
göre yükleyip yorumlayacağını açıklar. Varsayılan olarakDjangoTemplateskullanılır. EğerAPP_DIRSseçeneğiTrueiseDjangoTemplatesINSTALLED_APPS’deki her uygulama dizinindetemplatesdizinini arar.

Yeni oluşturduğuntemplatesdizinindepollsisimli bir dizin
oluştur ve onun da içindeindex.htmlisimli bir dosya oluştur.
Diğer bir deyişle şablon şurada olmalı:polls/templates/polls/index.html.
Çünkü şablon yükleyicisi yukarıda anlatıldığı şekliyle çalıştığında
Django içindeki bu şablona kolaycapolls/index.htmlşeklinde
başvurabilirsiniz.

Aşağıdaki kodu bu şablona yerleştirin:

```python
{% if latest_question_list %}
 <ul>
 {% for question in latest_question_list %}
 <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>
 {% endfor %}
 </ul>
{% else %}
 <p>No polls are available.</p>
{% endif %}

```

Şimdipolls/views.pyindex viewını şablonu kullanacak şekilde
güncelleyelim:

```python
from django.http import HttpResponse
from django.template import loader

from .models import Question

def index(request):
 latest_question_list = Question.objects.order_by('-pub_date')[:5]
 template = loader.get_template('polls/index.html')
 context = {
 'latest_question_list': latest_question_list,
 }
 return HttpResponse(template.render(context, request))

```

Bu kodpolls/index.htmlisimli şablonu yükler ve bir içerik iletir.
Bu içerik şablonun değişken isimleriyle Python nesnelerini eşleştiren
bir sözlüktür.

Tarayıcınızda “/polls/” ekleyerek sayfayı yeniden yükleyin. Bir önceki
bölümden “What’s up” sorusunu içeren bir liste görmelisiniz. Link sorunun
detay sayfasına götürür.

##### render()

Bu şablon yüklemek için çok sıradan bir deyimdir, içeriği doldurur ve birHttpResponsenesnesiyle işlenmiş şablon sonucunu döndürür. Burada
index viewının tamamen tekrar yazılmış hali var:

```python
from django.shortcuts import render

from .models import Question

def index(request):
 latest_question_list = Question.objects.order_by('-pub_date')[:5]
 context = {'latest_question_list': latest_question_list}
 return render(request, 'polls/index.html', context)

```

Bunu tüm bu görünümlerde yaptıktan sonra, artık yükleyici ve
HttpResponse’yi içe aktarmamız gerekmiyor (detay, sonuç ve oylama
için hala bu yöntemleri kullanıyorsanızHttpResponse’yi tutmak
isteyeceksiniz).

renderfonksiyonu, ilk parametre olarakrequestnesnesini, ikinici
parametre olarak şablonun adını ve üçüncü parametre olarak isteğe bağlı
bir sözlük alır. İçerikle işlenmiş şablonunHttpResponsenesnesini döndürür.

##### 404 hatası

Şimdi soru detay sayfasını ele alalım. Bu sayfa verilen anket için
soru metnini gösterir. Bu işi sağlayan view:

```python
from django.http import Http404
from django.shortcuts import render

from .models import Question
# ...
def detail(request, question_id):
 try:
 question = Question.objects.get(pk=question_id)
 except Question.DoesNotExist:
 raise Http404("Question does not exist")
 return render(request, 'polls/detail.html', {'question': question})

```

Buradaki yeni olayımız şu: İstenen kimliğe sahip bir soru yoksa viewHttp404hatası yollar.

polls/detail.htmlşablonuna ne koyabildiğimizi tartışacağız ancak
yukarıdaki örneği hızlıca çalıştırmak istiyorsanız sadece şunu yazın:

```python
{{ question }}

```

Bu başlamak için yeterli.

##### get_object_or_404()

Bu eğer nesne varsagetfonksiyonunu kullanarak nesneyi getirir, yoksaHttp404hatası yollar. Burada detay viewının tamamen tekrar yazılmış
hali var:

```python
from django.shortcuts import get_object_or_404, render

from .models import Question
# ...
def detail(request, question_id):
 question = get_object_or_404(Question, pk=question_id)
 return render(request, 'polls/detail.html', {'question': question})

```

get_object_or_404()fonkiyonu ilk parametre olarak Django modelini
vegetfonksiyonuna vermek için istediğiniz sayıda isimli parametreyi alır.
Eğer nesne yoksaHttp404hatası yollar.

Ayrıca,get_object_or_404fonksiyonu üzerine kuruluget_list_or_404fonkiyonu da vardır. Tek farkıgetyerinefilterkullanır. Eğer liste
boşsaHttp404hatası verir.

##### Şablon sistemi kullanalım

Anket uygulamanızdaki detay viewına geri dönelim. İçerik değişkeniquestiongöz önüne alınıp tekrar yazıldığındapolls/detail.htmlşablonu şöyle görülmeli:

```python
<h1>{{ question.question_text }}</h1>
<ul>
{% for choice in question.choice_set.all %}
 <li>{{ choice.choice_text }}</li>
{% endfor %}
</ul>

```

Şablon sistemi değişken özelliklerine erişmek için nokta arama
sözdizimini kullanır.{{ question.question_text }}örneğinde Django önce
sözlüktequestionnesnesini arar. Bunu başaramazsa, bu durumda çalışan
bir öznitelik aramaya çalışır. O da başarısız olsaydı, liste
dizini aramayı denerdi.

question.choice_set.allmetodu{% for %}döngüsünde çağırılır. Metod
Choice nesnelerini iterable olarak döndüren ve{% for %}döngüsünde
kullanmak için en müsait kod olanquestion.choice_set.all()olarak yorumlanır.

##### Şablonlardaki sabit URL’leri kaldıralım

Hatırla,polls/index.htmlşablonunda sorular için link yazdığımızda
linki kısmen böyle kodlamıştık:

```python
<li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li>

```

Bu kodlamada tipinde çok sayıda şablon içeren projelerde URL’leri
değiştirmeye kalktığımızda sorun ortaya çıkıyor. Bununla
birlikte,polls.urlsmodülünde path fonksiyonlarındanamedeğişkenini tanımladığımızdan, url yapılandırmalarınızda tanımlanmış
belirli URL yolları üzerine kurulu düzeni{% url%}template
etiketini kullanarak kaldırabilirsiniz:

```python
<li><a href="{% url 'detail' question.id %}">{{ question.question_text }}
</a></li>

```

Bunun çalışma şekli, polls.urls modülünde belirtilen URL tanımını
aramaktır. Tam olarak ‘detail’ URL’sinin adının nerede tanımlandığını
görebilirsiniz:

```python
...
# {% url %} şablon etiketiyle çağrılan 'name' değeri
path('<int:question_id>/', views.detail, name='detail'),
...

```

Eğer anket detay sayfasının URL’sini değiştirmek istersen -mesela “polls/specifics/12/”
gibi- bunu şablon ya da şablonlarda yapmak yerinepolls/urls.py’de
yapmanız yeterli:

```python
...
# 'specifics' sözcüğü eklendi.
path('specifics/<int:question_id>/', views.detail, name='detail'),
...

```

##### URL alanları

Bu öğretici bir uygulamaya sahip:polls. Gerçek bir Django projesi
belki beş belki on belki daha fazla uygulamaya sahip olur. Peki Django
farklı URL alanlarını nasıl birbirinden ayırır? Meselapollsuygulaması
detay viewına sahip ve aynı projede bir debloguygulaması detay sayfasına sahip.
Django hangi uygulamanın viewının çağırıldığını nasıl bilebilir?

Cevap: URL şemasına alan adı eklemek. Alan adı oluşturmak içinpolls/urls.pydosyasındaapp_namedeğişkeni ekleyelim:

```python
from django.urls import path

from . import views

app_name = 'polls'
urlpatterns = [
 path('', views.index, name='index'),
 path('<int:question_id>/', views.detail, name='detail'),
 path('<int:question_id>/results/', views.results, name='results'),
 path('<int:question_id>/vote/', views.vote, name='vote'),
]

```

Şimdipolls/index.htmlşablonunda değiştirelim:

```python
<li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li>

```

#### İLK DJANGO PROJENİ YAZ, part 4

##### Basit bir form yazalım

Hadi bir<form>etiketi içerecek şekilde anket detay
şablonumuzu (“polls/detail.html”) güncelleyelim:

```python
<h1>{{ question.question_text }}</h1>

{% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

<form action="{% url 'polls:vote' question.id %}" method="post">
{% csrf_token %}
{% for choice in question.choice_set.all %}
 <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}">
 <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br>
{% endfor %}
<input type="submit" value="Vote">
</form>

```

Hızlı bir özet:
- Yukarıdaki şablon, her soru seçimi için bir radyo düğmesi görüntüler.
Her radyo düğmesinin değeri, ilişkili soru seçiminin ID’sidir.
Her radyo düğmesinin adı “choice” dır. Bunun anlamı, biri radyo
düğmelerinden birini seçip formu gönderdiğinde POST yöntemi ile şu veri
yollanır:choice=#ID#. BuradaIDdeğeri seçilen butonunid’sidir.
HTML formları böyle çalışır.
- Formunactiondeğerini{% url ‘polls:vote’ question.id %}olarak ayarladık.
vemethod=”post”ayarını da ekledik.method=”post”yazmak çok önemli
(Alternatifi:method=”get”). Çünkü sunucu tarafıyla yapılan veri alışverişinin
yönteminini belirler. Bir veri alışverişi yapan bir form oluşturduğunda
hepmethod=”post”kullan.Bu Django’ya özel bir durum değil, iyi bir Web
geliştirme yöntemi.
- forloop.counterdeğişkeni içinde bulunduğufordöngüsünün kaç kez
döndüğünü tutar.
- Bir POST formu oluşturduğumuzdan (bu verileri değiştirme etkisi
yapabilir), Siteler Arası İstek Sahteciliği (Cross Site Request Forgeries)
konusunda endişelenmemiz gerekir. Neyse ki, çok fazla endişelenmenize gerek yok,
çünkü Django buna karşı korumak için kullanımı kolay bir sistemle
birlikte geliyor.Kısacası, dahili URL’leri hedef alan tüm POST formları,{% csrf_token%}şablon etiketini kullanmalıdır.

Yukarıdaki şablon, her soru seçimi için bir radyo düğmesi görüntüler.
Her radyo düğmesinin değeri, ilişkili soru seçiminin ID’sidir.
Her radyo düğmesinin adı “choice” dır. Bunun anlamı, biri radyo
düğmelerinden birini seçip formu gönderdiğinde POST yöntemi ile şu veri
yollanır:choice=#ID#. BuradaIDdeğeri seçilen butonunid’sidir.
HTML formları böyle çalışır.

Formunactiondeğerini{% url ‘polls:vote’ question.id %}olarak ayarladık.
vemethod=”post”ayarını da ekledik.method=”post”yazmak çok önemli
(Alternatifi:method=”get”). Çünkü sunucu tarafıyla yapılan veri alışverişinin
yönteminini belirler. Bir veri alışverişi yapan bir form oluşturduğunda
hepmethod=”post”kullan.Bu Django’ya özel bir durum değil, iyi bir Web
geliştirme yöntemi.

forloop.counterdeğişkeni içinde bulunduğufordöngüsünün kaç kez
döndüğünü tutar.

Bir POST formu oluşturduğumuzdan (bu verileri değiştirme etkisi
yapabilir), Siteler Arası İstek Sahteciliği (Cross Site Request Forgeries)
konusunda endişelenmemiz gerekir. Neyse ki, çok fazla endişelenmenize gerek yok,
çünkü Django buna karşı korumak için kullanımı kolay bir sistemle
birlikte geliyor.Kısacası, dahili URL’leri hedef alan tüm POST formları,{% csrf_token%}şablon etiketini kullanmalıdır.

Şimdi, gönderilen verileri işleyen ve onunla bir şeyler yapan bir Django
viewı oluşturalım. Hatırla, part 3’te anket uygulaması için bu
satırı içeren bir URLconf oluşturduk:

```python
path('<int:question_id>/vote/', views.vote, name='vote'),

```

Ayrıca göstermelik birvoteviewı yazmıştık. Hadi gerçek bir viewa
çevirelim:

```python
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse

from .models import Choice, Question
# ...
def vote(request, question_id):
 question = get_object_or_404(Question, pk=question_id)
 try:
 selected_choice = question.choice_set.get(pk=request.POST['choice'])
 except (KeyError, Choice.DoesNotExist):
 # Soru oylama formunu tekrar göster
 return render(request, 'polls/detail.html', {
 'question': question,
 'error_message': "You didn't select a choice.",
 })
 else:
 selected_choice.votes += 1
 selected_choice.save()
 # POST verileriyle başarılı bir şekilde ilgilendikten sonra
 # daima bir HttpResponseRedirect döndürün. Bu, bir kullanıcı
 # geri düğmesine basarsa verilerin iki kez gönderilmesini önler.
 return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

```

Bu kod, henüz görmediğimiz bazı şeyleri içeriyor:
- request.POST, gönderilen verilere anahtar adına göre erişmenizi sağlayan,
sözlük benzeri bir nesnedir. Bu durumda,request.POST[‘choice’]seçilen seçeneğin kimliğini
bir karakter dizisi olarak döndürür.request.POSTdeğerleri her zaman
karakter dizisidir.

request.POST, gönderilen verilere anahtar adına göre erişmenizi sağlayan,
sözlük benzeri bir nesnedir. Bu durumda,request.POST[‘choice’]seçilen seçeneğin kimliğini
bir karakter dizisi olarak döndürür.request.POSTdeğerleri her zaman
karakter dizisidir.

> **Not**
> Django’nun GET verilerine aynı şekilde erişmek için derequest.GETsağladığını unutmayın. Ancak verilerin yalnızca
bir POST çağrısı yoluyla değiştirilmesini sağlamak için kodumdarequest.POSTaçıkça kullanıyoruz.

Not

Django’nun GET verilerine aynı şekilde erişmek için derequest.GETsağladığını unutmayın. Ancak verilerin yalnızca
bir POST çağrısı yoluyla değiştirilmesini sağlamak için kodumdarequest.POSTaçıkça kullanıyoruz.
- POST verilerinde seçim yapılmadıysa,request.POST[‘choice’]KeyErrorhatası
verir. Yukarıdaki kodKeyError’u kontrol eder ve seçim yapılmadığı takdirde
soru formunu hata mesajı ile yeniden görüntüler.
- Seçim sayısını artırdıktan sonra, kod normal birHttpResponseyerine birHttpResponseRedirectdöndürür.HttpResponseRedirecttek bir argüman alır:
kullanıcının yönlendirileceği URL.
- Bu örnekteHttpResponseRedirectyapıcısındareversefonksiyonunu
kullanıyoruz. Bu fonksiyon, görüntüleme işinde bir URL’yi sabit olmaktan
kurtarmanıza yardımcı olur. Çalıştırmak istediğimiz viewın adı ve bu
viewa işaret eden URL modelinin değişken kısmı verilir. Bu durumda,
part 3’te kurduğumuz URLconf’u kullanarak, bureverseçağrısı bir karakter
dizisi döndürür. Bunun gibi:'/polls/3/results/'

POST verilerinde seçim yapılmadıysa,request.POST[‘choice’]KeyErrorhatası
verir. Yukarıdaki kodKeyError’u kontrol eder ve seçim yapılmadığı takdirde
soru formunu hata mesajı ile yeniden görüntüler.

Seçim sayısını artırdıktan sonra, kod normal birHttpResponseyerine birHttpResponseRedirectdöndürür.HttpResponseRedirecttek bir argüman alır:
kullanıcının yönlendirileceği URL.

Bu örnekteHttpResponseRedirectyapıcısındareversefonksiyonunu
kullanıyoruz. Bu fonksiyon, görüntüleme işinde bir URL’yi sabit olmaktan
kurtarmanıza yardımcı olur. Çalıştırmak istediğimiz viewın adı ve bu
viewa işaret eden URL modelinin değişken kısmı verilir. Bu durumda,
part 3’te kurduğumuz URLconf’u kullanarak, bureverseçağrısı bir karakter
dizisi döndürür. Bunun gibi:

```python
'/polls/3/results/'

```

Burada3question.iddeğeridir. Bu yeniden yönlendirilen URL daha sonra
son sayfayı görüntülemek için ‘results’ viewını çağırır.

Birisi bir soruya oy verdikten sonra,voteviewı sorunun sonuç sayfasına
yönlendirir. Bu görünümü yazalım:

```python
from django.shortcuts import get_object_or_404, render

def results(request, question_id):
 question = get_object_or_404(Question, pk=question_id)
 return render(request, 'polls/results.html', {'question': question})

```

Bu part 3’te yazdığımızdetailviewıyla hemen hemen aynı.
Tek fark şablon adı. Bu gereksizliği daha sonra düzeltiriz.

Şimdipolls/results.htmlşablonunu oluşturalım:

```python
<h1>{{ question.question_text }}</h1>

<ul>
{% for choice in question.choice_set.all %}
 <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
{% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote again?</a>

```

Şimdi tarayıcında/polls/1/adresine git ve soruyu oyla. Her oy verdiğinizde
güncellenen bir sonuç sayfası görmelisiniz. Bir seçim yapmadan formu
gönderirseniz, hata mesajını görmelisiniz.

##### Kalıp viewlar kullanalım

detailveresultsviewları çok basitve biraz da gereksizler. Anketlerin
listesini görüntüleyen index() viewı da onlara benzer bir viewdır.

Bu viewlar, temel bir Web geliştirme durumunu gösterir: Veritabanından
URL’deki parametreye göre veri almak, şablon yüklemek ve işlenmiş şablonu
döndürmek. Bu çok yaygın olduğu için Django “Kalıp view” adında bir kolaylık
sağlar.

Kalıp viewlar, bir uygulama yazmak için Python kodunu yazmanız gerekmediği
noktaya ortak kalıpları soyutlar.

Kalıp view sistemini kullanmak için anket uygulamamızı düzenleyelim.
Böylece gereksiz bir takım kodu silebiliriz. Düzenlememizde şu
adımları uygulayacağız:
1. URLconf’u değiştir.
1. Gereksiz viewlardan bazılarını sil.
1. Django’nun kalıp viewlarını temel alan yeni viewlar yaz.

URLconf’u değiştir.

Gereksiz viewlardan bazılarını sil.

Django’nun kalıp viewlarını temel alan yeni viewlar yaz.

###### URLconf’u değiştir

İlk önce,polls/urls.pydosyasını açın veURLconf’u şöyle değiştirin:

```python
from django.urls import path

from . import views

app_name = 'polls'
urlpatterns = [
 path ( '' , views . IndexView . as_view (), name = 'index' ),
 path ( '<int:pk>/' , views . DetailView . as_view (), name = 'detail' ),
 path ( '<int:pk>/results/' , views . ResultsView . as_view (), name = 'results' ),
 path ( '<int:question_id>/vote/' , views . vote , name = 'vote' ),
]

```

İkinci ve üçüncü desenlerin yol dizilerinde eşleşen kalıbın adının<question_id>’den<pk>’ye değiştiğini

###### Görünümleri değiştir

Şimdiindex,`detail` veresultsviewlarını kaldıracağız ve Django’nun
kalıp viewlarını kullanacağız. Bunu yapmak içinpolls/views.pydosyasını aç ve buna benzer şekilde değiştir:

```python
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views import generic

from .models import Choice, Question

class IndexView(generic.ListView):
 template_name = 'polls/index.html'
 context_object_name = 'latest_question_list'

 def get_queryset(self):
 """Return the last five published questions."""
 return Question.objects.order_by('-pub_date')[:5]

class DetailView(generic.DetailView):
 model = Question
 template_name = 'polls/detail.html'

class ResultsView(generic.DetailView):
 model = Question
 template_name = 'polls/results.html'

def vote(request, question_id):
 ... # yukarıdakiyle aynı, hiçbir değişiklik yok.

```

Burada iki kalıp view kullanıyoruz:ListViewveDetailView.ListViewnesnelerin listesini gösterir.DetailViewise belirli bir nesne türünün
detay sayfasını gösterir.
- Her kalıp viewın hangi modele etki edeceğini bilmesi gerekir. Bu model
özniteliği kullanılarak sağlanır.
- DetailView kalıp viewı, URL’den yakalanan birincil anahtar değerininpkolarak adlandırılmasını bekler. Bu nedenle kalıp viewlar içinquestion_idifadesinipkolarak değiştirdik.

Her kalıp viewın hangi modele etki edeceğini bilmesi gerekir. Bu model
özniteliği kullanılarak sağlanır.

DetailView kalıp viewı, URL’den yakalanan birincil anahtar değerininpkolarak adlandırılmasını bekler. Bu nedenle kalıp viewlar içinquestion_idifadesinipkolarak değiştirdik.

Varsayılan olarak, DetailView kalıp viewı<app name>/<model name>_detail.htmladlı bir şablon kullanır. Bizim
durumumuzdapolls/question_detail.htmlşablonunu kullanırdı.template_nameözelliği, Django’ya otomatik olarak oluşturulan varsayılan
şablon adı yerine belirli bir şablon adı kullanmasını bildirmek için
kullanılır. Bu,resultsviewının vedetailviewının, her ikisi de
sahne arkasındaki DetailView olsa bile, farklı bir şablona sahip olmasını
sağlar.

DurumListViewveIndexViewiçin de aynı.

Sunucuyu çalıştırın ve kalıp viewları temel alan yeni anket uygulamanı dene.

#### İçerik İşlemcileri

##### İçerik İşlemcileri Nedir

Dilden bağımsız olarak yazdığımız her uygulama DRY (Don’t Repeat Yourself, Kendini Tekrar Etme) ilkesine sahip olmalıdır.
Bu sayede yazılan kodların okunabilirliği daha yüksek, fazlalıkları ve karmaşıklıkları daha az olur.

Django yazılım iskeletinde içerik işlemcileri bu işe yarar. Bir kere tanımlanan değişken o proje içinde
oluşturulan tüm uygulamalarda kullanılabilir.

Oluşturduğumuz her içerik işlemcisi biranahtar(lar)-değer(ler)şeklinde dönmelidir. Bu değer tipi Python dilinin
sahip olduğu veri tipi olansözlüktür.

##### İçerik İşlemcileri Nasıl Oluşturulur?

Öncelikle bir Django projesi ve projemiz için bir uygulama oluşturuyoruz. Oluşturduğumuz uygulamanın içinecontext_processors.pyisimli bir dosya oluşturuyoruz. Bundan sonra oluşturduğumuz tüm içerik işleyicilerini bu dosya altında toplayacağız. Son olarak oluşturduğumuzcontext_processors.pydosyasınısettings.pydosyasının altında projemize bildirmemiz gerekir. Bunun içinsettings.pydosyasını açıp

```python
TEMPLATES = [
{
 'BACKEND': 'django.template.backends.django.DjangoTemplates',
 'DIRS': [os.path.join(BASE_DIR, 'templates')]
 ,
 'APP_DIRS': True,
 'OPTIONS': {
 'context_processors': [
 'django.template.context_processors.debug',
 'django.template.context_processors.request',
 'django.contrib.auth.context_processors.auth',
 'django.contrib.messages.context_processors.messages',
 ],
 },
},
]

```

bu kısmı buluyoruz. Ardından kendi oluşturacağımız içerik işleyicilerini diğerlerinin yanına ekliyoruz. Bu ekleme sırasında sözdizimi önemlidir ve bu şekilde olmalıdır.uygulama_adi.içerik_işlemcisi_dosya_adi.içerik_işlemcisi_adiYeni hali aşağıdaki gibi olmalı.

```python
TEMPLATES = [
{
 'BACKEND': 'django.template.backends.django.DjangoTemplates',
 'DIRS': [os.path.join(BASE_DIR, 'templates')]
 ,
 'APP_DIRS': True,
 'OPTIONS': {
 'context_processors': [
 'django.template.context_processors.debug',
 'django.template.context_processors.request',
 'django.contrib.auth.context_processors.auth',
 'django.contrib.messages.context_processors.messages',
 'deneme.context_processors.ilk_islec',
 ],
 },
},
]

```

İlk işlecimiz basit olması amacıyla isim ve ülke döndürsün. Bunun içincontext_processors.pyve ilk işlecimizi yazalım. Yazacağımız işleçler fonksiyon şeklinde olmalıdır ve bu fonksiyonrequestparametresini dışarıdan almalıdır.

```python
def ilk_islec(request):
 isim = "Mehmet"
 ulke = "Türkiye"

 return {'isim': isim, 'ulke': ulke}

```

Bu şekilde ilk işlecimizi yazdık şimdiisimveulkeadında iki tane anahtar değer döndürdük. Bu değerleri istediğimiz HTML sayfasında kullanabiliriz.
Denemek içintemplatesklasörü altındaindex.htmloluşturalım ardından HTML dosyasmıza aşağıdaki kodu yazalım.

```python
<!DOCTYPE html>
<html>
<head>
 <title>Django - İçerik İşlemcileri</title>
</head>
<body>

<p>Merhaba, benim adım {{ isim }} ve şu an bu ülkedeyim: {{ ulke }} </p>

</body>
</html>

```

HTML sayfasımızı oluşturduktan
sonra view oluşturacağız. Bunun için oluşturduğumuz uygulamanın alt dizininde bulunanviews.pydosyasına

```python
from django.shortcuts import render

def view(request):
 return render(request, 'index.html')

```

Şeklinde basit bir view fonksiyonu ekleyelim. Son olarakurls.pydosyasına yazdığımız view için URL yolu ekleyeceğiz.

```python
from django.urls import path
from deneme.views import view

urlpatterns = [
 path('index', view),
]

```

Tüm yapacağımız bu kadar! Artık tarayıcıda oluşturduğumuz sayfayı çalıştırınca anahtarlarımızın yerinde değişkenlerimiz var.

##### İçerik İşlemcileri Nerelerde Kullanılabilir?

Django ile proje geliştirirken kullanıcının tarayıcıda göreceği HTML kısımlarını ortak olan kısımlarını tek bir noktadan
çekebiliriz. Böylece ortak bir blok değiştiği zaman tüm sayfaları tekrar düzeltmeye gerek kalmaz. Bunu yapmak için oluşturduğumuz tüm view’lere
ana tema blogumuzu, tüm sayfalarda ortak olan diğer blok parçalarının yollarını içerik işlecinde tanımlayabiliriz.

İçerik İşlemcimiz:

```python
def template_path(request):
base_dir = os.path.dirname(os.path.dirname(__file__))
components_dir = os.path.join(base_dir, 'templates/components/')
base_component = os.path.join(components_dir, 'base_components/base.html')
common_components = os.path.join(components_dir, 'common_components/')
archive = os.path.join(common_components, 'archive.html')
quick_links = os.path.join(common_components, 'quick_links.html')
search_not_found = os.path.join(common_components, 'search_not_found.html')
social_account = os.path.join(common_components, 'social_account.html')
tag_cloud = os.path.join(common_components, 'tag_cloud.html')
blockquote = os.path.join(common_components, 'blockquote.html')

return {'base_components': base_component, 'archive': archive, 'quick_links': quick_links,
 'search_not_found': search_not_found, 'social_account': social_account, 'tag_cloud': tag_cloud,
 'blockquote': blockquote}

```

HTML Sayfamız:

```python
{% extends base_components %}
{% block title %}İletişime Geç {% endblock %}
{% block s_content %}
 <!-- s-content
 ================================================== -->
 <section class="s-content s-content--narrow">
 <div class="row">
 <div class="s-content__header col-full">
 <h1 class="s-content__header-title">
 İletişime Geç </h1>
 </div> <!-- end s-content__header -->
 <div class="col-full s-content__main">
 <h3>Merhaba De :)</h3>
 <p class="lead">Sosyal medya hesapları üzerinden bana ulaşabilirsin. </p>
 <ul class="s-content__author-social" style="display: flex; justify-content: center">
 {% for i in social %}
 <li>
 <a href="{{ i.sm_url }}" target="_blank"><i class="{{ i.sm_icon_class }}"
 style="font-size: 48px"
 aria-hidden="true"></i></a>
 </li>
 {% endfor %}
 </ul>
 </div> <!-- end s-content__main -->
 </div> <!-- end row -->
 </section> <!-- s-content -->
 <{% endblock %}

```

Örnek HTML sayfamızda{% extends base_components %}ilebase_componentsdeğişkenini içerik işlemcisinde tanımlamıştık, bu sayede bir daha
dosya adresini yazmamıza gerek kalmaz. Bunun yerine her view’de dosya yolunu yazabilirdik ancak dosyamızın yolu değişirse tüm view fonksiyonlarında
dosya yolunu değiştirmek zorunda kalacaktık.

Genel olarak kullanım şekli böyle oluyor.

Bu makale için hazırladığım kodabu adresüzerinden ulaşabilir, bu kodu detaylı olarak inceleyebilirsiniz.

#### Django ile reCAPTCHA Kullanımı
1. Giriş.1.1 reCAPTCHA Nedir?

1.1 reCAPTCHA Nedir?

1.2 Neden reCAPTCHA Kullanmalıyım?

Bir yorum sistemi düşünelim herhangi bir güvenlik önlemi olmayan, bir gece basit bir saldırı ile milyonlarca istenmeyen yorum eklenebilir.
Bu tür olayların önüne geçmek için bazı önlemler alabiliriz. Yorum eklerken basit bir matematik sorusu veya
eski yöntem captcha kullanabiliriz ancak bunlar artık pek kullanışlı değiller. En basitinden eski usul captchalar size
bozulmuş bir görüntü verir ve o görüntüde bulunan matematik işlemini veya harfleri ister. Bazen bunlar aşırı bozulmalar oluyor ve
görüntünün okunması neredeyse imkânsız hale geliyor. Bunun yerine reCAPTCHA gibi bir servis kullanarak bu tür sıkıntıların önüne geçebiliriz.
1. Kurulum.2.1 reCAPTCHA Servisine Kayıt Olmak.

2.1 reCAPTCHA Servisine Kayıt Olmak.

reCAPTCHA kullanmak için öncelikle sitesi üzerinden bir uygulama oluşturmak gerekli.
Buadresüzerinden Google reCAPTCHA servisine kaydolmak gerekli.

Kaydolma sayfasını açtığımız zaman bizi böyle bir sayfa karşılıyor. Burada bulunan bölümleri açıklayalım.
- Etiket: Uygulamamızı açıklayacak isim.
- reCAPTCHA türü: İnternet sitemizde kullanacağımız reCAPTCHA türünü buradan seçiyoruz.reCAPTCHA s3: Bu sürümde kullanıcının bot olup olmadığını bir puan yardımıyla hesaplayan ve size bu puanı döndüren bir Javascript API’dır.reCAPTCHA s2: Kullanıcı isteklerini yine kullanıcının eylemleri ile doğrulayan sürümdür.“Robot değilim” Onay Kutusu: Kullanıcıya “Ben Robot Değilim” şeklinde bir kutu işaretletir.

Etiket: Uygulamamızı açıklayacak isim.
- reCAPTCHA s3: Bu sürümde kullanıcının bot olup olmadığını bir puan yardımıyla hesaplayan ve size bu puanı döndüren bir Javascript API’dır.
- reCAPTCHA s2: Kullanıcı isteklerini yine kullanıcının eylemleri ile doğrulayan sürümdür.
- “Robot değilim” Onay Kutusu: Kullanıcıya “Ben Robot Değilim” şeklinde bir kutu işaretletir.

reCAPTCHA s3: Bu sürümde kullanıcının bot olup olmadığını bir puan yardımıyla hesaplayan ve size bu puanı döndüren bir Javascript API’dır.

reCAPTCHA s2: Kullanıcı isteklerini yine kullanıcının eylemleri ile doğrulayan sürümdür.

“Robot değilim” Onay Kutusu: Kullanıcıya “Ben Robot Değilim” şeklinde bir kutu işaretletir.
- Görünmez reCAPTCHA rozeti: İstekleri arka planda doğrular. Görünmez reCAPTCHA rozeti ile kullanıcının bir onay kutusuna tıklaması gerekmez. Bunun yerine kullanıcı sitenizde bulunan düğmeye tıkladığı zaman bir Javascript API çağrısı başlatılır.

Görünmez reCAPTCHA rozeti: İstekleri arka planda doğrular. Görünmez reCAPTCHA rozeti ile kullanıcının bir onay kutusuna tıklaması gerekmez. Bunun yerine kullanıcı sitenizde bulunan düğmeye tıkladığı zaman bir Javascript API çağrısı başlatılır.
- reCAPTCHA v2 (Android): Android servisleri için kullanılacak olan seçimdir.

reCAPTCHA v2 (Android): Android servisleri için kullanılacak olan seçimdir.

Detaylar içinadresebakabilirsiniz.
- Alan Adları: Bu uygulamayı hazırlayacağınız servislerin hangi alan adları altında kullanacağınızı belirler.

Alan Adları: Bu uygulamayı hazırlayacağınız servislerin hangi alan adları altında kullanacağınızı belirler.

Not: Kayıt işleminiz burada girdiğiniz alan adları ve alt alan adlarıyla sınırlıdır. Başka bir deyişle example.com kayıt işlemi subdomain.example.com adresini de kaydeder. Geçerli bir alan adında ana makine bulunmalıdır; yol, bağlantı noktası, sorgu veya parça bulunmamalıdır.
- Sahipler: reCAPTCHA uygulamasına yeni yöneticiler ekleyebilirsiniz. Varsayılan olarak sizin hesabınız eklidir.
- reCAPTCHA Hizmet Şartları’nı kabul edin: Servisi kullanmak için servis sahibi tarafından bizlere sunulan şartları kabul etmemiz gerekli.
- Site sahiplerine uyarı gönder: Şüpheli trafik gibi durumlarda mail yardımıyla uyarılar gönderir.

Sahipler: reCAPTCHA uygulamasına yeni yöneticiler ekleyebilirsiniz. Varsayılan olarak sizin hesabınız eklidir.

reCAPTCHA Hizmet Şartları’nı kabul edin: Servisi kullanmak için servis sahibi tarafından bizlere sunulan şartları kabul etmemiz gerekli.

Site sahiplerine uyarı gönder: Şüpheli trafik gibi durumlarda mail yardımıyla uyarılar gönderir.

Yapılandırma işlemi oldukça kolay biz bu metin boyunda reCAPTCHA s2Robot Değilimonay kutusunu kullanacağız.
Uygulamamızı kayıt ettiğimiz zaman bize iki adet anahtar hazırlanacak.
Bu anahtarlardanSite Anahtarıolan sitemizin HTML tarafındaGizli Anahtarolan ise sitemizin arka planında olacaktır.Gizli Anahtarı asla kullanıcılar ile paylaşmayın ve sitenizin HTML tarafında kullanmayınız.

reCAPTCHA tarafıyla işimiz bitti. Şimdi reCAPTCHA’yı uygulamamıza entegre etme kaldı.

reCAPTCHA servisini sitemize eklerken iki aşamalı olarak yapacağız. İlk aşaması sitemizin ön yüz için ikincisi için arka uç tarafında yapacağız. Bu belgede anlatılacak reCAPTCHA servisini bir yorum sistemine ekleyeceğiz.

2.2.1 reCAPTCHA Servisini Ön Yüz için Hazırlama.

Google Geliştirici Belgelerinebaktığımız zaman ön yüz tarafı için işimiz aşırı kolay. Öncelikle reCAPTCHA Javascript dosyasını projemize dahil ediyoruz.:

```python
<script src="https://www.google.com/recaptcha/api.js" async defer></script>

```

reCAPTCHA servisne ihtiyaç duyduğumuz forma aşağıdaki kodu ekliyoruz.:

```python
<div class="g-recaptcha" data-sitekey="your_site_key"></div>

```

2.2.2 reCAPTCHA Servisini Arka Uç Tarafına Ekleme.

Kendimize örnek bir proje ve bu proje için bir uygulama oluşturuyoruz. Gerekli anlatımlar önceki derslerde mevcuttur. Öncelikle örnek bir model oluşturuyoruz. Ben reCAPTCHA servisini yorum sisteminde kullanacağım içi yorumlar için bir model oluşturuyorum.

```python
from django.db import models

class Comments(models.Model):
 id = models.AutoField(primary_key=True)
 name = models.CharField(max_length=55, verbose_name='Kullanıcı Adınız')
 comment = models.TextField(verbose_name='Yorumunuz')

```

Ardından yorum uygulamamızın içineforms.pyadında bir dosya oluşturuyoruz.

```python
from django import forms
from blog.models import *

class CommentForm(forms.ModelForm):
 class Meta:
 model = Comments
 fields = [
 'name',
 'comment',
 ]

```

Şimdi ise kullanıcıyı karşılayacak sayfayı yazıyoruz.templatesklasörü altındaindex.htmladında bir dosya oluşturalım ve içine bu kodları yazalım.

```python
<html>
<head>
 <title>reCAPTCHA Demo</title>
 <script src="https://www.google.com/recaptcha/api.js" async defer></script>
</head>
<body>
<h4>Yorum Gönder</h4>
<form method="POST">
 {% csrf_token %}
 {{ form.as_p }}
 <div class="g-recaptcha" data-sitekey="6LdBO6cZAAAAAKVrVb26js1qHkeg23ks213nQgpBq7L6dva9lMuwTmX"></div>
 <br/>
 <input type="submit" value="Gönder">
</form>
<hr>
<h4>Gelen Yorumlar:</h4>
<hr>
{% for comment in comments %}
 <p><b>İsim: {{ comment.name }}</b> <br>Yorum: <b>{{ comment.comment }}</b></p>
 <hr>
{% endfor %}
</body>
</html>

```

Kısaca HTML kodlarımızdan bahsedersekPOSTyöntemiyle gönderilecek bir form hazırladık. Ardından{% csrf_token %}değişkenini ekledik. Böylece formumuz doğru şekilde çalışacak. Ardındanforms.py`sayfasında hazırladığımız formu kullanıcıya gösteriyoruz. Son olarak da Google Belgelerinde aldığımız reCAPTCHA kodunu ekledik.
Gelen yorumlar kısmında ise başarıyla kaydedilen yorumlar yer alacak.

Sıra tüm işi yapacakviews.pydosyasında.

```python
from django.shortcuts import render #1
from blog.models import Comments #2
from recaptcha import recaptcha_check #3
from blog.forms import CommentForm #4

def index(request): #5
 comments = Comments.objects.all() #6
 comment_form = CommentForm(request.POST or None) #7
 recaptcha_response = request.POST.get('g-recaptcha-response') #8
 recaptcha_response_result = recaptcha_check(recaptcha_response) #9
 if recaptcha_response_result is True and comment_form.is_valid(): #10
 comment_form.save() #11
 context = { # 12
 'form': comment_form,
 'comments': comments
 }
 return render(request, 'index.html', context) #13

```

Örnek kodumuz yukarıda. Bu kodu satır satır inceleyelim.
- #1, #2, #3, #4 Bu 4 kod satırı gerekli ihtiyaç duyduğumuz kütüphane ve modülleri dahil ediyoruz.
- #5indexisminde bir fonksiyon oluşturuyoruz.
- #6 Ana sayfamızda tüm yorumları listelemek bu satırdaCommentsmodelinde bulunan tüm kayıtları listeliyoruz.
- #7forms.pysayfasında oluşturduğumuz formu burada çağırıp bir değişkene atıyoruz.
- #8 reCAPTCHA Django Formunda olmadığı için bu satırdaPOSTyöntemiyle‘g-recaptcha-responsedeğişkenin değerini alıyoruz.
- #9recaptcha_checkisimli bir fonksiyon hazırladık böylece daha temiz bir görünüm elde ediyoruz. Bu fonksiyon ön yüz tarafından gelen kodu Google’ın doğrulama sunucusuna gönderiyor. Eğer sunucu doğrulamayı yaparsa sonuç olarakTrueveya hata olursa hatanın sebebini içeren bir sonuç dönecektir.
- #10 Bu satırda hazırladığımızrecaptcha_checkfonksiyonundan gelen değer ve Django Formunun geçerliliğini kontrol ediyoruz. Eğer iki karşılama da olumlu ise kod if bloğu devam eder.
- #11 Django Formunu kayıt ediyor.
- #12contextisimli bir sözlük hazırlıyoruz ve içine Django Formunu ve kayıt edilen tüm yorumları ekliyoruz.
- #13renderfonksiyonu ileindex.htmldosyasınıcontextdeğişkenini ekliyoruz.

#1, #2, #3, #4 Bu 4 kod satırı gerekli ihtiyaç duyduğumuz kütüphane ve modülleri dahil ediyoruz.

#5indexisminde bir fonksiyon oluşturuyoruz.

#6 Ana sayfamızda tüm yorumları listelemek bu satırdaCommentsmodelinde bulunan tüm kayıtları listeliyoruz.

#7forms.pysayfasında oluşturduğumuz formu burada çağırıp bir değişkene atıyoruz.

#8 reCAPTCHA Django Formunda olmadığı için bu satırdaPOSTyöntemiyle‘g-recaptcha-responsedeğişkenin değerini alıyoruz.

#9recaptcha_checkisimli bir fonksiyon hazırladık böylece daha temiz bir görünüm elde ediyoruz. Bu fonksiyon ön yüz tarafından gelen kodu Google’ın doğrulama sunucusuna gönderiyor. Eğer sunucu doğrulamayı yaparsa sonuç olarakTrueveya hata olursa hatanın sebebini içeren bir sonuç dönecektir.

#10 Bu satırda hazırladığımızrecaptcha_checkfonksiyonundan gelen değer ve Django Formunun geçerliliğini kontrol ediyoruz. Eğer iki karşılama da olumlu ise kod if bloğu devam eder.

#11 Django Formunu kayıt ediyor.

#12contextisimli bir sözlük hazırlıyoruz ve içine Django Formunu ve kayıt edilen tüm yorumları ekliyoruz.

#13renderfonksiyonu ileindex.htmldosyasınıcontextdeğişkenini ekliyoruz.

recaptcha_checkfonksiyonunu satır satır inceleyelim.

```python
import requests #1

def recaptcha_check(recaptcha_response): #2
 verify_url = 'https://www.google.com/recaptcha/api/siteverify' #3
 value = { #4
 'secret': '6LdBO6cZAAAAAAALlKFW656QWAPLOKasoPfLfYTVWV91Quo0H2tWBfRrc',
 'response': recaptcha_response
 }
 response = requests.post(verify_url, value) #5
 result = response.json() #6
 if result['success'] is True: #7
 return True
 else: #8
 return {'status': result['success'], 'reason': result['error-codes']} #

```
- #1requestskütüphanesini dahil ediyoruz.
- #2recaptcha_responseparametresini alanrecaptcha_checkisimli bir fonksiyon hazırlıyoruz.
- #3 Google doğrulama sunucusunun adresini yazıyoruz.
- #4valueisimli değişken oluşturuyoruz ve içine reCAPTCHA’nın uygulamasını kurulumunu yaparken bize sağlananGizli Anahtardeğerinisecretanahtarına, fonksiyona gelenrecaptcha_responsedeğeriniresponseanahtarına atıyoruz.
- #5 requests kütüphanesini kullanarakPOSTyöntemiyle Google doğrulama sunucusunavaluedeğişkenini gönderiyoruz.
- #6 Google doğrulama sunucusundan gelen değeri json haline getiriyoruz.
- #7 Eğer dönen sonuç başarılı ise fonksiyonTruedöndürür
- #8 Sonuç başarısız olursa neden başarısız olduğu dahil bir sözlük değeri döndürür.

#1requestskütüphanesini dahil ediyoruz.

#2recaptcha_responseparametresini alanrecaptcha_checkisimli bir fonksiyon hazırlıyoruz.

#3 Google doğrulama sunucusunun adresini yazıyoruz.

#4valueisimli değişken oluşturuyoruz ve içine reCAPTCHA’nın uygulamasını kurulumunu yaparken bize sağlananGizli Anahtardeğerinisecretanahtarına, fonksiyona gelenrecaptcha_responsedeğeriniresponseanahtarına atıyoruz.

#5 requests kütüphanesini kullanarakPOSTyöntemiyle Google doğrulama sunucusunavaluedeğişkenini gönderiyoruz.

#6 Google doğrulama sunucusundan gelen değeri json haline getiriyoruz.

#7 Eğer dönen sonuç başarılı ise fonksiyonTruedöndürür

#8 Sonuç başarısız olursa neden başarısız olduğu dahil bir sözlük değeri döndürür.

#### Django Kişiselleştirilmiş Kullanıcı Modelini Dahili Model ile Genişletmek

Django içinde hazır birçok modül ve modeller ile gelir. Bunlardan biri de kullanıcı modeli. Bu model ile hazırladığınız Django projesine çok hızlı bir şekilde üyelik sistemi geliştirebilirsiniz. Ancak bazen bu model tek başına yeterli gelmez. Böyle durumlarda kendi yazdığımız modeli Django ile gelen kullanıcı modeli ile genişletebiliriz.

##### Bu Yöntemin Avantajları Neler?

Django kullanıcı modeli yetki yönetim sistemi ve bazı hazır fonksiyonlar ile beraber gelir. Bu sayede kullanıcıların yetkisiz erişimlerini, yetki yönetimlerini, giriş, çıkış, parola değiştirme fonksiyonlarına ve bazı bezeyicilere(decarator) sahip oluruz. Bunlar sayesinde projemiz çok hızlı şekilde ilerleyebilir.

Django Admin Panelinden Kullanıcı ve Grup İzinleri Yönetimi

##### Nasıl Yapılır?

Projemize bir adet uygulama ekliyoruz. Bu uygulama kullanıcı modelimizi barındıracak ve Django’nun dahili kullanıcı modeli ile genişletilecek.settings.pydosyamızaAUTH_USER_MODEL = uygulama_adi.model_adideğişkenini ekliyoruz böylece varsayılan kullanıcı modelini geçersiz kılarak kendi modelimizi kullanabiliriz.

Hazırladığınız uygulamayısettings.pydosyasındaINSTALLED_APPSkısmına eklemeyi unutmayın.

Ardından uygulamamızınmodels.pydosyasında bir model oluşturmamız gerekli. Bu model dosyasını dahili Django kullanıcı modeli ile genişleteceğz. Öncelikle genişleşme sırasında doğru olan modeli seçmeliyiz. Django bize iki adet sınıf sunuyor bunlarAbstractuserveAbstractBaseUser.
- AbstractUser: Bu model ile beraber temel kullanıcı veri giriş alanları da geliyor. (Ad, soyad, son giriş, kayıt tarihi vs.)
- AbstractBaseUser: Bu model ile beraber sadece kimlik doğrulama fonksiyonları gelmekte. Kullanıcı veri giriş alanları gelmiyor.

AbstractUser: Bu model ile beraber temel kullanıcı veri giriş alanları da geliyor. (Ad, soyad, son giriş, kayıt tarihi vs.)

AbstractBaseUser: Bu model ile beraber sadece kimlik doğrulama fonksiyonları gelmekte. Kullanıcı veri giriş alanları gelmiyor.

Bu anlatıda AbstractUser ile genişletme yapacağız. Sınıfımızı yazıyoruz ve test etmek amacıyla fazladan veri giriş alanları ekleyelim.
Örnek kod:

```python
class CustomUserModel(AbstractUser):
 website = models.URL_Fields(verbose_name='Web Sitesi', blank=True)
 os = models.CharField(verbose_name='Kullandığı İşletim Sistemi', max_length=256)
 def __int__(self):
 return self.id

```

Hazırladığımız modeli veritabanı şemamıza uygulayacağız.

```python
python manage.py makemigrations

```

```python
python manage.py migrate

```

Yaptıklarımızı kontrol etmek için Python konsolunu açarak modelimizi dahil edelim.

```python
from user.models import *
CustomUserModel._meta.get_fields()

```

(<ManyToOneRel: admin.logentry>, <django.db.models.fields.AutoField: id>, <django.db.models.fields.CharField: password>, <django.db.models.fields.DateTimeField: last_login>, <django.db.models.fields.BooleanField: is_superuser>, <django.db.models.fields.CharField: username>, <django.db.models.fields.CharField: first_name>, <django.db.models.fields.CharField: last_name>, <django.db.models.fields.EmailField: email>, <django.db.models.fields.BooleanField: is_staff>, <django.db.models.fields.BooleanField: is_active>, <django.db.models.fields.DateTimeField: date_joined>, <django.db.models.fields.URLField: website>, <django.db.models.fields.CharField: os>, <django.db.models.fields.related.ManyToManyField: groups>, <django.db.models.fields.related.ManyToManyField: user_permissions>)

Çıktıyı incelediğimiz zaman<django.db.models.fields.URLField: website>, <django.db.models.fields.CharField: os>veri giriş yerlerini görüyoruz. Böylece yaptıklarımızın sıkıntısızca sisteme işlendiğini anlayabiliriz. Artık Django’nun dahili yetkliendirme ve kullanıcı sistemini kendi kullanıcı modelimiz üzerinden kullanabiliriz.

### Kivy Paketi

Bu belgelerin kaynak kodlarına ulaşmak içinGithubadresini ziyaret edebilir ve eğer isterseniz katkıda bulunarak bu kaynağın iyileştirilmesine yardımcı olabilirsiniz.

Soru, sorun ve görüşler içinForumsayfasını kullanabilirsiniz.

#### Kivy Nedir?

Kivy Android’den Windows’a kadar birden fazla işletim sistemini destekleyen bir grafik arayüz kütüphanesidir.
Açık kaynak kodludur ve %90 Python ile yazılmıştır. Kaynak kodlarını incelemek istersenizşulinke tıklayabilirsiniz. Ayrıca bu github adresinde yer alan, Kivy ile ilgili örnekleri de incelemek istersenizlinketıklayabilirsiniz.

Kivy çizim işlemlerini SDL2 kullanarak yapmaktadır. Doğal olarak pencere araçları, alışık olduğumuz Android veya diğer mobil pencere araçlarına benzemiyor(görünüm olarak). Kendine has şekilleri var, yani yerel işletim sisteminin grafiklerini kullanmıyor. Ekrana çizilen pencere araçlarının png haline, bilgisayarınızdaki kivy klasörünün altında ulaşabilirsiniz. kivy/data/images altında şöyle bir png dosyası var

Bu png dosyasını kesinlikle silmemelisiniz,boyutlarında kesinlikle oynama yapmamalısınız. Aksi takdirde Kivy pencere araçları ekrana çizilmeyecektir ve hata verecektir.

Kivy ile yazdığınız programları aynen veya birkaç değişiklik ile Android’de, Windows’ta çalıştırabilirsiniz. Yazdığınız programları buildozer yardımı ile paketleyebilirsiniz(android veya ios için). Bunlara yeri geldiğinde değinmeye çalışacağız.

Kivy kullanabilmeniz tabi ki Python temeliniz olmalı ve Kivy’i sisteminize kurmalısınız. Python’da sınıf yapılarını bilmeniz size ekstra bir katkı sağlar. Kivy programlarını nesne yönelimli olarak yazmak, çok daha sağlam ve düzenli programların ortaya çıkmasını sağlar.

Evet, Kivy hakkında biraz bilgi sahibi olduğumuza göre artık Kivy ile programlamaya giriş yapabiliriz…

#### Kurulum

Burada çok detaylı olarak kurulumu anlatmayacağız. Gerekli linkleri vereceğim, eğer yine de kurulumda sorun yaşarsanız forumda konu açarak belirtebilirsiniz.

Kuruluma başlamadan önce dikkat edilmesi gereken bir durum var. Eğer Kivy ile programlama yapacaksanız, bilgisayarınızda Python kurulu olmalıdır.

Kivy’in desteklediği sürümleri açıklayacak olursak;

Python 2.7 >= Kivy < Python 3.0

Python 3.4 >= Kivy

Python 2.7 sürümünden Python 3.0 sürümüne kadar, aynı zamanda Python 3.4 sürümünden itibaren ileri sürümlerde destekleniyor. Bu bilgiye göre, Python sürümünüzün Kivy programlama için uygun olup olmadığını tespit edebilirsiniz.

İşletim sisteminize göre kurulum için, aşağıda verdiğim kılavuz sayfalarına bakabilirsiniz.

Windows için kurulum:

https://kivy.org/doc/stable/installation/installation-windows.html

Linux için kurulum:

https://kivy.org/doc/stable/installation/installation-linux.html

OS X için kurulum

https://kivy.org/doc/stable/installation/installation-osx.html

Türkçe kaynak:

http://kivy-tr.readthedocs.io/tr/latest/kurulum.html

Kivy kütüphanesini kurduysanız, bir sorun olup olmadığını test etmek için şöyle basit bir program yazalım. Ekrana boş bir pencere çıkaralım.

```python
# -*- coding: utf-8 -*-

from kivy.app import App

App().run()

```

Kodu kaydedip çalıştırırsanız, ekrana boş bir siyah pencere çıkacaktır. Güzel, artık Kivy ile programlamaya başlayabiliriz :)

Yukarıda da yazdığım gibi, detaylı olarak anlatmadık. Çünkü birden fazla platform için yazılmış bir kütüphane olduğu için, her birine ayrılmış anlatım sayfaları ile yetindik. Yine de bir sorununuz olursa, kuramazsanız foruma konu açabilirsiniz. Kivy resmi kaynaklarında bulunan kurulum kılavuzu içinşubağlantıya tıklayabilirsiniz.

#### Kivy Programlamaya Giriş

Bu yazıyla Kivy derslerine giriş yapacağız. Önce klasik başlangıç olan “merhaba dünya” örneği yapacağız ve sırayla kodumuzu inceleyeceğiz.

Bundan önceki yazılarda da bahsettiğimiz gibi, Kivy ile programlamadan verim almak istiyorsanız Python sınıflar konusunda temel bilginiz olmalıdır. Çünkü genelde sınıfları kullanacağım ve bu yüzden yazdığım kodları(her ne kadar açıklama yapsam da) anlayabilmek için, temel de olsa, bilgili olmanız gerekir. Burdan, “Kivy sınıflar ile kullanılmak zorundadır” anlamı çıkmasın. Zaten sınıf yapısı çok zor değil, biraz pratik yaparak mantığını kavrayabilirsiniz.

Kivy kütüphanesini sıkıntısız bir şekilde kurduğunuzu varsayarak ilk örneğimize geçiş yapıyoruz.

Herhangi bir açıklama yapmadan önce hemen kodları verelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Program(App):
 def build(self):
 yazi = Label(text = "Merhaba Dünya")

 return yazi

Program().run()

```

Kodu kaydedip çalıştırdığınızda ekranda, karşınıza aşağıdaki gibi bir pencere çıkacaktır.

Şimdi sıra ile kodumuzu inceleyelim. İlk iki satır, her programın başına yazılan klasik satırlardır. Sadece ilk satır Linux için geçerli.

Sonraki satırda

```python
from kivy.app import App

```

programın belkemiğini oluşturan App sınıfını import ediyoruz. Ana pencere bu sınıf yardımıyla oluşturulur, programa dair tanımlamalar genelde bu sınıf ile yapılır.

Bir sonraki satır

```python
from kivy.uix.label import Label

```

ekranda yazı göstermemizi sağlayan Label sınıfını import ettik, yani kullanmak üzere içeriye aktardık. Artık gerekli sınıfları import ettiğimize göre ana programımızı tanımlayabiliriz

Bir sonraki satırda, Program adında bir sınıf oluşturduk ve App sınıfından miras aldık. Miras almak demek, önceden oluşturulan sınıfı tekrar kullanmak üzere bir sınıfa katmak, eklemek.

Yani biz burda programımızı oluşturabilmek için App sınıfını, kendi ana sınıfımıza miras aldık ve kullanmaya başladık. Ve sınıfımızda build adında bir metot tanımladık. Bu metot, programımız çalıştığında ekranda gösterilecek ana düzeni, bileşenleri geri döndürür. Genelde bir pencere düzeni geri döndürülür. Biz şimdilik basit bir şekilde ekranda yazı göstermek istedik ve bunu geri döndürdük. İleride pencere düzenlerini gördüğümüzde onları geri döndüreceğiz. Şimdilik örneğimize bakalım

Şimdiye kadar yaptıklarımız, ihtiyacımız olan şeyleri import etmek, ana sınıfımızı oluşturmak, ekranda gösterilecek nesneleri geri döndürmek. Artık programımızı çalıştırmamız gerekiyor. Bunu da Program().run() kısmında yaptık.

##### Kv Dili

Kivy programlarını geliştirmek için geliştirilen bir dildir. Kullanımı basittir. Yukarıda yaptığımız programı bir de kv dili ile gerçekleştirelim.

Öncelikle ana dosyamızı hazırlıyoruz. Benim ana dosyamın adı main.py . Ve bu dosyamın yanına bir tane program.kv dosyası oluşturuyorum. Ana sınıfımın ismi neyse, kv dosyama onun adını verdim. main.py dosyamın içerisine aşağıdaki kodları yazıyorum

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App

class Program(App):
 pass

Program().run()

```

Şimdi program.kv dosyasının içerisine şunları yazalım. Amacımız ekranda merhaba dünya yazmak

```python
Label:
 text:"Merhaba Dünya"

```

Programımızın build tarafından geri döndürülecek olan pencere düzenini, kv dili yardımıyla oluşturduk. Yapmamız gereken main.py dosyamızı çalıştırmak ve sonucu görmek.

kv dili kullanırken, aynen Python’da olduğu gibi girintilemeye dikkat etmelisiniz. Aksi taktirde hata verecektir. Kv dili, Kivy ile programlama yaparken oldukça kolaylık sağlar. Biz de derslerimizde bazen yaptığımız örnekleri kv diliyle de yapacağız. Bir programı birinci bölümdeki gibi sınıflarla da yazabilirsiniz, kv dili yardımıyla da yazabilirsiniz. Hatta bazı kısımları kv diliyle de yazabilirsiniz. Yerine göre değişecektir, illa ki kv diline ihtiyacınız olacaktır.

##### Uygulama Özellikleri

Yazdığımız Kivy programının bazı niteliklerini değiştirebiliriz. Örneğin, siz yukarıda programı çalıştırdığınızda programın başlığını henüz tanımlamadığınız için pencerenin başlığı ana sınıfın adı ile aynıdır. İsterseniz bunu değiştirebilirsiniz.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Program(App):
 def build(self):
 self.title = "Yazbel"

 return Label(text = "Merhaba Dünya")

Program().run()

```

Kivy’de bir program başlarken, ekrana pencere çizilmeden önce birtakım metotlar çalışır. Bunlardan birisi on_start() metodu. Bu metot içerisine, ekrana pencere çizilmeden önce yani programımız başlamadan yapmak istediğimiz tanımlamaları yazabiliriz. Örneğin başlığı burada tanımlayabiliriz, ya da veritabanımız varsa bağlantıları burada başlatabiliriz. Kullanımına dair basit bir örnek

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Program(App):
 def on_start(self):
 self.title = "Yazbel"

 def build(self):
 return Label(text = "Merhaba Dünya")

Program().run()

```

Ancak dikkat edilmesi gereken bir durum var. on_start() metodu, build() metodu çalıştırıldıktan sonra çağrılır.

Kivy uygulamamızda belli olaylarda çalışan başka metotlar da var.

on_stop(): Bu metot, programımız sona erdiğinde çalıştırılır. Böylece son olarak yapmak istediğimiz işlemleri(örneğin açık dosyaları kapatmak) burada yapabiliriz

on_pause(): android veya ios üzerinde programımız arkaplana alındığında bu metot çalıştırılır.

on_resume(): Kullanıcı arkaplana aldığı uygulamamıza tekrar dönerse bu metot çalıştırılır.

Şimdi bunların hepsini birarada kullandığımız bir örnek görelim ve konuyu bitirelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Program(App):
 def on_start(self):
 self.title = "Yazbel"
 # bir takım işlemler...

 def on_stop(self):
 # Uygulama kapatılırken...
 pass

 def on_pause(self):
 # Uygulama arkaplana alınırken...
 # Burda return True yapmanız gerekiyor
 return True

 def on_resume(self):
 # Tekrar giriş yapıldığında yazımızı değiştiriyoruz
 self.yazi.text = "Programa tekrar hoşgeldiniz"

 def build(self):
 self.yazi = Label(text = "Merhaba Dünya")
 return self.yazi

Program().run()

```

#### Pencere düzenleri

Merhaba arkadaşlar. Bir önceki yazıda, Kivy ile ilk programımızı yazdık,kv diline kısaca göz attık ve programımıza dair bazı özellikleri tanıdık.

Hatırlarsanız bir önceki derste ekrana “Merhaba Dünya” yazmıştık. Tabi ki programlar bu kadar basit olamaz. Yani ekranda başka araçlar da olacaktır. Buton, Metin giriş alanı, Seçim kutuları gibi araçlar da olacaktır elbette.

Bu pencere araçlarını ekranda gösterirken belli bir düzen içerisinde yerleştirmeliyiz ki, programın görüntüsü güzel olsun ve kullanıcıyı memnun etsin. Şimdi adım adım pencere düzenlerimizi tanımaya başlayalım.

> **Not**
> Pencere düzenleri bu kadarıyla sınırlı değil. Burada en çok kullanılanlar anlatılmıştır

Not

Pencere düzenleri bu kadarıyla sınırlı değil. Burada en çok kullanılanlar anlatılmıştır

##### BoxLayout

kivy.uix.boxlayout.BoxLayout

Bu pencere düzeni, içerisine yerleştirilen araçları yan yana veya alt alta yerleştirir. Hemen bir örnekle görelim.

```python
from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout

class Program(App):
 def build(self):
 duzen = BoxLayout()

 yazi1 = Label(text = "Merhaba")

 yazi2 = Label(text = "Dünya")

 duzen.add_widget(yazi1)
 duzen.add_widget(yazi2)

 return duzen

Program().run()

```

Ekran görüntüsü

Şimdi sıra ile kodumuzu inceleyelim.İlk satırda App sınıfını import ettik. Daha sonra ekrana yazı yazmamızı sağlayan Label sınıfını import ettik. Ve son olarak, pencere düzenimiz olan BoxLayout sınıfını import ettik.

Bir pencere düzenini kullanabilmek için öncelikle onu tanımlamanız gerekir. duzen isminde bir değişkenle tanımladık ve iki adet yazımızı bu düzenin içine add_widget() fonksiyonu ile ekledik. Bir pencere düzeninin içerisine pencere aracı eklemek için add_widget() fonksiyonu kullanılır. Bir pencere aracını kaldırmak için ise, remove_widget() fonksiyonu kullanılır.

Eğer BoxLayout pencere düzenini tanımlarken herhangi bir parametre vermezseniz elemanları yanyana dizecektir. Eğer alt alta dizmesini isterseniz orientation parametresini kullanmanız gerekir.

Örnek;

```python
from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout

class Program(App):
 def build(self):
 duzen = BoxLayout(orientation = "vertical")

 yazi1 = Label(text = "Merhaba")

 yazi2 = Label(text = "Dünya")

 duzen.add_widget(yazi1)
 duzen.add_widget(yazi2)

 return duzen

Program().run()

```

Ekran görüntüsü

Gördüğünüz gibi eklenen elemanları alt alta yerleştirdi. Peki ikisini birarada kullanabileceğimiz bir örnek yapabilir miyiz? Evet. Bir kullanıcı giriş ekranı yapalım. Ama sadece görüntü olarak, yani herhangi bir işlem yapmayacak. Sadece pencere düzenini göstermek için yapacağız.

Amacımız şuna benzer bir pencere oluşturmak;

Hem alt alta elemanlar var, hem de yan yana. Şimdi böyle bir pencereyi nasıl oluşturacağımızı görelim.

```python
from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.textinput import TextInput

class Program(App):
 def build(self):

 self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların hepsini tutan ana pencere düzenimiz

 self.ilkSatir = BoxLayout()
 self.ikinciSatir = BoxLayout()

 self.nick = Label(text = "Nick")
 self.nickKutu = TextInput()

 self.sifre = Label(text = "Şifre")
 self.sifreKutu = TextInput()

 self.buton = Button(text = "Giriş Yap")

 self.ilkSatir.add_widget(self.nick)
 self.ilkSatir.add_widget(self.nickKutu)

 self.ikinciSatir.add_widget(self.sifre)
 self.ikinciSatir.add_widget(self.sifreKutu)

 # Şimdi hepsini ana düzene yerleştiriyoruz

 self.anaDuzen.add_widget(self.ilkSatir)
 self.anaDuzen.add_widget(self.ikinciSatir)
 self.anaDuzen.add_widget(self.buton)

 return self.anaDuzen

Program().run()

```

Ekran görüntüsü

Şimdi kodumuzu adım adım inceleyelim. Yukarıda gördüğünüz gibi Button ve TextInput sınıflarını import ettik. Button sınıfı ile butonlar oluşturabiliriz. Butona tıklandığında yapılmasını istediğimiz işlemler tanımlayabiliriz. Ancak bu derste pencere düzenlerini incelediğimiz için butonumuza herhangi bir görev vermedik.

TextInput, kullanıcıdan girdi almayı sağlar. Böylece kullanıcı ile iletişime geçebiliriz, girdilere göre işlemler yapabiliriz.

Örneğimiz 3 tane BoxLayout düzeninden oluşuyor. Birincisi, tüm elemanları alt alta tutacak olan “anaDuzen”, İkincisi Nick ve Nick girme kutusunu yan yana tutacak olan “ilkSatir”, ve sonuncusu Şifre ve Şifre girme kutusunu yan yana tutacak olan “ikinciSatir”. Butonumuzu sadece anaDuzen’e eklememiz yeterli.Unutmayın bir pencere düzeninin içine başka bir pencere düzeni ekleyebilirsiniz.

Peki bu örneğimizi kv dili ile yazsaydık nasıl olurdu? Hemen bakalım

```python
BoxLayout:
 orientation: "vertical"
 BoxLayout:
 Label:
 text:"Nick"
 TextInput:
 BoxLayout:
 Label:
 text:"Şifre"
 TextInput:
 Button:
 text:"Giriş Yap"

```

BoxLayout ile ilgili bu kadar örnek yeterli sanırım. Siz de kendinize göre örnekler yaparak veya verilen örnekleri inceleyip değiştirerek konuyu pekiştirebilirsiniz.

##### FloatLayout

kivy.uix.floatlayout.FloatLayout

FloatLayout pencere düzeni, araçları istediğimiz boyutta ve koordinatta yerleştirebileceğimiz bir pencere düzenidir. Her zaman olduğu gibi önce import etmeliyiz ve kullanmak üzere tanımlamalıyız. Bir örnek yapalım

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.floatlayout import FloatLayout

# gerekli sınıfları import ettik

class Program(App):
 def build(self):

 duzen = FloatLayout() # pencere düzenimizi tanımladık

 buton = Button(text = "Merhaba",
 size_hint = (.1,.1),
 pos = (10,10))

 duzen.add_widget(buton) # butonumuzu yerleştiriyoruz

 return duzen

Program().run()

```

Ekran görüntüsü

Butonumuzu tanımlarken size_hint ve pos şeklinde iki tane parametre verdik. Bunlardan size_hint parametresi, butonumuzun ekrana orantılı bir şekilde boyutlandırılması içindir. Yani, .1 yazdığımızda, pencerenin boyutunun 10’da 1’i kadar genişlikte ve yükseklikte boyutlandırılır. Eğer .5 yazsaydık ekranın boyutunun yarısı kadar olacaktı.Bu arada Python’da .X gösterimi 0.X gösterimi ile aynıdır, bunu da burada belirtmiş olalım.

size_hint ile butonumuzun boyutlarını belirledikten sonra, pos parametresi ile FloatLayout pencere düzenindeki yerini belirledik. pos = (10,10) yani sıra ile 10 pixel soldan uzaklık, 10 pixel aşağıdan uzaklık şeklinde tanımlanır. Kivy’de (0,0) noktası sol-alt köşedir.

Eğer butonumuza bu parametreleri vermeden pencere düzenimize eklersek, tüm ekranı dolduracak şekilde boyutlandırılacaktır.

FloatLayout pencere düzenimizin de boyutunu ayarlayabiliriz. Bunun için

```python
duzen = FloatLayout(size = (300,300))

```

gibi bir tanımlama yapmamız yeterli. Aynı şekilde pencereye orantılı olmasını istersek, size_hint parametresini de verebiliriz. Bir örnekle beraber görelim

```python
#!/usr/bin/env python
# coding:utf-8

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.floatlayout import FloatLayout

# gerekli sınıfları import ettik

class Program(App):
 def build(self):

 duzen = FloatLayout(size_hint = (.5,.5)) # pencere boyutunun yarısı kadar

 buton = Button(text = "Merhaba") # FloatLayout pencere düzenimizi tam doldursun diye, parametre vermedik

 duzen.add_widget(buton) # butonumuzu yerleştiriyoruz

 return duzen

Program().run()

```

Ekran görüntüsü

FloatLayout pencere düzenine eklenen araçların, ekrana orantılı bir şekilde yerleştirilmesini istersek, pos_hint parametresini kullanabiliriz.Böylece penceremizin boyutu ne olursa olsun, orantılı bir şekilde yerleştirilecektir. Aşağıdaki kodları çalıştırıp pencerenin boyutlarıyla oynarsanız, ne demek istediğimi çok daha iyi anlarsınız.

Kullanımı şu şekilde;

```python
#!/usr/bin/env python
# coding:utf-8

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.floatlayout import FloatLayout

# gerekli sınıfları import ettik

class Program(App):
 def build(self):

 duzen = FloatLayout()

 button = Button(text='Hello world', size_hint=(.2, .1),
 pos_hint={'x':.2, 'y':.2})

 duzen.add_widget(button) # butonumuzu yerleştiriyoruz

 return duzen

Program().run()

```

FloatLayout pencere düzeni ile ilgili anlatacaklarımız bu kadar. FloatLayout pencere düzeni, üzerinde serbest konumlandırma yapıldığı için animasyon için uygundur. Sadece örnek olması açısından, aşağıdaki kodu çalıştırın ve ne olduğunu görün. Kodu anlamanızı istemiyorum, ileride zaten anlatacağız, sadece kodun sonuçlarını görmeniz yeterli.

```python
#!/usr/bin/env python
# coding:utf-8

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.floatlayout import FloatLayout
from kivy.clock import Clock

# gerekli sınıfları import ettik

class Program(App):
 def build(self):
 self.x = 0
 self.y = 2

 self.duzen = FloatLayout()
 self.buton = Button(text='Hello world',
 size_hint=(.2, .1),
 pos = (self.x,self.y))

 self.duzen.add_widget(self.buton)

 Clock.schedule_interval(self.animasyon,0.1)

 return self.duzen

 def animasyon(self,event = None):
 self.x = self.x + 1

 self.buton.pos = (self.x,self.y)

Program().run()

```

##### GridLayout

kivy.uix.gridlayout.GridLayout

Merhaba arkadaşlar. Bir önceki bölümde FloatLayout pencere düzenini anlattık. FloatLayout, üzerinde koordinat bilgisi ile yerleştirme yapabileceğimiz bir pencere düzenidir diyerek kısa bir tekrar yapmış olalım.

Bu bölümde GridLayout pencere düzenini inceleyeceğiz. GridLayout, ızgara şeklinde yerleştirmeye imkan veren bir pencere düzenidir. Örneğin şöyle bir görüntü elde etmek için GridLayout pencere düzeni kullanılabilir

GridLayout ile ilgili önemli iki kavram vardır. Birincisi rows, yani satır. GridLayout pencere düzeninin max kaç satırdan oluşmasını istiyorsak, rows parametresini kullanırız. Diğeri ise, cols yani sütun. GridLayout pencere düzenimizin max kaç sütundan oluşmasını istiyorsak, cols parametresini kullanabiliriz. Şimdi ayrı ayrı ikisiyle ilgili birer örnek yapalım ve nasıl kullanacağımızı görelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):

 govde = GridLayout(cols = 2)
 # Max 2 sütundan oluşmasını istedik
 # 2 sütundan sonra alta kayacaktır

 # Birden fazla buton ekleyerek nasıl göründüğüne bakalım
 # for döngüsü ile ekleyelim
 for i in range(10):
 govde.add_widget(Button(text = "{}".format(i+1)))

 return govde

Yazbel().run()

```

Bakalım nasıl görünüyor

Gördüğünüz gibi, ne kadar eleman eklersek ekleyelim her zaman 2 sütunu aşmayacak şekilde yerleştiriliyor. Eğer bir sütunun genişliğini biraz daraltmak istersek, aynı sütuna denk gelen elemanlara size_hint_x parametresini vermemiz gerekiyor. Bir örnek üzerinden görelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):

 govde = GridLayout(cols = 2)
 # Max 2 sütundan oluşmasını istedik
 # 2 sütundan sonra alta kayacaktır

 # Birden fazla buton ekleyerek nasıl göründüğüne bakalım
 # for kullanarak ekleyelim
 for i in range(10):
 if(i%2 == 0):
 # Aynı sütuna denk gelenler için
 govde.add_widget(Button(text = "{}".format(i+1),
 size_hint_x = .4))
 else:
 govde.add_widget(Button(text = "{}".format(i+1)))

 return govde

Yazbel().run()

```

width parametresini de kullanabiliriz

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):

 govde = GridLayout(cols = 2)
 # Max 2 sütundan oluşmasını istedik
 # 2 sütundan sonra alta kayacaktır

 # Birden fazla buton ekleyerek nasıl göründüğüne bakalım
 # for kullanarak ekleyelim
 for i in range(10):
 if(i%2 == 0):
 # Aynı sütuna denk gelenler için
 govde.add_widget(Button(text = "{}".format(i+1),
 size_hint_x = None,
 width = 200))
 else:
 govde.add_widget(Button(text = "{}".format(i+1)))

 return govde

Yazbel().run()

```

size_hint_x = None kısmını neden yazdığımıza gelirsek, eğer orantılı boyutlandırmaya None değeri vermezsek, width ile boyutu belirlememize izin vermeyecektir. O yüzden None değeri vererek boyutlandırmayı width ile yapabildik.

Şimdi, rows kullanımıyla ile ilgili örnek yapalım.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):

 govde = GridLayout(rows = 2)
 # Max 2 sütundan oluşmasını istedik
 # 2 sütundan sonra alta kayacaktır

 # Birden fazla buton ekleyerek nasıl göründüğüne bakalım
 # for döngüsü ile ekleyelim
 for i in range(10):
 govde.add_widget(Button(text = "{}".format(i+1)))

 return govde

Yazbel().run()

```

Aynı şekilde görüldüğü gibi, ne kadar eleman eklersek ekleyelim, her zaman 2 satır olacak şekilde yerleştiriliyor. Boyutlandırmak için, GridLayout nesnemizi tanımlarken row_default_height parametresini vererek, varsayılan yüksekliğini ayarlayabiliriz.

Eğer GridLayout ile ilgili daha çok bilgiye ulaşmak isterseniz,Kivy GridLayoutsayfasına bakabilirsiniz.

##### AnchorLayout

kivy.uix.anchorlayout.AnchorLayout

Pencere araçlarını belli yönlere yaslamak isterseniz, AnchorLayout kullanabilirsiniz. Örneğin sağ-yukarı, veya orta-aşağı gibi. Yalnız, bu pencere düzeninin kullanımı biraz farklı. Diğer pencere düzenleri içerisine eklenen elemanları belli bir düzene göre yerleştiriyordu. Ancak AnchorLayout kullanımı bundan farklı, AnchorLayout daha çok içine pencere araçlarının yaslanmasında yardımcı bir eleman olarak düşünülebilir.Bir örnekle sanırım daha iyi anlayabiliriz. Öncelikle pencere düzenini tanımlayalım. Pencere aracımız X ekseninde sola yaslı ve Y ekseninde ortada dursun.

```python
anchor = AnchorLayout(anchor_x = "left",anchor_y = "center")

```

Şimdi, sol-orta’ya yerleştirilmesini istediğimiz pencere aracını bunun içine koyuyoruz. Örneğin bir buton koyalım. Yalnız bu butonun boyutlarını biz belirlemezsek ekranı kaplayacaktır.

```python
buton = Button(text = "Sol Orta",size_hint = (.2,.2))
anchor.add_widget(buton)

```

İşte önemli nokta burası. İçine buton eklediğimiz bu pencere düzeni, kendi içinde sol-orta’ya yerleştirmeyecektir. Yerleşim için, bu pencere düzenini FloatLayout gibi bir pencere düzeni içerisinde göstermeliyiz.

```python
self.govde = FloatLayout()

self.govde.add_widget(anchor)

```

Yerleştirdikten sonra, butonumuz AnchorLayout yardımıyla sol-ortada duracaktır. Şimdi örneği tam olarak verelim.

```python
# coding: utf-8
from kivy.app import App
from kivy.uix.widget import Widget
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.button import Button

class AnchorOrnek(App):
 def build(self):
 self.govde = FloatLayout()

 anchor = AnchorLayout(anchor_x = "left",anchor_y = "center")
 buton = Button(text = "Sol Orta",size_hint = (.2,.2))
 anchor.add_widget(buton)

 self.govde.add_widget(anchor)

 return self.govde

AnchorOrnek().run()

```

Programı çalıştırdıktan sonra şöyle bir ekran bizi karşılayacaktır

anchor_x ile kullanılabilecek değerler: “left”,”right”,”center”
anchor_y ile kullanılabilecek değerler: “top”,”bottom”,”center”

##### StackLayout

kivy.uix.stacklayout.StackLayout

Stack yani Türkçe karşılığı olarak yığıt, tam da kelime anlamı olarak pencere araçlarını bir tarafa yığarak yerleştirir. Örneğin sağ-yukarı şeklinde tanımladığımızda, eklenen her pencere aracını bu tarafa yığarak yerleştirmeye başlayacaktır. Aşağıdaki png dosyasına bakarak daha iyi anlayabiliriz

İçerisine yerleştirilecek pencere araçlarının boyutunu değiştirmek gerekiyor. Yoksa diğer pencere düzenlerinde de olduğu gibi, tamamen bulunduğu alanı kaplayacak ve diğer pencere araçlarının düzgün bir şekilde yerleştirilmesine engel olacaktır. Şimdi, bir örnekle bu pencere düzenini kullanalım

```python
#coding: utf-8

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.stacklayout import StackLayout

class Program(App):

 def build(self):
 govde = StackLayout(orientation = "lr-tb")

 for i in range(1,11):
 govde.add_widget(Button(text = "{}".format(i),size_hint = (None,None),size = (100,50)))

 return govde

Program().run()

```

Ekran görüntüsü

StackLayout oluştururken kullandığımız orientation parametresi, yerleştirmenin hangi yönlerden hangi yöne olacağını belirtmek için kullanılır. Bu durumda bizim yazdığımız değere bakarsak, lr-tb, Left Right - Top Bottom yani soldan sağa ve yukarıdan aşağı şeklinde. Bu şekilde kullanılabilecek kombinasyonlar

lr-tb
tb-lr
rl-tb
tb-rl
lr-bt
bt-lr
rl-bt
bt-rl

Ekranda birden fazla buton oluşturmak için for döngüsü kullandık ve bu butonların boyutunu belirttik. Boyutu sığmayan butonlar otomatik olarak bir alt satıra yerleştirilir, resimde de gördüğünüz gibi.

###### padding

StackLayout çerçevesi ve içerisindeki pencere araçlarının arasında ne kadar boşluk olacağını belirtir. Varsayılan olarak [0,0,0,0]

###### spacing

Yerleştirilen pencere araçları arasında ne kadar boşluk olacağını belirtir. Varsayılan olarak [0,0]

#### Temel Pencere Araçları

Bu bölümde, Kivy içerisinde bulunan pencere araçlarından bahsedeceğiz. Bu bölüm, Kivy API kaynaklarından yardım alarak oluşturulmuştur. Kivy dökümanlarındaWidgetssayfasına bakabilirsiniz

Tüm pencere araçları Widget sınıfından türetilmiştir. Widget boş bir pencere aracıdır. Siz de isterseniz Widget sınıfını kullanarak kendi pencere aracınızı oluşturabilirsiniz. Biz de yeri geldiğinde burada Widget ile ilgili örnekler yapacağız.

Pencere araçları kullanıcı ile iletişim imkanı verir, görsel arayüzü anlamlı kılar. Boş pencere hiçbir anlam ifade etmez, ancak pencere araçlarıyla anlamlı olur. Pencere araçlarını iki kısımda anlatmayı düşünüyoruz. Birinci kısımda buton,yazı,metin kutusu gibi temel pencere araçlarını anlatacağız.

İkinci kısımda ileri seviye pencere araçlarından bahsedeceğiz. Android tarzı menüler, slayt pencereleri, popup pencereleri gibi araçları ikinci kısımda anlatacağız

Tabi ki bunlar Kivy dökümanlarında ikiye ayrılmış değil, sadece burada anlatım için benimsenmiştir. Amaç yazıların daha düzgün ve anlamlı bir şekilde sıralanmasıdır.

Öyleyse başlayalım

##### Label

kivy.uix.label.Label

Bildiğiniz gibi Label, ekranda yazı göstermeyi sağlayan bir pencere aracıdır. Nasıl import edeceğimizi ve nasıl kullanabileceğimizi bir örnekle görelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba ben bir yazıyım :)")

 return yazi

Yazbel().run()

```

Label sınıfıyla birlikte kullanabileceğimiz bazı özellikleri birer örnek ve kısa bir açıklama ile aşağıda belirteceğim.

###### font_size

Yazının boyutunu pixel cinsinden ifade etmeyi sağlar. Varsayılan olarak 15 sp’dir

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba ben bir yazıyım :)",
 font_size = "25sp")

 return yazi

Yazbel().run()

```

###### halign

Yazıyı sağa,sola veya ortaya hizalamak için kullanılır. Varsayılan olarak “left” değerini alır. Verebilinecek değerler; left,right,center

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba ben bir yazıyım :)\nSağa yaslı bir yazı...",
 font_size = "25sp",
 halign = "right")

 return yazi

Yazbel().run()

```

###### color

Yazının rengini değiştirmek için kullanılır. Liste veya demet olarak değer alır. RGBA cinsinden değer alabilir. Varsayılan değer: [1,1,1,1]

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba\nben bir yazıyım",
 font_size = "25sp",
 color = [0,.3,.9,1])

 return yazi

Yazbel().run()

```

###### bold - italic

Yazıyı kalın ve eğik göstermek için kullanılır.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba\nben bir yazıyım",
 font_size = "25sp",
 color = [0,.3,.9,1],
 bold = True,
 italic = True)

 return yazi

Yazbel().run()

```

###### line_height

Satır arası genişliği ayarlamak için kullanılır. Varsayılan değeri 1’dir.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Merhaba\nben bir yazıyım",
 font_size = "25sp",
 color = [0,.3,.9,1],
 line_height = 2)

 return yazi

Yazbel().run()

```

###### markup

Daha önce HTML tag’leri kullandıysanız markup kullanımını anlamanız gayet kolay olacaktır. Ancak kullanmadıysanız da sorun değil. Zira kolaydır. markup, tag’ler yardımı ile yazınızı biçimlendirmenizi sağlar. Kullanılabilir tag’ler şunlardır.

[b][/b]: Kalın yazı

[i][/i]: İtalic yazı

[u][/u]: Altı çizili yazı

[s][/s]: Üstü çizili yazı

[font=][/font]: Font belirleme. İnternetten indirdiğiniz font dosyasının adını verebilirsiniz. Font dosyası ile programınız aynı klasörde olmalı.

[size=][/size]: Yazı boyutu

[color=#RGB][/color]: Renkli yazı

[ref=deger][/ref]: Yazıya bir link ekler. Bu link’e tıklandığı zaman, belirlenen fonksiyona gönderilecektir.

[anchor=name]: Yazıya ekleyerek, yazının sol üst köşesine göre koordinat bilgisi almayı sağlar. yazi.anchors ile erişilebilir.

[sub][/sub]: alt simge olarak yazmayı sağlar. Logaritmik gösterimlerde kullanılabilir.

[sup][/sup]: üst simge olarak yazmayı sağlar. Üslü sayıların yazımında kullanabiliriz

Şimdi bunları bir örnek içerisinde görelim.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 string = """
[size=20]
[color=#090]Renkli[/color]
[size=15]Size 15[/size]
[i]italic[/i]
[b]bold[/b]
[ref=Link]Tıkla[/ref]
[u]Altı çizili[/u]
[s]Üstü çizili[/s]
[font=Pacifico]Font[/font]
2[sup]8[/sup]
log[sub]2[/sub]10
[/size]
"""
 # Tüm yazıyı [size=20] [/size] arasına alarak boyutunu artırdım

 yazi = Label(text = string,markup = True)
 # markup = True değerini vermezseniz yazınız tag'lerle birlikte yorumlanmaz
 # yani tag'ler etkisiz hale gelir
 # kapatmak için, markup = False değerini vermelisiniz

 yazi.bind(on_ref_press = self.tikla)
 # ref ile belirlediğimiz yazıya tıklandığı zaman
 # self.tikla metodumuz çalışacaktır
 # Burada amaç, ref ile belirlediğimiz yazıya tıklandığı zaman
 # hangi metodun çalışacağını belirlemektir.
 # bu bir olaydır. Olayları ileride göreceğiz
 # şimdilik bu örneği anlamanız yeterli

 return yazi

 def tikla(self,nesne,deger):
 print("Deger: {}".format(deger)) # [ref=deger] kısmındaki deger'i yazdırır

Yazbel().run()

```

Örnekte kullandığım Pacifico font’unu internet üzerinden kolaylıkla temin edebilirsiniz. İndirdikten sonra programın ana dosyasının yanına koymanız gerekiyor. Yoksa font dosyasının bulunamadığına dair hata mesajıyla karşılaşırsınız.

Yazınızın özelliklerine sonradan erişebilir, isterseniz bunları değiştirebilirsiniz. yazi.ozellik şeklinde ilgili özelliğe erişebilir, yazi.ozellik = yeni_deger ile de yeni değerini verebilirsiniz. Örneğin, bir yazının içeriğini ve rengini değiştirelim

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):

 yazi = Label(text = "Eski değer..",
 color = [0,.3,.9,1])

 yazi.text = "Yeni değer.."
 yazi.color = [1,0,0,1]

 return yazi

Yazbel().run()

```

Label ile ilgili daha fazla bilgi içinKivy Labelsayfasını ziyaret edebilirsiniz

##### Button

kivy.uix.button.Button

Button pencere aracı, butonlar oluşturmayı sağlar ve kivy.uix.button içerisinde bulunur. Bir butona tıklandığı zaman olaylar meydana gelir. Mesela butona tıklanma olayı, basılı tutulma olayı, butonu bırakma olayı vs hepsi birer olaydır ve event olarak adlandırılır. Event ingilizce olay,hareket demektir. Butonlar olaylarla anlam kazanır. Bir butonun tıklanma olayını fonksiyonlar yardımıyla dinleriz, olay gerçekleştiği zaman fonksiyonumuz da çalışmış olur. Biz de bu fonksiyon içerisinde yapılmasını istediğimiz işlemleri yazarız.

Kivy içerisinde butonlar, birer Label sayılabilirler. Label’den farkı tıklanabilir araçlardır. Onun dışında Label ile birlikte kullanılan tüm özellikleri Button sınıfıyla birlikte kullanabiliriz. Elbette bir Label’den fazlasına sahiptir. Bunları da birazdan inceleyeceğiz. Öncelikle bir butonun nasıl oluşturulduğunu ve bu butonun olaylarını(örneğin butona tıklama) nasıl dinleyeceğimizi görelim.

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.button import Button
from kivy.uix.boxlayout import BoxLayout

class Yazbel(App):

 def build(self):
 self.govde = BoxLayout(orientation = "vertical")

 self.yazi = Label(text = "Bildiri Ekranı")
 self.buton = Button(text = "Tıkla",size_hint_y = .3)

 self.buton.bind(on_press = self.press)
 # Basılma olayını self.press fonksiyonuna bağladık
 # Yani butona basıldığı anda self.press fonksiyonumuz çalışacaktır

 self.buton.bind(on_release = self.release)
 # Bırakılma olayını self.release fonksiyonuna bağladık
 # Yani buton bırakıldığı anda self.release fonksiyonumuz çalışacaktır

 self.govde.add_widget(self.yazi)
 self.govde.add_widget(self.buton)

 return self.govde

 def press(self,nesne):
 self.yazi.text = "Buton'a basıldı"

 def release(self,nesne):
 self.yazi.text = "Buton bırakıldı"

```

Şimdi kodu inceleyelim. İlk olarak gerekli sınıflarımızı import ettik. Bir tane BoxLayout pencere düzeni oluşturduk, içerisine de yazımızı ve butonumuzu ekledik. Butonumuzun yazımıza göre dikeyde daha az yer kaplaması için size_hint_y parametresine .3 değerini verdik.

Sonra, butonumuzun bind() metodu ile on_press olayını, self.press fonksiyonumuza bağladık. Fonksiyon ismini istediğiniz şekilde belirleyebilirsiniz. Ancak dikkat etmeniz gereken şey, fonksiyonun aldığı parametrelerdir. Fonksiyonumuz self hariç bir tane daha parametre alır. Bu parametre, olayın kaynağı olan pencere aracıdır. Dolayısıyla butona tıkladığımızda olayın kaynağı bu buton oluyor.

Button sınıfına dair bazı özellikleri tanımlamayalım

###### background_color

Butonumuzun arkaplan rengi. (r,g,b,a) formatında değer alır.

```python
buton = Button(text = "Buton", background_color = [1,1,0,1])

```

veya

```python
buton.background_color = [1,1,0,1]

```

###### background_normal

Butonun basılı olmadığı durumdaki arkaplan resmi. Resmin adını yazmanız yeterlidir. Resminiz ana program ile aynı klasörde olmalıdır. Eğer bir alt klasörde ise, mesela images klasöründe ise “images/resim.png” yazmalısınız

```python
buton = Button(text = "Buton",background_normal = "resim.png")

```

veya

```python
buton.background_normal = "resim.png"

```

###### background_down

Butona basılı haldeki arkaplan resmi. background_normal ile aynıdır.

```python
buton = Button(text = "Buton",background_down = "resim.png")

```

veya

```python
buton.background_down = "resim.png"

```

###### disabled

Butonun aktif olup olmama durumu. True değeri verilirse buton deaktif hale gelecektir. Bu durumda butona tıklama yapılamaz. Eğer False değeri verilirse buton aktif hale gelecektir

```python
buton = Button(text = "Buton",disabled = True)

```

veya

```python
buton.disabled = True

```

###### background_disabled_normal

Buton aktif olmadığı durumdaki arkaplan resmi

```python
buton = Button(text = "Buton",background_disabled_normal = "resim.png")

```

veya

```python
buton.background_disabled_normal = "resim.png"

```

###### background_disabled_down

Buton aktif olmadığı durumda, butona basıldığı zaman belirlenen arkaplan resmi

```python
buton = Button(text = "Buton",background_disabled_down = "resim.png")

```

veya

```python
buton.background_disabled_down = "resim.png"

```

###### border

Butonun kenar genişlikleri. [alt,sağ,üst,sol] formatında değer alır. Varsayılan değeri [16,16,16,16]

```python
buton = Button(text = "Buton",border = [2,2,2,2])

```

veya

```python
buton.border = [2,2,2,2]

```

Button sınıfıyla ilgili daha detaylı bilgi içinhttps://kivy.org/doc/stable/api-kivy.uix.button.html

##### TextInput

kivy.uix.textinput.TextInput

TextInput, kullanıcıdan girdi almayı sağlar, programlarda çok kullandığımız metin kutularıdır. Tek satırlı, çok satırlı, yıldızlı girdi alma ve daha birçok işlem için kullanılabilir. Aynı zamanda CTRL+C, CTRL+Z gibi kısayol tuşları da kullanılabilir.

kivy.uix.textinput modülü içerisinde yer alır. Hatırlarsanız BoxLayout konusunda birörnekyapmıştık. Bu örnek kullanıcıdan nick ve şifre almak üzere tasarlanmıştı ama henüz birşey yapamıyordu. İşte şimdi bu yazdığımız örneği kullanılabilir hale getireceğiz.

Öncelikle örneğimizi tekrar yazalım

```python
from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.textinput import TextInput

class Program(App):
 def build(self):

 self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların hepsini tutan ana pencere düzenimiz

 self.ilkSatir = BoxLayout()
 self.ikinciSatir = BoxLayout()

 self.nick = Label(text = "Nick")
 self.nickKutu = TextInput()

 self.sifre = Label(text = "Şifre")
 self.sifreKutu = TextInput()

 self.buton = Button(text = "Giriş Yap")

 self.ilkSatir.add_widget(self.nick)
 self.ilkSatir.add_widget(self.nickKutu)

 self.ikinciSatir.add_widget(self.sifre)
 self.ikinciSatir.add_widget(self.sifreKutu)

 # Şimdi hepsini ana düzene yerleştiriyoruz

 self.anaDuzen.add_widget(self.ilkSatir)
 self.anaDuzen.add_widget(self.ikinciSatir)
 self.anaDuzen.add_widget(self.buton)

 return self.anaDuzen

Program().run()

```

Nick aldığımız metin kutusunu tek satırlı hale getirmeliyiz. Yani kullanıcı Enter’a bastığı zaman alt satıra geçmemeli. Bunun için

```python
nickKutu = TextInput(multiline = False)

```

yazmamız yeterli. Böylece artık alt satıra geçmeyecek, sağa doğru yazmaya devam edecektir. Bu arada eğer multiline değeri “False” ise, kullanıcı Enter’a bastığında metin kutusu odaktan çıkacaktır.

Şimdi de parolayı aldığımız kutucuğu tek satırlı hale getirelim ve yazılanların görünmemesi için parolayı yıldızlı hale getirelim.

```python
sifreKutu = TextInput(multiline = False, password = True)

```

Böylece kullanıcı şifresini girdiğinde, yazdığı karakter değil yıldız görünecektir. Varsayılan olarak yıldızdır. Değiştirmek isterseniz;

```python
sifreKutu = TextInput(multiline = False,password = True,pasword_mask = "?")

```

Ya da

```python
sifreKutu.password_mask = "?"

```

Şimdi de butonumuza olay ekleyelim. Yani butona basıldığı zaman kutulardaki bilgileri alsın ve kontrol etsin. Eğer bilgiler doğru olursa “Giriş başarılı” yazsın, hatalıysa “Hatalı Giriş” yazsın.

Kodumuzu yeniden yazacak olursak

```python
# coding: utf-8

from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.textinput import TextInput

class Program(App):
 def build(self):

 self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların hepsini tutan ana pencere düzenimiz

 self.ilkSatir = BoxLayout()
 self.ikinciSatir = BoxLayout()

 self.nick = Label(text = "Nick")
 self.nickKutu = TextInput(multiline = False)

 self.sifre = Label(text = "Şifre")
 self.sifreKutu = TextInput(multiline = False,
 password = True,
 password_mask = "?")

 self.buton = Button(text = "Giriş Yap")
 self.buton.bind(on_press = self.kontrol) # Butonumuza tıklama olayı ekledik

 self.ilkSatir.add_widget(self.nick)
 self.ilkSatir.add_widget(self.nickKutu)

 self.ikinciSatir.add_widget(self.sifre)
 self.ikinciSatir.add_widget(self.sifreKutu)

 # Şimdi hepsini ana düzene yerleştiriyoruz

 self.anaDuzen.add_widget(self.ilkSatir)
 self.anaDuzen.add_widget(self.ikinciSatir)
 self.anaDuzen.add_widget(self.buton)

 return self.anaDuzen

 def kontrol(self,event = None):
 if(self.nickKutu.text == "admin" and self.sifreKutu.text == "12345"):
 print("Giriş Başarılı")

 else:
 print("Hatalı Giriş")

Program().run()

```

Programı çalıştırıp kullanıcı adını “admin” ve parolayı “12345” olarak girerseniz “Giriş Başarılı” yazılacaktır. Ancak ikisinden herhangi birini yanlış yazarsanız “Hatalı Giriş” yazılacaktır.

Kutulardaki metinleri kutu.text niteliği yardımıyla aldık. Bu bir String değerdir ve eğer kullanıcıdan sayı aldığımızda bunun String olarak bize verildiğini ve bunu Integer’a çevirmemiz gerektiğini unutmayalım.

###### TextInput Girdilerini Kontrol Etme

TextInput aracımıza girilen girdileri kontrol etmek istersek, TextInput.insert_text() metodunun üzerine yazmalıyız. Yani bu sınıfı miras alıp insert_text() metodunu kendimize göre tekrar yazmalıyız. Hemen bir örnekle bunu görelim

```python
# coding: utf-8

from kivy.app import App
from kivy.uix.textinput import TextInput

class MyInput(TextInput):

 def insert_text(self,substring,from_undo = False):
 s = substring.upper()
 return super(MyInput,self).insert_text(s,from_undo)

class Program(App):

 def build(self):
 return MyInput()

Program().run()

```

Programımıza girilen karakter ister küçük ister büyük olsun, her zaman büyük olarak metin kutusuna eklenecektir. Peki bunu nasıl yaptık? Öncelikle TextInput() sınıfını miras aldık. Miras alma işlemini nesne yönelimli programlamadan biliyor olmanız gerekiyor. Kısaca miras alma, önceden yazılan bir sınıfı yeni yazılan sınıfa katma, onun özelliklerini de kullanmaktır. Biz burada kendimize ait bir metin kutusu yapmak istediğimiz için, ilk olarak TextInput sınıfını miras aldık.

Bu sınıf, girilen yazıları inser_text() metoduyla işlediği için, biz de bu metodu yeniden yazdık. Böylece bir karakter girildiği zaman TextInput sınıfının insert_text() metodu değil, bizim yazdığımız sınıfın insert_tex() metodu çalışacaktır. Böylece biz de gelen karakterleri işleyebileceğiz. Girilen karakter “substring” argümanıyla gelir. Bunu işleyip üst sınıfa işlenmiş olarak göndereceğiz. Biz de burada gelen karakter upper() metoduyla büyük karaktere dönüştürdük ve üst sınıfın insert_text() metodunu değiştirilmiş karakterle birlikte çağırdık. Miras aldığımız sınıfın metodunu çağırmak için super() metodundan yararlanıyoruz.

Bir karakteri değiştirdiğimiz gibi, bu karakterin yazılmamasını da sağlayabiliriz. Diyelim ki “j” harfinin hiç girilmemesini istiyorsunuz, bu durumda “j” harfinin girilmesini şu şekilde engelleyebilirsiniz.

```python
# coding: utf-8

from kivy.app import App
from kivy.uix.textinput import TextInput

class MyInput(TextInput):

 def insert_text(self,substring,from_undo = False):
 if(substring.lower() == "j"):
 return False
 else:
 return super(MyInput,self).insert_text(substring,from_undo)

class Program(App):

 def build(self):
 return MyInput()

Program().run()

```

Programa büyük “J” harfi de girilebileceği için, gelen büyük karakteri küçülterek kontrol edip, hiçbir şekilde bu harfin girişine izin vermiyoruz.

Şimdi, TextInput ile birlikte kullanabileceğimiz bazı nitelikleri ve olayları inceleyelim.

###### selection_text

TextInput üzerinde bir yazı seçildiği zaman, bu seçili yazıya selection_text ile erişebiliriz. Böylece seçili yazı üzerinde işlemler yapabiliriz.

###### focus

TextInput üzerine odaklanıldığı zaman veya odaktan ayrıldığı zaman meydana gelen olay. Örnek kullanım

```python
def on_focus(instance, value):
 if value:
 print('Odaklanıldı', instance)
 else:
 print('Odaktan çıktı', instance)

textinput = TextInput()
textinput.bind(focus=on_focus)

```

###### copy(veri<str>)

Copy fonksiyonu, kopyalama hafızasına verilen “veri” değerini kopyalar. “veri” argümanı String olmalıdır. Eğer “veri” argümanı verilmezse, o anda metin kutusu üzerinde seçili olan metni hafızaya kopyalar.

```python
metinKutusu.copy()

```

Ya da

```python
metinKutusu.copy("kopyala")

```

###### cut()

Copy ile aynı işi yapmakla beraber, kopyaladığı metni metin kutusundan siler, yani bildiğimiz kesme işlemini yapar.

###### paste()

Kopyalama hafızasındaki metni, metin kutusuna o andaki cursor pozisyonuna yerleştirir.

###### readonly

Eğer metin kutusundaki ifadenin kullanıcı tarafından değiştirilmesini istemiyorsanız, readonly niteliğine True değerini vermelisiniz. Böylece kullanıcılar metin kutusundaki metni değiştiremeyecek ancak okuyup kopyalayabilecektir.

```python
metinKutusu.readonly = True

```

###### tab_width

Tab tuşunun varsayılan değeri 4’tür. Eğer bu değeri değiştirmek isterseniz tab_width parametresine bu değeri sayı olarak vermelisiniz.

###### text

TextInput içerisindeki metinde bir değişiklik olduğu zaman, bir “text” olayı meydana gelir. Bu olayı aşağıdaki örnekteki gibi ele alabiliriz

```python
def on_text(instance, value):
 print("TextInput metni değişti: {}".format(value))

textinput = TextInput()
textinput.bind(text=on_text)

```

##### CheckBox

kivy.uix.checkbox.CheckBox

Onay kutuları, genelde bir seçeneğin seçilip seçilmeyeceği veya birden fazla seçenek arasından bir tanesinin seçilmesi gerektiği durumlarda kullanılır. Örneğin, internet sitelerinde üye girişi yaparken bize sorulan “Hesabımı Hatırla” sorusunun yanında bir tane onay kutusu vardır. Seçili olduğunda, bir sonraki girişiniz otomatik yapılacaktır demektir. Eğer seçili olmazsa tarayıcı kapandığı zaman bilgileriniz artık hatırlanmayacaktır.

Çoklu seçime örnek verecek olursak, formlarda cinsiyet sorulduğu zaman Bay-Bayan şeklinde iki seçenekten birisinin seçilmesi gerektiği durumlarda kullanılır. Kivy, bu iki aracı da kullanabilmemiz için bize sunmuştur. Şimdi bunları nasıl kullanacağımızı görelim. Önceki yazılarda yazdığımız örneğe bir de onay kutusu ekleyelim

```python
# coding: utf-8

from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.textinput import TextInput
from kivy.uix.checkbox import CheckBox

class Program(App):
 def build(self):

 self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların hepsini tutan ana pencere düzenimiz

 self.ilkSatir = BoxLayout()
 self.ikinciSatir = BoxLayout()

 self.nick = Label(text = "Nick")
 self.nickKutu = TextInput(multiline = False)

 self.sifre = Label(text = "Şifre")
 self.sifreKutu = TextInput(multiline = False,
 password = True,
 password_mask = "?")

 self.buton = Button(text = "Giriş Yap")
 self.buton.bind(on_press = self.kontrol) # Butonumuza tıklama olayı ekledik

 self.ilkSatir.add_widget(self.nick)
 self.ilkSatir.add_widget(self.nickKutu)

 self.ikinciSatir.add_widget(self.sifre)
 self.ikinciSatir.add_widget(self.sifreKutu)

 self.onaySatir = BoxLayout(size_hint_y = .3)
 # onay kutumuzu ve yazımızı tutacak olan BoxLayout
 # Boyutunu biraz küçülttük :)

 self.onayYazi = Label(text = "Beni Hatırla")
 self.onayKutu = CheckBox()

 self.onaySatir.add_widget(self.onayYazi)
 self.onaySatir.add_widget(self.onayKutu)

 # Şimdi hepsini ana düzene yerleştiriyoruz

 self.anaDuzen.add_widget(self.ilkSatir)
 self.anaDuzen.add_widget(self.ikinciSatir)
 self.anaDuzen.add_widget(self.onaySatir)
 self.anaDuzen.add_widget(self.buton)

 return self.anaDuzen

 def kontrol(self,event = None):
 if(self.nickKutu.text == "admin" and self.sifreKutu.text == "12345"):
 if(self.onayKutu.active):
 print("Giriş Başarılı ve bilgileriniz hatırlanacak")
 else:
 print("Giriş Başarılı, bilgileriniz hatırlanmayacak")

 else:
 print("Hatalı Giriş")

Program().run()

```

BoxLayout içerisine bir satır daha ekledik. Bu satırımız, “Beni Hatırla” yazısını ve onay kutusunu taşıyor. Girişi kontrol ettiğimiz kontrol() fonksiyonunda onay kutusunun “active” yani seçili olup olmadığını kontrol ettik. Onay kutusunun seçili olup olmadığını “active” niteliğiyle öğrenebiliriz. Eğer True ise, kutu seçili demektir. Eğer False ise, onay kutusu seçili değil demektir.

CheckBox pencere aracını, RadioButton olarak kullanmak isterseniz elinizdeki onay kutularının gruplarına aynı değerleri vermeniz gerekiyor. Örneğin

```python
kutu1 = CheckBox(group = 1)
kutu2 = CheckBox(group = 1)

kutu3 = CheckBox(group = 2)
kutu4 = CheckBox(group = 2)

```

kutu1 ve kutu2 aynı grupta olduğu için, biri aktif olduğunda diğeri deaktif olacaktır.

CheckBox ile ilgili bazı niteliklere bakalım

###### color

CheckBox görünümünü(rengini) değiştirmek için kullanılabilir. Liste veya demet olarak parametre alır

###### active

Eğer bir CheckBox’ın aktif olma olayını ele almak isterseniz, bind ile tanımlayıp active parametresine fonksiyonunuzu yazmanız gerekir

```python
def on_checkbox_active(checkbox, value):
 if value:
 print('Checkbox', checkbox, 'aktif')
 else:
 print('Checkbox', checkbox, 'deaktif')

checkbox = CheckBox()
checkbox.bind(active=on_checkbox_active)

```

Fonksiyonunuz iki parametre almalıdır. Birincisi CheckBox’ın kendisi, diğeri aktif olup olmama durumunu belirten boolean bir parametre(True veya False).

##### Image

kivy.uix.image.Image

Eğer uygulamamızda resim göstermek istersek, Image kullanabiliriz. Kivy ile resimleri kullanmak oldukça kolay. Birden fazla resim formatını destekliyor. Yapmamız gereken sadece gerekli sınıfı import etmek ve resim dosyasının yolunu yazmak. Bir örnekle görelim.

```python
# coding:utf-8

from kivy.uix.image import Image
from kivy.app import App

class Yazbel(App):

 def build(self):
 resim = Image(source = "resim.png")

 return resim

Yazbel().run()

```

resim.png dosyası, programınızın ana dosyası ile aynı dizinde olmalıdır. Aksi takdirde ekranda beyaz boş bir alan gösterilir. Resim gösterildiği zaman, boyutu neyse o şekilde yerleştirilir. Resmin boyutlandırılmasını birazdan nitelikleri incelediğimiz zaman göreceğiz.

Resimleri sadece bilgisayarınızdaki bir dosyadan değil, aynı zamanda internet üzerinden gösterebilirsiniz. Bunun için AsyncImage kullanılır. Buyrun örnekle görelim :)

```python
# coding:utf-8

from kivy.uix.image import Image,AsyncImage
from kivy.app import App

class Yazbel(App):

 def build(self):
 resim = AsyncImage(source = "https://www.blogger.com/img/blogger-logotype-color-black-1x.png")

 return resim

Yazbel().run()

```

Resim internet üzerinde yüklenirken, resmin halen yüklenmekte olduğunu gösteren bir “loading” gif’i resmin yerinde durur. Resim yüklenince “loading” gif’i kaldırılır. Eğer bu “loading” gif’ini değiştirmek isterseniz, Loader sınıfını import edip, varsayılanı değiştirmeniz gerekir.

```python
from kivy.loader import Loader # import etme

Loader.loading_image = "your.gif" # varsayılanı değiştirme

```

###### Resmin Boyutlarını Değiştirme

Bir resmin boyutlarını değiştirebiliriz. Bunun için kv dilinden yardım alabiliriz.

```python
Image:
 source:"resim.png"
 width:100
 height:600
 size_hint_x:None
 size_hint_y:None
 keep_ratio:False
 allow_stretch:True

```

Resmin istenilen şekilde boyutlandırılabilmesi için, orantılı boyutlandırma özellikleri None yapılmalıdır. Ve resmin en-boy oranını koruma özelliği False, uzatılma özelliği True yapılmalıdır. Artık resmin boyutlarıyla istediğimiz gibi oynayabiliriz :)

###### allow_stretch

Resmimizin bulunduğu alanı tam olarak doldurmasını istiyorsak kullanabiliriz. Değer olarak True veya False alabilir. True değeri verildiğinde, bulunduğu alana göre boyutu artırılır. Ancak en-boy oranı korunur. Örneğin, eni boyundan büyük olan bir resim, boyutu arttığı zaman da eni boyundan büyük olacaktır.

###### keep_ratio

allow_stretch ile birlikte, en-boy oranını korumadan bulunduğu alanı tam olarak doldurmasını istersek, keep_ratio değerini False yapmalıyız. Bu parametre de, True veya False olarak iki değer alır.

###### anim_delay

Eğer yüklediğiniz resim bir gif ise(veya başka bir animasyon formatı), resim kareleri arasında geçiş süresini anim_delay ile ayarlayabilirsiniz. Varsayılan olarak 0.25’tir. Yani saniyede 4 kare.

###### anim_loop

Gif dosyamızın kaç kere döngüye gireceğini belirtebiliriz. Örneğin gif’in sadece 1 kez çalışmasını istersek,

```python
resim.anim_loop = 1

```

yazmalıyız. Böylece gif resmimiz bir kere çalışacak ve duracaktır. Varsayılan olarak 0’dır ve -1 değeri verilirse duracaktır

###### reload()

Diskten okuduğumuz resmi değiştirdiğimizde, bunu uygulama içinde güncellemek istersek reload() metodunu kullanabiliriz.

##### ProgressBar

kivy.uix.progressbar.ProgressBar

ProgressBar ile bir işlemin ne kadarının tamamlandığını görsel olarak gösterebiliriz. Kullanımı gayet basit. Basit bir örnek yapalım

```python
# -*- coding: utf-8 -*-

from kivy.app import App
from kivy.uix.progressbar import ProgressBar
from kivy.clock import Clock

class Yazbel(App):
 def build(self):
 self.bar = ProgressBar(max = 100)
 self.deger = 0

 Clock.schedule_once(self.say,1) # 1 ms sonra self.say adlı fonksiyona git

 return self.bar

 def say(self,event = None):
 if(self.deger <= 100):

 self.bar.value = self.deger
 self.deger += 5

 Clock.schedule_once(self.say,.5)

Yazbel().run()

```

ProgressBar’mızı tanımladık ve max değerini 100 olarak verdik. Yani eğer barımızın değerini en fazla 100 olarak verebiliriz. Eğer 10 olarak belirleseydik, en fazla 10 değerini verebilirdik. Sonra Clock yardımıyla sayacımız 100 olana kadar döngüye girdik ve barımızın değerini değiştirdik.

#### Uygulama 1 - Resim Görüntüleyici

Şimdiye kadar öğrendiklerimiz ile örnek bir uygulama yapma zamanı geldi. Çünkü uygulamadıkça öğrenmemiz eksik kalır. O yüzden bir örnek yapalım

Örneğimiz bir resim görüntüleyici. Bir klasör içinde bulunan resimleri listeler, sonra bunları ileri ve geri butonlarına bastıkça görüntüler. Planımız ise şöyle. Girişte bir yazı ve bir progressbar olacak. Resimler yüklenirken progressbar üzerinde yüklenme durumu gösterilecek. Tabi, resimler az olduğunda çok hızlı bir şekilde yüklenecek. Ancak örnekte de bulunsun diye bir progressbar eklemek istedim.

Resimlerimiz yüklendikten sonra, ekrandaki yazıyı ve progressbar’ı kaldırıp yerine ana ekranımızı koyacağız. Bunu da ayrı bir fonksiyon içinde yaptık. O zaman şimdi kodumuzu görelim, sonra da incelemeye başlayalım

```python
# -*- coding: utf-8 -*-
# Resim Görüntüleyici
# Yazbel

from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.widget import Widget
from kivy.uix.image import Image
from kivy.clock import Clock
from kivy.uix.progressbar import ProgressBar
import os

class Program(App):

 def resimYukle(self,dosya_yolu):
 # Format listesi
 liste = ["png","gif","jpeg","jpg"]

 # Dosyaların listesini alma
 dosyaListesi = os.listdir(dosya_yolu)
 self.sayac = 0
 self.bar.max = len(dosyaListesi)
 self.bar.value = 0

 # Resim dosyalarını tespit etme
 for i in dosyaListesi:
 if(i.split(".")[-1] in liste):
 self.resimListesi.append(i)

 self.sayac += 1
 self.bar.value = self.sayac

 # Resimlerin yüklenmesi bittikten sonra, görüntüleme ekranını başlatmak üzere
 # self.basla fonksiyonuna git
 self.yukleniyor.text = "Resimler yüklendi"
 Clock.schedule_once(self.basla,1.5)

 def build(self):
 self.resimYolu = "resim/"
 self.resimListesi = list()
 self.resimSirasi = 0

 self.yukleniyor = Label(text = "Resimler yükleniyor...")
 self.bar = ProgressBar()

 self.govde = BoxLayout(orientation = "vertical")
 self.govde.add_widget(self.yukleniyor)
 self.govde.add_widget(self.bar)

 # Resimleri yüklemek üzere, self.resimYukle fonksiyonuna git
 Clock.schedule_once(lambda event = None:self.resimYukle(self.resimYolu),1)

 return self.govde

 def basla(self,event = None):
 # Ekrandaki tüm araçları kaldırıyoruz
 self.govde.clear_widgets()

 # Ve yeni araçlarımızı ekliyoruz
 self.bilgi = Label(text = "[color=#05f]Yazbel[/color] Resim Görüntüleyici",
 markup = True,
 size_hint_y = .1)
 self.resim = Image(source = self.resimYolu+self.resimListesi[0],
 allow_stretch = True,
 keep_ratio = True)

 # Geri ve ileri butonlarını taşıyan BoxLayout
 self.butonBar = BoxLayout(size_hint_y = .15)

 self.ileri = Button(text = "ileri",
 size_hint_x = .2,
 on_release = self.ileriYukle
 )

 self.geri = Button(text = "geri",
 size_hint_x = .2,
 on_release = self.geriYukle)

 self.butonBar.add_widget(self.geri)
 self.butonBar.add_widget(Widget())
 self.butonBar.add_widget(self.ileri)

 self.govde.add_widget(self.bilgi)
 self.govde.add_widget(self.resim)
 self.govde.add_widget(self.butonBar)

 def ileriYukle(self,event = None):
 self.resimSirasi += 1

 # Eğer resim sırası listemizin boyutunu aşmamışsa
 if(self.resimSirasi < len(self.resimListesi)):
 try:
 self.resim.source = self.resimYolu+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

 # Eğer liste boyutunu aşmışsa, bunu sıfırlıyoruz
 else:
 try:
 self.resimSirasi = 0
 self.resim.source = self.resimYolu+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]

 except Exception as e:
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

 def geriYukle(self,event = None):
 self.resimSirasi -= 1

 # Eğer resim sırası listemizin boyutunun altına düşmemişse
 if(self.resimSirasi >= 0):
 try:
 self.resim.source = self.resimYolu+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 print(e)
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

 # Eğer düşmüşse, yani negatif olduysa
 # sırayı listenin sonuna alıyoruz
 else:
 try:
 self.resimSirasi = len(self.resimListesi)-1
 self.resim.source = self.resimYolu+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 print(e)
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

Program().run()

```

Öncelikle, programımız başlar başlamaz yazıyı ve progressbar’ı ekliyoruz sonra da resimlerin yüklenmesi için self.resimYukle fonksiyonuna gidiyoruz.

```python
def resimYukle(self,dosya_yolu):
 # Format listesi
 liste = ["png","gif","jpeg","jpg"]

 # Dosyaların listesini alma
 dosyaListesi = os.listdir(dosya_yolu)
 self.sayac = 0
 self.bar.max = len(dosyaListesi)
 self.bar.value = 0

 # Resim dosyalarını tespit etme
 for i in dosyaListesi:
 if(i.split(".")[-1] in liste):
 self.resimListesi.append(i)

 self.sayac += 1
 self.bar.value = self.sayac

 # Resimlerin yüklenmesi bittikten sonra, görüntüleme ekranını başlatmak üzere
 # self.basla fonksiyonuna git
 self.yukleniyor.text = "Resimler yüklendi"
 Clock.schedule_once(self.basla,1)

```

Bu fonksiyonda ilk olarak, hangi resim formatlarını göstereceğimizi bir listede tuttuk. Farklı resim formatları da ekleyebilirsiniz. Biz şimdilik bu 4 formatı tercih ettik. Bu formatlar dışındaki resimleri dikkate almayacaktır.

Formatlarımızı tanımladıktan sonra, os.listdir() yardımıyla hangi klasördeki resimleri göstermek istiyorsak, o klasördeki dosyaları liste olarak elde ediyoruz. Bakın resimleri değil, dosyaları diyorum. Çünkü os.listdir() sadece verilen dizindeki dosyaların listesini verir. Bu listeden resim dosyalarını, bizim belirlediğimiz formatta olanları, ayırt etmek bizim işimiz.

Bu yüzden hemen aşağısında for döngüsü ile bu listenin elemanlarını tek tek kontrol ettik, ve uzantısı bizim belirttiğimiz uzantılardan biriyle eşleşiyorsa, self.resimListesi adlı listemize ekledik.

Tüm resimleri tespit ettikten sonra, 1 saniye sonra self.basla fonksiyonuna gidiyoruz. Bu fonksiyonda, ekrandaki tüm araçları self.govde.clear_widgets() ile temizledik ve yeni araçlarımızı ekledik.

```python
def basla(self,event = None):
 # Ekrandaki tüm araçları kaldırıyoruz
 self.govde.clear_widgets()

 # Ve yeni araçlarımızı ekliyoruz
 self.bilgi = Label(text = "[color=#05f]Yazbel[/color] Resim Görüntüleyici",
 markup = True,
 size_hint_y = .1)
 self.resim = Image(source = self.resimYolu+os.sep+self.resimListesi[0],
 allow_stretch = True,
 keep_ratio = True)

 # Geri ve ileri butonlarını taşıyan BoxLayout
 self.butonBar = BoxLayout(size_hint_y = .15)

 self.ileri = Button(text = "ileri",
 size_hint_x = .2,
 on_release = self.ileriYukle
 )

 self.geri = Button(text = "geri",
 size_hint_x = .2,
 on_release = self.geriYukle)

 self.butonBar.add_widget(self.geri)
 self.butonBar.add_widget(Widget())
 self.butonBar.add_widget(self.ileri)

 self.govde.add_widget(self.bilgi)
 self.govde.add_widget(self.resim)
 self.govde.add_widget(self.butonBar)

```

Bu fonksiyonda yabancı olduğumuz bir kod yok sanırım.Kullandığımız tüm pencere araçlarını daha önce gördük. Sadece butonBar içine eklediğimiz bir adet boş widget var. Onu da iki butonun arasını doldurmak için ekledik. Eklemeseydik de olurdu tabi.

Butonlarımızı ekledik ve ileri butonuna tıklandığı zaman, self.ileriYukle fonksiyonumuzun çalışmasını sağladık.

```python
def ileriYukle(self,event = None):
 self.resimSirasi += 1

 # Eğer resim sırası listemizin boyutunu aşmamışsa
 if(self.resimSirasi < len(self.resimListesi)):
 try:
 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

 # Eğer liste boyutunu aşmışsa, bunu sıfırlıyoruz
 else:
 try:
 self.resimSirasi = 0
 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]

 except Exception as e:
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

```

İlk olarak resimSirasi değişkenini 1 artırıyoruz ve sonra da bu değerin listemizin boyutunu aşıp aşmadığını kontrol ediyoruz. Çünkü eğer boyutunu aşarsa, “liste boyutu aşıldı” hatası alabiliriz. Bu yüzden eğer boyutu aştıysa, değerini tekrardan 0 yapıyoruz

Geri butonumuz için de benzer şeyleri yapıyoruz

```python
def geriYukle(self,event = None):
 self.resimSirasi -= 1

 # Eğer resim sırası listemizin boyutunun altına düşmemişse
 if(self.resimSirasi >= 0):
 try:
 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 print(e)
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

 # Eğer düşmüşse, yani negatif olduysa
 # sırayı listenin sonuna alıyoruz
 else:
 try:
 self.resimSirasi = len(self.resimListesi)-1
 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self.resimSirasi]
 self.bilgi.text = self.resimListesi[self.resimSirasi]
 except Exception as e:
 print(e)
 self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self.resimSirasi])

```

Burada farklı olarak, resimSirasi değerinin eksiye düşüp düşmediğini kontrol ettik. Eksiye düştüyse, tekrar listenin sonuna alıyoruz. Böylece bir döngü içinde resimlerin görüntülenmesini sağladık.

Örnekte bulunan os.sep, bulunduğunuz işletim sisteminde kullanılan dizin ayracını verir. Linux kullanıyorsanız, “/” Windows kullanıyorsanız “\” veya “" olarak belirlenir. Örnekte kullanmamızın sebebi, resim yolu ve resim adını birleştirdiğimizde araya dizin ayracı koymak. Eğer koymazsak, resmin bulunamadığına dair hata alırız.

```python
>>> resimYolu+os.sep+resim
"resim/resim.jpg"

>>> resimYolu+resim
"resimresim.jpg"

```

Ben örnekte görüntülemek istediğim resimleri, program ile aynı klasörde bulunan “resim” adlı klasöre koydum. Eğer aynı klasörde bulunmayan başka bir klasörü listelemek isterseniz, tam dizini vermeniz gerekiyor. Yani “C:\resimler” gibi.

Programın görüntüsü şöyle

Gayet güzel çalışıyor. Kodu elimden geldiği kadar anlaşılır yazmaya çalıştım. Eğer anlamadığınız bir kısım olursa, veya hata olduğunu düşündüğünüz bir kısım varsaForumüzerinden ulaşabilirsiniz.

#### Olaylar

Olaylardan önceki bölümlerde bahsetmiştik, ancak detaylı olarak anlatmamıştık. Bu bölümde olaylardan biraz daha detaylı bir şekilde bahsedeceğiz. Öncelikle olay nedir tanımlamaya çalışalım. Bir olay, kullanıcı etkileşimi sonucu oluşabilen durumların tümüne denir. Örneğin kullanıcının bir butona tıklaması, bir pencere aracının üzerine mouse ile gelmesi, bir pencere aracından mouse tıklamasını kaldırması veya bir pencere aracını seçmesi(checkbox gibi araçlar) bütün hepsi birer olay olarak ele alınır.

Kullanıcı taraflı gerçekleşmeyen, ancak birer olay olarak ele alınan durumlar da vardır. Örneğin bir resmin yüklenmeye başlaması, yüklenmesinin bitmesi durumları da birer olaydır. Bunlara da yeri geldiğinde değineceğiz.

Olaylar, kullanıcı hareketlerini yorumlamanın iyi bir yoludur. Bu hareketleri yorumlamak için, fonksiyonlarımızı ilgili olaylara bağlamalıyız. Örneğin kullanıcı butona bastığı zaman şu fonksiyonum çalışsın, ben de gerekli bilgileri alarak işlem yapayım.

Şimdi bazı belli başlı olayları inceleyelim.

##### Clock Olayları

Clock ile ilgili daha önce bir örnek yapmıştık. Clock sınıfı, belirtilen süre sonunda bir fonksiyon çalıştırmak üzere tasarlanmıştır. İşte bu süre sonunda fonksiyonu çalıştırması, bir olay olarak ele alınıyor. Clock için zamanlayıcı da diyebiliriz.

Clock sınıfını iki şekilde kullanabiliriz. Birincisi, fonksiyonun sadece bir kez çağrılması. Yani belirtilen süre sonunda, fonksiyon çalıştırılır ve işlem tamamlanır. Bir örnekle görelim

```python
# coding: utf-8

from kivy.app import App
from kivy.clock import Clock
from kivy.uix.label import Label

class Program(App):
 def build(self):

 self.yazi = Label(text = "Merhaba")

 Clock.schedule_once(self.degistir,3) # 3 saniye sonra, self.degistir adlı fonksiyonu çalıştır

 return self.yazi

 def degistir(self,event):
 self.yazi.text = "Dünya"

Program().run()

```

Program başladıktan 3 saniye sonra, ekrandaki “Merhaba” yazısı, “Dünya” yazısıyla değiştirilecektir. Böylece işlem tamamlanmış olacaktır.

Clock sınıfının bir başka kullanımı ise, belli aralıklarla sürekli çalışmasıdır. Fonksiyonu çalıştırır, sonra belirtilen süre kadar bekler ve sonra tekrar çalıştırır. Bunu, siz sonlandırana kadar veya program kapanana kadar yapmaya devam eder. Saat örneği, bu kullanım için çok iyi bir örnektir.

```python
# coding: utf-8

from kivy.app import App
from kivy.clock import Clock
from kivy.uix.label import Label
import datetime

class Program(App):
 def build(self):
 self.yazi = Label(text = "Merhaba",markup = True)

 Clock.schedule_interval(self.degistir,1) # 1 saniye sonra, self.degistir adlı fonksiyonu çalıştır

 return self.yazi

 def degistir(self,event):
 zaman = datetime.datetime.now()
 self.saat = "[size=25sp]{}:{}:{}[/size]".format(zaman.hour,zaman.minute,zaman.second)
 self.yazi.text = self.saat

Program().run()

```

Programda kullandığımız datetime modülü, zaman bilgisini elde etmek içindir. Dikkat ettiyseniz, sürekli çalışmasını istediğimizde Clock.schedule_interval() kullanıyoruz. Bir saniye aralıkla çalışmasını sağlayarak, ekranda zaman bilgisini göstermiş olduk.

Her iki kullanım şeklinde dikkat etmemiz gereken şey, çalıştırılacak olan fonksiyonun mutlaka bir argüman almasıdır. Burda kullandığımız “self” dışında alması gereken bir argüman olduğunu görüyoruz. Bu argüman, belirlediğimiz zamanın kendisidir.

Eğer tanımladığınız bir Clock nesnesini kaldırmak isterseniz;

```python
# Tanımladık
self.event = Clock.schedule_interval(self.fonk,2)
self.event2 = Clock.schedule_once(self.fonk2,5)

# Ve bunları kaldırıyoruz
self.event.cancel()
Clock.unschedule(self.event2)

```

##### Girdi Olayları

Kullanıcı girdisi sonucu oluşan olaylardır. Tıklama, basılı halde sürükleme, bırakma, mouse tekerleği hareketi gibi hareketler sonucu oluşan olaylardır. Daha önce buna benzer olayları bazı pencere araçlarımızda ele almıştık. Bunlardan birisi Button sınıfıydı. Bir butonun üzerine tıklanması on_press, bırakılma olayı da on_release ile dinleniyordu.

Genelde bir pencere aracının sahip olduğu olaylar, ilgiliAPIkaynağında bulunur. Böylece kaynağa bakarak, ele almak istediğimiz olayları bind() yardımıyla bağlayabiliriz. Basit bir örnek yapalım isterseniz

```python
# coding: utf-8

from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.textinput import TextInput

class Program(App):
 def build(self):

 self.metin_kutusu = TextInput()
 self.metin_kutusu.bind(text = self.kontrol)

 return self.metin_kutusu

 def kontrol(self,instance,value):
 print(value)

Program().run()

```

TextInput pencere aracı üzerinde herhangi bir yazı yazıldığında çalışacak olan kontrol fonksiyonumuzu tanımladık. Bu fonksiyon iki adet parametre alıyor(self hariç). Bunlardan instance, pencere aracının kendisi, diğeri ise bunun içerdiği metindir. Herhangi bir karakter girişinde kontrol fonksiyonumuz çağrılacaktır. Bağlama işlemini de bind() ile yaptığımıza dikkat edin.

Bunun gibi birçok pencere aracının sahip olduğu olayları API kaynağından inceleyebilirsiniz. Biz de yeri geldiğinde bunlara değineceğiz ve kullanacağız.

#### Pencere Araçları - 2

Pencere araçlarının birinci bölümünde, oldukça temel olan araçları inceledik. Bu bölümde, programın daha kullanışlı olmasını sağlayan, daha iyi bir görünüm imkanı veren, daha dinamik olan, daha ileri pencere araçlarını inceleyeceğiz.

##### Popup

Bazen program çalışırken beklenmedik bir işlem gerçekleştiğinde kullanıcıya bilgi vermek için bir mesaj kutusu gösterilir. Ya da bazen kullanıcının ek bilgi girebilmesi için bir form göstermek istenirse ekranda küçük bir dialog ekranı gösterilir. Bunların hepsini Popup pencereleri ile yapabiliriz. Kivy’de Popup pencereleri, üzerinde başka pencere araçlarını taşırlar. Örneğin ekranda mesaj göstermek istersek, Popup penceresinin içerisinde bir Label tanımlayabiliriz. Birazdan örneklerle beraber göreceğiz.

Popup pencerelerini oluşturmak için öncelikle kivy.uix.popup.Popup sınıfını import etmeliyiz. Sonra da mutlaka içerisinde yer alacak başka bir pencere aracını belirtmeliyiz. Şimdi bir butona tıklandığı zaman ekranda beliren Popup penceresi örneğini yapalım

```python
#coding: utf-8

from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label

class Yazbel(App):
 def build(self):
 self.buton = Button(text = "Bir Mesajınız Var!")
 self.buton.bind(on_release = self.mesaj)

 return self.buton

 def mesaj(self,instance = None):
 popup = Popup(title = "Mesajınız",
 content = Label(text = "Tebrikler! İlk Popup pencereyi başarıyla\noluşturdunuz.")
 )

 popup.open()

Yazbel().run()

```

Örneğimiz oldukça basit. Bir buton tanımladık ve tıklandığı zaman mesaj() metoduna geçiş yaptık. Bu metodumuzun içerisinde de bir tane Popup penceresi oluşturduk ve gerekli özelliklerini tanımladık. title, Popup penceresinin üst kısmında gösterilecek başlığını ifade eder. content ise, Popup penceresi içerisinde gösterilecek pencere aracını ifade eder. Bu pencere aracı sadece Label,Button gibi araçlar değil, bir pencere düzeni de olabilir.

```python
#coding: utf-8

from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):
 self.buton = Button(text = "Bir Mesajınız Var!")
 self.buton.bind(on_release = self.mesaj)

 return self.buton

 def mesaj(self,instance = None):
 govde = GridLayout(rows = 2,column = 1)

 govde.add_widget(Label(text = "[color=#0f0]Gönderen:[/color]Yazbel",
 markup = True,
 size_hint_y = .2
 ))

 govde.add_widget(Label(text = "Popup penceresi başarıyla oluşturuldu",
 markup = True,
 halign = "left"))

 popup = Popup(title = "Mesajınız",content = govde)

 popup.open()

Yazbel().run()

```

Ekran görüntüsü

Popup penceresini kapatmak istediğinizde, bunu yapmanın bir yolu olmadığını gördünüz değil mi? Evet, çünkü yazdığımız örnekte pencerenin kapatılmasını sağlayacak bir kod yazmadık. Peki bir Popup penceresini nasıl kapatabiliriz?

Bunun iki yolu var. Birincisi, Popup penceresi dışındaki bir alana basıldığı zaman pencerenin kapatılmasıdır. Yukarıdaki örneğimizde Popup penceremiz tam ekran olarak açıldığı için Popup dışındaki bir alana basamıyoruz. Bu yüzden popup penceremizin boyutlarını değiştirelim ve Popup dışındaki bir alana basıldığı zaman kapanması için auto_dismiss özelliğini aktif edelim

```python
#coding: utf-8

from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout

class Yazbel(App):
 def build(self):
 self.buton = Button(text = "Bir Mesajınız Var!")
 self.buton.bind(on_release = self.popAc)

 return self.buton

 def popAc(self,instance = None):
 govde = GridLayout(rows = 2,column = 1)

 govde.add_widget(Label(text = "[color=#0f0]Gönderen:[/color]Yazbel",
 markup = True,
 size_hint_y = .2
 ))

 govde.add_widget(Label(text = "Popup penceresi\nbaşarıyla oluşturuldu.\nPencereyi kapatmak için\nalan dışında bir\nyere tıklayın",
 markup = True,
 halign = "left"))

 # Penceremizin boyutlarını 200x200 olarak ayarladık
 # size_hint = (None,None) yazmamızın sebebi
 # otomatik orantılı boyutlandırmayı kapatmak
 # ve pixel bazında boyutlandırmaya izin vermek içindir

 popup = Popup(title = "Mesajınız",
 content = govde,
 auto_dismiss = True,
 size_hint = (None,None),
 size = (200,200))

 popup.open()

Yazbel().run()

```

Programı çalıştırıp, Popup alanı dışındaki bir alana tıklarsanız Popup kapatılacaktır. Popup pencerelerini kapatmanın bir diğer yolu, dismiss() metodunu kullanmaktır. Bu sefer ki örneğimizde kullanıcı programdan çıkmak istesin ve biz de, evet - hayır dialog kutusu göstererek onaylayalım. Eğer kullanıcı hayır derse, Popup pencereyi kapatalım. Evet derse programdan çıkış yapalım.

```python
#coding: utf-8

from kivy.app import App
from kivy.uix.popup import Popup
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.widget import Widget
from kivy.uix.boxlayout import BoxLayout
from kivy.core.window import Window

class Yazbel(App):
 def build(self):

 self.buton = Button(text = "Çıkış Yap")
 self.buton.bind(on_release = self.cikis)

 return self.buton

 def cikis(self,instance = None):

 govde = GridLayout(cols = 1)

 govde.add_widget(Label(markup = True,text = "[color=#fff]Çıkmak istiyor musunuz?[/color]",size_hint_y = .1))
 govde.add_widget(Widget(size_hint_y = .1))

 buton = BoxLayout(size_hint_y = .2)
 buton.add_widget(Button(text = "Evet",markup = True,size_hint_y = .7,on_release = self.kontrol))
 buton.add_widget(Button(text = "Hayır",markup = True,size_hint_y = .7,on_release = self.kontrol))

 govde.add_widget(buton)

 # Penceremizin boyutlarını 200x200 olarak ayarladık
 # size_hint = (None,None) yazmamızın sebebi
 # otomatik orantılı boyutlandırmayı kapatmak
 # ve pixel bazında boyutlandırmaya izin vermek içindir

 self.popup = Popup(title = "Çıkış",
 content = govde,
 auto_dismiss = False,
 size_hint = (None,None),
 size = (200,200))

 self.popup.open()

 def kontrol(self,instance = None):
 buton_yazisi = instance.text

 if(buton_yazisi == "Evet"):
 Window.close()
 else:
 self.popup.dismiss()

Yazbel().run()

```

Şimdi örneğimizi biraz inceleyelim. İlk olarak bir buton tanımladık ve tıklanıp bırakıldığı zaman(on_release) cikis() metoduna geçiş yapmasını sağladık. Bu metod içerisinde kullanıcıya çıkış yapmak istediğinden emin olup olmadığını soracağımız bir Popup penceresi göstereceğiz. Ve bu Popup penceresi içerisinde yer alacak gövdemizi tanımladık. Gövdemiz bir GridLayout ve biz bunun içerisine yazımızı ve butonlarımızı koyarak rahatlıkla Popup üzerinde gösterebiliriz.

İki adet buton ekledik. Evet ve Hayır butonları. Dikkat ederseniz ikisinin de olaylarına aynı metodu verdik. Yani iki butondan hangisi basılırsa basılsın kontrol() metoduna geçiş yapılacaktır. Biz de bu metod içerisinde tıklanan butonun yazısını ele aldık ve eğer “Evet” butonuna basıldıysa, Window sınıfının close() metodunu kullanarak programdan sağlıklı bir şekilde çıkış yaptık. Yazacağınız programlarda, programınızın içerisinde bir yerde programdan çıkış yapmak isterseniz, bu metodu kullanmanızı tavsiye ederim.

Sonra, eğer “Hayır” butonuna basıldıysa popup penceremizi dismiss() metodu yardımıyla kapattık. Böylece kodumuzu tamamlamış olduk.

Popup penceresine ait bazı özellikleri inceleyelim

###### seperator_color

Popup penceresi ile başlık arasında bulunan uzun çizginin rengini değiştirmek için kullanılır. Liste veya demet olarak değer alır. Varsayılan olarak [47 / 255., 167 / 255., 212 / 255., 1.] değerine sahiptir

###### separator_height

Uzun çizginin yüksekliğini ayarlayabilirsiniz. Varsayılan olarak 2dp dir.

###### title_align

Başlığın pozisyonunu ifade eder. “left”,”right”,”center” ve “justify” değerlerini alır

###### title_color

Aynı zamanda, başlığın rengini de değiştirebilirsiniz. Liste veya demet olarak değer alır. Varsayılan değeri [1, 1, 1, 1].

###### title_font

Başlığın yazı tipini belirtir

###### title_size

Anlaşıldığı gibi, başlığın boyutunu ifade eder. Varsayılan olarak 14sp dir.

### Pyperclip Modülü

Bu modül pano işlemleri ile alakalıdır. Kopyala-yapıştır gibi işlemleri yapmamızı sağlar.

#### Kurulum

Bu modülü kurmak için komut satırına aşağıdaki kodları vermelisiniz:

pip install pyperclip

Modül kurulumunda bir hata ile karşılaşırsanız forum.yazbel.com’dan destek alabilirsiniz.

#### Kullanım

##### copy

Bu fonksiyon panoya veri kopyalamanızı sağlar. Aldığı tek argüman kopyalanacak veridir.

Örnekler:

```python
from pyperclip import copy
copy("Bu veri panoya kopyalanacak veridir.")

```

copy fonksiyonunu çalıştırdıktan sonra metnimiz panoya kopyalanmış olacak. Dilerseniz test edebilirsiniz.

##### paste

Bu fonksiyon o anda panodaki veriyi almamızı sağlar. Fonskiyon panodaki veriyi döndürür.

```python
from pyperclip import paste
result = paste()
print(result)

```

Gördüğünüz kodlar o anda panoda bulunan veriyi ekrana yazdıracaktır.. Eğer panoda veri yoksa boş karakter dizisi döndürülür.

##### waitForPaste

Panoda veri varsa veriyi döndürür, eğer yoksa panoya veri gelene kadar bekler, geldiğinde döndürür.

```python
from pyperclip import waitForPaste
print("Panoda veri varsa ekrana yazdirilacak, yoksa gelene kadar beklenecek.")
result = waitForPaste()
print(result)

```

##### waitForNewPaste

Bu fonksiyon da yukarıdakine benzer. O an panoda veri varsa bile, yeni veri gelene kadar bekler. Panodaki veride bir değişiklik olduğu an yeni veri döndürülür.

```python
from pyperclip import waitForNewPaste
print("Panoya yeni veri geldigi an ekrana yazdirilacak.")
result = waitForNewPaste()
print(result)

```

#### NotImplementedError Hatası

Eğer GNU/Linux dağıtımlarından birini kullanıyorsanız, modülümüzü kullanırken NotImplementedError hatası alabilirsiniz. Bu sorunu çözmek için aşağıdaki yöntemlerden sadece bir tanesini uygulamanız yeterlidir.

##### 1. Yöntem

xsel aracını kurabilirsiniz. Eğer Debian tabanlı bir dağıtım kullanıyorsanız;

```python
sudo apt-get install xsel

```

Eğer Fedora kullanıyorsanız;

```python
sudo dnf install xsel

```

##### 2. Yöntem

xclip aracını kurabilirsiniz. Eğer Debian tabanlı bir dağıtım kullanıyorsanız;

```python
sudo apt-get install xclip

```

Eğer Fedora kullanıyorsanız;

```python
sudo dnf install xcode

```

##### 3. Yöntem

Sisteminize Gtk kurabilirsiniz:

```python
pip install Gtk

```

##### 4. Yöntem

Sisteminize PyQt4 kurabilirsiniz.

```python
pip install PyQt4

```

### Tornado paketi

Bu belgeler eş-zamansız olarak çok sayıda bağlantı kurabilen bir web
frameworkünü anlatmaktadır.

#### Tornado

Eğer yazdığınız sitede gerçek zamanlı(real-time) bağlantılar kullanacaksanız
ya da bir mikro çerçeveye(micro framework) ihtiyacınız varsa tornado tamamen
sizin ihtiyaçlarınız için tasarlanmış bir çerçeve.

##### Kurulum

Tornado’yu kullanmak için önce indirmemiz gerekiyor. Aşağıdaki komutu komut
istemcisinde yazın:

```python
pip install tornado

```

Successfully installed tornado-6.1yazısını gördüyseniz sorunsuzca inmiştir.

##### Proje Oluşturma

Tornado, herhangi bir dizinde açtığınız herhangi bir dosyada çalışabilir. Yani
normal bir python dosyası açalım ve yazmaya başlayalım. Bentornisimli bir
klasör açıp__init__.pydosyasında yazacağım. Önce dosyanın ana
bileşenlerini yazalım:

```python
import tornado.web
import tornado.ioloop

app = tornado.web.Application()
app.listen(8888)

tornado.ioloop.IOLoop.current().start()

```

Hemen burada ne yaptığımızı açıklayalım.

Önce kullanacağımız modülleri içeri aktardık:

```python
import tornado.web
import tornado.ioloop

```

Daha sonra bir sitemizi çalıştırmak için gerekli ayarları yaptık:

```python
app = tornado.web.Application()
# İleride yönlendirme(routing) için kullanacağımız araç.
app.listen(8888)
# Port olarak 8888 belirledik. Siz başka bir sayı seçebilirsiniz.

tornado.ioloop.IOLoop.current().start()
# Sitemizi çalıştırmaya başladık

```

Sitemizi açmak için önce yazdığımız dosyayı çalıştıralım. Daha sonrahttp://localhost:8888/adresine gidelim. Elbette farklı bir port seçtiyseniz
portu değiştirmeyi unutmayın.

Siteye girdiğiniz zaman sizi404: Not Foundyazısı karşılayacak. Çünkü daha
hiç sayfa oluşturmadık. Hadi şimdi bir sayfa oluşturalım.

##### Sayfa Sunma

Sitemizde sayfa sunmak için bir view yazmalıyız. Geleneği bozmayalım ve
“Merhaba Zalim Dünya” yazarak başlayalım. Bu iş içinApplication’da olduğu
gibitornado.webmodülünü kullancağız. Bu seferRequestHandlerisimli
bir sınıf bize yardımcı olacak.

Şimdi yazacağımız kodları içe aktarma ileappdeğişkeni arasına yazalım:

```python
class Merhaba(tornado.web.RequestHandler):
 # View için bir sınıf oluşturduk
 def get(self):
 # Sayfayı yollayan fonksiyonumuz
 self.write("Merhaba, Zalim Dünya!")
 # En basit yolu kullanarak "Merhaba, Zalim Dünya!" yazdık

```

İlk viewımızı yazdık. Şimdi dosyamızı tekrar çalıştırıp test edelim.

Sonuçta bir değişiklik olmadığını göreceksiniz. Yani hâlâ404: Not Foundyazıyor. Çünkü sitemize gelen istekle view arasındaki bağlantıyı kurmadık.
Hadi hemen yapalım.

Kullanıcının siteye girmesiyle sunucuya bir istek yollanır. Bu istek
kullanıcının adres çubuğuna yazdığı ifadeyle doğrudan ilişkilidir.
Mesela kullanıcıhttp://localhost:8888/istihza/yazarsa bizden/istihza/adresini istemiştir. Eğer biz bu adresi bir view ile ilişkilendirdiysek bu view
çalışır. Eğer ilişkilendirmediysek404hatası alırız. BizTornado’da bu
ilişkilendirme işiniApplication’dan faydalanarak yapıyoruz. Yaniapp = tornado.web.Application()diye yazdığımız bölümü düzenleyeceğiz:

```python
app = tornado.web.Application([
 ("/", Merhaba)
])

```

Şu an/isteği ileMerhabaviewı arasında bir ilişki kurduk. Nasıl
yazdığımıza dikkat edelim: Bir liste içinde önce istek sonra view içeren
bir demet. Eğer daha fazla view eklemek isterseniz aynı liste içine demet
ekleyerek yapabilirsiniz.http://localhost:8888/adresine giderekMerhaba, Zalim Dünya!yazdığını görebiliriz.

Yazdığımız kodları topluca paylaşayım:

```python
import tornado.web
import tornado.ioloop

class Merhaba(tornado.web.RequestHandler):
 # View için bir sınıf oluşturduk
 def get(self):
 # Sayfayı yollayan fonksiyonumuz
 self.write("Merhaba, Zalim Dünya!")
 # En basit yolu kullanarak "Merhaba, Zalim Dünya!" yazdık

app = tornado.web.Application([
 ("/", Merhaba)
])
app.listen(8888)

tornado.ioloop.IOLoop.current().start()

```

##### Template(Şablon) Sistemi

Sitemizde göstereceğimiz sayfalarıhtmlformatında yazıp kaydetmeliyiz.
Daha sonra bu dosyalarıTornadoile çağırıp servis etmeliyiz.

Göstereceğimiz sayfalar ikiye ayrılıyor: “Statik” ve “Dinamik”. Statik sayfalarTornado’nun çağırıp değiştirmeden servis ettiği dosyalardır. Dinamik sayfalar
iseTornado’nun çağırdıktan sonra düzenleyip servis ettiği dosyalardır.

Önce birhtmldosyası oluşturalım, ardından bu dosyayı servis edelim.

```python
<!DOCTYPE html>
<html>
<head>
 <title>Merhaba Zalim Dünya</title>
</head>
<body>
 <h1>Merhaba Zalim Dünya</h1>
</body>
</html>

```

Bu dosyayı “index.html” ismiyletornklasörüme kaydedeceğim. Siz başka bir
isimle başka bir klasöre de kaydedebilirsiniz. Hemen servis etmek içinMerhabaview’ını düzenleyelim:

```python
class Merhaba(tornado.web.RequestHandler):
 def get(self):
 loader = tornado.template.Loader(".")
 sayfa = loader.load("index.html").generate()
 self.write(sayfa)

```

Ben servis etmek içinMerhaba view’ını düzenlemeyi tercih ettim. Ancak siz yeni
birviewyazmak isteyebilirsiniz. Bu durumda yazdığınızview’ı yeni bir istek
ile eşleştirmeniz gerekir. Bu iş için de bir örnek verip kodlarımızı açıklayayım.
Oluşturduğunuzview’ın adıYazbelolsun ve/yazbel/isteği ile
ilişkilendirelim:

```python
app = tornado.web.Application([
 ("/", Merhaba), # Buradaki virgülü koymayı unutmayınız
 ("/yazbel/", Yazbel)
])

```

Bu durumu geçip yukarıdaki kodlara tekrar bakalım. İlk satırda eklediğimiz kod:

```python
loader = tornado.template.Loader(".")

```

BuradaHtmldosyalarımızın bulunduğu diziniTornado’ya bildirdik. EğerHtmldosyalarınız farklı bir dizinde yer alıyorsa benim.yazdığım yeri
o dizin ile değiştirmelisiniz.

Peki neden bildirdik? Çünkü web programlamadaHtml,Css,Js,Resimgibi dosyalar kendilerine ait bir klasörde bulunur.
BizHtmldosyalarının bulunduğu klasörü bildirerek tekrar tekrar yazmaktan
kurtulduk. İkinci eklediğimiz satıra bakalım:

```python
sayfa = loader.load("index.html").generate()

```

Burada daha önce oluşturduğumuzloaderdeğişkenini kullanarak sayfamızı
getirdik.generatefonksiyonunu kullanarak sayfayıTornado’nun sunabileceği
bir hale dönüştürdük. Daha sonrawritefonksiyonuyla sayfamızı gösterdik:

```python
self.write(sayfa)

```

Şimdi de dinamik sayfaların nasıl oluşturulduğuna bakalım. Dinamik sayfaların
çağrıldıktan sonra düzenlendiğini söylemiştik. Düzenleyeceğimiz yeriTornado’ya bildirmek içinTemplate`(Şablon) denen bir yöntemden faydalanacağız.
Değişiklik yapmak istediğimiz yeri 2 tane küme parantezi içinde bir isimle
`Htmldosyamızda kullanıyoruz. Hemen birindex.htmldosyasını düzenleyerek bir
örnek verelim.

```python
<!DOCTYPE html>
<html>
<head>
 <title>Merhaba {{ yazbel }}</title>
</head>
<body>
 <h1>Merhaba {{ yazbel }}</h1>
</body>
</html>

```

Burada{{ yazbel }}yazarakyazbelisimli bir değişken tanımladık. Tabi ki
siz farklı bir değişken isimi seçebilirsiniz.

Şu an__init__.pydosyamızı çalıştırıphttp://localhost:8888/adresine
gidersek500hatasıyla karşılaşacağız.__init__.py’nin çalıştığı komut
istemcisine bakarsak bir hata göreceğiz.

```python
NameError: name 'yazbel' is not defined

```

Bu hatadanyazbelisimli bir değişken tanımlayıp ona bir değer vermediğimiz
için karşımıza çıktı. Bu değişkene değer vermek içingeneratefonksiyonunu
kullanacağız:

```python
sayfa = loader.load("index.html").generate(yazbel="Yazbel")

```

__init__.pydosyasını tekrar çalıştırdığımızdaMerhaba Yazbelyazısıyla
karşılaşacağız.

Aklınıza şöyle bir soru takılmış olabilir: Bu şekilde yapmak yerineHtmldosyasını düzenlemek daha kolay olmaz mı?

Elbetteki olabilir ancak aynı işi yapan birkaç view daha yazdığımızda
birkaçHtmldosyası daha oluşturmamız gerekir. Mesela sitemize şu ikiviewda katıldığında dinamik olarak oluşturmak daha mantıklı oluyor:

```python
class Merhaba_istihza(tornado.web.RequestHandler):
 def get(self):
 loader = tornado.template.Loader(".")
 sayfa = loader.load("index.html").generate(yazbel="İstihza")
 self.write(sayfa)

class Merhaba_Dünya(tornado.web.RequestHandler):
 def get(self):
 loader = tornado.template.Loader(".")
 sayfa = loader.load("index.html").generate(yazbel="Dünya")
 self.write(sayfa)

```

Templatesisteminde kullanabileceğimiz bir özellik daha var:if,else,else,for. Fakat bu özelliği 2 küme işareti arasında değil 1 küme 1 yüzde
işareti arasında kullanıyoruz:{% else %}. Bu özelliği anlatma için
listelerden faydalanalım.Merhabaviewımızıyazbeldeğişkenine bir liste
verecek şekilde düzenleyelim:

```python
class Merhaba(tornado.web.RequestHandler):
 def get(self):
 loader = tornado.template.Loader(".")
 liste = [0, 1, 2, 3]
 sayfa = loader.load("index.html").generate(yazbel=liste)
 self.write(sayfa)

```

Hemen bu sayıları listeleyecek birTemplate(Şablon) yazalım. Bu listede
çift sayılar büyük, tek sayılar küçük gözüksün.

```python
<!DOCTYPE html>
<html>
<body>
 {% for sayı in yazbel %}
 {% if sayı%2==0 %}
 <h1> {{ sayı }} </h1>
 {% else %}
 <h4> {{ sayı }} </h4>
 {% end %}
 {% end %}
</body>
</html>

```

Gördüğünüz gibi genel olarakpythonile çok benzer bir yapıya sahip ancak
çok önemli bir fark var.fordöngüsü birendifadesiyle bitiyor. Aynı
şekilde birbiriyle ilişkili kontrol ifadeleri(if,else) hep birlikte
birendile bitiyor.

#### Tornado(devamı)

##### Websocket

Bazen amacımız web sayfaları sunmak olmaz. Uygulamamızla sürekli olarak veri
alışverişinde bulunmak isteriz. Mesela çevrimiçi oyunlarda veya mesajlaşma
uygulamalarında bu durumla sık karşılaşırız. AncakHTTPprotokolü bu iş
için yetersiz kalır. ÇünküHTTPprotokolü en basit haliyle şu şekilde çalışır:
Kullanıcı istek yollar, sunucu isteğe karşılık sayfa yollar, bağlantı kesilir.
Sürekli olarak bağlantı kurmak istediğimizde yeni bir protokol kullanmalıyız:WS.WSprotokolü kullanıcı veya sunucu kapatana kadar bağlantı açık kalır.
Sunucu veya kullanıcı herhangi bir istek olmadan birbirine veri yollayabilir.

Websocket’ler, en basit tabirleHTTPyerineWSprotokolü kullananview’lardır. Biz birviewtanımlarken sadecegetmetodunu yazmıştık.
Çünkü birviewsadece sayfamızı sunuyordu. Ancakwebsocket’ler sadece
sayfa sunmuyorlar, aynı zamanda veri de alıyorlar. Bu yüzden 3 tane
metoda sahipler:on_open,on_message,on_close.

Websocketile bağlantı kurulduğundaon_openmetodu çağrılıyor.Websocket’e mesaj geldiğindeon_messagemetodu çağrılıyor.Websocket’in bağlantısı kapatıldığındaon_closemetodu çağrılıyor.

Bizviewile kullanıcıya veri yollarkenwritemetodundan faydalanmıştık.
Fakatwebsocket’ler bu iş içinwrite_messagemetodunu kullanıyor.

Şimdi gelen mesajları geri gönderen birwebsocketyazalım:

```python
import tornado.web
import tornado.ioloop

import tornado.websocket

class Geri(tornado.websocket.WebSocketHandler):

 def on_open(self):
 print("Bağlantı kuruldu")

 def on_message(self, mesaj):
 print(mesaj)
 self.write_message(mesaj)

 def on_close(self):
 print("Bağlantı kapandı")

app = tornado.web.Application([
 ("/ws/geri", Geri)
])
app.listen(8888)

tornado.ioloop.IOLoop.current().start()

```

İlk işimiz yeni bir kütüphane eklemek oldu.Bu kütüphane bizimwebsocketyazmamız için gerekli sınıfı bulunduruyor.

```python
import tornado.websocket

```

Yeni bir sınıf oluşturduk:

```python
class Geri(tornado.websocket.WebSocketHandler):

```

Bu sınıf bizimwebsocket’imiz. Daha önceviewyazarkentornado.web.RequestHandlersınıfından faydalanmıştık. Şimdi isetornado.websocket.WebSocketHandlersınıfından faydalandık.

Websocketile bağlantı kurulduğunda bizeBağlantı kurulduyazması içinon_openmetodunu düzenledik:

```python
def on_open(self):
 print("Bağlantı kuruldu")

```

Websocket’e mesaj geldiğinde onu yazdırıp geri yollaması içinon_messagemetodunu düzenledik. Burada metodumuzun bir parametresi daha olduğuna dikkat
edelim:

```python
def on_message(self, mesaj):
 # Mesajı yazdır
 print(mesaj)
 # Mesajı geri yolla
 self.write_message(mesaj)

```

Websocketkapandığında ekrana yazdırması içinon_closemetodunu düzenledik:

```python
def on_close(self):
 print("Bağlantı kapandı")

```

Gerekli yönlendirmeyi yapması içinApplicationnesnemizi düzenledik:

```python
app = tornado.web.Application([
 ("/ws/geri/", Geri)
])

```

Burada 2 önemli nokta var. Biz hemwebsocket’leri hemview’ları aynıApplicationnesnesine yazıyoruz. Burada ayrım yapmak için geneldewebsocket’lerin isteklerini “/ws/” ile başlatmaya önem veriyoruz. Diğer
sıkıntı ise gelen isteklerin protokollerine göre ayrılmadan işlenmesi. Yani
kullanıcı “HTTPile mi istekte bulundu,WSile mi istekte bulundu?” diye
sorulmuyor. Bu ayrım direkt olarak bizim o isteğe karşı ne yazdımız ile ilgili.

Websocket’lere tarayıcımızdaki adres çubuğuna yazarak ulaşamayız.
Tarayıcımızdaki adres çubuğu sadeceHTTPprotokolünü kullanır.Websocket’lere ulaşmak için kütüphaneleri kullanıyoruz. Ben size javascript
ile nasıl bağlantı kurabileceğinizi göstereceğim. Bu noktada basit seviyede
javascript bilgisine sahip olmanız gerekiyor.

> **Not**
> Burada javascript için yazdığımız kodları tarayıcınızın konsolunda
yazabilirsiniz. (Tarayıcınızda F12 tuşuna basın ve yukarıdaki
sekmelerden “console” yazanı seçin.)

Not

Burada javascript için yazdığımız kodları tarayıcınızın konsolunda
yazabilirsiniz. (Tarayıcınızda F12 tuşuna basın ve yukarıdaki
sekmelerden “console” yazanı seçin.)

__init__.pydosyamızı çalıştıralım ve javascript kodlarımızı yazmaya
başlayalım.

wsisminde birWebsocketnesnesi oluşturacağız. Javascript’te nesne
oluşturmak içinvardeyimi kullanılıyor ve satır sonuna;koyuluyor.
BirWebsocketnesnesi oluştururken hangi siteye bağlanacağımızı belirtiyoruz:

```python
var ws = new WebSocket("ws://localhost/ws/geri/");

```

Bu koddaHTTPyerineWSprotokolünü kullandığıza ve nasıl kullanıldığına
dikkat edelim: Normaldehttpyazdığımız yerewsyazdık.

Şimdi mesaj geldiğinde çalışacak olanonmessagefonksiyonumuzu yazalım.
Bizim Python’da yaptığımız gibi nesnenin devamına.koyupon_messageekleyerek tanımlayacağız. Javascript’te fonksiyon tanımlarkenfunctiondeyimi
kullanılıyor. Parametrelerfunctiondeyiminden hemen sonra parantez içinde
tanımlanıyor. Fonksiyon ile ilgili kodlar küme parantezleri içinde yine;kullanarak yazılıyor.

Yazdığımız fonksiyon gelen mesajları konsolumuzda yazdırsın. Konsolda yazdırmak
istediğimiz yazılarıconsole.logfonksiyonuna parametre olarak veriyoruz.

```python
ws.onmessage = function(mesaj){console.log(mesaj)}

```

Tornado’da mesaj yollamak içinwrite_messagemetodunu kullanmıştık.
Javascript’te isesendmetodunu kullanacağız.

## Katkıda Bulunanlar

Yeterince gözbebeğinin olduğu yerde tüm hatalar sığdadır.

—Linus Torvalds

Bu sayfada, Python3 belgelerine herhangi bir şekilde katkıda bulunanların
isimleri bir liste halinde yer alıyor.

Lütfen siz de belgelerde gördüğünüz hatalarıGitHubaracılığı ile bildirmekten ya da
düzeltmekten çekinmeyin. Katkılarınız, bu belgelerin hem daha az hata içermesini
hem de daha çok kişiye ulaşmasını sağlayacaktır.
- Hakan Demiral
- Barbaros Akkurt
- Şebnem Duyar
- Onur Eker
- Emre Erözgün
- Tayfun Yaşar
- Metin Hırçın
- Ahmet Öztekin
- Mesut İdiz
- Levent Civa
- Fırat Ekinci
- Talha Kesler
- Ömer Gök
- Yunus Emre Bulut
- Erhan Paşaoğlu
- Cemre Efe Karakaş
- Salim Yıldırım
- Çağatay Genlik
- Valeh Asadlı
- Halit Turan Arıcan
- Levent Güler
- Yaşar Celep
- Uğur Uyar
- Serdar Çağlar
- Ahmet Onur Yıldırım
- Anıl İlginoğlu
- Hüseyin Ulaş Yeltürk
- Nuri Acar
- Azat Fırat Çimen
- Aykut Kardaş
- Sezer Bozkır
- Alican Uzunhan
- Özgür Özer
- Kerim Yıldız
- Muhammed Yılmaz
- Ahmet Erdoğan
- Abdurrahman Dursun
- Tahir Uzelli
- Mehmet Akbay
- Mehmet Çelikyontar
- Savaş Zengin
- Tuncay Güven
- Cafer Uluç
- Nikita Türkmen
- Axolotl Axolotl
- Burak Kadir Er
- Muhammed Hattap Alkan
- Husamsdu
- Ahmet Burak Özyurt
- Yunus Kale
- Adem Kurtipek
- Ali Sezişli
- Ekrem Dinçel
- Ramazan Sancar
- Beyazıt Uysal
- Ramazan Emre Osmanoglu
- Zeki Akyol
- Mertcan Bilek

Hakan Demiral

Barbaros Akkurt

Şebnem Duyar

Onur Eker

Emre Erözgün

Tayfun Yaşar

Metin Hırçın

Ahmet Öztekin

Mesut İdiz

Levent Civa

Fırat Ekinci

Talha Kesler

Ömer Gök

Yunus Emre Bulut

Erhan Paşaoğlu

Cemre Efe Karakaş

Salim Yıldırım

Çağatay Genlik

Valeh Asadlı

Halit Turan Arıcan

Levent Güler

Yaşar Celep

Uğur Uyar

Serdar Çağlar

Ahmet Onur Yıldırım

Anıl İlginoğlu

Hüseyin Ulaş Yeltürk

Nuri Acar

Azat Fırat Çimen

Aykut Kardaş

Sezer Bozkır

Alican Uzunhan

Özgür Özer

Kerim Yıldız

Muhammed Yılmaz

Ahmet Erdoğan

Abdurrahman Dursun

Tahir Uzelli

Mehmet Akbay

Mehmet Çelikyontar

Savaş Zengin

Tuncay Güven

Cafer Uluç

Nikita Türkmen

Axolotl Axolotl

Burak Kadir Er

Muhammed Hattap Alkan

Husamsdu

Ahmet Burak Özyurt

Yunus Kale

Adem Kurtipek

Ali Sezişli

Ekrem Dinçel

Ramazan Sancar

Beyazıt Uysal

Ramazan Emre Osmanoglu

Zeki Akyol

Mertcan Bilek

### Hakan Demiral
- Sonlanan istihza.com projesinin ulaşılamayan linkleri WaybackMachine veritabanındaki
en güncel halleri ile güncellendi.
- Navigation bar kısmındaki kırık pdf linki kaldırılarak açıklaması yapıldı.

Sonlanan istihza.com projesinin ulaşılamayan linkleri WaybackMachine veritabanındaki
en güncel halleri ile güncellendi.

Navigation bar kısmındaki kırık pdf linki kaldırılarak açıklaması yapıldı.

### Barbaros Akkurt
- echo$HOMEkomutunun,C:\Users\falancaşeklinde gösterilen çıktısı/home/istihzaolarak düzeltildi.

echo$HOMEkomutunun,C:\Users\falancaşeklinde gösterilen çıktısı/home/istihzaolarak düzeltildi.

### Şebnem Duyar
- ‘dahtaa’ şeklinde yazılan ‘daha’ kelimesi düzeltildi.
- Bölme işleminde30olarak gösterilen değer3olarak değiştirildi.
- 23 + 5işleminin27olarak gösterilen sonucu28olarak düzeltildi.

‘dahtaa’ şeklinde yazılan ‘daha’ kelimesi düzeltildi.

Bölme işleminde30olarak gösterilen değer3olarak değiştirildi.

23 + 5işleminin27olarak gösterilen sonucu28olarak düzeltildi.

### Onur Eker
- Satırdaki kayma düzeltildi.
- bdeğişkeninin23olarak verilen değeri10olarak düzeltildi.
- count()örneğinin açıklamasında2olarak belirtilen karakter sayısı1olarak düzeltildi.

Satırdaki kayma düzeltildi.

bdeğişkeninin23olarak verilen değeri10olarak düzeltildi.

count()örneğinin açıklamasında2olarak belirtilen karakter sayısı1olarak düzeltildi.

### Emre Erözgün
- type()ile yazılan örnekint()ile yeniden yazıldı.
- Tamsayıya çevrilmesi unutulan öğeler sayıya çevrildi.
- Hatalı çıktı verencount()örneği düzeltildi.

type()ile yazılan örnekint()ile yeniden yazıldı.

Tamsayıya çevrilmesi unutulan öğeler sayıya çevrildi.

Hatalı çıktı verencount()örneği düzeltildi.

### Tayfun Yaşar
- Koyulması unutulan küme parantezleri karakter dizisi içine yerleştirildi.

Koyulması unutulan küme parantezleri karakter dizisi içine yerleştirildi.

### Metin Hırçın
- ‘etkileşimli kabul’ şeklinde yazılan ifade ‘etkileşimli kabuk’ olarak
düzeltildi.
- ‘içidnde’ şeklinde yazılan ifade ‘içinde’ olarak düzeltildi.
- ‘görünmüyür’ şeklinde yazılan ifade ‘görünmüyor’ olarak düzeltildi.
- ‘öğrendikce’ şeklinde yazılan ifade ‘öğrendikçe’ olarak düzeltildi.
- ‘dizilerinne’ şeklinde yazılan ifade ‘dizilerine’ olarak düzeltildi.
- Birbirinden ‘,’ işareti ile ayrılan anahtar-değer çiftleri ‘:’ işareti ile
ayrıldı.
- ‘yanınıra’ şeklinde yazılan ifade ‘yanısıra’ olarak düzeltildi.

‘etkileşimli kabul’ şeklinde yazılan ifade ‘etkileşimli kabuk’ olarak
düzeltildi.

‘içidnde’ şeklinde yazılan ifade ‘içinde’ olarak düzeltildi.

‘görünmüyür’ şeklinde yazılan ifade ‘görünmüyor’ olarak düzeltildi.

‘öğrendikce’ şeklinde yazılan ifade ‘öğrendikçe’ olarak düzeltildi.

‘dizilerinne’ şeklinde yazılan ifade ‘dizilerine’ olarak düzeltildi.

Birbirinden ‘,’ işareti ile ayrılan anahtar-değer çiftleri ‘:’ işareti ile
ayrıldı.

‘yanınıra’ şeklinde yazılan ifade ‘yanısıra’ olarak düzeltildi.

### Ahmet Öztekin
- ‘yukarı’ şeklinde yazılan ifade ‘yukarıda’ olarak düzeltildi.
- rjust()metodunun yanlış yazılan çıktısı düzeltildi.
- l1şeklinde yazılan değişken adıli1olarak düzeltildi.

‘yukarı’ şeklinde yazılan ifade ‘yukarıda’ olarak düzeltildi.

rjust()metodunun yanlış yazılan çıktısı düzeltildi.

l1şeklinde yazılan değişken adıli1olarak düzeltildi.

### Mesut İdiz
- ‘farkedemezsiniz’ şeklinde yazılan kelime ‘farkedemezseniz’ olarak
düzeltildi.
- Unutulan bir ‘a’ harfi eklendi.
- Cümle içinde “’=’ işleci” ifadesinden sonra yazılan “sayı2” ifadesi doğru
yerine yerleştirildi.
- ‘farlıdır’ şeklinde yazılan kelime ‘farklıdır’ olarak düzeltildi.

‘farkedemezsiniz’ şeklinde yazılan kelime ‘farkedemezseniz’ olarak
düzeltildi.

Unutulan bir ‘a’ harfi eklendi.

Cümle içinde “’=’ işleci” ifadesinden sonra yazılan “sayı2” ifadesi doğru
yerine yerleştirildi.

‘farlıdır’ şeklinde yazılan kelime ‘farklıdır’ olarak düzeltildi.

### Levent Civa
- ‘ayrıntılılarıyla’ şeklinde yazılan kelime ‘ayrıntılarıyla’ olarak
düzeltildi.
- Toplam karakter uzunluğuna ilişkin örnek koddaki mantık hatası giderildi.

‘ayrıntılılarıyla’ şeklinde yazılan kelime ‘ayrıntılarıyla’ olarak
düzeltildi.

Toplam karakter uzunluğuna ilişkin örnek koddaki mantık hatası giderildi.

### Fırat Ekinci
- Örnekte ters yazılan ‘Osman’ ve ‘Mehmet’ isimlerinin sırası düzeltildi.

Örnekte ters yazılan ‘Osman’ ve ‘Mehmet’ isimlerinin sırası düzeltildi.

### Talha Kesler
- Kontrol mekanizmalıeval()kodlarındaki hata düzeltildi.
- Hesap makinesi kodlarındaki eksik karakter dizisi düzeltildi.

Kontrol mekanizmalıeval()kodlarındaki hata düzeltildi.

Hesap makinesi kodlarındaki eksik karakter dizisi düzeltildi.

### Ömer Gök
- Dosya karşılaştırma kodlarındaki değişken hataları giderildi.

Dosya karşılaştırma kodlarındaki değişken hataları giderildi.

### Yunus Emre Bulut
- ‘Önclelikle’ olarak yazılan kelime ‘Öncelikle’ olarak düzeltildi.
- Kırık bağlantı düzeltildi.
- 8 bit yerine yanlışlıkla 7 bit olarak belirtilen sayı düzeltildi.

‘Önclelikle’ olarak yazılan kelime ‘Öncelikle’ olarak düzeltildi.

Kırık bağlantı düzeltildi.

8 bit yerine yanlışlıkla 7 bit olarak belirtilen sayı düzeltildi.

### Erhan Paşaoğlu
- ‘Bunun sebebi bir sayı ile (45) karakter dizisini (“45”) birbiriyle
toplamaya çalışmamızdır’ cümlesi ‘Bunun sebebi bir sayı (45) ile bir
karakter dizisini (“45”) birbiriyle toplamaya çalışmamızdır’ şeklinde
düzeltilerek daha berrak bir hale getirildi.

‘Bunun sebebi bir sayı ile (45) karakter dizisini (“45”) birbiriyle
toplamaya çalışmamızdır’ cümlesi ‘Bunun sebebi bir sayı (45) ile bir
karakter dizisini (“45”) birbiriyle toplamaya çalışmamızdır’ şeklinde
düzeltilerek daha berrak bir hale getirildi.

### Cemre Efe Karakaş
- split()olarak yazılan metot adıstrip()olarak
düzeltildi.

split()olarak yazılan metot adıstrip()olarak
düzeltildi.

### Salim Yıldırım
- falanca.png”olarak yazılan karakter dizisi“falanca.png”olarak düzeltildi.
- ‘tatlilar’ şeklinde yazılan kelime ‘tatlılar’ olarak
düzeltildi.
- "{:,}.format(1234567890)olarak yazılan kod"{:,}".format(1234567890)olarak düzeltildi.
- "{:b}.format(2)olarak yazılan kod"{:b}".format(2)olarak düzeltildi.
- Belge güncellemesi esnasında yanlışlıkla paragraftan silinen kısım
tekrar eklendi.

falanca.png”olarak yazılan karakter dizisi“falanca.png”olarak düzeltildi.

‘tatlilar’ şeklinde yazılan kelime ‘tatlılar’ olarak
düzeltildi.

"{:,}.format(1234567890)olarak yazılan kod"{:,}".format(1234567890)olarak düzeltildi.

"{:b}.format(2)olarak yazılan kod"{:b}".format(2)olarak düzeltildi.

Belge güncellemesi esnasında yanlışlıkla paragraftan silinen kısım
tekrar eklendi.

### Çağatay Genlik
- (50087).bit_length()kodunun2olarak gösterilen çıktısı16olarak düzeltildi.

(50087).bit_length()kodunun2olarak gösterilen çıktısı16olarak düzeltildi.

### Valeh Asadlı
- listeolarak belirtilen liste adlarıüyelerolarak düzeltildi.
- Demet içinde‘mehmetşeklinde yazılan karakter dizisi‘mehmet’olarak
düzeltildi.
- TBMMolarak belirtilen karakter dizisi‘TBMM’olarak düzeltildi.
- ‘\nolarak yazılan karakter dizisi‘\n’olarak düzeltildi.

listeolarak belirtilen liste adlarıüyelerolarak düzeltildi.

Demet içinde‘mehmetşeklinde yazılan karakter dizisi‘mehmet’olarak
düzeltildi.

TBMMolarak belirtilen karakter dizisi‘TBMM’olarak düzeltildi.

‘\nolarak yazılan karakter dizisi‘\n’olarak düzeltildi.

### Halit Turan Arıcan
- “Burada ikinci sıradaki sayılar ilk sıradaki sayıların ikili sistemdeki
karşılıklarıdır. Üçüncü sıradaki sayılar ise her bir sayının kaç bit
olduğunu, yani bir bakıma ikili sayma sisteminde kaç basamağa sahip
olduğunu gösteriyor,” cümlesinde ‘sıra’ kelimeleri ‘sütun’ kelimeleri ile
değiştirilerek ifade tarzının daha anlaşılır olması sağlandı.

“Burada ikinci sıradaki sayılar ilk sıradaki sayıların ikili sistemdeki
karşılıklarıdır. Üçüncü sıradaki sayılar ise her bir sayının kaç bit
olduğunu, yani bir bakıma ikili sayma sisteminde kaç basamağa sahip
olduğunu gösteriyor,” cümlesinde ‘sıra’ kelimeleri ‘sütun’ kelimeleri ile
değiştirilerek ifade tarzının daha anlaşılır olması sağlandı.

### Levent Güler
- PDF için kapak tasarımı [bkz.https://web.archive.org/web/20150831052508/http://istihza.com/forum/viewtopic.php?f=40&t=2487]
- Komutun,‘uzak çok uzak…’olarak gösterilen çıktısı'uzakçokuzak...'olarak düzeltildi.
- C:\\aylar\\nisan\\toplam masrafşeklinde gösterilen dizin yoluC:\aylar\nisan\toplam masrafşeklinde düzeltildi.
- ‘\\n’olarak yazılan kaçış dizisi‘\n’olarak düzeltildi.
- İki kez aynı şekilde yazılan kodlar düzeltildi.
- Yanlışlıklast_sizeyerine yazılanst_mtimeniteliği değiştirildi.
- Karakter dizisinin sonuna eklenmesi unutulan satır başı karakteri
(’\n’) eklendi.

PDF için kapak tasarımı [bkz.https://web.archive.org/web/20150831052508/http://istihza.com/forum/viewtopic.php?f=40&t=2487]

Komutun,‘uzak çok uzak…’olarak gösterilen çıktısı'uzakçokuzak...'olarak düzeltildi.

C:\\aylar\\nisan\\toplam masrafşeklinde gösterilen dizin yoluC:\aylar\nisan\toplam masrafşeklinde düzeltildi.

‘\\n’olarak yazılan kaçış dizisi‘\n’olarak düzeltildi.

İki kez aynı şekilde yazılan kodlar düzeltildi.

Yanlışlıklast_sizeyerine yazılanst_mtimeniteliği değiştirildi.

Karakter dizisinin sonuna eklenmesi unutulan satır başı karakteri
(’\n’) eklendi.

### Yaşar Celep
- ‘onlu, sekizli ve onaltılı’ şeklinde yazılması gerekirken ‘onlu ve
onaltılı’ olarak belirtilen ifade düzeltildi.

‘onlu, sekizli ve onaltılı’ şeklinde yazılması gerekirken ‘onlu ve
onaltılı’ olarak belirtilen ifade düzeltildi.

### Uğur Uyar
- ‘print() fonksiyonu, kendisine verilen parametreler arasına birer nokta
yerleştirir,’ cümlesi ‘print() fonksiyonu, kendisine verilen parametreler
arasına birer boşluk yerleştirir,’ olarak düzeltildi.

‘print() fonksiyonu, kendisine verilen parametreler arasına birer nokta
yerleştirir,’ cümlesi ‘print() fonksiyonu, kendisine verilen parametreler
arasına birer boşluk yerleştirir,’ olarak düzeltildi.

### Serdar Çağlar
- Program sonunda kapatılması unutulan bir dosya kapatıldı.
- Liste içinde yer alan sayıların bazılarındaki, hataya yol açan biçim
bozukluğu giderildi.
- print(çeviri_tablosu[i])yerine hatalı olarakprint(i)şeklinde
yazılan kod düzeltildi.
- Uyarı üzerine, belge Python’ın en son sürümüne göre gözden geçirildi.

Program sonunda kapatılması unutulan bir dosya kapatıldı.

Liste içinde yer alan sayıların bazılarındaki, hataya yol açan biçim
bozukluğu giderildi.

print(çeviri_tablosu[i])yerine hatalı olarakprint(i)şeklinde
yazılan kod düzeltildi.

Uyarı üzerine, belge Python’ın en son sürümüne göre gözden geçirildi.

### Ahmet Onur Yıldırım
- '{:o}'.format(1980)yerine hatalı olarak':o'.format(1980)şeklinde yazılan kod düzeltildi.
- closed()olarak belirtilen nitelikclosedolarak düzeltildi.
- sözlük=harfler.index(i)olarak yazılan kodsözlük[i]=harfler.index(i)olarak düzeltildi.
- ‘ifaye’ olarak yazılan kelime ‘ifadeye’ olarak düzeltildi.
- ‘aktarmadağımız’ olarak yazılan kelime ‘aktarmadığımız’ olarak düzeltildi
- Çıktıya eklenmesi unutulanfonk8_fonksiyonu eklendi.
- Bazı GNU/Linux dağıtımlarındawebbrowsermodülününopen()fonksiyonuna verilen websitesi adreslerinin ‘http’ önekiyle yazılması
gerektiğine dair bir not eklendi.
- ‘ayna’ olarak yazılan kelime ‘aynı’ olarak düzeltildi.
- Yanlışlıkla ‘prezantabl’ olarak yazılan liste öğesi ‘konuşkan’ olarak
düzeltildi.
- ‘mimtarisi’ olarak yazılan kelime ‘mimarisi’ olarak düzeltildi.
- %PROCESSOR_ARCHITECTUREolarak yazılan çevre değişkeni%PROCESSOR_ARCHITECTURE%olarak düzeltildi.

'{:o}'.format(1980)yerine hatalı olarak':o'.format(1980)şeklinde yazılan kod düzeltildi.

closed()olarak belirtilen nitelikclosedolarak düzeltildi.

sözlük=harfler.index(i)olarak yazılan kodsözlük[i]=harfler.index(i)olarak düzeltildi.

‘ifaye’ olarak yazılan kelime ‘ifadeye’ olarak düzeltildi.

‘aktarmadağımız’ olarak yazılan kelime ‘aktarmadığımız’ olarak düzeltildi

Çıktıya eklenmesi unutulanfonk8_fonksiyonu eklendi.

Bazı GNU/Linux dağıtımlarındawebbrowsermodülününopen()fonksiyonuna verilen websitesi adreslerinin ‘http’ önekiyle yazılması
gerektiğine dair bir not eklendi.

‘ayna’ olarak yazılan kelime ‘aynı’ olarak düzeltildi.

Yanlışlıkla ‘prezantabl’ olarak yazılan liste öğesi ‘konuşkan’ olarak
düzeltildi.

‘mimtarisi’ olarak yazılan kelime ‘mimarisi’ olarak düzeltildi.

%PROCESSOR_ARCHITECTUREolarak yazılan çevre değişkeni%PROCESSOR_ARCHITECTURE%olarak düzeltildi.

### Anıl İlginoğlu
- ‘denene’ olarak yazılan kelime ‘deneme’ olarak düzeltildi.

‘denene’ olarak yazılan kelime ‘deneme’ olarak düzeltildi.

### Hüseyin Ulaş Yeltürk
- ‘listedindeki’ olarak yazılan kelime ‘listesindeki’ olarak düzeltildi.
- Yanlışlıkla çift yazılan ‘teknik’ kelimesi düzeltildi.
- ‘niteliği’ olarak yazılan kelime ‘niteliğin’ olarak düzeltildi.

‘listedindeki’ olarak yazılan kelime ‘listesindeki’ olarak düzeltildi.

Yanlışlıkla çift yazılan ‘teknik’ kelimesi düzeltildi.

‘niteliği’ olarak yazılan kelime ‘niteliğin’ olarak düzeltildi.

### Nuri Acar
- ‘nitelğin’ olarak yazılan kelime ‘niteliğin’ olarak düzeltildi.
- colorama modülü anlatımı, “print(Fore.RED + ‘sade kırmızı yazı)” satırı
parantez içi sonunda olması gereken ‘ işareti eklendi.
- Fonksiyonlar konusu, cümle sonu harf hatası düzeltmesi.kalacaktır. => kalacaktık.
- Gömülü fonksiyonlar konusu, liste isimlendirmesi eksikliği yüzünden
devamındaki kodlarda ortaya çıkan “NameError: name ‘l’ is not defined”
hatası düzeltmesi.[400, 176, 64, …]l = [400, 176, 64, …]
- Modüller konusu, __name__ Niteliği, kod satır sıralaması düzeltmesi.
Program opsiyonları görüntülenmeden işlem numarası girilmesi istenmesi
durumu düzeltmesi.

‘nitelğin’ olarak yazılan kelime ‘niteliğin’ olarak düzeltildi.

colorama modülü anlatımı, “print(Fore.RED + ‘sade kırmızı yazı)” satırı
parantez içi sonunda olması gereken ‘ işareti eklendi.

Fonksiyonlar konusu, cümle sonu harf hatası düzeltmesi.

kalacaktır. => kalacaktık.

Gömülü fonksiyonlar konusu, liste isimlendirmesi eksikliği yüzünden
devamındaki kodlarda ortaya çıkan “NameError: name ‘l’ is not defined”
hatası düzeltmesi.

[400, 176, 64, …]

l = [400, 176, 64, …]

Modüller konusu, __name__ Niteliği, kod satır sıralaması düzeltmesi.
Program opsiyonları görüntülenmeden işlem numarası girilmesi istenmesi
durumu düzeltmesi.

### Azat Fırat Çimen
- ‘gün_sayısı’ olarak yazılan değişken adı ‘gün’ olarak düzeltildi.

‘gün_sayısı’ olarak yazılan değişken adı ‘gün’ olarak düzeltildi.

### Aykut Kardaş
- nşeklinde yazılan kaçış dizisi,\nolarak düzeltildi.

nşeklinde yazılan kaçış dizisi,\nolarak düzeltildi.

### Sezer Bozkır
- ‘derini’ şeklinde yazılan kelime ‘değerini’ olarak düzeltildi.

‘derini’ şeklinde yazılan kelime ‘değerini’ olarak düzeltildi.

### Alican Uzunhan
- ifbloğundaki girinti kayması düzeltildi.
- ‘gözde’ şeklinde yazılan kelime ‘göze’ olarak düzeltildi.
- Örnek bir koddaki değişken ve işleç hatası düzeltildi.
- ‘kullanmasınız’ şeklinde yazılan kelime ‘kullanmasanız’ olarak düzeltildi.
- ‘programımımızın’ şeklinde yazılan kelime ‘programımızın’ olarak
düzeltildi.
- self.__personelolarak yazılan değişkenself._personelolarak
düzeltildi.
- ‘mekanizmasınına’ olarak yazılan kelime ‘mekanizmasına’ olarak düzeltildi.
- ‘konuları de’ olarak yazılan ifade ‘konuları da’ olarak düzeltildi.
- ‘akrarırken’ olarak yazılan kelime ‘aktarırken’ olarak düzeltildi.
- sa\*tolarak görünen düzenli ifadesa*tolarak düzeltildi.
- print(im)şeklinde yazılanprint(veri)olarak düzeltildi.
- ‘yardınıyla’ olarak yazılan kelime ‘yardımıyla’ olarak düzeltildi.
- ‘Burada kadar’ olarak yazılan ifade ‘buraya kadar’ olarak düzeltildi

ifbloğundaki girinti kayması düzeltildi.

‘gözde’ şeklinde yazılan kelime ‘göze’ olarak düzeltildi.

Örnek bir koddaki değişken ve işleç hatası düzeltildi.

‘kullanmasınız’ şeklinde yazılan kelime ‘kullanmasanız’ olarak düzeltildi.

‘programımımızın’ şeklinde yazılan kelime ‘programımızın’ olarak
düzeltildi.

self.__personelolarak yazılan değişkenself._personelolarak
düzeltildi.

‘mekanizmasınına’ olarak yazılan kelime ‘mekanizmasına’ olarak düzeltildi.

‘konuları de’ olarak yazılan ifade ‘konuları da’ olarak düzeltildi.

‘akrarırken’ olarak yazılan kelime ‘aktarırken’ olarak düzeltildi.

sa\*tolarak görünen düzenli ifadesa*tolarak düzeltildi.

print(im)şeklinde yazılanprint(veri)olarak düzeltildi.

‘yardınıyla’ olarak yazılan kelime ‘yardımıyla’ olarak düzeltildi.

‘Burada kadar’ olarak yazılan ifade ‘buraya kadar’ olarak düzeltildi

### Özgür Özer
- ‘Flemenkçe’ olarak yazılan kelime ‘Felemenkçe’ olarak düzeltildi.
- ‘komutunun’ olarak yazılan kelime ‘komutun’ olarak düzeltildi.
- Yanlışlıkla iki kez yazılan ‘bir’ kelimesi teke indirildi.
- ‘fonksiyonun’ olarak yazılan kelime ‘fonksiyonunun’ olarak düzeltildi.

‘Flemenkçe’ olarak yazılan kelime ‘Felemenkçe’ olarak düzeltildi.

‘komutunun’ olarak yazılan kelime ‘komutun’ olarak düzeltildi.

Yanlışlıkla iki kez yazılan ‘bir’ kelimesi teke indirildi.

‘fonksiyonun’ olarak yazılan kelime ‘fonksiyonunun’ olarak düzeltildi.

### Kerim Yıldız
- ‘yime’ olarak yazılan kelime ‘yine’ olarak düzeltildi.

‘yime’ olarak yazılan kelime ‘yine’ olarak düzeltildi.

### Muhammed Yılmaz
- ‘randrage’ olarak yazılan fonksiyon adı ‘randrange’ olarak düzeltildi.

‘randrage’ olarak yazılan fonksiyon adı ‘randrange’ olarak düzeltildi.

### Ahmet Erdoğan
- print('a','b',end='')komutunun çıktı görünümü düzeltildi.

print('a','b',end='')komutunun çıktı görünümü düzeltildi.

### Abdurrahman Dursun
- Cümlede yanlış yerde kullanılan ‘end’ ve ‘sep’ kelimeleri düzeltildi.
- Yanlışlıkla ‘alnımız dik’ olarak yazılan ifade ‘başımız dik’ olarak
düzeltildi.
- Kendisinden önceki cümlede ifade edilen fikri tekrar eden gereksiz bir
cümle paragraftan çıkarıldı.
- Karakter dizisinin, unutulan kapatma tırnağı yerine koyuldu.

Cümlede yanlış yerde kullanılan ‘end’ ve ‘sep’ kelimeleri düzeltildi.

Yanlışlıkla ‘alnımız dik’ olarak yazılan ifade ‘başımız dik’ olarak
düzeltildi.

Kendisinden önceki cümlede ifade edilen fikri tekrar eden gereksiz bir
cümle paragraftan çıkarıldı.

Karakter dizisinin, unutulan kapatma tırnağı yerine koyuldu.

### Tahir Uzelli
- Yanlışlıkla ‘8 adet bir’ şeklinde yazılan ifade ‘8 adet bit’ olarak
düzeltildi.

Yanlışlıkla ‘8 adet bir’ şeklinde yazılan ifade ‘8 adet bit’ olarak
düzeltildi.

### Mehmet Akbay
- Yanlışlıkla ‘a1.txt’ olarak belirtilen dosya adı ‘hakkında.txt’ olarak
düzeltildi.

Yanlışlıkla ‘a1.txt’ olarak belirtilen dosya adı ‘hakkında.txt’ olarak
düzeltildi.

### Mehmet Çelikyontar
- Yanlışlıkla ‘satı1’ olarak yazılan kelime ‘satır1’ olarak düzeltildi.

Yanlışlıkla ‘satı1’ olarak yazılan kelime ‘satır1’ olarak düzeltildi.

### Savaş Zengin
- Kodlardaki eksik parantez düzeltildi.
- [^A-Z-a-z_]düzenli ifadesi[^A-Za-z0-9_]olarak düzeltildi.
- Kodlara yanlışlıkla fazladan eklenen\işareti kaldırıldı.

Kodlardaki eksik parantez düzeltildi.

[^A-Z-a-z_]düzenli ifadesi[^A-Za-z0-9_]olarak düzeltildi.

Kodlara yanlışlıkla fazladan eklenen\işareti kaldırıldı.

### Tuncay Güven
- python3.pdfadlı belgenin yanlış yazılan indirme adresi düzeltildi.

python3.pdfadlı belgenin yanlış yazılan indirme adresi düzeltildi.

### Cafer Uluç
- ‘GNU-dışı’ ifadesi ‘GNU dışı’ olarak düzeltildi.
- ‘websitesi’ kelimesi ‘web sitesi’ olarak düzeltildi.

‘GNU-dışı’ ifadesi ‘GNU dışı’ olarak düzeltildi.

‘websitesi’ kelimesi ‘web sitesi’ olarak düzeltildi.

### Nikita Türkmen
- Kodlardaki bir adet fazla boşluk karakteri kaldırıldı.
- Yanlışlıkla 3 milisaniye olarak belirtilen değer 300 milisaniye olarak
düzeltildi.
- Çalışan.personelolarak belirtilmesi gerekirkenpersonelolarak
belirtilen değişken adı düzeltildi.

Kodlardaki bir adet fazla boşluk karakteri kaldırıldı.

Yanlışlıkla 3 milisaniye olarak belirtilen değer 300 milisaniye olarak
düzeltildi.

Çalışan.personelolarak belirtilmesi gerekirkenpersonelolarak
belirtilen değişken adı düzeltildi.

### Axolotl Axolotl
- Yanlışlıkla ‘yukarı’ olarak yazılan kelime ‘yukarıda’ olarak düzeltildi.
- Kodlardaki yanlış girintileme düzeltildi.
- Gereksiz bir virgül işareti kaldırıldı.
- Yanlışlıkla ‘olmadığını’ olarak yazılan kelime ‘oluşmadığını’ olarak
düzeltildi.
- Sürüm bilgisini gösteren çıktıdaki ‘Python’ ifadesi kaldırıldı.
- ‘metodununa’ olarak yazılan kelime ‘metoduna’ olarak düzeltildi.
- Gereksiz bir virgül işareti kaldırıldı.
- ‘ilermeye’ olarak yazılan kelime ‘ilerlemeye’ olarak düzeltildi.
- Kodun hatalı çıktısı düzeltildi.
- ‘<’ işareti ‘>’ olarak düzeltildi.
- Kodlardaki gereksiz bir parantez kaldırıldı.
- Cümledeki gereksiz bir virgül işareti kaldırıldı.
- Küçük harfle başlanan cümle düzeltildi.
- ‘isim 5 karakterden küçükse’ ifadesi ‘isim 5 karakterse veya bundan
küçükse’ olarak düzeltildi.
- Unutulan bir ‘a’ harfi eklendi.
- Cümle sonunda unutulan nokta işareti eklendi.
- ‘metodunu’ olarak yazılan kelime ‘metodu’ olarak düzeltildi.
- ASCII tablosu ile ilgili bir hata düzeltildi.
- Kullanıcı adı ve parola ile ilgili kodlardaki bir hata giderildi.
- Yanlış yere koyulan nokta işareti kaldırıldı.
- Cümlede farklı nesne grupları birbirinden ayırılırken virgül yerine
noktalı virgül işareti kullanıldı.
- ‘işlemini’ olarak yazılan kelime ‘işlemi’ olarak düzeltildi.
- ‘işare’ olarak yazılan kelime ‘işareti’ olarak düzeltildi.
- Unutulan kod çıktısı eklendi.
- İki nokta işaretinden sonra büyük harfle başlaması gereken cümle
düzeltildi.
- ‘istemiyorsanuz’ olarak yazılan kelime ‘istemiyorsanız’ olarak düzeltildi.
- ‘oyununun’ olarak yazılan kelime ‘oyunun’ olarak düzeltildi.
- ‘O’ olarak yazılması gerekirken ‘Y’ olarak yazılan karakter düzeltildi.
- ‘programımın’ olarak yazılan kelime ‘programın’ olarak düzeltildi.

Yanlışlıkla ‘yukarı’ olarak yazılan kelime ‘yukarıda’ olarak düzeltildi.

Kodlardaki yanlış girintileme düzeltildi.

Gereksiz bir virgül işareti kaldırıldı.

Yanlışlıkla ‘olmadığını’ olarak yazılan kelime ‘oluşmadığını’ olarak
düzeltildi.

Sürüm bilgisini gösteren çıktıdaki ‘Python’ ifadesi kaldırıldı.

‘metodununa’ olarak yazılan kelime ‘metoduna’ olarak düzeltildi.

Gereksiz bir virgül işareti kaldırıldı.

‘ilermeye’ olarak yazılan kelime ‘ilerlemeye’ olarak düzeltildi.

Kodun hatalı çıktısı düzeltildi.

‘<’ işareti ‘>’ olarak düzeltildi.

Kodlardaki gereksiz bir parantez kaldırıldı.

Cümledeki gereksiz bir virgül işareti kaldırıldı.

Küçük harfle başlanan cümle düzeltildi.

‘isim 5 karakterden küçükse’ ifadesi ‘isim 5 karakterse veya bundan
küçükse’ olarak düzeltildi.

Unutulan bir ‘a’ harfi eklendi.

Cümle sonunda unutulan nokta işareti eklendi.

‘metodunu’ olarak yazılan kelime ‘metodu’ olarak düzeltildi.

ASCII tablosu ile ilgili bir hata düzeltildi.

Kullanıcı adı ve parola ile ilgili kodlardaki bir hata giderildi.

Yanlış yere koyulan nokta işareti kaldırıldı.

Cümlede farklı nesne grupları birbirinden ayırılırken virgül yerine
noktalı virgül işareti kullanıldı.

‘işlemini’ olarak yazılan kelime ‘işlemi’ olarak düzeltildi.

‘işare’ olarak yazılan kelime ‘işareti’ olarak düzeltildi.

Unutulan kod çıktısı eklendi.

İki nokta işaretinden sonra büyük harfle başlaması gereken cümle
düzeltildi.

‘istemiyorsanuz’ olarak yazılan kelime ‘istemiyorsanız’ olarak düzeltildi.

‘oyununun’ olarak yazılan kelime ‘oyunun’ olarak düzeltildi.

‘O’ olarak yazılması gerekirken ‘Y’ olarak yazılan karakter düzeltildi.

‘programımın’ olarak yazılan kelime ‘programın’ olarak düzeltildi.

### Burak Kadir Er
- “56715değeri olduğu için” ifadesi “56700değeri olduğu için” olarak düzeltildi.
- ‘Pekı’ kelimesi ‘Peki’ olarak düzeltildi.
- “Verebileceğimizi, ‘ama’ bunun bir yolu yordamı olduğunu biliyorsunuz” cümlesi “Verebileceğimizi ‘ve’ bunun bir yolu yordamı olduğunu biliyorsunuz” olarak değiştirildi.
- ‘Herbir’ ve ‘herzamanki’ kelimeleri düzeltildi.
- Demetler kısmında gramer düzeltmesi yapıldı.
- Evaluate kısmında anlatımı pekiştirme açısından eval’li kod örneği eklendi.
- Listelerin metotları kısmında kelime düzeltmesi yapıldı.
- ‘Doğruda’ kelimesi ‘doğrudan’ olarak düzeltildi.
- Sayma sistemleri kısmındaki ‘herbir’ kelimesi düzeltildi.
- ‘veirleri’, ‘verileri’ olarak düzeltildi.
- “Yani karşı karşıya olduğunuz ‘duruma’ değerlendirip”, “Yani karşı karşıya olduğunuz ‘durumu’ değerlendirip” olarak düzeltildi.
- ‘iyiden iyine’, ‘iyiden iyiye’ olarak değiştirildi.
- Gerekli yere soru işareti eklendi.
- Yanlışlıkla iki kez yazılan ‘eğer’ kelimesi düzeltildi.
- Sözlüklerin metotları kısmında kelime düzeltmesi yapıldı.
- ‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.
- Fonksiyonlar kısmındaki gramer hatası düzeltildi.
- Fonksiyonlar kısmındaki kelime hatası düzeltildi.
- ‘metodununa’, ‘metoduna’ olarak düzeltildi.
- Gömülü fonksiyonlar kısmında kelime düzeltmesi yapıldı.
- ‘yanlızca’, ‘yalnızca’ olarak düzeltildi.
- Yanlışlıkla bitişik yazılmış olan ‘yanı sıra’ kelimesi düzeltildi.
- Gömülü fonksiyonlar kısmında birden çok kez yanlış yazılmış olan ‘herbir’ kelimeleri düzeltildi.
- Input fonksiyonunun değişken adı girilmesi gereken yerde yanlışlıkla özyinelemeli fonksiyon girilen yer düzeltildi.
- Modüller kısmında gramer hatası düzeltildi.
- Modüller kısmında kelime düzeltmesi yapıldı.
- Nesne Tabanlı Programlama(OOP) kısmındaki ‘herbir’ kelimesi, ‘her bir’ olarak düzeltildi.
- ‘şipariş’, ‘sipariş’ olarak düzeltildi.
- Nesne Tabanlı Programlama(OOP) kısmındaki ‘yanısıra’ kelimesi, ‘yanı sıra’ olarak düzeltildi.
- Nesne Tabanlı Programlama(OOP) kısmında ‘örnek niteliği’ olarak yazılmış olan kelime, ‘sınıf niteliği’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.
- Nesne Tabanlı Programlama(Devamı) kısmındaki ‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmındaki ‘sözdizimi’, ‘söz dizimi’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmındaki ‘ve saire’, ‘vesaire’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.
- Nesne Tabanlı Programlama(Devamı) kısmındaki ‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmında birden çok kez yanlış yazılmış olan ‘herbir’ kelimeleri düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmındaki ‘herzamanki’, ‘her zamanki’ olarak düzeltildi.
- Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.
- Nesne Tabanlı Programlama(Devamı) kısmındaki “bu sınıfları ‘uygulamamız’ içine dahil ediyoruz” cümlesi “bu sınıfları
‘uygulamamızın’ içine dahil ediyoruz” olarak düzeltildi.
- Paketler kısmında kelime düzeltmesi yapıldı.
- Düzenli İfadeler kısmında kelime düzeltmesi yapıldı.
- Düzenli İfadeler kısmındaki ‘bir kaç’, “birkaç’ olarak düzeltildi.
- Düzenli İfadeler kısmındaki ‘paramtresinin’, ‘parametresinin’ olarak düzeltildi.
- Düzenli İfadeler kısmındaki ‘websitesinde’, ‘web sitesinde’ olarak düzeltildi.
- Düzenli İfadeler kısmındaki bozuk linkler düzeltildi.
- Düzenli İfadeler kısmında kelime düzeltmesi yapıldı.
- Hata Yakalama kısmında gerekli yere nokta eklendi.
- Hata Yakalama kısmında kelime düzeltmesi yapıldı.
- Random modülü kısmında birden çok kelime düzeltmesi yapıldı.
- OS modülü kısmında birden çok kelime düzeltmesi yapıldı.
- Bezeyiciler kısmında birleşik yazılan bağlaç düzeltildi.
- Bezeyiciler kısmındaki ‘Örnek Olarak’, ‘Örnek olarak’ olarak düzeltildi.
- Bezeyiciler kısmındaki “Çağrılabilir ‘objeleri’ örnek verecek olursak”, “Çağrılabilir ‘objelere’ örnek verecek olursak” olarak düzeltildi.
- Bezeyiciler kısmındaki ‘methodunun’, ‘metodunun’ olarak düzeltildi.
- Bezeyiciler kısmındaki ‘Tabiki’, ‘Tabii ki’ olarak düzeltildi.
- Bezeyiciler kısmındaki bir cümlede anlatım bozukluğu giderildi.
- Bezeyiciler kısmının son bölümündeki hatalı kod düzeltildi.
- Bezeyiciler kısmındaki son cümlelerden birindeki anlatım bozukluğu giderildi.

“56715değeri olduğu için” ifadesi “56700değeri olduğu için” olarak düzeltildi.

‘Pekı’ kelimesi ‘Peki’ olarak düzeltildi.

“Verebileceğimizi, ‘ama’ bunun bir yolu yordamı olduğunu biliyorsunuz” cümlesi “Verebileceğimizi ‘ve’ bunun bir yolu yordamı olduğunu biliyorsunuz” olarak değiştirildi.

‘Herbir’ ve ‘herzamanki’ kelimeleri düzeltildi.

Demetler kısmında gramer düzeltmesi yapıldı.

Evaluate kısmında anlatımı pekiştirme açısından eval’li kod örneği eklendi.

Listelerin metotları kısmında kelime düzeltmesi yapıldı.

‘Doğruda’ kelimesi ‘doğrudan’ olarak düzeltildi.

Sayma sistemleri kısmındaki ‘herbir’ kelimesi düzeltildi.

‘veirleri’, ‘verileri’ olarak düzeltildi.

“Yani karşı karşıya olduğunuz ‘duruma’ değerlendirip”, “Yani karşı karşıya olduğunuz ‘durumu’ değerlendirip” olarak düzeltildi.

‘iyiden iyine’, ‘iyiden iyiye’ olarak değiştirildi.

Gerekli yere soru işareti eklendi.

Yanlışlıkla iki kez yazılan ‘eğer’ kelimesi düzeltildi.

Sözlüklerin metotları kısmında kelime düzeltmesi yapıldı.

‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.

Fonksiyonlar kısmındaki gramer hatası düzeltildi.

Fonksiyonlar kısmındaki kelime hatası düzeltildi.

‘metodununa’, ‘metoduna’ olarak düzeltildi.

Gömülü fonksiyonlar kısmında kelime düzeltmesi yapıldı.

‘yanlızca’, ‘yalnızca’ olarak düzeltildi.

Yanlışlıkla bitişik yazılmış olan ‘yanı sıra’ kelimesi düzeltildi.

Gömülü fonksiyonlar kısmında birden çok kez yanlış yazılmış olan ‘herbir’ kelimeleri düzeltildi.

Input fonksiyonunun değişken adı girilmesi gereken yerde yanlışlıkla özyinelemeli fonksiyon girilen yer düzeltildi.

Modüller kısmında gramer hatası düzeltildi.

Modüller kısmında kelime düzeltmesi yapıldı.

Nesne Tabanlı Programlama(OOP) kısmındaki ‘herbir’ kelimesi, ‘her bir’ olarak düzeltildi.

‘şipariş’, ‘sipariş’ olarak düzeltildi.

Nesne Tabanlı Programlama(OOP) kısmındaki ‘yanısıra’ kelimesi, ‘yanı sıra’ olarak düzeltildi.

Nesne Tabanlı Programlama(OOP) kısmında ‘örnek niteliği’ olarak yazılmış olan kelime, ‘sınıf niteliği’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.

Nesne Tabanlı Programlama(Devamı) kısmındaki ‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmındaki ‘sözdizimi’, ‘söz dizimi’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmındaki ‘ve saire’, ‘vesaire’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.

Nesne Tabanlı Programlama(Devamı) kısmındaki ‘yanısıra’, ‘yanı sıra’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmında birden çok kez yanlış yazılmış olan ‘herbir’ kelimeleri düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmındaki ‘herzamanki’, ‘her zamanki’ olarak düzeltildi.

Nesne Tabanlı Programlama(Devamı) kısmında birden çok kelime düzeltmesi yapıldı.

Nesne Tabanlı Programlama(Devamı) kısmındaki “bu sınıfları ‘uygulamamız’ içine dahil ediyoruz” cümlesi “bu sınıfları
‘uygulamamızın’ içine dahil ediyoruz” olarak düzeltildi.

Paketler kısmında kelime düzeltmesi yapıldı.

Düzenli İfadeler kısmında kelime düzeltmesi yapıldı.

Düzenli İfadeler kısmındaki ‘bir kaç’, “birkaç’ olarak düzeltildi.

Düzenli İfadeler kısmındaki ‘paramtresinin’, ‘parametresinin’ olarak düzeltildi.

Düzenli İfadeler kısmındaki ‘websitesinde’, ‘web sitesinde’ olarak düzeltildi.

Düzenli İfadeler kısmındaki bozuk linkler düzeltildi.

Düzenli İfadeler kısmında kelime düzeltmesi yapıldı.

Hata Yakalama kısmında gerekli yere nokta eklendi.

Hata Yakalama kısmında kelime düzeltmesi yapıldı.

Random modülü kısmında birden çok kelime düzeltmesi yapıldı.

OS modülü kısmında birden çok kelime düzeltmesi yapıldı.

Bezeyiciler kısmında birleşik yazılan bağlaç düzeltildi.

Bezeyiciler kısmındaki ‘Örnek Olarak’, ‘Örnek olarak’ olarak düzeltildi.

Bezeyiciler kısmındaki “Çağrılabilir ‘objeleri’ örnek verecek olursak”, “Çağrılabilir ‘objelere’ örnek verecek olursak” olarak düzeltildi.

Bezeyiciler kısmındaki ‘methodunun’, ‘metodunun’ olarak düzeltildi.

Bezeyiciler kısmındaki ‘Tabiki’, ‘Tabii ki’ olarak düzeltildi.

Bezeyiciler kısmındaki bir cümlede anlatım bozukluğu giderildi.

Bezeyiciler kısmının son bölümündeki hatalı kod düzeltildi.

Bezeyiciler kısmındaki son cümlelerden birindeki anlatım bozukluğu giderildi.

### Muhammed Hattap Alkan
- Bezeyiciler (decoratorlar) konusu eklendi.

Bezeyiciler (decoratorlar) konusu eklendi.

### Husamsdu
- Birden fazla yazım hatası düzeltildi.

Birden fazla yazım hatası düzeltildi.

### Ahmet Burak Özyurt
- Birden fazla Python sürmümünün yönetilebilmesi için mevcut olanpyenvaracının kurulumu ve kullanımı hakkında rehber hazırlandı.
- Python2 desteğinin sonlandırılmasıyla ilgili ekleme yapıldı.
- f-string kullanımı hakkında detaylar ve örnekler eklendi.

Birden fazla Python sürmümünün yönetilebilmesi için mevcut olanpyenvaracının kurulumu ve kullanımı hakkında rehber hazırlandı.

Python2 desteğinin sonlandırılmasıyla ilgili ekleme yapıldı.

f-string kullanımı hakkında detaylar ve örnekler eklendi.

### Yunus Kale
- Fonksiyonlar konusundaki kod hatası düzeltildi.
- Colorama Modülündeki bir kod hatası ve yazım yanlışı düzeltildi.

Fonksiyonlar konusundaki kod hatası düzeltildi.

Colorama Modülündeki bir kod hatası ve yazım yanlışı düzeltildi.

### Adem Kurtipek
- Kaçış dizileri kısmındakiprint("\N{LATINCAPITALLETTERSWITHCEDILLA}")komutunun, çıktısı olarak gösterilenşdeğeriŞolarak değiştirildi.

Kaçış dizileri kısmındakiprint("\N{LATINCAPITALLETTERSWITHCEDILLA}")komutunun, çıktısı olarak gösterilenşdeğeriŞolarak değiştirildi.

### Ali Sezişli
- Bir yazım hatası düzeltildi.
- RHEL ve CentOS tarafında python3 kurulumu için komut eklendi.
- pyenv bağımlılıklarının kurulumunda Fedora ve RHEL/CentOS ayrıldı.

Bir yazım hatası düzeltildi.

RHEL ve CentOS tarafında python3 kurulumu için komut eklendi.

pyenv bağımlılıklarının kurulumunda Fedora ve RHEL/CentOS ayrıldı.

### Ekrem Dinçel
- Belgelerin tekrardan PDF ve EPUB olarak inşa edilmesi sağlandı.
- Bozuk linkler düzeltildi.

Belgelerin tekrardan PDF ve EPUB olarak inşa edilmesi sağlandı.

Bozuk linkler düzeltildi.

### Ramazan Sancar
- “Koşul Deyimleri” içerisinde tanıma uygun açıklama düzeltildi.
- LISENCE içinde yer alan hatalı (bozuk) bağlantı düzeltildi.

“Koşul Deyimleri” içerisinde tanıma uygun açıklama düzeltildi.

LISENCE içinde yer alan hatalı (bozuk) bağlantı düzeltildi.

### Beyazıt Uysal
- ‘/Ucuncu_taraf_moduller/kivy_dersleri/widgets.rst’ dosyası altında bulunan bir kod bloğunda iki kez kütüphane importu giderildi.
- islecler.rst dosyası içerisinde bulunan “görüntülecektir” kelimesi “görüntülenecektir” olarak düzeltildi.
- kurulum.rst dosyası içerisinde bulunan “yazağımız” kelimesi “yazacağımız” olarak düzeltildi.
- donguler.rst altında yer alan ‘Dosyaların İçeriğini Karşılaştırma’ başlığında kod açıklama hatası düzeltildi.
- sozlukler.rst dosyasında yer alan ve sözlüklerin sıraya sahip olmasıyla ilgili not, HTML dosyasında hatalı bir görünüme sahipti, ancak bu sorun giderildi.

‘/Ucuncu_taraf_moduller/kivy_dersleri/widgets.rst’ dosyası altında bulunan bir kod bloğunda iki kez kütüphane importu giderildi.

islecler.rst dosyası içerisinde bulunan “görüntülecektir” kelimesi “görüntülenecektir” olarak düzeltildi.

kurulum.rst dosyası içerisinde bulunan “yazağımız” kelimesi “yazacağımız” olarak düzeltildi.

donguler.rst altında yer alan ‘Dosyaların İçeriğini Karşılaştırma’ başlığında kod açıklama hatası düzeltildi.

sozlukler.rst dosyasında yer alan ve sözlüklerin sıraya sahip olmasıyla ilgili not, HTML dosyasında hatalı bir görünüme sahipti, ancak bu sorun giderildi.

### Ramazan Emre Osmanoglu
- Colorama dokumanlari eklendi.
- Pyperclip dokumanlari eklendi.
- Recursion dokumanindaki base case duzenlendi.

Colorama dokumanlari eklendi.

Pyperclip dokumanlari eklendi.

Recursion dokumanindaki base case duzenlendi.

### Zeki Akyol
- Kod içermeyen düz metindeki tekrarlayan bir yazım hatası düzeltildi.

Kod içermeyen düz metindeki tekrarlayan bir yazım hatası düzeltildi.

### Mertcan Bilek
- Bitwise (Bitsel) İşleçleri dokumanlari eklendi.

Bitwise (Bitsel) İşleçleri dokumanlari eklendi.

### Gezinti
- ⌂
- Yazbel Python Belgeleri

### Önemli Not

```python

 <pre><code class="python">
 print("Merhaba Dünya!")
 </code></pre>
 
```