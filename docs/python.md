# Python Programlama Dili Referans Belgesi

Bu belge, Python programlama dilinin temel kavramlarını içermektedir.
Resmi akademik dil kullanılmış ve kod örnekleri açıklayıcı yorumlarla desteklenmiştir.

---

```python
Python Belgeleri Yayım 4.1.3 Fırat Özgül | .com 19.08.2024 İçindekiler 1 BuKitapHakkında 1 1.1 BuKitaptanNasılYararlanabilirim? . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.2 NeredenYardımAlabilirim? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.3 ProjeyeNasılYardımcıOlabilirim? . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.4 KullanımKoşulları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2 PythonHakkında 4 2.1 PythonNedir? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 2.2 NedenProgramlamaÖğrenmekİsteyeyim? . . . . . . . . . . . . . . . . . . . . 5 2.3 NedenPython? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 2.4 PythonNasılTelaffuzEdilir? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.5 PlatformDesteği . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 2.6 FarklıPythonSürümleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.7 HangiSeriyiÖğrenmeliyim? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3 PythonNasılKurulur? 9 3.1 GNU/LinuxKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.2 WindowsKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 3.3 PythonKurulumveÇalışmaDizini . . . . . . . . . . . . . . . . . . . . . . . . . 17 4 PythonNasılÇalıştırılır? 19 4.1 GNU/LinuxKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 4.2 WindowsKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 4.3 HangiKomutHangiSürümüÇalıştırıyor? . . . . . . . . . . . . . . . . . . . . . . 27 4.4 SistemKomutSatırıvePythonKomutSatırı . . . . . . . . . . . . . . . . . . . . 28 5 EtkileşimliPython 29 5.1 EtkileşimliKabuktaİlkAdımlar . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 5.2 EtkileşimliKabuğunHafızası . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55 6 print()Fonksiyonu 57 6.1 Nedir,NeİşeYarar? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 6.2 NasılKullanılır? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 6.3 BirFonksiyonOlarakprint() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 6.4 print()FonksiyonununParametreleri . . . . . . . . . . . . . . . . . . . . . . . . 64 6.5 BirkaçPratikBilgi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 i 7 KaçışDizileri 82 7.1 TersTaksim(\) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 7.2 SatırBaşı(\n) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 7.3 Sekme(\t) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90 7.4 ZilSesi(\a) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91 7.5 AynıSatırBaşı(\r) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 7.6 DüşeySekme(\v) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92 7.7 İmleçKaydırma(\b) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 7.8 KüçükUnicode(\u) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 7.9 BüyükUnicode(\U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 7.10 UzunAd(\N) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96 7.11 OnaltılıKarakter(\x) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97 7.12 Etkisizleştirme(r) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98 7.13 SayfaBaşı(\f) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 7.14 KaçışDizilerineTopluBakış . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 8 ProgramlarıKaydetmeveÇalıştırma 103 8.1 GNU/Linux . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 8.2 Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 9 ÇalışmaOrtamıTavsiyesi 108 9.1 WindowsKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 9.2 GNU/LinuxKullanıcıları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110 9.3 MetinDüzenleyiciAyarları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110 9.4 MS-DOSKomutSatırıAyarları . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112 9.5 ProgramÖrnekleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113 10 YorumveAçıklamaCümleleri 116 10.1 Yorumİşareti . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118 10.2 YorumİşaretininFarklıKullanımları. . . . . . . . . . . . . . . . . . . . . . . . . 119 11 KullanıcıdanBilgiAlmak 121 11.1 input()Fonksiyonu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 11.2 TipDönüşümleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124 11.3 eval()veexec()Fonksiyonları . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 11.4 format()Metodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142 12 KoşulluDurumlar 148 12.1 KoşulDeyimleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 12.2 ÖrnekUygulama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161 13 İşleçler 163 13.1 Aritmetikİşleçler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 13.2 Karşılaştırmaİşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 13.3 Boolİşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 13.4 DeğerAtamaİşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180 13.5 Bitwise(Bitsel)İşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185 13.6 Aitlikİşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191 13.7 Kimlikİşleçleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192 13.8 UygulamaÖrnekleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196 14 Döngüler(Loops) 208 14.1 whileDöngüsü. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209 ii 14.2 forDöngüsü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218 14.3 İlgiliAraçlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224 14.4 ÖrnekUygulamalar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233 15 HataYakalama 246 15.1 HataTürleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247 15.2 try... except... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250 15.3 try... except... as... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253 15.4 try... except... else... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254 15.5 try... except... finally... . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255 15.6 raise . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256 15.7 assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257 15.8 BütünHatalarıYakalamak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259 15.9 ÖrnekUygulama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260 16 KarakterDizileri 262 16.1 KarakterDizilerininÖğelerineErişmek . . . . . . . . . . . . . . . . . . . . . . . 263 16.2 KarakterDizileriniDilimlemek . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271 16.3 KarakterDizileriniTersÇevirmek . . . . . . . . . . . . . . . . . . . . . . . . . . 273 16.4 KarakterDizileriniAlfabeSırasınaDizmek . . . . . . . . . . . . . . . . . . . . . 275 16.5 KarakterDizileriÜzerindeDeğişiklikYapmak. . . . . . . . . . . . . . . . . . . . 278 16.6 ÜçÖnemliFonksiyon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281 16.7 Notlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288 17 KarakterDizilerininMetotları 290 17.1 replace() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291 17.2 split(),rsplit(),splitlines() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293 17.3 lower() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299 17.4 upper() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302 17.5 islower(),isupper() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304 17.6 endswith() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306 17.7 startswith() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307 18 KarakterDizilerininMetotları(Devamı) 309 18.1 capitalize() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309 18.2 title() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311 18.3 swapcase() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314 18.4 casefold(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316 18.5 strip(),lstrip(),rstrip() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316 18.6 join() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319 18.7 count() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321 18.8 index(),rindex() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325 18.9 find,rfind() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329 18.10center() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330 18.11rjust(),ljust() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331 18.12zfill() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333 18.13partition(),rpartition() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333 18.14encode() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334 18.15expandtabs() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334 19 KarakterDizilerininMetotları(Devamı) 336 19.1 str.maketrans(),translate() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336 iii 19.2 isalpha() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349 19.3 isdigit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349 19.4 isalnum() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 19.5 isdecimal() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350 19.6 isidentifier() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351 19.7 isnumeric() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351 19.8 isspace() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352 19.9 isprintable() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352 20 KarakterDizileriniBiçimlendirmek 354 20.1 %İşaretiileBiçimlendirme(EskiYöntem) . . . . . . . . . . . . . . . . . . . . . 356 20.2 format()MetoduileBiçimlendirme(YeniYöntem) . . . . . . . . . . . . . . . . . 370 21 f-string 379 21.1 Kullanım . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380 21.2 f-stringFormatlamaÖzellikleri . . . . . . . . . . . . . . . . . . . . . . . . . . . 381 22 ListelerveDemetler 384 22.1 Listeler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385 22.2 Demetler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424 23 ListelerinveDemetlerinMetotları 428 23.1 ListelerinMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428 23.2 DemetlerinMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440 24 SaymaSistemleri 442 24.1 OnluSaymaSistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442 24.2 SekizliSaymaSistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443 24.3 OnAltılıSaymaSistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445 24.4 İkiliSaymaSistemi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447 24.5 SaymaSistemleriniBirbirineDönüştürme . . . . . . . . . . . . . . . . . . . . . 448 24.6 SaymaSistemlerininBirbirlerineKarşıAvantajları. . . . . . . . . . . . . . . . . 452 25 Sayılar 453 25.1 SayılarınMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454 25.2 AritmetikFonksiyonlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457 26 TemelDosyaİşlemleri 462 26.1 DosyaOluşturmak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463 26.2 DosyayaYazmak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 464 26.3 DosyaOkumak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465 26.4 DosyalarıOtomatikKapatma . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468 26.5 Dosyayıİleri-GeriSarmak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469 26.6 DosyalardaDeğişiklikYapmak . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470 26.7 DosyayaErişmeKipleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 475 27 DosyalarınMetotveNitelikleri 477 27.1 closedNiteliği . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478 27.2 readable()Metodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478 27.3 writable()Metodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478 27.4 truncate()Metodu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478 27.5 modeNiteliği . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480 27.6 nameNiteliği . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480 iv 27.7 encodingNiteliği . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 480 28 İkili(Binary)Dosyalar 482 28.1 İkiliDosyalarlaÖrnekler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483 29 BasitbirİletişimModeli 492 29.1 8BitlikbirSistem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493 29.2 HataKontrolü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 495 29.3 KarakterlerinTemsili . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496 30 KarakterKodlama(CharacterEncoding) 500 30.1 Giriş . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501 30.2 ASCII . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503 30.3 UNICODE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 512 30.4 KonuileilgiliFonksiyonlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521 31 Baytlar(Bytes)veBaytDizileri(Bytearrays) 526 31.1 Giriş . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526 31.2 EskisiveYenisi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528 31.3 BaytTanımlamak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 31.4 bytes()Fonksiyonu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530 31.5 BaytlarınMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531 31.6 BaytDizileri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533 31.7 BaytDizilerininMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533 32 Sözlükler 536 32.1 SözlükTanımlamak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537 32.2 SözlükÖğelerineErişmek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539 32.3 SözlüklerinYapısı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542 32.4 SözlüklereÖğeEklemek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 546 32.5 SözlükÖğeleriÜzerindeDeğişiklikYapmak. . . . . . . . . . . . . . . . . . . . . 549 32.6 SözlükÜreteçleri(DictionaryComprehensions) . . . . . . . . . . . . . . . . . . 550 33 SözlüklerinMetotları 552 33.1 keys() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552 33.2 values() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 554 33.3 items() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555 33.4 get() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555 33.5 clear() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557 33.6 copy() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 558 33.7 fromkeys() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559 33.8 pop() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 560 33.9 popitem() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 33.10setdefault(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 33.11update() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 561 34 KümelerveDondurulmuşKümeler 563 34.1 Kümeler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 563 34.2 DondurulmuşKümeler(Frozenset) . . . . . . . . . . . . . . . . . . . . . . . . . 580 35 Fonksiyonlar 582 35.1 FonksiyonNedirveNeİşeYarar? . . . . . . . . . . . . . . . . . . . . . . . . . . 582 35.2 FonksiyonTanımlamakveÇağırmak . . . . . . . . . . . . . . . . . . . . . . . . 587 v 35.3 FonksiyonlarınYapısı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590 35.4 FonksiyonlarNeİşeYarar? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593 35.5 ParametrelerveArgümanlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 598 35.6 returnDeyimi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607 35.7 ÖrnekbirUygulama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610 35.8 FonksiyonlarınKapsamıveglobalDeyimi . . . . . . . . . . . . . . . . . . . . . 614 36 GömülüFonksiyonlar 619 36.1 abs() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620 36.2 round() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 620 36.3 all() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 622 36.4 any() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623 36.5 ascii() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623 36.6 repr() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625 36.7 bool() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625 36.8 bin(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626 36.9 bytes() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626 36.10bytearray() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629 36.11chr() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630 36.12list() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 630 36.13set() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 631 36.14tuple() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632 36.15frozenset() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632 36.16complex() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632 36.17float() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633 36.18int() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633 36.19str() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 634 36.20dict() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635 36.21callable() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 635 36.22ord() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636 36.23oct() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636 36.24hex() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 636 36.25eval(),exec(),globals(),locals(),compile() . . . . . . . . . . . . . . . . . . . . . 637 36.26copyright() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 36.27credits() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 36.28license() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 36.29dir() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 641 36.30divmod() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642 36.31enumerate() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642 36.32exit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644 36.33help() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 644 36.34id() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645 36.35input() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645 36.36format() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 645 36.37filter() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 646 36.38hash() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649 36.39isinstance() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 649 36.40len() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 650 36.41map() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 650 36.42max() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 651 36.43min() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 653 vi 36.44open() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 654 36.45pow() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 658 36.46print() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 659 36.47quit() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 660 36.48range() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 660 36.49reversed() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 662 36.50sorted() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 663 36.51slice() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669 36.52sum() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671 36.53type() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671 36.54zip() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671 36.55vars() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 672 37 İleriDüzeyFonksiyonlar 674 37.1 LambdaFonksiyonları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 674 37.2 Özyinelemeli(Recursive)Fonksiyonlar . . . . . . . . . . . . . . . . . . . . . . . 679 37.3 İçİçe(Nested)Fonksiyonlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 692 37.4 Üreteçler(Generators) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 703 38 Modüller 715 38.1 ModülNedir? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 715 38.2 HazırModüller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 718 38.3 ModüllerinİçeAktarılması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 718 38.4 KendiTanımladığımızModüller . . . . . . . . . . . . . . . . . . . . . . . . . . . 727 38.5 ÜçüncüŞahısModülleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 736 38.6 __all__Listesi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 738 38.7 ModüllerinÖzelNitelikleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 740 39 NesneTabanlıProgramlama(OOP) 751 39.1 Giriş . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 751 39.2 Sınıflar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 752 39.3 SınıflarNeİşeYarar? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 753 39.4 SınıfTanımlamak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 762 39.5 SınıfNitelikleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 763 39.6 SınıflarınÖrneklenmesi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 765 39.7 ÖrnekNitelikleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771 39.8 __init__Fonksiyonuveself . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771 39.9 ÖrnekMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 778 40 NesneTabanlıProgramlama(Devamı) 786 40.1 SınıfMetotları . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 786 40.2 @classmethodBezeyicisivecls . . . . . . . . . . . . . . . . . . . . . . . . . . . 792 40.3 Alternatifİnşacılar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 795 40.4 StatikMetotlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805 40.5 @staticmethodBezeyicisi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 805 41 NesneTabanlıProgramlama(Devamı) 809 41.1 Nesneler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809 41.2 NesneNedir? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 809 41.3 BasitBirOyun . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 811 41.4 HerŞeyBirNesnedir . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 822 41.5 BirinciSınıfÖğeler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 824 vii 42 NesneTabanlıProgramlama(Devamı) 826 42.1 SınıfÜyeleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 826 42.2 @propertyBezeyicisi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 837 43 NesneTabanlıProgramlama(Devamı) 849 43.1 MirasAlma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 849 43.2 TabanSınıflar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 852 43.3 AltSınıflar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 853 43.4 MirasAlmaTürleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 856 43.5 super() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 862 43.6 objectSınıfı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 866 44 NesneTabanlıProgramlama(Devamı) 868 44.1 TkinterHakkında . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869 44.2 ProsedürelBirÖrnek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 869 44.3 SınıflıBirÖrnek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 875 44.4 ÇokluMirasAlma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 877 44.5 DahilEtme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 880 45 NesneTabanlıProgramlama(Devamı) 882 45.1 İnşa,İlklendirmeveSonlandırma . . . . . . . . . . . . . . . . . . . . . . . . . . 882 46 Paketler 885 46.1 PaketNedir? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 885 46.2 PaketTürleri . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 886 46.3 PaketlerinİçeAktarılması . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 889 46.4 KendiOluşturduğumuzPaketler. . . . . . . . . . . . . . . . . . . . . . . . . . . 891 47 ÖnemliStandartKütüphaneModülleri 901 47.1 Düzenliİfadeler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 901 47.2 datetimeModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 938 47.3 mathModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 951 47.4 randomModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 958 47.5 SqliteileVeritabanıProgramlama . . . . . . . . . . . . . . . . . . . . . . . . . . 963 47.6 osModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 991 47.7 timeModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1011 47.8 cursesModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1016 47.9 threadingModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1048 47.10schedmodülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1082 47.11jsonModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1085 47.12timeitModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1089 47.13sysModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1095 47.14argparseModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1108 48 ÜçüncüTarafModüller 1133 48.1 ColoramaModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1133 48.2 djangoPaketi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1135 48.3 KivyPaketi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1171 48.4 PyperclipModülü . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1236 48.5 Tornadopaketi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1238 49 KatkıdaBulunanlar 1246 49.1 HakanDemiral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1248 viii 49.2 BarbarosAkkurt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1248 49.3 ŞebnemDuyar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1248 49.4 OnurEker . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249 49.5 EmreErözgün . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249 49.6 TayfunYaşar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249 49.7 MetinHırçın . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249 49.8 AhmetÖztekin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1249 49.9 Mesutİdiz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.10LeventCiva. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.11FıratEkinci . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.12TalhaKesler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.13ÖmerGök . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.14YunusEmreBulut . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1250 49.15ErhanPaşaoğlu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.16CemreEfeKarakaş . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.17SalimYıldırım . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.18ÇağatayGenlik . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.19ValehAsadlı . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.20HalitTuranArıcan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1251 49.21LeventGüler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1252 49.22YaşarCelep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1252 49.23UğurUyar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1252 49.24SerdarÇağlar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1252 49.25AhmetOnurYıldırım . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1252 49.26Anılİlginoğlu. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253 49.27HüseyinUlaşYeltürk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253 49.28NuriAcar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1253 49.29AzatFıratÇimen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254 49.30AykutKardaş . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254 49.31SezerBozkır . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254 49.32AlicanUzunhan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254 49.33ÖzgürÖzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1254 49.34KerimYıldız . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.35MuhammedYılmaz . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.36AhmetErdoğan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.37AbdurrahmanDursun . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.38TahirUzelli . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.39MehmetAkbay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.40MehmetÇelikyontar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1255 49.41SavaşZengin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1256 49.42TuncayGüven . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1256 49.43CaferUluç . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1256 49.44NikitaTürkmen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1256 49.45AxolotlAxolotl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1256 49.46BurakKadirEr . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1257 49.47MuhammedHattapAlkan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1259 49.48Husamsdu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1259 49.49AhmetBurakÖzyurt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1259 49.50YunusKale . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 49.51AdemKurtipek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 49.52AliSezişli . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 ix 49.53EkremDinçel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 49.54RamazanSancar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 49.55BeyazıtUysal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1260 49.56RamazanEmreOsmanoglu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1261 49.57ZekiAkyol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1261 49.58MertcanBilek . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1261 x 1 BÖLÜM Bu Kitap Hakkında Elinizdeki kitap, Python programlama dili için kapsamlı bir Türkçe kaynak oluşturma projesi olan .com1’un bir ürünüdür. Bu kitabın amacı, herhangi bir sebeple Python programlama diline ilgi duyan, bu programlama dilini öğrenmek isteyen kişilere bu dili olabildiğincehızlı,ayrıntılıvekolaybirşekildeöğretmektir. Bu kitabın hedef kitlesi, programlamayı hiç bilmeyen kişilerdir. Bu sebeple, bu kitapta ders konularınıolabildiğinceayrıntılıvebasitleştirilmişbirşekildeelealmayaçalıştık. 1.1 Bu Kitaptan Nasıl Yararlanabilirim? Elinizdeki kitap, epey uzun ve ayrıntılı makalelerden oluşuyor. Dolayısıyla bu kitabı elinize alıpbirromangibiokumayaçalışırsanız,sıkılıpöğrenmeazminizikaybedebilirsiniz.Bukitabı sıkılmadanvebıkkınlığadüşmedentakipedebilmeniziçinsizebirkaçöneridebulunalım. Programlama dillerini, sanki tarih, coğrafya veya felsefe çalışıyormuşsunuz gibi, kitaba gömülüp harıl harıl okuyarak öğrenemezsiniz. Programlama dillerini öğrenebilmek için sizin deetkinbirşekildeöğrenmesürecinekatılmanızgerekir.Yanibukitaptakimakalelerekafanızı gömmek yerine, bol bol örnek kod yazmaya çalışırsanız, öğrendiğiniz şeyler zihninizde daha kolayyeredecektir.Birincisibu. İkincisi,kimsesizdenbukitaptakiherayrıntıyıezberlemenizibeklemiyor.Maharet,birkonuya ilişkin bütün ayrıntıları akılda tutabilmekte değildir. İyi bir programcı, bir konuya dair nasıl araştırma yapacağını ve kaynaklardan nasıl faydalanacağını bilir. Bir yazılım geliştirici adayı olaraksizindeöğrenmenizgerekenşey,gördüğünüzbütünkonularıeninceayrıntısınakadar ezberlemeyekalkışmaktanziyade,okonuyailişkinilkaşamadafikirsahibiolmayaçalışmaktır. Python’da ilerledikçe, zaten belli alanlara ilgi duyacak, kendinizi o alanlarda geliştirmeye çalışacaksınız. Elbette çok uğraştığınız konulara ilişkin ayrıntılar da daha kolay aklınızda kalacaktır.Üstelikbirprojeyeilişkingerekliliklerinsiziyönlendirmesiyle,bellikonulardadaha ayrıntılıaraştırmayapmafırsatıdabulacaksınız. 1https://.com/ 1 PythonBelgeleri,Yayım4.1.3 Üçüncüsü, bir konuyu çalışırken yeterince anlayamadığınızı hissederseniz, lütfen dudağınızı büzüp bir duvar köşesine kıvrılarak kendi kendinizi yılgınlığa düşürmeyin. Eğer bir konuyu anlamadıysanız, okuyup geçin. Okuyup geçmek içinize sinmiyorsa, aşağıda belirttiğimiz şekildeyardımisteyin. Sonolarak,bukitaptançevrimdışıolarakfaydalanmakistiyorsanızburadaki2seçenekleritakip edebilirsiniz. 1.2 Nereden Yardım Alabilirim? BukitaptaPythonprogramlamadilineilişkinkonularıolabildiğincetemizveanlaşılırbirdille anlatmaya çalıştık. Ancak yine de bazı konular zihninizde tam olarak yer etmeyebilir. Üstelik kimi zaman, bir konuyu daha iyi anlayabilmek ya da bir sorunun üstesinden gelebilmek için bilen birilerinin yardımına da ihtiyaç duyabilirsiniz. İşte böyle durumlarda .com’un forumalanına3 uğrayarakbaşkaPythonprogramcılarındanyardımisteyebilirsiniz. Forum alanı hem bilgi edinmek, hem de bildiklerinizi paylaşmak için oldukça elverişli bir ortamdır. Foruma ilk girişiniz muhtemelen yardım istemek için olacaktır. Ama ilerleyen zamanlardaPythonbilginizarttıkçabirdebakacaksınızkiyardımararkenyardımederduruma gelmişsiniz. İşte forum; kendinizdeki değişimi görmek, bilgi düzeyinizdeki artışı takip etmek vehattayenişeyleröğrenmekiçinbulunmazbirfırsattır. 1.3 Projeye Nasıl Yardımcı Olabilirim? Bu kitabın amacı, kitabı okuyanlara Python programlama dilini doğru ve ayrıntılı bir şekilde öğretmek olduğu kadar, bu programlama dilini öğretirken düzgün ve anlaşılır bir Türkçe de kullanmaktır. Bu bakımdan, kitapta bulabileceğiniz kod hatalarıyla birlikte, kitaptaki anlatım, yazımvenoktalamahatalarınıdaGitHub’dakiverihavuzunda4 düzelterekyadaGitHub’dabir konuaçarak5 buprojeyeönemlibirkatkıdabulunmuşolursunuz. ª Ayrıcabakınız Projeye bu şekilde katkıda bulunanların listesini Katkıda Bulunanlar başlıklı sayfada görebilirsiniz. Bunun dışında, projeye destek olmanın bir başka yolu, forum alanında sorulan soruları cevaplamaya çalışmaktır. Bu şekilde hem projeye destek olmuş, hem başkalarına yardım etmiş,hemdekendibilginiziartırmışolursunuz. Python’da kendinizi belli bir seviyeye getirdikten sonra, eğer kaleminize de güveniyorsanız eksikkonularhakkındayazıpkitabakatkıdabilebulunabilirsiniz. 2https://github.com//python-#belgelerden-%C3%A7evrimd%C4%B1%C5%9F%C4% B1-iken-faydalanmak 3https://forum..com/ 4https://github.com//python- 5https://github.com//python-/issues/new 2 Bölüm1. BuKitapHakkında PythonBelgeleri,Yayım4.1.3 1.4 Kullanım Koşulları BukitaptakibilgilerCreativeCommonslisansı6 altındadır.Bulisansagöre,bukitaptakibütün bilgilerdenherkesücretsizolarakyararlanabilir.Eğeristersenizburadagördüğünüzbelgelerin çıktısını alabilir, tanıdığınız veya tanımadığınız herkesle gönül rahatlığıyla paylaşabilirsiniz. Ancak bu belgeleri başka bir yerde kullanacaksanız, yine bu lisans altında kullanmalı ve bu belgeleri kesinlikle satmamalısınız. Arzu ederseniz belgeleri çoğaltıp ücretsiz olarak dağıtabilirsiniz. 6https://creativecommons.org/licenses/by-nc-sa/3.0/ 1.4. KullanımKoşulları 3 2 BÖLÜM Python Hakkında Eğeryaşamınızınbirdönemindeherhangibirprogramlamadiliileazveyaçokilgilendiyseniz, Pythonadınıduymuşolabilirsiniz.Öncedenbirprogramlamadilideneyiminizhiçolmamışsa dahi,Pythonadınınbiryerlerdenkulağınızaçalınmışolmaihtimalibirhayliyüksek.Busatırları okuyor olduğunuza göre, Python adını en az bir kez duymuş olduğunuzu ve bu şeye karşı içinizdehiçdeğilsebirmerakuyandığınıvarsayabiliriz. Peki, en kötü ihtimalle kulak dolgunluğunuz olduğunu varsaydığımız bu şey hakkında acaba nelerbiliyorsunuz? İşte biz bu ilk bölümde, fazla teknik ayrıntıya kaçmadan, Python hakkında kısa kısa bilgiler vererekPython’ınneolduğunuvebununlaneleryapabileceğinizianlatmayaçalışacağız. 2.1 Python Nedir? Tahmin edebileceğiniz gibi Python (C, C++, Perl, Ruby ve benzerleri gibi) bir programlama dilidir ve tıpkı öteki programlama dilleri gibi, önünüzde duran kara kutuya, yani bilgisayara hükmetmenizisağlar. BuprogramlamadiliGuidoVanRossumadlıHollandalıbirprogramcıtarafından90’lıyılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halinialmıştır. Dediğimiz gibi, Python bir programlama dilidir. Üstelik pek çok dile kıyasla öğrenmesi kolay birprogramlamadilidir.Buyüzden,eğerdahaöncehiçprogramlamadeneyiminizolmamışsa, programlamamaceranızaPython’labaşlamayıtercihedebilirsiniz. 4 PythonBelgeleri,Yayım4.1.3 2.2 Neden Programlama Öğrenmek İsteyeyim? Günlük yaşamınıza şöyle bir bakın. Gerek iş yerinizde olsun, gerek evde bilgisayar başında olsun,belliişleritekdüzebirşekildetekrarettiğinizigöreceksiniz.Meselasürekliolarakyazılı belgelerle uğraşmanızı gerektiren bir işte çalışıyor olabilirsiniz. Belki de her gün onlarca belgeyi açıp bu belgelerde birtakım bilgiler arıyor, bu bilgileri düzeltiyor, yeniliyor veya siliyorsunuzdur. Bu işlemlerin ne kadar vakit alıcı ve sıkıcı olduğunu düşünün. Eğer bir programlama dili biliyor olsaydınız, bütün bu işlemleri sizin yerinize bu programlama dili hallediyorolabilirdi. İşte Python programlama dili böyle bir durumda devreye girer. Her gün saatler boyunca uğraştığınız işlerinizi, yalnızca birkaç satır Python kodu yardımıyla birkaç saniye içinde tamamlayabilirsiniz. Ya da şöyle bir durum düşünün: Çalıştığınız iş yerinde PDF belgeleriyle bolca haşır neşir oluyor olabilirsiniz. Belki de yüzlerce sayfalık kaşeli ve imzalı belgeyi PDF haline getirmeniz gerekiyordur. Üstelik sizden bu belgeleri mümkün olduğunca tek parça halinde PDF’lemeniz isteniyor olabilir. Ama o yüzlerce sayfayı tarayıcıdan geçirirken işin tam ortasında bir aksilik oluyor,makinearızalanıyorvebelkideisteristemezbelgenizbölünüyordur. İştePythonprogramlamadiliböylebirdurumdadadevreyegirer.EğerPythonprogramlama dilini öğrenirseniz, İnternet’te saatlerce ücretsiz PDF birleştirme programı aramak veya profesyonel yazılımlara onlarca dolar para vermek yerine, belgelerinizi birleştirip işinizi görecekprogramıkendinizyazabilirsiniz. Elbette Python’la yapabilecekleriniz yukarıda verdiğimiz basit örneklerle sınırlı değildir. Python’ı kullanarak masaüstü programlama, oyun programlama, taşınabilir cihaz programlama, web programlama ve ağ programlama gibi pek çok alanda çalışmalar yürütebilirsiniz. 2.3 Neden Python? Python programlarının en büyük özelliklerinden birisi, C ve C++ gibi dillerin aksine, derlenmeye gerek olmadan çalıştırılabilmeleridir. Python’da derleme işlemi ortadan kaldırıldığıiçin,budilleoldukçahızlıbirşekildeprogramgeliştirilebilir. AyrıcaPythonprogramlamadilininbasitvetemizsözdizimi,onupekçokprogramcıtarafından tercihedilenbirdilhalinegetirmiştir.Python’ınsözdiziminintemizvebasitolmasısayesinde hemprogramyazmak,hemdebaşkasıtarafındanyazılmışbirprogramıokumak,başkadillere kıyaslaçokkolaydır. Python’ın yukarıda sayılan özellikleri sayesinde dünya çapında ün sahibi büyük kuruluşlar (Google, YouTube ve Yahoo! gibi) bünyelerinde her zaman Python programcılarına ihtiyaç duyuyor. Mesela pek çok büyük şirketin Python bilen programcılara iş imkanı sağladığını, Python’ın baş geliştiricisi Guido Van Rossum’un 2005 ile 2012 yılları arasında Google’da çalıştığını, 2012 yılının sonlarına doğru ise Dropbox şirketine geçtiğini söylersek, bu programlamadilininönemivegeçerliliğiherhaldedahabelirginbirşekildeortayaçıkacaktır. Python programlama dili ve bu dili hakkıyla bilenler sadece uluslararası şirketlerin ilgisini çekmekle kalmıyor. Python son zamanlarda Türkiye’deki kurum ve kuruluşların da dikkatini çekmeyebaşladı.BudilartıkyavaşyavaşTürkiye’dekiüniversitelerinmüfredatındadakendine yerbuluyor. 2.2. NedenProgramlamaÖğrenmekİsteyeyim? 5 PythonBelgeleri,Yayım4.1.3 Sözün özü, pek çok farklı sebepten, başka bir programlama dilini değil de, Python programlamadiliniöğrenmekistiyorolabilirsiniz. 2.4 Python Nasıl Telaffuz Edilir? Pythonprogramlamadiliüzerinebukadarsözsöyledik.Pekiyabancıbirkelimeolanpython’ı nasıltelaffuzedeceğimizibiliyormuyuz? Geliştiricisi Hollandalı olsa da python İngilizce bir kelimedir. Dolayısıyla bu kelimenin telaffuzunda İngilizceninkurallarıgeçerli. Ancak bukelimeyi hakkıyla telaffuz etmek,ana dili Türkçeolanlariçinpekkolaydeğil.Çünkübukelimeiçinde,Türkçedeyeralmayanvetelaffuzu peltek s’yi andıran [th] sesi var. İngilizce bilenler bu sesi think (düşünmek) kelimesinden hatırlayacaklardır. Ana dili Türkçe olanlar think kelimesini genellikle [tink] şeklinde telaffuz eder.Dolayısıylapythonkelimesinide[paytın]şeklindetelaffuzedebilirsiniz. Python kelimesini tamamen Türkçeleştirerek [piton] şeklinde telaffuz etmeyi yeğleyenler de var.Elbettesizdedilinizindöndüğübirtelaffuzutercihetmekteözgürsünüz. Bu arada, eğer python kelimesinin İngilizce telaffuzunu dinlemek istiyorsanız howjsay.com7 adresini ziyaret edebilir, Guido Van Rossum’un bu kelimeyi nasıl telaffuz ettiğini merak ediyorsanız da https://www.youtube.com/watch?v=UIDdgeISLUI adresindeki tanıtım videosunuizleyebilirsiniz. 2.5 Platform Desteği Python programlama dili pek çok farklı işletim sistemi ve platform üzerinde çalışabilir. GNU/Linux, Windows, Mac OS X, AS/400, BeOS, MorphOS, MS-DOS, OS/2, OS/390, z/OS, RiscOS, S60, Solaris, VMS, Windows CE, HP-UX, iOS ve Android gibi, belki adını dahi duymadığınız pek çok ortamda Python uygulamaları geliştirebilirsiniz. Ayrıca herhangi bir ortamda yazdığınız bir Python programı, üzerinde hiçbir değişiklik yapılmadan veya ufak değişikliklerlebaşkaortamlardadaçalıştırılabilir. BizbubelgelerdePythonprogramlamadiliniGNU/LinuxveMicrosoftWindowsişletimsistemi üzerinden anlatacağız. Ancak sıkı sıkıya bel bağlayacağımız özel bir GNU/Linux dağıtımı veya Windowssürümüyok.Buyüzden,hangiGNU/LinuxdağıtımınıveyahangiWindowssürümünü kullanıyorolursanızolun,buradakibilgileryardımıylaPythonprogramlamadiliniöğrenebilir, öğrendiklerinizikendiişletimsisteminizeuyarlayabilirsiniz. (cid:242) Not Bu satırların yazarının, Ubuntu, CentOS, Windows 7 ve Windows 10 kurulu bilgisayarlara erişimi olduğu için, bu kitaptaki ekran görüntüleri genellikle bu işletim sistemlerinden alınmışolacaktır. 7https://howjsay.com/ 6 Bölüm2. PythonHakkında PythonBelgeleri,Yayım4.1.3 2.6 Farklı Python Sürümleri Eğer daha önce Python programlama dili ile ilgili araştırma yaptıysanız, şu anda piyasada iki farklı Python serisinin olduğu dikkatinizi çekmiş olmalı. 19.08.2024 tarihi itibariyle piyasada olanenyeniPythonsürümleriPython2.7.18vePython3.12.1’dir. Eğer bir Python sürümü 2 sayısı ile başlıyorsa (mesela 2.7.15), o sürüm Python 2.x serisine aittir. Yok eğer bir Python sürümü 3 sayısı ile başlıyorsa (mesela 3.7.0), o sürüm Python 3.x serisineaittir. PekinedenpiyasadaikifarklıPythonsürümüvarvebubizimiçinneanlamageliyor? Python programlama dili 1990 yılından bu yana geliştirilen bir dil. Bu süre içinde pek çok Python programı yazıldı ve insanların kullanımına sunuldu. Şu anda piyasada Python’ın 2.x serisinden bir sürümle yazılmış pek çok program bulunuyor. 3.x serisi ise ancak son yıllarda yaygınlıkkazanmayabaşladı. (cid:242) Not Biz bu kitapta kolaylık olsun diye Python’ın 3.x serisini Python3; 2.x serisini ise Python2 olarakadlandıracağız. Python3, Python2’ye göre hem çok daha güçlüdür, hem de Python2’nin hatalarından arındırılmıştır. Python3’teki büyük değişikliklerden ötürü, Python2 ile yazılmış bir program Python3 altında çalışmayacaktır. Aynı durum bunun tersi için de geçerlidir. Yani Python3 kullanarakyazdığınızbirprogramPython2altındaçalışmaz. Dediğimizgibi,piyasadaPython2ileyazılmışçoksayıdaprogramvar.İştebusebeplePython geliştiricileri uzun bir süre daha Python2’yi geliştirmeye devam edecek. Elbette geliştiriciler biryandandaPython3üzerindeçalışmayıvebuyeniseriyigeliştirmeyisürdürecek. Farklı Python serilerinin var olmasından ötürü, Python ile program yazarken hangi seriye ait sürümlerden birini kullandığınızı bilmeniz, yazacağınız programın kaderi açısından büyük önemtaşır. (cid:242) Not BizbukitaptaPython3.7kullanacağız.Aksibelirtilmediğisürecebütünkodlarınbusürüm ile çalıştırıldığını varsayabilirsiniz. Ayrıca Python3.7 için yazacağımız kodlar daha yüksek versiyonlardadaçalışacaktır. 2.7 Hangi Seriyi Öğrenmeliyim? Dediğimiz gibi, şu anda piyasada iki farklı Python serisi var: Python3 ve Python2. Peki acaba hangiseriyeaitbirsürümüöğrenmelisiniz? [Kısacevap] Python3’üöğrenmelisiniz. [Uzuncevap] 2.6. FarklıPythonSürümleri 7 PythonBelgeleri,Yayım4.1.3 Eğer Python programlama diline yeni başlıyorsanız Python3’ü öğrenmeniz daha doğru olacaktır. Ama eğer Python programlama dilini belirli bir proje üzerinde çalışmak üzere öğreniyorsanız, hangi sürümü öğrenmeniz gerektiği, projede kullanacağınız yardımcı modüllerin durumuna bağlıdır. Zira şu anda piyasada bulunan bütün Python modülleri/programlarıhenüzPython3’eaktarılmışdeğil. Eğer projenizde kullanmayı planladığınız yardımcı modüller halihazırda Python3’e aktarılmışsa Python3’ü öğrenebilirsiniz. Ancak eğer bu modüllerin henüz Python3 sürümü çıkmamışsa sizin de Python2 ile devam etmeniz daha uygun olabilir. Ama her halükarda Python3’ün bu dilin geleceği olduğunu ve günün birinde Python2’nin tamamen tedavülden kalkacağınıdaaklınızınbirköşesindebulundurun. . Uyarı 1 Ocak 2020 itibarıyla Python2’ye verilen destek bitmiştir. Python Yazılım Vakfı8 artık Python2.x sürümlerini geliştirmemektedir. Yukarıda yazarın yazdığı satırların günümüzde bir geçerliliği kalmamış, önemli Python kütüphanelerinin neredeyse hepsi Python3’e geçmiş ve Python2 desteklerini 2021’de bırakacaklarını duyurmuştur. Python’u yeni öğrenenbiriolarakPython2yerinePython3’üseçmenizçokdahadoğruolur.Ayrıntılıbilgi içinbulinklerebakabilirsiniz: • https://www.python.org/doc/sunset-python-2/ • https://pythonclock.org/ • https://python3statement.github.io 8https://www.python.org/psf-landing/ 8 Bölüm2. PythonHakkında 3 BÖLÜM Python Nasıl Kurulur? Pythonileprogramyazabilmemiziçinbuprogramlamadilininbilgisayarımızdakuruluolması gerekiyor. Bu programlama dilini kurmanızın gerekip gerekmediği, kullandığınız işletim sistemine bağlıdır. Biz burada hem GNU/Linux hem de Windows kullanıcılarının durumunu sırasıyla ve ayrı ayrı inceleyeceğiz. Dilerseniz öncelikle GNU/Linux kullanıcılarının durumuna bakalım: (cid:242) Not Bu kitap boyunca bazı konuların GNU/Linux ve Windows kullanıcıları için ayrı ayrı anlatıldığını göreceksiniz. Ancak konular bu şekilde ayrılmış da olsa, ben size her ikisini de okumanızı tavsiye ederim. Çünkü bu bölümlerde her iki kullanıcı grubunun da ilgisini çekebilecek bilgilere rastlayacaksınız. Ayrıca bu bölümler farklı kullanıcı gruplarına hitap ediyorolsada,aslındabubölümlerinbirbirinitamamlayıcınitelikteolduğunugöreceksiniz. 3.1 GNU/Linux Kullanıcıları GNU/Linux dağıtımlarına Python programlama dilini kurarken bazı noktaları göz önünde bulundurmamız gerekiyor. İşte bu bölümde bu önemli noktaların neler olduğunu inceleyeceğiz. 9 PythonBelgeleri,Yayım4.1.3 3.1.1 Kurulu Python Sürümü HemenhemenbütünGNU/LinuxdağıtımlarındaPythonprogramlamadilikuruluolarakgelir. ÖrneğinUbuntu’daPythonzatenkuruludur. Ancakburadaşöylebirdurumvar: Dahaöncedebelirttiğimizgibi,şuandapiyasadaikifarklıPythonserisibulunuyor.Bunlardan birininPython’ın2.xserisi,ötekininise3.xserisiolduğunubiliyorsunuz. Sisteminizde kurulu olan Python sürümünü denetlemek için komut satırında öncelikle şu komutuvermeyideneyin(büyük‘V’ile): python -V EğerbukomuttanPython2.x.yşeklindebirçıktıalıyorsanız,yanixvey’denöncekikısım2ile başlıyorsasisteminizdePython2kuruludur. Ancak python -V komutundan Python 2.x.y şeklinde bir çıktı almanız sisteminizde sadece Python2’nin kurulu olduğunu göstermez. Sisteminizde Python2 ile birlikte Python3 de halihazırda kurulu olabilir. Örneğin Ubuntu GNU/Linux’un 12.10 sürümünden itibaren hem Python2,hemdePython3sistemdekuruluvaziyettedir. Kullandığınız GNU/Linux dağıtımında durumun ne olduğunu denetlemek için yukarıdaki komutubirdepython3 -Vşeklindeçalıştırmayıdeneyebilirsiniz.Eğerbukomutsizebirhata mesajıyerinebirsürümnumarasıveriyorsasisteminizdePython3dekuruludur. Sisteminizdeki Python sürümlerine ilişkin daha kesin bir rapor içinse şu komutu kullanabilirsiniz: ls -g {,/usr{,/local}}/bin | grep python Buradan aldığınız çıktıyı inceleyerek de sisteminizde birden fazla Python sürümünün kurulu olupolmadığınıgörebilirsiniz. Ayrıca kullandığınız GNU/Linux dağıtımında whereis python gibi bir komut vererek de sistemdekuruluPythonsürümlerihakkındabilgiedinebilirsiniz. Eğer sisteminizde Python3 kuruluysa ve siz de kurulu olan Python3 sürümünden memnunsanız herhangi bir şey yapmanıza gerek yok. Farklı bir Python sürümü kurmaya çalışmadanyolunuzadevamedebilirsiniz. 3.1.2 Paket Deposundan Kurulum Sistemlerinde öntanımlı olarak herhangi bir Python3 sürümü kurulu olmayan veya sistemlerinde kurulu öntanımlı Python3 sürümünden memnun olmayan GNU/Linux kullanıcılarının, Python3’ü elde etmek için tercih edebileceği iki yol var: Birincisi ve benim size önereceğim yol, öncelikle kullandığınız dağıtımın paket yöneticisini kontrol etmenizdir. Python3 sisteminizde kurulu olmasa bile, dağıtımınızın depolarında bu sürüm paketlenmiş halde duruyor olabilir. O yüzden sisteminize uygun bir şekilde paket yöneticinizi açıp orada ‘python’ kelimesini kullanarak bir arama yapmanızı öneririm. Örneğin Ubuntu GNU/Linux dağıtımının paket depolarında Python3 var. Dolayısıyla Ubuntu kullanıcıları, eğer sistemlerinde zaten kurulu değilse (ki muhtemelen kuruludur), bu paketi Ubuntu Yazılım Merkeziaracılığıylaveyadoğrudanşukomutlakurabilir: 10 Bölüm3. PythonNasılKurulur? PythonBelgeleri,Yayım4.1.3 sudo apt-get install python3 RHEL/CentOSkullanıcılarıiseşukomutukullanabilir: sudo yum install python3 Bukomutlar,Python3’übütünbağımlılıklarıileberaberbilgisayarınızakuracaktır. 3.1.3 Kaynaktan Kurulum Peki ya kullandığınız dağıtımın depolarında Python3 yoksa veya depodaki Python3 sürümü eskiysevesizdahayenibirPython3sürümükullanmakistiyorsanızneyapacaksınız? Eğer dağıtımınızın depolarında Python3 paketini bulamazsanız veya depodaki sürüm sizi tatmin etmiyorsa, Python3’ü kaynaktan derlemeniz gerekecektir. Python3’ü kaynaktan derlerken iki seçeneğiniz var: Python3’ü root hakları ile kurmak veya Python3’ü yetkisiz kullanıcı olarak kurmak. Normal şartlar altında eğer kullandığınız sistemde root haklarına sahipsenizPython3’üyetkilikullanıcıolarakkurmanızıtavsiyeederim. rootHaklarıİleKurulum Python’ı kurmadan önce sistemimizde bulunması gereken bazı programlar var. Aslında bu programlarolmadandaPythonkurulabilir,ancakeğerbuprogramlarıkurmazsanızPython’ın bazıözelliklerindenyararlanamazsınız.Buprogramlarşunlardır: 1. tcl-dev 2. tk-dev 3. zlib1g-dev 4. ncurses-dev 5. libreadline-dev 6. libdb-dev 7. libgdbm-dev 8. libzip-dev 9. libssl-dev 10. libsqlite3-dev 11. libbz2-dev 12. liblzma-dev Buprogramları,kullandığınızGNU/Linuxdağıtımınınpaketyöneticisiaracılığıylakurabilirsiniz. Yalnızpaketadlarınınvegereklipaketsayısınındağıtımlararasındafarklılıkgösterebileceğini unutmayın. Yukarıdaki liste Ubuntu için geçerlidir. Mesela yukarıda tcl-dev olarak verdiğimiz paket adı başka bir dağıtımda sadece tcl olarak geçiyor ya da yukarıdaki paketlerin bazıları kullandığınız dağıtımda halihazırda kurulu olduğu için sizin daha az bağımlılık kurmanız gerekiyorolabilir. Ubuntu’dayukarıdakipaketlerinhepsinişukomutlakurabilirsiniz: 3.1. GNU/LinuxKullanıcıları 11 PythonBelgeleri,Yayım4.1.3 sudo apt-get install tcl-dev tk-dev zlib1g-dev ncurses-dev libreadline-dev␣ libdb-dev libgdbm-dev libzip-dev libssl-dev libsqlite3-dev libbz2-dev liblzma- ˓→ dev ˓→ Yukarıdaki programları kurduktan sonra https://www.python.org/ftp/python/3.7.0 adresine gidiyoruz. Bu adreste, üzerinde ‘Python-3.7.0.tar.xz’ yazan bağlantıya tıklayarak sıkıştırılmış kurulumdosyasınıbilgisayarımızaindiriyoruz. Daha sonra bu sıkıştırılmış dosyayı açıyoruz. Açılan klasörün içine girip, orada ilk olarak şu komutuveriyoruz: ./configure Bu komut, Python programlama dilinin sisteminize kurulabilmesi için gereken hazırlık aşamalarınıgerçekleştirir.Bubetiğintemelolarakyaptığıiş,sisteminizinPythonprogramlama dilinin kurulmasına uygun olup olmadığını, derleme işlemi için gereken yazılımların sisteminizde kurulu olup olmadığını denetlemektir. Bu betik ayrıca, bir sonraki adımda gerçekleştireceğimiz inşa işleminin nasıl yürüyeceğini tarif eden Makefile adlı bir dosya da oluşturur. Bu arada bu komutun başındaki ./ işareti, o anda içinde bulunduğunuz dizinde yer alan configure adlı bir betiği çalıştırmanızı sağlıyor. Eğer yalnızca configure komutu verirseniz, işletimsistemibubetiğiPATHdizinleriiçindearayacakvebulamayacağıiçindehataverecektir. ./configurekomutuhatasızolaraktamamlandıktansonraikinciolarakşukomutuveriyoruz: make Burada aslında ./configure komutu ile oluşan Makefile adlı dosyayı make adlı bir program aracılığıyla çalıştırmış oluyoruz. make bir sistem komutudur. Bu komutu yukarıdaki gibi parametresiz olarak çalıştırdığımızda make komutu, o anda içinde bulunduğumuz dizinde bir Makefile dosyası arar ve eğer böyle bir dosya varsa onu çalıştırır. Eğer bir önceki adımda çalıştırdığımız ./configure komutu başarısız olduysa, dizinde bir Makefile dosyası oluşmayacağı için yukarıdaki make komutu da çalışmayacaktır. O yüzden derleme işlemi sırasında verdiğimiz komutların çıktılarını takip edip, bir sonraki aşamaya geçmeden önce komutundüzgünsonlanıpsonlanmadığındaneminolmamızgerekiyor. make komutunun yaptığı iş, Python programlama dilinin sisteminize kurulması esnasında sistemin çeşitli yerlerine kopyalanacak olan dosyaları inşa edip oluşturmaktır. Bu komutun tamamlanması,kullandığınızbilgisayarınkapasitesinebağlıolarakbirazuzunsürebilir. make komutu tamamlandıktan sonra, komut çıktısının son satırlarına doğru şöyle bir uyarı mesajıgörebilirsiniz: Python build finished, but the necessary bits to build these modules were not␣ found: ˓→ [burada eksik olan modül veya modüllerin adları sıralanır] Burada Python, sistemimizde bazı paketlerin eksik olduğu konusunda bizi uyarıyor. Uyarı mesajındabirveyadahafazlapaketineksikolduğunugörebilirsiniz.Eğeröyleyse,eksikolduğu bildirilenbütünpaketlerikurmamızgerekiyor. Gerekli paketi ya da paketleri kurduktan sonra make komutunu tekrar çalıştırıyoruz. Endişe etmeyin,makekomutunuikincikezverdiğimizdekomutuntamamlanmasıbirincisikadaruzun 12 Bölüm3. PythonNasılKurulur? PythonBelgeleri,Yayım4.1.3 sürmez. Eğer bu komutu ikinci kez çalıştırdığınızda yukarıdaki uyarı mesajı kaybolduysa şu komutlayolunuzadevamedebilirsiniz: sudo make altinstall DahaöncekaynaktanprogramderlemişolanGNU/Linuxkullanıcılarınıneli,makekomutundan sonra make install komutunu vermeye gitmiş olabilir. Ama burada bizim make install yerine make altinstall komutunu kullandığımıza dikkat edin. make altinstall komutu, Python kurulurken klasör ve dosyalara sürüm numarasının da eklenmesini sağlar. Böylece yeni kurduğunuz Python, sistemdeki eski Python3 sürümünü silip üzerine yazmamış olur ve iki farklı sürüm yan yana varolabilir. Eğer make altinstall yerine make install komutunu verirseniz sisteminizde zaten varolan eski bir Python3 sürümüne ait dosya ve dizinlerin üzerine yazıp silerek o sürümü kullanılamaz hale getirebilirsiniz. Bu da sistemde beklenmedikproblemlerinortayaçıkmasınayolaçabilir.Buönemliayrıntıyıkesinliklegözden kaçırmamalısınız. Derleme aşamalarının hiçbirinde herhangi bir hata mesajı almadıysanız kurulum başarıyla gerçekleşmişvesisteminizePythonprogramlamadilinin3.xsürümükurulmuşdemektir. YetkisizKullanıcıOlarakKurulum Elbettesudo make altinstallkomutunuveripPython’ıkurabilmekiçinroothaklarınasahip olmanız gerekiyor. Ama eğer kullandığınız sistemde bu haklara sahip değilseniz Python’ı bu şekilde kuramazsınız. Kısıtlı haklara sahip olduğunuz bir sistemde Python’ı ancak kendi ev dizininize($HOME)kurabilirsiniz. Eğer Python’ı yetkisiz kullanıcı olarak kuracaksanız, öncelikle yukarıda bahsettiğimiz Python bağımlılıklarının sisteminizde kurulu olup olmadığını kontrol etmeniz lazım. KullandığınızsistemdeherhangibirPythonsürümühalihazırdakuruluysa,bubağımlılıklarda muhtemelenzatenkuruludur.Amadeğilse,bunlarıkurmasıiçinyasistemyöneticisinericada bulunacaksınız,yadabubağımlılıklarıdatektekkendievdizininizekuracaksınız.Eğersistem yöneticisini bu bağımlılıkları kurmaya ikna edemezseniz, internet üzerinden bulabileceğiniz bilgileryardımıylabubağımlılıklarıtektekellekendinizkurabilirsiniz.Ancakbuişleminepey zamanalacağınıvesüreçsırasındapekçokbaşkabağımlılıkladakarşılacağınızısöyleyebilirim. O yüzden ne yapıp edip sistem yöneticisini bağımlılıkları kurmaya ikna etmenizi tavsiye ederim... Tabii sistem yöneticisini bu bağımlılıkları kurmaya ikna edebilirseniz, istediğiniz Python sürümünü de kurmaya ikna edebileceğinizi düşünebiliriz! Ama biz burada sizin Python’ıkendinizinkuracağınıvarsayarakyolumuzadevamedelim. Python’ıyetkisizolarakkurmak,roothaklarıylakurmayaçokbenzer.Aralarındayalnızcabir-iki ufakfarkvardır.MeselaPython’ıyetkisizkullanıcıolarakkurarken,./configurekomutunuşu şekildevermenizgerekiyor: ./configure --prefix=$HOME/python Python’ıroothaklarıylakurduğunuzdaPython/usrdizinialtınakurulacaktır.Ancaksizyetkisiz kullanıcıolduğunuziçin/usrdizinineherhangibirşeykuramazsınız.İştebuyüzden,configure betiğine verdiğimiz –prefix parametresi yardımıyla Python’ı, yazma yetkimiz olan bir dizine kuruyoruz. Mesela yukarıdaki komut Python’ın /usr dizinine değil, ev dizininiz içinde python adlı bir klasöre kurulmasını sağlayacaktır. Elbette siz python yerine farklı bir dizin adı da belirleyebilirsiniz. Burada önemli olan nokta, –prefix parametresine vereceğiniz dizin adının, sizinyazmayayetkiliolduğunuzbirdizinolmasıdır. 3.1. GNU/LinuxKullanıcıları 13 PythonBelgeleri,Yayım4.1.3 Bukomutuçalıştırdıktansonramakekomutununormalbirşekildeveriyoruz.Bununardından da make install (veya duruma göre make altinstall) komutuyla Python’ı ev dizinimize kuruyoruz. Burada make install komutunu sudo’suz kullandığımıza dikkat edin. Çünkü, dediğimizgibi,sizyetkilikullanıcıolmadığınıziçinsudokomutunukullanamazsınız. Python’ı bu şekilde ev dizininiz altında bir klasöre kurduğunuzda Python ile ilgili bütün dosyaların bu klasör içinde yer aldığını göreceksiniz. Bu klasörü dikkatlice inceleyip neyin nerede olduğuna aşinalık kazanmaya çalışın. Eğer mümkünse root hakları ile kurulmuş bir Pythonsürümünüinceleyerek,dosyalarınikifarklıkurulumtüründenerelerekopyalandığını karşılaştırın. Böylece Python programlama dilini bilgisayarımıza nasıl kuracağımızı öğrenmiş olduk. Ama bunoktadabiruyarıyapmadangeçmeyelim:PythonözelliklebazıGNU/Linuxdağıtımlarında pekçoksistemaracıylasıkısıkıyabağlantılıdır.YaniPython,kullandığınızdağıtımınbelkemiği durumunda olabilir. Bu yüzden Python’ı kaynaktan derlemek bazı riskler taşıyabilir. Eğer yukarıda anlatıldığı şekilde, kaynaktan Python derleyecekseniz, karşı karşıya olduğunuz risklerin farkında olmalısınız. Ayrıca GNU/Linux üzerinde kaynaktan program derlemek konusunda tecrübeli değilseniz ve eğer yukarıdaki açıklamalar size kafa karıştırıcı geliyorsa, mesela ‘Ben bu komutları nereye yazacağım?’ diye bir soru geçiyorsa aklınızdan, kesinlikle dağıtımınızla birlikte gelen Python sürümünü kullanmalısınız. Python sürümlerini başa baş takip ettiği için, ben size Ubuntu GNU/Linux’u denemenizi önerebilirim. Ubuntu’nun depolarında Python’ın en yeni sürümlerini rahatlıkla bulabilirsiniz. Ubuntu’nun resmi sitesineubuntu.com9adresinden,yerelTürkiyesitesineiseforum.ubuntu-tr.net10adresinden ulaşabilirsiniz.EğerşuandakullandığınızGNU/Linuxdağıtımındanvazgeçmekistemiyorsanız, sabitdiskinizdenküçükbirbölümayırıpbubölümesadecePythonçalışmalarınıziçinUbuntu dağıtımınıdakurmayıtercihedebilirsiniz. Yalnız küçük bir uyarı daha yapalım. Kaynaktan kurulum ile ilgili bu söylediklerimizden, Python’ın GNU/Linux’a kesinlikle kaynaktan derlenerek kurulmaması gerektiği anlamı çıkmamalı.Yukarıdakiuyarılarınamacı,kullanıcınınPython’ıkaynaktanderlerkensadecebiraz dahadikkatliolmasıgerektiğinihatırlatmaktır.Örneğinbusatırlarınyazarı,kullandığıUbuntu sistemindePython3’ükaynaktanderleyerekkullanmayıtercihediyorveherhangibirproblem yaşamıyor. Buönemliuyarılarıdayaptığımızagöregönülrahatlığıylayolumuzadevamedebiliriz. Kurduğumuz yeni Python’ı nasıl çalıştıracağımızı biraz sonra göreceğiz. Ama önce Windows kullanıcılarınınPython3’ünasılkuracaklarınabakalım. 3.1.4 Sürüm Yöneticisi ile Kurulum (pyenv) Sisteminize bir veya birden fazla Python sürümü kurmak istiyorsunuz fakat root hakları, kaynaktan sürüm derlemeleri vb. işlemler gözünüzü mü korkutuyor? Bütün bu işlemleri çok daha hızlı, pratik ve güvenli bir şekilde pyenv ile gerçekleştirebilirsiniz. pyenv sisteminizde birden fazla Python sürümünü kullanabilmenizi sağlayan ve birçok kolaylığı da beraberinde getiren bir araçtır. Bunun için öncelikle pyenv-installer ile sistemimize pyenv kurmamız gerekmektedir.Kurulumiçinaşağıdakikomutuçalıştırmanızyeterlidir: curl https://pyenv.run | bash Kurulumtamamlandıktansonraaşağıdakişekildebirmesajçıkacaktır: 9https://ubuntu.com/ 10https://forum.ubuntu-tr.net/ 14 Bölüm3. PythonNasılKurulur? PythonBelgeleri,Yayım4.1.3 # Load pyenv automatically by adding # the following to ~/.bashrc: export PATH="$HOME/.pyenv/bin:$PATH" eval "$(pyenv init -)" eval "$(pyenv virtualenv-init -)" Buradakison3satırıanadizininizdeki.bashrcdosyanızın(veyafarklıbirshellkullanıyorsanız ilgili dosyanın) sonuna eklemeniz gerekmektedir. Eklemeyi yapıp kaydettikten sonra pyenv’i kullanmaya başlamak için terminali yeniden başlatmanız veya terminale source ~/.bashrc yazmanızyeterlidir. pyenvileyükleyebileceğinizPythonsürümlerinilisteleyebilmekiçintekyapmanızgerekenşu komutuçalıştırmaktır: pyenv install --list Yalnızca3.8.xsürümlerinilistelemekiçinse: pyenv install --list |grep " 3.8.*" Komutunu çalıştırabilirsiniz. Eğer bütün sürümleri listelediyseniz görebileceğiniz üzere, pyenv ile kurabileceğiniz Python sürümü sayısı oldukça fazladır. Bu sürümlerden herhangi bir tanesini kurmadan önce pyenv’in kurulumları tamamlayabilmesi için ihtiyaç duyduğu bağımlılıklarıkurmanızıtavsiyeederim.Aksitakdirdekurulumubekleyiphataalmaolasılığınız yüksektir.Ohatamesajıdasizişulinkeyönlendirecektir:(pyenv|SıkKarşılaşılanHatalar)11 pyenvBağımlılıklarınKurulumu • Ubuntu/Debian: sudo apt-get install -y build-essential libssl-dev zlib1g-dev libbz2-dev \ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5- dev \ ˓→ xz-utils tk-dev libffi-dev liblzma-dev python-openssl git • Fedora: sudo dnf install zlib-devel bzip2 bzip2-devel readline-devel sqlite \ sqlite-devel openssl-devel xz xz-devel libffi-devel findutils • RHEL/CentOS: sudo yum install zlib-devel bzip2 bzip2-devel readline-devel sqlite \ sqlite-devel openssl-devel xz xz-devel libffi-devel findutils • Archvetürevleri: pacman -S --needed base-devel openssl zlib bzip2 readline sqlite curl \ llvm ncurses xz tk libffi python-pyopenssl git 11https://github.com/pyenv/pyenv/wiki/Common-build-problems 3.1. GNU/LinuxKullanıcıları 15 PythonBelgeleri,Yayım4.1.3 YeniSürümlerinKurulumu pyenv için gerekli ayarları yaptıktan sonra yeni bir Python sürümü kurabilmek için tek yapmanız gereken pyenv install <python-sürümü> şeklinde bir komut çalıştırmaktır. <python-sürümü>kısmınayazacağımızsürümbilgisipyenv install --listsonuçlarıileaynı isimde olmalıdır. Python 3.8.5 sürümünü kurmak için yapmanız gereken aşağıdaki komutu çalıştırmaktır: pyenv install 3.8.5 Bukomutile3.8.5sürümüsisteminizeyüklenecektir. YüklenenSürümünKullanımı Yüklediğiniz sürümün doğrulamasını yapmak için pyenv versions komutunu çalıştırabilirsiniz. Eğer yükleme uygun bir şekilde tamamlandı ise komutu çalıştırdığınızda görmenizgerekençıktışuşekildedir: * system 3.8.5 * işareti hali hazırda aktif olan sürümü temsil etmektedir. Kurduğunuz sürümü aktif olarak kullanabilmekiçinçalıştırmanızgerekenkomutşudur: pyenv global 3.8.5 pyenv ile temel seviyede Python yükleme ve etkinleştirme kısmı bu şekilde özetlenebilir. pyenv kullanımıyla ilgili detaylara GNU/Linux’ta Farklı Sürümleri Birlikte ‘ Kullanmak:ref: gnu-linux-ta-farkli-surumleri-birlikte-kullanmakkısmındadeğineceğiz. 3.2 Windows Kullanıcıları Windows sürümlerinin hiçbirinde Python kurulu olarak gelmez. O yüzden Windows kullanıcıları,Python’ısitesindenindiripkuracak. Bununiçinönceliklehttps://www.python.org/downloads/adresinegidiyoruz. Buadresegittiğinizde,üzerinde‘DownloadPython3.7.0’yazanbirdüğmegöreceksiniz.Daha önce de söylediğimiz gibi, eğer bir Python sürüm numarası ‘2’ ile başlıyorsa o sürüm 2.x serisine,yokeğer‘3’ilebaşlıyorsa3.xserisineaittir.DolayısıylabudüğmePython3sürümünü içerir. Budüğmeyetıklıyoruz.Budüğmeyetıkladığınızdabilgisayarınıza.exeuzantılıkurulumdosyası inecek.Budosyayaçifttıklayarakkurulumprogramınıbaşlatabilirsiniz. (cid:242) Not EğerindireceğinizPythonsürümününmimarisinivesürümünükendinizseçmekisterseniz https://www.python.org/ftp/python/3.7.0adresindenkendinizeuygunolansürümübulup indirebilirsiniz. 16 Bölüm3. PythonNasılKurulur? PythonBelgeleri,Yayım4.1.3 Kurulum dosyasına çift tıkladığınızda karşınıza ilk gelen ekranda, pencerenin alt tarafında şu kutucuklarıgöreceksiniz: 1. Installlauncherforallusers(recommended) 2. AddPython3.7toPATH Burada ilk kutucuk zaten seçilidir. Bunu bu şekilde bırakabilirsiniz. İkinci kutucuk ise Python’ıyolaeklememizi,böyleceyalnızcapythonkomutuvererekPython’ıbaşlatabilmemizi sağlayacak.Oyüzdenoradakiikincikutucuğudaişaretliyoruz. Aynıpencereninüsttarafındaiseşuseçeneklerigöreceksiniz: 1. ->InstallNow 2. ->CustomizeInstallation Burada‘InstallNow’yazankısmatıklayarakkurulumubaşlatıyoruz. Eğer Python’ın bilgisayarda nereye kurulacağını ve başka birtakım kurulum özelliklerini değiştirmek istiyorsanız ‘Customize Installation’ yazılı kısma tıklayabilirsiniz. Ben bu kitapta sizin‘InstallNow’yazankısmatıklayarakkurulumyaptığınızıvarsayacağım. (cid:242) Not Python’ın resmi sitesinde dolaşırken kurulum dosyaları arasında, ‘web-based installer’ (web tabanlı kurulum betiği) adlı bir kurulum dosyası görebilirsiniz. Bu kurulum dosyası, Python’ın çalışması için gereken dosyaları kurulum esnasında internetten indirip kuran, 1MB’dan küçük bir kurulum programı içerir. Dolayısıyla eğer kurulumu bu dosyadan yapacaksanız,kesintisizbirinternetbağlantısınaihtiyacınızolacak. . Uyarı Eğer Windows’ta Python’ı kurmaya çalışırken hata alıyorsanız, muhtemelen işletim sisteminiz güncel değildir. Örneğin Windows 7’de Python kurabilmeniz için, SP1 (Service Pack 1) kurulu olmalıdır. Windows güncellemelerini kurduktan sonra Python’ı kurmayı tekrar deneyin. Ancak Windows XP kullanıyorsanız kurabileceğiniz en yüksek sürüm, Python3.4’tür.NeyazıkkiWindowsXPartıkdesteklenmiyor. 3.3 Python Kurulum ve Çalışma Dizini Python programlama dilini, kullandığımız işletim sistemine nasıl kurabileceğimizi bilmek kadar önemli bir konu da Python’ı hangi dizine kurduğumuzu bilmektir. Zira programcılık maceramızboyuncakarşılaşacağımızbazısorunlar,Python’ınkuruluolduğudizinegitmemizi gerektirecek, üstelik kendi yazdığımız bazı programlarda da Python’ın kurulu olduğu dizinde çeşitli işlemler yapmak ihtiyacı duyacağız. Ayrıca bazı durumlarda, o anda çalışan Python sürümününhangikonumdançalıştığınıtespitetmemizdegerekebilir. İştebusebeplerden,Python’ınhangidizinekurulduğunumutlakabiliyorolmamızlazım. Python’ın,işletimsisteminizdehangidizinekurulduğu,Python’ınasılkurduğunuzabağlıolarak farklılıkgösterir. 3.3. PythonKurulumveÇalışmaDizini 17 PythonBelgeleri,Yayım4.1.3 GNU/Linux dağıtımlarında Python genellikle /usr/lib/python3.7 dizininde kurulur. Ama elbette, eğer siz Python’ı kaynaktan derlediyseniz, derleme sırasında configure betiğine verdiğiniz –prefix parametresi yardımıyla Python’ın kurulum dizinini kendiniz de belirlemiş olabilirsiniz. Windows’ta Python programlama dilini aynen bu kitapta gösterdiğimiz şekilde kurduysanız, Python %LOCALAPPDATA%\Programs\Python dizini içine kurulacaktır. Ancak eğer kurulum penceresinde ‘Customize Installation’ düğmesine basarak kurulumu özelleştirdiyseniz ve ‘Install for all users’ seçeneğini işaretlediyseniz Python %PROGRAMFILES% veya %PROGRAMFILES(x86)adlıçevredeğişkenlerininişaretettiğidiziniçinekurulacaktır. 18 Bölüm3. PythonNasılKurulur? 4 BÖLÜM Python Nasıl Çalıştırılır? Bir önceki bölümde, Python’ı farklı platformlara nasıl kuracağımızı bütün ayrıntılarıyla anlattık. Bu bölümde ise kurduğumuz bu Python programını hem GNU/Linux’ta hem de Windows’ta nasıl çalıştıracağımızı göreceğiz. Öncelikle GNU/Linux kullanıcılarının Python’ı nasılçalıştıracağınabakalım. 4.1 GNU/Linux Kullanıcıları Geçenbölümlerdegördüğünüzgibi,Python3’üGNU/Linuxsistemleriüzerinefarklışekillerde kurabiliyoruz.Bubölümde,herbirkurulumtürüiçinPython3’ünnasılçalıştırılacağınıayrıayrı inceleyeceğiz. 4.1.1 Kurulu Python3’ü Kullananlar Eğer sisteminizde zaten Python3 kurulu ise komut satırında yalnızca şu komutu vererek Python3’übaşlatabilirsiniz: python Ancakdahaöncededediğimizgibi,19.08.2024tarihiitibariylepekçokGNU/Linuxdağıtımında öntanımlıolarakPython2kuruludur.Dolayısıylapythonkomutunuverdiğinizdeçalışansürüm muhtemelen Python2 olacaktır. Bu yüzden sistemimizde öntanımlı olarak hangi sürümün kuruluolduğunavepythonkomutununhangisürümübaşlattığınaçokdikkatetmelisiniz. Yine daha önce de söylediğimiz gibi, sisteminizde hem Python2 hem de Python3 zaten kurulu durumda olabilir. O yüzden yukarıdaki komutu bir de python3 şeklinde vermeyi deneyebilirsiniz. Örneğin Ubuntu GNU/Linux dağıtımının 12.10 sürümünden itibaren python komutu Python2’yi;python3komutuisePython3’üçalıştırıyor. 19 PythonBelgeleri,Yayım4.1.3 4.1.2 Python3’ü Depodan Kuranlar Dediğimiz gibi, 19.08.2024 tarihi itibariyle GNU/Linux dağıtımlarında öntanımlı Python sürümü ağırlıklı olarak Python2’dir. Dolayısıyla python komutu Python’ın 2.x sürümlerini çalıştırır. Bu durumdan ötürü, herhangi bir çakışmayı önlemek için GNU/Linux dağıtımları Python3 paketini farklı bir şekilde adlandırma yoluna gider. Şu anda piyasada bulunan dağıtımların ezici çoğunluğu Python3 paketini ‘python3’ şeklinde adlandırıyor. O yüzden GNU/Linuxkullanıcıları,eğerpaketyöneticilerinikullanarakPythonkurulumugerçekleştirmiş iseler,komutsatırındaşukomutuvererekPython3’übaşlatabilirler: python3 Bukomutunardındanşunabenzerbirekranlakarşılaşmışolmalısınız: @ubuntu:~$ # python3 Python 3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux Type “help”, “copyright”, “credits” or “license” for more information.>>> Eğer yukarıdaki ekranı gördüyseniz Python’la programlama yapmaya hazırsınız demektir. Değilse,geriyedönüpişlerinneredetersgittiğinibulmayaçalışabilirsiniz. Buaşamadaişlerinneredetersgitmişolabileceğinedairbirkaçipucuverelim: 1. Python3 kurulurken paket yöneticinizin herhangi bir hata vermediğinden, programın sisteminizebaşarıylakurulduğundaneminolun.BununiçinPython3’ünkurulupaketler listesindegörünüpgörünmediğinidenetleyebilirsiniz. 2. python3 komutunu doğru verdiğinize emin olun. Python programlama diline özellikle yeni başlayanların en sık yaptığı hatalardan biri python kelimesini yanlış yazmaktır. Pythonyerineyanlışlıklapyhton,pytonveyaphytonyazmışolabilirsiniz.Ayrıcapython3 komutunun tamamen küçük harflerden oluştuğuna dikkat edin. Python ve python bilgisayaraçısındanaynışeylerdeğildir. 3. KullandığınızdağıtımınPython3paketiniadlandırmapolitikasıyukarıdaanlattığımızdan farklıolabilir.Yanisizinkullandığınızdağıtım,belkidePython3paketinifarklıbirşekilde adlandırmıştır.Eğerdurumböyleyse,dağıtımınızınyardımkaynaklarını(wiki,forum,irc, yardımbelgeleri,kullanıcılisteleri,vb.)kullanarakyadaforum..com12 adresinde sorarakPython3’ünnasılçalıştırılacağınıöğrenmeyideneyebilirsiniz. GelelimPython3’ükaynaktanderlemişolanlarındurumuna... 4.1.3 Python3’ü root Olarak Derleyenler EğerPython3’üöncekibölümlerdeanlattığımızşekildekaynaktanroothaklarıilederlediyseniz python3komutuçalışmayacaktır.Bununyerineşukomutukullanmanızgerekecek: python3.7 (cid:242) Not Kurduğunuz Python3 sürümünün 3.7 olduğunu varsayıyorum. Eğer farklı bir Python3 sürümü kurduysanız, elbette başlatıcı komut olarak o sürümün adını kullanmanız 12https://forum..com/ 20 Bölüm4. PythonNasılÇalıştırılır? PythonBelgeleri,Yayım4.1.3 gerekecektir. Mesela: python3.0 veya python3.1. Bu arada python3.7 komutunda 37 sayısınınrakamlarıarasındabiradetnoktaişaretiolduğunugözdenkaçırmıyoruz... Tıpkıpaketdeposundankurulumdaolduğugibi,eğeryukarıdakikomutPython’ıçalıştırmanızı sağlamıyorsa, kurulum esnasında bazı şeyler ters gitmiş olabilir. Örneğin kaynaktan kurulumun herhangi bir aşamasında bir hata almış olabilirsiniz ve bu da Python’ın kurulumunuengellemişolabilir. Gördüğünüz gibi, Python’ı kaynaktan derleyenler Python programlama dilini çalıştırabilmek içinPython’ıntamsürümadınıbelirtiyor.Dilersenizbuşekildeçalışmayadevamedebilirsiniz. Bunun hiçbir sakıncası yok. Ancak ben size kolaylık açısından, /usr/bin/ dizini altına py3 adındabirsembolikbağyerleştirmenizitavsiyeederim.Böylecesadecepy3komutunuvererek Python3’übaşlatabilirsiniz. Pekibununasılyapacağız? Python kaynaktan derlendiğinde çalıştırılabilir dosya /usr/local/bin/ dizini içine Python3.7 (veya kurduğunuz Python3 sürümüne bağlı olarak Python3.0 ya da Python3.1) adıyla kopyalanır. Bu nedenle Python3’ü çalıştırabilmek için python3.7 komutunu kullanmamız gerekir.Python3’üçalıştırabilmekiçinmeselasadecepy3gibibirkomutkullanmakistiyorsak yapacağımız tek şey /usr/local/bin/ dizini içindeki python3.7 adlı dosyaya /usr/bin dizini altından, py3 adlı bir sembolik bağ oluşturmak olacaktır. Bunun için ln komutunu kullanacağız: ln -s /usr/local/bin/python3.7 /usr/bin/py3 Tabii bu komutu yetkili kullanıcı olarak vermeniz gerektiğini söylememe herhalde gerek yoktur. Bu komutu verdikten sonra artık sadece py3 komutu ile Python programlama dilini başlatabilirsiniz. ÇokÖnemliBirUyarı Bir önceki adımda anlattığımız gibi Python3’ü resmi sitesinden indirip kendiniz derlediniz. Gayet güzel. Ancak bu noktada çok önemli bir konuya dikkatinizi çekmek isterim. En baştan beri söylediğimiz gibi, Python programlama dili GNU/Linux işletim sistemlerinde çok önemli bir yere sahiptir. Öyle ki bu programlama dili, kullandığınız dağıtımın belkemiği durumunda olabilir. Örneğin Ubuntu GNU/Linux dağıtımında pek çok sistem aracı Python ile yazılmıştır. Bu yüzden,sistemdekiöntanımlıPythonsürümününneolduğuvedolayısıylapythonkomutunun hangi Python sürümünü çalıştırdığı çok önemlidir. Çünkü sisteminizdeki hayati bazı araçlar, python komutunun çalıştırdığı Python sürümüne bel bağlamış durumdadır. Dolayısıyla sizin bupythonkomutununçalıştırdığıPythonsürümünedokunmamanızgerekir. Mesela eğer kullandığınız işletim sisteminde python komutu Python’ın 2.x sürümlerinden biriniçalıştırıyorsasembolikbağlarveyabaşkaaraçlarvasıtasıylapythonkomutunuPython’ın başka bir sürümüne bağlamayın. Bu şekilde bütün sistemi kullanılmaz hale getirirsiniz. Elbette eğer kurulum aşamasında tarif ettiğimiz gibi, Python3’ü make install yerine make altinstallkomutuilekurmayaözengösterdiyseniz,sonradanoluşturduğunuzbağdosyasını silip python komutunu yine sistemdeki öntanımlı sürüme bağlayabilirsiniz. Bu şekilde her şey yine eski haline döner. Ama eğer Python’ı make install komutuyla kurmanızdan ötürü sistemdeki öntanımlı Python sürümüne ait dosyaları kaybettiyseniz sizin için yapılacak fazla birşeyyok... Sistemitekrareskikararlıhalinegetirmekiçinkan,tervegözyaşıdökeceksiniz... 4.1. GNU/LinuxKullanıcıları 21 PythonBelgeleri,Yayım4.1.3 Aynı şekilde, kullandığınız dağıtımda python3 komutunun öntanımlı olarak belirli bir Python sürümünü başlatıp başlatmadığı da önemlidir. Yukarıda python komutu ile ilgili söylediklerimizpython3vebunabenzerbaşkakomutlariçindeaynengeçerli. Örneğin, Ubuntu GNU/Linux dağıtımında python komutu sistemde kurulu olan Python 2.x sürümünü; python3 komutu ise sistemde kurulu olan Python 3.x sürümünü çalıştırdığından, biz kendi kurduğumuz Python sürümleri için, sistemdeki sürümlerle çakışmayacak isimler seçtik.MeselakendikurduğumuzPython3sürümünüçalıştırmakiçinpy3gibibirkomuttercih ettik. İyi bir test olarak, Python programlama dilini kendiniz kaynaktan derlemeden önce şu komutunçıktısınıiyiceinceleyebilirsiniz: ls -g {,/usr{,/local}}/bin | grep python Bu komut iki farklı Python sürümünün kurulu olduğu sistemlerde şuna benzer bir çıktı verir (çıktıkırpılmıştır): dh_python2 dh_python3 pdb2.7 -> ../lib/python2.7/pdb.py pdb3.7 -> ../lib/python3.7/pdb.py py3versions -> ../share/python3/py3versions.py python -> python2.7 python2 -> python2.7 python2.7 python3 -> python3.7 python3.7 -> python3.7mu python3.7mu python3mu -> python3.7mu pyversions -> ../share/python/pyversions.py Yatık harflerle gösterdiğimiz kısımlara dikkat edin. Gördüğünüz gibi python ve python2 komutlarıbusistemdePython’ın2.7sürümünüçalıştırıyor.python3komutuisePython’ın3.7 sürümünü... Dolayısıyla yukarıdaki çıktıyı aldığımız bir sistemde kendi kurduğumuz Python sürümlerine‘python’,‘python2’veya‘python3’gibiisimlervermektenkaçınmalıyız. Sözün özü, bir GNU/Linux kullanıcısı olarak sistemdeki öntanımlı hiçbir Python sürümünü silmemeli,öntanımlısürümeulaşankomutlarıdeğiştirmemelisiniz.Eğermeselasisteminizde python3 komutu halihazırda bir Python sürümünü çalıştırıyorsa, siz yeni kurduğunuz Python sürümüne ulaşmak için öntanımlı adla çakışmayacak başka bir komut adı kullanın. Yani örneğin sisteminizde python3 komutu Python’ın 3.7 sürümünü çalıştırıyorsa, siz yeni kurduğunuz sürümü çalıştırmak için py3 gibi bir sembolik bağ oluşturun. Bırakın öntanımlı komut(python,python3vb.)öntanımlıPythonsürümünüçalıştırmayadevametsin. Asla unutmayın. Siz bir programcı adayı olarak, program yazacağınız işletim sistemini enineboyunatanımaklayükümlüsünüz.Dolayısıylaişletimsisteminizikararsızhalegetirecek davranışları bilmeli, bu davranışlardan kaçınmalı, yanlış bir işlem yaptığınızda da nasıl geri döneceğinizibilmelisiniz.Helekibirprogramıkaynaktanderlemeyekararvermişseniz... Buciddiuyarıyıdayaptığımızagöregönülrahatlığıylayolumuzadevamedebiliriz. 22 Bölüm4. PythonNasılÇalıştırılır? PythonBelgeleri,Yayım4.1.3 4.1.4 Python3’ü Ev Dizinine Kuranlar Eğer Python3’ü kısıtlı kullanıcı hakları ile derleyip ev dizininize kurduysanız yukarıdaki komutlar Python’ı çalıştırmanızı sağlamayacaktır. Python3’ü ev dizinine kurmuş olan kullanıcılar Python3’ü çalıştırabilmek için, öncelikle komut satırı aracılığıyla Python3’ü kurdukları dizine, oradan da o dizin altındaki bin/ klasörüne ulaşacak ve orada şu komutu verecek: ./python3.7 Diyelim ki Python3’ü $HOME/python adlı dizine kurdunuz. Önce şu komutla $HOME/python/binadlıdizineulaşıyoruz: cd $HOME/python/bin Ardındandaşukomutuveriyoruz: ./python3.7 (cid:242) Not Komutunbaşındaki./işaretininneişeyaradığınıartıkadınızgibibiliyorsunuz... (cid:242) Not Elbette ben burada kurduğunuz Python sürümünün 3.7 olduğunu varsaydım. Eğer farklı birsürümkurduysanızyukarıdakikomutuonagöreyazmanızgerekiyor. Eğeristersenizbuşekildeçalışmayadevamedebilirsiniz.AncakherdefasındaPython’ınkurulu olduğu dizin altına gelip orada ./python3.7 komutunu çalıştırmak bir süre sonra eziyete dönüşecektir.İşlerinizikolaylaştırmakiçinşuişlemleritakipetmelisiniz: 1.evdizininizinaltındabulunan.profile(veyakullandığınızdağıtımagöre.bash_profileyada .bashrc)adlıdosyayıaçın. 2.BudosyanınensonunaşunabenzerbirsatıryerleştirerekPython’ıçalıştırmamızısağlayan dosyanınbulunduğudiziniyolaekleyin: export PATH=$PATH:$HOME/python/bin/ 3.$HOME/python/bin/satırıPython3’ünçalıştırılabilirdosyasınınhangidizinaltındaolduğunu gösteriyor.BenburadaPython3’ünçalıştırılabilirdosyasının$HOME/python/bindiziniiçinde olduğunu varsaydım. O yüzden de $HOME/python/bin/ gibi bir satır yazdım. Ama eğer Python3’ünçalıştırılabilirdosyasısizdefarklıbirdizindeysebusatırıonagöreyazmalısınız. 4. Kendi sisteminize uygun satırı dosyaya ekledikten sonra dosyayı kaydedip çıkın. Dosyada yaptığımızdeğişikliğinetkinhalegelebilmesiiçinşukomutuverin: source .profile Elbetteeğersizinsisteminizdekidosyanınadı.bash_profileveya.bashrciseyukarıdakikomutu onagöredeğiştirmelisiniz. 4.1. GNU/LinuxKullanıcıları 23 PythonBelgeleri,Yayım4.1.3 5.Dahasonra$HOME/python/bin/python3.7adlıdosyaya$HOME/python/bin/dizinialtından meselapy3gibibirsembolikbağverin: ln -s $HOME/python/bin/python3.7 $HOME/python/bin/py3 6.Bilgisayarınızıyenidenbaşlatın. 7.Artıkhangikonumdabulunursanızbulunun,şukomutuvererekPython3’übaşlatabilirsiniz: py3 BuradadaeğeryukarıdakikomutPython3’üçalıştırmanızısağlamıyorsa,bazışeylerieksikveya yanlışyapmışolabilirsiniz.Yardımalmakiçinforum..com13 adresineuğrayabilirsiniz. Python3’übaşarıylakurupçalıştırabildiğinizivarsayarakyolumuzadevamedelim. 4.1.5 GNU/Linux’ta Farklı Sürümleri Birlikte Kullanmak Daha önce de dediğimiz gibi, şu anda piyasada iki farklı Python serisi bulunuyor: Python2 ve Python3. 2020 yılı itibariyle Python2 desteği bitmiştir fakat hem Python2 ile yazılmış programlarıçalıştırmak,hemdePython3ilegeliştirmeyapmakistiyorsanız,sisteminizdehem Python2’yi hem de Python3’ü aynı anda bulundurmayı tercih edebilir veya yazdığınız kodu farklısürümlerdetestetmekisteyebilirsiniz.Pekibununasılyapacaksınız? Enbaştadasöylediğimizgibi,hemenhemenbütünGNU/LinuxdağıtımlarındaPython2kurulu olarak gelir. Dolayısıyla eğer sisteminize ek olarak Python3’ü de kurduysanız (kaynaktan veya paket deposundan), başka herhangi bir şey yapmanıza gerek yok. Yukarıda anlattığımız yönergeleri takip ettiyseniz, konsolda python komutu verdiğinizde Python2, python3 (veya py3)komutunuverdiğinizdeisePython3çalışacaktır. Ama eğer sisteminizde Python2 bile kurulu değilse, ki bu çok çok düşük bir ihtimaldir, Python2’yi paket yöneticiniz yardımıyla sisteminize kurabilirsiniz. Şu anda piyasada olup da paketdeposundaPythonbulundurmayanGNU/Linuxdağıtımıpekazdır. pyenvileSürümleriYönetmek Sürüm Yöneticisi ile Kurulum (pyenv) kısmında anlatıldığı şekilde pyenv kurulumu yaptıktan sonra pyenv install <python-sürümü> ile istediğiniz python sürümünü kolayca kurabilir ve sürümler arasında geçiş yapabilirsiniz. Sürüm geçişlerini şu şekilde örneklendirebiliriz. Sisteminizde3.8.5sürümününaktifolduğunuvarsayaraksisteme2yeniPythonsürümüdaha kuralım: pyenv install 2.7.18 pyenv install 3.6.9 Budurumdapyenv versionskomutununçıktısışuşekildeolacaktır: system 2.7.18 3.6.9 * 3.8.5 (set by /home/{kullanıcı-adınız}/.pyenv/version) 13https://forum..com/ 24 Bölüm4. PythonNasılÇalıştırılır? PythonBelgeleri,Yayım4.1.3 pyenvilekurulansürümlerinkullanılabilmesiiçin3farklıkomutbulunmaktadır. • pyenv local: pyenv local <python-sürümü> local komutu ile sürüm seçtiğinizde, bulunduğunuz dizinde .python-version isimli bir dosya oluşur.BudosyaiçerisindeyalnızcaseçtiğinizPythonsürümünumarasıbulunurvebusürüm yalnızca mevcut dizin içerisinde aktif olur. Aşağıdaki şekilde bir klasör yapısında proje1 dizinindepyenv local 3.6.9komutunuçalıştırdığımızıdüşünelim: projeler proje1 .python-version # 3.6.9 proje2 Budurumdaproje1dizinindepythonkomutu3.6.9sürümü,bunundışındakibütündizinlerde 3.8.5sürümüçalışacaktır. • pyenv global: pyenv global <python-sürümü> Kurulum kısmında da bahsettiğimiz gibi aktif kullandığınız Python sürümünü global komutu ile etkinleştirerek sürekli olarak kullanabilirsiniz. Python2 yüklü sistemlerde python komutu Python2 sürümünü çalıştırırken, global komutu ile aktifleştirme sonrasında python yazdığınızdaseçtiğinizPythonsürümüçalışacaktır. pyenv global 3.8.5 • pyenv shell: pyenv shell <python-sürümü> shell komutu ile aktifleştirdiğiniz Python sürümü mevcut terminal oturumunuz süresince aktif olacaktır. shell komutu local ve global sürümleri geçersiz kılar. Yani local olarak ayarladığınız bir dizine girdiğinizde bile hala shell ile aktifleştirdiğiniz sürüm çalışır. Normal şekilde kullanmaya devam edebilmek için pyenv shell --unset komutunu çalıştırmalı veya terminaliyenidenbaşlatmalısınız. YeniPythonsürümleriçıktıkçapyenv’eeklenmektedir.Yenisürümleriindirebilmekiçinpyenv updatekomutuilepyenvaracınıgüncellemelisiniz. GNU/Linux’ta Python’ı nasıl çalıştıracağımızı ve farklı Python sürümlerini bir arada nasıl kullanacağımızıöğrendiğimizegöre,Windowskullanıcılarınındurumunabakabiliriz. 4.1. GNU/LinuxKullanıcıları 25 PythonBelgeleri,Yayım4.1.3 4.2 Windows Kullanıcıları WindowskullanıcılarıPython3’üikişekildebaşlatabilir: 1. Başlat>TümProgramlar>Python3.7>Python3.7yolunutakipederek. 2. Komutsatırındapythonkomutunuvererek. Eğer birinci yolu tercih ederseniz, Python’ın size sunduğu komut satırına doğrudan ulaşmış olursunuz. Ancak Python komut satırına bu şekilde ulaştığınızda bazı kısıtlamalarla karşı karşıya kalırsınız. Doğrudan Python’ın komut satırına ulaşmak yerine önce MS-DOS komut satırınaulaşıp,oradanPythonkomutsatırınaulaşmaközellikleilerideyapacağınızçalışmalar açısından çok daha mantıklı olacaktır. O yüzden komut satırına bu şekilde ulaşmak yerine ikinci seçeneği tercih etmenizi tavsiye ederim. Bunun için komut satırına ulaşın ve orada şu komutuçalıştırın: python Bukomutuverdiğinizdeşunabenzerbirekranlakarşılaşacaksınız: C:\Users\> python3 Python 3.7.0 (v3.7.0:c0e311e010fc, 19.08.2024, 12:24:55) [MSC v.1600 32 bit (Intel)] on win32 Type “help”, “copyright”, “credits” or “license” for more information.>>> Eğer bu komut yukarıdakine benzer bir ekran yerine bir hata mesajı verdiyse kurulum sırasında bazı adımları eksik veya yanlış yapmış olabilirsiniz. Yukarıdaki komut çalışmıyorsa, muhtemelen kurulum sırasında Add Python 3.7 to PATH kutucuğunu işaretlemeyi unutmuşsunuzdur. Eğer öyleyse, kurulum dosyasını tekrar çalıştırıp, ilgili adımıgerçekleştirmenizveyaPython’ıkendinizYOL’aeklemenizgerekiyor. pythonkomutunubaşarıylaçalıştırabildiğinizivarsayarakyolumuzadevamedelim. 4.2.1 Windows’ta Farklı Sürümleri Birlikte Kullanmak Dahaönce dedediğimiz gibi,şuanda piyasadaiki farklıPythonserisi bulunuyor:Python2 ve Python3. Çok uzun zamandan beri kullanımda olduğu için, Python2 Python3’e kıyasla daha yaygın.EğerhemPython2ileyazılmışprogramlarıçalıştırmak,hemdePython3ilegeliştirme yapmakistiyorsanız,sisteminizdehemPython2’yihemdePython3’üaynıandabulundurmayı tercihedebilirsiniz.Pekibununasılyapacaksınız? Windows’ta bu işlemi yapmak çok kolaydır. python.org/download14 adresine giderek farklı Python sürümlerini bilgisayarınıza indirebilir ve bunları bilgisayarınıza normal bir şekilde kurabilirsiniz.BuşekildesisteminizeistediğinizsayıdafarklıPythonsürümükurabilirsiniz.Peki bufarklısürümlerenasılulaşacaksınız? Python, bilgisayarımızdaki farklı Python sürümlerini çalıştırabilmemiz için bize ‘py’ adlı özel birprogramsunar. (cid:242) Not PyprogramıyalnızcaWindows’aözgüdür.GNU/Linux’taböylebirprogrambulunmaz. 14https://www.python.org/downloads/ 26 Bölüm4. PythonNasılÇalıştırılır? PythonBelgeleri,Yayım4.1.3 Pyprogramınıçalıştırmakiçin,sistemkomutsatırınaulaşıyoruzveoradaşukomutuveriyoruz: py Bu komutu verdiğinizde (teorik olarak) sisteminize en son kurduğunuz Python sürümü çalışmaya başlayacaktır. Ancak bu her zaman böyle olmayabilir. Ya da aldığınız çıktı beklediğiniz gibi olmayabilir. O yüzden bu komutu verdiğinizde hangi sürümün başladığına dikkatedin. Eğer sisteminizde birden fazla Python sürümü kurulu ise, bu betik yardımıyla istediğiniz sürümübaşlatabilirsiniz.MeselasisteminizdehemPython’ın2.xsürümlerindenbiri,hemde Python’ın3.xsürümlerindenbirikuruluise,şukomutyardımıylaPython2.x’ibaşlatabilirsiniz: py -2 Python3.x’ibaşlatmakiçiniseşukomutuveriyoruz: py -3 Eğer sisteminizde birden fazla Python2 veya birden fazla Python3 sürümü kurulu ise, ana ve altsürümnumaralarınıbelirterekistediğinizsürümeulaşabilirsiniz: py -2.6 py -2.7 py -3.4 py -3.5 Bu arada dikkat ettiyseniz, Python programlarını başlatabilmek için hem python hem de py komutunu kullanma imkanına sahibiz. Eğer sisteminizde tek bir Python sürümü kurulu ise, Python’ı başlatmak için python komutunu kullanmak isteyebilir, farklı sürümlerin bir arada bulunduğudurumlardaisepyilebufarklısürümleretektekerişmekisteyebilirsiniz. BöylecePython’lailgilientemelbilgileriedinmişolduk.Bubölümdeöğrendiklerimizsayesinde Python programlama dilini bilgisayarımıza kurabiliyor ve bu programlama dilini başarıyla çalıştırabiliyoruz. 4.3 Hangi Komut Hangi Sürümü Çalıştırıyor? ArtıkPythonprogramlamadilininbilgisayarımızanasılkurulacağınıvebuprogramlamadilinin nasıl çalıştırılacağını biliyoruz. Ancak konunun öneminden ötürü, tekrar vurgulayıp, cevabını bilip bilmediğinizden emin olmak istediğimiz bir soru var: Kullandığınız işletim sisteminde acabahangikomut,hangiPythonsürümünüçalıştırıyor? Bu kitapta anlattığımız farklı yöntemleri takip ederek, Python programlama dilini bilgisayarınıza farklı şekillerde kurmuş olabilirsiniz. Örneğin Python programlama dilini, kullandığınız GNU/Linux dağıtımının paket yöneticisi aracılığıyla kurduysanız, Python’ı başlatmak için python3 komutunu kullanmanız gerekebilir. Aynı şekilde, eğer Python’ı Windows’a kurduysanız, bu programlama dilini çalıştırmak için python komutunu kullanıyor olabilirsiniz. Bütün bunlardan farklı olarak, eğer Python’ın kaynak kodlarını sitesinden 4.3. HangiKomutHangiSürümüÇalıştırıyor? 27 PythonBelgeleri,Yayım4.1.3 indirip derlediyseniz, Python’ı çalıştırmak için kendi belirlediğiniz bambaşka bir adı da kullanıyor olabilirsiniz. Örneğin belki de Python’ı çalıştırmak için py3 gibi bir komut kullanıyorsunuzdur... Pythonprogramlamadiliniçalıştırmakiçinhangikomutukullanıyorolursanızolun,lütfenbir sonrakikonuyageçmedenöncekendikendinizeşusorularısorun: 1. KullandığımişletimsistemindePythonprogramıhalihazırdakurulumu? 2. KullandığımişletimsistemindetoplamkaçfarklıPythonsürümüvar? 3. pythonkomutubuPythonsürümlerindenhangisiniçalıştırıyor? 4. python3komutuçalışıyormu? 5. Eğerçalışıyorsa,bukomutPythonsürümlerindenhangisiniçalıştırıyor? 6. KaynaktanderlediğimPythonsürümünüçalıştırmakiçinhangikomutukullanıyorum? Bizbukitaptaşunlarıvarsayacağız: 1. Kullandığınız işletim sisteminde Python’ın 2.x sürümlerini python komutuyla çalıştırıyorsunuz. 2. Kullandığınız işletim sisteminde Python’ın 3.x sürümlerini python3 komutuyla çalıştırıyorsunuz. Bu kitaptan yararlanırken, bu varsayımları göz önünde bulundurmalı, eğer bunlardan farklı komutlarkullanıyorsanız,kodlarınızıonagöreayarlamalısınız. 4.4 Sistem Komut Satırı ve Python Komut Satırı Buraya kadar Python programlama dilini nasıl çalıştıracağımız konusundaki bütün bilgileri edindik. Ancak programlamaya yeni başlayanların çok sık yaptığı bir hata var: Sistem komut satırıilePythonkomutsatırınıbirbirinekarıştırmak. Asla unutmayın, kullandığınız işletim sisteminin komut satırı ile Python’ın komut satırı birbirinden farklı iki ortamdır. Yani Windows’ta cmd, Ubuntu’da ise Ctrl+Alt+T ile ulaştığınız ortam, sistem komut satırı iken, bu ortamı açıp python3 (veya python ya da py3) komutu vererek ulaştığınız ortam Python’ın komut satırıdır. Sistem komut satırında sistem komutları (mesela cd, ls, dir, pwd) verilirken, Python komut satırında, biraz sonra öğrenmeye başlayacağımız Python komutları verilir. Dolayısıyla python3 (veya python ya da py3) komutunu verdikten sonra ulaştığınız ortamda cd Desktop ve ls gibi sistem komutlarını kullanmayaçalışmanızsizihüsranauğratacaktır. 28 Bölüm4. PythonNasılÇalıştırılır? 5 BÖLÜM Etkileşimli Python Şu ana kadar öğrendiklerimiz sayesinde Python programlama dilinin farklı sistemlere nasıl kurulacağını ve nasıl çalıştırılacağını biliyoruz. Dolayısıyla Python’ı bir önceki bölümde anlattığımız şekilde çalıştırdığımız zaman şuna benzer bir ekranla karşılaşacağımızın farkındayız: @ubuntu:~$ # python3 Python 3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux Type “help”, “copyright”, “credits” or “license” for more information.>>> Biz şimdiye kadar bu ekrana Python komut satırı demeyi tercih ettik. Dilerseniz bundan sonra da bu adı kullanmaya devam edebilirsiniz. Ancak teknik olarak bu ekrana etkileşimli kabuk(interactiveshell)adıverildiğinibilmemizdefaydavar.Etkileşimlikabuk,bizimPython programlamadiliileilişkikurabileceğimiz,yanionunlaetkileşebileceğimizbirüstkatmandır. Etkileşimli kabuk, asıl programımız içinde kullanacağımız kodları deneme imkanı sunar bize. Burası bir nevi test alanı gibidir. Örneğin bir Python kodunun çalışıp çalışmadığını denemek veyanasılçalıştığını,nesonuçverdiğinigörmekistediğimizdebuekransonderecefaydalıbir araç olarak karşımıza çıkar. Bu ortam, özellikle Python’a yeni başlayanların bu programlama diline aşinalık kazanmasını sağlaması açısından da bulunmaz bir araçtır. Biz de bu bölümde etkileşimlikabuküzerindebazıçalışmalaryaparak,Python’aalışmaturlarıatacağız. Bu arada, geçen bölümde söylediğimiz gibi, bu ortamın sistem komut satırı adını verdiğimiz ortamdanfarklıolduğunuaklımızdançıkarmıyoruz.Ozamandadediğimizgibi,sistemkomut satırında sistem komutları, Python komut satırında (yani etkileşimli kabukta) ise Python komutlarıverilir.Meselaecho %PATH%,cd Desktop,dirvelsbirersistemkomutudur.Eğerbu komutlarıetkileşimlikabuktavermeyekalkışırsanız,bunlarbirerPythonkomutuolmadığıiçin, Pythonsizebirhatamesajıgösterecektir.MeselaPython’ınetkileşimlikabuğundacd Desktop komutunuverirsenizşöylebirhataalırsınız: >>> cd Desktop File "<stdin>", line 1 cd Desktop (sonrakisayfayadevam) 29 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ^ SyntaxError: invalid syntax Çünkü cd Desktop bir Python komutu değildir. O yüzden bu komutu Python’ın etkileşimli kabuğunda veremeyiz. Bu komutu ancak ve ancak kullandığımız işletim sisteminin komut satırındaverebiliriz. Ne diyorduk? Etkileşimli kabuk bir veya birkaç satırlık kodları denemek/test etmek için gayet uygun bir araçtır. İsterseniz konuyu daha fazla lafa boğmayalım. Zira etkileşimli kabuğu kullandıkça bunun ne büyük bir nimet olduğunu siz de anlayacaksınız. Özellikle derlenerek çalıştırılan programlama dilleri ile uğraşmış olan arkadaşlarım, etkileşimli kabuğun gücünü gördüklerindegözyaşlarınahakimolamayacaklar. Farklı işletim sistemlerinde py3, py -3, python3 veya python komutunu vererek Python’ın komutsatırınanasılerişebileceğimiziöncekiderslerdeayrıntılıolarakanlatmıştık.Etkileşimli kabuğaulaşmaktasıkıntıyaşıyorsanızeskikonularıtekrargözdengeçirmenizitavsiyeederim. Etkileşimli kabuk üzerinde çalışmaya başlamadan önce dilerseniz önemli bir konuyu açıklığa kavuşturalım: Etkileşimli kabuğu başarıyla çalıştırdık. Peki bu kabuktan çıkmak istersek ne yapacağız? Elbette doğrudan pencere üzerindeki çarpı tuşuna basarak bu ortamı terk edebilirsiniz.Ancakbuişlemikabakuvvetebaşvurmadanyapmanınbiryoluolmalı,değilmi? Etkileşimlikabuktançıkmanınbirkaçfarklıyoluvardır: 1. Pencereüzerindekiçarpıdüğmesinebasmak(kabakuvvet) 2. ÖnceCtrl+Ztuşlarına,ardındandaEntertuşunabasmak(Windows) 3. Ctrl+Ztuşlarınabasmak(GNU/Linux) 4. ÖnceF6tuşuna,ardındandaEntertuşunabasmak(Windows) 5. quit()yazıpEntertuşunabasmak(Bütünişletimsistemleri) 6. import sys; sys.exit()komutunuvermek(Bütünişletimsistemleri) Sizbufarklıyöntemlerarasından,kolayınızahangisigeliyorsaonuseçebilirsiniz.Busatırların yazarı,Windows’ta2numaralı;GNU/Linux’taise3numaralıseçeneğitercihediyor. 5.1 Etkileşimli Kabukta İlk Adımlar Python’da etkileşimli kabuğu nasıl çalıştıracağımızı ve bu ortamı nasıl terk edeceğimizi öğrendiğimize göre artık etkileşimli kabuk aracılığıyla Python programlama dilinde ilk adımlarımızıatmayabaşlayabiliriz. Şimdi kendi sistemimize uygun bir şekilde etkileşimli kabuğu tekrar çalıştıralım. Etkileşimli kabuğu çalıştırdığımızda ekranda görünen >>> işareti Python’ın bizden komut almaya hazır olduğunu gösteriyor. Python kodlarımızı bu >>> işaretinden hemen sonra, hiç boşluk bırakmadanyazacağız. Buradaki ‘hiç boşluk bırakmadan’ kısmı önemli. Python’a yeni başlayanların en sık yaptığı hatalardan biri >>> işareti ile komut arasında boşluk bırakmalarıdır. Eğer bu şekilde boşluk bırakırsanızyazdığınızkodhataverecektir. İstersenizbasitbirdenemeyapalım.>>>işaretindenhemensonra,hiçboşlukbırakmadanşu komutuyazalım: 30 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> "Merhaba Zalim Dünya!" Bu arada yukarıdaki kodlar içinde görünen >>> işaretini siz yazmayacaksınız. Bu işareti etkileşimli kabuğun görünümünü temsil etmek için yerleştirdik oraya. Siz “Merhaba Zalim Dünya!”satırınıyazdıktansonradoğrucaEnterdüğmesinebasacaksınız. BukomutuyazıpEntertuşunabastığımızdaşöylebirçıktıalmışolmalıyız: ’Merhaba Zalim Dünya!’ BöyleceyarımyamalakdaolsailkPythonprogramımızıyazmışolduk... Muhtemelen bu kod, içinizde en ufak bir heyecan dahi uyandırmamıştır. Hatta böyle bir kod yazmaksizeanlamsızbilegelmişolabilir.AmaaslındaşuküçücükkodparçasıbilebizePython programlama dili hakkında çok önemli ipuçları veriyor. Gelin isterseniz bu tek satırlık kodu birazinceleyelim... 5.1.1 Karakter Dizilerine Giriş Dediğimizgibi,yukarıdayazdığımızküçücükkodparçasısiziheyecanlandırmamışolabilir,ama aslındabukodPythonprogramlamadilivebudilinyapısıhakkındaçokönemlibilgileriiçinde barındırıyor. Teknik olarak söylemek gerekirse, yukarıda yazdığımız “Merhaba Zalim Dünya!” ifadesi bir karakter dizisidir. İngilizcede buna string adı verilir ve programlama açısından son derece önemlibirkavramdırbu.Kavramınadındandarahatlıklaanlayabileceğinizgibi,birveyadaha fazlakarakterdenoluşanöğelerekarakterdizisi(string)diyoruz. Karakter dizileri bütün programcılık maceramız boyunca karşımıza çıkacak. O yüzden bu kavramınekadarerkenöğrenirsekokadariyi. Peki bir verinin karakter dizisi olup olmamasının bize ne faydası var? Yani yukarıdaki cümle karakterdizisiolmuşolmamışbizene? Python’da, o anda elinizde bulunan bir verinin hangi tipte olduğunu bilmek son derece önemlidir. Çünkü bir verinin ait olduğu tip, o veriyle neler yapıp neler yapamayacağınızı belirler. Python’da her veri tipinin belli başlı özellikleri vardır. Dolayısıyla, elimizdeki bir verinintipinibilmezsekoveriyiprogramlarımızdaetkinbirşekildekullanamayız.İşteyukarıda örneğini verdiğimiz “Merhaba Zalim Dünya!” adlı karakter dizisi de bir veri tipidir. Python’da karakter dizileri dışında başka veri tipleri de bulunur. Biraz sonra başka veri tiplerini de inceleyeceğiz. Dikkat ederseniz “Merhaba Zalim Dünya!” adlı karakter dizisini tırnak içinde gösterdik. Bu da çokönemlibirbilgidir.Eğerbucümleyitırnakiçinealmazsakprogramımızhataverecektir: >>> Merhaba Zalim Dünya! File "<stdin>", line 1 Merhaba Zalim Dünya! ^ SyntaxError: invalid syntax Zatentırnakişaretleri,karakterdizilerininayırtediciözelliğidir.Öyleki,Python’datırnakiçinde gösterdiğinizherşeybirkarakterdizisidir.Örneğinşubirkarakterdizisidir: 5.1. EtkileşimliKabuktaİlkAdımlar 31 PythonBelgeleri,Yayım4.1.3 >>> "a" Gördüğünüz gibi, tırnak içinde gösterilen tek karakterlik bir öğe de Python’da karakter dizisi sınıfınagiriyor. Meselaşu,içiboşbirkarakterdizisidir: >>> "" Şudaiçindebiradetboşlukkarakteribarındıranbirkarakterdizisi... >>> " " Buikisiarasındakifarkadikkatediyoruz:Python’da‘boşkarakterdizisi’ve‘biradetboşluktan oluşan karakter dizisi’ birbirlerinden farklı iki kavramdır. Adından da anlaşılacağı gibi, boş karakter dizileri içlerinde hiçbir karakter (başka bir deyişle ‘öğe’) barındırmayan karakter dizileridir.Bir(veyadahafazla)boşluktanoluşankarakterdizileriiseiçlerindeboşlukkarakteri barındıran karakter dizileridir. Yani bu karakter dizilerinden biri boş, öteki ise doludur. Ama neticede her ikisi de karakter dizisidir. Şu anda oldukça anlamsız bir konu üzerinde vakit kaybediyormuşuz hissine kapılmış olabilirsiniz, ama emin olun, Python programlama diline yenibaşlayanlarınönemlitökezlemenoktalarındanbiridirbusöylediğimizşey... Dilersenizbizkarakterdizilerineelimizinalışmasıiçinbirkaçörnekverelim: >>> "Elma" ’Elma’ >>> "Guido Van Rossum" ’Guido Van Rossum’ >>> "Python programlama dili" ’Python programlama dili’ >>> "ömnhbgfgh" ’ömnhbgfgh’ >>> "$5&" ’$5&’ >>> "" ’’ >>> " " ’ ’ 32 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Yukarıdaki örneklerin hepsi birer karakter dizisidir. Dikkat ettiyseniz yukarıdaki karakter dizilerinin hepsinin ortak özelliği tırnak içinde gösteriliyor olmasıdır. Dediğimiz gibi, tırnak işaretlerikarakterdizilerininayırtediciözelliğidir. Pekibirverininkarakterdizisiolupolmadığındannasıleminolabilirsiniz? Eğerherhangibirverininkarakterdizisiolupolmadığıkonusundatereddütünüzvarsa,type() adlı bir fonksiyondan yararlanarak o verinin tipini sorgulayabilirsiniz. Bu fonksiyonu şöyle kullanıyoruz: >>> type("Elma") <class ’str’> (cid:242) Not Bu ‘fonksiyon’ kelimesinin kafanızı karıştırmasına izin vermeyin. İleride fonksiyonları oldukçaayrıntılıbirşekildeinceleyeceğimiziçin,type()ifadesininbirfonksiyonolduğunu bilmenizşimdilikyeterliolacaktır.Üstelikfonksiyonkonusunuayrıntılıbirşekildeanlatma vaktigeldiğindesizfonksiyonlaradairpekçokşeyizatenöğrenmişolacaksınız. Burada amacımız “Elma” adlı öğenin tipini denetlemek. Denetlenecek öğeyi type() fonksiyonunun parantezleri arasında belirttiğimize dikkat edin. (Fonksiyonların parantezleri içindebelirtilendeğerlereteknikdildeparametreadıverilir.) Yukarıdaki çıktıda bizi ilgilendiren kısım, sondaki ‘str’ ifadesi. Tahmin edebileceğiniz gibi, bu ifadestringkelimesininkısaltmasıdır.BukelimeninTürkçedekarakterdizisianlamınageldiğini söylemiştik. O halde yukarıdaki çıktıya bakarak, “Elma” öğesinin bir karakter dizisi olduğunu söyleyebiliyoruz. type() fonksiyonu yardımıyla kendi kendinize bazı denemeler yaparak konuyu iyice sindirmenizi tavsiye ederim. Mesela “½{656$#gfd” ifadesinin hangi sınıfa girdiğini kontrol etmeklebaşlayabilirsiniz. Peki karakter dizileri ile neler yapabiliriz? Şu anda Python bilgimiz kısıtlı olduğu için karakter dizileri ile çok fazla şey yapamayız, ama ileride bilgimiz arttıkça, karakter dizileriyle sıkı fıkı olacağız. Esasında, henüz bilgimiz kısıtlı da olsa karakter dizileriyle yine de ufak tefek bazı şeyler yapamayacak durumda değiliz. Mesela şu anki bilgilerimizi ve görür görmez size tanıdık gelecekbazıbasitparçalarıkullanarak,karakterdizilerinibirbirleriylebirleştirebiliriz: >>> "" + ".com" ’.com’ Burada + işaretini kullanarak karakter dizilerini nasıl birleştirebildiğimize dikkat edin. İki karakterdizisini+işaretiilebirleştirdiğimizdekarakterdizilerininarasındaboşlukolmadığına özellikledikkatiniziçekmekisterim.Budurumuşuörnektedahanetgörebiliriz: >>> "Fırat" + "Özgül" ’FıratÖzgül’ 5.1. EtkileşimliKabuktaİlkAdımlar 33 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, bu iki karakter dizisi, arada boşluk olmadan birbiriyle bitiştirildi. Araya boşlukeklemekiçinbirkaçfarklıyöntemdenyararlanabilirsiniz: >>> "Fırat" + " " + "Özgül" ’Fırat Özgül’ Burada iki karakter dizisi arasına bir adet boşluk karakteri yerleştirdik. Aynı etkiyi şu şekilde deeldeedebilirsiniz: >>> "Fırat" + " Özgül" BuradadaÖzgülkarakterdizisininbaşınabiradetboşlukyerleştirerekistediğimizçıktıyıelde ettik. Bu arada, karakter dizilerini birleştirmek için mutlaka + işareti kullanmak zorunda değilsiniz. Siz + işaretini kullanmasanız da Python sizin karakter dizilerini birleştirmek istediğinizi anlayacakkadarzekidir: >>> "www" "." "google" "." "com" ’www.google.com’ Ancakgördüğünüzgibi,+işaretinikullandığınızdakodlarınızdahaokunaklıoluyor. +işaretidışındakarakterdizileriilebirlikte*(çarpı)işaretinidekullanabiliriz.Ozamanşöyle biretkieldeederiz: >>> "w" * 3 ’www’ >>> "yavaş " * 2 ’yavaş yavaş ’ >>> "-" * 10 ’----------’ >>> "uzak" + " " * 5 + "çok uzak..." ’uzak çok uzak...’ Gördüğünüz gibi, çok basit parçaları bir araya getirerek karmaşık çıktılar elde edebiliyoruz. Mesela son örnekte “uzak” adlı karakter dizisine önce 5 adet boşluk karakteri (" " * 5), ardındanda“çokuzak...”adlıkarakterdizisiniekleyerekistediğimizçıktıyıaldık. Burada + ve * adlı iki yeni araç görüyoruz. Bunlar aslında sayılarla birlikte kullanılan birer aritmetik işleçtir. Normalde + işleci toplama işlemleri için, * işleci ise çarpma işlemleri için kullanılır. Ama yukarıdaki örneklerde, + işaretinin ‘birleştirme’; * işaretinin ise ‘tekrarlama’ anlamındanötürübuikiişlecibazıdurumlardakarakterdizileriilebirliktedekullanabiliyoruz. Bunlarındışındabirde-(eksi)ve/(bölü)işleçleribulunur.Ancakbuişaretlerikarakterdizileri ilebirliktekullanamıyoruz. 34 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Karakter dizilerini sonraki bir bölümde bütün ayrıntılarıyla inceleyeceğiz. O yüzden şimdilik bukonuyabiraraverelim. 5.1.2 Sayılara Giriş Dedik ki, Python’da birtakım veri tipleri bulunur ve karakter dizileri de bu veri tiplerinden yalnızca biridir. Veri tipi olarak karakter dizilerinin dışında, biraz önce aritmetik işleçler vesilesiylesözünüettiğimiz,birde‘sayı’(number)adlıbirveritipivardır. Herhalde sayıların ne anlama geldiğini tarif etmeye gerek yok. Bunlar bildiğimiz sayılardır. Mesela: >>> 23 23 >>> 4567 4567 >>> 2.3 2.3 >>> (10+2j) (10+2j) Python’dasayılarınfarklıalttürleribulunur.Meselatamsayılar,kayannoktalısayılar,karmaşık sayılar... Yukarıdaki örnekler arasında geçen 23 ve 4567 birer tamsayıdır. İngilizcede bu tür sayılara integeradıverilir. 2.3 ise bir kayan noktalı sayıdır (floating point number veya kısaca float). Bu arada kayan noktalısayılardabasamakayracıolarakvirgüldeğil,noktaişaretikullandığımızadikkatedin. Ensondagördüğümüz10+2jsayısıisebirkarmaşıksayıdır(complex).Ancakeğermatematikle yoğunbirşekildeuğraşmıyorsanızkarmaşıksayılarpekkarşınızaçıkmaz. Sayılarıtemelolaraköğrendiğimizegöreetkileşimlikabuğubasitbirhesapmakinesiniyetine kullanabiliriz: >>> 5 + 2 7 >>> 25 * 25 625 >>> 5 / 2 (sonrakisayfayadevam) 5.1. EtkileşimliKabuktaİlkAdımlar 35 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 2.5 >>> 10 - 3 7 Yukarıdaki örneklerde kullandığımız aritmetik işleçlerden biraz önce bahsetmiştik. O yüzden bunlara yabancılık çektiğinizi zannetmiyorum. Ama biz yine de bu işleçleri ve görevlerini şöylecesıralayalım: tabularytabulary İşleç Görevi + toplama - çıkarma * çarpma / bölme Yukarıdaki örneklerde bir şey dikkatinizi çekmiş olmalı: Karakter dizilerini tanımlarken tırnak işaretlerini kullandık. Ancak sayılarda tırnak işareti yok. Daha önce de dediğimiz gibi, tırnak işaretleri karakter dizilerinin ayırt edici özelliğidir. Python’da tırnak içinde gösterdiğiniz her şeybirkarakterdizisidir.Meselaşuörneklerebakalım: >>> 34657 34657 Bubirsayıdır.Pekiyaşu? >>> "34657" ’34657’ Buisebirkarakterdizisidir.Dilersenizbirazönceöğrendiğimiztype()fonksiyonuyardımıyla buverilerintipinisorgulayalım: >>> type(34657) <class ’int’> Buradaki ‘int’ ifadesi İngilizce “integer”, yani tamsayı kelimesinin kısaltmasıdır. Demek ki 34657sayısıbirtamsayıimiş.Birdeşunabakalım: >>> type("34657") <class ’str’> Gördüğünüz gibi, 34657 sayısını tırnak içine aldığımızda bu sayı artık sayı olma özelliğini yitiriyor ve bir karakter dizisi oluyor. Şu anda bu çok önemsiz bir ayrıntıymış gibi gelebilir size, ama aslında son derece önemli bir konudur bu. Bu durumun etkilerini şu örneklerde görebilirsiniz: 36 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> 23 + 65 88 Buradanormalbirşekildeikisayıyıbirbiriyletopladık. Birdeşunabakın: >>> "23" + "65" ’2365’ Burada ise Python iki karakter dizisini yan yana yazmakla yetindi; yani bunları birleştirdi. Python açısından “23” ve 23 birbirinden farklıdır. “23” bir karakter dizisi iken, 23 bir sayıdır. Aynı şey “65” ve 65 için de geçerlidir. Yani Python açısından “65” ile “Merhaba Zalim Dünya!” arasında hiç bir fark yoktur. Bunların ikisi de karakter dizisi sınıfına girer. Ancak 65 ile “65” birbirindenfarklıdır.65birsayıiken,“65”birkarakterdizisidir. Bubilgi,özelliklearitmetikişlemlerdebüyükönemtaşır.Bunudilersenizşuörneklerüzerinde gösterelim: >>> 45 + "45" Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unsupported operand type(s) for +: ’int’ and ’str’ Gördüğünüz gibi, yukarıdaki kodlar hata veriyor. Bunun sebebi bir sayı (45) ile bir karakter dizisini (“45”) birbiriyle toplamaya çalışmamızdır. Asla unutmayın, aritmetik işlemler ancak sayılararasındayapılır.Karakterdizileriileherhangibiraritmetikişlemyapılamaz. Birdeşunabakalım: >>> 45 + 45 90 Bukodlarisedüzgünçalışır.Çünküburadaikisayıyıaritmetikişlemesoktukvebaşarılıolduk. Sonolarakşuörneğiverelim: >>> "45" + "45" ’4545’ Burada + işlecinin toplama anlamına gelmediğine dikkat edin. Bu işleç burada iki karakter dizisinibirleştirmegöreviüstleniyor.Yaniyukarıdakiörneğinşuörnektenhiçbirfarkıyoktur: >>> "." + "com" ’.com’ Buikiörnektedeyaptığımızşeykarakterdizilerinibirbiriylebirleştirmektir. 5.1. EtkileşimliKabuktaİlkAdımlar 37 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, + işlecinin sağındaki ve solundaki değerler birer karakter dizisi ise bu işleç bu iki değeri birbiriyle birleştiriyor. Ama eğer bu değerler birer sayı ise + işleci bu değerleri birbiriylearitmetikolaraktopluyor. * işleci de + işlecine benzer bir iş yapar. Yani eğer * işleci bir sayı ve bir karakter dizisi ile karşılaşırsa,okarakterdizisini,verilensayıkadartekrarlar.Örneğin: >>> "w" * 3 ’www’ Burada * işleci bir karakter dizisi (“w”) ve bir sayı (3) arasında işlem yaptığı için, karakter dizisini,ilgilisayıkadartekrarlıyor.Yani“w”karakterdizisini3keztekrarlıyor. Birdeşunabakalım: >>> 25 * 3 75 Burada ise * işleci iki adet sayı arasında işlem yaptığı için bu değerleri birbiriyle aritmetik olarakçarpıyorve75değerinieldeetmemizisağlıyor. Gördüğünüz gibi, o anda elimizde bulunan verilerin tipini bilmek gerçekten de büyük önem taşıyor. Çünkü eğer elimizdeki verilerin tipini bilmezsek nasıl sonuçlar elde edeceğimizi de kestiremeyiz. Böylecekarakterdizileriilesayılararasındakifarkıöğrenmişolduk.Bubilgilersizeönemsizmiş gibi gelebilir, ama aslında karakter dizileri ile sayılar arasındaki farkı anlamak, Python programlama dilinin önemli bir bölümünü öğrenmiş olmak demektir. İleride yazacağınız en karmaşık programlarda bile, bazen programınızın çalışmamasının (veya daha kötüsü yanlış çalışmasının) nedeninin karakter dizileri ile sayıları birbirine karıştırmanız olduğunu göreceksiniz. O yüzden burada öğrendiğiniz hiçbir bilgi kırıntısını baştan savmamanızı (ve sabırsızlıkyadaaceleciliketmemenizi)tavsiyeederim. 5.1.3 Değişkenler Şimdi şöyle bir durum düşünün: Diyelim ki sisteme kayıt için kullanıcı adı ve parola belirlenmesiniisteyenbirprogramyazıyorsunuz.Yazacağınızbuprogramda,belirlenebilecek kullanıcıadıveparolanıntoplamuzunluğu40karakterigeçmeyecek. Buprogramıyazarkenilkaşamadayapmanızgerekenşey,kullanıcınınbelirlediğikullanıcıadı veparolanınuzunluğunutektekdenetlemekolmalı. Meselakullanıcışöylebirkullanıcıadıbelirlemişolsun: firat_ozgul_1980 Kullanıcınınbelirlediğiparolaiseşuolsun: rT%65#$hGfUY56123 İşte bizim öncelikle kullanıcıdan gelen bu verilerin teker teker uzunluğunu biliyor olmamız lazım,kibuverilerintoplam40karaktersınırınıaşıpaşmadığınıdenetleyebilelim. 38 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Pekibuverilerinuzunluğununasılölçeceğiz?Elbettebununiçinverilerdekiharflerielletektek saymayacağız.Bununyerine,Pythonprogramlamadilininbizesunduğubiraracıkullanacağız. Pekinedirbuaraç? Hatırlarsanız birkaç sayfa önce type() adlı bir fonksiyondan söz etmiştik. Bu fonksiyonun görevibirverininhangitipteolduğunubizebildirmekti.İştetıpkıtype()gibi,Python’dalen() adlıbaşkabirfonksiyondahabulunur.Bufonksiyonungöreviisekarakterdizilerinin(veileride göreceğimiz gibi, başka veri tiplerinin) uzunluğunu ölçmektir. Yani bu fonksiyonu kullanarak birkarakterdizisinintoplamkaçkarakterdenoluştuğunuöğrenebiliriz. Biz henüz kullanıcıdan nasıl veri alacağımızı bilmiyoruz. Ama şimdilik şunu söyleyebiliriz: Python’da kullanıcıdan herhangi bir veri aldığımızda, bu veri bize bir karakter dizisi olarak gelecektir. Yani kullanıcıdan yukarıdaki kullanıcı adı ve parolayı aldığımızı varsayarsak, bu verilerbizeşuşekildegelir: "firat_ozgul_1980" ve: "rT%65#$hGfUY56123" Gördüğünüzgibi,eldeettiğimizverilertırnakiçindeyeralıyor.Yanibunlarbirerkarakterdizisi. Şimdi gelin yukarıda bahsettiğimiz len() fonksiyonunu kullanarak bu karakter dizilerinin uzunluğunuölçelim. Dediğimiz gibi, len() de tıpkı type() gibi bir fonksiyondur. Dolayısıyla len() fonksiyonunun kullanımı type() fonksiyonunun kullanımına çok benzer. Nasıl type() fonksiyonu bize, kendisine verdiğimiz parametrelerin tipini söylüyorsa, len() fonksiyonu da kendisine verdiğimizparametrelerinuzunluğunusöyler. Dikkatlicebakın: >>> len("firat_ozgul_1980") 16 >>> len("rT%65#$hGfUY56123") 17 Demek ki “firat_ozgul_1980” adlı karakter dizisinde 16; “rT%65#$hGfUY56123” adlı karakter dizisindeise17karaktervarmış.Bizimistediğimizşeybuikideğerintoplamuzunluğunun40 karakteriaşmaması.Bunudenetlemekiçinyapmamızgerekenşeybuikideğerinuzunluğunu birbiriyletoplamakolmalı.Yani: >>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123") Buradan alacağımız sonuç 33 olacaktır. Demek ki kullanıcı 40 karakter limitini aşmamış. O haldeprogramımızbukullanıcıadıveparolayıkabuledebilir... Bu arada, belki farkettiniz, belki de farketmediniz, ama burada da çok önemli bir durumla karşıkarşıyayız.Gördüğünüzgibilen()fonksiyonubizesayıdeğerlibirverigönderiyor.Gelin istersenizbunuteyitedelim: 5.1. EtkileşimliKabuktaİlkAdımlar 39 PythonBelgeleri,Yayım4.1.3 >>> type(len("firat_ozgul_1980")) <class ’int’> len() fonksiyonunun bize sayı değerli bir veri göndermesi sayesinde bu fonksiyondan elde ettiğimizdeğerleribirbiriyletoplayabiliyoruz: >>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123") 33 Eğerlen()fonksiyonubizesayıdeğildemeselakarakterdizisiverseydi,bufonksiyondanelde ettiğimizdeğerleriyukarıdakigibidoğrudanbirbiriylearitmetikolaraktoplayamazdık.Öylebir durumda,buikiveriyibirbiriyletoplamayaçalıştığımızda,+işleci16ve17değerlerinibirbiriyle toplamakyerinebudeğerleribirbiriylebirleştirerekbize‘1617’gibibirsonuçverecekti. Herzamansöylediğimizgibi,Python’daveritipikavramınıçokiyianlamakveoandaelimizde bulunanbirverininhangitipteolduğunubilmekçokönemlidir.Aksihaldeprogramlarımızda hatayapmamızkaçınılmazdır. Eğeryukarıdaanlattığımızşeylerikafakarıştırıcıbulduysanızhiçendişeetmeyin.Birkaçbölüm sonrainput()adlıbirfonksiyondanbahsettiğimizdeşimdisöylediğimizşeyleriçokdahanet anlayacaksınız. Biraz sonra len() fonksiyonundan bahsetmeye devam edeceğiz, ama isterseniz ondan önce çokönemlibirkonuyadeğinelim. Birazönceşöylebirörnekvermiştik: >>> len("firat_ozgul_1980") 16 >>> len("rT%65#$hGfUY56123") 17 >>> len("firat_ozgul_1980") + len("rT%65#$hGfUY56123") Bukodlar,istediğimizşeyigayetgüzelyerinegetiriyor.Amasizcedeyukarıdakikodlardaçok rahatsızedicibirdurumyokmu? Dikkat ederseniz, yukarıdaki örneklerde kullandığımız verileri, program içinde her ihtiyaç duyduğumuzdatekrartekraryazdık.Böyleceaynıprogramiçindeikikez“firat_ozgul_1980”;iki kez de “rT%65#$hGfUY56123” yazmak zorunda kaldık. Halbuki bu verileri programlarımızın içinde her ihtiyaç duyduğumuzda tekrar tekrar yazmak yerine bir değişkene atasak ve gerektiğindeodeğişkenikullansakçokdahaiyiolmazmı?Herhaldeolur... Pekinedirbudeğişkendediğimizşey? Python’da bir program içinde değerlere verilen isimlere değişken denir. Hemen bir örnek verelim: >>> n = 5 40 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Burada 5 sayısını bir değişkene atadık. Değişkenimiz ise n. Ayrıca 5 sayısını bir değişkene atamak için = işaretinden yararlandığımıza da çok dikkat edin. Buradan, = işaretinin Python programlamadilindedeğeratamaişlemleriiçinkullanıldığısonucunuçıkarıyoruz. n = 5 gibi bir komut yardımıyla 5 değerini n adlı değişkene atamamız sayesinde artık ne zaman5sayısınaihtiyaçduysakbundeğişkeniniçağırmamızyeterliolacaktır: >>> n 5 >>> n * 10 50 >>> n / 2 2.5 Gördüğünüzgibi,5değerinibirdeğişkeneatadıktansonra,bu5değerinikullanmamızgereken yerlerdesadecedeğişkeninadınıkullandığımızdadeğişkenindeğeriniPythonotomatikolarak yerine koyabiliyor. Yani n = 5 komutuyla n adlı bir değişken tanımladıktan sonra, artık ne zaman5sayısınaihtiyaçduysakndeğişkeniniçağırmamızyeterliolacaktır.Pythono5değerini otomatikolarakyerinekoyar. Şimdidepiadlıbaşkabirdeğişkentanımlayalım: >>> pi = 3.14 Bupideğişkeninindeğeriilendeğişkeninindeğerinitoplayalım: >>> pi + n 8.14 Gördüğünüz gibi, değerleri her defasında tekrar yazmak yerine bunları bir değişkene atayıp, gerekenyerdebudeğişkenikullanmakçokdahapratikbiryöntem. Aynışeyiprogramımıziçindeyapabiliriz: >>> kullanıcı_adı = "firat_ozgul_1980" >>> parola = "rT%65#$hGfUY56123" =işaretinikullanarakilgilideğerlereartıkbireradverdiğimiz,yanibudeğerleribirerdeğişkene atadığımız için, bu değerleri kullanmamız gereken yerlerde değerlerin kendisini uzun uzun yazmakyerine,belirlediğimizdeğişkenadlarınıkullanabiliriz.Mesela: >>> len(kullanıcı_adı) 16 >>> len(parola) (sonrakisayfayadevam) 5.1. EtkileşimliKabuktaİlkAdımlar 41 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 17 >>> len(kullanıcı_adı) + len(parola) 33 >>> k_adı_uzunluğu = len(kullanıcı_adı) >>> type(k_adı_uzunluğu) <class ’int’> Gördüğünüzgibi,değişkenkullanımıişlerimizibirhaylikolaylaştırıyor. DeğişkenAdıBelirlemeKuralları Pythonprogramlamadilinde,değişkenadıolarakbelirleyebileceğimizkelimesayısıneredeyse sınırsızdır. Yani hemen hemen her kelimeyi değişken adı olarak kullanabiliriz. Ama yine de değişken adı belirlerken dikkat etmemiz gereken bazı kurallar var. Bu kuralların bazıları zorunluluk,bazılarıiseyalnızcatavsiyeniteliğindedir. Şimdibukurallarıtektekinceleyelim: 1.Değişkenadlarıbirsayıilebaşlayamaz.Yanişukullanımyanlıştır: >>> 3_kilo_elma = "5 TL" 2.Değişkenadlarıaritmetikişleçlerlebaşlayamaz.Yanişukullanımyanlıştır: >>> +değer = 4568 3.Değişkenadlarıyabiralfabeharfiyleyada_işaretiylebaşlamalıdır: >>> _değer = 4568 >>> değer = 4568 4.DeğişkenadlarıiçindeTürkçekarakterlerkullanabilirsiniz.Ancakileridebeklenmedikuyum sorunlarıçıkmasıihtimalinekarşıdeğişkenadlarındaTürkçekarakterkullanmaktankaçınmak isteyebilirsiniz. 5.Aşağıdakikelimelerideğişkenadıolarakkullanamazsınız: [’False’, ’None’, ’True’, ’and’, ’as’, ’assert’, ’async’, ’await’, ’break’, ’class’, ’continue’, ’def’, ’del’, ˓→ ’elif’, ’else’, ’except’, ’finally’, ’for’, ’from’, ’global’, ’if’, ’import’, ’in’, ’is’, ’lambda’, ’nonlocal’, ˓→ ’not’, ’or’, ’pass’, ’raise’, ’return’, ’try’, ’while’, ’with’, ’yield’] Bunlar Python’da özel anlam ifade eden kelimelerdir. Etkileşimli kabuk zaten bu kelimeleri değişkenadıolarakkullanmanızaizinvermez.Örneğin: 42 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> elif = "hoş kız" File "<stdin>", line 1 elif = "hoş kız" ^ SyntaxError: invalid syntax >>> as = "kare" File "<stdin>", line 1 as = "kare" ^ SyntaxError: invalid syntax >>> False = 45 File "<stdin>", line 1 SyntaxError: assignment to keyword Amaileridegöreceğimizgibi,programlarınızıbirdosyayayazarkenbukelimelerideğişkenadı olarakkullanmayaçalışırsanızprogramınıztespitetmesiçokgüçhatalarüretecektir. Bu arada elbette yukarıdaki listeyi bir çırpıda ezberlemeniz beklenmiyor sizden. Python programlamadiliniöğrendikçeözelkelimeleribirbakıştatanıyabilecekdurumageleceksiniz. Ayrıcaeğeristersenizşukomutlarıvererek,istediğinizheranyukarıdakilisteyeulaşabilirsiniz: >>> import keyword >>> keyword.kwlist [’False’, ’None’, ’True’, ’and’, ’as’, ’assert’, ’async’, ’await’, ’break’, ’class’, ’continue’, ’def’, ’del’, ˓→ ’elif’, ’else’, ’except’, ’finally’, ’for’, ’from’, ’global’, ’if’, ’import’, ’in’, ’is’, ’lambda’, ’nonlocal’, ˓→ ’not’, ’or’, ’pass’, ’raise’, ’return’, ’try’, ’while’, ’with’, ’yield’] Sizebirsoru:Acababulistedekaçtanekelimevar? Bu soru karşısında listedeki kelimeleri tek tek elle saymaya kalkışan arkadaşlarıma teessüflerimiiletiyorum... Butürişleriçinhangiaracıkullanabileceğimiziartıkçokiyibiliyor olmalısınız: >>> len(keyword.kwlist) 35 Bukodlarışöyleyazabileceğimizidebiliyorsunuz: >>> yasaklı_kelimeler = keyword.kwlist >>> len(yasaklı_kelimeler) 35 5.1. EtkileşimliKabuktaİlkAdımlar 43 PythonBelgeleri,Yayım4.1.3 Buarada,yukarıdakikodlarınbirkısmınıhenüzanlayamamışolabilirsiniz.Hiçendişeetmeyin. Yukarıdaki kodları vermemizin sebebi değişken adı olarak kullanılamayacak kelimelere kısa yoldan nasıl ulaşabileceğinizi gösterebilmek içindir. Bir-iki bölüm sonra burada yazdığımız kodlarırahatlıklaanlayabilecekdüzeyegeleceksiniz. Yukarıda verdiğimiz kodların çıktısından anladığımıza göre, toplam 35 tane kelime varmış değişkenadıbelirlerkenkullanmaktankaçınmamızgereken... 6. Yukarıdaki kelimeler dışında, Python programlama diline ait fonksiyon ve benzeri araçlarınadlarınıdadeğişkenadıolarakkullanmamalısınız.Örneğinyazdığınızprogramlarda değişkenlerinize type veya len adı vermeyin. Çünkü ‘type’ ve ‘len’ Python’a ait iki önemli fonksiyonunadıdır.Eğermeselabirdeğişkenetypeadınıverirseniz,oprogramdaartıktype() fonksiyonunukullanamazsınız: >>> type = 3456 Bu örnekte type adında bir değişken tanımladık. Şimdi mesela “elma” kelimesinin tipini denetlemekiçintype()fonksiyonunukullanmayaçalışalım: >>> type("elma") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’int’ object is not callable Gördüğünüzgibi,artıktype()fonksiyonuçalışmıyor.Çünküsiz‘type’kelimesinibirdeğişken adıolarakkullanarak,type()fonksiyonunukullanılamazhalegetirdiniz. Bu durumdan kurtulmak için etkileşimli kabuğu kapatıp tekrar açabilirsiniz. Ya da eğer etkileşimli kabuğu kapatmak istemiyorsanız şu komut yardımıyla type değişkenini ortadan kaldırmayıdatercihedebilirsiniz: >>> del type Böylece, (tahmin edebileceğiniz gibi delete (silmek) kelimesinin kısaltması olan) del komutuyla type değişkenini silmiş oldunuz. Artık ‘type’ kelimesi yine type() fonksiyonunu çağıracak: >>> type("elma") <class ’str’> 7. Değişken adlarını belirlerken, değişkeni oluşturan kelimeler arasında boşluk bırakılamaz. Yanişukullanımyanlıştır: >>> kullanıcı adı = "" Yukarıdakideğişkenişuşekildetanımlayabiliriz: >>> kullanıcı_adı = "" Yadaşöyle: 44 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> kullanıcıAdı = "" 8. Değişken adları belirlerken, değişken adının, değişkenin değerini olabildiğince betimlemesinedikkatetmemizkodlarımızınokunaklılığınıartıracaktır.Örneğin: >>> personel_sayısı = 45 Yukarıdaki,tanımladığıdeğereuygunbirdeğişkenadıdır.Şuisekurallarauygunbirdeğişken adıolsadayeterincebetimleyicideğildir: >>> sayı = 45 9.Değişkenadlarıneçokkısa,nedeçokuzunolmalıdır.Meselaşudeğişkenadı,kodlarıokuyan kişiye,değişkendeğerininanlamıkonusundapekfikirvermez: >>> a = 345542353 Şudeğişkenadıisegereksizyereuzundur: >>> türkiye_büyük_millet_meclisi_milletvekili_sayısı = 600 Değişkenadlarınınuzunluğunumakulseviyedetutmakesastır: >>> tbmm_mv_sayısı = 600 Yukarıda verdiğimiz bütün bu örnekler bize, Python’da değişkenlerin, değerlere atanmış adlardan ibaret olduğunu gösteriyor. Değişkenler, yazdığımız programlarda bize çok büyük kolaylık sağlar. Mesela 123432456322 gibi bir sayıyı ya da “Türkiye Cumhuriyeti Çalışma ve Sosyal Güvenlik Bakanlığı” gibi bir karakter dizisini gerektiği her yerde tek tek elle yazmak yerine, bunları birer değişkene atayarak, gerektiğinde sadece bu değişken adını kullanmak çokdahamantıklıbiriştir. Ayrıca zaten ileride kullanıcıdan veri almaya başladığınızda, aldığınız bu verileri, yazdığınız programda kullanabilmek için mutlaka bir değişkene atamanız gerekecek. O yüzden Python’dakideğişkenkavramınışimdideniyitanıyıpanlamaktabüyükfaydavar. UygulamaÖrnekleri Gelin isterseniz yukarıda verdiğimiz bilgileri pekiştirmek için birkaç ufak alıştırma yapalım, alıştırmayaparkendesiziyinePythonprogramlamadilineilişkinçokönemlibazıyenibilgilerle tanıştıralım. Diyelimkiaylıkyolmasrafımızıhesaplayanbirprogramyazmakistiyoruz.Elimizdekiverilerin şunlarolduğunuvarsayalım: 1. Cumartesi-Pazargünleriçalışmıyoruz. 2. Dolayısıylaayda22günçalışıyoruz. 3. Evdenişegitmekiçinkullandığımızvasıtanınücreti1.5TL 4. İştenevedönmekiçinkullandığımızvasıtanınücreti1.4TL 5.1. EtkileşimliKabuktaİlkAdımlar 45 PythonBelgeleri,Yayım4.1.3 Aylık yol masrafımızı hesaplayabilmek için gidiş ve dönüş ücretlerini toplayıp, bunları çalıştığımız gün sayısıyla çarpmamız yeterli olacaktır. Elimizdeki bu bilgilere göre aylık yol masrafımızıhesaplamakiçinşöylebirformülüretebiliriz: masraf = gün sayısı x (gidiş ücreti + dönüş ücreti) DilersenizhemenbunubirPythonprogramıhalinegetirelim: >>> 22 * (1.5 + 1.4) 63.8 Demekkibirayda63.8TL’likbiryolmasrafımızvarmış. Buarada,yukarıdakiörnektebirşeydikkatiniziçekmişolmalı.Aritmetikişlemiyaparkenbazı sayıları parantez içine aldık. Python’da aritmetik işlemler yapılırken alıştığımız matematik kuralları geçerlidir. Yani mesela aynı anda bölme, çıkarma, toplama ve çarpma işlemleri yapılacaksa işlem öncelik sırası önce bölme ve çarpma, sonra toplama ve çıkarma şeklinde olacaktır.Elbettesizparantezleryardımıylabuişlemsırasınıdeğiştirebilirsiniz. Bu anlattıklarımıza göre, eğer yukarıda yol masrafını hesaplayan programda parantezleri kullanmazsak, işlem öncelik kuralları gereğince Python önce 22 ile 1.5’i çarpıp, çıkan sonucu 1.4 ile toplayacağı için elde ettiğimiz sonuç yanlış çıkacaktır. Bizim burada doğru sonuç alabilmemiz için önce 1.5 ile 1.4’ü toplamamız, çıkan sonucu da 22 ile çarpmamız gerekiyor. Busıralamayıdaparantezleryardımıylaeldeediyoruz. Yine dikkat ederseniz, yukarıdaki örnek programda aslında çok verimsiz bir yol izledik. Gördüğünüz gibi, bu programda bütün değerleri tek tek elle kendimiz giriyoruz. Örneğin çalışılan gün sayısına karşılık gelen 22 değerini başka bir yerde daha kullanmak istesek aynı sayıyı tekrar elle doğrudan kendimiz girmek zorundayız. Mesela yılda kaç gün çalıştığımızı hesaplayalım: >>> 22 * 12 264 Gördüğünüz gibi, burada da 22 sayısına ihtiyaç duyduk. Aslında değerleri bu şekilde her defasında tekrar tekrar elle girmek hem hata yapma riskini artırdığı, hem de bize fazladan iş çıkardığıiçintercihedilmeyenbiryöntemdir.Bununyerine,22sayısınabirisimverip,gereken yerlerde bu ismi kullanmak daha mantıklı olacaktır. Yani tıpkı kullanıcı ve parola örneğinde olduğugibi,buradadaverileriönceliklebirdeğişkeneatamakçokdahaakıllıcabiriştir: >>> gün = 22 >>> gidiş_ücreti = 1.5 >>> dönüş_ücreti = 1.4 >>> gün * (gidiş_ücreti + dönüş_ücreti) 63.8 Bütün değerleri birer değişkene atadığımız için, artık bu değişkenleri istediğimiz yerde kullanabiliriz. Mesela yılda toplam kaç gün çalıştığımızı bulmak istersek, ilgili değeri elle yazmakyerine,yukarıdatanımladığımızgündeğişkeninikullanabiliriz: 46 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> gün * 12 264 İlerleyen zamanda aylık çalışılan gün sayısı değişirse sadece gün değişkeninin değerini değiştirmemizyeterliolacaktır: >>> gün = 23 >>> gün * (gidiş_ücreti + dönüş_ücreti) 66.7 >>> gün * 12 276 Eğer bu şekilde değişken atamak yerine, değerleri gerektiği her yerde elle yazsaydık, bu değerlerde herhangi bir değişiklik yapmamız gerektiğinde program içinde geçen ilgili bütün değerleribuluptektekdeğiştirmemizgerekecekti: >>> 23 * (1.6 + 1.5) 71.3 >>> 23 * 12 276 Değişken kavramı şu anda gözünüze pek anlamlı görünmemiş olabilir. Ama programlarımızı ileride dosyaya kaydettiğimiz zaman bu değişkenler çok daha kullanışlı araçlar olarak karşımızaçıkacaktır. Dilersenizbirörnekdahayaparakyukarıdakibilgilerinkafamızaiyiceyerleşmesinisağlayalım. Meselabirdaireninalanını(yaklaşıkolarak)hesaplayanbirprogramyazalım. Öncelikleçapadlıbirdeğişkentanımlayarakdaireninçapınıbelirleyelim: >>> çap = 16 Bu değeri kullanarak dairemizin yarıçapını hesaplayabiliriz. Bunun için çap değişkeninin değerininyarısınıalmamızyeterliolacaktır: >>> yarıçap = çap / 2 pisayısını3.14159olarakalalım. >>> pi = 3.14159 Birdaireninalanformülü(pi)r2’dir: >>> alan = pi * (yarıçap * yarıçap) Sonolarakalandeğişkeninindeğeriniekranayazdırabiliriz: 5.1. EtkileşimliKabuktaİlkAdımlar 47 PythonBelgeleri,Yayım4.1.3 >>> alan 201.06176 Böylecebirdaireninalanınıyaklaşıkolarakhesaplamışolduk.Dilersenizprogramımızıbirde derlitopluolarakgörelim: >>> çap = 16 >>> yarıçap = çap / 2 >>> pi = 3.14159 >>> alan = pi * (yarıçap * yarıçap) >>> alan 201.06176 Görüyorsunuz ya, değişkenler işimizi nasıl da kolaylaştırıyor. Eğer yukarıdaki programda değişkenkullanmasaydıkkodlarımızşöylegörünecekti: >>> 3.14159 * ((16/2) * (16/2)) 201.06176 Bu kodlar tek kullanımlıktır. Eğer yukarıdaki örnekte mesela dairenin çapını değiştirmeniz gerekirse,ikiyerdeelledeğişiklikyapmanızgerekir.Amadeğişkenlerikullandığımızdasadece çap değişkeninin değerini değiştirmeniz yeterli olacaktır. Ayrıca değişken kullanmadığınızda, ilgilideğeriprogramboyuncaaklınızdatutmanızgerekir.Örneğinçapdeğişkeninikullanmak yerine, gereken her yerde 16 değerini kullanacaksanız, bu 16 değerini sürekli aklınızda tutmanız lazım. Ama bu değeri en başta bir değişkene atarsanız, 16 değerini kullanmanız gerekenyerlerde,akıldatutmasıdahakolaybirifadeolançapisminikullanabilirsiniz. Bu arada yeri gelmişken sizi yeni bir işleçle daha tanıştıralım. Şimdiye kadar Python’da toplama (+), çıkarma (-), çarpma (*), bölme (/) ve değer atama (=) işleçlerini gördük. Ama yukarıdaverdiğimizsonörnek,başkabirişleçdahaöğrenmemizigerektiriyor... Yukarıdakişuörneğetekrarbakalım: alan = pi * (yarıçap * yarıçap) Buradayarıçapdeğişkenininkaresinialabilmekiçinbudeğerikendisiyleçarptık.Aslındagayet mantıklıvemakulbiryöntem.Karebulmakiçindeğerikendisiyleçarpıyoruz.Eğerbirsayının küpünübulmakisteseydikosayıyıüçkezkendisiyleçarpacaktık: >>> 3 * 3 * 3 27 Peki ya bir sayının mesela beşinci kuvvetini hesaplamak istersek ne yapacağız? O sayıyı beş kezkendisiylemiçarpacağız?Bunekadarvasatbiryöntem,değilmi? Elbette bir sayının herhangi bir kuvvetini hesaplamak için o sayıyı kendisiyle kuvvetince çarpmayacağız. Python’da bu tür ‘kuvvet hesaplamaları’ için ayrı bir işleç (ve fonksiyon) bulunur. Önceliklekuvvethesaplarınıyapmamızısağlayanişleçtensözedelim. 48 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Python’da ** adlı bir işleç bulunur. Bu işlecin görevi bir sayının kuvvetini hesaplamamızı sağlamaktır. Örneğin bir sayının 2. kuvvetini, ya da başka bir deyişle karesini hesaplamak istersekşöylebirkodyazabiliriz: >>> 12 ** 2 144 Burada 12 sayısının 2. kuvvetini, yani karesini hesapladık. Bu bilgiyi yukarıdaki formüle uygulayalım: >>> alan = pi * (yarıçap ** 2) Bu işleci herhangi bir sayının herhangi bir kuvvetini hesaplamak için kullanabiliriz elbette. Mesela23sayısınınküpünü(yani3.kuvvetini)hesaplayalım: >>> 23 ** 3 12167 Aynı işleçten, bir sayının karekökünü hesaplamak için de yararlanabilirsiniz. Neticede bir sayının0.5’incikuvveti,osayınınkareköküdür: >>> 144 ** 0.5 12.0 Gördüğünüz gibi, kuvvet hesaplama işlemleri için bu işleç son derece kullanışlı bir araç vazifesi görüyor. Ama eğer istersek aynı iş için özel bir fonksiyondan da yararlanabiliriz. Bu fonksiyonunadıpow(). Pekibufonksiyonunasılkullanacağız? Dahaönceöğrendiğimiztype()velen()fonksiyonlarınınasılkullanıyorsakpow()fonksiyonu daaynışekildekullanacağız. type()velen()fonksiyonlarınıbirtakımparametrelerilebirliktekullanıyordukhatırlarsanız. Aynışekildepow()fonksiyonudabirtakımparametreleralır. Daha önce öğrendiğimiz fonksiyonları tek bir parametre ile birlikte kullanmıştık. pow() fonksiyonu ise toplam üç farklı parametre alır. Ama genellikle bu fonksiyon yalnızca iki parametreilekullanılır. Bufonksiyonuşöylekullanıyoruz: >>> pow(12, 2) 144 >>> pow(23, 3) 12167 >>> pow(144, 0.5) (sonrakisayfayadevam) 5.1. EtkileşimliKabuktaİlkAdımlar 49 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 12.0 Gördüğünüz gibi, pow() fonksiyonunun ilk parametresi asıl sayıyı, ikinci parametresi ise bu sayınınhangikuvvetinihesaplamakistediğimizigösteriyor. Bu arada, fonksiyonun parantezleri içinde belirttiğimiz parametreleri birbirinden virgül ile ayırdığımızıgözdenkaçırmayın. Dediğimiz gibi, pow() fonksiyonu, pek kullanılmayan üçüncü bir parametre daha alır. Bu fonksiyonunüçüncüparametresişöylekullanılır.Dikkatlicebakın: >>> pow(16, 2, 2) 0 Bukomutşuanlamagelir: 16 sayısının 2’nci kuvvetini hesapla ve çıkan sayıyı 2’ye bölüp, bölme işleminden kalansayıyıgöster! 16 sayısının 2. kuvveti 256 sayısıdır. 256 sayısını 2’ye böldüğümüzde, bölme işleminin kalanı 0’dır.Yani256sayısı2’yetambölünür... Birörnekdahaverelim: >>> pow(11, 3, 4) 3 Demekki,11sayısının3.kuvvetiolan1331sayısı4’ebölündüğünde,bölmeişlemindenkalan sayı3imiş... Dediğimiz gibi, pow() fonksiyonu genellikle sadece iki parametre ile kullanılır. Üçüncü parametreninkullanımalanıoldukçadardır. DeğişkenlereDairBazıİpuçları Değişkenin ne demek olduğunu öğrendiğimize göre, değişkenlere dair bazı ufak ipuçları verebiliriz. AynıDeğereSahipDeğişkenlerTanımlama Şimdi size şöyle bir soru sormama izin verin: Acaba aynı değere sahip iki değişkeni nasıl tanımlayabiliriz?Yanimeseladeğeri4sayısıolanikifarklıdeğişkeninasılbelirleyeceğiz? Aklınızaşöylebirçözümgelmişolabilir: >>> a = 4 >>> b = 4 Böyleceikiside4değerinesahipavebadlıikifarklıdeğişkentanımlamışolduk.Butamamen geçerlibiryöntemdir.AncakPython’dabuişlemiyapmanındahakolaybiryoluvar.Bakalım: 50 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 >>> a = b = 4 Bukodlarbiröncekiyletamamenaynıişlevigörür.Yaniherikikodda4değerinesahipaveb değişkenleritanımlamamızısağlar: >>> a 4 >>> b 4 Bu bilgiyi kullanarak mesela bir yıl içindeki her bir ayın çektiği gün sayısını ay adlarına atayabilirsiniz: >>> ocak = mart = mayıs = temmuz = ağustos = ekim = aralık = 31 >>> nisan = haziran = eylül = kasım = 30 >>> şubat = 28 Böylecebirçırpıdadeğeri31olanyediadetdeğişken,değeri30olandörtadetdeğişken,değeri 28 olan bir adet değişken tanımlamış olduk. Bu değişkenlerin değerine nasıl ulaşacağınızı biliyorsunuz: >>> ocak 31 >>> haziran 30 >>> şubat 28 >>> mayıs 31 >>> ekim 31 >>> eylül 30 Eğer Python’ın aynı anda birden fazla değişkene tek bir değer atama özelliği olmasaydı yukarıdakikodlarışöyleyazmamızgerekirdi: 5.1. EtkileşimliKabuktaİlkAdımlar 51 PythonBelgeleri,Yayım4.1.3 >>> ocak = 31 >>> şubat = 28 >>> mart = 31 >>> nisan = 30 >>> mayıs = 31 >>> haziran = 30 >>> temmuz = 31 >>> ağustos = 31 >>> eylül = 30 >>> ekim = 31 >>> kasım = 30 >>> aralık = 31 Budeğişkenlerinasılbirprogramiçindekullanacağınıztamamensizinhayalgücünüzekalmış. Mesela bu değişkenleri kullanarak aylara göre doğalgaz faturasını hesaplayan bir program yazabiliriz. Hemen son gelen doğalgaz faturasını (örn. Mart ayı) elimize alıp inceliyoruz ve bu faturadan şuverilerieldeediyoruz: Martayıdoğalgazfaturasınagöresayaçtanölçülenhacim346m3.Demekkibiraydatoplam 346m3 doğalgazharcamışız. Fatura tutarı 273.87 TL imiş. Yani 346 m3 doğalgaz tüketmenin bedeli 273.87 TL. Buna göre değişkenlerimizitanımlayalım: >>> aylık_sarfiyat = 346 >>> fatura_tutarı = 273.87 Bubilgiyikullanarakdoğalgazınbirimfiyatınıhesaplayabiliriz.Formülümüzşöyleolmalı: >>> birim_fiyat = fatura_tutarı / aylık_sarfiyat >>> birim_fiyat 0.7915317919075144 Demekkidoğalgazınm3 fiyatı(vergilerlebirlikteyaklaşık)0.79TL’yekarşılıkgeliyormuş. Bunoktadagünlükortalamadoğalgazsarfiyatımızıdahesaplamamızgerekiyor: >>> günlük_sarfiyat = aylık_sarfiyat / mart >>> günlük_sarfiyat 11.161290322580646 DemekkiMartayındagünlükortalama11m3 doğalgaztüketmişiz. BütünbubilgilerikullanarakNisanayındagelecekfaturayıtahminedebiliriz: >>> nisan_faturası = birim_fiyat * günlük_sarfiyat * nisan >>> nisan_faturası 265.03548387096777 52 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Şubatayıfaturasıiseşöyleolabilir: >>> şubat_faturası = birim_fiyat * günlük_sarfiyat * şubat >>> şubat_faturası 247.36645161290326 Burada farklı değişkenlerin değerini değiştirerek daha başka işlemler de yapabilirsiniz. Örneğin pratik olması açısından günlük_sarfiyat değişkeninin değerini 15 yaparak hesaplamalarınızıbunagöregüncelleyebilirsiniz. Gördüğünüz gibi, aynı anda birden fazla değişken tanımlayabilmek işlerimizi epey kolaylaştırıyor. Değişkenlerleilgilibiripucudahaverelim... DeğişkenlerinDeğeriniTakasEtme Diyelim ki, işyerinizdeki personelin unvanlarını tuttuğunuz bir veritabanı var elinizde. Bu veritabanındaşunabenzerilişkilertanımlı: >>> osman = "Araştırma Geliştirme Müdürü" >>> mehmet = "Proje Sorumlusu" İlerleyen zamanda işvereniniz sizden Osman ve Mehmet’in unvanlarını değiştirmenizi talep edebilir.YaniOsman’ıProjeSorumlusu,Mehmet’ideAraştırmaGeliştirmeMüdürüyapmanızı isteyebilirsizden. Patronunuzun bu isteğini Python’da çok rahat bir biçimde yerine getirebilirsiniz. Dikkatlice bakın: >>> osman, mehmet = mehmet, osman Böylece tek hamlede bu iki kişinin unvanlarını takas etmiş oldunuz. Gelin isterseniz değişkenlerinsondurumunabakalım: >>> osman ’Proje Sorumlusu >>> mehmet ’Araştırma Geliştirme Müdürü’ Gördüğünüzgibi,osmandeğişkeninindeğerinimehmet’e;mehmetdeğişkeninindeğeriniise osman’abaşarıylaverebilmişiz. Yukarıdaki yöntem Python’ın öteki diller üzerinde önemli bir üstünlüğüdür. Başka programlamadillerindebuişlemiyapmakiçingeçicibirdeğişkentanımlamanızgerekir.Yani mesela: >>> osman = "Araştırma Geliştirme Müdürü" >>> mehmet = "Proje Sorumlusu" 5.1. EtkileşimliKabuktaİlkAdımlar 53 PythonBelgeleri,Yayım4.1.3 Elimizdeki değerler bunlar. Biz şimdi Osman’ın değerini Mehmet’e; Mehmet’in değerini ise Osman’aaktaracağız.Bununiçinönceliklebirgeçicideğişkentanımlamalıyız: >>> geçici = "Proje Sorumlusu" Busayede“ProjeSorumlusu”değeriniyedeklemişolduk.Buişlemsayesinde,takassırasında budeğerikaybetmeyeceğiz. ŞimdiOsman’ındeğeriniMehmet’eaktaralım: >>> mehmet = osman ŞimdielimizdeikitaneAraştırmaGeliştirmeMüdürüolmuşoldu: >>> mehmet ’Araştırma Geliştirme Müdürü’ >>> osman ’Araştırma Geliştirme Müdürü’ Gördüğünüz gibi, mehmet = osman kodunu kullanarak mehmet değişkeninin değerini osman değişkeninin değeriyle değiştirdiğimiz için “Proje Sorumlusu” değeri ortadan kayboldu. Ama biz önceden bu değeri geçici adlı değişkene atadığımız için bu değeri kaybetmemiş olduk. ŞimdiOsman’ageçicideğişkeniiçindetuttuğumuz“ProjeSorumlusu”değeriniverebiliriz: >>> osman = geçici Böyleceistediğimiztakasişleminigerçekleştirmişolduk.Sondurumukontroledelim: >>> osman ’Proje Sorumlusu >>> mehmet ’Araştırma Geliştirme Müdürü’ Basitbirişlemiçinnekadarbüyükbirzamankaybı,değilmi?Amadediğimizgibi,Python’dabu şekildegeçicibirdeğişkenatamaklauğraşmamızahiçgerekyok.Sadeceşuformülükullanarak değişkenlerindeğerinitakasedebiliriz: a, b = b, a Bu şekilde a değişkeninin değerini b değişkenine; b değişkeninin değerini ise a değişkenine vermiş oluyoruz. Eğer bu işlemi geri alıp her şeyi eski haline döndürmek istersek, tahmin edebileceğinizgibiyineaynıyöntemdenyararlanabiliriz: b, a = a, b Böylece değişkenler konusunu da oldukça ayrıntılı bir şekilde incelemiş olduk. Ayrıca bu esnadalen()vepow()adlıikiyenifonksiyonile**adlıbirişleçdeöğrendik. 54 Bölüm5. EtkileşimliPython PythonBelgeleri,Yayım4.1.3 Hazırlafıgeçmişken,len()fonksiyonununbazıkısıtlamalarındansözedelim.Dediğimizgibi, bu fonksiyonu kullanarak karakter dizileri içinde toplam kaç adet karakter bulunduğunu hesaplayabiliyoruz.Örneğin: >>> kelime = "muvaffakiyet" >>> len(kelime) 12 Yalnızbulen()fonksiyonunusayılarınuzunluğunuölçmekiçinkullanamıyoruz: >>> len(123456) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: object of type ’int’ has no len() Gördüğünüz gibi, len() fonksiyonu, şu ana kadar öğrendiğimiz veri tipleri arasında yalnızca karakterdizileriilebirliktekullanılabiliyor.Bufonksiyonusayılarlabirliktekullanamıyoruz. Bu bölümün başında, o anda elimizde bulunan bir verinin tipini bilmemizin çok önemli olduğunu ve Python’da bir verinin tipinin, o veri ile neler yapıp neler yapamayacağınızı belirlediğini söylediğimizi hatırlıyorsunuz, değil mi? İşte len() fonksiyonu bu duruma çok güzelbirörnektir. len() fonksiyonu sayılarla birlikte kullanılamaz. Dolayısıyla eğer elinizdeki verinin bir sayı olduğunu bilmezseniz, bu sayıyı len() fonksiyonu ile birlikte kullanmaya çalışabilir ve bu şekildeprogramınızınhatavererekçökmesineyolaçabilirsiniz. Ayrıca daha önce de söylediğimiz gibi, len() fonksiyonunu doğru kullanabilmek için, bu fonksiyonunbizesayıdeğerlibirçıktıverdiğinidebilmemizgerekir. len() fonksiyonu ile ilgili bu durumu da bir kenara not ettikten sonra yolumuza kaldığımız yerdendevamedelim. 5.2 Etkileşimli Kabuğun Hafızası Bir önceki bölümde Python’ın etkileşimli kabuğunun nasıl kullanılacağına dair epey örnek verdikveetkileşimlikabuküzerindenPython’ınbazıtemelaraçlarınakısabirgirişyaptık.Şimdi isterseniz yeri gelmişken Python’ın etkileşimli kabuğunun bir başka yeteneğinden daha söz edelim. Etkileşimli kabukta _ adlı işaret (alt çizgi işareti), yapılan son işlemin veya girilen son öğenin değerinitutmaişlevigörür.Yani: >>> 2345 + 54355 56700 Eğerbuişleminardından_komutunuverirsekşöylebirçıktıalırız: 5.2. EtkileşimliKabuğunHafızası 55 PythonBelgeleri,Yayım4.1.3 >>> _ 56700 Gördüğünüz gibi, _ komutu son girilen öğeyi hafızasında tutuyor. Bu özellikten çeşitli şekillerdeyararlanabilirsiniz: >>> _ + 15 56715 Burada _ komutunun değeri bir önceki işlemin sonucu olan 56700 değeri olduğu için, _ komutuna 15 eklediğimizde 56715 değerini elde ediyoruz. _ komutunun değerini tekrar kontroledelim: >>> _ 56715 Gördüğünüzgibi,_komutunundeğeriartık56715sayısıdır... _komutuyalnızcasayılarıdeğil,karakterdizilerinidehafızasındatutabilir: >>> "www" ’www’ >>> _ ’www’ >>> _ + "..com" ’www..com’ Buişaretöyleçoksıkkullanılanbiraraçdeğildir,amazamanzamanişiniziepeykolaylaştırır. Yalnız, unutmamamız gereken şey, bu özelliğin sadece etkileşimli kabuk ortamında geçerli olmasıdır._komutununetkileşimlikabukortamıdışındaherhangibirgeçerliliğiyoktur. Aslında burada söylenecek daha çok şey var. Ama biz şimdilik bunları sonraki konulara bırakacağız. Zira bu bölümdeki amacımız size konuların her ayrıntısını vermekten ziyade, Python’aısınmanızısağlamaktır. 56 Bölüm5. EtkileşimliPython 6 BÖLÜM print() Fonksiyonu GeçenbölümdebiryandanPython’ınetkileşimlikabuğunuyakındantanıyıpbuvesileylebazı önemli fonksiyon ve araçları öğrenirken, öbür yandan bu öğrendiklerimizi kullanarak örnek programlaryazdık.Gördüğünüzgibi,azıcıkbirbilgiyledahiazçokişeyararprogramlaryazmak mümkünolabiliyor.Dahayararlıprogramlaryazabilmekiçinhenüzöğrenmemizgerekenpek çok şey var. İşte bu bölümde, ‘daha yararlı programlar yazmamızı’ sağlayacak çok önemli bir araçtan söz edeceğiz. Öneminden dolayı ayrıntılı bir şekilde anlatacağımız bu aracın adı print()fonksiyonu. Elbettebubölümdesadeceprint()fonksiyonundanbahsetmeyeceğiz.Bubölümdeprint() fonksiyonunun yanısıra Python’daki bazı önemli temel konuları da ele alacağız. Mesela bu bölümdePython’dakikarakterdizilerinevesayılarailişkinçokönemlibilgilervereceğiz.Ayrıca print() fonksiyonu vesilesiyle Python’daki ‘fonksiyon’ konusuna da sağlam bir giriş yapmış, bu kavram ile ilgili ilk bilgilerimizi almış olacağız. Sözün özü, bu bölüm bizim için, deyim yerindeyse,tamanlamıylabirdönümnoktasıolacak. O halde isterseniz lafı daha fazla uzatmadan işe print() fonksiyonunun ne olduğu ve ne işe yaradığınıanlatarakbaşlayalım. 6.1 Nedir, Ne İşe Yarar? Şimdiye kadar etkileşimli kabukta gerek karakter dizilerini gerekse sayıları doğrudan ekrana yazdık.Yanişöylebirşeyyaptık: >>> "Python programlama dili" ’Python programlama dili’ >>> 6567 6567 57 PythonBelgeleri,Yayım4.1.3 Etkileşimli kabuk da, ekrana yazdığımız bu karakter dizisi ve sayıyı doğrudan bize çıktı olarak verdi. Ancak ilerde Python kodlarımızı bir dosyaya kaydedip çalıştırdığımızda da göreceğiniz gibi, Python’ın ekrana çıktı verebilmesi için yukarıdaki kullanım yeterli değildir. Yani yukarıdaki kullanım yalnızca etkileşimli kabukta çalışır. Bu kodları bir dosyaya kaydedip çalıştırmak istediğimizde hiçbir çıktı alamayız. Python’da yazdığımız şeylerin ekrana çıktı olarakverilebilmesiiçinprint()adlıözelbirfonksiyondanyararlanmamızgerekir. O halde gelin bu print() fonksiyonunun ne işe yaradığını ve nasıl kullanıldığını anlamaya çalışalım: print() de tıpkı daha önce gördüğümüz type(), len() ve pow() gibi bir fonksiyondur. Fonksiyonları ilerde daha ayrıntılı bir şekilde inceleyeceğimizi söylemiştik hatırlarsanız. O yüzden fonksiyon kelimesine takılarak, burada anlattığımız şeylerin kafanızı karıştırmasına, moralinizibozmasınaizinvermeyin. print() fonksiyonunun görevi ekrana çıktı vermemizi sağlamaktır. Hemen bununla ilgili bir örnekverelim: >>> print("Python programlama dili") Python programlama dili Bildiğiniz gibi burada gördüğümüz “Python programlama dili” bir karakter dizisidir. İşte print() fonksiyonunun görevi bu karakter dizisini ekrana çıktı olarak vermektir. Peki bu karakter dizisini print() fonksiyonu olmadan yazdığımızda da ekrana çıktı vermiş olmuyor muyuz? Aslında olmuyoruz. Dediğimiz gibi, ilerde programlarımızı dosyalara kaydedip çalıştırdığımızda,başındaprint()olmayanifadelerinçıktıdagörünmediğineşahitolacaksınız. Daha önce de dediğimiz gibi, etkileşimli kabuk bir test ortamı olması açısından rahat bir ortamdır. Bu sebeple bu ortamda ekrana çıktı verebilmek için print() fonksiyonunu kullanmak zorunda değilsiniz. Yani başında print() olsa da olmasa da etkileşimli kabuk ekrana yazdırmak istediğiniz şeyi yazdırır. Ama iyi bir alışkanlık olması açısından, ekrana herhangibirşeyyazdıracağınızdabensizeprint()fonksiyonunukullanmanızıtavsiyeederim. print() son derece güçlü bir fonksiyondur. Gelin isterseniz bu güçlü ve faydalı fonksiyonu derinderinincelemeyekoyulalım. 6.2 Nasıl Kullanılır? Yukarıdaverdiğimizörnekteilkgözümüzeçarpanşey,karakterdizisiniprint()fonksiyonunun parantezleriiçineyazmışolmamızdır.Bizbirfonksiyonunparantezleriiçindebelirtilenöğelere ‘parametre’dendiğinigeçenbölümdeöğrenmiştik.Tıpkıöğrendiğimizötekifonksiyonlargibi, print()fonksiyonudabirtakımparametreleralır. Bu arada print() fonksiyonunun parantezini açıp parametreyi yazdıktan sonra, parantezi kapatmayı unutmuyoruz. Python programlama diline yeni başlayanların, hatta bazen deneyimli programcıların bile en sık yaptığı hatalardan biri açtıkları parantezi kapatmayı unutmalarıdır. Elbette, eğer istersek burada doğrudan “Python programlama dili” adlı karakter dizisini kullanmak yerine, önce bu karakter dizisini bir değişkene atayıp, sonra da print() fonksiyonununparantezleriiçindebudeğişkenikullanabiliriz.Yani: 58 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 >>> dil = "Python programlama dili" >>> print(dil) Python programlama dili Bu arada, hem şimdi verdiğimiz, hem de daha önce yazdığımız örneklerde bir şey dikkatinizi çekmiş olmalı. Şimdiye kadar verdiğimiz örneklerde karakter dizilerini hep çift tırnakla gösterdik.Amaaslındatekseçeneğimizçifttırnakdeğildir.Pythonbizeüçfarklıtırnakseçeneği sunar: 1. Tektırnak(’‘) 2. Çifttırnak(”“) 3. Üçtırnak(“””“””) Dolayısıylayukarıdakiörneğiüçfarklışekildeyazabiliriz: >>> print(’Python programlama dili’) Python programlama dili >>> print("Python programlama dili") Python programlama dili >>> print("""Python programlama dili""") Python programlama dili Gördüğünüzgibiçıktılararasındahiçbirfarkyok. Pekiçıktılardahiçbirfarkyoksanedenüçfarklıtırnakçeşidivar? İstersenizbusoruyubirörneküzerindenaçıklamayaçalışalım.Diyelimkiekranaşöylebirçıktı vermekistiyoruz: Python programlama dilinin adı "piton" yılanından gelmez Eğerbucümleyiçifttırnaklariçindegösterirsekprogramımızhataverecektir: >>> print("Python programlama dilinin adı "piton" yılanından gelmez") File "<stdin>", line 1 print("Python programlama dilinin adı "piton" yılanından gelmez") ^ SyntaxError: invalid syntax Bunun sebebi, cümle içinde geçen ‘piton’ kelimesinin de çift tırnaklar içinde gösterilmiş olmasıdır.Cümlenin,yanikarakterdizisininkendisideçifttırnakiçindegösterildiğiiçinPython, karakter dizisini başlatan ve bitiren tırnakların hangisi olduğunu ayırt edemiyor. Yukarıdaki cümleyienkolayşuşekildeekranayazdırabiliriz: 6.2. NasılKullanılır? 59 PythonBelgeleri,Yayım4.1.3 >>> print(’Python programlama dilinin adı "piton" yılanından gelmez’) Python programlama dilinin adı "piton" yılanından gelmez Burada karakter dizisini tek tırnak içine aldık. Karakter dizisi içinde geçen ‘piton’ kelimesi çifttırnakiçindeolduğuiçin,karakterdizisinibaşlatıpbitirentırnaklarla‘piton’kelimesindeki tırnaklarınbirbirinekarışmasıgibibirdurumsözkonusudeğildir. Birdeşöylebirörnekverelim:Diyelimkiaşağıdakigibibirçıktıeldeetmekistiyoruz: İstanbul’un 5 günlük hava durumu tahmini Eğer bu karakter dizisini tek tırnak işaretleri içinde belirtirseniz Python size bir hata mesajı gösterecektir: >>> print(’İstanbul’un 5 günlük hava durumu tahmini’) File "<stdin>", line 1 print(’İstanbul’un 5 günlük hava durumu tahmini’) ^ SyntaxError: invalid syntax Bu hatanın sebebi ‘İstanbul’un’ kelimesi içinde geçen kesme işaretidir. Tıpkı bir önceki örnekte olduğu gibi, Python karakter dizisini başlatan ve bitiren tırnakların hangisi olduğunukestiremiyor.Python,karakterdizisininenbaşındakitektırnakişaretininardından ‘İstanbul’un’kelimesiiçindekikesmeişaretinigörüncekarakterdizisininburadasonaerdiğini zannediyor. Ancak karakter dizisini soldan sağa doğru okumaya devam edince bir yerlerde bir terslik olduğunu düşünüyor ve bize bir hata mesajı göstermekten başka çaresi kalmıyor. Yukarıdakikarakterdizisinienkolayşöyletanımlayabiliriz: >>> print("İstanbul’un 5 günlük hava durumu tahmini") İstanbul’un 5 günlük hava durumu tahmini Burada da, karakter dizisi içinde geçen kesme işaretine takılmamak için karakter dizimizi çift tırnakişaretleriiçinealıyoruz. Yukarıdaki karakter dizilerini düzgün bir şekilde çıktı verebilmek için üç tırnak işaretlerinden deyararlanabiliriz: >>> print("""Python programlama dilinin adı "piton" yılanından gelmez""") Python programlama dilinin adı "piton" yılanından gelmez >>> print("""İstanbul’un 5 günlük hava durumu tahmini""") İstanbul’un 5 günlük hava durumu tahmini Bütünbuörneklerdensonrakafanızdaşöylebirdüşünceuyanmışolabilir: Görünüşe göre üç tırnak işaretiyle her türlü karakter dizisini hatasız bir şekilde ekrana çıktı olarak verebiliyoruz. O zaman ben en iyisi bütün karakter dizileri için üçtırnakişaretinikullanayım! 60 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 Elbette, eğer isterseniz pek çok karakter dizisi için üç tırnak işaretini kullanabilirsiniz. Ancak Python’dakarakter dizileri tanımlanırkengenellikle tektırnak veyaçift tırnak işaretleri kullanılır. Üç tırnak işaretlerinin asıl kullanım yeri ise farklıdır. Peki nedir bu üç tırnak işaretlerininasılkullanımyeri? Üç tırnak işaretlerini her türlü karakter dizisiyle birlikte kullanabiliyor olsak da, bu tırnak tipi çoğunlukla sadece birden fazla satıra yayılmış karakter dizilerini tanımlamada kullanılır. Örneğinşöylebirekrançıktısıvermekistediğinizidüşünün: [H]=========HARMAN========[-][o][x] | | | Programa Hoşgeldiniz! | | Sürüm 0.8 | | Devam etmek için herhangi | | bir düğmeye basın. | | | |=================================| Böyle bir çıktı verebilmek için eğer tek veya çift tırnak kullanmaya kalkışırsanız epey eziyet çekersiniz.Butürbirçıktıvermeninenkolayyoluüçtırnaklarıkullanmaktır: >>> print(""" ... [H]=========HARMAN========[-][o][x] ... | | ... | Programa Hoşgeldiniz! | ... | Sürüm 0.8 | ... | Devam etmek için herhangi | ... | bir düğmeye basın. | ... | | ... |=================================| ... """) Burada bazı şeyler dikkatinizi çekmiş olmalı. Gördüğünüz gibi, üç tırnaklı yapı öteki tırnak tiplerinegörebirazfarklıdavranıyor.Şimdişuörneğebakın: >>> print("""Game Over! ... Buraya çok dikkatli bakın. Karakter dizisine üç tırnakla başladıktan sonra, kapanış tırnağını koymadanEntertuşunabastığımızda>>>işareti... işaretinedönüştü.Pythonbuşekildebize, ‘yazmayadevamet!’demişoluyor.Bizdebunauyarakyazmayadevamedelim: >>> print("""Game Over! ... Insert Coin!""") Game Over! Insert Coin! KapanıştırnağıkoyulmadanEntertuşunabasıldığında>>>işaretinin... işaretinedönüşmesi üç tırnağa özgü bir durumdur. Eğer aynı şeyi tek veya çift tırnaklarla yapmaya çalışırsanız programınızhataverir: 6.2. NasılKullanılır? 61 PythonBelgeleri,Yayım4.1.3 >>> print("Game Over! File "<stdin>", line 1 print("Game Over! ^ SyntaxError: EOL while scanning string literal ...veya: >>> print(’Game Over! File "<stdin>", line 1 print("Game Over! ^ SyntaxError: EOL while scanning string literal Üç tırnak işaretlerinin tırnak kapanmadan Enter tuşuna basıldığında hata vermeme özelliği sayesinde, bu tırnak tipi özellikle birden fazla satıra yayılmış karakter dizilerinin gösterilmesi içinbirebirdir. Gelinistersenizüçtırnakkullanımınailişkinbirörnekdahaverelim: >>> print("""Python programlama dili Guido Van Rossum ... adlı Hollandalı bir programcı tarafından 90’lı ... yılların başında geliştirilmeye başlanmıştır. Çoğu ... insan, isminin "Python" olmasına bakarak, bu programlama ... dilinin, adını piton yılanından aldığını düşünür. ... Ancak zannedildiğinin aksine bu programlama dilinin ... adı piton yılanından gelmez.""") Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin "Python" olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin dı piton yılanından gelmez. Elbetteeğeristersekbumetniöncebirdeğişkeneatamayıdatercihedebiliriz: >>> python_hakkinda = """Python programlama dili Guido Van Rossum ... adlı Hollandalı bir programcı tarafından 90’lı ... yılların başında geliştirilmeye başlanmıştır. Çoğu ... insan, isminin "Python" olmasına bakarak, bu programlama ... dilinin, adını piton yılanından aldığını düşünür. ... Ancak zannedildiğinin aksine bu programlama dilinin ... adı piton yılanından gelmez.""" >>> print(python_hakkinda) Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı (sonrakisayfayadevam) 62 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin "Python" olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Siz yukarıdaki çıktıyı tek veya çift tırnak kullanarak nasıl ekrana yazdırabileceğinizi düşünedurun,bizönemlibirkonuyageçişyapalım! 6.3 Bir Fonksiyon Olarak print() print() ifadesinin bir fonksiyon olduğunu söylemiştik hatırlarsanız. Dediğimiz gibi, fonksiyonlarlailgiliayrıntılıaçıklamalarıilerleyenderslerdevereceğiz.Ancakşimdidilerseniz bundan sonra anlatacaklarımızı daha iyi kavrayabilmemiz için, fonksiyonlar hakkında bilmemizgerekenbazıtemelşeyleriöğrenmeyeçalışalım. Gördüğünüzgibi,print()fonksiyonunuşöylekullanıyoruz: >>> print("Aramak istediğiniz kelimeyi yazın: ") Burada print() bir fonksiyon, “Aramak istediğiniz kelimeyi yazın:” adlı karakter dizisi ise bu fonksiyonun parametresidir. Daha önce len() adlı başka bir fonksiyon daha öğrenmiştik hatırlarsanız.Onudaşöylekullanıyorduk: >>> len("elma") Buradadalen()birfonksiyon,“elma”adlıkarakterdizisiisebufonksiyonunparametresidir. Aslında biçim olarak print() ve len() fonksiyonlarının birbirinden hiçbir farkı olmadığını görüyorsunuz. Daha önce söylediğimiz ve bu örneklerden de anladığımız gibi, bir fonksiyonun parantezleri içinde belirtilen öğelere parametre adı veriliyor. Mesela aşağıdaki örnekte print() fonksiyonunutekbirparametreilekullanıyoruz: >>> print(’En az 8 haneli bir parola belirleyin.’) print()fonksiyonu,tıpkıpow()fonksiyonugibi,birdenfazlaparametrealabilir: >>> print(’Fırat’, ’Özgül’) Fırat Özgül Bu örnekte bizim için çıkarılacak çok dersler var. Bir defa burada print() fonksiyonunu iki farklı parametre ile birlikte kullandık. Bunlardan ilki Fırat adlı bir karakter dizisi, ikincisi ise Özgüladlıbaşkabirkarakterdizisi.Python’ınbuikikarakterdizisininasılbirleştirdiğinedikkat edin.print()fonksiyonubuikikarakterdizisiniçıktıolarakverirkenaralarınadabirerboşluk yerleştirdi. Ayrıca, geçen derste de vurguladığımız gibi, parametrelerin birbirinden virgül ile ayrıldığınıdagözdenkaçırmıyoruz. Gelinbununlailgilibirikiörnekdahaverelimelimizinalışmasıiçin: 6.3. BirFonksiyonOlarakprint() 63 PythonBelgeleri,Yayım4.1.3 >>> print("Python", "Programlama", "Dili") Python Programlama Dili >>> print(’Fırat’, ’Özgül’, ’Adana’, 1980) Fırat Özgül Adana 1980 Bu arada dikkatinizi önemli bir noktaya çekmek istiyorum. Yukarıdaki örneklerde bazen tek tırnak, bazen de çift tırnak kullandık. Daha önce de söylediğimiz gibi, hangi tırnak tipini kullandığımız önemli değildir. Python hangi tırnak tipini kullandığımızdan ziyade, tırnak kullanımındatutarlıolupolmadığımızlailgilenir.YaniPythoniçinönemliolan,karakterdizisini hangitırnaklabaşlatmışsak,otırnaklabitirmemizdir.Yanişutipkullanımlargeçerlideğildir: >>> print("karakter dizisi’) >>> print(’karakter dizisi") Karakter dizisini tanımlamaya başlarken kullandığımız tırnak tipi ile karakter dizisini tanımlamayı bitirirken kullandığımız tırnak tipi birbirinden farklı olduğu için bu iki kullanım dahataverecektir. 6.4 print() Fonksiyonunun Parametreleri Şimdiye kadar verdiğimiz örneklerde belki çok da belli olmuyordur, ama aslında print() fonksiyonu son derece güçlü bir araçtır. İşte şimdi biz bu fonksiyonun gücünü gözler önüne seren özelliklerini incelemeye başlayacağız. Bu bölümü dikkatle takip etmeniz, ilerde yapacağımızçalışmalarıdaharahatanlayabilmenizaçısındanbüyükönemtaşır. 6.4.1 sep print() fonksiyonu ile ilgili olarak yukarıda verdiğimiz örnekleri incelediğimizde, bu fonksiyonunkendineözgübirdavranışşekliolduğunugörüyoruz.Meselabiröncekibölümde verdiğimizşuörneğebakalım: >>> print(’Fırat’, ’Özgül’) Fırat Özgül Burada print() fonksiyonunu iki farklı parametre ile birlikte kullandık. Bu fonksiyon, kendisine verdiğimiz bu parametreleri belli bir düzene göre birbiriyle birleştirdi. Bu düzen gereğince print(), kendisine verilen parametreleri birleştirirken, parametreler arasına bir boşlukyerleştiriyor.Bunudahanetgörmekiçinşöylebirörnekdahaverelim: >>> print("Python", "PHP", "C++", "C", "Erlang") Python PHP C++ C Erlang Gördüğünüz gibi, print() fonksiyonu gerçekten de, kendisine verilen parametreleri birleştirirken,parametrelerinherbiriarasınabirboşlukyerleştiriyor.Halbukibuboşluğubiz 64 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 talepetmedik!Pythonbizebuboşluğueşantiyonolarakverdi.Çoğudurumdaistediğimizşey buolacaktır,amabazıdurumlardabuboşluğuistemeyebiliriz.Örneğin: >>> print("http://", "www.", ".", "com") http:// www. . com Yadaboşlukkarakteriyerinedahafarklıbirkarakterkullanmakistiyordaolabiliriz.Pekiböyle birdurumdaneyapmamızgerekir? İştebunoktadabazıözelaraçlardanyararlanarakprint()fonksiyonununöntanımlıdavranış kalıplarıüzerindedeğişiklikleryapabiliriz. Pekinedirprint()fonksiyonunuözelleştirmemizisağlayacakbuaraçlar? Hatırlarsanız, Python’da fonksiyonların parantezleri içindeki değerlere parametre adı verildiğinisöylemiştik.Meselaprint()fonksiyonunubiryadadahafazlaparametreilebirlikte kullanabileceğimizibiliyoruz: >>> print("Mehmet", "Öz", "İstanbul", "Çamlıca", 156, "/", 45) Mehmet Öz İstanbul Çamlıca 156 / 45 print() fonksiyonu içinde istediğimiz sayıda karakter dizisi ve/veya sayı değerli parametre kullanabiliriz. Fonksiyonların bir de daha özel görünümlü parametreleri vardır. Mesela print() fonksiyonunun sep adlı özel bir parametresi bulunur. Bu parametre print() fonksiyonunda görünmesebileherzamanoradadır.Yanidiyelimkişöylebirkodyazdık: >>> print("http://", "www.", "google.", "com") Burada herhangi bir sep parametresi görmüyoruz. Ancak Python yukarıdaki kodu aslında şöylealgılar: >>> print("http://", "www.", "google.", "com", sep=" ") sepifadesi,İngilizcedeseparator(ayırıcı,ayraç)kelimesininkısaltmasıdır.Dolayısıylaprint() fonksiyonundaki bu sep parametresi, ekrana basılacak öğeler arasına hangi karakterin yerleştirileceğini gösterir. Bu parametrenin öntanımlı değeri bir adet boşluk karakteridir (” “). Yani siz bu özel parametrenin değerini başka bir şeyle değiştirmezseniz, Python bu parametrenin değerini bir adet boşluk karakteri olarak alacak ve ekrana basılacak öğeleri birbirindenbirerboşluklaayıracaktır.Ancakeğerbizistersekbusepparametresinindeğerini değiştirebiliriz. Böylece Python, karakter dizilerini birleştirirken araya boşluk değil, bizim istediğimiz başka bir karakteri yerleştirebilir. Gelin şimdi bu parametrenin değerini nasıl değiştireceğimizigörelim: >>> print("http://", "www.", ".", "com", sep="") http://www..com Gördüğünüzgibi,karakterdizilerinibaşarıylabirleştirip,geçerlibirinternetadresieldeettik. Buradayaptığımızşeyaslındaçokbasit.Sadecesepparametresinin‘biradetboşlukkarakteri’ olan öntanımlı değerini silip, yerine ‘boş bir karakter dizisi’ değerini yazdık. Bu iki kavramın 6.4. print()FonksiyonununParametreleri 65 PythonBelgeleri,Yayım4.1.3 birbirindenfarklıolduğunusöylediğimizihatırlıyorsunuz,değilmi? Gelinbirörnekdahayapalım: >>> print("T", "C", sep=".") T.C BuradaPython’aşöylebiremirvermişolduk: “T” ve “C” karakter dizilerini birbiriyle birleştir! Bunu yaparken de bu karakter dizilerininarasınanoktaişaretiyerleştir! sep parametresinin öteki parametrelerden farkı her zaman ismiyle birlikte kullanılmasıdır. Zatenteknikolarakdabutürparametrelere‘isimliparametreler’adıverilir.Örneğin: >>> print("Adana", "Mersin", sep="-") Adana-Mersin Eğer burada sep parametresinin ismini belirtmeden, doğrudan parametrenin değerini yazarsak,budeğerinötekiparametrelerdenhiçbirfarkıkalmayacaktır: >>> print("Adana", "Mersin", "-") Adana Mersin - Gelinistersenizbuparametreyleilgilibirörnekdahayapalım: ‘Bir mumdur iki mumdur...’ diye başlayan türküyü biliyorsunuzdur. Şimdi bu türküyü Python’lanasılyazabileceğimizigörelim! >>> print("bir", "iki", "üç", "dört", "on dört", sep="mumdur") birmumdurikimumdurüçmumdurdörtmumduron dört Burada bir terslik olduğu açık! Karakter dizileri birbirlerine sıkışık düzende birleştirildi. Bunların arasında birer boşluk olsa tabii daha iyi olurdu. Ancak biliyorsunuz sep parametresinin öntanımlı değerini silip, yerine “mumdur” değerini yerleştirdiğimiz için, Python’ınotomatikolarakyerleştirdiğiboşlukkarakterikayboldu.Amaeğeristersekoboşluk karakterlerinikendimizdeayarlayabiliriz: >>> print("bir", "iki", "üç", "dört", "on dört", sep=" mumdur ") bir mumdur iki mumdur üç mumdur dört mumdur on dört Gördüğünüz gibi, sep parametresine verdiğimiz “mumdur” değerinin sağında ve solunda birerboşlukbırakaraksorunumuzuçözebildik.Busorunuçözmeninbaşkabiryoludahavar. Hatırlarsanızetkileşimlikabuktailkörneklerimiziverirkenkarakterdizilerinibirleştirmekiçin + işaretinden de yararlanabileceğimizi söylemiştik. Dolayısıyla sep parametresini şöyle de yazabiliriz: >>> print("bir", "iki", "üç", "dört", "on dört", sep=" " + "mumdur" + " ") 66 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 Buradada,“mumdur”adlıkarakterdizisininbaşındavesonundabirerboşlukbırakmakyerine, gerekliboşlukları+işaretiyardımıylabukarakterdizisinebirleştirdik.Hattaistersek+işlecini kullanmakzorundaolmadığımızıdahibiliyorsunuz: >>> print("bir", "iki", "üç", "dört", "on dört", sep=" " "mumdur" " ") Amagördüğünüzgibibirproblemimizdahavar.Türkününsözlerişuşekildeolmalıydı: birmumdurikimumdurüçmumdurdörtmumdurondörtmumdur Ama sondaki ‘mumdur’ kelimesi yukarıdaki çıktıda yok. Normal olan da bu aslında. sep parametresi,karakterdizilerininarasınabirdeğeryerleştirir.Karakterdizilerininsontarafıyla ilgilenmez.Buişiçinprint()fonksiyonubaşkabirparametreyesahiptir. Bu arada, yukarıdaki örneklerde hep karakter dizilerini kullanmış olmamız sizi yanıltmasın. sep parametresi yalnızca karakter dizilerinin değil sayıların arasına da istediğiniz bir değerin yerleştirilmesinisağlayabilir.Mesela: >>> print(1, 2, 3, 4, 5, sep="-") 1-2-3-4-5 AncaksepparametresinedeğerolarakyalnızcakarakterdizileriniveNoneadlıözelbirsözcüğü verebiliriz.(Nonesözcüğündenileridesözedeceğiz): >>> print(1, 2, 3, 4, 5, sep=0) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: sep must be None or a string, not int Gördüğünüzgibi,sepparametresinebirsayıolan0değeriniveremiyoruz. PekibuparametreyeNonedeğeriverirsekneolur?BuparametreyeNonedeğeriverildiğinde, print()fonksiyonubuparametreiçinöntanımlıdeğeri(yanibiradetboşluk)kullanır: >>> print(’a’, ’b’, sep=None) a b Eğeramacınızparametreleribirbirinebitiştirmekse,yanisepparametresininöntanımlıdeğeri olan boşluk karakterini ortadan kaldırmaksa, sep parametresine boş bir karakter dizisi vermenizgerektiğinibiliyorsunuz: >>> print(’a’, ’b’, sep=’’) ab print() fonksiyonunun sep parametresini bütün ayrıntılarıyla incelediğimize göre, bu fonksiyonunbirbaşkaözelparametresindensözedebiliriz. 6.4. print()FonksiyonununParametreleri 67 PythonBelgeleri,Yayım4.1.3 6.4.2 end Biröncekibölümdeşöylebirlafetmiştik: print()fonksiyonunsepadlıözelbirparametresibulunur.Buparametreprint() fonksiyonundagörünmesebileherzamanoradadır. Aynı bu şekilde, print() fonksiyonunun end adlı özel bir parametresi daha bulunur. Tıpkı sepparametresigibi,endparametresideprint()fonksiyonundagörünmesebileherzaman oradadır. Bildiğiniz gibi, sep parametresi print() fonksiyonuna verilen parametreler birleştirilirken arayahangikarakteringireceğinibelirliyordu.endparametresiisebuparametrelerinsonuna neyingeleceğinibelirler. print() fonksiyonu öntanımlı olarak, parametrelerin sonuna ‘satır başı karakteri’ ekler. Peki busatırbaşıkarakteri(veya‘yenisatırkarakteri’)denenşeydeneoluyor? Dilersenizbunubirörneküzerindegörelim. Şöylebirkodumuzolsun: >>> print("Pardus ve Ubuntu birer GNU/Linux dağıtımıdır.") BukoduyazıpEntertuşunabastığımızandaprint()fonksiyonuikifarklıişlemgerçekleştirir: 1. Önceliklekarakterdizisiniekranayazdırır. 2. Ardındanbiraltsatırageçipbize>>>işaretinigösterir. İşte bu ikinci işlem, karakter dizisinin sonunda bir adet satır başı karakteri olmasından, daha doğrusu print() fonksiyonunun, satır başı karakterini karakter dizisinin sonuna eklemesindenkaynaklanır.Buaçıklamabirazkafakarıştırıcıgelmişolabilir.Ohaldebirazdaha açıklayalım.Şuörneğebakın: >>> print("Pardus\nUbuntu") Pardus Ubuntu Burada “Pardus” ve “Ubuntu” karakter dizilerinin tam ortasında çok özel bir karakter dizisi daha görüyorsunuz. Bu karakter dizisi şudur: \n. İşte bu özel karakter dizisine satır başı karakteri (newline) adı verilir. Bu karakterin görevi, karakter dizisini, bulunduğu noktadan bölüp, karakter dizisinin geri kalanını bir alt satıra geçirmektir. Zaten çıktıda da bu işlevi yerinegetirdiğinigörüyorsunuz.Karakterdizisi“Pardus”kısmındansonraikiyebölünüyorve bu karakter dizisinin geri kalan kısmı olan “Ubuntu” karakter dizisi bir alt satıra yazdırılıyor. Bunudahaiyianlamakiçinbirörnekdahaverelim: >>> print("birinci satır\nikinci satır\nüçüncü satır") birinci satır ikinci satır üçüncü satır Pekisizebirsorusorayım:Acabayukarıdakikodlarıdahaverimlibirşekildenasılyazabiliriz? Evet,doğrutahminettiniz... Tabiikisepparametresinikullanarak: 68 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 >>> print("birinci satır", "ikinci satır", "üçüncü satır", sep="\n") birinci satır ikinci satır üçüncü satır Burada yaptığımız şey çok basit. sep parametresinin değerini \n, yani yeni satır karakteri (veyasatırbaşıkarakteri)olarakdeğiştirdik.Böylecekarakterdizileriarasınabirer\nkarakteri yerleştirerekherbirkarakterdizisininfarklısatırayazdırılmasınısağladık. İşte end parametresinin öntanımlı değeri de bu \n karakteridir ve bu parametre print() fonksiyonundagörünmesebileherzamanoradadır. Yanidiyelimkişöylebirkodyazdık: >>> print("Bugün günlerden Salı") Burada herhangi bir end parametresi görmüyoruz. Ancak Python yukarıdaki kodu aslında şöylealgılar: >>> print("Bugün günlerden Salı", end="\n") Birazöncededediğimizgibi,bukoduyazıpEntertuşunabastığımızandaprint()fonksiyonu ikifarklıişlemgerçekleştirir: 1. Önceliklekarakterdizisiniekranayazdırır. 2. Ardındanbiraltsatırageçipbize>>>işaretinigösterir. Bunun ne demek olduğunu anlamak için end parametresinin değerini değiştirmemiz yeterli olacaktır: >>> print("Bugün günlerden Salı", end=".") Bugün günlerden Salı.>>> Gördüğünüzgibi,endparametresininöntanımlıdeğeriolan\nkarakterinisilipyerine.(nokta) işareti koyduğumuz için, komutu yazıp Enter tuşuna bastığımızda print() fonksiyonu satır başına geçmedi. Yeni satıra geçebilmek için Enter tuşuna kendimiz basmalıyız. Elbette, eğer yukarıdakikodlarışöyleyazarsanız,print()fonksiyonuhemkarakterdizisininsonunanokta ekleyecek,hemdesatırbaşınageçecektir: >>> print("Bugün günlerden Salı", end=".\n") Bugün günlerden Salı. Şimdibuöğrendiklerimizitürkümüzeuygulayalım: >>> print("bir", "iki", "üç", "dört", "on dört", ... sep=" mumdur ", end=" mumdur\n") (cid:242) Not 6.4. print()FonksiyonununParametreleri 69 PythonBelgeleri,Yayım4.1.3 Burada kodlarımızın sağa doğru çirkin bir şekilde uzamasını engellemek için “on dört” karakter dizisini yazıp virgülü koyduktan sonra Enter tuşuna basarak bir alt satıra geçtik. Bir alt satıra geçtiğimizde >>> işaretinin ... işaretine dönüştüğüne dikkat edin. Python’da doğru kod yazmak kadar, yazdığımız kodların düzgün görünmesi de önemlidir. O yüzden yazdığımızherbirkodsatırınınmümkünolduğunca79karakterigeçmemesinisağlamalıyız. Eğeryazdığınızbirsatır79karakteriaşıyorsa,aşankısmıyukarıdagösterdiğimizşekildealt satıraalabilirsiniz. end parametresi de, tıpkı sep parametresi gibi, her zaman ismiyle birlikte kullanılması gereken bir parametredir. Yani eğer end parametresinin ismini belirtmeden sadece değerini kullanmayaçalışırsakPythonneyapmayaçalıştığımızıanlayamaz. Yine tıpkı sep parametresi gibi, end parametresinin değeri de sadece bir karakter dizisi veya Noneolabilir: >>> print(1, 2, 3, 4, 5, end=0) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: end must be None or a string, not int Gördüğünüzgibi,endparametresinebirsayıolan0değeriniveremiyoruz. Eğer bu parametreye None değeri verirsek, tıpkı sep parametresinde olduğu gibi, print() fonksiyonubuparametreiçinöntanımlıdeğeri(yanisatırbaşıkarakteri)kullanır: >>> print(’a’, ’b’, end=None) a b Eğer amacınız yeni satıra geçilmesini engellemekse, yani end parametresinin öntanımlı değeri olan \n kaçış dizisini ortadan kaldırmaksa, end parametresine boş bir karakter dizisi vermelisiniz: >>> print(’a’, ’b’, end=’’) a b>>> 6.4.3 file (cid:242) Not Buradahenüzöğrenmediğimizbazışeylergöreceksiniz.Hiçendişeetmeyin.Bunlarıilerde bütün ayrıntılarıyla öğreneceğiz. Şimdilik konu hakkında biraz olsun fikir sahibi olmanızı sağlayabilirsekkendimizibaşarılısayacağız. print() fonksiyonunun sep ve end dışında üçüncü bir özel parametresi daha bulunur. Bu parametrenin adı file’dır. Görevi ise, print() fonksiyonuna verilen karakter dizisi ve/veya sayıların,yaniparametrelerinnereyeyazılacağınıbelirtmektir. 70 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 Bu parametrenin öntanımlı değeri sys.stdout’tur. Peki bu ne anlama geliyor? sys.stdout, ‘standartçıktıkonumu’anlamınagelir.Peki‘standartçıktıkonumu’nedemek? Standartçıktıkonumu;birprogramın,ürettiğiçıktılarıverdiğiyerdir.Aslındabukavramınne demekolduğuadındandaanlaşılıyor: standartçıktıkonumu=çıktılarınstandartolarakverildiğikonum. MeselaPythonöntanımlıolarak,ürettiğiçıktılarıekranaverir.Eğeroandaetkileşimlikabukta çalışıyorsanız, Python ürettiği çıktıları etkileşimli kabuk üzerinde gösterir. Eğer yazdığınız bir programı komut satırında çalıştırıyorsanız, üretilen çıktılar komut satırında görünür. Dolayısıyla Python’ın standart çıktı konumu etkileşimli kabuk veya komut satırıdır. Yani print() fonksiyonu yardımıyla bastığınız çıktılar etkileşimli kabukta ya da komut satırında görünecektir. Şimdibukonuyudahaiyianlayabilmekiçinbirkaçörnekyapalım. Normalşartlaraltındaprint()fonksiyonununçıktısınıetkileşimlikabuktagörürüz: >>> print("Ben Python, Monty Python!") Ben Python, Monty Python! Ama eğer istersek print() fonksiyonunun, çıktılarını ekrana değil, bir dosyaya yazdırmasını da sağlayabiliriz. Mesela biz şimdi print() fonksiyonunun deneme.txt adlı bir dosyaya çıktı vermesinisağlayalım. Bununiçinsırasıylaşukodlarıyazalım: >>> dosya = open("deneme.txt", "w") >>> print("Ben Python, Monty Python!", file=dosya) >>> dosya.close() Herhangi bir çıktı almadınız, değil mi? Evet. Çünkü yazdığımız bu kodlar sayesinde print() fonksiyonu,çıktılarınıdeneme.txtadlıbirdosyayayazdırdı. Gelinistersenizyukarıdakikodlarısatırsatırinceleyelim: 1. Öncelikle deneme.txt adlı bir dosya oluşturduk ve bu dosyayı dosya adlı bir değişkene atadık. Burada kullandığımız open() fonksiyonuna çok takılmayın. Bunu birkaç bölüm sonra inceleyeceğiz. Biz şimdilik bu şekilde dosya oluşturulduğunu bilelim yeter. Bu arada open fonksiyonunun da biçim olarak type(), len(), pow() ve print() fonksiyonlarına ne kadar benzediğine dikkat edin. Gördüğünüz gibi open() fonksiyonu da tıpkı type(), len(), pow() ve print() fonksiyonları gibi birtakım parametreler alıyor. Bu fonksiyonun ilk parametresi “deneme.txt” adlı bir karakter dizisi. İşte bu karakter dizisi bizim oluşturmak istediğimiz dosyanın adını gösteriyor. İkinci parametre ise “w” adlı başka bir karakter dizisi. Bu da deneme.txt dosyasının yazma kipinde (modunda) açılacağını gösteriyor. Ama dediğim gibi, siz şimdilik bu ayrıntılara fazla takılmayın. İlerleyen derslerde, bu konuları adınızı bilir gibi bileceğinizdeneminolabilirsiniz. 2.Oluşturduğumuzbudeneme.txtadlıdosya,oandabulunduğunuzdiziniçindeoluşacaktır. Budizininhangisiolduğunuöğrenmekiçinşukomutlarıverebilirsiniz: >>> import os >>> os.getcwd() 6.4. print()FonksiyonununParametreleri 71 PythonBelgeleri,Yayım4.1.3 Bu komutun çıktısında hangi dizinin adı görünüyorsa, deneme.txt dosyası da o dizinin içindedir. Mesela bendeki çıktı /home//Desktop. Demek ki oluşturduğum deneme.txt adlı dosya masaüstündeymiş. Ben bu komutları Ubuntu üzerinde verdim. Eğer Windows üzerindeverseydimşunabenzerbirçıktıalacaktım:C:\Users\\Desktop 3.Ardındandanormalbirşekildeprint()fonksiyonumuzuçalıştırdık.Amagördüğünüzgibi print() fonksiyonu bize herhangi bir çıktı vermedi. Çünkü, daha önce de söylediğimiz gibi, print()fonksiyonunubizekranadeğil,dosyayaçıktıverecekşekildeayarladık.Buişlemi,file adlıbirparametreye,birazöncetanımladığımızdosyadeğişkeniniyazarakyaptık. 4. Son komut yardımıyla da, yaptığımız değişikliklerin dosyada görünebilmesi için ilk başta açtığımızdosyayıkapatıyoruz. Şimdi deneme.txt adlı dosyayı açın. Biraz önce print() fonksiyonuyla yazdırdığımız “Ben Python,MontyPython!”karakterdizisinindosyayaişlenmişolduğunugöreceksiniz. Böylece print() fonksiyonunun standart çıktı konumunu değiştirmiş olduk. Yani print() fonksiyonunun file adlı parametresine farklı bir değer vererek, print() fonksiyonunun etkileşimlikabuğadeğildosyayayazmasınısağladık. Tıpkısepveendparametrelerigibi,fileparametreside,sizgörmesenizbileherzamanprint() fonksiyonununiçindevardır.Yanidiyelimkişöylebirkomutverdik: >>> print("Tahir olmak da ayıp değil", "Zühre olmak da") Pythonbukomutuşöylealgılar: >>> print("Tahir olmak da ayıp değil", "Zühre olmak da", ... sep=" ", end="\n", file=sys.stdout) Yani kendisine parametre olarak verilen değerleri ekrana yazdırırken sırasıyla şu işlemleri gerçekleştirir: 1. Parametrelerinarasınabirerboşlukkoyar(sep=" "), 2. Ekranayazdırmaişlemibittiktensonraparametrelerinsonunasatırbaşıkarakteriekler (end="\n") 3. Buçıktıyıstandartçıktıkonumunagönderir(file=sys.stdout). İşte biz burada file parametresinin değeri olan standart çıktı konumuna başka bir değer vererekbukonumudeğiştiriyoruz. Gelin isterseniz bununla ilgili bir örnek daha yapalım. Mesela kişisel bilgilerimizi bir dosyaya kaydedelim.Önceliklebilgilerikaydedeceğimizdosyayıoluşturalım: >>> f = open("kişisel_bilgiler.txt", "w") Bukodlarla,kişisel_bilgiler.txtadınıtaşıyanbirdosyayıyazmakipinde(w)açmışvebudosyayı f adlıbirdeğişkeneatamışolduk.Şimdibilgileriyazmayabaşlayabiliriz: >>> print("Fırat Özgül", file=f) >>> print("Adana", file=f) >>> print("Ubuntu", file=f) İşimiz bittiğinde dosyayı kapatmayı unutmuyoruz. Böylece bütün bilgiler dosyaya yazılmış oluyor: 72 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 >>> f.close() Oluşturduğumuzkişisel_bilgiler.txtadlıdosyayıaçtığımızda,print()fonksiyonunaverdiğimiz parametrelerindosyayayazdırıldığınıgörüyoruz. Enbaştadasöylediğimgibi,bubölümdehenüzöğrenmediğimizbazışeylerlekarşılaştık.Eğer yukarıda verilen örnekleri anlamakta zorlandıysanız hiç endişe etmenize gerek yok. Birkaç bölümsonraburadaanlattığımızşeylersizeçocukoyuncağıgibigelecek... 6.4.4 flush Şimdiye kadar print() fonksiyonunun sep, end ve file adlı özel birtakım parametreleri olduğunuöğrendik.print()fonksiyonununbunlarındışındabaşkabirözelparametresidaha bulunur. Bu parametrenin adı flush. İşte şimdi biz print() fonksiyonunun bu flush adlı parametresindensözedeceğiz. Bildiğiniz gibi, print() gibi bir komut verdiğimizde Python, yazdırmak istediğimiz bilgiyi standart çıktı konumuna gönderir. Ancak Python’da bazı işlemler standart çıktı konumuna gönderilmedenöncebirsüretampondabekletilirvedahasonrabekleyenbuişlemlertopluca standart çıktı konumuna gönderilir. Peki ilk başta çok karmaşıkmış gibi görünen bu ifade ne anlamageliyor? Aslındasizbuolguyahiçyabancıdeğilsiniz.fileparametresinianlatırkenverdiğimizşuörneği tekrarelealalım: >>> f = open("kişisel_bilgiler.txt", "w") Bu komutla kişisel_bilgiler.txt adlı bir dosyayı yazma kipinde açtık. Şimdi bu dosyaya bazı bilgilerekleyelim: >>> print("Fırat Özgül", file=f) Bukomutlakişisel_bilgiler.txtadlıdosyaya‘FıratÖzgül’diyebirsatıreklemişolduk. Şimdi bilgisayarınızda oluşan bu kişisel_bilgiler.txt dosyasını açın. Gördüğünüz gibi dosyada hiçbirbilgiyok.Dosyaşuandaboşgörünüyor.Halbukibizbirazöncebudosyaya‘FıratÖzgül’ diyebirsatıreklemiştik,değilmi? Python bizim bu dosyaya eklemek istediğimiz satırı tampona kaydetti. Dosyaya yazma işlemleri sona erdiğinde ise Python, tamponda bekleyen bütün bilgileri standart çıktı konumuna(yanibizimdurumumuzdafadlıdeğişkenintuttuğukişisel_bilgiler.txtadlıdosyaya) boşaltacak. Dosyayabaşkabilgilerdeyazalım: >>> print("Adana", file=f) >>> print("Ubuntu", file=f) Dosyayayazacağımızşeylerbukadar.ArtıkyazmaişlemininsonaerdiğiniPython’abildirmek içinşukomutuveriyoruz: >>> f.close() 6.4. print()FonksiyonununParametreleri 73 PythonBelgeleri,Yayım4.1.3 Böylecedosyamızıkapatmışolduk.Şimdikişisel_bilgiler.txtadlıdosyayaçifttıklayarakdosyayı tekraraçın.Orada‘FıratÖzgül’,‘Adana’ve‘Ubuntu’satırlarınıgöreceksiniz. Gördüğünüz gibi, gerçekten de Python dosyaya yazdırmak istediğimiz bütün verileri önce tamponda bekletti, daha sonra dosya kapatılınca tamponda bekleyen bütünverileri dosyaya boşalttı. İşte flush parametresi ile, bahsettiğimiz bu boşaltma işlemini kontrol edebilirsiniz. Şimdidikkatliceinceleyin: >>> f = open("kişisel_bilgiler.txt", "w") Dosyamızıoluşturduk.Şimdibudosyayabazıbilgilerekleyelim: >>> print("Merhaba Dünya!", file=f, flush=True) Gördüğünüz gibi, burada flush adlı yeni bir parametre kullandık. Bu parametreye verdiğimiz değer True. Şimdi dosyaya çift tıklayarak dosyayı açın. Gördüğünüz gibi, henüz dosyayı kapatmadığımız halde bilgiler dosyaya yazıldı. Bu durum, tahmin edebileceğiniz gibi, flush parametresine True değeri vermemiz sayesindedir. Bu parametre iki değer alabilir: True ve False. Bu parametrenin öntanımlı değeri False’tur. Yani eğer biz bu parametreye herhangi bir değer belirtmezsek Python bu parametrenin değerini False olarak kabul edecek ve bilgilerindosyayayazılmasıiçindosyanınkapatılmasınıbekleyecektir.Ancakbuparametreye True değerini verdiğimizde ise veriler tamponda bekletilmeksizin standart çıktı konumuna gönderilecektir. Yazdığınız bir programda, yapmak istediğiniz işin niteliğine göre, bir dosyaya yazmak istediğiniz bilgilerin bir süre tamponda bekletilmesini veya hiç bekletilmeden doğrudan dosyayayazılmasınıisteyebilirsiniz.İhtiyacınızabağlıolarakdaflushparametresinindeğerini TrueveyaFalseolarakbelirleyebilirsiniz. 6.5 Birkaç Pratik Bilgi Buraya gelene kadar print() fonksiyonu ve bu fonksiyonun parametreleri hakkında epey söz söyledik. Dilerseniz şimdi de, programcılık maceranızda işinize yarayacak, işlerinizi kolaylaştıracakbazıipuçlarıverelim. 6.5.1 Yıldızlı Parametreler Şimdisizeşöylebirsorusormamaizinverin:Acabaaşağıdakigibibirçıktıyınasıleldeederiz? L.i.n.u.x Aklınızahemenşöylebircevapgelmişolabilir: >>> print("L", "i", "n", "u", "x", sep=".") L.i.n.u.x Yukarıdaki, gerçekten de doğru bir çözümdür. Ancak bu soruyu çözmenin çok daha basit bir yoluvar.Şimdidikkatlebakın: 74 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 >>> print(*"Linux", sep=".") L.i.n.u.x Konuyuaçıklamayageçmedenöncebirörnekdahaverelim: >>> print(*"Galatasaray") G a l a t a s a r a y Buradanelerdöndüğünüazçoktahminettiğinizizannediyorum.Sonörnektedegördüğünüz gibi, “Galatasaray” karakter dizisinin başına eklediğimiz yıldız işareti; “Galatasaray” karakter dizisinin her bir öğesini parçalarına ayırarak, bunları tek tek print() fonksiyonuna yolluyor. Yanisankiprint()fonksiyonunuşöyleyazmışızgibioluyor: >>> print("G", "a", "l", "a", "t", "a", "s", "a", "r", "a", "y") G a l a t a s a r a y Dediğimiz gibi, bir fonksiyona parametre olarak verdiğimiz bir karakter dizisinin başına eklediğimizyıldızişareti,bukarakterdizisinitekteköğelerineayırıp,buöğeleriyinetektekve sanki her bir öğe ayrı bir parametreymiş gibi o fonksiyona gönderdiği için doğal olarak yıldız işaretiniancak,birdenfazlaparametrealabilenfonksiyonlarauygulayabiliriz. Örneğinlen()fonksiyonusadecetekbirparametrealabilir: >>> len("Galatasaray") 11 Bufonksiyonubirdenfazlaparametreilekullanamayız: >>> len("Galatasaray", "Fenerbahçe", "Beşiktaş") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: len() takes exactly one argument (3 given) Hata mesajında da söylendiği gibi, len() fonksiyonu yalnızca tek bir parametre alabilirken, biz3parametrevermeyeçalışmışız... Dolayısıylayıldızlıparametrelerilen()fonksiyonunauygulayamayız: >>> len(*"Galatasaray") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: len() takes exactly one argument (11 given) Bir parametrenin başına yıldız eklediğimizde, o parametreyi oluşturan bütün öğeler tek tek fonksiyonagönderildiğiiçin,sankilen()fonksiyonuna1değilde,11ayrıparametrevermişiz gibibirsonuçortayaçıkıyor. 6.5. BirkaçPratikBilgi 75 PythonBelgeleri,Yayım4.1.3 Yıldızlı parametreleri bir fonksiyona uygulayabilmemiz için o fonksiyonun birden fazla parametre alabilmesinin yanısıra, yapısının da yıldızlı parametre almaya uygun olması gerekir. Mesela open(), type() ve biraz önce bahsettiğimiz len() fonksiyonlarının yapısı yıldızlı parametre almaya uygun değildir. Dolayısıyla yıldızlı parametreleri her fonksiyonla birlikte kullanamayız, ama print() fonksiyonu yıldızlı parametreler için son derece uygun birfonksiyondur: >>> print(*"Galatasaray") G a l a t a s a r a y >>> print(*"TBMM", sep=".") T.B.M.M >>> print(*"abcçdefgğh", sep="/") a/b/c/ç/d/e/f/g/ğ/h Bu örneklerden de gördüğünüz gibi, print() fonksiyonuna verdiğimiz bir parametrenin başına yıldız eklediğimizde, o parametre tek tek parçalarına ayrılıp print() fonksiyonuna gönderildiği için, sonuç olarak sep parametresinin karakter dizisi öğelerine tek tek uygulanmasınısağlamışoluyoruz. Hatırlarsanız sep parametresinin öntanımlı değerinin bir adet boşluk karakteri olduğunu söylemiştik.YaniaslındaPythonyukarıdakiilkkomutuşöylegörüyor: >>> print(*"Galatasaray", sep=" ") Dolayısıyla, yıldız işareti sayesinde “Galatasaray” adlı karakter dizisinin her bir öğesinin arasınabiradetboşlukkarakteriyerleştiriliyor.Birsonraki“TBMM”karakterdizisindeise,sep parametresinin değerini nokta işareti olarak değiştirdiğimiz için “TBMM” karakter dizisinin her bir öğesinin arasına bir adet nokta işareti yerleştiriliyor. Aynı şekilde “abcçdefgğh” karakterdizisininherbiröğesinitektekprint()fonksiyonunayollayarak,sepparametresine verdiğimiz/işaretiyardımıylaheröğeninarasınabu/işaretiniyerleştirebiliyoruz. Yıldızlı parametrelerle ilgili tek kısıtlama, bunların sayılarla birlikte kullanılamayacak olmasıdır: >>> print(*2345) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: print() argument after * must be a sequence, not int Çünkü yıldızlı parametreler ancak ve ancak dizi özelliği taşıyan veri tipleriyle birlikte kullanılabilir. Mesela karakter dizileri bu türden bir veri tipidir. İlerde dizi özelliği taşıyan ve busayedeyıldızlıparametrelerlebirliktekullanılabilecekbaşkaveritiplerinideöğreneceğiz. Yukarıda verdiğimiz örnekler bize yıldızlı parametrelerin son derece kullanışlı araçlar olduğunu gösteriyor. İleride de bu parametrelerden bol bol yararlanacağız. Biz şimdi bu konuyuburadakapatıpbaşkabirşeydensözedelim. 76 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 6.5.2 sys.stdout’u Kalıcı Olarak Değiştirmek Önceki başlıklar altında verdiğimiz örneklerden de gördüğünüz gibi, print() fonksiyonunun fileparametresiyardımıylaPython’ınstandartçıktıkonumunugeçiciolarakdeğiştirebiliyoruz. Ama bazı durumlarda, yazdığınız programlarda, o programın işleyişi boyunca standart dışı bir çıktı konumu belirlemek isteyebilirsiniz. Yani standart çıktı konumunu geçici olarak değil, kalıcıolarakdeğiştirmenizgerekebilir.Meselayazdığınızprogramdabütünçıktılarıbirdosyaya yazdırmayı tercih edebilirsiniz. Elbette bu işlemi her defasında file parametresini, çıktıları yazdırmak istediğiniz dosyanın adı olarak belirleyerek yapabilirsiniz. Tıpkı şu örnekte olduğu gibi: >>> f = open("dosya.txt", "w") >>> print("Fırat Özgül", file=f) >>> print("Adana", file=f) >>> print("Ubuntu", file=f) >>> f.close() Gördüğünüz gibi, her defasında file parametresine f değerini vererek işimizi hallettik. Ama bunu yapmanın daha pratik bir yöntemi var. Dilerseniz yazdığınız programın tüm işleyişi boyunca çıktıları başka bir konuma yönlendirebilirsiniz. Bunun için hem şimdiye kadar öğrendiğimiz,hemdehenüzöğrenmediğimizbazıbilgilerikullanacağız. İlkönceşöylebirkodyazalım: >>> import sys Bukodyardımıylasysadlıözelbir‘modülü’programımızadahiletmiş,yaniiçeaktarmışolduk. Peki‘modül’nedir,‘içeaktarmak’nedemek? Aslındabizbu‘modül’ve‘içeaktarma’kavramlarınahiçdeyabancıdeğiliz.Öncekiderslerde, pek üzerinde durmamış da olsak, biz Python’daki birkaç modülle zaten tanışmıştık. Mesela os adlı bir modül içindeki getcwd() adlı bir fonksiyonu kullanarak, o anda hangi dizinde bulunduğumuzuöğrenebilmiştik: >>> import os >>> os.getcwd() Aynı şekilde keyword adlı başka bir modül içindeki kwlist adlı değişkeni kullanarak, hangi kelimelerinPython’dadeğişkenadıolarakkullanılamayacağınıdalisteleyebilmiştik: >>> import keyword >>> keyword.kwlist İşteşimdide,osvekeywordmodüllerineekolaraksysadlıbirmodüldensözediyoruz.Gelin istersenizötekimodüllerişimdilikbirkenarabırakıp,busysdenenmodüledikkatimiziverelim. Dediğimiz gibi, sys modülü içinde pek çok önemli değişken ve fonksiyon bulunur. Ancak bir modüliçindekideğişkenvefonksiyonlarıkullanabilmekiçinomodülüöncelikleprogramımıza dahiletmemiz,yaniiçeaktarmamızgerekiyor.Bunuimportkomutuylayapıyoruz: >>> import sys Artıksysmodülüiçindekibütünfonksiyonvedeğişkenlereulaşabileceğiz. 6.5. BirkaçPratikBilgi 77 PythonBelgeleri,Yayım4.1.3 sysmodülüiçindebulunanpekçokdeğişkenvefonksiyondanbiridestdoutadlıdeğişkendir. Budeğişkenindeğerineşöyleulaşabilirsiniz: >>> sys.stdout Bukomutşunabenzerbirçıktıverir: <_io.TextIOWrapper name=’<stdout>’ mode=’w’ encoding=’cp1254’> Bu çıktıdaki name=’<stdout>’ kısmına dikkat edin. Bu ifadeye birazdan geri döneceğiz. Biz şimdibaşkabirşeydensözedelim. Hatırlarsanız etkileşimli kabuğu nasıl kapatabileceğimizi anlatırken, etkileşimli kabuktan çıkmanınbiryolunundaşukomutlarıvermekolduğunusöylemiştik: >>> import sys; sys.exit() Bukomututeksatırdayazmıştık,amaistersekşöyledeyazabilirizelbette: >>> import sys >>> sys.exit() Dedikya,sysmodülüiçindepekçokdeğişkenvefonksiyonbulunur.Nasılstdoutsysmodülü içindekideğişkenlerdenbiriise,exit()desysmodülüiçindebulunanfonksiyonlardanbiridir. Biz ‘modüller’ konusunu ilerleyen derslerde ayrıntılı bir şekilde inceleyeceğiz. Şimdilik modüllereilişkinolarakyalnızcaşunlarıbilelimyeter: 1. Python’da modüller import komutu ile içe aktarılır. Örneğin sys adlı modülü içe aktarmak içinimport syskomutunuveriyoruz. 2. Modüller içinde pek çok faydalı değişken ve fonksiyon bulunur. İşte bir modülü içe aktardığımızda,omodüliçindekibudeğişkenvefonksiyonlarıkullanmaimkanıeldeederiz. 3. sys modülü içindeki değişkenlere bir örnek stdout; fonksiyonlara örnek ise exit() fonksiyonudur. Bir modül içindeki bu değişken ve fonksiyonlara ‘modül_adı.değişken_ya_da_fonksiyon’formülünükullanarakerişebiliriz.Örneğin: >>> sys.stdout >>> sys.exit() 4. Hatırlarsanız bundan önce de, open() fonksiyonu ile dosya oluşturmayı anlatırken, oluşturulan dosyanın hangi dizinde olduğunu bulabilmek amacıyla, o anda içinde bulunduğumuzdizinitespitedebilmekiçinşukodlarıkullanmıştık: >>> import os >>> os.getcwd() Burada da os adlı başka bir modül görüyoruz. İşte os da tıpkı sys gibi bir modüldür ve tıpkı sys modülünde olduğu gibi, os modülünün de içinde pek çok yararlı değişken ve fonksiyon bulunur. getcwd() adlı fonksiyon da os modülü içinde yer alan ve o anda hangi dizin altında bulunduğumuzugösterenbirfonksiyondur.Elbette,yinetıpkısysmodülündeolduğugibi,os modülü içindeki bu yararlı değişken ve fonksiyonları kullanabilmek için de öncelikle bu os modülünüiçeaktarmamız,yaniprogramımızadahiletmemizgerekiyor.osmodülünüimport 78 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 komutu aracılığıyla uygun bir şekilde içe aktardıktan sonra, modül içinde yer alan getcwd() adlıfonksiyonayine‘modül_adı.fonksiyon’formülünükullanarakerişebiliyoruz. Modüllere ilişkin şimdilik bu kadar bilgi yeter. Modülleri bir kenara bırakıp yolumuza devam edelim... Eğer sys.exit() komutunu verip etkileşimli kabuktan çıktıysanız, etkileşimli kabuğa tekrar girinvesysmodülünüyenideniçeaktarın: >>> import sys (cid:242) Not Bir modülü aynı etkileşimli kabuk oturumu içinde bir kez içe aktarmak yeterlidir. Bir modülü bir kez içe aktardıktan sonra, o oturum süresince bu modül içindeki değişken ve fonksiyonları kullanmaya devam edebilirsiniz. Ama tabii ki etkileşimli kabuğu kapatıp tekrar açtıktan sonra, bir modülü kullanabilmek için o modülü tekrar içe aktarmanız gerekir. Şimdişukoduyazın: >>> f = open("dosya.txt", "w") Bukodunanlamınıbiliyorsunuz.Buradadosya.txtadlıbirdosyayıyazmakipindeaçmışolduk. Tahminedebileceğinizgibi,çıktılarımızıekranyerinebudosyayayönlendireceğiz. Şimdideşöylebirkodyazalım: >>> sys.stdout = f Bildiğiniz gibi, sys.stdout değeri Python’ın çıktıları hangi konuma vereceğini belirliyor. İşte biz burada sys.stdout’un değerini biraz önce oluşturduğumuz f adlı dosya ile değiştiriyoruz. Böylece Python bütün çıktıları f değişkeni içinde belirttiğimiz dosya.txt adlı dosyaya gönderiyor. Buandansonrayazacağınızherşeydosya.txtadlıdosyayagidecektir: >>> print("deneme metni", flush=True) Gördüğünüz gibi, burada file parametresini kullanmadığımız halde çıktılarımız ekrana değil, dosya.txt adlı bir dosyaya yazdırıldı. Peki ama bu nasıl oldu? Aslında bunun cevabı çok basit: Birazöncesys.stdout = fkomutuylasys.stdout’undeğerinifdeğişkeninintuttuğudosyaile değiştirdik.Buişlemiyapmadanöncesys.stdout’undeğerişuyduhatırlarsanız: <_io.TextIOWrapper name=’<stdout>’ mode=’w’ encoding=’cp1254’> Amasys.stdout = fkomutundansonraherşeydeğişti.Kontroledelim: >>> print(sys.stdout, flush=True) Elbettebukomuttanherhangibirçıktıalmadınız.Çıktınınneolduğunugörmekiçindosya.txt adlıdosyayıaçın.Oradaşusatırıgöreceksiniz: 6.5. BirkaçPratikBilgi 79 PythonBelgeleri,Yayım4.1.3 <_io.TextIOWrapper name=’dosya.txt’ mode=’w’ encoding=’cp1254’> Gördüğünüz gibi, özgün stdout çıktısındaki name=’<stdout>’ değeri name=’dosya.txt’ olmuş. Dolayısıylaartıkbütünçıktılardosya.txtadlıdosyayagidiyor... Bu arada, yukarıdaki çıktıda görünen name, mode ve encoding değerlerine şu şekilde ulaşabilirsiniz: >>> sys.stdout.name >>> sys.stdout.mode >>> sys.stdout.encoding Burada sys.stdout.name komutu standart çıktı konumunun o anki adını verecektir. sys.stdout.mode komutu ise standart çıktı konumunun hangi kipe sahip olduğunu gösterir. Standart çıktı konumu genellikle yazma kipinde (w) bulunur. sys.stdout.encoding kodu ise standart çıktı konumunun sahip olduğu kodlama biçimini gösterir. Kodlama biçimi, standart çıktı konumuna yazdıracağınız karakterlerin hangi kodlama biçimi ile kodlanacağını belirler. Kodlama biçimi Windows’ta genellikle ‘cp1254’, GNU/Linux’ta ise ‘utf-8’dir. Eğer bu kodlama biçimi yanlış olursa, mesela dosyaya yazdıracağınız karakterler içindeki Türkçe harfler düzgün görüntülenemez. Eğer burada söylediklerimiz size şu anda anlaşılmaz geliyorsa, söylediklerimizi dikkate almadan yolunuza devam edebilirsiniz. Birkaç bölüm sonra bu söylediklerimizsizedahafazlaşeyifadeetmeyebaşlayacaknasılolsa. Peki standart çıktı konumunu eski haline döndürmek isterseniz ne yapacaksınız? Bunun için etkileşimli kabuktan çıkıp tekrar girebilirsiniz. Etkileşimli kabuğu tekrar açtığınızda her şeyin eski haline döndüğünü göreceksiniz. Aynı şekilde, eğer bu kodları bir program dosyasına yazmışolsaydınız,programınızkapandığındaherşeyeskihalinedönecekti. Pekistandartçıktıkonumunu,etkileşimlikabuktançıkmadanveyaprogramıkapatmadaneski halinedöndürmeninbiryoluvarmı?Elbettevar.Dikkatlicebakın: >>> import sys >>> f = open("dosya.txt", "w") >>> sys.stdout, f = f, sys.stdout >>> print("deneme", flush=True) >>> f, sys.stdout = sys.stdout, f >>> print("deneme") deneme . Uyarı Eğer yukarıdaki kodları çalıştıramıyorsanız, aynı etkileşimli kabuk oturumunda önceden verdiğiniz kodlar bu kodların doğru çıktı vermesini engelliyor olabilir. Bu sorunu aşmak için,etkileşimlikabuğukapatıptekraraçınveyukarıdakikomutlarıtekrarverin. Aslında burada anlayamayacağınız hiçbir şey yok. Burada yaptığımız şeyi geçen bölümlerde değişkenlerindeğerininasıltakasedeceğimizianlatırkendeyapmıştık.Hatırlayalım: >>> osman = "Araştırma Geliştirme Müdürü" >>> mehmet = "Proje Sorumlusu" (sonrakisayfayadevam) 80 Bölüm6. print()Fonksiyonu PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> osman, mehmet = mehmet, osman BukodlarlaOsmanveMehmet’inunvanlarınıbirbiriyletakasetmiştik.İşteyukarıdayaptığımız şeydebununlaaynıdır.sys.stdout, f = f, sys.stdoutdediğimizdefdeğerinisys.stdout’a, sys.stdout’undeğeriniisef’yevermişoluyoruz.f, sys.stdout = sys.stdout, fdediğimizde ise,buişlemintamtersiniyaparakherşeyieskihalinegetirmişoluyoruz. Python’ın bize sunduğu bu kolaylıktan faydalanarak değişkenlerin değerini birbiriyle kolayca takasedebiliyoruz.Eğerböylebirkolaylıkolmasaydıyukarıdakikodlarışöyleyazabilirdik: >>> import sys >>> f = open("dosya.txt", "w") >>> özgün_stdout = sys.stdout >>> sys.stdout = f >>> print("deneme", flush=True) >>> sys.stdout = özgün_stdout >>> print("deneme") deneme Gördüğünüzgibi,sys.stdout’undeğerinikaybetmemekiçin,sys.stdoutdeğerinifadlıdosyaya göndermedenönceşukodyardımıylayedekliyoruz: >>> özgün_stdout = sys.stdout sys.stdout’un özgün değerini özgün_stdout değişkenine atadığımız için, bu değere sonradan tekrar ulaşabileceğiz. Zaten yukarıdaki kodlardan da gördüğünüz gibi, sys.stdout’un özgün değerinedönmekistediğimizdeşukoduyazarakisteğimizigerçekleştirebiliyoruz: >>> sys.stdout = özgün_stdout Böylece stdout değeri eski haline dönmüş oluyor ve bundan sonra yazdırdığımız her şey yenidenekranabasılmayabaşlıyor. ...veböyleceuzunbirbölümüdahageridebıraktık.Bubölümdehemprint()fonksiyonunu bütünayrıntılarıylaincelemişolduk,hemdePythonprogramlamadilinedairbaşkaçokönemli kavramlardan söz ettik. Bu bakımdan bu bölüm bize epey şey öğretti. Artık öğrendiğimiz bu bilgilerideküfemizekoyarakbaşımızdikbirşekildeyoladevamedebiliriz. 6.5. BirkaçPratikBilgi 81 7 BÖLÜM Kaçış Dizileri Python’da karakter dizilerini tanımlayabilmek için tek, çift veya üç tırnak işaretlerinden faydalandığımızı geçen bölümde öğrenmiştik. Python bir verinin karakter dizisi olup olmadığına bu tırnak işaretlerine bakarak karar verdiği için, tek, çift ve üç tırnak işaretleri Python açısından özel bir önem taşıyor. Zira Python’ın gözünde bir başlangıç tırnağı ile bitiş tırnağıarasındayeralanherşeybirkarakterdizisidir. Örneğin ilk olarak bir “ işareti koyup ardından “elma şeklinde devam ettiğinizde, Python ilk tırnağıgördüktensonrakarakterdizisinitanımlayabilmekiçinikincibirtırnakişaretiaramaya başlar. Siz “elma” şeklinde kodunuzu tamamladığınızda ise Python bellekte “elma” adlı bir karakterdizisioluşturur. Bunoktadasizeşöylebirsorusormamaizinverin:Acabatırnakişaretleriherhangibirmetin içindekaçfarklıamaçlakullanılabilir? İstersenizbusorununcevabınıörneklerüzerindevermeyeçalışalım: Ahmet,“Bugünsinemayagidiyorum,”dedi. Buradatırnakişaretlerini,birbaşkasınınsözleriniaktarmakiçinkullandık. ‘book’kelimesiTürkçede‘kitap’anlamınagelir. Buradaisetırnakişaretlerinibazıkelimelerivurgulamakiçinkullandık. Birdeşunabakalım: YarınAdana’yagidiyorum. Buradadatırnakişaretini,çekimekiolan‘-(y)a’ileözelisimolan‘Adana’kelimesinibirbirinden ayırmakiçinkesmeişaretigörevindekullandık. Şimdiyukarıdaverdiğimizilkcümleyibirkarakterdizisiolaraktanımlamayaçalışalım: >>> ’Ahmet, "Bugün sinemaya gidiyorum," dedi.’ Buradakarakterdizisinitanımlamayatektırnakişaretiilebaşladık.BöylecePythonbukarakter dizisinitanımlamaişleminibitirebilmekiçinikincibirtektırnakişaretidahaaramayakoyuldu 82 PythonBelgeleri,Yayım4.1.3 ve aradığı tek tırnak işaretini cümlenin sonunda bularak, karakter dizisini düzgün bir şekilde oluşturabildi. Dediğimiz gibi, Python’ın gözünde tırnak işaretleri bir karakter dizisini başka veri tiplerinden ayırt etmeye yarayan bir ölçüttür. Ama biz insanlar, yukarıda verdiğimiz örnek cümlelerden de göreceğiniz gibi, programlama dillerinden farklı olarak, tırnak işaretlerini bir metin içinde dahafarklıamaçlariçindekullanabiliyoruz. Şimdiyukarıdakikarakterdizisinişöyletanımlamayaçalıştığımızıdüşünün: >>> "Ahmet, "Bugün sinemaya gidiyorum," dedi." İşte burada Python’ın çıkarları ile bizim çıkarlarımız birbiriyle çatıştı. Python karakter dizisini başlatan ilk çift tırnak işaretini gördükten sonra, karakter dizisini tanımlama işlemini bitirebilmekiçinikincibirtırnakişaretidahaaramayakoyuldu.Buarayışsırasındada‘Bugün’ kelimesininbaşındakiçifttırnakişaretinigördüvekarakterdizisininşuolduğunuzannetti: >>> "Ahmet, " Burayakadarbirsorunyok.BukarakterdizisiPython’ınsözdizimikurallarınauygun. KarakterdizisibuşekildetanımlandıktansonraPythoncümleningerikalanınıokumayadevam ediyor ve herhangi bir tırnak işareti ile başlamayan ve kendisinden önce gelen öğeden herhangi bir virgül işareti ile ayrılmamış ‘Bugün’ kelimesini görüyor. Eğer bir kelime tırnak işareti ile başlamıyorsa bu kelime ya bir değişkendir ya da sayıdır. Ama ‘Bugün’ kelimesi ne bir değişken, ne de bir sayı olduğu, üstelik önceki öğeden de virgülle ayrılmadığı için Python’ın hata vermekten başka çaresi kalmıyor. Çünkü biz burada ‘Bugün’ kelimesinin baş tarafındaki çift tırnak işaretini karakter dizisi tanımlamak için değil, başkasının sözlerini aktarmak amacıyla kullandık. Ancak elbette bir programlama dili bizim amacımızın ne olduğunukestiremezvehatamesajınısuratımızayapıştırır: File "<stdin>", line 1 "Ahmet, "Bugün sinemaya gidiyorum," dedi." ^ SyntaxError: invalid syntax Pekibizböylebirdurumdaneyapmalıyız? Buhatayıengellemekiçinkarakterdizisinitanımlamayaçifttırnakyerinetektırnaklayadaüç tırnaklabaşlayabiliriz: >>> ’Ahmet, "Bugün sinemaya gidiyorum," dedi.’ ... veya: >>> """Ahmet, "Bugün sinemaya gidiyorum," dedi.""" Böylecekarakterdizisinibaşlatanişaret‘Bugünsinemayagidiyorum,’cümlesininbaşındakive sonundaki işaretlerden farklı olduğu için, Python okuma esnasında bu cümleye takılmaz ve doğrubirşekilde,karakterdizisinikapatantırnakişaretinibulabilir. Bu yöntem tamamen geçerli ve mantıklıdır. Ama eğer istersek, aynı karakter dizisini çift tırnaklatanımlayıp,yinedehataalmayıengelleyebiliriz.Pekiamanasıl? İşteburada‘kaçışdizileri’adıverilenbirtakımaraçlardanfaydalanacağız. 83 PythonBelgeleri,Yayım4.1.3 Pekinedirbu‘kaçışdizisi’denenşey? Kaçış dizileri, Python’da özel anlam taşıyan işaret veya karakterleri, sahip oldukları bu özel anlam dışında bir amaçla kullanmamızı sağlayan birtakım araçlardır. Mesela yukarıda da örneklerini verdiğimiz gibi, tırnak işaretleri Python açısından özel anlam taşıyan işaretlerdir. Normalde Python bu işaretleri karakter dizilerini tanımlamak için kullanır. Ama eğer siz mesela bir metin içinde bu tırnak işaretlerini farklı bir amaçla kullanacaksanız Python’ı bu durumdan haberdar etmeniz gerekiyor. İşte kaçış dizileri, Python’ı böyle bir durumdan haberdaretmemizeyarayanaraçlardır. Python’da pek çok kaçış dizisi bulunur. Biz burada bu kaçış dizilerini tek tek inceleyeceğiz. O haldehemenişekoyulalım. 7.1 Ters Taksim (\) Yukarıda verdiğimiz örneklerde, çift tırnakla gösterdiğimiz karakter dizilerinin içinde de çift tırnak işareti kullanabilmek için birkaç farklı yöntemden yararlanabildiğimizi öğrenmiştik. Buna göre, eğer bir karakter dizisi içinde çift tırnak işareti geçiyorsa, o karakter dizisini tek tırnakla;eğertektırnakgeçiyorsadaokarakterdizisiniçifttırnaklatanımlayarakbusorunun üstesinden gelebiliyorduk. Ama daha önce de söylediğimiz gibi, ‘kaçış dizileri’ adı verilen birtakımaraçlarıkullanarak,meselaiçindeçifttırnakgeçenkarakterdizileriniyineçifttırnakla tanımlayabiliriz. Dilerseniz, kaçış dizisi kavramını açıklamaya geçmeden önce bununla ilgili birkaç örnek verelim.Busayedeneilekarşıkarşıyaolduğumuz,zihnimizdebirazdahabelirginleşebilir: >>> print(’Yarın Adana\’ya gidiyorum.’) Yarın Adana’ya gidiyorum. Birörnekdahaverelim: >>> print("\"book\" kelimesi Türkçede \"kitap\" anlamına gelir.") "book" kelimesi Türkçede "kitap" anlamına gelir. Burada da cümle içinde çift tırnak işaretlerini kullandığımız halde, \ işaretleri sayesinde karakterdizileriniyineçifttırnaklatanımlayabildik. Birdeşuörneğebakalım: >>> print("Python programlama dilinin adı \"piton\" yılanından gelmez") Bütün bu örneklerde, karakter dizisini hem çift tırnakla tanımlayıp hem de karakter dizisi içindeçifttırnakişaretlerinikullandığımızhalde,herhangibirhataalmadığımızıgörüyorsunuz. Yukarıdaki kodlarda hata almamızı önleyen şeyin \ işareti olduğu belli. Ama dilerseniz bu işaretin,hataalmamızınasılönlediğinianlatmadanöncesonbirörnekdahaverelim. Hatırlarsanızöncekisayfalardaşöylebirkarakterdizisiilekarşılaşmıştık: >>> print(’İstanbul’un 5 günlük hava durumu tahmini’) (sonrakisayfayadevam) 84 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) File "<stdin>", line 1 print(’İstanbul’un 5 günlük hava durumu tahmini’) ^ SyntaxError: invalid syntax Burada da ‘İstanbul’un’ kelimesi içinde geçen tırnak işareti nedeniyle karakter dizisini tek tırnakkullanaraktanımlayamıyorduk.Bukarakterdizisinihatasızbirşekildetanımlayabilmek içinyaçifttırnakyadaüçtırnakkullanmamızgerekiyordu: >>> print("İstanbul’un 5 günlük hava durumu tahmini") İstanbul’un 5 günlük hava durumu tahmini ... veya: >>> print("""İstanbul’un 5 günlük hava durumu tahmini""") İstanbul’un 5 günlük hava durumu tahmini Tıpkı önceki örneklerde olduğu gibi, yukarıdaki karakter dizisini de aslında tek tırnakla tanımlayıphataoluşmasınıönleyebiliriz.Hemengörelim: >>> print(’İstanbul\’un 5 günlük hava durumu tahmini’) İstanbul’un 5 günlük hava durumu tahmini Bütünörneklerde\işaretinikullandığımızıgörüyorsunuz.İştebutürişaretlerePython’dakaçış dizisi (escape sequence) adı verilir. Bu işaretler karakter dizilerini tanımlarken oluşabilecek hatalardan kaçmamızı sağlar. Peki bu \ işareti nasıl oluyor da karakter dizisini tanımlarken hataalmamızıönlüyor?Gelinbusüreciadımadımtarifedelim: Python bir karakter dizisi tanımladığımızda, karakter dizisini soldan sağa doğru okumaya başlar. Mesela yukarıdaki örnekte ilk olarak karakter dizisini tanımlamaya tek tırnakla başladığımızıgörür. Python karakter dizisini başlatan bu tek tırnak işaretini gördüğü zaman, soldan sağa doğru ilerleyerekkarakterdizisinibitirecekolantektırnakişaretiniaramayabaşlar. Soldan sağa doğru ilerlerken ‘İstanbul’un’ kelimesi içinde geçen kesme işaretini görür ve karakter dizisinin burada sona erdiğini düşünür. Ancak karakter dizisini sona erdiren işaret buolmadığıiçinPython’ınhatavermektenbaşkaçaresikalmaz. İşte biz ‘İstanbul’un’ kelimesi içinde geçen bu kesme işaretinin sol tarafına bir adet \ işareti yerleştirerekPython’a,‘Aradığınişaretbudeğil.Senkarakterdizisiniokumayadevamet.Biraz sonra aradığın tırnağı bulacaksın!’ mesajı vermiş, yani orada tırnak işaretini farklı bir amaçla kullandığımızkonusundaPython’ıbilgilendirmişoluruz. Şuradadaaynıdurumsözkonusu: >>> print("Python programlama dilinin adı \"piton\" yılanından gelmez") Tıpkı bir önceki örnekte olduğu gibi, burada da Python karakter dizisini soldan sağa doğru okumaya başlıyor, karakter dizisini başlatan çift tırnak işaretini görüyor ve bunun üzerine Pythonkarakterdizisinibitirecekolançifttırnakişaretiniaramayakoyuluyor. 7.1. TersTaksim(\) 85 PythonBelgeleri,Yayım4.1.3 Karakter dizisini soldan sağa doğru okuduğu sırada, karakter dizisi içinde geçen ‘piton’ kelimesinigörüyor.EğerburadabirönlemalmazsakPythonbukelimeninbaşındakiçifttırnak işaretini, karakter dizisini sona erdiren tırnak olarak algılar ve durum aslında böyle olmadığı içindehataverir. Bu hatayı önlemek için ‘piton’ kelimesinin başındaki çift tırnağın soluna bir adet \ işareti yerleştirerekPython’a,‘Aradığıntırnakbudeğil!’mesajıveriyoruz.Yanibirbakıma,\adlıkaçış dizisikendisinitırnakişaretinesiperedipPython’ınbutırnağıgörmesinemanioluyor... BununüzerinePythonbuçifttırnakişaretinigörmezdengelerek,soldansağadoğruokumaya devam eder ve yol üzerinde ‘piton’ kelimesinin sonundaki çift tırnak işaretini görür. Eğer buradadabirönlemalmazsakPythonyinebirhataverecektir. Tıpkı biraz önce yaptığımız gibi, bu tırnak işaretinin de soluna bir adet \ işareti yerleştirerek Python’a,‘Aradığıntırnakbudadeğil.Senyineokumayadevamet!’mesajıveriyoruz. BumesajıalanPythonkarakterdizisinisoldansağadoğruokumayadevamediyorvesonunda karakterdizisinibitirençifttırnakişaretinibularakbizehatasızbirçıktıveriyor. Böylece \ işareti üzerinden hem kaçış dizilerinin ne olduğunu öğrenmiş, hem de bu kaçış dizisinin nasıl kullanılacağına dair örnekler vermiş olduk. Ancak \ kaçış dizisinin yetenekleri yukarıdakilerle sınırlı değildir. Bu kaçış dizisini, uzun karakter dizilerini bölmek için de kullanabiliriz.Şimdişuörneğidikkatliceinceleyin: >>> print("Python 1990 yılında Guido Van Rossum \ ... tarafından geliştirilmeye başlanmış, oldukça \ ... güçlü ve yetenekli bir programlama dilidir.") Python 1990 yılında Guido Van Rossum tarafından geliştirilmeye başlanmış, oldukça güçlü ve yetenekli bir programlama dilidir. Normal şartlar altında, bir karakter dizisini tanımlamaya tek veya çift tırnakla başlamışsak, karakterdizisininkapanıştırnağınıkoymadanEntertuşunabastığımızdaPythonbizebirhata mesajıgösterir: >>> print("Python 1990 yılında Guido Van Rossum File "<stdin>", line 1 print("Python 1990 yılında Guido Van Rossum ^ SyntaxError: EOL while scanning string literal İşte \ kaçış dizisi bizim burada olası bir hatadan kaçmamızı sağlar. Eğer Enter tuşuna basmadan önce bu işareti kullanırsak Python tıpkı üç tırnak işaretlerinde şahit olduğumuz gibi,hatavermedenbiraltsatırageçecektir.Busırada,yani\kaçışdizisinikoyupEntertuşuna bastığımızda >>> işaretinin ... işaretine dönüştüğünü görüyorsunuz. Bu işaretin, Python’ın bizeverdiğibir‘Yazmayadevamet!’mesajıolduğunubiliyorsunuz. 86 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 7.2 Satır Başı (\n) Python’daki en temel kaçış dizisi biraz önce örneklerini verdiğimiz \ işaretidir. Bu kaçış dizisi başkakarakterlerlebirleşerek,farklıişlevleresahipyenikaçışdizilerideoluşturabilir.Aslında bu olguya yabancı değiliz. Önceki sayfalarda bu duruma bir örnek vermiştik. Hatırlarsanız print() fonksiyonunu anlatırken end parametresinin ön tanımlı değerinin \n, yani satır başı karakteriolduğunusöylemiştik. (cid:242) Not Satırbaşıkarakterine‘yenisatırkarakteri’dendiğideolur. Satırbaşıkarakteriniilköğrendiğimizdebukarakterianlatırkenbazıörneklerdevermiştik: >>> print("birinci satır\nikinci satır\nüçüncü satır") birinci satır ikinci satır üçüncü satır Gördüğünüz gibi, \n adlı kaçış dizisi, bir alt satıra geçilmesini sağlıyor. İşte aslında \n kaçış diziside,\ile‘n’harfininbirleşmesindenoluşmuşbirkaçışdizisidir.Burada\işaretiningörevi, ‘n’harfininözelbiranlamkazanmasınısağlamaktır.\işaretiile‘n’harfibirleştiğinde‘satırbaşı karakteri’denenözelbirkarakterdizisiortayaçıkarıyor. Gelinbukaçışdizisiileilgilibirörnekverelim.Şimdişukodlarıdikkatliceinceleyin: >>> başlık = "Türkiye’de Özgür Yazılımın Geçmişi" >>> print(başlık, "\n", "-"*len(başlık), sep="") Türkiye’de Özgür Yazılımın Geçmişi ---------------------------------- Burada, başlık adlı değişkenin tuttuğu “Türkiye’de Özgür Yazılımın Geçmişi” adlı karakter dizisinin altını çizdik. Dikkat ederseniz, başlığın altına koyduğumuz çizgiler başlığın uzunluğunu aşmıyor. Yazdığımız program, başlığın uzunluğu kadar çizgiyi başlığın altına ekliyor. Bu programda başlık ne olursa olsun, programımız çizgi uzunluğunu kendisi ayarlayacaktır.Örneğin: >>> başlık = "Python Programlama Dili" >>> print(başlık, "\n", "-"*len(başlık), sep="") Python Programlama Dili ----------------------- >>> başlık = "Alışveriş Listesi" >>> print(başlık, "\n", "-"*len(başlık), sep="") Alışveriş Listesi ----------------- 7.2. SatırBaşı(\n) 87 PythonBelgeleri,Yayım4.1.3 Gelinistersenizbukodlardakiprint()satırınışöylebirinceleyelim.Kodumuzşu: >>> print(başlık, "\n", "-"*len(başlık), sep="") Burada öncelikle başlık adlı değişkeni print() fonksiyonunun parantezleri içine yazdık. Böylecebaşlıkdeğişkeninindeğeriekranayazdırılacak. print()fonksiyonununikinciparametresinin\nadlıkaçışdizisiolduğunugörüyoruz.Bukaçış dizisinieklememizsayesindePythonilkparametreyiçıktıolarakverdiktensonrabiraltsatıra geçiyor.Buparametrenintamolarakneişeyaradığınıanlamakiçin,yukarıdakisatırıbirdeo parametreolmadançalıştırmayıdeneyebilirsiniz: >>> print(başlık, "-"*len(başlık), sep="") Alışveriş Listesi----------------- print()fonksiyonununüçüncüparametresininiseşuolduğunugörüyoruz:"-"*len(başlık). İşte başlık değişkeninin altına gerekli sayıda çizgiyi çizen kodlar bunlardır. Burada len() fonksiyonunu nasıl kullandığımıza çok dikkat edin. Bu kod sayesinde başlık değişkeninin uzunluğu(len(başlık))sayısınca-işaretiniekranaçıktıolarakverebiliyoruz. Yukarıdaki kodlarda print() fonksiyonunun son parametresi ise sep=’’. Peki bu ne işe yarıyor? Her zaman olduğu gibi, bu kod parçasının ne işe yaradığını anlamak için programı birdeokodlarolmadançalıştırmayıdeneyebilirsiniz: >>> print(başlık, "\n", "-"*len(başlık)) Alışveriş Listesi ----------------- Gördüğünüz gibi,başlıkdeğişkeninin tam altınagelmesi gereken çizgi işaretleri sağa kaymış. Bunun nedeni sep parametresinin öntanımlı değerinin bir adet boşluk karakteri olmasıdır. sepparametresininöntanımlıdeğerinedeniyleçizgilerinbaştarafınabiradetboşlukkarakteri ekleniyorçıktıda.Oyüzdenbuçizgilersağakaymışgörünüyor.İştebizyukarıdakikodlardasep parametresinin öntanımlı değerini değiştirip, boşluk karakteri yerine boş bir karakter dizisi yerleştiriyoruz.Böyleceçizgilerçıktıdasağakaymıyor. Satır başı karakteri, programlama maceramız sırasında en çok kullanacağımız kaçış dizilerinden biri ve hatta belki de birincisidir. O yüzden bu kaçış dizisini çok iyi öğrenmenizi tavsiyeederim. Ayrıca bu kaçış dizisini (ve tabii öteki kaçış dizilerini) tanıyıp öğrenmeniz, yazacağınız programların selameti açısından da büyük önem taşır. Eğer bir karakter dizisi içinde geçen kaçış dizilerini ayırt edemezseniz Python size hiç beklemediğiniz çıktılar verebilir. Hatta yazdığınızprogramlarkaçışdizilerinitanımıyorolmanızdanötürübirandahataveripçökebilir. Pekiamanasıl? Şimdişuörneğedikkatlicebakın: Diyelimkibilgisayarınızın‘C:\’dizinindeki‘nisan’adlıbirklasörüniçindeyeralanmasraflar.txt adlıbirdosyayıyazdığınızbirprogramiçindekullanmanızgerekiyor.Meselabudosyayı,tam adresiylebirliktekullanıcılarınızagöstermekistiyorsunuz. İlkdenememiziyapalım: 88 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 >>> print("C:\nisan\masraflar.txt") Buradanşöylebirçıktıaldık: C: isan\masraflar.txt Gördüğünüz gibi, bu çıktıyı normal yollardan vermeye çalıştığımızda Python bize hiç de beklemediğimizbirçıktıveriyor.Pekiamaneden? Python’da karakter dizileri ile çalışırken asla aklımızdan çıkarmamamız gereken bir şey var: Eğer yazdığımız herhangi bir karakter dizisinin herhangi bir yerinde \ işaretini kullanmışsak, bu işaretten hemen sonra gelen karakterin ne olduğuna çok dikkat etmemiz gerekir. Çünkü eğer dikkat etmezsek, farkında olmadan Python için özel anlam taşıyan bir karakter dizisi oluşturmuşolabiliriz.Budakodlarımızınbeklediğimizgibiçalışmasınıengeller. Yukarıdakisorununkaynağınıanlamakiçin"C:\nisan\masraflar.txt"adlıkarakterdizisine çok dikkatlice bakın. Python bu karakter dizisinde bizim ‘\nisan’ olarak belirttiğimiz kısmın başındaki \n karakterlerini bir kaçış dizisi olarak algıladı. Çünkü \n adlı karakter dizisi, ‘satır başı kaçış dizisi’ adını verdiğimiz, Python açısından özel anlam taşıyan bir karakter dizisine işaretediyor.Zatenyukarıdakituhafgörünençıktıyabaktığınızdada,bukaçışdizisininolduğu noktadan itibaren karakter dizisinin bölünüp yeni bir satıra geçildiğini göreceksiniz. İşte biz yukarıdaki örnekte alelade bir dizin adı belirttiğimizi zannederken aslında hiç farkında olmadan bir kaçış dizisi üretmiş oluyoruz. Bu nedenle, daha önce de söylediğimiz gibi, karakter dizileri içinde farkında olarak veya olmayarak kullandığımız kaçış dizilerine karşı her zaman uyanık olmalıyız. Aksi takdirde, yukarıda olduğu gibi hiç beklemediğimiz çıktılarla karşılaşabiliriz. Esasen yukarıdaki problem bir dereceye kadar (ve yerine göre) ‘masum bir kusur’ olarak görülebilir. Çünkü bu hata programımızın çökmesine yol açmıyor. Ama bir karakter dizisi içindeki gizli kaçış dizilerini gözden kaçırmak, bazı durumlarda çok daha yıkıcı sonuçlara yol açabilir.Meselayukarıdakisorunludizinadınıekranayazdırmakyerineopen()fonksiyonunu kullanarak,bukarakterdizisiiçindebelirttiğimizmasraflar.txtadlıdosyayıaçmayaçalıştığımızı düşünün: >>> open("C:\nisan\masraflar.txt") Traceback (most recent call last): File "<stdin>", line 1, in <module> OSError: [Errno 22] Invalid argument: ’C:\nisan\\masraflar.txt’ Eğersorunungözdenkaçanbirkaçışdizisindenkaynaklandığınıfarkedemezseniz,busorunu çözebilmek için saatlerinizi ve hatta günlerinizi harcamak zorunda kalabilirsiniz. Çünkü yukarıdaki hata mesajı sorunun nedenine dair hiçbir şey söylemiyor. Ancak ve ancak yukarıdaki karakter dizisi içinde sinsice gizlenen bir \n kaçış dizisi olduğu gözünüze çarparsa busorunuçözmeyolundabiradımatabilirsiniz. Diyelimkisorunun‘\nisan’ifadesininbaşındaki\nkarakterlerininPythontarafındanbirkaçış dizisiolarakalgılanmasındankaynaklandığınıfarkettiniz.Pekibusorununasılçözeceksiniz? Bu sorunun birkaç farklı çözüm yolu var. Biz şimdilik sadece ikisini göreceğiz. Bu bölümün sonunavardığınızdaötekiçözümyolunudaöğrenmişolacaksınız. Yukarıdakiproblemi,ilgilikaçışdizisiiçindekiterstaksimişaretiniçiftleyerekçözebilirsiniz: 7.2. SatırBaşı(\n) 89 PythonBelgeleri,Yayım4.1.3 >>> open("C:\\nisan\masraflar") Tabiitutarlılıkaçısındankarakterdizisiiçindekibütünterstaksimişaretleriniçiftlemekmantıklı olacaktır: >>> open("C:\\nisan\\masraflar") Bunun dışında, bu örnek için, dizin adlarını ters taksim yerine düz taksim işaretiyle ayırmayı tercihedebilirsiniz: >>> open("C:/nisan/masraflar") Dediğimizgibi,üçüncü(veaslındadahakullanışlıolan)yöntemibirazsonrainceleyeceğiz.Biz şimdilikkaçışdizilerinianlatmayadevamedelim. 7.3 Sekme (\t) Python’da \ işareti sadece ‘n’ harfiyle değil, başka harflerle de birleşebilir. Örneğin \ işaretini ‘t’harfiylebirleştirerekyineözelbiranlamifadeedenbirkaçışdizisieldeedebiliriz: >>> print("abc\tdef") abc def Burada \t adlı kaçış dizisi, “abc” ifadesinden sonra sanki Tab (sekme) tuşuna basılmış gibi bir etkioluşturarak“def”ifadesinisağadoğruitiyor.Birdeşuörneğebakalım: >>> print("bir", "iki", "üç", sep="\t") bir iki üç Birörnekdaha: >>> print(*"123456789", sep="\t") 1 2 3 4 5 6 7 8 9 Gördüğünüzgibi,parametrelerarasındabelliaralıktabirboşlukbırakmakistediğimizde\tadlı kaçışdizisindenyararlanabiliyoruz. Tıpkı \n kaçış dizisinde olduğu gibi, karakter dizilerinde \t kaçış dizisinin varlığına karşı da uyanıkolmalıyız: >>> open("C:\nisan\masraflar\toplam_masraf.txt") Traceback (most recent call last): File "<stdin>", line 1, in <module> OSError: [Errno 22] Invalid argument: ’C:\nisan\\masraflar\toplam_masraf.txt’ Burada da \n ile yaşadığımız soruna benzer bir durum var. Biz toplam_masraf.txt adlı bir dosyaya atıfta bulunmaya çalışıyoruz, ama Python bu ifadenin başındaki ‘t’ harfinin, 90 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 kendisinden önce gelen\işareti ile birleşmesindenötürü, bunu \tkaçış dizisi olarak algılıyor veonagöredavranıyor. Belkiyukarıdakikodlarışöyleyazarsakdurumuanlamakdahakolayolabilir: >>> print("C:\nisan\masraflar\toplam_masraf.txt") C: isan\masraflar oplam_masraf.txt Gördüğünüzgibi,Python\nkaçışdizisinigördüğünoktadaaltsatırınbaşınageçiyorve\tkaçış dizisini gördüğü noktada da önceki ve sonraki öğeler arasında bir sekme boşluğu bırakıyor. Bu durumu engellemek için ne yapmanız gerektiğini biliyorsunuz: Ya ters taksim işaretlerini çiftleyeceksiniz: >>> print("C:\\nisan\\masraflar\\toplam_masraf.txt") Yadadizinadıayracıolarakdüztaksimişaretinikullanacaksınız: >>> print("C:/nisan/masraflar/toplam_masraf.txt") Dahaöncedesöylediğimizgibi,üçüncüvedahapratikolanyolubirazsonragöreceğiz.Şimdilik sadecebirazsabır... 7.4 Zil Sesi (\a) \ işaretinin birleştiğinde farklı bir anlam türettiği bir başka harf de ‘a’ harfidir. \ işareti ‘a’ harfiylebirleşerek!bip!benzeribirzilsesiüretilmesinisağlayabilir: >>> print("\a") !bip! İstersenizyukarıdakikomutuşuşekildeyazarak,kafaşişirmekatsayısınıartırabilirsiniz: >>> print("\a" * 10) Buşekilde!bip!sesi10keztekraredilecektir.AncakbukaçışdizisiçoğunluklasadeceWindows üzerinde çalışacaktır. Bu kaçış dizisinin GNU/Linux üzerinde çalışma garantisi yoktur. Hatta bukaçışdizisibütünWindowssistemlerindedahiçalışmayabilir.Dolayısıylabukaçışdizisinin işlevinebelbağlamakpekmantıklıbirişdeğildir. Tıpkı\nve\tkaçışdizilerindeolduğugibibukaçışdizisininvarlığınakarşıdauyanıkolmalıyız. Burada da mesela ‘C:\aylar’ gibi bir dizin adı tanımlamaya çalışırken aslında \a kaçış dizisini oluşturuyorolabilirsinizfarkındaolmadan. 7.4. ZilSesi(\a) 91 PythonBelgeleri,Yayım4.1.3 7.5 Aynı Satır Başı (\r) Bu kaçış dizisi, bir karakter dizisinde aynı satırın en başına dönülmesini sağlar. Bu kaçış dizisinin işlevini tanımına bakarak anlamak biraz zor olabilir. O yüzden dilerseniz bu kaçış dizisininneişeyaradığınıbirörneküzerindegöstermeyeçalışalım: >>> print("Merhaba\rZalim Dünya!") Zalim Dünya! Burada olan şey şu: Normal şartlar altında, print() fonksiyonu içine yazdığımız bir karakter dizisindekibütünkarakterlersoldansağadoğrutektekekranayazdırılır: >>> print("Merhaba Zalim Dünya!") Merhaba Zalim Dünya! Ancak eğer karakter dizisinin herhangi bir yerine \r adlı kaçış dizisini yerleştirirsek, bu kaçış dizisinin bulunduğu konumdan itibaren aynı satırın başına dönülecek ve \r kaçış dizisinden sonragelenbütünkarakterlersatırbaşındakikarakterlerinüzerineyazacaktır.Şuörnekdaha açıklayıcıolabilir: >>> print("Merhaba\rDünya") Dünyaba Burada, “Merhaba” karakter dizisi ekrana yazdırıldıktan sonra \r kaçış dizisinin etkisiyle satır başına dönülüyor ve bu kaçış dizisinden sonra gelen “Dünya” karakter dizisi “Merhaba” karakter dizisinin üzerine yazıyor. Tabii “Dünya” karakter dizisi içinde 5 karakter, “Merhaba” karakterdizisiiçindeise7karakterolduğuiçin,“Merhaba”karakterdizisininsonikikarakteri (“ba”)dışardakalıyor.Böyleceortaya“Dünyaba”gibibirşeyçıkıyor. Öncekikaçışdizilerindeolduğugibi,bukaçışdizisinidefarkındaolmadankarakterdizisiiçinde kullanırsanızbeklemediğinizçıktılaralırsınız: >>> print("C:\ülke\türkiye\iller\rize\nüfus.txt") izeülke ürkiye\iller üfus.txt Buradafarkındaolmadansadecebirdeğil,üçkaçışdizisibirdenoluşturduk! 7.6 Düşey Sekme (\v) Eğer\işaretini‘v’harfiylebirliktekullanırsakdüşeysekmedenenşeyieldeederiz.Hemenbir örnekverelim: >>> print("düşey\vsekme") düşey sekme 92 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 Yalnız bu \v adlı kaçış dizisi her işletim sisteminde çalışmayabilir. Dolayısıyla, birden fazla platform üzerinde çalışmak üzere tasarladığınız programlarınızda bu kaçış dizisini kullanmanızıönermem. 7.7 İmleç Kaydırma (\b) \ kaçış dizisinin, biraraya geldiğinde özel bir anlam kazandığı bir başka harf de b’dir. \b kaçış dizisinin görevi, imleci o anki konumundan sola kaydırmaktır. Bu tanım pek anlaşılır değil. O yüzdenbirörnekverelim: >>> print("yahoo.com\b") Bu kodu çalıştırdığınızda herhangi bir değişiklik görmeyeceksiniz. Ama aslında en sonda gördüğümüz\bkaçışdizisi,imlecibirkaraktersolakaydırdı.Dikkatlicebakın: >>> print("yahoo.com\b.uk") Gördüğünüz gibi, \b kaçış dizisinin etkisiyle imleç bir karakter sola kaydığı için, ‘com’ kelimesinin son harfi silindi ve bunun yerine \b kaçış dizisinden sonra gelen .uk karakterleri yerleştirildi.Dolayısıylabizdeşuçıktıyıaldık: yahoo.co.uk Birörnekdahaverelim... Bildiğiniz gibi, print() fonksiyonu, kendisine verilen parametreler arasına birer boşluk yerleştirir: >>> print(’’, ’.’, ’com’) . com Bizbuöğeleribirbirinebitiştirmekiçinşöylebiryolizleyebileceğimizibiliyoruz: >>> print(’’, ’.’, ’com’, sep=’’) .com İşteaynıetkiyi\bkaçışdizisinikullanarakdaeldeedebiliriz: >>> print(’’, ’\b.’, ’\bcom’) .com Gördüğünüzgibi,\bkaçışdizisi,‘.’ve‘com’parametrelerindenönceimlecibirerkaraktersola kaydırdığıiçin,parametrelerarasındakiboşlukkarakterleriortadankalktı. Bukaçışdizisinikullanarakşöylegereksizişlerpeşindedekoşabilirsiniz: >>> print(’\b\b\bsn’) istisna 7.7. İmleçKaydırma(\b) 93 PythonBelgeleri,Yayım4.1.3 Burada \b kaçış dizisini üst üste birkaç kez kullanarak imleci birkaç karakter sola kaydırdık ve‘sn’harflerini‘hz’harflerininüzerinebindirdik.Böylece‘’kelimesi‘istisna’kelimesine dönüşmüşoldu... Daha fazla uzatmadan, bu kaçış dizisinin Python’da çok nadir kullanıldığı bilgisini vererek yolumuzadevamedelim... 7.8 Küçük Unicode (\u) Tıpkı bundan önceki kaçış dizileri gibi, karakter dizileri içindeki varlığı konusunda dikkatli olmamızgerekenbirbaşkakaçışdiziside\uadlıkaçışdizisidir.Eğerbukaçışdizisinitanımaz vedikkatlikullanmazsak,yazdığımızprogramlartespitetmesiçokgüçhatalarüretebilir. Örneğinşöylebirçıktıvermekistediğinizidüşünün: Dosyakonumu:C:\users\zeynep\gizli\dosya.txt BuçıktıyınormalyollardanvermeyeçalışırsakPythonbizebirhatamesajıgösterecektir: >>> print("Dosya konumu: C:\users\zeynep\gizli\dosya.txt") File "<stdin>", line 1 SyntaxError: (unicode error) ’unicodeescape’ codec can’t decode bytes in position 16-18: truncated \uXXXX escape Belki sağda solda ‘UNICODE’ diye bir şey duymuşsunuzdur. Eğer şimdiye kadar böyle bir şey duymadıysanız veya duyduysanız bile ne olduğunu bilmiyorsanız hiç ziyanı yok. Birkaç bölüm sonra bunun ne anlama geldiğini bütün ayrıntılarıyla anlatacağız. Biz şimdilik sadece şunubilelim:UNICODE,karakterlerin,harflerin,sayılarınvebilgisayarekranındagördüğümüz ötekibütünişaretlerinherbiriiçintekvebenzersizbirnumaranıntanımlandığıbirsistemdir. Bu sistemde, ‘kod konumu’ (code point) adı verilen bu numaralar özel bir şekilde gösterilir. Örneğin‘ı’harfiUNICODEsistemindeşuşekildetemsiledilir: u+0131 Aynışekilde‘a’harfibusistemdeşukodkonumuilegösterilir: u+0061 Pythonprogramlamadilindeise,yukarıdakikodkonumudüzenişöylegösterilir: \\u0131 Gördüğünüz gibi, Python UNICODE sistemindeki her bir kod konumunu gösterebilmek için, önce\uşeklindebirkaçışdizisitanımlıyor,ardındanUNICODEsisteminde+işaretindensonra gelen sayıyı bu kaçış dizisinin hemen sağına ekliyor. Gelin kendi kendimize birkaç deneme çalışmasıyapalım: >>> ’\u0130’ ’İ’ (sonrakisayfayadevam) 94 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> ’\u0070’ ’p’ >>> "\ufdsf" File "<stdin>", line 1 SyntaxError: (unicode error) ’unicodeescape’ codec can’t decode bytes in position 0-4: truncated \uXXXX escape Gördüğünüz gibi, eğer \u kaçış dizisinden sonra doğru bir kod konumu belirtmezsek Python bizebirhatamesajıgösteriyor... Buhatamesajının,birazönceprint("Dosya konumu: C:\users\zeynep\gizli\dosya.txt") kodunu yazdıktan sonra aldığımız hata ile aynı olduğuna dikkat edin. Tıpkı \ufdsf örneğinde olduğu gibi, \users ifadesi de varolan bir UNICODE kod konumuna karşılık gelmediği için, Python’ınhatavermektenbaşkaçaresikalmıyor. Bizbuörnekte‘users’kelimesinikullanmayaçalışıyoruz,ama‘u’harfindenhemenöncegelen \ kaçış dizisi nedeniyle, hiç farkında olmadan Python açısından önemli bir karakter dizisi (\u) meydanagetirmişoluyoruz.Oyüzden,böylecansıkıcıhatalarlakarşılaşmamakiçinolasıkaçış dizilerinekarşıherzamanuyanıkolmamızgerekiyor. Peki biz bu kaçış dizisi yüzünden, yazdığımız programlarda Dosya konumu: C:\users\zeynep\gizli\dosya.txt”)gibibirçıktıveremeyecekmiyiz? Verebileceğimizivebununbiryoluyordamıolduğunubiliyorsunuz: >>> print("Dosya konumu: C:\\users\\zeynep\\gizli\\dosya.txt") Dosya konumu: C:\users\zeynep\gizli\dosya.txt Gördüğünüz gibi, karakter dizisi içinde geçen bütün \ işaretlerini çiftleyerek sorunumuzu çözdük.Buradakigibibirsorunlakarşılaşmamakiçin,dizinadlarınıayırırkenterstaksimişareti yerinedüztaksimişaretinikullanmayıdatercihedebilirsiniz: >>> print("Dosya konumu: C:/users/zeynep/gizli/dosya.txt") Birazsonrabusorunuhalletmeninüçüncüvedahakolaybiryöntemindendahasözedeceğiz. Amabizşimdilikbukaçışdizisinibirkenarabırakıpbaşkabirkaçışdizisiniincelemeyegeçelim. 7.9 Büyük Unicode (\U) Bu kaçış dizisi biraz önce gördüğümüz \u adlı kaçış dizisiyle hemen hemen aynı anlama gelir. Bu kaçış dizisi de, tıpkı \u gibi, UNICODE kod konumlarını temsil etmek için kullanılır. Ancak U ile gösterilen kod konumları u ile gösterilenlere göre biraz daha uzundur. Örneğin, hatırlarsanız u kaçış dizisini kullanarak ‘ı’ harfinin UNICODE kod konumunu şöyle temsil ediyorduk: 7.9. BüyükUnicode(\U) 95 PythonBelgeleri,Yayım4.1.3 >>> ’\u0131’ ’ı’ Eğer aynı kod konumunu U adlı kaçış dizisi ile göstermek istersek şöyle bir şey yazmamız gerekir: >>> ’\U00000131’ Gördüğünüz gibi, burada \U kaçış dizisinden sonra gelen kısım toplam 8 haneli bir sayıdan oluşuyor. u kaçış dizisinde ise bu kısmı toplam 4 haneli bir sayı olarak yazıyorduk. İşte \u kaçış dizisi ile U kaçış dizisi arasındaki fark budur. u kaçış dizisi hakkında söylediğimiz öteki herşeyUkaçışdizisiiçindegeçerlidir. 7.10 Uzun Ad (\N) UNICODEsistemiileilgilibirbaşkakaçışdiziside\Nadlıkaçışdizisidir. Dediğimizgibi,UNICODEsistemineilişkinayrıntılardanilerleyenderslerdesözedeceğiz,ama busistemleilgiliufakbirbilgidahaverelim. UNICODE sisteminde her karakterin tek ve benzersiz bir kod konumu olduğu gibi, tek ve benzersizbirdeuzunadıvardır.Örneğin‘a’harfininUNICODEsistemindekiuzunadışudur: LATIN SMALL LETTER A BirkarakterinUNICODEsistemindekiuzunadınıöğrenmekiçinunicodedataadlıbirmodülden yararlanabilirsiniz: >>> import unicodedata >>> unicodedata.name(’a’) LATIN SMALL LETTER A >>> unicodedata.name(’Ş’) LATIN CAPITAL LETTER S WITH CEDILLA Bu arada, daha önce de söylediğimiz gibi, bu ‘modül’ kavramına şimdilik takılmayın. İlerde modülleri ayrıntılı olarak inceleyeceğiz. Şimdilik unicodedata denen şeyin, (tıpkı daha önce örneklerini gördüğümüz os, sys ve keyword gibi) bir modül olduğunu ve bu modül içindeki name adlı bir fonksiyonu kullanarak, parantez içinde belirttiğimiz herhangi bir karakterin UNICODEsistemindekiuzunadınıeldeedebileceğimizibilelimyeter. İşte \N kaçış dizisi bu uzun isimleri, Python programlarımızda kullanma imkanı verir bize. Bu kaçış dizisini, karakterlerin UNICODE sistemindeki uzun adları ile birlikte kullanarak asıl karakterlerieldeedebiliriz.Dikkatlicebakın: >>> print("\N{LATIN SMALL LETTER A}") a (sonrakisayfayadevam) 96 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> print("\N{LATIN CAPITAL LETTER S WITH CEDILLA}") Ş >>> print("\Nisan") File "<stdin>", line 1 SyntaxError: (unicode error) ’unicodeescape’ codec can’t decode bytes in position 0-1: malformed \N character escape Gördüğünüz gibi, herhangi bir karşılığı olmayan bir uzun ad belirttiğimizde Python bize bir hata mesajı gösteriyor. Çünkü Python \N kaçış dizisinin hemen ardından { işaretinin getirilmesinivesonradaUNICODEsistemidahilindegeçerlibiruzunadbelirtilmesinibekliyor. Yukarıdaki örnekte \N kaçış dizisinden sonra { işareti yok. Zaten \N kaçış dizisinin hemen ardından gelen ‘isan’ ifadesi de doğru bir uzun ada işaret etmiyor. Dolayısıyla da Python’ın bizehatamesajıgöstermektenbaşkaçaresikalmıyor... \u, \U ve \N kaçış dizileri, UNICODE sistemi ile ilgili çalışmalar yapmak isteyen programcılar için Python programlama dilinin sunduğu faydalı araçlardan yalnızca birkaçıdır. Ancak bu araçlarınsizinişinizeyaramayacağınıasladüşünmeyin.Zira\u,\Uve\Nkaçışdizileriileilgili yukarıdaki durum hiç beklemediğiniz bir anda sizi de vurabilir. Çünkü bu kaçış dizilerinin oluşturduğuriskhiçdeöylenadirkarşılaşılacakbirsorundeğildir. Bildiğiniz gibi Windows 7’de kullanıcının dosyalarını içeren dizin adı C:\Users\kullanıcı_adı şeklinde gösteriliyor. Dolayısıyla Windows kullananlar UNICODE kaçış dizilerinden kaynaklanan bu tuzağa her an düşebilir. Ya da eğer adınız ‘u’ veya ‘n’ harfi ile başlıyorsa yinebutuzağadüşmeihtimalinizepeyyüksekolacak,C:\Users\umutveyaC:\Users\Nihatgibi birdizinadıbelirtirkençokdikkatliolmanızgerekecektir.Ziraözellikledosyalarüzerindeişlem yaparken,butürdizinadlarınısıksıkkullanmakdurumundakalacaksınız.Buyüzden,alelade bir kelime yazdığınızı zannederken hiç farkında olmadan bir kaçış dizisi tanımlıyor olma ihtimaliniherzamangözönündebulundurmalıvebunauygunönlemlerialmışolmalısınız. 7.11 Onaltılı Karakter (\x) ‘x’harfide\işaretiilebirleştiğindeözelanlamkazanarakbirkaçışdizisimeydanagetirir. \x kaçış dizisini kullanarak, onaltılı (hexadecimal) sayma sistemindeki bir sayının karakter karşılığınıgösterebilirsiniz.Dikkatlicebakın: >>> "\x41" ’A’ Onaltılı sayma sistemindeki 41 sayısı ‘A’ harfine karşılık gelir. Eğer hangi karakterlerin hangi sayılara karşılık geldiğini merak ediyorsanız https://ascii.cl/ adresindeki tabloyu inceleyebilirsiniz. Bu tabloda ‘hex’ sütunu altında gösterilen sayılar onaltılı sayılar olup, ‘symbol’ sütununda gösterilen karakterlere karşılık gelirler. Örneğin ‘hex’ sütunundaki 4E sayısı‘symbol’sütunundaki‘N’harfinekarşılıkgelir.BudurumuPython’ladateyitedebilirsiniz: 7.11. OnaltılıKarakter(\x) 97 PythonBelgeleri,Yayım4.1.3 >>>"\x4E" N Eğer sayılarla karakterler arasındaki bağlantının tam olarak ne olduğunu bilmiyorsanız hiç endişe etmeyin. Birkaç bölüm sonra sayılarla karakterler arasında nasıl bir bağ olduğunu gayet ayrıntılı bir şekilde anlatacağız. Biz şimdilik yalnızca \x karakter dizisinin özel bir kaçış dizisinekarşılıkgeldiğinivebukaçışdizisinikarakterdizileriiçindekullanırkendikkatliolmamız gerektiğinibilelimyeter: >>> print("C:\Users\Ayşe\xp_dosyaları") File "<stdin>", line 1 SyntaxError: (unicode error) ’unicodeescape’ codec can’t decode bytes in position 2-4: truncated \UXXXXXXXX escape Gördüğünüz gibi, Python \x ifadesinden sonra onaltılı bir sayı belirtmenizi bekliyor. Halbuki bizburada\xifadesini‘xp_dosyaları’adlıdizinigösterebilmekiçinkullanmıştık.Amagörünüşe göreyanlışlıklaPythoniçinözelbiranlamifadeedenbirkarakterdizisioluşturmuşuz... 7.12 Etkisizleştirme (r) Dediğimiz gibi, Python’daki en temel kaçış dizisi \ işaretidir. Bu işaret bazı başka harflerle birleşerekyenikaçışdizilerideoluşturabilir. Python’da \ işaretinin dışında temel bir kaçış dizisi daha bulunur. Bu kaçış dizisi ‘r’ harfidir. Şimdibukaçışdizisininnasılkullanılacağınıveneişeyaradığınıinceleyelim: Şöylebirçıktıvermekistediğimizidüşünün: Kurulum dizini: C:\aylar\nisan\toplam masraf Bildiğimizyoldanbuçıktıyıvermeyeçalışırsaknelerolacağınıadınızgibibiliyorsunuz: >>> print("Kurulum dizini: C:\aylar\nisan\toplam masraf") Kurulum dizini: C:ylar isan oplam masraf (cid:242) Not EğerWindowsüzerindeçalışıyorsanızbukomutuverdiktensonrabir!bip!sesideduymuş olabilirsiniz... Python tabii ki, karakter dizisi içinde geçen ‘\aylar’, ‘\nisan’, ve ‘\toplam masraf’ ifadelerinin ilk karakterlerini yanlış anladı! \a, \n ve \t gibi ifadeler Python’ın gözünde birer kaçış dizisi. Dolayısıyla Python \a karakterlerini görünce bir!bip! sesi çıkarıyor, \n karakterlerini görünce satırbaşınageçiyorve\tkarakterlerinigörüncedeTabtuşunabasılmışgibibirtepkiveriyor. Sonuçolarakdayukarıdakigibibirçıktıüretiyor. Dahaöncebudurumuşöylebirkodyazarakengellemiştik: 98 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 >>> print("Kurulum dizini: C:\\aylar\\nisan\\toplam masraf") Kurulum dizini: C:\aylar\nisan\toplam masraf Burada, \ işaretlerinin her birini çiftleyerek sorunun üstesinden geldik. Yukarıdaki yöntem doğru ve kabul görmüş bir çözümdür. Ama bu sorunun üstesinden gelmenin çok daha basit vepratikbiryoluvar.Bakalım: >>> print(r"Kurulum dizini: C:\aylar\nisan\toplam masraf") Kurulum dizini: C:\aylar\nisan\toplam masraf Gördüğünüz gibi, karakter dizisinin baş kısmının dış tarafına bir adet r harfi yerleştirerek sorunun üstesinden geliyoruz. Bu kaçış dizisinin, kullanım açısından öteki kaçış dizilerinden farklı olduğuna dikkat edin. Öteki kaçış dizileri karakter dizisinin içinde yer alırken, bu kaçış dizisikarakterdizisinindışınayerleştiriliyor. Bukaçışdizisinintamolaraknasılişlediğinigörmekiçindilersenizbirörnekdahaverelim: >>> print("Kaçış dizileri: \, \n, \t, \a, \\, r") Kaçış dizileri: \, , , , \, r Burada da Python bizim yapmak istediğimiz şeyi anlayamadı ve karakter dizisi içinde geçen kaçış dizilerini doğrudan ekrana yazdırmak yerine bu kaçış dizilerinin işlevlerini yerine getirmesineizinverdi.Tıpkıbirazöncekiörnekteolduğugibi,istersekkaçışdizileriniçiftleyerek busorunuaşabiliriz: >>> print("Kaçış dizileri: \\, \\n, \\t, \\a, \\\, r") Kaçış dizileri: \, \n, \t, \a, \\, r Amatabiikibununçokdahakolaybiryöntemiolduğunubiliyorsunuz: >>> print(r"Kaçış dizileri: \, \n, \t, \a, \\, r") Kaçış dizileri: \, \n, \t, \a, \\, r Gördüğünüz gibi, karakter dizisinin başına getirdiğimiz r kaçış dizisi, karakter dizisi içinde geçen kaçış dizilerinin işlevlerini yerine getirmesine engel olarak, istediğimiz çıktıyı elde etmemizisağlıyor. Buaradabukaçışdizisini,dahaönceöğrendiğimiz\radlıkaçışdizisiilekarıştırmamayadikkat ediyoruz. Python’dakibütünkaçışdizilerindensözettiğimizegöre,konuyukapatmadanönceönemlibir ayrıntıdansözedelim. Python’da karakter dizilerinin sonunda sadece çift sayıda \ işareti bulunabilir. Tek sayıda \ işareti kullanıldığında karakter dizisini bitiren tırnak işareti etkisizleşeceği için çakışma sorunu ortaya çıkar. Bu etkisizleşmeyi, karakter dizisinin başına koyduğunuz ‘r’ kaçış dizisi deengelleyemez.Yani: 7.12. Etkisizleştirme(r) 99 PythonBelgeleri,Yayım4.1.3 >>> print("Kaçış dizisi: \") Bu şekilde bir tanımlama yaptığımızda Python bize bir hata mesajı gösterir. Çünkü kapanış tırnağının hemen öncesine yerleştirdiğimiz \ kaçış dizisi, Python’ın karakter dizisini kapatan tırnak işaretini görmezden gelmesine yol açarak bu tırnağı etkisizleştiriyor. Böylece sanki karakterdizisinitanımlarkenkapanıştırnağınıhiçyazmamışızgibibirsonuçortayaçıkıyor: >>> print("Kaçış dizisi: \") File "<stdin>", line 1 print("Kaçış dizisi: \") ^ SyntaxError: EOL while scanning string literal Üstelikbudurumu,radlıkaçışdizisideengelleyemiyor: >>> print(r"Kaçış dizisi: \") File "<stdin>", line 1 print(r"Kaçış dizisi: \") ^ SyntaxError: EOL while scanning string literal Çözüm olarak birkaç farklı yöntemden yararlanabilirsiniz. Mesela karakter dizisini kapatmadan önce karakter dizisinin sonundaki \ işaretinin sağına bir adet boşluk karakteri yerleştirmeyideneyebilirsiniz: >>> print("Kaçış dizisi: \ ") Veyakaçışdizisiniçiftleyebilirsiniz: >>> print("Kaçış dizisi: \\") Yadakarakterdizisibirleştirmeyöntemlerindenherhangibirinikullanabilirsiniz: >>> print("Kaçış dizisi: " + "\\") >>> print("Kaçış dizisi:", "\\") >>> print("Kaçış dizisi: " "\\") BöylebirdurumlailkkezkarşılaştığınızdabununPythonprogramlamadilindenkaynaklanan birhataolduğunudüşünebilirsiniz,ancakbudurumPython’ınresmiinternetsitesinde‘Sıkça SorulanSorular’bölümünealınacakkadarönemlibirtasarımtercihidir:https://docs.python. org/2/faq/design.html#why-can-t-raw-strings-r-strings-end-with-a-backslash 100 Bölüm7. KaçışDizileri PythonBelgeleri,Yayım4.1.3 7.13 Sayfa Başı (\f) \fartıkgünümüzdepekkullanılmayanbirkaçışdizisidir.Bukaçışdizisiningörevi,özellikleeski yazıcılarda, bir sayfanın sona erip yeni bir sayfanın başladığını göstermektir. Dolayısıyla eski modelyazıcılar,bukarakterigördüklerinoktadamevcutsayfayısonaerdiripyenibirsayfaya geçer. Bukaçışdizisinintamolarakneişeyaradığınıtestetmekiçinşukodlarıçalıştırın: >>> f = open("deneme.txt", "w") >>> print("deneme\fdeneme", file=f) >>> f.close() Şimdi bu kodlarla oluşturduğunuz deneme.txt adlı dosyayı LibreOffice veya Microsoft Word gibi bir programla açın. ‘deneme’ satırlarının iki farklı sayfaya yazdırıldığını göreceksiniz. Bu arada,eğerMicrosoftWorddosyayıaçarkenbirhatamesajıgösterirse,ohatamesajınabirkaç kez‘tamam’diyerekhatapenceresinikapatın.Dosyanormalbirşekildeaçılacaktır. Dediğimiz gibi, bu kaçış dizisi artık pek kullanılmıyor. Ama yine de bu kaçış dizisine karşı da uyanık olmalısınız. Çünkü bu kaçış dizisi de beklemediğiniz çıktılar almanıza yol açabilir. Meselaşuörneğebirbakalım: >>> "\fırat" ’\x0cırat’ Gördüğünüz gibi, siz aslında ‘\fırat’ yazmak isterken, Python bu kelimenin baş tarafındaki \f karakterdizisinibirkaçışdizisiolarakdeğerlendiriponagörebirçıktıverdi. Bütün bu anlattıklarımızın ardından, kaçış dizilerinin, birleştirildikleri karakterlerin farklı bir anlam yüklenmesini sağlayan birtakım işaretler olduğunu anlıyoruz. Örneğin \ işareti ‘ (tek tırnak)işaretiilebirarayagelerek,tektırnakişaretininkarakterdizisitanımlamadışındabaşka bir anlam yüklenmesini sağlıyor. Aynı şekilde yine \ işareti “ (çift tırnak) işareti ile birleşerek çift tırnak işaretinin de karakter dizisi tanımlama dışında bir anlama kavuşmasını sağlıyor. Böylecetırnakişaretlerinikarakterdizileriiçinderahatlıklakullanabiliyoruz. Ya da yine \ işareti ‘n’ harfi ile bir araya gelip, bu harfin satır başına geçilmesini sağlayan bir kaçışdizisioluşturmasınımümkünkılıyor.Veyaaynıişaret‘t’harfiylebirleşip,öğelerarasında sekme oluşturulmasını sağlayabiliyor. Bu araçlar sayesinde ekrana yazdırdığımız bir metnin akışınıkontroletmeimkanınakavuşuyoruz. 7.14 Kaçış Dizilerine Toplu Bakış Biraz sonra bu önemli konuyu kapatacağız. Ama dilerseniz kapatmadan önce, bu bölümde öğrendiğimizkaçışdizilerinişöylebirtoplucagörelim: 7.13. SayfaBaşı(\f) 101 PythonBelgeleri,Yayım4.1.3 tabularytabulary KaçışDizisi Anlamı \’ Karakterdizisiiçindetektırnakişaretinikullanabilmemizisağlar. \” Karakterdizisiiçindeçifttırnakişaretinikullanabilmemizisağlar. \\ Karakterdizisiiçinde\işaretinikullanabilmemizisağlar. \n Yenibirsatırageçmemizisağlar. \t Karakterlerarasındasekmeboşluğubırakmamızısağlar. \u UNICODEkodkonumlarınıgösterebilmemizisağlar. \U UNICODEkodkonumlarınıgösterebilmemizisağlar. \N KarakterleriUNICODEadlarınagörekullanabilmemizisağlar. \x Onaltılısistemdekibirsayınınkarakterkarşılığınıgösterebilmemizisağlar. \a Destekleyensistemlerde,kasahoparlöründenbir‘bip’sesiverilmesinisağlar. \r Aynısatırınbaşınadönülmesinisağlar. \v Destekleyensistemlerdedüşeysekmeoluşturulmasınısağlar. \b İmlecinsoladoğrukaydırılmasınısağlar \f Yenibirsayfayageçilmesinisağlar. r Karakterdizisiiçindekaçışdizilerinikullanabilmemizisağlar. Kaçış dizileriyle ilgili son olarak şunu söyleyebiliriz: Kaçış dizileri, görmezden gelebileceğiniz, ‘öğrenmesem de olur,’ diyebileceğiniz önemsiz birtakım işaretler değildir. Bu konu boyunca verdiğimizörneklerdendegördüğünüzgibi,kaçışdizileri,kullanıcıyagöstereceğinizmetinlerin biçimini doğrudan etkiliyor. Bütün bu örnekler, bu kaçış dizilerinin yersiz veya yanlış kullanılmasının ya da bunların bir metin içinde gözden kaçmasının, yazdığınız programların hataveripçökmesine,yaniprogramınızındurmasınasebepolabileceğinidegösteriyorbize. Böylece bir bölümü daha bitirmiş olduk. Artık Python’la ‘gerçek’ programlar yazmamızın önündehiçbirengelkalmadı. 102 Bölüm7. KaçışDizileri 8 BÖLÜM Programları Kaydetme ve Çalıştırma Bu noktaya kadar bütün işlerimizi Python’ın etkileşimli kabuğu üzerinden hallettik. Her ne kadar etkileşimli kabuk son derece kullanışlı bir ortam da olsa, bizim asıl çalışma alanımız değildir.Dahaöncededediğimizgibi,etkileşimlikabuğugenellikleufaktefekPythonkodlarını test etmek için kullanacağız. Ama asıl programlarımızı tabii ki etkileşimli kabuğa değil, programdosyasınayazacağız. Ne dedik? Özellikle küçük kod parçaları yazıp bunları denemek için etkileşimli kabuk mükemmel bir ortamdır. Ancak kodlar çoğalıp büyümeye başlayınca bu ortam yetersiz gelmeye başlayacaktır. Üstelik tabii ki yazdığınız kodları bir yere kaydedip saklamak isteyeceksiniz.İşteburadametindüzenleyicilerdevreyegirecek. Python kodlarını yazmak için istediğiniz herhangi bir metin düzenleyiciyi kullanabilirsiniz. Hatta Notepad bile olur. Ancak Python kodlarını ayırt edip renklendirebilen bir metin düzenleyiciileyolaçıkmakherbakımdanhayatınızıkolaylaştıracaktır. (cid:242) Not Python kodlarınızı yazmak için Microsoft Word veya OpenOffice.Org OOWriter gibi, belgeleriikili(binary)düzendekaydedenprogramlaruygundeğildir.Kullanacağınızmetin düzenleyici,belgelerinizidüzmetin(plaintext)biçimindekaydedebilmeli. Biz bu bölümde farklı işletim sistemlerinde, metin düzenleyici kullanılarak Python programlarınınnasılyazılacağınıvebunlarınnasılçalıştırılacağınıtektekinceleyeceğiz. Daha önce de söylediğimiz gibi, hangi işletim sistemini kullanıyor olursanız olun, hem WindowshemdeGNU/Linuxbaşlığıaltındayazılanlarıokumalısınız. DilersenizönceGNU/Linuxilebaşlayalım: 103 PythonBelgeleri,Yayım4.1.3 8.1 GNU/Linux Eğer kullandığınız sistem GNU/Linux’ta Unity veya GNOME masaüstü ortamı ise başlangıç düzeyiiçinGeditadlımetindüzenleyiciyeterliolacaktır. Eğer kullandığınız sistem GNU/Linux’ta KDE masaüstü ortamı ise Kwrite veya Kate adlı metin düzenleyicilerden herhangi birini kullanabilirsiniz. Şu aşamada kullanım kolaylığı ve sadeliği nedeniyleKwriteönerilebilir. İşeyenibirGeditbelgesiaçarakbaşlayalım.YenibirGeditbelgesiaçmanınenkolayyoluAlt+F2 tuşlarınabastıktansonraçıkanekranda: gedit yazıpEnterdüğmesinebasmaktır. EğerGedityerinemeselaKwritekullanıyorsanız,yenibirKwritebelgesioluşturmakiçinAlt+F2 tuşlarınabastıktansonra: kwrite komutunu vermelisiniz. Elbette kullanacağınız metin düzenleyiciye, komut vermek yerine, dağıtımınızınmenüleriaracılığıyladaulaşabilirsiniz. Pythonkodlarımızı,karşımızaçıkanbuboşmetindosyasınayazıpkaydedeceğiz. Aslında kodları metin dosyasına yazmakla etkileşimli kabuğa yazmak arasında çok fazla fark yoktur.Dilersenizhemenbirörnekverereknedemekistediğimizianlatmayaçalışalım: 1. Boş bir Gedit ya da Kwrite belgesi açıyoruz ve bu belgeye şu kodları eksiksiz bir şekilde yazıyoruz: tarih = "02.01.2012" gün = "Pazartesi" vakit = "öğleden sonra" print(tarih, gün, vakit, "buluşalım", end=".\n") 2.Bukodlarıyazıpbitirdiktensonradosyayımasaüstünerandevu.pyadıylakaydedelim. 3.Sonraişletimsistemimizeuygunbirşekildekomutsatırınaulaşalım. 4. Ardından komut satırı üzerinden masaüstüne gelelim. (Bunun nasıl yapılacağını hatırlıyorsunuz,değilmi?) 5.Sonolarakşukomutlaprogramımızıçalıştıralım: python3 randevu.py Şöylebirçıktıalmışolmalıyız: 02.01.2012 Pazartesi öğleden sonra buluşalım. Eğerbuçıktıyerinebirhatamesajıalıyorsanızbununbirkaçfarklısebebiolabilir: 1. Kodlarda yazım hatası yapmış olabilirsiniz. Bu ihtimali bertaraf etmek için yukarıdaki kodlarlakendiyazdığınızkodlarıdikkatlicekarşılaştırın. 104 Bölüm8. ProgramlarıKaydetmeveÇalıştırma PythonBelgeleri,Yayım4.1.3 2. Kodlarınızı kaydettiğiniz randevu.py adlı dosyanın adını yanlış yazmış olabilirsiniz. Dolayısıyla python3 randevu.py komutu, var olmayan bir dosyaya atıfta bulunuyor olabilir. 3. python3 randevu.py komutunu verdiğiniz dizin konumu ile randevu.py dosyasının bulunduğu dizin konumu birbirinden farklı olabilir. Yani siz randevu.py dosyasını masaüstüne kaydetmişsinizdir, ama python3 randevu.py komutunu yanlışlıkla başka birdizinaltındaveriyorolabilirsiniz.Buihtimaliortadankaldırmakiçin,öncekiderslerde öğrendiğimiz yöntemleri kullanarak hangi dizin altında bulunduğunuzu kontrol edin. O anda içinde bulunduğunuz dizinin içeriğini listeleyerek, randevu.py dosyasının orada görünüp görünmediğini kontrol edebilirsiniz. Eğer program dosyanız bu listede görünmüyorsa,elbettepython3 randevu.pykomutuçalışmayacaktır. 4. Geçen derslerde anlattığımız şekilde Python3’ü kaynaktan root haklarıyla derlemenize rağmen, derleme sonrasında /usr/bin/ dizini altına python3 adlı bir sembolik bağ oluşturmadığınıziçinpython3komutuçalışmıyorolabilir. 5. EğerPython3’üyetkisizkullanıcıolarakderlediyseniz,$HOME/python/bin/dizinialtında hem python3 adlı bir sembolik bağ oluşturmuş, hem de $HOME/python/bin/ dizinini YOL’a(PATH)eklemişolmanızgerekirkenbunlarıyapmamışolabilirsiniz. 6. Asla unutmayın, Python’ın etkileşimli kabuğunu başlatmak için hangi komutu kullanıyorsanız, randevu.py dosyasını çalıştırmak için de aynı komutu kullanacaksınız. Yani eğer Python’ın etkileşimli kabuğunu python3.7 gibi bir komutla çalıştırıyorsanız, programınızı da python3.7 randevu.py şeklinde çalıştırmanız gerekir. Aynı şekilde, eğer etkileşimli kabuğu mesela python (veya py3) gibi bir komutla çalıştırıyorsanız, programınızı da python randevu.py (veya py3 randevu.py) şeklinde çalıştırmalısınız. Neticedeetkileşimlikabuğuçalıştırırkende,birprogramdosyasıçalıştırırkendeaslında temel olarak Python programlama dilini çalıştırmış oluyorsunuz. Python programını çalıştırırken bir dosya adı belirtmezseniz, yani Python’ı başlatan komutu tek başına kullanırsanız etkileşimli kabuk çalışmaya başlar. Ama eğer Python’ı başlatan komutla birlikte bir program dosyası ismi de belirtirseniz, o belirttiğiniz program dosyası çalışmayabaşlar. Kodlarınızıdüzgünbirşekildeçalıştırabildiğinizivarsayarakyolumuzadevamedelim... Gördüğünüz gibi, kod dosyamızı çalıştırmak için python3 komutundan yararlanıyoruz. Bu arada tekrar etmekte fayda var: Python’ın etkileşimli kabuğunu çalıştırmak için hangi komutukullanıyorsanız,dosyayakaydettiğinizprogramlarınızıçalıştırmakiçindeaynıkomutu kullanacaksınız. GelelimWindowskullanıcılarına... 8.2 Windows Daha önce de söylediğimiz gibi, Python kodlarımızı yazmak için istediğimiz bir metin düzenleyiciyikullanabiliriz.HattaNotepad’ibilekullansakolur.AncakNotepad’denbirazdaha gelişmişbirmetindüzenleyiciilebaşlamakişinizikolaylaştıracaktır. Python programlama dilini öğrenmeye yeni başlayan Windows kullanıcıları için en uygun metindüzenleyiciIDLE’dır.Başlat>TümProgramlar>Python3.7>IDLE(PythonGUI)yolunu takipederekIDLE’aulaşabilirsiniz. IDLE’ıaçtığınızdaşöylebirekranlakarşılaşacaksınız: 8.2. Windows 105 PythonBelgeleri,Yayım4.1.3 Aslında bu ekran size bir yerlerden tanıdık geliyor olmalı. Dikkat ederseniz beyaz ekranın en sonunda bordo renkli bir >>> işareti var. Evet, tahmin ettiğiniz gibi, burası aslında Python’ın etkileşimli kabuğudur. Yani o siyah etkileşimli kabuk ekranında ne yapabilirseniz burada da aynı şeyi yapabilirsiniz. Dilerseniz kendi kendinize bazı denemeler yapın. Ama şu anda biz IDLE’ınbuözelliğinideğil,metindüzenleyiciolmaözelliğinikullanacağız.Oyüzdenyolumuza devamediyoruz. (cid:242) Not Dediğimizgibi,yukarıdagörünenekranaslındaPython’ınetkileşimlikabuğudur.Dolayısıyla birazsonragöstereceğimizkodlarıburayayazmayacağız.Pythonprogramlamadilineyeni başlayanların en sık yaptığı hatalardan biri de, kaydetmek istedikleri kodları yukarıda görünen ekrana yazmaya çalışmalarıdır. Unutmayın, Python’ın etkileşimli kabuğunda ne yapabiliyorsanız, IDLE’ı açtığınızda ilk karşınıza çıkan ekranda da onu yapabilirsiniz. Python’ın etkileşimli kabuğunda yazdığınız kodlar etkileşimli kabuğu kapattığınızda nasıl kayboluyorsa,yukarıdakiekranayazdığınızkodlardaIDLE’ıkapattığınızdakaybolur... BiröncekiekrandasolüstköşedeFile[Dosya]menüsügörüyorsunuz.Orayatıklayınvemenü içindekiNewWindow[YeniPencere]düğmesinebasın.Şöylebirekranlakarşılaşacaksınız: İştePythonkodlarımızıbubeyazekranayazacağız.Şimdibuekranaşusatırlarıyazalım: tarih = "02.01.2012" gün = "Pazartesi" vakit = "öğleden sonra" print(tarih, gün, vakit, "buluşalım", end=".\n") Bunoktadansonrayapmamızgerekenşeydosyamızıkaydetmekolacak.BununiçinFile>Save asyolunutakipederekprogramımızımasaüstünerandevu.pyadıylakaydediyoruz. Şu anda programımızı yazdık ve kaydettik. Artık programımızı çalıştırabiliriz. Bunun için IDLE’da Run > Run Module yolunu takip etmeniz veya kısaca F5 tuşuna basmanız yeterli olacaktır.Buikiyöntemdenbirinikullanarakprogramınızıçalıştırdığınızdaşöylebirçıktıelde edeceksiniz: 02.01.2012 Pazartesi öğleden sonra buluşalım. Tebrikler! İlk Python programınızı yazıp çalıştırdınız... Eğer çalıştıramadıysanız veya yukarıdaki çıktı yerine bir hata mesajı aldıysanız muhtemelen kodları yazarken yazım hatasıyapmışsınızdır.Kendiyazdığınızkodlarıburadakikodlarladikkatlicekarşılaştırıptekrar deneyin. 106 Bölüm8. ProgramlarıKaydetmeveÇalıştırma PythonBelgeleri,Yayım4.1.3 Şimdigelinistersenizyukarıdayazdığımızkodlarışöylebirkısacainceleyelim. Programımızda üç farklı değişken tanımladığımıza dikkat edin. Bu değişkenler tarih, gün ve vakit adlı değişkenlerdir. Daha sonra bu değişkenleri birbiriyle birleştiriyoruz. Bunun için print() fonksiyonundan nasıl yararlandığımızı görüyorsunuz. Ayrıca print() fonksiyonunu kullanış biçimimize de dikkat edin. Buradaki end parametresinin anlamını ve bunun ne işe yaradığını artık gayet iyi biliyorsunuz. end parametresi yardımıyla cümlenin en sonuna bir adetnoktayerleştirip,\nadlıkaçışdizisiyardımıyladabiraltsatırageçiyoruz. BöylecebasitbirPythonprogramınıntemelolaraknasılyazılıpbirdosyayakaydedileceğinive buprogramınnasılçalıştırılacağınıöğrenmişolduk. 8.2. Windows 107 9 BÖLÜM Çalışma Ortamı Tavsiyesi Bu bölümde, Python programları geliştirirken rahat bir çalışma ortamı elde edebilmek için yapmanızgerekenlerisıralayacağız.ÖncelikleWindowskullanıcılarındanbaşlayalım. 9.1 Windows Kullanıcıları Windows’ta bir Python programı yazıp kaydettikten sonra bu programı komut satırından çalıştırabilmek için, MS-DOS’u açıp, öncelikle cd komutuyla programın bulunduğu dizine ulaşmamızgerekir.İlgilidizineulaştıktansonraprogramımızıpython program_adıkomutuyla çalıştırabiliriz. Ancak bir süre sonra, programı çalıştırmak için her defasında programın bulunduğudizineulaşmayaçalışmaksıkıcıbirhalalacaktır.Amabukonudaçaresizdeğiliz. Windows 7, istediğimiz dizin altında bir MS-DOS ekranı açabilmemiz için bize çok güzel bir kolaylık sunuyor. Normal şartlar altında mesela masaüstünde bir MS-DOS ekranı açabilmek içinşuyoluizlemenizgerekiyor: 1. WindowslogolutuşaveRtuşunabirliktebas, 2. AçılanpencereyecmdyazıpEnterdüğmesinebas, 3. BuşekildeulaştığınMS-DOSekranındacd Desktopkomutunuver. Bu üç adımla, MS-DOS ekranı üzerinden masaüstüne ulaşmış oluyoruz. Ama aslında bunun çokdahakolaybiryoluvar:MasaüstünesağtıklarkenShifttuşunudabasılıtutarsanız,sağ-tık menüsünde‘Komutpenceresiniburadaaç’adlıbirsatırgörürsünüz.İştebusatıratıklayarak, MS-DOS komut satırını tek harekette masaüstü konumunda çalıştırabilirsiniz. Elbette bu özellik sadece masaüstü için değil, bütün konumlar için geçerlidir. Yani bilgisayarınızda herhangibiryeresağtıklarkenShifttuşunudabasılıtutarakokonumdabirMS-DOSpenceresi açabilirsiniz. Ayrıca, herhangi bir klasör açıkken dosya tarayıcısının adres çubuğuna cmd yazıp Enter düğmesine basarak da, o klasörün bulunduğu konumda bir komut ekranı açabilirsiniz. Örneğin eğer o anda önünüzde ‘İndirilenler’ (veya ‘Karşıdan Yüklenenler’) dizini 108 PythonBelgeleri,Yayım4.1.3 açıksa, adres çubuğuna (aşağıdaki resimde kırmızı ile gösterilen bölge) cmd yazarak C:\Users\Kullanıcı\Downloads>konumundabirkomutekranıaçabilirsiniz. İkinci olarak, çalışma kolaylığı açısından Windows’ta dosya uzantılarının her zaman görünmesini sağlamanızı da tavsiye ederim. Windows ilk kurulduğunda hiçbir dosyanın uzantısıgörünmez.Yanimeseladeneme.txtadlıbirdosyaWindowsilkkurulduğundadeneme şeklinde görünecektir. Bu durumda, bir dosyanın uzantısını değiştirmek istediğinizde bazı sıkıntılar yaşarsınız. Örneğin, masaüstünde bir metin dosyası oluşturduğunuzu varsayalım. Diyelim ki amacınız bu dosyanın içine bir şeyler yazıp daha sonra mesela bu dosyanın uzantısını .bat veya .py yapmak olsun. Böyle bir durumda, dosya uzantılarını göremediğiniz için,metindosyasınınuzantısınıdeğiştirmeyeçalıştığınızdadeneme.bat.txtgibibirdosyaadı elde edebilirsiniz. Tabii ki bu dosya bir .bat dosyası değil, bir .txt, yani metin dosyasıdır. Dolayısıylaaslındadosyauzantısınıdeğiştirememişoluyorsunuz. Yukarıdaki nedenlerden ötürü, ben size şu yolu takip ederek dosya uzantılarını her zaman görünürhalegetirmeniziöneririm: 1. Başlat>DenetimMasasıyolunutakipederekdenetimmasasınaulaşın, 2. Denetimmasasında‘GörünümveKişiselleştirme’seçeneğinetıklayın, 3. Açılanmenününsağtarafında‘KlasörSeçenekleri’satırınatıklayın, 4. Açılanpencerede‘Görünüm’sekmesinetıklayın, 5. ‘Gelişmiş Ayarlar’ listesinde ‘Bilinen dosya türleri için uzantıları gizle’ seçeneğinin yanındakionayişaretinikaldırın, 6. UygulaveTamamdüğmelerinebasarakbütünpencerelerikapatın, 9.1. WindowsKullanıcıları 109 PythonBelgeleri,Yayım4.1.3 7. Artıkbütündosyalarınızınuzantısıdagörüneceğiiçin,uzantıdeğiştirmeişlemleriniçok dahakolaybirşekildehalledebilirsiniz. 9.2 GNU/Linux Kullanıcıları Eğer KDE temelli bir GNU/Linux dağıtımı kullanıyorsanız, yazıp kaydettiğiniz Python programını barındıran dizin açıkken F4 tuşuna bastığınızda, komut satırı o dizin altında açılacaktır. UnityveGNOMEkullanıcılarınınisebenzerbirkolaylığaulaşmakiçinnautilus-open-terminal adlıbetiğisistemlerinekurmalarıgerekiyor.EğerUbuntukullanıyorsanızbubetiğişukomutla kurabilirsiniz: sudo apt-get install nautilus-open-terminal Bubetiğikurduktansonrabilgisayarınızıyenidenbaşlatınveyaşukomutuverin: killall nautilus Artık komut satırını hangi dizin altında başlatmak istiyorsanız o dizine sağ tıklayın. Menüler arasındaOpeninTerminal[Uçbirimdeaç]adlıbirseçenekgöreceksiniz.Bunatıkladığınızdao dizinaltındabirkomutsatırıpenceresiaçılacaktır. 9.3 Metin Düzenleyici Ayarları Dahaöncedesöylediğimizgibi,Pythonileprogramyazmakiçinistediğinizmetindüzenleyiciyi kullanabilirsiniz. Ama kodlarınızın kusursuz görünmesi ve hatasız çalışması için kullandığınız metin düzenleyicide birtakım ayarlamalar yapmanız gerekir. İşte bu bölümde bu ayarların nelerolduğunugöstereceğiz. Eğer programlarınızı IDLE ile yazıyorsanız aslında bir şey yapmanıza gerek yok. IDLE Python ile program yazmak üzere tasarlanmış bir düzenleyici olduğu için bu programın bütün ayarları Python ile uyumludur. Ama eğer IDLE dışında bir metin düzenleyici kullanıyorsanız budüzenleyicidetemelolarakşuayarlarıyapmanızgerekir: 1. Sekmegenişliğini[TABwidth]4olarakayarlayın. 2. Girintigenişliğini[Indentwidth]4olarakayarlayın. 3. Girintilemedesekmeyerineboşlukkullanmayıtercihedin[Usespacesinsteadoftabs] 4. Tercihedilenkodlamabiçimini[Preferredencoding]utf-8olarakayarlayın. Özellikle son söylediğimiz ‘kodlama biçimi’ ayarı çok önemlidir. Bu ayarın yanlış olması halinde,yazdığınızprogramıçalıştırmakistediğinizdeşöylebirhataalabilirsiniz: SyntaxError: Non-UTF-8 code starting with ’\xfe’ in file deneme.py on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details Eğeryazdığınızbirprogramböylebirhatamesajıüretiyorsa,ilkolarakmetindüzenleyicinizin kodlamabiçimi(encoding)ayarlarınıkontroledin.Metindüzenleyicilergenellikletercihedilen kodlama biçimini aşağıdaki örnek resimde görüldüğü gibi, durum çubuğunda sürekli olarak gösterir. 110 Bölüm9. ÇalışmaOrtamıTavsiyesi PythonBelgeleri,Yayım4.1.3 Ancak kodlama biçimi doğru bir şekilde utf-8 olarak ayarlanmış metin düzenleyicilerde, özellikle internet üzerinden kod kopyalanıp yapıştırılması sırasında bu ayar siz farkında olmadan değişebilir. Böyle bir durumda da program çalışırken yukarıda bahsedilen hatayı alabilirsiniz.Dolayısıyla,programınızıyazdığınızmetindüzenleyicininkodlamaayarlarınınsiz farkındaolmadandeğişmeihtimalinekarşıuyanıkolmanızgerekir. Elbette piyasada yüzlerce metin düzenleyici olduğu için yukarıda bahsedilen ayarların her metin düzenleyicide nasıl yapılacağını tek tek göstermemiz mümkün değil. Ancak iyi bir metindüzenleyicideyukarıdakiayarlarınhepsibulunur.Tekyapmanızgereken,buayarların, kullandığınız metin düzenleyicide nereden yapıldığını bulmak. Eğer kullandığınız metin düzenleyiciyiayarlamaktazorlanıyorsanız,herzamankigibi15 adresindesıkıntınızıdile getirebilirsiniz. ‘Kodlamabiçimi’kavramındansözetmişken,Python’lailgiliönemlibirkonuyadahadeğinelim. En başta da söylediğimiz gibi, şu anda piyasada Python iki farklı seri halinde geliştiriliyor. Bunlardanbirinin2.xserisi,öbürününde3.xserisiolduğunubiliyoruz.Python’ın2.xserisinde Türkçe karakterlerin gösterimi ile ilgili çok ciddi problemler vardı. Örneğin Python’ın 2.x serisindeşöylebirkodyazamıyorduk: print("Günaydın Şirin Baba!") Bukodubirdosyayakaydedip,Python’ın2.xserisineaitbirsürümleçalıştırmakistediğimizde Pythonbizeşöylebirhatamesajıveriyordu: SyntaxError: Non-ASCII character ’\xc3’ in file test.py on line 1, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details Bununsebebi,Python’ın2.xsürümlerindeASCIIadlıkodlamabiçimininkullanılıyorolmasıdır. Zaten hata mesajına baktığımızda da, Python’ın ASCII olmayan karakterlerin varlığından şikayetettiğinigörüyoruz. Yukarıdakikodlarınçalışabilmesiiçinprogramımızaşöylebireklemeyapmamızgerekiyordu: # -*- coding: utf-8 -*- print("Günaydın Şirin Baba!") Buradakiilksatıradikkatedin.Bukodlarlayaptığımızşey,Python’ınASCIIadlıkodlamabiçimi yerineUTF-8adlıkodlamabiçiminikullanmasınısağlamaktır.ASCIIadlıkodlamabiçimiTürkçe karakterleri gösteremez, ama UTF-8 adlı kodlama biçimi Türkçe karakterleri çok rahat bir şekildegösterebilir. (cid:242) Not 15https://forum..com/ 9.3. MetinDüzenleyiciAyarları 111 PythonBelgeleri,Yayım4.1.3 Kodlama biçimlerinden, ileride ayrıntılı bir şekilde söz edeceğiz. O yüzden bu anlattıklarımızdaeğeranlamadığınızyerlerolursabunlaratakılmanızagerekyok. Python’ın3.xserisiningelişiilebirliktePython’daöntanımlıolarakASCIIyerineUTF-8kodlama biçimi kullanılmaya başlandı. Dolayısıyla yazdığımız programlara # -*- coding: utf-8 -*- satırını eklememize gerek kalmadı. Çünkü zaten Python UTF-8 kodlama biçimini öntanımlı olarak kendisi kullanıyor. Ama eğer UTF-8 dışında başka bir kodlama biçimine ihtiyaç duyarsanızyinebusatırdanyararlanabilirsiniz. Örneğin GNU/Linux dağıtımlarının geleneksel olarak UTF-8 kodlama biçimi ile arası iyidir. Dolayısıyla eğer GNU/Linux üzerinde Python programları geliştiriyorsanız bu satırı hiç yazmadan bir ömür geçirebilirsiniz. Ama Windows işletim sistemleri UTF-8’i desteklemeklebirlikte,budestekGNU/Linux’takikadariyideğildir.Dolayısıylazamanzaman Windows’ta UTF-8 dışında başka bir kodlama biçimini kullanmanız gerekebilir. Örneğin yazdığınız bir programda Türkçe karakterleri göremiyorsanız, programınızın ilk satırını şöyle düzenleyebilirsiniz: # -*- coding: cp1254 -*- Burada UTF-8 yerine cp1254 adlı kodlama biçimini kullanmış oluyoruz. Windows işletim sistemindecp1254adlıkodlamabiçimiUTF-8’ekıyasladahafazladesteklenir. 9.4 MS-DOS Komut Satırı Ayarları Eğer yukarıda anlattığımız bütün ayarları doğru bir şekilde yapmanıza rağmen, özellikle MS-DOS komut satırında hala Türkçe karakterleri düzgün görüntüleyemiyorsanız, kullandığınız Windows sürümünün komut satırı, öntanımlı olarak Türkçe karakterleri gösteremeyenbiryazıtipineayarlanmışolabilir.DolayısıylaTürkçekarakterlerigösterebilmek içinöncelikleuygunbiryazıtipiseçmenizgerekir.Bununiçinşubasamaklarıtakipediyoruz: 1. Komutsatırınıaçıyoruz, 2. Açılanpencereninbaşlıkçubuğunasağtıklayarak,‘özellikler’menüsünegiriyoruz, 3. ‘Yazıtipi’sekmesindeyazıtipiolarak‘LucidaConsole’u(veyavarsa‘Consolas’ı)seçiyoruz, 4. ‘Tamam’düğmesinebasıyoruz. 5. Eğer önünüze bir onay penceresi açılırsa, ‘Özellikleri aynı başlıkla ileride oluşturulacak pencereleriçinkaydet’seçeneğiniişaretleyip‘Tamam’abastıktansonraçıkıyoruz. 6. Bu işlemin nasıl yapılacağını gösteren bir videoyu http://media..com/videos/ ms-dos.swf adresindenizleyebilirsiniz. Böylece MS-DOS komut satırı için Türkçe karakterleri gösterebilen bir yazı tipi belirlemiş olduk. Ancak bu, Türkçe karakterleri düzgün görüntülemeye yetmeyebilir. Eğer Türkçe karakterler hala düzgün görünmüyorsa, kullandığınız sistemde MS-DOS’un dil kodlaması Türkçekarakterlerigörüntülemeyeuygunolmayabilir.Türkçekarakterlerigösterebilenbirdil kodlamasıbelirlemekiçinkomutsatırındaşukomutuverin: chcp 1254 112 Bölüm9. ÇalışmaOrtamıTavsiyesi PythonBelgeleri,Yayım4.1.3 CP1254, Türkçe karakterleri de içeren bir dil kodlamasıdır. Bu komutu verdikten sonra artık Türkçekarakterleridüzgüngörüntüleyebiliyorolmanızlazım. 9.5 Program Örnekleri Yukarıda Python ve programlamaya ilişkin pek çok teknik bilgi verdik. Bunları öğrenmemiz, işlerimizi kuru kuruya ezberleyerek değil, anlayarak yapmamızı sağlaması açısından büyük önemtaşıyordu.Ancakyukarıdapratiğeyönelikpekbirşeysunamadık.İştebubölümdepratik eksikliğimizibirazolsunkapamayadönükörnekleryapacağız. Hatırlarsanız Python’la tanışmamızı sağlayan ilk örneğimiz ekrana basit bir “Merhaba Zalim Dünya!”cümlesiyazdırmaktı.Builkörneğietkileşimlikabuktaverdiğimizihatırlıyorsunuz: >>> "Merhaba Zalim Dünya!" Ama artık programlarımızı dosyaya kaydetmeyi öğrendiğimize göre bu kodları etkileşimli kabuğa yazmak yerine bir dosyaya yazmayı tercih edebiliriz. Bu sayede yazdığımız kodlar kalıcılıkkazanacaktır. Hemenbirdenemeyapalım.Boşbirmetinbelgesiaçıporayaşusatırıyazalım: "Merhaba Zalim Dünya!" Şimdi de bu dosyayı daha önce anlattığımız şekilde masaüstüne deneme.py adıyla kaydedip programımızıçalıştıralım. Neoldu?Programınızhiçbirçıktıvermedenkapandı,değilmi? Hemen hatırlayacağınız gibi, print() fonksiyonu içine alınmayan ifadelerin ekrana çıktı olarakverilebilmesisadeceetkileşimlikabuğaözgübirdurumdur.Programlarımızıdosyadan çalıştırırken, print() fonksiyonu içine alınmayan ifadeler ekranda görünmeyecektir. Yukarıdaki örnek bu durumun bir göstergesidir. Dolayısıyla yukarıdaki ifadenin ekrana çıktı olarakverilebilmesiiçinokoduşöyleyazmamızgerekiyor: print("Merhaba Zalim Dünya!") Programınızıbuşekildetekrarçalıştırdığınızdaşöylebirçıktıalıyoruz: Merhaba Zalim Dünya! Buoldukçabasitbirörnekti.Şimdibirazdahakarmaşıkbirörnekverelim. Yine hatırlayacağınız gibi, önceki bölümlerden birinde aylık yol masrafımızı hesaplayan bir programyazmıştık. Oradaelimizdekiverilerinşunlarolduğunuvarsaymıştık: 1. Cumartesi-Pazargünleriçalışmıyoruz. 2. Dolayısıylaayda22günçalışıyoruz. 3. Evdenişegitmekiçinkullandığımızvasıtanınücreti1.5TL 4. İştenevedönmekiçinkullandığımızvasıtanınücreti1.4TL 9.5. ProgramÖrnekleri 113 PythonBelgeleri,Yayım4.1.3 Elimizdeki bu bilgilere göre aylık yol masrafımızı hesaplamak için de şöyle bir formül üretmiştik: masraf = gün sayısı x (gidiş ücreti + dönüş ücreti) Gelinşimdiyukarıdakibilgilerikullanarakprogramımızıdosyayayazalım: gün = 22 gidiş_ücreti = 1.5 dönüş_ücreti = 1.4 masraf = gün * (gidiş_ücreti + dönüş_ücreti) print(masraf) Tıpkı öncekiler gibi, bu programı da masaüstüne deneme.py adıyla kaydedelim ve komut satırında masaüstünün bulunduğu konuma giderek python3 deneme.py komutuyla programımızıçalıştıralım.Programıçalıştırdığımızdaşöylebirçıktıalıyoruz: 63.8 Programımız gayet düzgün çalışıyor. Ancak gördüğünüz gibi, elde ettiğimiz çıktı çok yavan. Ama eğer isterseniz yukarıdaki programa daha profesyonel bir görünüm de kazandırabilirsiniz.Dikkatliceinceleyin: gün = 22 gidiş_ücreti = 1.5 dönüş_ücreti = 1.4 masraf = gün * (gidiş_ücreti + dönüş_ücreti) print("-"*30) print("çalışılan gün sayısı\t:", gün) print("işe gidiş ücreti\t:", gidiş_ücreti) print("işten dönüş ücreti\t:", dönüş_ücreti) print("-"*30) print("AYLIK YOL MASRAFI\t:", masraf) Budefaprogramımızşöylebirçıktıverdi: ------------------------------ çalışılan gün sayısı : 22 işe gidiş ücreti : 1.5 işten dönüş ücreti : 1.4 ------------------------------ AYLIK YOL MASRAFI : 63.8 Gördüğünüzgibi,bukodlarsayesindekullanıcıyadahaayrıntılıbilgivermişolduk.Üstelikelde ettiğimizçıktıdahaşıkgörünüyor. Yukarıdaki kodlarda şimdiye kadar öğrenmediğimiz hiçbir şey yok. Yukarıdaki kodların tamamını anlayabilecek kadar Python bilgimiz var. Bu kodlarda çok basit parçaları bir araya 114 Bölüm9. ÇalışmaOrtamıTavsiyesi PythonBelgeleri,Yayım4.1.3 getirerek istediğimiz çıktıyı nasıl elde ettiğimizi dikkatlice inceleyin. Mesela elde etmek istediğimizçıktınıngörünüşünügüzelleştirmekiçinikiyerdeşusatırıkullandık: print("-"*30) Böylece 30 adet - işaretini yan yana basmış olduk. Bu sayede elde ettiğimiz çıktı daha derli toplu bir görünüme kavuştu. Ayrıca kodlarımız içinde \t adlı kaçış dizisinden de yararlandık. Böylelikleekranabasılançıktılaraltaltadüzgünbirşekildehizalanmışoldu. Bu arada, yukarıdaki kodlar sayesinde değişken kullanımının işlerimizi ne kadar kolaylaştırdığına da birebir tanık olduk. Eğer değişkenler olmasaydı yukarıdaki kodları şöyleyazacaktık: print("-"*30) print("çalışılan gün sayısı\t:", 22) print("işe gidiş ücreti\t:", 1.5) print("işten dönüş ücreti\t:", 1.4) print("-"*30) print("AYLIK YOL MASRAFI\t:", 22 * (1.5 + 1.4)) Eğer günün birinde mesela çalışılan gün sayısı değişirse yukarıdaki kodların iki farklı yerinde değişiklik yapmamız gerekecekti. Bu kodların çok büyük bir programın parçası olduğunu düşünün. Kodların içinde değer arayıp bunları tek tek değiştirmeye kalkışmanın ne kadar hataya açık bir yöntem olduğunu tahmin edebilirsiniz. Ama değişkenler sayesinde, sadece tekbiryerdedeğişiklikyaparakkodlarımızıgünceltutabiliriz.Meselaçalışılangünsayısı20’ye düşmüşolsun: gün = 20 gidiş_ücreti = 1.5 dönüş_ücreti = 1.4 masraf = gün * (gidiş_ücreti + dönüş_ücreti) print("-"*30) print("çalışılan gün sayısı\t:", gün) print("işe gidiş ücreti\t:", gidiş_ücreti) print("işten dönüş ücreti\t:", dönüş_ücreti) print("-"*30) print("AYLIK YOL MASRAFI\t:", masraf) Gördüğünüz gibi, sadece en baştaki gün adlı değişkenin değerini değiştirerek istediğimiz sonucueldeettik. Kendinizistersenizyukarıdakiörnekleriçeşitlendirebilirsiniz. Gördüğünüz gibi, Python’da az da olsa işe yarar bir şeyler yazabilmek için çok şey bilmemizegerekyok.Sırfşuanakadaröğrendiklerimizikullanarakbileufaktefekprogramlar yazabiliyoruz. 9.5. ProgramÖrnekleri 115 10 BÖLÜM Yorum ve Açıklama Cümleleri Python’la ilgili şimdiye kadar öğrendiğimiz bilgileri kullanarak yazabileceğimiz en karmaşık programlardanbiriherhaldeşöyleolacaktır: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" print("isim : ", isim, "\n", "soyisim : ", soyisim, "\n", "işletim sistemi: ", işsis, "\n", "şehir : ", şehir, "\n", sep="") Yukarıdakikodlarırahatlıklaanlayabildiğinizizannediyorum.Amaistersenizyinedebukodları satırsatırinceleyelim: İlkolarakisim,soyisim,işsisveşehiradındadörtfarklıdeğişkentanımladık.Budeğişkenlerin değerisırasıylaFırat,Özgül,Ubuntuveİstanbul. Daha sonra da tanımladığımız bu değişkenleri belli bir düzen içinde kullanıcılarımıza gösterdik,yaniekranayazdırdık.Elbettebuişiçinprint()fonksiyonunukullandık.Bildiğiniz gibi, print() birden fazla parametre alabilen bir fonksiyondur. Yani print() fonksiyonunun parantezleriiçineistediğimizsayıdaöğeyazabiliriz. Eğer print() fonksiyonunun yukarıdaki kullanımı ilk bakışta gözünüze anlaşılmaz göründüyse,fonksiyondageçenveneişeyaradığınıanlayamadığınızöğeleri,birdeçıkartarak yazmayıdeneyebilirsinizbufonksiyonu. Python’la yazılmış herhangi bir programın tam olarak nasıl işlediğini anlamanın en iyi yolu program içindeki kodlarda bazı değişiklikler yaparak ortaya çıkan sonucu incelemektir. Örneğin print() fonksiyonunda sep parametresinin değerini boş bir karakter dizisi yapmamızın nedenini anlamak için, fonksiyondaki bu sep parametresini kaldırıp, programı birdebuşekildeçalıştırmayıdeneyebilirsiniz. 116 PythonBelgeleri,Yayım4.1.3 Yukarıdaki örnekte bütün öğeleri tek bir print() fonksiyonu içine yazdık. Ama tabii eğer istersenizbirdenfazlaprint()fonksiyonudakullanabilirsiniz.Şöyle: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) Yukarıdakikodlarlailgilibirkaçnoktayadahadikkatiniziçekmekistiyorum: Birincisi, gördüğünüz gibi kodları yazarken biraz şekil vererek yazdık. Bunun sebebi kodların görünüşolarakanlaşılırolmasınısağlamak.Dahaöncededediğimizgibi,Python’dadoğrukod yazmak kadar, yazdığınız kodların anlaşılır olması da önemlidir. Bu sebepten, Python’la kod yazarken,meselakodlarımızdakiherbirsatırınuzunluğunun79karakterigeçmemesineözen gösteriyoruz. Bunu sağlamak için, kodlarımızı yukarıda görüldüğü şekilde belli noktalardan bölmemizgerekebilir. Esasındayukarıdakikodlarışöyledeyazabilirdik: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" print("isim: ", isim, "\n", "soyisim: ", soyisim, "\n", "işletim sistemi: ", işsis, "\n", "şehir: ", şehir, "\n", sep="") Ancak bu şekilde kod yapısı biraz karmaşık görünüyor. Ayrıca parantez içindeki öğeleri yan yana yazdığımız için, isim:, soyisim:, işletim sistemi: ve şehir: ifadelerini alt alta düzgün bir şekildehizalamakdakolayolmayacaktır. Belki bu basit kodlarda çok fazla dikkati çekmiyordur, ama özellikle büyük boyutlu programlarda kodlarımızı hem yapı hem de görüntü olarak olabildiğince anlaşılır bir hale getirmekhemkoduokuyanbaşkalarıiçin,hemdekendimiziçinbüyükönemtaşır.Unutmayın, bir programı yazdıktan 5-6 ay sonra geri dönüp baktığınızda kendi yazdığınız kodlardan siz dahihiçbirşeyanlamadığınızıfarkedebilirsiniz! Birprogramyazarkenkodlarınolabildiğinceokunaklıolmasınısağlamanınbirkaçyoluvardır. Bizbunlardanbazılarınıyukarıdagördük.Ancakbirprogramıokunaklıhalegetirmenineniyi yolukodlariçinebazıyorumcümleleriekleyerekkodlarıaçıklamaktır. İşte bu bölümde, Python programlama dili ile yazdığımız kodlara nasıl yorum ve açıklama cümleleriekleyeceğimiziinceleyeceğiz. 117 PythonBelgeleri,Yayım4.1.3 10.1 Yorum İşareti Programcılıkta en zor şey başkasının yazdığı kodları okuyup anlamaktır. Hatta yazılmış bir programıdüzeltmeyeçalışmak,bazenoprogramısıfırdanyazmaktandahazorolabilir.Bunun nedeni,programiçindekikodlarınneişeyaradığınıanlamanınzorluğudur.Programıyazankişi kendidüşünüşünegörebiryolizlemişveprogramıgeliştirirkenkarşılaştığısorunlarıçözmek için kimi yerlerde enteresan çözümler üretmiş olabilir. Ancak kodlara dışarıdan bakan birisi içinoprogramınmantıkdüzeniniveiçindekikodlarıntamolarakneyaptığınıanlamakbirhayli zorolacaktır.Böyledurumlarda,kodlarıokuyanprogramcınınenbüyükyardımcısı,programı geliştirenkişininkodlararasınaeklediğinotlarolacaktır.Tabiiprogramıgeliştirenkişikodlara yorumeklemezahmetindebulunmuşsa... Python’da yazdığımız kodları başkalarının da anlayabilmesini sağlamak için, programımızın yorumlarla desteklenmesi tavsiye edilir. Elbette programınızı yorumlarla desteklemeseniz de programınız sorunsuz bir şekilde çalışacaktır. Ama programı yorumlarla desteklemek en azındannezaketgereğidir. Ayrıca işin başka bir boyutu daha var. Sizin yazdığınız kodları nasıl başkaları okurken zorlanıyorsa,kendiyazdığınızkodlarıokurkensizbilezorlanabilirsiniz.Özellikleuzunsüredir ilgilenmediğiniz eski programlarınızı gözden geçirirken böyle bir sorunla karşılaşabilirsiniz. Programın içindeki bir kod parçası, programın ilk yazılışının üzerinden 5-6 ay geçtikten sonra size artık hiçbir şey ifade etmiyor olabilir. Kodlara bakıp, ‘Acaba burada ne yapmaya çalışmışım?’ diye düşündüğünüz zamanlar da olacaktır. İşte bu tür sıkıntıları ortadan kaldırmakveyaenazaindirmekiçinkodlarımızınarasınaaçıklayıcınotlarekleyeceğiz. Python’da yorumlar # işareti ile gösterilir. Mesela bu bölümün ilk başında verdiğimiz kodları yorumlarladestekleyelim: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" #işletim sistemi şehir = "İstanbul" #isim, soyisim, işsis ve şehir adlı değişkenleri #alt alta, düzgün bir şekilde ekrana basıyoruz. #Uygun yerlerde alt satıra geçebilmek için "\n" #adlı kaçış dizisini kullanıyoruz. print("isim : ", isim, "\n", "soyisim : ", soyisim, "\n", "işletim sistemi: ", işsis, "\n", "şehir : ", şehir, "\n", sep="") #parametreler arasında boşluk bırakmıyoruz. Buradadikkatedeceğimiznoktaheryorumsatırınınbaşına#işaretinikoymayıunutmamaktır. Yazdığımız yorumlar Python’a hiç bir şey ifade etmez. Python bu yorumları tamamen görmezden gelecektir. Bu yorumlar bilgisayardan ziyade kodları okuyan kişi için bir anlam taşır. Elbette yazdığınız yorumların ne kadar faydalı olacağı, yazdığınız yorumların kalitesine bağlıdır.Dediğimizgibi,yerliyerindekullanılmışyorumlarbirprogramınokunaklılığınıartırır, ama her tarafı yorumlarla kaplı bir programı okumak da bazen hiç yorum girilmemiş bir programı okumaktan daha zor olabilir! Dolayısıyla Python’da kodlarımıza yorum eklerken 118 Bölüm10. YorumveAçıklamaCümleleri PythonBelgeleri,Yayım4.1.3 önemli olan şey, kaş yapmaya çalışırken göz çıkarmamaktır. Yani yorumlarımızı, bir kodun okunaklılığınıartırmayaçalışırkendahadabozmayacakşekildeyerleştirmeyedikkatetmeliyiz. 10.2 Yorum İşaretinin Farklı Kullanımları Yukarıda yorum (#) işaretini kullanarak, yazdığımız Python kodlarını nasıl açıklayacağımızı öğrendik. Python’da yorum işaretleri çoğunlukla bu amaç için kullanılır. Yani kodları açıklamak,bukodlarıhemkendimizhemdekodlarıokuyanbaşkalarıiçindahaanlaşılırhale getirmekiçin... AmaPython’da#işaretiasılamacınındışındabazıbaşkaamaçlaradahizmet edebilir. 10.2.1 Etkisizleştirme Amaçlı Dediğimiz gibi, yorum işaretinin birincil görevi, tabii ki, kodlara açıklayıcı notlar eklememizi sağlamaktır.Amabuişaretbaşkaamaçlariçindekullanılabilir.Örneğin,diyelimkiyazdığımız programa bir özellik eklemeyi düşünüyoruz, ama henüz bu özelliği yeni sürüme eklemek istemiyoruz.Ozamanşöylebirşeyyapabiliriz: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" #uyruğu = "T.C" print("isim : ", isim, "\n", "soyisim : ", soyisim, "\n", "işletim sistemi: ", işsis, "\n", "şehir : ", şehir, "\n", #"uyruğu : ", uyruğu, "\n", sep="") Burada,programahenüzeklemekistemediğimizbirözelliği,yorumiçinealarakşimdilikiptal ediyoruz yani etkisizleştiriyoruz (İngilizcede bu yorum içine alma işlemine comment out deniyor).Pythonyorumiçindebirkodbileyeralsaokodlarıçalıştırmayacaktır.ÇünküPython # işareti ile başlayan satırların içeriğini görmez (#!/usr/bin/env python3 ve # -*- coding: utf-8 -*-satırlarıhariç). Peki eklemek istemediğimiz özelliği yorum içine almaktansa doğrudan silsek olmaz mı? Elbette olur. Ama programın daha sonraki bir sürümüne ilave edeceğimiz bir özelliği yorum içine almak yerine silecek olursak, vakti geldiğinde o özelliği nasıl yaptığımızı hatırlamakta zorlanabiliriz! Hatta bir süre sonra programımıza hangi özelliği ekleyeceğimizi dahi unutmuş olabiliriz.‘Hayır,benhafızamagüveniyorum!’diyorsanızkararsizin. Yorum içine alarak iptal ettiğiniz bu kodları programa ekleme vakti geldiğinde yapacağınız tek şey, kodların başındaki # işaretlerini kaldırmak olacaktır. Hatta bazı metin düzenleyiciler bu işlemi tek bir tuşa basarak da gerçekleştirme yeteneğine sahiptir. Örneğin IDLE ile çalışıyorsanız, yorum içine almak istediğiniz kodları fare ile seçtikten sonra Alt+3 tuşlarına basarak ilgili kodları yorum içine alabilirsiniz. Bu kodları yorumdan kurtarmak için ise ilgili alanıseçtiktensonraAlt+4tuşlarınabasmanızyeterliolacaktır(yorumdankurtarmaişlemine İngilizcedeuncommentdiyorlar). 10.2. YorumİşaretininFarklıKullanımları 119 PythonBelgeleri,Yayım4.1.3 10.2.2 Süsleme Amaçlı Bütün bunların dışında, isterseniz yorum işaretini kodlarınızı süslemek için dahi kullanabilirsiniz: ####################################################### #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# # FALANCA v.1 # # Yazan: Keramet Su # # Lisans: GPL v2 # #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~# ####################################################### isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" print("isim : ", isim, "\n", "soyisim : ", soyisim, "\n", "işletim sistemi: ", işsis, "\n", "şehir : ", şehir, "\n", sep="") Yani kısaca, Python’un görmesini, çalıştırmasını istemediğimiz her şeyi yorum içine alabiliriz. Unutmamamız gereken tek şey, yorumların yazdığımız programların önemli bir parçası olduğuvebunlarımantıklı,makulbirşekildekullanmamızgerektiğidir. 120 Bölüm10. YorumveAçıklamaCümleleri 11 BÖLÜM Kullanıcıdan Bilgi Almak ŞimdiyekadarPythonprogramlamadiliileilgiliepeybilgiedindik.Amamuhtemelenburaya kadar öğrendiklerimiz sizi heyecanlandırmaktan bir hayli uzaktı. Zira şu ana kadar hep tek yönlübirprogramlamafaaliyetiyürüttük. Meselaşimdiyekadaröğrendiklerimizikullanarakancakşöylebirprogramyazabildik: isim = "Mübeccel" print("Merhaba", isim, end="!\n") Buprogramıçalıştırdığımızdaşöylebirçıktıalacağımızıbiliyorsunuz: Merhaba Mübeccel! Bu programın ne kadar sıkıcı olduğunu herhalde söylemeye gerek yok. Bu programda isim değişkenini doğrudan kendimiz yazdığımız için programımız hiçbir koşulda Merhaba Mübecceldışındabirçıktıveremez.Çünkübuprogram,tekyönlübirprogramlamafaaliyetinin ürünüdür. Halbuki bu değişkenin değerini kendimiz yazmasak, bu değeri kullanıcıdan alsak ne hoş olurdu,değilmi? Python’da kullanıcıdan herhangi bir veri alıp, yazdığımız programları tek taraflı olmaktan kurtarmakiçininput()adlıbirfonksiyondanfaydalanıyoruz. İşte biz bu bölümde, programcılık maceramızı bir üst seviyeye taşıyacak çok önemli bir araç olan bu input() fonksiyonunu derinlemesine inceleyeceğiz. Ama bu bölümde sadece bu fonksiyonu ele almayacağız elbette. Burada kullanıcıdan veri almanın yanısıra, aldığımız bu veriyi nasıl dönüştüreceğimizi ve bu veriyi, yazdığımız programlarda nasıl kullanacağımızı da derinderininceleyeceğiz. İlkininput()fonksiyonunuanlatarakyolakoyulalım. 121 PythonBelgeleri,Yayım4.1.3 11.1 input() Fonksiyonu input()dadahaönceöğrendiğimiztype(),len()veprint()gibibirfonksiyondur.Esasında bizbufonksiyonuilkkezburadagörmüyoruz.WindowsveGNU/Linuxkullanıcıları,yazdıkları bir programı çift tıklayarak çalıştırabilmek için bu fonksiyonu kullandıklarını hatırlıyor olmalılar.Meselaşuprogramıelealalım: #!/usr/bin/env python3 kartvizit = """ Anonim Şirketi Fırat Özgül Tel: 0212 123 23 23 Faks: 0212 123 23 24 e.posta: k@yahoo.com """ print(kartvizit) Bu programı yazıp kaydettikten sonra bu programın simgesi üzerine çift tıkladığımızda siyah bir komut ekranının çok hızlı bir şekilde açılıp kapandığını görürüz. Aslında programımız çalışıyor, ama programımız yapması gereken işi yaptıktan hemen sonra kapandığı için biz programpenceresinigörmüyoruz. Programımızınçalıştıktansonrahemenkapanmamasınısağlamakiçinsonsatırabirinput() fonksiyonuyerleştirmemizgerektiğinibiliyoruz: #!/usr/bin/env python3 kartvizit = """ Anonim Şirketi Fırat Özgül Tel: 0212 123 23 23 Faks: 0212 123 23 24 e.posta: k@yahoo.com """ print(kartvizit) input() Bu sayede programımız kullanıcıdan bir giriş bekleyecek ve o girişi alana kadar da kapanmayacaktır.ProgramıkapatmakiçinEnterdüğmesinebasabiliriz. input() bir fonksiyondur dedik. Henüz fonksiyon kavramının ayrıntılarını öğrenmemiş olsak da, şimdiye kadar pek çok fonksiyon gördüğümüz için artık bir fonksiyonla karşılaştığımızda bunun nasıl kullanılacağını az çok tahmin edebiliyoruz. Tıpkı düşündüğünüz ve yukarıdaki örnekten de gördüğünüz gibi, birer fonksiyon olan type(), print(), len() ve open() fonksiyonlarınınasılkullanıyorsakinput()fonksiyonunudaöylekullanacağız. Dilersenizlafıdahafazlauzatmadanörnekbirprogramyazalım: 122 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 isim = input("İsminiz nedir? ") print("Merhaba", isim, end="!\n") Bu programı kaydedip çalıştırdığınızda, sorulan soruya verdiğiniz cevaba göre çıktı farklı olacaktır. Örneğin eğer bu soruya ‘Niyazi’ cevabını vermişseniz çıktınız Merhaba Niyazi! şeklindeolacaktır. Görüyorsunuz ya, tıpkı daha önce gördüğümüz fonksiyonlarda olduğu gibi, input() fonksiyonunda da parantez içine bir parametre yazıyoruz. Bu fonksiyona verilen parametre, kullanıcıdan veri alınırken kullanıcıya sorulacak soruyu gösteriyor. Gelin isterseniz bir örnek dahayapalımelimizinalışmasıiçin: yaş = input("Yaşınız: ") print("Demek", yaş, "yaşındasın.") print("Genç mi yoksa yaşlı mı olduğuna karar veremedim.") input() fonksiyonunun ne kadar kullanışlı bir araç olduğu ortada. Bu fonksiyon sayesinde, şimdiye kadar tek sesli bir şekilde yürüttüğümüz programcılık faaliyetlerimizi çok sesli bir hale getirebileceğiz. Mesela önceki bölümlerden birinde yazdığımız, daire alanı hesaplayan programı hatırlarsınız. O zaman henüz dosyalarımızı kaydetmeyi ve input() fonksiyonunu öğrenmediğimiziçinoprogramıetkileşimlikabuktaşuşekildeyazmıştık: >>> çap = 16 >>> yarıçap = çap / 2 >>> pi = 3.14159 >>> alan = pi * (yarıçap * yarıçap) >>> alan 201.06176 Ama artık hem dosyalarımızı kaydetmeyi biliyoruz, hem de input() fonksiyonunu öğrendik. Dolayısıylayukarıdakiprogramışuşekildeyazabiliriz: #Kullanıcıdan dairenin çapını girmesini istiyoruz. çap = input("Dairenin çapı: ") #Kullanıcının verdiği çap bilgisini kullanarak #yarıçapı hesaplayalım. Buradaki int() fonksiyonunu #ilk kez görüyoruz. Biraz sonra bunu açıklayacağız yarıçap = int(çap) / 2 #pi sayımız sabit pi = 3.14159 #Yukarıdaki bilgileri kullanarak artık #dairenin alanını hesaplayabiliriz alan = pi * (yarıçap * yarıçap) #Son olarak, hesapladığımız alanı yazdırıyoruz (sonrakisayfayadevam) 11.1. input()Fonksiyonu 123 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Çapı", çap, "cm olan dairenin alanı: ", alan, "cm2’dir") Gördüğünüz gibi, input() fonksiyonunu öğrenmemiz sayesinde artık yavaş yavaş işe yarar programlaryazabiliyoruz. Ancak burada, daha önce öğrenmediğimiz bir fonksiyon dikkatinizi çekmiş olmalı. Bu fonksiyonun adı int(). Bu yeni fonksiyon dışında, yukarıdaki bütün kodları anlayabilecek kadarPythonbilgisinesahibiz. int() fonksiyonunun ne işe yaradığını anlamak için isterseniz ilgili satırı yarıçap = çap / 2 şeklindeyazarakçalıştırmayıdeneyinbuprogramı. Dediğim gibi, eğer o satırdaki int() fonksiyonunu kaldırarak programı çalıştırdıysanız şuna benzerbirhatamesajıalmışolmalısınız: Traceback (most recent call last): File "deneme.py", line 8, in <module> yarıçap = çap / 2 TypeError: unsupported operand type(s) for /: ’str’ and ’int’ Gördüğünüz gibi programımız bölme işlemini yapamadı. Buradan anlıyoruz ki, bu int() fonksiyonu programımızdaki aritmetik işlemin düzgün bir şekilde yapılabilmesini sağlıyor. Gelelimbufonksiyonunbuişlevinasılyerinegetirdiğiniincelemeye. 11.2 Tip Dönüşümleri Bir önceki bölümün sonunda verdiğimiz örnek programda int() adlı bir fonksiyon görmüş, bu fonksiyonu anlatmayı o zaman ertelemiştik. Çok gecikmeden, bu önemli fonksiyonun ne işeyaradığınıöğrenmemizgerekiyor.İstersenizbirörneküzerindengidelim. Diyelim ki kullanıcıdan aldığı sayının karesini hesaplayan bir program yazmak istiyoruz. Öncelikleşöylebirşeydeneyelim: sayı = input("Lütfen bir sayı girin: ") #Girilen sayının karesini bulmak için sayı değişkeninin 2. #kuvvetini alıyoruz. Aynı şeyi pow() fonksiyonu ile de #yapabileceğimizi biliyorsunuz. Örn.: pow(sayı, 2) print("Girdiğiniz sayının karesi: ", sayı ** 2) Bukodlarıçalıştırdığımızzaman,programımızkullanıcıdanbirsayıgirmesiniisteyecek,ancak kullanıcıbirsayıgiripEntertuşunabastığındaşöylebirhatamesajıylakarşılaşacaktır: Traceback (most recent call last): File "test.py", line 5, in <module> print("Girdiğiniz sayının karesi: ", sayı ** 2) TypeError: unsupported operand type(s) for ** or pow(): ’str’ and ’int’ Hatamesajınabaktığınızda,‘TypeError’ifadesinden,bununveritipineilişkinbirhataolduğunu tahmin edebilirsiniz. Eğer İngilizce biliyorsanız yukarıdaki hata mesajının anlamını rahatlıkla 124 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 çıkarabilirsiniz.İngilizcebilmesenizdeensondaki‘str’ve‘int’kelimelerisizekarakterdizisive sayıadlıveritiplerinihatırlatacaktır.Demekkiortadaveritipleriniilgilendirenbirsorunvar... Pekiburadatamolaraknelerdönüyor? Hatırlayacaksınız, geçen derslerden birinde len() fonksiyonunu anlatırken şöyle bir şey söylemiştik: Biz henüz kullanıcıdan nasıl veri alacağımızı bilmiyoruz. Ama şimdilik şunu söyleyebiliriz:Python’dakullanıcıdanherhangibirverialdığımızda,buveribizebir karakterdizisiolarakgelecektir. Gelinistersenizyukarıdaanlattığımızdurumuteyitedenbirprogramyazalım: #Kullanıcıdan herhangi bir veri girmesini istiyoruz sayı = input("Herhangi bir veri girin: ") #Kullanıcının girdiği verinin tipini bir #değişkene atıyoruz tip = type(sayı) #Son olarak kullanıcının girdiği verinin tipini #ekrana basıyoruz. print("Girdiğiniz verinin tipi: ", tip) Bu programı çalıştırdığımızda ne tür bir veri girersek girelim, girdiğimiz verinin tipi str, yani karakter dizisi olacaktır. Demek ki gerçekten de, kullanıcıdan veri almak için kullandığımız input()fonksiyonubizeherkoşuldabirkarakterdizisiveriyormuş. Geçenderslerdeşöylebirşeydahasöylemiştik: Python’da, o anda elinizde bulunan bir verinin hangi tipte olduğunu bilmek son derece önemlidir. Çünkü bir verinin ait olduğu tip, o veriyle neler yapıp neler yapamayacağınızıbelirler. Şuandakarşıkarşıyaolduğumuzdurumdabunaçokgüzelbirörnektir.Eğeroandaelimizde bulunanverinintipinibilmezsektıpkıyukarıdaolduğugibi,overiyiprogramımızdakullanmaya çalışırkenprogramımızhataverirveçöker. Her zaman üstüne basa basa söylediğimiz gibi, aritmetik işlemler yalnızca sayılarla yapılır. Karakter dizileri ile herhangi bir aritmetik işlem yapılamaz. Dolayısıyla, input() fonksiyonundan gelen veri bir karakter dizisi olduğu için ve biz de programımızda girilen sayınınkaresinihesaplamakamacıylabufonksiyondangelenverinin2.kuvvetini,yanikaresini hesaplamayaçalıştığımıziçinprogramımızhataverecektir. Yukarıdaki programda neler olup bittiğini daha iyi anlayabilmek için Python’ın etkileşimli kabuğundaşuişlemleriyapabiliriz: >>> "23" ** 2 Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unsupported operand type(s) for ** or pow(): ’str’ and ’int’ Gördüğünüz gibi, programımızdan aldığımız hata ile yukarıdaki hata tamamen aynı (hata mesajlarında bizi ilgilendiren kısım en son satırdır). Tıpkı burada olduğu gibi, hata veren 11.2. TipDönüşümleri 125 PythonBelgeleri,Yayım4.1.3 programdada‘Lütfenbirsayıgirin:‘sorusunaörneğin23cevabınıverdiğimizdeprogramımız aslında"23" ** 2gibibirişlemyapmayaçalışıyor.Birkarakterdizisininkuvvetinihesaplamak mümkünolmadığı,kuvvetalmaişlemiyalnızcasayılarlayapılabileceğiiçindehatavermekten başkaçaresikalmıyor. Ancak bazen öyle durumlarla karşılaşırsınız ki, programınız hiçbir hata vermez, ama elde edilensonuçaslındatamamenbeklentinizindışındadır.Meselaşubasitörneğiinceleyelim: sayı1 = input("Toplama işlemi için ilk sayıyı girin: ") sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ") print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Bukodlarıçalıştırdığımızdaşöylebirmanzaraylakarşılaşırız: input() fonksiyonunun alttan alta neler çevirdiğini bu örnek yardımıyla çok daha iyi anladığınızı zannediyorum. Gördüğünüz gibi yukarıdaki program herhangi bir hata vermedi. Amabeklediğimizçıktıyıdavermedi.Zirabizprogramımızınikisayıyıtoplamasınıistiyorduk. O ise kullanıcının girdiği sayıları yan yana yazmakla yetindi. Yani bir aritmetik işlem yapmak yerine, verileri birbiriyle bitiştirdi. Çünkü, dediğim gibi, input() fonksiyonunun kullanıcıdan aldığışeybirkarakterdizisidir.Dolayısıylabufonksiyonyukarıdakigibibirdurumlakarşılaştığı zaman karakter dizileri arasında bir birleştirme işlemi gerçekleştirir. Tıpkı ilk derslerimizde etkileşimlikabuktaverdiğimizşuörnekteolduğugibi: >>> "23" + "23" 2323 Bu son örnekten ayrıca şunu çıkarıyoruz: Yazdığınız bir programın herhangi bir hata vermemesi o programın doğru çalıştığı anlamına gelmeyebilir. Dolayısıyla bu tür durumlara karşıherzamanuyanıkolmanızdafaydavar. Pekiyukarıdakigibidurumlarlakarşılaşmamakiçinneyapacağız? 126 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 İştebunoktadadevreyetipdönüştürücüadınıverdiğimizbirtakımfonksiyonlargirecek. 11.2.1 int() Dediğimizgibi,input()fonksiyonundangelenveriherzamanbirkarakterdizisidir.Dolayısıyla bufonksiyondangelenveriyleherhangibiraritmetikişlemyapabilmekiçinönceliklebuveriyi birsayıyadönüştürmemizgerekir.Budönüştürmeişlemiiçinint()adlıözelbirdönüştürücü fonksiyondanyararlanacağız.GelinistersenizPython’ınetkileşimlikabuğundabufonksiyonla bir kaç deneme yaparak bu fonksiyonun ne işe yaradığını ve nasıl kullanıldığını anlamaya çalışalım.Ziraetkileşimlikabukbutürdenemeişlemleriiçinbiçilmişkaftandır: >>> karakter_dizisi = "23" >>> sayı = int(karakter_dizisi) >>> print(sayı) 23 Burada öncelikle “23” adlı bir karakter dizisi tanımladık. Ardından da int() fonksiyonunu kullanarakbukarakterdizisinibirtamsayıya(integer)dönüştürdük.İsmindendeanlayacağınız gibiint()fonksiyonuİngilizceinteger(tamsayı)kelimesininkısaltmasıdırvebufonksiyonun görevibirveriyitamsayıyadönüştürmektir. Ancak burada dikkat etmemiz gereken bir şey var. Herhangi bir verinin sayıya dönüştürülebilmesi için o verinin sayı değerli bir veri olması gerekir. Örneğin “23”, sayı değerli bir karakter dizisidir. Ama mesela “elma” sayı değerli bir karakter dizisi değildir. Bu yüzden“elma”karakterdizisisayıyadönüştürülemez: >>> karakter_dizisi = "elma" >>> sayı = int(karakter_dizisi) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: invalid literal for int() with base 10: ’elma’ Gördüğünüzgibi,sayıdeğerliolmayanbirveriyisayıyadönüştürmeyeçalıştırdığımızdaPython bizebirhatamesajıgösteriyor.Yazdığımızprogramlardabudurumaözellikledikkatetmemiz gerekiyor. Şimdibubölümünbaşındayazdığımızvehataverenprogramımızadönelimyine: sayı = input("Lütfen bir sayı girin: ") print("Girdiğiniz sayının karesi: ", sayı ** 2) Bu kodların hata vereceğini biliyoruz. Ama artık, öğrendiğimiz int() dönüştürücüsünü kullanarakprogramımızıhatavermeyecekşekildeyenidenyazabiliriz: veri = input("Lütfen bir sayı girin: ") #input() fonksiyonundan gelen karakter dizisini #sayıya dönüştürüyoruz. sayı = int(veri) (sonrakisayfayadevam) 11.2. TipDönüşümleri 127 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Girdiğiniz sayının karesi: ", sayı ** 2) Artıkprogramımızhatasızbirşekildeçalışıyor. Birdeötekiörneğimizielealalım: sayı1 = input("Toplama işlemi için ilk sayıyı girin: ") sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ") print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Bu kodların beklediğimiz çıktıyı vermeyeceğini biliyoruz. Ama eğer bu kodları şöyle yazarsak işlerdeğişir: v1 = input("Toplama işlemi için ilk sayıyı girin: ") v2 = input("Toplama işlemi için ikinci sayıyı girin: ") sayı1 = int(v1) #v1 adlı karakter dizisini sayıya dönüştürüyoruz. sayı2 = int(v2) #v2 adlı karakter dizisini sayıya dönüştürüyoruz. print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Gördüğünüz gibi, input() fonksiyonundan gelen karakter dizilerini sayıya dönüştürerek istediğimizçıktıyıalabiliyoruz. 11.2.2 str() Python’daki tip dönüştürücüleri elbette sadece int() fonksiyonuyla sınırlı değildir. Gördüğünüz gibi, int() fonksiyonu sayı değerli verileri (mesela karakter dizilerini) tam sayıya dönüştürüyor. Bunun bir de tersi mümkündür. Yani karakter dizisi olmayan verileri karakter dizisine dönüştürmemiz de mümkündür. Bu işlem için str() adlı başka bir tip dönüştürücüdenyararlanıyoruz: >>> sayı = 23 >>> kardiz = str(sayı) >>> print(kardiz) 23 >>> print(type(kardiz)) <class ’str’> Gördüğünüz gibi, bir tam sayı olan 23’ü str() adlı bir fonksiyondan yararlanarak karakter dizisi olan “23” ifadesine dönüştürdük. Son satırda da, elde ettiğimiz şeyin bir karakter dizisi olduğundaneminolmakiçintype()fonksiyonunukullanarakverinintipinidenetledik. Yukarıdaki örneklerden gördüğümüz gibi, aritmetik işlemler yapmak istediğimizde karakter dizilerinisayıyaçevirmemizgerekiyor.Pekiacabahangidurumlardabununtersiniyapmamız, yani sayıları karakter dizilerine çevirmemiz gerekir? Python bilginiz ve tecrübeniz arttıkça 128 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 bunların hangi durumlar olduğunu kendiniz de göreceksiniz. Mesela biz daha şimdiden, sayıları karakter dizisine çevirmemiz gereken bir durumla karşılaştık. Hatırlarsanız, len() fonksiyonunuanlatırken,bufonksiyonunsayılarlabirliktekullanılamayacağınısöylemiştik: >>> len(12343423432) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: object of type ’int’ has no len() Peki ya yazdığınız programda bir sayının kaç haneden oluştuğunu hesaplamanız gerekirse ne yapacaksınız? Yani mesela yukarıdaki sayının 11 haneli olduğunu bilmeniz gerekiyorsa ne olacak? İşteböylebirdurumdastr()fonksiyonundanyararlanabilirsiniz: >>> sayı = 12343423432 >>> kardiz = str(sayı) >>> len(kardiz) 11 Bildiğiniz gibi, len() fonksiyonu, şu ana kadar öğrendiğimiz veri tipleri içinde sadece karakterdizileriüzerindeişlemyapabiliyor.Bizdebuyüzden,sayımızınkaçhaneliolduğunu öğrenebilmek için, öncelikle bu sayıyı bir karakter dizisine çeviriyoruz. Daha sonra da elde ettiğimizbukarakterdizisinilen()fonksiyonunaparametreolarakveriyoruz.Böylecesayının kaçhaneliolduğubilgisinieldeetmişoluyoruz. Buaradaelbetteyukarıdakiişlemiteksatırdadahalledebilirsiniz: >>> len(str(12343423432)) 11 Bu şekilde iç içe geçmiş fonksiyonlar yazdığımızda, Python fonksiyonları içten dışa doğru tek tek değerlendirecektir. Mesela yukarıdaki örnekte Python önce str(12343423432) ifadesini değerlendirecek ve çıkan sonucu len() fonksiyonuna gönderecektir. İç içe geçmiş fonksiyonlarıyazarkendikkatetmemizgerekenönemlibirnoktada,açtığımızherbirparantezi tektekkapatmayıunutmamaktır. 11.2.3 float() Hatırlarsanız ilk bölümlerde sayılardan söz ederken tamsayıların (integer) dışında kayan noktalı sayıların (float) da olduğundan söz etmiştik. İşte eğer bir tamsayıyı veya sayı değerli bir karakter dizisini kayan noktalı sayıya dönüştürmek istersek float() adlı başka bir dönüştürücüdenyararlanacağız: >>> a = 23 >>> type(a) <class ’int’> (sonrakisayfayadevam) 11.2. TipDönüşümleri 129 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> float(a) 23.0 Gördüğünüz gibi, 23 tamsayısı, float() fonksiyonu sayesinde 23.0’a yani bir kayan noktalı sayıyadönüştü. Aynışeyi,sayıdeğerlikarakterdizileriüzerineuygulamakdamümkündür: >>> b = "23" >>> type(b) <class ’str’> >>> float(b) 23.0 11.2.4 complex() Sayılardan söz ederken, eğer matematikle çok fazla içli dışlı değilseniz pek karşılaşmayacağınız, ‘karmaşık sayı’ adlı bir sayı türünden de bahsetmiştik. Karmaşık sayılar Python’da ‘complex’ ifadesiyle gösteriliyor. Mesela şunun bir karmaşık sayı olduğunu biliyoruz: >>> 12+0j Kontroledelim: >>> type(12+0j) <class ’complex’> İşte eğer herhangi bir sayıyı karmaşık sayıya dönüştürmeniz gerekirse complex() adlı bir fonksiyondanyararlanabilirsiniz.Örneğin: >>> complex(15) (15+0j) BöylecePython’dakibütünsayıdönüştürücüleriöğrenmişolduk. Gelin isterseniz, bu bölümde anlattığımız konuları şöyle bir tekrar ederek bilgilerimizi sağlamlaştırmayaçalışalım. >>> a = 56 Bu sayı bir tamsayıdır. İngilizce olarak ifade etmek gerekirse, integer. Bunun bir tamsayı olduğunuşuşekildeteyitedebileceğimizigayetiyibiliyorsunuz: 130 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 >>> type(a) <class ’int’> Burada aldığımız <class int> çıktısı, bize a değişkeninin tuttuğu sayının bir tamsayı olduğunu söylüyor.‘int’ifadesi,integer(tamsayı)kelimesininkısaltmasıdır. Birdeşusayıyabakalım: >>> b = 34.5 >>> type(b) <class ’float’> Bu çıktı ise bize 34.5 sayısının bir kayan noktalı sayı olduğunu söylüyor. float kelimesi Floats veyaFloatingPointNumberifadesininkısaltmasıdır.Yani‘kayannoktalısayı’demektir. Bu arada, bu type() adlı fonksiyonu sadece sayılara değil, başka şeylere de uygulayabileceğimizibiliyorsunuz.Meselabirörnekvermekgerekirse: >>> meyve = "karpuz" >>> type(meyve) <class ’str’> Gördüğünüzgibi,type()fonksiyonubizemeyveadlıdeğişkenindeğerininbir‘str’yanistring yanikarakterdizisiolduğunubildirdi. Buveritipleriarasında,bazıözelfonksiyonlarıkullanarakdönüştürmeişlemiyapabileceğimizi öğrendik.Mesela: >>> sayı = 45 sayıadlıdeğişkenintuttuğuverinindeğeribirtamsayıdır.Bizbutamsayıyıkayannoktalısayıya dönüştürmekistiyoruz.Yapacağımızişlemçokbasit: >>> float(sayı) 45.0 Gördüğünüz gibi, 45 adlı tamsayıyı, 45.0 adlı bir kayan noktalı sayıya dönüştürdük. Şimdi type(45.0)komutubize<class‘float’>çıktısınıverecektir. Eğerkayannoktalıbirsayıyıtamsayıyaçevirmekistersekşukomutuveriyoruz.Meselakayan noktalısayımız,56.5olsun: >>> int(56.5) 56 Yukarıdakiörneğitabiikişöyledeyazabiliriz: 11.2. TipDönüşümleri 131 PythonBelgeleri,Yayım4.1.3 >>> a = 56.5 >>> int(a) 56 Dönüştürmeişleminisayılararasındayapabileceğimizgibi,sayılarvekarakterdizileriarasında dayapabiliriz.Örneğinşubirkarakterdizisidir: >>> nesne = "45" Yukarıdakideğeritırnakiçindebelirttiğimiziçinbudeğerbirkarakterdizisidir.Şimdibunubir tamsayıyaçevireceğiz: >>> int(nesne) 45 Dilersek,aynıkarakterdizisinikayannoktalısayıyadaçevirebiliriz: >>> float(nesne) 45.0 Hattabirsayıyıkarakterdizisinedeçevirebiliriz.Bununiçinstring(karakterdizisi)kelimesinin kısaltmasıolanstrifadesinikullanacağız: >>> s = 6547 >>> str(s) ’6547’ Birörnekdekayannoktalısayılarlayapalım: >>> s = 65.7 >>> str(s) ’65.7’ Yalnız şunu unutmayın: Bir karakter dizisinin sayıya dönüştürülebilmesi için o karakter dizisinin sayı değerli olması lazım. Yani “45” değerini sayıya dönüştürebiliriz. Çünkü “45” değeri,tırnaklardanötürübirkarakterdizisideolsa,neticedesayıdeğerlibirkarakterdizisidir. Amamesela“elma”karakterdizisiböyledeğildir.Dolayısıyla,şöylebirmacerayagirişmekbizi hüsranauğratacaktır: >>> nesne = "elma" >>> int(nesne) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: invalid literal for int() with base 10: ’elma’ Gördüğünüzgibi,Pythonböylebirişlemdenemesikarşısındahataveriyor... 132 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 Bubölümdepekçokyenişeyöğrendik.Bubölümünenönemligetirisiinput()fonksiyonunu öğrenmemiz oldu. Bu fonksiyon sayesinde kullanıcıyla iletişim kurmayı başardık. Artık kullanıcıdanverialıp,buverileriprogramlarımıziçindeişleyebiliyoruz. Yinebubölümdedikkatiniziçektiğimizbaşkabirkonudasayılarvekarakterdizileriarasındaki ilişkiydi. input() fonksiyonuyla elde edilen çıktının bir karakter dizisi olduğunu öğrendik. Bildiğimiz gibi, aritmetik işlemler ancak sayılar arasında yapılabilir. Dolayısıyla input() fonksiyonuyla gelen karakter dizisini bir sayıyla çarpmaya kalkarsak hata alıyoruz. Burada yapmamızgerekenşey,elimizdekiverileridönüştürmek.Yaniinput()fonksiyonundangelen karakter dizisini bir sayıyla çarpmak istiyorsak, öncelikle aldığımız karakter dizisini sayıya dönüştürmemizgerekiyor.Dönüştürmeişlemleriiçinkullandığımızfonksiyonlarşunlardı: int() Sayıdeğerlibirkarakterdizisiniveyakayannoktalısayıyıtamsayıya(integer) çevirir. float() Sayı değerli bir karakter dizisini veya tamsayıyı kayan noktalı sayıya (float) çevirir. str() Birtamsayıveyakayannoktalısayıyıkarakterdizisine(string)çevirir. complex() Herhangi bir sayıyı veya sayı değerli karakter dizisini karmaşık sayıya (complex)çevirir. Ayrıcabubölümdeöğrendiklerimiz,şöyleönemlibirtespittebulunmamızadaolanaktanıdı: Hertamsayıve/veyakayannoktalısayıbirkarakterdizisinedönüştürülebilir.Ama herkarakterdizisitamsayıyave/veyakayannoktalısayıyadönüştürülemez. Örneğin, 5654 gibi bir tamsayıyı veya 543.34 gibi bir kayan noktalı sayıyı str() fonksiyonu yardımıylakarakterdizisinedönüştürebiliriz: >>> str(5654) >>> str(543.34) “5654” karakter dizisini int() fonksiyonu ile tamsayıya, float() fonksiyonu ile de bir kayan noktalısayıyadönüştürebiliriz: >>> int("5654") >>> float("5654") veya “543.34” gibi bir karakter dizisini float() fonksiyonu yardımıyla kayan noktalı sayıya dönüştürebiliriz: >>> float("543.34") Ancak“543.34”karakterdizisiniint()fonksiyonuilebirliktekullanırsakhataalırız,çünkü543.34 birtamsayıolamaz.Eğeramacımız“543.34”karakterdizisinisayısaldeğergibidüşünüpaşağı yuvarlamakolsaydışöylebirşeyyapabilirdik: >>> x = float("543.34") >>> x (sonrakisayfayadevam) 11.2. TipDönüşümleri 133 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 543.34 >>> int(x) 543 >>> Aşağı değil de yukarı yuvarlamak istersek en son elde ettiğimiz 543 değerine bir eklemek yeterliolurdu. Ama “elma” gibi bir karakter dizisini ne int() ne de float() fonksiyonuyla tamsayıya veya kayannoktalısayıyadönüştürebiliriz!Çünkü“elma”verisisayıdeğerlideğildir. Bu bölümü kapatmadan önce, dilerseniz şimdiye kadar öğrendiklerimizi de içeren örnek bir programyazalım.Buprogram,Pythonmaceramızaçısındanbizeyenikapılardaaçacak. Önceki derslerimizin birinde verdiğimiz doğalgaz faturası hesaplayan programı hatırlarsınız. İşteartıkinput()fonksiyonusayesindebudoğalgazfaturasıhesaplamaprogramınıdadaha ilginçbirhalegetirebiliriz: #Her bir ayın kaç gün çektiğini tanımlıyoruz ocak = mart = mayıs = temmuz = ağustos = ekim = aralık = 31 nisan = haziran = eylül = kasım = 30 şubat = 28 #Doğalgazın vergiler dahil metreküp fiyatı birimFiyat = 0.79 #Kullanıcı ayda ne kadar doğalgaz tüketmiş? aylıkSarfiyat = input("Aylık doğalgaz sarfiyatınızı metreküp olarak giriniz: ") #Kullanıcı hangi aya ait faturasını öğrenmek istiyor? dönem = input("""Hangi aya ait faturayı hesaplamak istersiniz? (Lütfen ay adını tamamı küçük harf olacak şekilde giriniz)\n""") #Yukarıdaki input() fonksiyonundan gelen veriyi ’ #Python ın anlayabileceği bir biçime dönüştürüyoruz ay = eval(dönem) #Kullanıcının günlük doğalgaz sarfiyatı günlükSarfiyat = int(aylıkSarfiyat) / ay #Fatura tutarı fatura = birimFiyat * günlükSarfiyat * ay print("günlük sarfiyatınız: \t", günlükSarfiyat, " metreküp\n", "tahmini fatura tutarı: \t", fatura, " TL", sep="") Burada yine bilmediğimiz bir fonksiyonla daha karşılaştık. Bu fonksiyonun adı eval(). Biraz sonra eval() fonksiyonunu derinlemesine inceleyeceğiz. Ama bu fonksiyonu anlatmaya geçmedenöncedilersenizyukarıdakikodlarıbirazdidikleyelim. İlksatırlarınneişeyaradığınızatenbiliyorsunuz.Biryıliçindekibütünaylarınkaçgünçektiğini gösteren değişkenlerimizi tanımladık. Burada her bir değişkeni tek tek tanımlamak yerine 134 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 değişkenleri topluca tanımladığımıza dikkat edin. İsteseydik tabii ki yukarıdaki kodları şöyle deyazabilirdik: #Her bir ayın kaç gün çektiğini tanımlıyoruz ocak = 31 şubat = 28 mart = 31 nisan = 30 mayıs = 31 haziran = 30 temmuz = 31 ağustos = 31 eylül = 30 ekim = 31 kasım = 30 aralık = 31 #Doğalgazın vergiler dahil m3 fiyatı birimFiyat = 0.79 #Kullanıcı ayda ne kadar doğalgaz tüketmiş? aylıkSarfiyat = input("Aylık doğalgaz sarfiyatınızı m3 olarak giriniz: ") #Kullanıcı hangi aya ait faturasını öğrenmek istiyor? dönem = input("""Hangi aya ait faturayı hesaplamak istersiniz? (Lütfen ay adını tamamı küçük harf olacak şekilde giriniz)\n""") #Yukarıdaki input() fonksiyonundan gelen veriyi ’ #Python ın anlayabileceği bir biçime dönüştürüyoruz ay = eval(dönem) #Kullanıcının günlük doğalgaz sarfiyatı günlükSarfiyat = int(aylıkSarfiyat) / ay #Fatura tutarı fatura = birimFiyat * günlükSarfiyat * ay print("günlük sarfiyatınız: \t", günlükSarfiyat, " metreküp\n", "tahmini fatura tutarı: \t", fatura, " TL", sep="") Ama tabii ki, değişkenleri tek tek tanımlamak yerine topluca tanımlamak, daha az kod yazmanızısağlamasınınyanısıra,programınızınçalışmaperformansıaçısındandadahaiyidir. Yanideğişkenleribuşekildetanımladığınızdaprogramınızdahahızlıçalışır. Programımızıincelemeyedevamedelim... Değişkenleri tanımladıktan sonra doğalgazın vergiler dahil yaklaşık birim fiyatını da bir değişken olarak tanımladık. 0.79 değerini zaten birkaç bölüm önce hesaplayıp bulduğumuz için, aynı işlemleri tekrar programımıza eklememize gerek yok. Doğrudan nihai değeri programımızayazsakyeter... Birimfiyatıbelirlediktensonrakullanıcıyaaylıkdoğalgazsarfiyatınısoruyoruz.Kullanıcınınbu değeri m3 olarak girmesini bekliyoruz. Elbette bu veriyi kullanıcıdan alabilmek için input() 11.2. TipDönüşümleri 135 PythonBelgeleri,Yayım4.1.3 fonksiyonunukullanıyoruz. Daha sonra kullanıcıya hangi aya ait doğalgaz faturasını ödemek istediğini soruyoruz. Bu bilgi, bir sonraki satırda günlük doğalgaz sarfiyatını hesaplarken işimize yarayacak. Çünkü kullanıcının girdiği ayın çektiği gün sayısına bağlı olarak günlük sarfiyat değişecektir. Günlük sarfiyatı hesaplamak için aylık sarfiyatı, ilgili ayın çektiği gün sayısına bölüyoruz. Bu arada bir önceki satırda dönem değişkenini eval() adlı bir fonksiyonla birlikte kullandığımızı görüyorsunuz.Bunubirazsonrainceleyeceğiz.Oyüzdenbusatırlarıatlayıpsonsatıragelelim. Son satırda print() fonksiyonunu kullanarak, kullanıcıdan aldığımız verileri düzgün bir şekilde kendisine gösteriyoruz. Programımız kullanıcıya günlük doğalgaz sarfiyatını ve ay sonunda karşılaşacağı tahmini fatura tutarını bildiriyor. print() fonksiyonu içinde kullandığımız kaçış dizilerine özellikle dikkatinizi çekmek istiyorum. Burada düzgün bir çıktı elde etmek için \t ve \n adlı kaçış dizilerinden nasıl yararlandığımızı görüyorsunuz. Bu kaçış dizilerinin buradaki işlevini tam olarak anlayabilmek için, bu kodları bir de bu kaçış dizileri olmadanyazmayıdeneyebilirsiniz. Bubilgileri,önemlerindenötürüaklımızdatutmayaçalışalım.Burayakadaranlatılankonular hakkında zihnimizde belirsizlikler varsa veya bazı noktaları tam olarak kavrayamadıysak, şimdiye kadar öğrendiğimiz konuları tekrar gözden geçirmemiz bizim için epey faydalı olacaktır.Zirabundansonrakibölümlerde,yenibilgilerinyanısıra,burayakadaröğrendiğimiz şeyleri de yoğun bir şekilde pratiğe dökeceğiz. Bundan sonraki konuları takip edebilmemiz açısından, buraya kadar verdiğimiz temel bilgileri iyice sindirmiş olmak işimizi bir hayli kolaylaştıracaktır. 11.3 eval() ve exec() Fonksiyonları Bir önceki bölümün son örnek programında eval() adlı bir fonksiyonla karşılaşmıştık. İşte şimdi bu önemli fonksiyonun ne işe yaradığını anlamaya çalışacağız. Ancak eval() fonksiyonunuanlatmayabaşlamadanönceşuuyarıyıyapalım: eval()ŞEYTANİGÜÇLERİOLANBİRFONKSİYONDUR! Bunun neden böyle olduğunu hem biz anlatacağız, hem de zaten bu fonksiyonu tanıdıkça nedeneval()’ekarşıdikkatliolmanızgerektiğinikendinizdeanlayacaksınız. Dilersenizişebasitbireval()örneğivererekbaşlayalım: print(""" Basit bir hesap makinesi uygulaması. İşleçler: + toplama - çıkarma * çarpma / bölme Yapmak istediğiniz işlemi yazıp ENTER tuşuna basın. (Örneğin 23 ve 46 sayılarını çarpmak için 23 * 46 yazdıktan sonra ENTER tuşuna basın.) (sonrakisayfayadevam) 136 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) """) veri = input("İşleminiz: ") hesap = eval(veri) print(hesap) İngilizcedeevaluatediyebirkelimebulunur.Bukelime,‘değerlendirmeyetabitutmak,işleme sokmak, işlemek’ gibi anlamlar taşır. İşte eval() fonksiyonundaki eval kelimesi bu evaluate kelimesinin kısaltmasıdır. Yani bu fonksiyonun görevi, kendisine verilen karakter dizilerini değerlendirmeyetabitutmakyadaişlemektir.Pekibutamolarakneanlamageliyor? Aslında yukarıdaki örnek programı çalıştırdığımızda bu sorunun yanıtını kendi kendimize verebiliyoruz.Buprogramıçalıştırarak,“İşleminiz:“ifadesindensonra,örneğin,45 * 76yazıp Enter tuşuna basarsak programımız bize 3420 çıktısı verecektir. Yani programımız hesap makinesi işlevini yerine getirip 45 sayısı ile 76 sayısını çarpacaktır. Dolayısıyla, yukarıdaki programı kullanarak her türlü aritmetik işlemi yapabilirsiniz. Hatta bu program, son derece karmaşıkaritmetikişlemlerinyapılmasınadahimüsaadeeder. Pekiprogramımızbuişlevinasılyerinegetiriyor?İstersenizkodlarınüzerindentektekgeçelim. Öncelikle programımızın en başına kullanım kılavuzuna benzer bir metin yerleştirdik ve bu metniprint()fonksiyonuyardımıylaekranabastık. Dahasonrakullanıcıdanalacağımızkomutlarıveriadlıbirdeğişkeneatadık.Tabiikikullanıcıyla iletişimiherzamanolduğugibiinput()fonksiyonuyardımıylasağlıyoruz. Ardından, kullanıcıdan gelen veriyi eval() fonksiyonu yardımıyla değerlendirmeye tabi tutuyoruz.Yanikullanıcınıngirdiğikomutlarıişlemesokuyoruz.Örneğin,kullanıcı46 / 2gibi birverigirdiyse,bizeval()fonksiyonuyardımıylabu46 / 2komutunuişletiyoruz.Buişlemin sonucunudahesapadlıbaşkabirdeğişkeniçindedepoluyoruz. Eğer burada eval() fonksiyonunu kullanmazsak, programımız, kullanıcının girdiği 45 * 76 komutunuhiçbirişlemesokmadandümdüzekranabasacaktır.Yani: print(""" Basit bir hesap makinesi uygulaması. İşleçler: + toplama - çıkarma * çarpma / bölme Yapmak istediğiniz işlemi yazıp ENTER tuşuna basın. (Örneğin 23 ve 46 sayılarını çarpmak için 23 * 46 yazdıktan sonra ENTER tuşuna basın.) """) veri = input("İşleminiz: ") (sonrakisayfayadevam) 11.3. eval()veexec()Fonksiyonları 137 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(veri) Eğer programımızı yukarıdaki gibi, eval() fonksiyonu olmadan yazarsak, kullanıcımız 45 * 76 gibi bir komut girdiğinde alacağı cevap dümdüz bir 45 * 76 çıktısı olacaktır. İşte eval() fonksiyonu,kullanıcınıngirdiğiherveriyibirPythonkomutuolarakalgılarvebuveriyiişleme sokar. Yani 45 * 76 gibi bir şey gördüğünde, bu şeyi doğrudan ekrana yazdırmak yerine, işleminsonucuolan3420sayısınıverir. eval() fonksiyonunun, yukarıda anlattığımız özelliklerini okuduktan sonra, ‘Ne güzel bir fonksiyon!Herişimigörürbu!’dediğiniziduyargibiyim.Amaaslındadurumhiçdeöyledeğil. Nedenmi? print(""" Basit bir hesap makinesi uygulaması. İşleçler: + toplama - çıkarma * çarpma / bölme Yapmak istediğiniz işlemi yazıp ENTER tuşuna basın. (Örneğin 23 ve 46 sayılarını çarpmak için 23 * 46 yazdıktan sonra ENTER tuşuna basın.) """) veri = input("İşleminiz: ") hesap = eval(veri) print(hesap) Şimdiyukarıdakiprogramıtekrarçalıştırınve“İşleminiz:“ifadesindensonraşucevabıverin: print("Merhaba Python!") Bukomutşöylebirçıktıvermişolmalı: Merhaba Python! None (cid:242) Not Buradaki None değerini görmezden gelin. Bunu fonksiyonlar konusunu anlatırken inceleyeceğiz. Gördüğünüz gibi, yazdığımız program, kullanıcının girdiği Python komutunun işletilmesine sebepoldu.Bunoktada,‘Eee,neolmuş!’demişolabilirsiniz.Gelinbirdeşunabakalım.Şimdi 138 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 programıtekrarçalıştırıpşucevabıverin: open("deneme.txt", "w") Bu cevap, bilgisayarınızda deneme.txt adlı bir dosya oluşturulmasına sebep oldu. Belki farkındasınız, belki farkında değilsiniz, ama aslında şu anda kendi yazdığınız program sizin kontrolünüzden tamamen çıktı. Siz aslında bir hesap makinesi programı yazmıştınız. Ama eval() fonksiyonu nedeniyle kullanıcıya rastgele Python komutlarını çalıştırma imkanı verdiğiniziçinprogramınızsadecearitmetikişlemlerihesaplamakiçinkullanılmayabilir.Böyle bir durumda kötü niyetli (ve bilgili) bir kullanıcı size çok büyük zarar verebilir. Mesela kullanıcının,yukarıdakiprogramaşöylebircevapverdiğinidüşünün: __import__("os").system("dir") Buradaanlamadığınızşeylerişimdilikbirkenarabırakıp,bukomutunsonuçlarınaodaklanın. Gördüğünüz gibi, yukarıdaki programa bu cevabı vererek mevcut dizin altındaki bütün dosyaları listeleyebildik. Yani programımız bir anda amacını aştı. Artık bu aşamadan sonra bu programı şeytani bir amaca yönelik olarak kullanmak tamamen programı kullanan kişiye kalmış... Bu programın, bir web sunucusu üzerinde çalışan bir uygulama olduğunu ve bu programıkullananlarınyukarıdakigibimasumanebirşekildediziniçindekidosyalarılisteleyen birkomutyerine,diziniçindekidosyalarıvehattasabitdisküzerindekiherşeyisilenbirkomut yazdığını düşünün... Yanlış yazılmış bir program yüzünden bütün verilerinizi kaybetmeniz işten bile değildir. (Bahsettiğim o, ‘bütün sabit diski silen komutu’ kendi sisteminizde vermemenizgerektiğinisöylememegerekyok,değilmi?) Eğer SQL Injection kavramını biliyorsanız, yukarıdaki kodların yol açtığı güvenlik açığını gayet iyi anlamış olmalısınız. Zaten internet üzerinde yaygın bir şekilde kullanılan ve web sitelerini hedef alan SQL Injection tarzı saldırılar da aynı mantık üzerinden gerçekleştiriliyor. SQL Injection metoduyla bir web sitesine saldıran cracker’lar, o web sitesini programlayan kişinin(çoğunluklafarkındaolmadan)kullanıcıyaverdiğirastgeleSQLkomutuişletmeyetkisini kötüye kullanarak gizli ve özel bilgileri ele geçirebiliyorlar. Örneğin SQL Injection metodu kullanılarak, bir web sitesine ait veritabanının içeriği tamamen silinebilir. Aynı şekilde, yukarıdaki eval() fonksiyonu da kullanıcılarınıza rastgele Python komutlarını çalıştırma yetkisi verdiği için kötü niyetli bir kullanıcının programınıza sızmasına yol açabilecek potansiyelesahiptir. Peki eval() fonksiyonunu asla kullanmayacak mıyız? Elbette kullanacağız. Bu fonksiyonun kullanımınıgerektirendurumlarladakarşılaşabilirsiniz.Amaşunuaslaaklınızdançıkarmayın: eval() fonksiyonu her ne kadar son derece yetenekli ve güçlü bir araç da olsa yanlış ellerde yıkıcı sonuçlar doğurabilir. Program yazarken, eğer eval() kullanmanızı gerektiren birdurumlakarşıkarşıyaolduğunuzudüşünüyorsanız,birkezdahadüşünün.eval()ileelde edeceğinizetkiyimuhtemelenbaşkaveçokdahaiyiyöntemlerledeeldeedebilirsiniz.Üstelik performans açısından eval() pek iyi bir tercih değildir, çünkü bu fonksiyon (çoğu durumda farketmesenizde)aslındayavaşçalışır.Oyüzden,eval()fonksiyonunukullanacağınızzaman, bunun artı ve eksilerini çok iyi tartın: Bu fonksiyonu kullanmak size ne kazandırıyor, ne kaybettiriyor? Ayrıca eval() fonksiyonu kullanılacağı zaman, kullanıcıdan gelen veri bu fonksiyona parametre olarak verilmeden önce sıkı bir kontrolden geçirilir. Yani kullanıcının girdiği veri eval() aracılığıyla doğrudan değerlendirmeye tabi tutulmaz. Araya bir kontrol mekanizması yerleştirilir. Örneğin, yukarıdaki hesap makinesi programında kullanıcının gireceği verileri sadecesayılarveişleçlerlesınırlandırabilirsiniz.Yanikullanıcınızın,izinverilendeğerlerharici bir değer girmesini engelleyebilirsiniz. Bu durumu somutlaştırmak için şöyle bir diyagram 11.3. eval()veexec()Fonksiyonları 139 PythonBelgeleri,Yayım4.1.3 çizebiliriz: Yukarıdakidiyagrameval()fonksiyonununyanlışuygulanışbiçiminigösteriyor.Gördüğünüz gibi, veri doğrudan eval() fonksiyonuna gidiyor ve çıktı olarak veriliyor. Böyle bir durumda, eval()fonksiyonukullanıcıdangelenverininneolduğunabakmadan,veriyidoğrudankomut olarakdeğerlendiripişleteceğiiçinprogramınızıkullanıcınıninsafınaterketmişoluyorsunuz. Aşağıdakidiyagramiseeval()fonksiyonunundoğruuygulanışbiçiminigösteriyor: Buradaise,verieval()fonksiyonunaulaşmadanöncekontroldengeçiriliyor.Eğerveriancak kontrol aşamasından geçerse eval() fonksiyona ulaşabilecek ve oradan da çıktı olarak verilebilecektir.Böylecekullanıcıdangelenkomutlarısüzmeimkanınasahipoluyoruz. Gördüğünüz gibi, Python eval() gibi bir fonksiyon yardımıyla karakter dizileri içinde geçen Python kodlarını ayıklayıp bunları çalıştırabiliyor. Bu sayede, mesela bize input() fonksiyonu aracılığıyla gelen bir karakter dizisi içindeki Python kodlarını işletme imkanına sahipolabiliyoruz.Buözellik,dikkatlikullanıldığında,işleriniziepeykolaylaştırabilir. Python’daeval()fonksiyonunaçokbenzeyenexec()adlıbaşkabirfonksiyondahabulunur. eval()ileyapamadığımızbazışeyleriexec()ileyapabiliriz.Bufonksiyonyardımıyla,karakter dizileriiçindekiçokkapsamlıPythonkodlarınıişletebilirsiniz. Örneğin eval() fonksiyonu bir karakter dizisi içindeki değişken tanımlama işlemini yerine getiremez.Yanieval()ileşöylebirşeyyapamazsınız: >>> eval("a = 45") Amaexec()ileböylebirişlemyapabilirsiniz: >>> exec("a = 45") Böyleceaadlıbirdeğişkentanımlamışolduk.Kontroledelim: >>> print(a) 45 eval() ve exec() fonksiyonları özellikle kullanıcıdan alınan verilerle doğrudan işlem yapmak gereken durumlarda işinize yarar. Örneğin bir hesap makinesi yaparken eval() fonksiyonundanyararlanabilirsiniz. 140 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 Aynı şekilde mesela insanlara Python programlama dilini öğreten bir program yazıyorsanız exec()fonksiyonunuşöylekullanabilirsiniz: d1 = """ Python’da ekrana çıktı verebilmek için print() adlı bir fonksiyondan yararlanıyoruz. Bu fonksiyonu şöyle kullanabilirsiniz: >>> print("Merhaba Dünya") Şimdi de aynı kodu siz yazın! >>> """ girdi = input(d1) exec(girdi) d2 = """ Gördüğünüz gibi print() fonksiyonu, kendisine parametre olarak verilen değerleri ekrana basıyor. Böylece ilk dersimizi tamamlamış olduk. Şimdi bir sonraki dersimize geçebiliriz.""" print(d2) Burada exec() ile yaptığımız işi eval() ile de yapabiliriz. Ama mesela eğer bir sonraki derste‘Python’dadeğişkenler’konusunuöğretecekseniz,eval()yerineexec()fonksiyonunu kullanmakdurumundakalabilirsiniz. eval() fonksiyonunu anlatırken güvenlik ile ilgili olarak söylediğimiz her şey exec() fonksiyonuiçindegeçerlidir.Dolayısıylabuikifonksiyonuçokdikkatlibirşekildekullanmanız vebufonksiyonlarındoğurduğugüvenlikaçığınınbilincindeolmanızgerekiyor. Henüz Python bilgilerimiz çok kısıtlı olduğu için eval() ve exec() fonksiyonlarını bütün ayrıntılarıyla inceleyemiyoruz. Ama bilgimiz arttıkça bu fonksiyonların ne kadar güçlü (ve tehlikeli)araçlarolduğunusizdegöreceksiniz. 11.3. eval()veexec()Fonksiyonları 141 PythonBelgeleri,Yayım4.1.3 11.4 format() Metodu Python programlama dili içindeki çok temel bazı araçları incelediğimize göre, bu noktada Python’dakiküçükamaönemlibirkonuyadeğinelimbubölümükapatmadanönce. İnternettedolaşırkenmutlakaşunabenzerbirsayfaylakarşılaşmışolmalısınız: Buradabellikiadresçubuğunafdkgd.comdiyebirURLyazmışız,amaböylebirinternetadresi olmadığıiçin,kullandığımızinternettarayıcısıbizeşöylebirmesajvermiş: Hata! Google Chrome fdkgd.com sitesini bulamadı Şimdidedadasdaf.comadresiniarayalım... Yineböylebiradresolmadığıiçin,budefatarayıcımızbizeşöylebiruyarıgösterecek: Hata! Google Chrome dadasdaf.com sitesini bulamadı Gördüğünüz gibi, hata mesajlarında değişen tek yer, aradığımız sitenin adresi. Yani internet tarayıcımızbuhataiçinşöylebirtaslağasahip: Hata! Google Chrome ... sitesini bulamadı Burada... ilegösterdiğimizyere,bulunamayanURLyerleştiriliyor.PekiböylebirşeyiPython programlamadiliilenasılyapabiliriz? Çokbasit: #Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ") #Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz print("Hata! Google Chrome", url, "sitesini bulamadı") Gördüğünüzgibi,şimdiyekadaröğrendiğimizbilgilerikullanarakböylebirprogramırahatlıkla yazabiliyoruz. Peki ya biz kullanıcının girdiği internet adresini mesela tırnak içinde göstermek istersek ne olacak?Yaniörneğinşöylebirçıktıvermekistersek: Hata! Google Chrome ’fdsfd.com’ sitesini bulamadı Bununiçinyinekarakterdizisibirleştirmeyöntemindenyararlanabilirsiniz: 142 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 #Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ") #Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz print("Hata! Google Chrome", "’" + url + "’", "sitesini bulamadı") Burada, + işaretlerini kullanarak, kullanıcının girdiği adresin sağına ve soluna birer tırnak işaretininasılyerleştirdiğimizedikkatedin. Gördüğünüzgibibuyöntemişeyarıyor,amaortayaçıkankarakterdizisideoldukçakarmaşık görünüyor.İştebutür‘karakterdizisibiçimlendirme’işlemleriiçinPythonbizeçokfaydalıbir araçsunuyor.Buaracınadıformat(). Buaracışöylekullanıyoruz: #Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ") #Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz print("Hata! Google Chrome {} sitesini bulamadı".format(url)) Birdebulunamayaninternetadresinitırnakiçinealalım: print("Hata! Google Chrome ’{}’ sitesini bulamadı".format(url)) Görüyorsunuz ya, biraz önce karakter dizisi birleştirme yöntemini kullanarak gerçekleştirdiğimiz işlemi, çok daha basit bir yolla gerçekleştirme imkanı sunuyor bize buformat()denenaraç... Pekiformat()nasılçalışıyor? Bunuanlamakiçinşubasitörneklerebirbakalım: >>> print("{} ve {} iyi bir ikilidir".format("Python", "Django")) ’Python ve Django iyi bir ikilidir’ >>> print("{} {}’yi seviyor!".format("Ali", "Ayşe")) ’Ali Ayşe’yi seviyor!’ >>> print("{} {} yaşında bir {}dur".format("Ahmet", "18", "futbolcu")) ’Ahmet 18 yaşında bir futbolcudur’ Elbettebuörneklerişöyledeyazabilirdik: >>> metin = "{} ve {} iyi bir ikilidir" >>> metin.format("Python", "Django") ’Python ve Django iyi bir ikilidir’ >>> metin = "{} {}’yi seviyor!" (sonrakisayfayadevam) 11.4. format()Metodu 143 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> metin.format("Ali", "Ayşe") ’Ali Ayşe’yi seviyor!’ >>> metin = "{} {} yaşında bir {}dur" >>> metin.format("Ahmet", "18", "futbolcu") ’Ahmet 18 yaşında bir futbolcudur’ Burada taslak metni doğrudan format() metoduna parametre olarak vermeden önce bir değişkeneatadık.Böylecebumetnidahakolaybirşekildekullanabildik. Bu örneklerin, format() denen aracı anlamak konusunda size epey fikir verdiğini zannediyorum.Amaistersenizbuaracınneolduğunuvenasılçalıştığınıdahaayrıntılıolarak incelemeyegeçmedenöncebaşkabirörnekdahaverelim. Varsayalım ki kullanıcıdan aldığı bilgiler doğrultusunda, özel bir konu üzerine dilekçe oluşturanbirprogramyazmakistiyorsunuz. Dilekçetaslağımızşuşekildeolsun: tarih: T.C. ... ÜNİVERSİTESİ ... Fakültesi Dekanlığına Fakülteniz ..........Bölümü ......... numaralı öğrencisiyim. Ekte sunduğum belgede belirtilen mazeretim gereğince ....... Eğitim-Öğretim Yılı ......... yarıyılında öğrenime ara izni (kayıt dondurma) istiyorum. Bilgilerinizi ve gereğini arz ederim. İmza Ad-Soyadı : T.C. Kimlik No. : Adres : Tel. : Ekler : Amacınız bu dilekçedeki boşluklara gelmesi gereken bilgileri kullanıcıdan alıp, eksiksiz bir dilekçeortayaçıkarmak. Kullanıcıdan bilgi alma kısmı kolay. input() fonksiyonunu kullanarak gerekli bilgileri kullanıcıdanalabileceğimizibiliyorsunuz: tarih = input("tarih: ") üniversite = input("üniversite adı: ") fakülte = input("fakülte adı: ") bölüm = input("bölüm adı: ") (sonrakisayfayadevam) 144 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) öğrenci_no = input("öğrenci no. :") öğretim_yılı = input("öğretim yılı: ") yarıyıl = input("yarıyıl: ") ad = input("öğrencinin adı: ") soyad = input("öğrencinin soyadı: ") tc_kimlik_no = input("TC Kimlik no. :") adres = input("adres: ") tel = input("telefon: ") ekler = input("ekler: ") Bilgileri kullanıcıdan aldık. Peki ama bu bilgileri dilekçe taslağı içindeki boşluklara nasıl yerleştireceğiz? Şu ana kadar öğrendiğimiz print() fonksiyonunu ve \t ve \n gibi kaçış dizilerini kullanarak istediğiniz çıktıyı elde etmeyi deneyebilirsiniz. Ama denediğinizde siz de göreceksiniz ki, bu tür yöntemleri kullanarak yukarıdaki dilekçe taslağını doldurmak inanılmaz zor ve vakit alıcı olacaktır. Halbuki bunların hiçbirine gerek yok. Çünkü Python bize bu tür durumlarda kullanılmaküzereçokpratikbiraraçsunuyor.Şimdiçokdikkatliceinceleyinşukodları: dilekçe = """ tarih: {} T.C. {} ÜNİVERSİTESİ {} Fakültesi Dekanlığına Fakülteniz {} Bölümü {} numaralı öğrencisiyim. Ekte sunduğum belgede belirtilen mazeretim gereğince {} Eğitim-Öğretim Yılı {}. yarıyılında öğrenime ara izni (kayıt dondurma) istiyorum. Bilgilerinizi ve gereğini arz ederim. İmza Ad : {} Soyad : {} T.C. Kimlik No. : {} Adres : {} Tel. : {} Ekler : {} """ tarih = input("tarih: ") üniversite = input("üniversite adı: ") fakülte = input("fakülte adı: ") bölüm = input("bölüm adı: ") öğrenci_no = input("öğrenci no. :") (sonrakisayfayadevam) 11.4. format()Metodu 145 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) öğretim_yılı = input("öğretim yılı: ") yarıyıl = input("yarıyıl: ") ad = input("öğrencinin adı: ") soyad = input("öğrencinin soyadı: ") tc_kimlik_no = input("TC Kimlik no. :") adres = input("adres: ") tel = input("telefon: ") ekler = input("ekler: ") print(dilekçe.format(tarih, üniversite, fakülte, bölüm, öğrenci_no, öğretim_yılı, yarıyıl, ad, soyad, tc_kimlik_no, adres, tel, ekler)) Bukodlara(vebundanöncekiörneklere)bakarakbirkaçtespittebulunalım: 1. Taslakmetindekullanıcıdanalınacakbilgilerinolduğuyerlerebirer{}işaretiyerleştirdik. 2. Taslaktakieksiklikleritamamlayacakverileriinput()fonksiyonuyardımıylakullanıcıdan tektekaldık. 3. Son olarak, print() fonksiyonu yardımıyla metni tam bir şekilde ekrana çıktı olarak verdik. Şimdi son tespitimizi biraz açıklayalım. Gördüğünüz gibi, print() fonksiyonu içinde dilekçe.format() gibi bir yapı var. Burada dilekçe değişkenine nokta işareti ile bağlanmış format() adlı, fonksiyon benzeri bir araç görüyoruz. Bu araca teknik dilde ‘metot’ adı verilir. format() metodunun parantezleri içinde ise, kullanıcıdan alıp birer değişkene atadığımız verileryeralıyor. Dilerseniz yukarıda olan biteni daha net anlayabilmek için bu konunun başına verdiğimiz örnekleregeridönelim. İlkolarakşöylebirörnekvermiştik: #Öncelikle kullanıcıdan bir internet adresi girmesini istiyoruz url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ") #Şimdi de bu adresin bulunamadığı konusunda kullanıcıyı bilgilendiriyoruz print("Hata! Google Chrome {} sitesini bulamadı".format(url)) Burada kullanıcının gireceği internet adresinin yerini tutması için {} işaretlerinden yararlanarakşöylebirkarakterdizisioluşturduk: "Hata! Google Chrome {} sitesini bulamadı" Gördüğünüzgibi,{}işaretikarakterdizisiiçindeURL’ningeleceğiyeritutuyor.Bu{}işaretinin yerineneyingeleceğiniformat()metodununparantezleriiçindebelirtiyoruz.Dikkatlicebakın: print("Hata! Google Chrome {} sitesini bulamadı".format(url)) Elbetteeğeristersekyukarıdakiörneğişöyledeyazabilirdik: 146 Bölüm11. KullanıcıdanBilgiAlmak PythonBelgeleri,Yayım4.1.3 url = input("Lütfen ulaşmak istediğiniz sitenin adresini yazın: ") #Kullanıcıya gösterilecek hata için bir taslak metin oluşturuyoruz hata_taslağı = "Hata! Google Chrome {} sitesini bulamadı" print(hata_taslağı.format(url)) Buradahatametniniiçerenkarakterdizisinidoğrudanformat()metodunabağlamakyerine, bunubirdeğişkeneatayıp,format()metodunubudeğişkenebağladık. Bunundışındaşuörnekleridevermiştik: >>> metin = "{} ve {} iyi bir ikilidir" >>> metin.format("Python", "Django") ’Python ve Django iyi bir ikilidir >>> metin = "{} {}’yi seviyor!" >>> metin.format("Ali", "Ayşe") ’Ali Ayşe’yi seviyor!’ >>> metin = "{} {} yaşında bir {}dur" >>> metin.format("Ahmet", "18", "futbolcu") ’Ahmet 18 yaşında bir futbolcudur’ Burada da, gördüğüz gibi, öncelikle bir karakter dizisi tanımlıyoruz. Bu karakter dizisi içindeki değişken değerleri ise {} işaretleri ile gösteriyoruz. Daha sonra format() metodunu alıp bu karakter dizisine bağlıyoruz. Karakter dizisi içindeki {} işaretleri ile gösterdiğimiz yerlere gelecek değerleri de format() metodunun parantezleri içinde gösteriyoruz. Yalnız burada şuna dikkat etmemiz lazım: Karakter dizisi içinde kaç tane {} işareti varsa, format() metodununparantezleriiçindedeosayıdadeğerolmasıgerekiyor. Bu yapının, yazdığımız programlarda işimizi ne kadar kolaylaştıracağını tahmin edebilirsiniz. Kısa karakter dizilerinde pek belli olmayabilir, ama özellikle çok uzun ve boşluklu karakter dizilerini biçimlendirirken format() metodunun hayat kurtardığına kendiniz de şahit olacaksınız. İlerleyen derslerimizde format() metodunu ve karakter dizisi biçimlendirme konusunu çok dahaayrıntılıbirşekildeinceleyeceğiz.Ancakyukarıdaverdiğimizbilgilerformat()metodunu verimlibirşekildekullanabilmenizisağlamayayetecekdüzeydedir. 11.4. format()Metodu 147 12 BÖLÜM Koşullu Durumlar ArtıkPythonprogramlamadilindebellibirnoktayageldiksayılır.Amaeğerfarkettiyseniz,yine de elimizi kolumuzu bağlayan, istediğimiz şeyleri yapmamıza engel olan bir şeyler var. İşte bu bölümde, Python programlama dilinde hareket alanımızı bir hayli genişletecek araçları tanıyacağız. Aslında sadece bu bölümde değil, bu bölümü takip eden her bölümde, hareket alanımızı kısıtlayanduvarlarıtektekyıktığımızaşahitolacaksınız.Özelliklebubölümdeinceleyeceğimiz ‘koşulludurumlar’konusu,tabiryerindeyse,Python’daboyutatlamamızısağlayacak. Ohaldehiçvakitkaybetmedenyolakoyulalım... Şimdiye kadar öğrendiğimiz Python bilgilerini kullanarak şöyle bir program yazabileceğimizi biliyorsunuz: yaş = 15 print("""Programa hoşgeldiniz! Programımızı kullanabilmek için en az 13 yaşında olmalısınız.""") print("Yaşınız: ", yaş) Burada yaptığımız şey çok basit. Öncelikle, değeri 15 olan, yaş adlı bir değişken tanımladık. Dahasonra,programımızıçalıştırankullanıcılariçinbirhoşgeldinmesajıhazırladık.Sonolarak dayaşdeğişkeninindeğeriniekranayazdırdık. Bu programın özelliği tek sesli bir uygulama olmasıdır. Yani bu programda kullanıcıyla herhangi bir etkileşim yok. Burada bütün değerleri/değişkenleri programcı olarak kendimiz belirliyoruz.Buprogramınnekadaryavanolduğunuherhaldesöylemeyegerekyok. Ancak yine önceki derslerde öğrendiğimiz input() fonksiyonu yardımıyla yukarıdaki programınüzerindekiyavanlığıbirnebzedeolsaatabilir,buprogramırahatlıklaçokseslibir halegetirebilir,yanikullanıcıylaetkileşimiçinegirebiliriz. 148 PythonBelgeleri,Yayım4.1.3 Yukarıdaki tek sesli uygulamayı, input() fonksiyonunu kullanarak çok sesli bir hale nasıl getireceğimizigayetiyibildiğinizeeminim: print("""Programa hoşgeldiniz! Programımızı kullanabilmek için en az 13 yaşında olmalısınız.""") print("Lütfen yaşınızı girin.\n") yaş = input("Yaşınız: \t") print("Yaşınız: ", yaş) Tıpkı bir önceki uygulamada olduğu gibi, burada da yaptığımız şey çok basit. İlk örnekte yaş değişkeninin değerini kendimiz elle yazmıştık. İkinci örnekte ise bu yaş değişkenini kullanıcıdan alıyoruz ve tıpkı ilk örnekte olduğu gibi, bu değişkenin değerini ekrana yazdırıyoruz. Bu arada, yukarıdaki uygulamada yer verdiğimiz \n ve \t adlı kaçış dizileri de artık sizin için oldukçatanıdık.\nkaçışdizisiyardımıylabiraltsatırageçtiğimizi,\tadlıkaçışdizisiyardımıyla dabirsekmelikboşlukbıraktığımızıbiliyorsunuz. Gördüğünüz gibi, şu ana kadar öğrendiklerimizle ancak kullanıcıdan gelen yaş bilgisini ekranayazdırabiliyoruz.Öğrendiğimizinput()fonksiyonubizekullanıcıdanbilgialmaimkanı sağlıyor. Ama kullanıcıdan gelen bu bilgiyi şimdilik ancak olduğu gibi kullanabiliyoruz. Yani mesela yukarıdaki örneği dikkate alarak konuşacak olursak, kullanıcının yaşı eğer 13’ün üzerindeyse onu programa kabul edecek, yok eğer 13 yaşın altındaysa da programdan atacak bir mekanizma üretemiyoruz. Yapabildiğimiz tek şey, kullanıcının girdiği veriyi ekrana yazdırmak. Yukarıda verdiğimiz örneklerle nereye varmaya çalıştığımızı az çok tahmin etmişsinizdir. Dikkat ederseniz yukarıda sözünü ettiğimiz şey koşullu bir durum. Yani aslında yapmak istediğimiz şey, kullanıcının yaşını denetleyip, onun programa kabul edilmesini 13 yaşından büyükolmakoşulunabağlamak. İsterseniztamolaraknedenbahsettiğimizianlayabilmekiçin,birkaçvakaörneğiverelim. DiyelimkiGoogle’ınGmailhizmetiaracılığıylabire.postahesabıaldınız.Buhesabagireceğiniz zamanGmailsizebirkullanıcıadıveparolasorar.Sizdekendinizeaitkullanıcıadınıveparolayı sayfadaki kutucuklara yazarsınız. Eğer yazdığınız kullanıcı adı ve parola doğruysa hesabınıza erişebilirsiniz.Amaeğerkullanıcıadınızveparolanızdoğrudeğilsehesabınızaerişemezsiniz. Yanie.postahesabınızaerişmeniz,kullanıcıadıveparolayıdoğrugirmekoşulunabağlıdır. Ya da şu vaka örneğini düşünelim: Diyelim ki Pardus’ta komut satırı aracılığıyla güncelleme işlemi yapacaksınız. sudo pisi up komutunu verdiğiniz zaman güncellemelerin listesi size bildirilecek, bu güncellemeleri yapmak isteyip istemediğiniz sorulacaktır. Eğer evet cevabı verirseniz güncelleme işlemi başlar. Ama eğer hayır cevabı verirseniz güncelleme işlemi başlamaz. Yani güncelleme işleminin başlaması kullanıcının evet cevabı vermesi koşuluna bağlıdır. İştebubölümdebizbutürkoşulludurumlardansözedeceğiz. 149 PythonBelgeleri,Yayım4.1.3 12.1 Koşul Deyimleri Hiç kuşkusuz, koşula bağlı durumlar Python’daki en önemli konulardan biridir. Giriş bölümünde bahsettiğimiz koşullu işlemleri yapabilmek için ‘koşul deyimleri’ adı verilen birtakımaraçlardanyararlanacağız.Gelinşimdibuaraçlarınnelerolduğunugörelim. 12.1.1 if Python programlama dilinde koşullu durumları belirtmek için üç adet deyimden yararlanıyoruz: • if • elif • else İstersenizönceifdeyimiilebaşlayalım... Eğerdahaöncedenherhangibirprogramlamadiliniazdaolsakurcalamafırsatınızolduysa,bir programlamadilindeifdeyimlerininneişeyaradığınıazçokbiliyorsunuzdur.Dahaönceden hiç programcılık deneyiminiz olmamışsa da ziyanı yok. Zira bu bölümde if deyimlerinin ne işeyaradığınıvenerelerdekullanıldığınıenineboyunatartışacağız. İngilizce bir kelime olan ‘if’, Türkçede ‘eğer’ anlamına gelir. Anlamından da çıkarabileceğimiz gibi, bu kelime bir koşul bildiriyor. Yani ‘eğer bir şey falanca ise...’ ya da ‘eğer bir şey filanca ise...’ gibi... İşte biz Python’da bir koşula bağlamak istediğimiz durumları if deyimi aracılığıylagöstereceğiz. Gelinistersenizbudeyiminasılkullanacağımızadairufacıkbirörnekvererekişebaşlayalım: Öncelikleelimizdeşöylebirdeğişkenolsun: n = 255 Yukarıda verdiğimiz değişkenin değerinin bir karakter dizisi değil, aksine bir sayı olduğunu görüyoruz.Şimdibudeğişkenindeğerinisorgulayalım: if n > 10: Buradasayının10’danbüyükolupolmadığınabakıyoruz. Buradagördüğümüz>işaretininnedemekolduğunuaçıklamayagerekyoksanırım.Hepimizin bildiği ‘büyüktür’ işareti Python’da da aynen bildiğimiz şekilde kullanılıyor. Mesela ‘küçüktür’ demek isteseydik, < işaretini kullanacaktık. İsterseniz hemen şurada araya girip bu işaretleri yenidenhatırlayalım: tabularytabulary İşleç Anlamı > büyüktür < küçüktür >= büyükeşittir <= küçükeşittir == eşittir != eşitdeğildir 150 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi hiçbiri bize yabancı gelecek gibi değil. Yalnızca en sondaki ‘eşittir’ (==) ve ‘eşitdeğildir’(!=)işaretleribirazdeğişikgelmişolabilir.Burada‘eşittir’işaretinin=olmadığına dikkat edin. Python’da = işaretini değer atama işlemleri için kullanıyoruz. == işaretini ise iki adetdeğerinbirbirineeşitolupolmadığınıdenetlemekiçin... Mesela: >>> a = 26 Buradadeğeri26olanaadlıbirdeğişkenbelirledik.Yaniadeğişkeninedeğerolarak26sayısını atadık. Ayrıca burada, değer atama işleminin ardından Enter tuşuna bastıktan sonra Python hiçbirşeyyapmadanbiraltsatırageçti.Birdeşunabakalım: >>> a == 26 True Burada ise yaptığımız şey a değişkeninin değerinin 26 olup olmadığını sorgulamak a == 26 komutunu verdikten sonra Python bize True diye bir çıktı verdi. Bu çıktının anlamını biraz sonraöğreneceğiz.Amaşimdiistersenizkonuyudahafazladağıtmayalım.Bizşimdiliksadece =ve==işaretlerininbirbirindentamamenfarklıanlamlarageldiğinibilelimyeter. Nediyorduk? if n > 10: BuifadeylePython’aşöylebirşeydemişoluyoruz: Eğernsayısınındeğeri10’danbüyükse... Burada kullandığımız işaretlere dikkat edin. En sonda bir adet: işaretinin olduğunu gözden kaçırmıyoruz. Bu tür işaretler Python için çok önemlidir. Bunları yazmayı unutursak Python gözümüzünyaşınabakmayacaktır. Dedikki,if n > 10:ifadesi,‘eğerndeğişkeninindeğeri10’danbüyükse...’anlamınagelir.Bu ifadenineksikolduğuapaçıkortada.Yanibellikibucümleninbirdedevamıolmasıgerekiyor. Ohaldebizdedevamınıgetirelim: if n > 10: print("sayı 10’dan büyüktür!") Burada çok önemli bir durumla karşı karşıyayız. Dikkat ederseniz, ikinci satırı ilk satıra göre girintili yazdık. Elbette bunu şirinlik olsun diye yapmadık. Python programlama dilinde girintiler çok büyük önem taşır. Hatta ne kadarlık bir girinti verdiğiniz bile önemlidir. Eğer Python kodlarına duyarlı bir metin düzenleyici kullanıyorsanız, kullandığınız metin düzenleyici çoğu durumda sizin yerinize uygun bir şekilde girintilemeyi yapacaktır. Mesela IDLE adlı geliştirme ortamını kullananlar, ilk satırdaki: işaretini koyup Enter tuşuna bastıklarında otomatik olarak girinti verildiğini farkedeceklerdir. Eğer kullandığınız metin düzenleyici, satırları otomatik olarak girintilemiyorsa sizin bu girintileme işlemini elle yapmanızgerekecektir.Yalnızellegirintilerken,nekadargirintivereceğimizedikkatetmeliyiz. Genelkuralolarak4boşluklukbirgirintilemeuygunolacaktır.Girintilemeişleminiklavyedeki sekme(Tab)tuşunabasarakdayapabilirsiniz.Amaaynıprogramiçindesekmelerleboşlukları karıştırmayın. Yani eğer girintileme işlemini klavyedeki boşluk (Space) tuşuna basarak yapıyorsanız, program boyunca aynı şekilde yapın. (Ben size girinti verirken Tab tuşu yerine Spacetuşunukullanmanızıtavsiyeederim).Kısacasöylemekgerekirse;Python’dagirintileme 12.1. KoşulDeyimleri 151 PythonBelgeleri,Yayım4.1.3 ve girintilemede tutarlılık çok önemlidir. Özellikle büyük programlarda, girintilemeler açısındantutarsızlıkgösterilmesiprogramınçalışmamasınasebepolabilir. (cid:242) Not Python’da girintileme konusuyla ilgili daha ayrıntılı bilgi için: http://www..com/blog/python-ve-metin-duzenleyiciler.html16 (arşivlinki) Eğer yukarıdaki if bloğunu bir metin düzenleyici içine değil de doğrudan etkileşimli kabuğa yazmışsanız bazı şeyler dikkatinizi çekmiş olmalı. Etkileşimli kabukta if sayı > 10: satırını yazıpEntertuşunabastığınızdaşöylebirgörüntüylekarşılaşmışolmalısınız: >>> if n > 10: ... Dikkat ederseniz, >>> işareti, ... işaretine dönüştü. Eğer bu noktada herhangi bir şey yazmadanEntertuşunabasacakolursanızPythonsizeşöylebirhatamesajıverecektir: File "<stdin>", line 2 ^ IndentationError: expected an indented block Hatamesajındadasöylendiğigibi,Pythonbizdengirintilenmişbirblokbeklerken,bizonunbu beklentisini karşılamamışız. Dolayısıyla bize yukarıdaki hata mesajını göstermiş. ... işaretini gördükten sonra yapmamız gereken şey, dört kez boşluk (Space) tuşuna basarak girinti oluşturmakveifbloğunundevamınıyazmakolmalıydı.Yanişöyle: >>> if n > 10: ... print("sayı 10’dan büyüktür!") ... Gördüğünüz gibi, print() fonksiyonunu yazıp Enter tuşuna bastıktan sonra yine ... işaretini gördük. Python burada bizden yeni bir satır daha bekliyor. Ama bizim yazacak başka bir kodumuz olmadığı için tekrar Enter tuşuna basıyoruz ve nihai olarak şöyle bir görüntü elde ediyoruz: >>> if n > 10: ... print("sayı 10’dan büyüktür!") ... sayı 10’dan büyüktür! >>> Demek ki 255 sayısı 10’dan büyükmüş! Ne büyük bir buluş! Merak etmeyin, daha çok şey öğrendikçe daha mantıklı programlar yazacağız. Burada amacımız işin temelini kavramak. Bunudaeniyi,(çokmantıklıolmasabile)basitprogramlaryazarakyapabiliriz. Şimdi metin düzenleyicimizi açarak daha mantıklı şeyler yazmaya çalışalım. Zira yukarıdaki örnektedeğişkenikendimizbelirlediğimiziçin,budeğişkenindeğeriniifdeyimleriyardımıyla denetlemek pek akla yatkın görünmüyor. Ne de olsa değişkenin değerinin ne olduğunu biliyoruz. Dolayısıyla bu değişkenin 10 sayısından büyük olduğunu da biliyoruz! Bunu if 16http://web.archive.org/web/20161122123704/http://www..com/blog/python-ve-metin-duzenleyiciler. html 152 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 deyimiyle kontrol etmek çok gerekli değil. Ama şimdi daha makul bir iş yapacağız. Değişkeni bizbelirlemekyerinekullanıcıyabelirleteceğiz: sayı = int(input("Bir sayı giriniz: ")) if sayı > 10: print("Girdiğiniz sayı 10’dan büyüktür!") if sayı < 10: print("Girdiğiniz sayı 10’dan küçüktür!") if sayı == 10: print("Girdiğiniz sayı 10’dur!") Gördüğünüzgibi,artardaüçadetifbloğukullandık.Bukodlaragöre,eğerkullanıcınıngirdiği sayı10’danbüyükse,ilkifbloğuişletilecek;eğersayı10’danküçükseikinciifbloğuişletilecek; eğer sayı 10’a eşit ise üçüncü if bloğu işletilecektir. Peki ya kullanıcı muziplik yapıp sayı yerine harf yazarsa ne olacak? Böyle bir ihtimal için programımıza herhangi bir denetleyici yerleştirmedik. Dolayısıyla eğer kullanıcı sayı yerine harf girerse programımız hata verecek, yani çökecektir. Bu tür durumlara karşı nasıl önlem alacağımızı ilerleyen derslerimizde göreceğiz.Bizşimdilikbildiğimizyoldayürüyelim. Yukarıdaki örnekte input() ile gelen karakter dizisini, int() fonksiyonu yardımıyla bir sayıyadönüştürdüğümüzedikkatedin.Kullanıcıdangelenveriyibüyüklük-küçüklükölçütüne göre inceleyeceğimiz için, gelen veriyi bir sayıya dönüştürmemiz gerekiyor. Bunu da int() fonksiyonuileyapabileceğimizibiliyorsunuz. Elbetteyukarıdakidönüştürmeişleminişöyledeyapabilirdik: sayı = input("Bir sayı giriniz: ") sayı = int(sayı) Burada önce input() fonksiyonuyla veriyi aldık, daha sonra bu veriyi ayrı bir yerde sayıya dönüştürüptekrarsayıadlıdeğişkeneatadık. ifdeyimlerinikullanıcıadıveyaparoladenetlerkendekullanabiliriz.Meselaşöylebirprogram taslağıyazabiliriz: print(""" Dünyanın en gelişmiş e.posta hizmetine hoşgeldiniz. Yalnız hizmetimizden yararlanmak için önce sisteme giriş yapmalısınız. """) parola = input("Parola: ") if parola == "12345678": print("Sisteme Hoşgeldiniz!") Gördüğünüz gibi, programın başında üç tırnak işaretlerinden yararlanarak uzun bir metni kullanıcıya gösterdik. Bu bölümü, kendiniz göze hoş gelecek bir şekilde süsleyebilirsiniz de. Eğer kullanıcı, kendisine parola sorulduğunda cevap olarak “12345678” yazarsa kullanıcıyı sistemealıyoruz. 12.1. KoşulDeyimleri 153 PythonBelgeleri,Yayım4.1.3 Yukarıdakiörnekte,kullanıcınıngirdiğiparola“12345678”isekendisine“SistemeHoşgeldiniz!” mesajınıgösteriyoruz.Mantıkolarakbununtersiniyapmakdamümkündür.Yani: if parola != "12345678": print("Ne yazık ki yanlış parola girdiniz!") Burada ise bir önceki örneğin mantığını ters çevirdik. Önceki örnekte parola değişkeni “12345678” adlı karakter dizisine eşitse (if parola == "12345678") bir işlem yapıyorduk. Yukarıdaki örnekte ise parola değişkeni “12345678” adlı karakter dizisine eşit değilse (if parola != "12345678")birişlemyapıyoruz. Bu iki örneğin de aslında aynı kapıya çıktığını görüyorsunuz. Tek değişiklik, kullanıcıya gösterilenmesajlardadır. Böylece Python’daki koşullu durumlar üzerindeki incelememizin ilk ve en önemli aşamasını geride bırakmış olduk. Dikkat ettiyseniz if deyimi sayesinde programlarımıza karar vermeyi öğrettik. Bu deyim yardımıyla, kullanıcıdan aldığımız herhangi bir verinin niteliği üzerinde kapsamlıbirkararvermeişlemiyürütebiliyoruz.Yaniartıkprogramlarımızkullanıcıdanalınan veriyi olduğu gibi kabul etmekle yetinmiyor. Kullanıcının girdiği verinin ne olduğuna bağlı olarakprogramlarımızınfarklıişlemleryapmasınıdasağlayabiliyoruz. Daha önce de söylediğimiz gibi, if deyimi dışında Python’da koşullu durumları ifade etmek için kullandığımız, elif ve else adlı iki deyim daha vardır. Bunlar if ile birlikte kullanılırlar. Gelinistersenizbuikideyimden,adıelifolanabakalım. 12.1.2 elif Python’da, if deyimleriyle birlikte kullanılan ve yine koşul belirten bir başka deyim de elif deyimidir.Bunaşöylebirörnekverebiliriz: yaş = int(input("Yaşınız: ")) if yaş == 18: print("18 iyidir!") elif yaş < 0: print("Yok canım, daha neler!...") elif yaş < 18: print("Genç bir kardeşimizsin!") elif yaş > 18: print("Eh, artık yaş yavaş yavaş kemale eriyor!") Yukarıdakiörneğişöyleyazmayıdadeneyebilirsiniz: yaş = int(input("Yaşınız: ")) if yaş == 18: print("18 iyidir!") if yaş < 0: (sonrakisayfayadevam) 154 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Yok canım, daha neler!...") if yaş < 18: print("Genç bir kardeşimizsin!") if yaş > 18: print("Eh, artık yaş yavaş yavaş kemale eriyor!") Buikiprogramındaaynıişlevigördüğünüdüşünebilirsiniz.Ancakilkbakıştapekbelliolmasa da,aslındayukarıdakiikiprogrambirbirindenfarklıdavranacaktır.Örneğinikinciprogramda eğerkullanıcıeksideğerlibirsayıgirersehemif yaş < 0bloğu,hemdeif yaş < 18bloğu çalışacaktır. İsterseniz yukarıdaki programı çalıştırıp, cevap olarak eksi değerli bir sayı verin. Nedemekistediğimizgayetnetanlaşılacaktır. Bu durum if ile elif arasındaki çok önemli bir farktan kaynaklanır. Buna göre if bize olası bütün sonuçları listeler, elif ise sadece doğru olan ilk sonucu verir. Bu soyut tanımlamayı birazdahasomutlaştıralım: a = int(input("Bir sayı giriniz: ")) if a < 100: print("verdiğiniz sayı 100’den küçüktür.") if a < 50: print("verdiğiniz sayı 50’den küçüktür.") if a == 100: print("verdiğiniz sayı 100’dür.") if a > 100: print("verdiğiniz sayı 100’den büyüktür.") if a > 150: print("verdiğiniz sayı 150’den büyüktür.") Yukarıdaki kodları çalıştırdığımızda, doğru olan bütün sonuçlar listelenecektir. Yani mesela kullanıcı40sayısınıgirmişse,ekranaverilecekçıktışöyleolacaktır: verdiğiniz sayı 100’den küçüktür. verdiğiniz sayı 50’den küçüktür. Burada 40 sayısı hem 100’den, hem de 50’den küçük olduğu için iki sonuç da çıktı olarak verilecektir.Amaeğeryukarıdakikodlarışöyleyazarsak: a = int(input("Bir sayı giriniz: ")) if a < 100: print("verdiğiniz sayı 100’den küçüktür.") elif a < 50: (sonrakisayfayadevam) 12.1. KoşulDeyimleri 155 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("verdiğiniz sayı 50’den küçüktür.") elif a == 100: print("verdiğiniz sayı 100’dür.") elif a > 150: print("verdiğiniz sayı 150’den büyüktür.") elif a > 100: print("verdiğiniz sayı 100’den büyüktür.") Kullanıcının 40 sayısını girdiğini varsaydığımızda, bu defa programımımız yalnızca şu çıktıyı verecektir: verdiğiniz sayı 100’den küçüktür. Gördüğünüzgibi,elifdeyimlerinikullandığımızzaman,ekranayalnızcadoğruolanilksonuç veriliyor. Yukarıda 40 sayısı hem 100’den hem de 50’den küçük olduğu halde, Python bu sayının 100’den küçük olduğunu görür görmez sonucu ekrana basıp, öteki koşul bloklarını incelemeyibırakıyor.ifdeyimleriniarkaarkayasıraladığımızdaise,Pythonbütünolasılıkları tektekdeğerlendirip,geçerliolanbütünsonuçlarıekranadöküyor. Bir sonraki bölümde else deyimini öğrendiğimiz zaman, elif’in tam olarak ne işe yaradığını çokdahaiyianlamanızısağlayacakbirörnekvereceğiz. (cid:242) Not Şimdiye kadar verdiğimiz örneklerden de rahatlıkla anlayabileceğiniz gibi, ilk koşul bloğundaaslaelifdeyimikullanılamaz.Budeyiminkullanılabilmesiiçinkendisindenönce enazbiradetifbloğuolmalıdır.YaniPython’dakoşulludurumlarıifadeederkenilkkoşul bloğumuzherzamanifdeyimiilebaşlamalıdır. elif’ideincelediğimizegöre,koşulbildirendeyimlerinsonuncusunagözatabiliriz:else 12.1.3 else ŞimdiyekadarPython’dakoşulbildirenikideyimiöğrendik.Bunlarifveelifidi.Bubölümde isekoşuldeyimlerininsonuncusuolanelsedeyiminigöreceğiz.Öğrendiğimizşeylerişöylebir gözdengeçirecekolursak,temelolarakşöylebirdurumlakarşıkarşıyaolduğumuzugörürüz: if falanca: bu işlemi yap if filanca: şu işlemi yap Veyaşöylebirdurum: 156 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 if falanca: bu işlemi yap elif filanca: şu işlemi yap ifileelifarasındakifarkıbiliyoruz.Eğerifdeyimleriniartardasıralayacakolursak,Python doğru olan bütün sonuçları listeleyecektir. Ama eğer if deyiminden sonra elif deyimini kullanırsak,Pythondoğruolanilksonuculistelemekleyetinecektir. Bu bölümde göreceğimiz else deyimi, yukarıdaki tabloya bambaşka bir boyut kazandırıyor. Dikkat ederseniz şimdiye kadar öğrendiğimiz deyimleri kullanabilmek için ilgili bütün durumlarıtanımlamamızgerekiyordu.Yani: eğer böyle bir durum varsa: bunu yap eğer şöyle bir durum varsa: şunu yap eğer filancaysa: şöyle git eğer falancaysa: böyle gel gibi... Ancak her durum için bir if bloğu yazmak bir süre sonra yorucu ve sıkıcı olacaktır. İşte bu noktadadevreyeelsedeyimigirecek.else’inanlamıkabacaşudur: Eğeryukarıdakikoşullarınhiçbirigerçekleşmezse... Gelinistersenizbununlailgilişöylebirörnekverelim: soru = input("Bir meyve adı söyleyin bana:") if soru == "elma": print("evet, elma bir meyvedir...") elif soru == "karpuz": print("evet, karpuz bir meyvedir...") elif soru == "armut": print("evet, armut bir meyvedir...") else: print(soru, "gerçekten bir meyve midir?") Eğer kullanıcı soruya ‘elma’, ‘karpuz’ veya ‘armut’ cevabı verirse, evet, ... bir meyvedir çıktısı verilecektir.Amaeğerkullanıcıbuüçüdışındabircevapverirse,... gerçektenbirmeyvemidir? çıktısınıgörürüz.Buradaelsedeyimi,programımızaşuanlamıkatıyor: Eğer kullanıcı yukarıda belirlenen meyve adlarından hiç birini girmez, bunların 12.1. KoşulDeyimleri 157 PythonBelgeleri,Yayım4.1.3 yerine bambaşka bir şey yazarsa, o zaman else bloğu içinde belirtilen işlemi gerçekleştir. Dikkatedersenizyukarıdakikodlardaifdeyimleriniartardasıralamakyerineilkif’tensonra elifiledevamettik.Pekişöylebirşeyyazarsakneolur? soru = input("Bir meyve adı söyleyin bana:") if soru == "elma": print("evet, elma bir meyvedir...") if soru == "karpuz": print("evet, karpuz bir meyvedir...") if soru == "armut": print("evet, armut bir meyvedir...") else: print(soru, "gerçekten bir meyve midir?") Bukodlarbeklediğinizsonucuvermeyecektir.İstersenizyukarıdakikodlarıçalıştırıpnedemek istediğimizidahaiyianlayabilirsiniz.Eğeryukarıdaolduğugibiifdeyimleriniartardasıralar vesonolarakdabirelsebloğutanımlarsak,ekranailkbakıştaanlamsızgibigörünenbirçıktı verilecektir: evet, elma bir meyvedir... elma gerçekten bir meyve midir? Buradaolanşeyşu: Soruya ‘elma’ cevabını verdiğimizi düşünelim. Bu durumda, Python ilk olarak ilk if bloğunu değerlendirecek ve soruya verdiğimiz cevap ‘elma’ olduğu için evet, elma bir meyvedir... çıktısınıverecektir. if ile elif arasındaki farkı anlatırken, hatırlarsanız art arda gelen if bloklarında Python’ın olası bütün sonuçları değerlendireceğini söylemiştik. İşte burada da böyle bir durum söz konusu.Gördüğünüzgibi,ilkifbloğundansonrayinebirifbloğugeliyor.BunedenlePython olası bütün sonuçları değerlendirebilmek için blokları okumaya devam edecek ve sorunun cevabı‘karpuz’olmadığıiçinikinciifbloğunuatlayacaktır. Sonraki blok yine bir if bloğu olduğu için Python kodları okumaya devam ediyor. Ancak sorunun cevabı ‘armut’ da olmadığı için, Python sonraki if bloğunu da geçiyor ve böylece elsebloğunaulaşıyor. Yukarıda verdiğimiz örnekteki gibi art arda if deyimlerinin sıralanıp en sona else deyiminin yerleştirildiği durumlarda else deyimi sadece bir önceki if deyimini dikkate alarak işlem yapar.Yaniyukarıdakiörnektekullanıcınınverdiğicevap‘armut’olmadığıiçinelsedeyiminin olduğu blok çalışmaya başlar. Yukarıdaki örneğe ‘armut’ cevabını verirseniz ne demek istediğimibirazdahaiyianlayabilirsiniz.‘armut’cevabıverilmesidurumundasadeceif soru == "armut" ifadesinin olduğu blok çalışır, else bloğu ise çalışmaz. Çünkü dediğim gibi, eğer elsebloğundanönceartardagelenifbloklarıvarsa,elsedeyimiyalnızcakendisindenönceki sonifbloğunudikkatealırvesankiyukarıdakiörnekşöyleymişgibidavranır: 158 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 if soru == "armut": print("evet, armut bir meyvedir...") else: print(soru, "gerçekten bir meyve midir?") Bu tür durumlarda else deyimi bir önceki if bloğundan önce gelen bütün if bloklarını görmezdengelirveböyleceşuanlamsızgörünençıktıeldeedilir: evet, elma bir meyvedir... elma gerçekten bir meyve midir? Sözün özü, kullanıcının cevabı ‘elma’ olduğu için, yukarıdaki çıktıda yer alan ilk cümle ilk if bloğunun çalışması sonucu ekrana basılıyor. İkinci cümle ise else bloğundan bir önceki if bloğukullanıcınıncevabıylauyuşmadığıiçinekranabasılıyor. Yalnız bu dediğimizden, else ifadesi if ile birlikte kullanılmaz, anlamı çıkarılmamalı. Mesela şöylebirörnekyapılabilir: soru = input("Programdan çıkmak istediğinize emin misiniz? \ Eminseniz ’e’ harfine basın : ") if soru == "e": print("Güle güle!") else: print("Peki, biraz daha sohbet edelim!") Burada eğer kullanıcının cevabı ‘e’ ise if bloğu işletilecek, eğer cevap ‘e’ dışında herhangi bir şey ise else bloğu çalışacaktır. Gayet mantıklı bir süreç. Ama eğer yukarıdaki örneğe bir if bloğudahaeklersenizişlerbeklediğinizgibigitmez: soru = input("Programdan çıkmak istediğinize emin misiniz? \ Eminseniz ’e’ harfine basın : ") if soru == "e": print("Güle güle!") if soru == "b": print("Kararsız kaldım şimdi!") else: print("Peki, biraz daha sohbet edelim!") Bu soruya ‘e’ cevabı verdiğimizi düşünelim. Bu cevap ilk if bloğuyla uyuşuyor ve böylece ekranaGülegüle!çıktısıveriliyor.İlkifbloğundansonratekrarbirifbloğudahageldiğiiçin Python bütün olasılıkları değerlendirmek amacıyla blokları okumaya devam ediyor ve cevap ‘b’olmadığıiçinikinciifbloğunuatlıyorveböyleceelsebloğunaulaşıyor.Biröncekiörnekte de söylediğimiz gibi, else bloğu art arda gelen if blokları gördüğünde sadece bir önceki if bloğunudikkatealdığıvekullanıcınıncevabıda‘b’olmadığıiçinekranaPeki,birazdahasohbet edelim!çıktısınıveriyorveilkbakıştatuhafgörünenşöylebirçıktıüretiyor: 12.1. KoşulDeyimleri 159 PythonBelgeleri,Yayım4.1.3 Güle güle! Peki, biraz daha sohbet edelim! Dolayısıyla,eğerprogramınızdabirelsebloğunayerverecekseniz,ondanöncegelenkoşullu durumlarınilkiniifilesonrakileriiseelifilebağlayın.Yani: if koşul_1: sonuç_1 elif koşul_2: sonuç_2 elif koşul_3: sonuç_3 else: sonuç_4 Amaeğerelsebloğundanöncesadecetekbirkoşulbloğuyeralacaksabunuifilebağlayın. Yani: if koşul_1: sonuç_1 else: sonuç_2 Programlarımızın doğru çalışması ve istediğimiz sonucu verebilmesi için bu tür ayrıntılara olabildiğince dikkat etmemiz gerekiyor. Neticede koşullu durumlar mantıkla ilgilidir. Dolayısıyla koşullu durumlarla muhatap olurken mantığınızı hiçbir zaman devre dışı bırakmamalısınız. Bir önceki bölümde elif deyiminin tam olarak ne işe yaradığını anlamamızı sağlayacak bir örnekvereceğimizisöylemiştik.Şimdibuörneğebakalım: boy = int(input("boyunuz kaç cm?")) if boy < 170: print("boyunuz kısa") elif boy < 180: print("boyunuz normal") else: print("boyunuz uzun") Yukarıda yedi satırla hallettiğimiz işi sadece if deyimleriyle yapmaya çalışırsanız bunun ne kadar zor olduğunu göreceksiniz. Diyelim ki kullanıcı ‘165’ cevabını verdi. Python bu 165 sayısının 170’ten küçük olduğunu görünce boyunuz kısa cevabını verecek, öteki satırları değerlendirmeyecektir. 165 sayısı, elif ile gösterdiğimiz koşullu duruma da uygun olduğu halde(165 < 180),koşulilkbloktakarşılandığıiçinikinciblokdeğerlendirmeyealınmayacaktır. Kullanıcının ‘175’ cevabını verdiğini varsayalım: Python 175 sayısını görünce önce ilk koşula 160 Bölüm12. KoşulluDurumlar PythonBelgeleri,Yayım4.1.3 bakacak,verilen175sayısınınilkkoşulukarşılamadığınıgörecektir(175 > 170).Bununüzerine Python kodları incelemeye devam edecek ve elif bloğunu değerlendirmeye alacaktır. 175 sayısının180’denküçükolduğunugörüncedeçıktıolarakboyunuznormalcevabınıverecektir. Peki ya kullanıcı ‘190’ cevabını verirse ne olacak? Python yine önce ilk if bloğuna bakacak ve 190 cevabının bu bloğa uymadığını görecektir. Dolayısıyla ilk bloğu bırakıp ikinci bloğa bakacaktır.190cevabınınbubloğadauymadığınıgörünce,birsonrakibloğudeğerlendirmeye alacaktır. Bir sonraki blokta ise else deyimimiz var. Bu bölümde öğrendiğimiz gibi, else deyimi, ‘eğer kullanıcının cevabı yukarıdaki koşulların hiçbirine uymazsa bu bloğu çalıştır,’ anlamınageliyor.Kullanıcınıngirdiği190cevabınebirincinedeikincibloktakikoşulauyduğu için, normal bir şekilde else bloğu işletilecek, dolayısıyla da ekrana boyunuz uzun çıktısı verilecektir. Böylece Python’da if, elif ve else deyimlerini incelemiş olduk. Ancak tabii ki bu deyimlerle işimiz henüz bitmedi. Elimizdeki bilgiler şimdilik bu deyimleri ancak bu kadar incelememize yetiyor,amailerleyensayfalardabazıbaşkaaraçlarıdabilgidağarcığımızakattıktansonrabu deyimlerindahafarklıyönleriniöğrenmeimkanınakavuşacağız. 12.2 Örnek Uygulama Önceki derslerimizde len() fonksiyonunu anlatırken şöyle bir program tasarısından bahsetmiştikhatırlarsanız: Diyelim ki sisteme kayıt için kullanıcı adı ve parola belirlenmesini isteyen bir programyazıyorsunuz.Yazacağınızbuprogramda,belirlenebilecekkullanıcıadıve parolanıntoplamuzunluğu40karakterigeçmeyecek. O zaman henüz koşullu durumları öğrenmemiş olduğumuz için, yukarıda bahsettiğimiz programınancakşukadarlıkkısmınıyazabilmiştik: kullanıcı_adı = input("Kullanıcı adınız: ") parola = input("Parolanız : ") toplam_uzunluk = len(kullanıcı_adı) + len(parola) Buradayapabildiğimiztekşey,kullanıcıdankullanıcıadıveparolabilgilerinialıp,bubilgilerin karakter uzunluğunu ölçebilmekti. Ama artık koşullu durumları öğrendiğimize göre bu programıeksiksizolarakyazabiliriz.Şukodlarıdikkatliceinceleyin: kullanıcı_adı = input("Kullanıcı adınız: ") parola = input("Parolanız : ") toplam_uzunluk = len(kullanıcı_adı) + len(parola) mesaj = "Kullanıcı adı ve parolanız toplam {} karakterden oluşuyor!" print(mesaj.format(toplam_uzunluk)) if toplam_uzunluk > 40: print("Kullanıcı adınız ile parolanızın ", "toplam uzunluğu 40 karakteri geçmemeli!") (sonrakisayfayadevam) 12.2. ÖrnekUygulama 161 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) else: print("Sisteme hoşgeldiniz!") Burada öncelikle kullanıcıdan kullanıcı adı ve parola bilgilerini alıyoruz. Daha sonra da kullanıcıdan gelen bu bilgilerin toplam karakter uzunluğunu hesaplıyoruz. Bunun için len() fonksiyonundanyararlanmamızgerektiğinihatırlıyorolmalısınız. Eğertoplamuzunluk40karakterdenfazlaise,ifbloğundaverilenmesajıgösteriyoruz.Bunun dışındakibütündurumlardaiseelsebloğunudevreyesokuyoruz. 162 Bölüm12. KoşulluDurumlar 13 BÖLÜM İşleçler Bubölümde,aslındapekdeyabancısıolmadığımızvehattaöncekiderslerimizdeüstünkörüde olsadeğindiğimizbirkonuyuçokdahaayrıntılıbirşekildeelealacağız.Buradaanlatacağımız konu size yer yer sıkıcı gelebilir. Ancak bu konuyu hakkıyla öğrenmenizin, programcılık maceranızaçısındanhayatiönemdeolduğunurahatlıklasöyleyebilirim. Gelelimkonumuza... Bubölümünkonusuişleçler.Pekinedirbu‘işleç’denenşey? İngilizce’de operator adı verilen işleçler, sağında ve solunda bulunan değerler arasında bir ilişkikuranişaretlerdir.Birişlecinsağındavesolundabulunandeğerlereiseişlenen(operand) adıveriyoruz. (cid:242) Not Türkçedeişleçyerineoperatör,işlenenyerinedeoperantdendiğinetanıkolabilirsiniz. Bizbubölümdeişleçlerialtıbaşlıkaltındainceleyeceğiz: 1. Aritmetikİşleçler 2. Karşılaştırmaİşleçleri 3. Boolİşleçleri 4. DeğerAtamaİşleçleri 5. Bitwise(Bitsel)İşleçleri 6. Aitlikİşleçleri 7. Kimlikİşleçleri Gördüğünüzgibi,işlememizgerekenkonuçok,gitmemizgerekenyoluzun.Ohaldehiçvakit kaybetmeden,aritmetikişleçlerleyolculuğumuzabaşlayalım. 163 PythonBelgeleri,Yayım4.1.3 13.1 Aritmetik İşleçler Dedik ki, sağında ve solunda bulunan değerler arasında bir ilişki kuran işaretlere işleç (operator) adı verilir. Önceki derslerimizde temel işleçlerin bazılarını öğrenmiştik. İsterseniz bunlarışöylebirhatırlayalım: tabularytabulary + toplama - çıkarma * çarpma / bölme ** kuvvet Buişleçlerearitmetikişleçleradıverilir.Aritmetikişleçler;matematiktekullanılanvesayılarla aritmetikişlemleryapmamızısağlayanyardımcıaraçlardır. Dilersenizbutanımıbirörneklesomutlaştıralım: >>> 45 + 33 78 Burada 45 ve 33 değerlerine işlenen (operand) adı verilir. Bu iki değer arasında yer alan + işaretiisebirişleçtir(operator).Dikkatederseniz+işleci45ve33adlıişlenenlerarasındabir toplamailişkisikuruyor. Birörnekdahaverelim: >>> 23 * 46 1058 Burada da 23 ve 46 değerleri birer işlenendir. Bu iki değer arasında yer alan * işareti ise, işlenenlerarasındabirçarpmailişkisikuranbirişleçtir. Ancak bir noktaya özellikle dikkatinizi çekmek istiyorum. Daha önceki derslerimizde de değindiğimiz gibi, + ve * işleçleri Python’da birden fazla anlama gelir. Örneğin yukarıdaki örnekte + işleci, işlenenler arasında bir toplama ilişkisi kuruyor. Ama aşağıdaki durum biraz farklıdır: >>> "" + ".com" ’.com’ Burada+işleciişlenenler(“”ve“.com”)arasındabirbirleştirmeilişkisikuruyor. Tıpkı+işlecindeolduğugibi,*işlecidePython’dabirdenfazlaanlamagelir.Buişlecin,çarpma ilişkisikurmaişlevidışındatekraretmeilişkisikurmaişlevidevardır.Yani: >>> "hızlı " * 2 ’hızlı hızlı ’ ...veya: 164 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 >>> "-" * 30 ’------------------------------’ Burada * işlecinin, sayılar arasında çarpma işlemi yapmak dışında bir görev üstlendiğini görüyoruz. Python’da bu tür farklar, yazacağınız programın sağlıklı çalışabilmesi açısından büyük önem taşır.Oyüzdenbutürfarklarakarşıherzamanuyanıkolmamızgerekiyor. +ve*işleçlerininaksine/ve-işleçleriiseişlenenlerarasındasadecebölmeveçıkarmailişkisi kurar.Buişleçlertekişlevlidir: >>> 25 / 4 6.25 >>> 10 - 5 5 Öncekiderslerdegördüğümüzveyukarıdadatekrarettiğimizdörtadettemelaritmetikişlece şuikiaritmetikişlecideekleyelim: tabularytabulary % modülüs // tabanbölme İlköncemodülüsünneolduğunuveneişeyaradığınıanlamayaçalışalım. Şubölmeişleminebirbakın: Burada 02 sayısı bölme işleminin kalanıdır. İşte modülüs denen işleç de bölme işleminden kalanbudeğerigösterir.Yani: >>> 30 % 4 2 Gördüğünüzgibimodülüsişleci(%)gerçektendebölmeişlemindenkalansayıyıgösteriyor... Pekibubilgineişimizeyarar? Meselabubilgiyikullanarakbirsayınıntekmiyoksaçiftmiolduğunutespitedebiliriz: sayı = int(input("Bir sayı girin: ")) if sayı % 2 == 0: (sonrakisayfayadevam) 13.1. Aritmetikİşleçler 165 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Girdiğiniz sayı bir çift sayıdır.") else: print("Girdiğiniz sayı bir tek sayıdır.") Eğerbirsayı2’yebölündüğündekalandeğer0iseosayıçifttir.Aksihaldeosayıtektir.Mesela: >>> 14 % 2 0 Gördüğünüz gibi, bir çift sayı olan 14’ü 2’ye böldüğümüzde kalan sayı 0 oluyor. Çünkü çift sayılar2’yetambölünürler. Birdeşunabakalım: >>> 15 % 2 1 Bir tek sayı olan 15 ise 2’ye bölündüğünde kalan sayı 1 oluyor. Yani 15 sayısı 2’ye tam bölünmüyor.Bubilgidenyolaçıkarak15sayısınınbirteksayıolduğunusöyleyebiliyoruz. Bir sayının tek mi yoksa çift mi olduğunu tespit etme işlemini küçümsememenizi tavsiye ederim. Bir sayının tek mi yoksa çift mi olduğu bilgisinin, arayüz geliştirirken dahi işinize yarayacağındaneminolabilirsiniz. Elbette modülüs işlecini bir sayının yalnızca 2’ye tam bölünüp bölünmediğini denetlemek içinkullanmıyoruz.Buişlecikullanarakherhangibirsayınınherhangibirsayıyatambölünüp bölünmediğinidedenetleyebilirsiniz.Örneğin: >>> 45 % 4 1 >>> 36 % 9 0 Bubilgiyikullanarakmeselaşöylebirprogramyazabilirsiniz: bölünen = int(input("Bir sayı girin: ")) bölen = int(input("Bir sayı daha girin: ")) şablon = "{} sayısı {} sayısına tam".format(bölünen, bölen) if bölünen % bölen == 0: print(şablon, "bölünüyor!") else: print(şablon, "bölünmüyor!") Programımız, kullanıcının girdiği ilk sayının ikinci sayıya tam bölünüp bölünmediğini hesaplıyorvesonucagörekullanıcıyıbilgilendiriyor.Bukodlardaözellikleşusatıradikkatedin: 166 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 if bölünen % bölen == 0: ... Programımızın temelini bu kod oluşturuyor. Çünkü bir sayının bir sayıya tam bölünüp bölünmediğinibukodlabelirliyoruz.Eğerbirsayıbaşkabirsayıyabölündüğündekalandeğer, yanimodülüs0ise,osayıöbürsayıyatambölünüyordemektir. Ayrıcabirsayınınsonbasamağınıeldeetmekiçindemodülüstenyararlanabilirsiniz.Herhangi birtamsayı10’abölündüğündekalan(yanimodülüs),bölünensayınınsonbasamağıolacaktır: >>> 65 % 10 5 >>> 543 % 10 3 Programlamatecrübenizarttıkça,aslındamodülüsünnekadarfaydalıbiraraçolduğunukendi gözlerinizlegöreceksiniz. Modülüs işlecini örnekler eşliğinde ayrıntılı bir şekilde incelediğimize göre sıra geldi taban bölmeişleciniaçıklamaya... Öncelikleşuörneğiinceleyelim: >>> 5 / 2 2.5 Burada, bildiğimiz bölme işlecini (/) kullanarak basit bir bölme işlemi yaptık. Elde ettiğimiz sonuçdoğalolarak2.5. Matematikte bölme işleminin sonucunun kesirli olması durumuna ‘kesirli bölme’ adı verilir. Bununtersiisetamsayılıbölmeveyatabanbölmedir.Eğerherhangibirsebeplekesirlibölme işlemideğildetabanbölmeişlemiyapmanızgerekirse//işlecindenyararlanabilirsiniz: >>> 5 // 2 2 Gördüğünüzgibi,//işlecisayesindebölmeişlemininsonucukesirlideğil,tamsayıolarakelde ediliyor. Yukarıdayaptığımıztabanbölmeişlemişununlaaynıanlamagelir: >>> int(5 / 2) 2 Dahaaçıkifadeetmemizgerekirse: >>> a = 5 / 2 >>> a (sonrakisayfayadevam) 13.1. Aritmetikİşleçler 167 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 2.5 >>> int(a) 2 Burada olan şu: 5 / 2 işleminin sonucu bir kayan noktalı sayıdır (2.5). Bunu şu şekilde teyit edebiliriz: >>> a = 5 / 2 >>> type(a) <class ’float’> Buradaki float çıktısının floating point number, yani kayan noktalı sayı anlamına geldiğini biliyorsunuz. Bu kayan noktalı sayının sadece tabanını elde etmek için bu sayıyı tamsayıya (integer) çevirmemizyeterliolacaktır.Yani: >>> int(a) 2 Bu arada yeri gelmişken round() adlı bir gömülü fonksiyondan bahsetmeden geçmeyelim. Eğerbirsayınındeğeriniyuvarlamanızgerekirseround()fonksiyonundanyararlanabilirsiniz. Bufonksiyonşöylekullanılır: >>> round(2.55) 3 Gördüğünüzgibi,round()fonksiyonunaparametreolarakbirsayıveriyoruz.Bufonksiyonda bizeosayınınyuvarlanmışhalinidöndürüyor.Bufonksiyonukullanarakyuvarlanacaksayının noktadansonrakihassasiyetinidebelirleyebilirsiniz.Örneğin: >>> round(2.55, 1) 2.5 Burada ikinci parametre olarak 1 sayısını verdiğimiz için, noktadan sonraki bir basamak görüntüleniyor.Birdeşunabakalım: >>> round(2.68, 1) 2.7 Buradadayuvarlamaişlemiyapılırkennoktadansonrabirbasamakkorunuyor.Eğer1sayısı yerine2sayısınıkullanırsanız,yukarıdakiörnekşuçıktıyıverir: 168 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 >>> round(2.68, 2) 2.68 round() fonksiyonunun çalışma prensibini anlamak için kendi kendinize örnekler yapabilirsiniz. Şimdiye kadar öğrendiğimiz ve yukarıdaki tabloda andığımız bir başka aritmetik işleç de kuvvet işleci (**) idi. Mesela bu işleci kullanarak bir sayının karesini hesaplayabileceğimizi biliyorsunuz: >>> 25 ** 2 625 Birsayının2.kuvvetiosayınınkaresidir.Birsayının0.5.kuvvetiiseosayınınkareköküdür: >>> 625 ** 0.5 25.0 Buarada,eğerkarekökünkayannoktalısayıcinsindenolmasıhoşunuzagitmediyse,busayıyı int()fonksiyonuiletamsayıyaçevirebileceğinizibiliyorsunuz: >>> int(625 ** 0.5) 25 Kuvvet hesaplamaları için ** işlecinin yanısıra pow() adlı bir fonksiyondan da yararlanabileceğimiziöğrenmiştik: >>> pow(25, 2) 625 Bildiğinizgibipow()fonksiyonuaslındatoplamüçparametrealabiliyor: >>> pow(25, 2, 5) 0 Buişleminşununlaaynıanlamageliyor: >>> (25 ** 2) % 5 0 Yani pow(25, 2, 5) gibi bir komut verdiğimizde, 25 sayısının 2. kuvvetini alıp, elde ettiğimiz sayının5’ebölünmesindenkalansayıyıhesaplamışoluyoruz. Böylecearitmetikişleçleritamamlamışolduk.Artıkkarşılaştırmaişleçleriniinceleyebiliriz. 13.1. Aritmetikİşleçler 169 PythonBelgeleri,Yayım4.1.3 13.2 Karşılaştırma İşleçleri Adından da anlaşılacağı gibi, karşılaştırma işleçleri, işlenenler (operands) arasında bir karşılaştırmailişkisikuranişleçlerdir.Buişleçlerişöylesıralayabiliriz: tabularytabulary == eşittir != eşitdeğildir > büyüktür < küçüktür >= büyükeşittir <= küçükeşittir Bu işleçlerin hiçbiri size yabancı değil, zira bunların hepsini aslında daha önceki derslerde verdiğimizörneklerdekullanmıştık.Buradadabunlarlailgilibasitbirörnekvererekyolumuza devamedelim: parola = "xyz05" soru = input("parolanız: ") if soru == parola: print("doğru parola!") elif soru != parola: print("yanlış parola!") Burada soru değişkeniyle kullanıcıdan alınan verinin, programın başında tanımladığımız paroladeğişkeninindeğerineeşitolupolmadığınısorguluyoruz.Bunagöre,eğerkullanıcıdan gelen veri parolayla eşleşiyorsa (if soru == parola), kullanıcıyı parolanın doğru olduğu konusunda bilgilendiriyoruz (print("doğru parola!")). Ama eğer kullanıcıdan gelen veri parolayla eşleşmiyorsa (elif soru != parola), o zaman da kullanıcıya parolanın yanlış olduğunubildiriyoruz(print("yanlış parola!")). Yukarıdakiörnekte==(eşittir)ve!=(eşitdeğildir)işleçlerininkullanımınıörneklendirdik.Öteki karşılaştırmaişleçlerinindenasılkullanıldığınıbiliyorsunuz.Basitbirörnekverelim: sayı = input("sayı: ") if int(sayı) <= 100: print("sayı 100 veya 100’den küçük") elif int(sayı) >= 100: print("sayı 100 veya 100’den büyük") Böylecekarşılaştırmaişleçlerinideincelemişolduk.Ohaldegelelimboolişleçlerine... 170 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 13.3 Bool İşleçleri Bubölümdeboolişleçlerindensözedeceğiz,ancakboolişleçlerinegeçmedenöncebirazbool kavramındanbahsetmemizyerindeolacaktır. Nedirbubooldenenşey? Bilgisayarbilimiikiadetdeğerüzerinekuruludur:1ve0.YanisırasıylaTrueveFalse.Bilgisayar bilimindeherhangibirşeyindeğeriyaTrue,yadaFalse’tur.İştebuTrueveFalseolarakifade edilen değerlere bool değerleri adı verilir (George Boole adlı İngiliz matematikçi ve filozofun adından). Türkçe olarak söylemek gerekirse, True değerinin karşılığı Doğru, False değerinin karşılığıiseYanlış’tır. Örneğin: >>> a = 1 Burada a adlı bir değişken tanımladık. Bu değişkenin değeri 1. Şimdi bu değişkenin değerini sorgulayalım: ’ >>> a == 1 #a değeri 1 e eşit mi? True Gördüğünüz gibi, a == 1 sorgusu True (Doğru) çıktısı veriyor. Çünkü a değişkeninin değeri gerçektende1.Birdeşunudeneyelim: >>> a == 2 False Burada da a değişkeninin değerinin 2 sayısına eşdeğer olup olmadığını sorguladık. a değişkeninindeğeri2olmadığıiçindePythonbizeFalse(Yanlış)çıktısıverdi. Gördüğünüzgibi,boolişleçleriherhangibirifadenindoğruluğunuveyayanlışlığınısorgulamak için kullanılabiliyor. Buna göre, eğer bir sorgulamanın sonucu doğru ise True, eğer yanlış ise Falseçıktısıalıyoruz. Bool işleçleri sadece yukarıda verdiğimiz örneklerdeki gibi, salt bir doğruluk-yanlışlık sorgulamaya yarayan araçlar değildir. Bilgisayar biliminde her şeyin bir bool değeri vardır. Bununlailgiligenelkuralımızşu:0değeriveboşveritipleriFalse’tur.Bunlardışındakalanher şeyiseTrue’dur. Budurumubool()adlıözelbirfonksiyondanyararlanarakteyitedebiliriz: >>> bool(3) True >>> bool("elma") True >>> bool(" ") (sonrakisayfayadevam) 13.3. Boolİşleçleri 171 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) True >>> bool(" ") True >>> bool("fdsdfsdg") True >>> bool("0") True >>> bool(0) False >>> bool("") False Gördüğünüz gibi, gerçekten de 0 sayısının ve boş karakter dizilerinin bool değeri False’tur. GerikalanherşeyiseTrue’dur. (cid:242) Not 0’ın bir sayı, “0”’ın ise bir karakter dizisi olduğunu unutmayın. Sayı olan 0’ın bool değeri False’tur,amakarakterdizisiolan“0”’ındeğeriTrue’dur. Yukarıdakiörnekleregöre,içindeherhangibirdeğerbarındırankarakterdizileri(0hariç)True çıktısıveriyor.Buradasöylediğimizşeybütünveritipleriiçingeçerlidir.Eğerherhangibirveri tipiherhangibirdeğeriçermiyorsaoveritipiFalseçıktısıverir. Peki bu bilgi bizim ne işimize yarar? Yani mesela boş veri tiplerinin False, içinde bir veri barındıran veri tiplerinin ise True olması bizim için neden bu kadar önemli? Bunu birazdan açıklayacağız.Amaönceisterseniz,booldeğerleriileilgiliçokönemlibirkonuyadeğinelim. Belki kendiniz de farketmişsinizdir; bool değerleri Python’da koşul belirten if, elif ve else deyimlerinindetemelinioluşturur.Şuörneğielealalımmesela: isim = input("İsminiz: ") if isim == "Ferhat": print("Ne güzel bir isim bu!") else: print(isim, "ismini pek sevmem!") Buradaif isim == "Ferhat"dediğimizde,aslındaPython’aşuemrivermişoluyoruz: 172 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 Eğerisim == "Ferhat"ifadesiTrueise... Bunuteyitetmekiçinşöylebirkodyazabilirsiniz: isim = input("İsminiz: ") print(isim == "Ferhat") Eğer burada kullanıcı ‘Ferhat’ ismini girecek olursa programımız True çıktısı verir. Ama eğer kullanıcı başka bir isim girerse bu kez False çıktısını alırız. İşte koşul bildiren deyimler, karar verme görevini, kendilerine verilen ifadelerin bool değerlerine bakarak yerine getirir. DolayısıylayukarıdakiörneğişuşekildeTürkçeyeçevirebiliriz: Eğerisim == "Ferhat"ifadesininbooldeğeriTrueise,Negüzelbirisimbu!çıktısı ver!Amaeğerisim == "Ferhat"ifadesininbooldeğeriTruedışındaherhangibir şeyise(yaniFalseise),... isminipeksevmem!çıktısıver! Koşulbildirendeyimlerlebooldeğerleriarasındakiilişkiyidahaiyianlamakiçinbirörnekdaha verelim: HatırlarsanıziçiboşveritiplerininbooldeğerininherzamanFalseolacağınısöylemiştik.Yani: >>> a = "" >>> bool(a) False HerhangibirdeğeresahipveritiplerininbooldeğeriiseherzamanTrueolur(0hariç): >>> a = "gdfg" >>> bool(a) True İçi boş veri tiplerinin bool değerinin her zaman False olacağı bilgisini kullanarak şöyle bir uygulamayazabiliriz: kullanıcı = input("Kullanıcı adınız: ") if bool(kullanıcı) == True: print("Teşekkürler!") else: print("Kullanıcı adı alanı boş bırakılamaz!") Buradaşöylebiremirverdik: “Eğer kullanıcı değişkeninin bool değeri True ise Teşekkürler! çıktısı ver! Değilse Kullanıcıadıalanıboşbırakılamaz!uyarısınıgöster! Eğerkullanıcı,kullanıcıadınaherhangibirşeyyazdıktansonraEntertuşunabasarsakullanıcı değişkeni, kullanıcının girdiği değeri gösterecek ve böylece bool(kullanıcı) komutu True çıktısıverecektir.Busayededekodlarımızıniçindekiifbloğuçalışmayabaşlayacaktır. 13.3. Boolİşleçleri 173 PythonBelgeleri,Yayım4.1.3 Ama eğer kullanıcı, kullanıcı adını yazmadan Enter tuşuna basarsa, kullanıcı değişkeni boş kalacağı için (yani kullanıcı = "" gibi bir durum ortaya çıkacağı için) bool(kullanıcı) komutuFalseçıktısıverecekveböyleceelsebloğuçalışacaktır. Yalnızbunoktadaşöylebiruyarıyapalım.Yukarıdakikomutlarsözdizimiaçısındantamamen doğruolsada,etraftayukarıdakinebenzerbirkullanımıpekgörmezsiniz.Aynıişiçingenellikle şöylebirşeyleryazılır: kullanıcı = input("Kullanıcı adınız: ") if kullanıcı: print("Teşekkürler!") Gördüğünüz gibi, if bool(kullanıcı) == True: kodunu if kullanıcı: şeklinde kısaltabiliyoruz. Bu ikisi tamamen aynı anlama gelir. Yani ikisi de ‘kullanıcı değişkeninin booldeğeriTrueise...’demektir. Boolkavramınaaşinalıkkazandığımızagöreşimdiboolişleçleriniincelemeyebaşlayabiliriz. Bool işleçleri, bool değerlerinden birini elde etmemizi sağlayan işleçlerdir. Bu işleçler şunlardır: and or not Eğer mantık dersleri aldıysanız bu işleçler size hiç yabancı gelmeyecektir. Eğer lisede mantık derslerialmadıysanızveyaaldığınızderslerdenhiçbirşeyhatırlamıyorsanız,yinedeziyanıyok. Bizburadabuişleçleribütünayrıntılarıylainceleyeceğiz. Önceandilebaşlayalım... Türkçesöylemekgerekirseand‘ve’anlamınagelir.Pekibuandneişimizeyarar?Çokbasitbir örnekverelim: Hatırlarsanız geçen bölümde koşullu durumlara örnek verirken şöyle bir durumdan bahsetmiştik: DiyelimkiGoogle’ınGmailhizmetiaracılığıylabire.postahesabıaldınız.Buhesaba gireceğiniz zaman Gmail size bir kullanıcı adı ve parola sorar. Siz de kendinize ait kullanıcı adını ve parolayı sayfadaki kutucuklara yazarsınız. Eğer yazdığınız kullanıcı adı ve parola doğruysa hesabınıza erişebilirsiniz. Ama eğer kullanıcı adınızveparolanızdoğrudeğilsehesabınızaerişemezsiniz.Yanie.postahesabınıza erişmeniz,kullanıcıadıveparolayıdoğrugirmekoşulunabağlıdır. Burada çok önemli bir nokta var. Kullanıcının Gmail sistemine girebilmesi için hem kullanıcı adını hem de parolayı doğru yazması gerekiyor. Yani kullanıcı adı veya paroladan herhangi biriyanlışisesistemegirişmümkünolmayacaktır. Yukarıdaki durumu taklit eden bir programı, şu ana kadar olan bilgilerimizi kullanarak şöyle yazabiliyoruz: kullanıcı_adı = input("Kullanıcı adınız: ") parola = input("Parolanız: ") (sonrakisayfayadevam) 174 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if kullanıcı_adı == "aliveli": if parola == "12345678": print("Programa hoşgeldiniz") else: print("Yanlış kullanıcı adı veya parola!") else: print("Yanlış kullanıcı adı veya parola!") Burada yeni bir bilgiyle daha karşılaşıyoruz. Gördüğünüz gibi, burada if deyimlerini iç içe kullandık.Python’daistediğinizkadariçiçegeçmişifdeyimikullanabilirsiniz.Ancakyazdığınız bir programda eğer üçten fazla iç içe if deyimi kullandıysanız, benimsediğiniz yöntemi yeniden gözden geçirmenizi tavsiye ederim. Çünkü iç içe geçmiş if deyimleri bir süre sonra anlaşılmasıgüçbirkodyapısıortayaçıkarabilir.Neyse... Bizkonumuzadönelim. Yukarıdaki yazdığımız programda kullanıcının sisteme giriş yapabilmesi için hem kullanıcı adını hem de parolayı doğru girmesi gerekiyor. Kullanıcı adı ve paroladan herhangi biri yanlışsa sisteme girişe izin verilmiyor. Ancak yukarıdaki yöntem dolambaçlıdır. Halbuki aynı işleviyerinegetirmenin,Python’daçokdahakolaybiryoluvar.Bakalım: kullanıcı_adı = input("Kullanıcı adınız: ") parola = input("Parolanız: ") if kullanıcı_adı == "aliveli" and parola == "12345678": print("Programa hoşgeldiniz") else: print("Yanlış kullanıcı adı veya parola!") Burada and işlecini nasıl kullandığımızı görüyorsunuz. Bu işleci kullanarak iki farklı ifadeyi birbirinebağladık.Böylecekullanıcınınsistemegirişinihemkullanıcıadınınhemdeparolanın doğruolmasıkoşulunadayandırdık. Pekiandişlecininçalışmamantığınedir?Dediğimgibi,andTürkçede‘ve’anlamınageliyor.Bu işlecidahaiyianlayabilmekiçinşucümlelerarasındakifarkıdüşünün: a. ToplantıyaAliveVelikatılacak. b. ToplantıyaAliveyaVelikatılacak. İlk cümlede ‘ve’ bağlacı kullanıldığı için, bu cümlenin gereğinin yerine getirilebilmesi, hem Ali’nin hem de Veli’nin toplantıya katılmasına bağlıdır. Sadece Ali veya sadece Veli’nin toplantıyakatılmasıdurumundabucümleningereğiyerinegetirilememişolacaktır. İkinci cümlede ise toplantıya Ali ve Veli’den herhangi birisinin katılması yeterlidir. Toplantıya sadece Ali’nin katılması, sadece Veli’nin katılması veya her ikisinin birden katılması, bu cümleningereğininyerinegetirilebilmesiaçısındanyeterlidir. İştePython’dakiandişlecideaynıbuşekildeişler.Şuörneklerebirbakalım: >>> a = 23 >>> b = 10 >>> a == 23 (sonrakisayfayadevam) 13.3. Boolİşleçleri 175 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) True >>> b == 10 True >>> a == 23 and b == 10 True Buradadeğeri23olanbiradetadeğişkenivedeğeri10olanbiradetbdeğişkenitanımladık. Dahasonrabuikideğişkenindeğerinitekteksorguladıkvebunlarıngerçektendesırasıyla23 ve 10 sayısına eşit olduğunu gördük. Son olarak da bunları and işleci ile birbirine bağlayarak sorguladık. a değişkeninin değeri 23, b değişkeninin değeri de 10 olduğu için, yani and ile bağlanan her iki önerme de True çıktısı verdiği için a == 23 and b == 10 ifadesi True değeri verdi. Birdeşunabakalım: >>> a = 23 >>> b = 10 >>> a == 23 True >>> b == 54 False >>> a == 23 and b == 54 False Burada ise a değişkenin değeri 23’tür. Dolayısıyla a == 23 ifadesi True çıktısı verir. Ancak b değişkeninindeğeri54değildir.Oyüzdendeb == 54komutuFalseçıktısıverir.Gördüğünüz gibi, and işleci ile bağlanan önermelerden herhangi biri False olduğunda çıktımız da False oluyor.Unutmayın:andişlecininTrueçıktısıverebilmesiiçinbuişleçtarafındanbağlananher iki önermenin de True olması gerekir. Eğer önermelerden biri bile True değilse çıktı da True olmayacaktır. Tahmin edebileceğiniz gibi, and işleci en yaygın if deyimleriyle birlikte kullanılır. Mesela yukarıdakullanıcıdankullanıcıadıveparolaalırkendebuandişlecindenyararlanmıştık. Gelelimorişlecine... Tıpkı and gibi bir bool işleci olan or’un Türkçede karşılığı ‘veya’dır. Yukarıda ‘Toplantıya Ali veya Veli katılacak.’ cümlesini tartışırken aslında bu or kelimesinin anlamını açıklamıştık. HatırlarsanızandişlecininTrueçıktısıverebilmesiiçinbuişleçlebağlananbütünönermelerin Truedeğerinesahipolmasıgerekiyordu.orişlecininTrueçıktısıverebilmesiiçiniseorişleciyle bağlananönermelerdenherhangibirininTrueçıktısıvermesiyeterliolacaktır.Söylediğimizbu şeyleribirkaçörneküzerindesomutlaştıralım: 176 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 >>> a = 23 >>> b = 10 >>> a == 23 True >>> b == 10 True >>> a == 11 False >>> a == 11 or b == 10 True Gördüğünüzgibi,a == 11ifadesininbooldeğeriFalseolduğuhalde,b == 10ifadesininbool değeriTrueolduğuiçina == 11 or b == 10ifadesiTruedeğeriniveriyor. and ve or işleçlerini öğrendiğimize göre, bir sınavdan alınan notların harf karşılıklarını gösterenbiruygulamayazabiliriz: x = int(input("Notunuz: ")) if x > 100 or x < 0: print("Böyle bir not yok") elif x >= 90 and x <= 100: print("A aldınız.") elif x >= 80 and x <= 89: print("B aldınız.") elif x >= 70 and x <= 79: print("C aldınız.") elif x >= 60 and x <= 69: print("D aldınız.") elif x >= 0 and x <= 59: print("F aldınız.") Bu programda eğer kullanıcı 100’den büyük ya da 0’dan küçük bir sayı girerse Böyle bir not yok uyarısı alacaktır. 0-100 arası notlarda ise, her bir not aralığına karşılık gelen harf görüntülenecektir.Eğeristersenizyukarıdakikodlarışuşekildedekısaltabilirsiniz: x = int(input("Notunuz: ")) if x > 100 or x < 0: (sonrakisayfayadevam) 13.3. Boolİşleçleri 177 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Böyle bir not yok") elif x >= 90 <= 100: print("A aldınız.") elif x >= 80 <= 89: print("B aldınız.") elif x >= 70 <= 79: print("C aldınız.") elif x >= 60 <= 69: print("D aldınız.") elif x >= 0 <= 59: print("F aldınız.") Gördüğünüz gibi, and x kısımlarını çıkardığımızda da bir önceki kodlarla aynı anlamı yakalayabiliyoruz. Hattayukarıdakikodlarışöyledeyazabilirsiniz: x = int(input("Notunuz: ")) if x > 100 or x < 0: print("Böyle bir not yok") ’ ’ #90 sayısı x ten küçük veya x e eşit, ’ ’ #x sayısı 100 den küçük veya 100 e eşit ise, #Yani x, 90 ile 100 arasında bir sayı ise elif 90 <= x <= 100: print("A aldınız.") ’ ’ #80 sayısı x ten küçük veya x e eşit, ’ ’ #x sayısı 89 dan küçük veya 89 a eşit ise, #Yani x, 80 ile 89 arasında bir sayı ise elif 80 <= x <= 89: print("B aldınız.") elif 70 <= x <= 79: print("C aldınız.") elif 60 <= x <= 69: print("D aldınız.") elif 0 <= x <= 59: print("F aldınız.") Bu kodlar bir öncekiyle aynı işi yapar. Yorumlardan da göreceğiniz gibi, bu iki kod arasında sadecemantıkfarkıvar. 178 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 Hatta,dahadailerigiderekaynıkoduçokdahabasithalegetirmekisterseniz,aşağıdakikoda bakabilirsiniz. x = int(input("Notunuz: ")) if x > 100 or x < 0: print("Böyle bir not yok") elif x >= 90: print("A aldınız.") elif x >= 80: print("B aldınız.") elif x >= 70: print("C aldınız.") elif x >= 60: print("D aldınız.") elif x >= 0: print("F aldınız.") Sonboolişlecimiznot.Bukelimeninİngilizce’dekianlamı‘değil’dir.Buişlecişöylekullanıyoruz: >>> a = 23 >>> not a False >>> a = "" >>> not a True Bu işleç, özellikle kullanıcı tarafından bir değişkene veri girilip girilmediğini denetlemek için kullanılabilir.Örneğin: parola = input("parola: ") if not parola: print("Parola boş bırakılamaz!") Eğer kullanıcı herhangi bir parola belirlemeden doğrudan Enter tuşuna basacak olursa parola değişkeninin değeri boş bir karakter dizisi olacaktır. Yani parola = "". Boş veri tiplerinin bool değerinin False olacağını biliyoruz. Dolayısıyla, yukarıdaki gibi bir örnekte, kullanıcı parolayı boş geçtiğinde not parola kodu True verecek ve böylece ekrana “Parola boşbırakılamaz!”karakterdizisiyazdırılacaktır.Eğeryukarıdakiörneğinmantığınıkavramakta zorlukçekiyorsanızşuörnekleriincelemenizideöneririm: >>> parola = "" (sonrakisayfayadevam) 13.3. Boolİşleçleri 179 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> bool(parola) False >>> bool(not parola) True >>> parola = "1243" >>> bool(parola) True >>> bool(not parola) False Aslındayukarıdakiörneklerdeşunabenzersorularsormuşgibioluyoruz: >>> parola = "" >>> bool(parola) #parola boş bırakılmamış, değil mi? >>> False #Hayır, parola boş bırakılmış. >>> bool(not parola) #parola boş bırakılmış, değil mi? >>> True #Evet, parola boş bırakılmış Kendikendinizepratikyaparakbuişlecingörevinidahaiyianlayabilirsiniz. Böylecekısmençetrefillibirkonuolanboolişleçlerinidegeridebırakmışolduk.Sıradadeğer atamaişleçlerivar. 13.4 Değer Atama İşleçleri Bunoktayakadaryaptığımızçalışmalardasadecetekbirdeğeratamaişlecigördük.Buişleç= işlecidir.Adındandaanlaşılacağıgibi,buişlecingörevibirdeğişkenedeğeratamaktır.Mesela: >>> a = 23 Burada=işleciadeğişkenine23değeriniatamaişlevigörüyor. Python’daki tek değer atama işleci elbette = değildir. Bunun dışında başka değer atama işleçleridebulunur.Tektekinceleyelim: +=işleci Buişlecinneişeyaradığınıanlamakiçinşöylebirörnekdüşünün: >>> a = 23 180 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 adeğerinemesela5ekleyipbudeğeri28’eeşitlemekiçinneyapmamızlazım?Tabiikişunu: >>> a = a + 5 >>> print(a) 28 Buradayaptığımızşeyçokbasit:adeğişkeninintaşıdığıdeğere5ilaveediyoruzvedahasonra budeğeritekraradeğişkenineatıyoruz.Aynıişlemiçokdahakolaybirşekildedeyapabiliriz: >>> a += 5 >>> print(a) 28 Bu kod, yukarıdakiyle tamamen aynı anlama gelir. Ama bir önceki koda göre çok daha verimlidir.Çünküa += 5kodundaPythonadeğişkeninindeğerinisadecebirkezkontrolettiği için,işlemia = a + 5kodunagöredahahızlıyapacaktır. -=işleci Bir önceki += işleci toplama işlemi yapıp, ortaya çıkan değeri tekrar aynı değişkene atıyordu. -=işlecidebunabenzerbirişlemgerçekleştirir: >>> a = 23 >>> a -= 5 >>> print(a) 18 Yukarıdakikullanımşununlatamamenaynıdır: >>> a = 23 >>> a = a - 5 >>> print(a) 18 Ancaktıpkı+=işlecindeolduğugibi,-=işlecidealternatifinegöredahahızlıçalışanbiraraçtır. /=işleci Buişlecinçalışmamantığıdayukarıdakiişleçlerleaynıdır: >>> a = 30 >>> a /= 3 >>> print(a) 10 Yukarıdakiişlemdeşununlatamamenaynıdır: >>> a = 30 >>> a = a / 3 (sonrakisayfayadevam) 13.4. DeğerAtamaİşleçleri 181 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> print(a) 10 *=işleci Budaötekilergibi,çarpmaişlemiyapıp,buişleminsonucunuaynıdeğişkeneatar: >>> a = 20 >>> a *= 2 >>> print(a) 40 Buişlecineşdeğerideşudur: >>> a = 20 >>> a = a * 2 >>> print(a) 40 %=işleci Buişlecimizisebölmeişlemindenkalansayıyıaynıdeğişkeneatar: >>> a = 40 >>> a %= 3 >>> print(a) 1 Buişleçdeşunaeşdeğerdir: >>> a = 40 >>> a = a % 3 >>> print(a) 1 **=işleci Buişlecinneyaptığınıtahminetmekzordeğil.Buişlecimiz,birsayınınkuvvetinihesapladıktan sonraçıkandeğeriaynıdeğişkeneatıyor: >>> a = 12 >>> a **= 2 >>> print(a) 144 Eşdeğeri: 182 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 >>> a = 12 >>> a = a ** 2 >>> print(a) 144 //=işleci Değer atama işleçlerinin sonuncusu olan //= işlecinin görevi ise taban bölme işleminin sonucunuaynıdeğişkeneatamaktır: >>> a = 5 >>> a //= 2 >>> print(a) 2 Eşdeğeri: >>> a = 5 >>> a = a // 2 >>> print(a) 2 Buişleçlerarasından,özellikle+=ve-=işleçleriişinizebirhayliyarayacak. Buaradaeğerbuişleçlerikullanırkenmesela+=miyoksa=+mıyazacağınızıkarıştırıyorsanız, şöyledüşünebilirsiniz: >>> a = 5 >>> a += 5 >>> print(a) 10 Burada, değeri 5 olan bir a değişkenine 5 daha ekleyip, çıkan sonucu tekrar a değişkenine atadık.Böylecedeğeri10olanbiradeğişkenieldeettik.+=işlecinindoğrukullanımıyukarıdaki gibidir.Birdeyukarıdakiörneğişöyleyazmayıdeneyelim: >>> a = 5 >>> a =+ 5 >>> print(a) 5 Burada+işleciile=işlecininyerinideğiştirdik. a =+ 5 satırına dikkatlice bakın. Aslında burada yaptığımız şeyin a = +5 işlemi olduğunu, yani a değişkenine +5 gibi bir değer verdiğimizi göreceksiniz. Durum şu örnekte daha net görünecektir: 13.4. DeğerAtamaİşleçleri 183 PythonBelgeleri,Yayım4.1.3 >>> a = 5 >>> a =- 5 >>> print(a) >>> -5 Gördüğünüz gibi, a =- 5 yazdığımızda, aslında yaptığımız şey a değişkenine -5 değerini vermektenibarettir.Yania = -5. :=işleci (cid:242) Not Walrus operatörü olarak da bilinen bu işleç, Python’un 3.8 versiyonu ile eklenmiştir. Bundan önceki versiyonlarda bulunmamaktadır ve çalışmayacaktır. SyntaxError hatası verecektir. Buişleçbirazgaripgözüküyorolabilir.Neyaptığınıbakarakkestirmekdebirazzor.Eniyisibir örneklebaşlayalım: giriş = len(input("Adın ne? ")) if giriş < 4: print("Adın kısaymış.") elif giriş < 6: print("Adın biraz uzunmuş.") else: print("Çok uzun bir adın var.") Gördüğünüz gibi girilen karakter dizisinin uzunluğuna göre ekrana bir çıktı yazdırmaktayız. Python3.8’e sahipseniz vereceğimiz örnekleri kendiniz de deneyebilirsiniz. Bir de:= işleci ile bukodunasılyazabileceğimizebakalım: if ( giriş := len(input("Adın ne? ")) ) < 4: print("Adın kısaymış.") elif giriş < 6: print("Adın biraz uzunmuş.") else: print("Çok uzun bir adın var.") Buradagirişdeğişkeninedeğeratamayıififadesininiçindeyaptık.Normaldeböylebirişlemi =ileyapamazdık: >>> if ( giriş = len(input("Adın ne? ")) ) < 4: SyntaxError: invalid syntax Fark edebileceğiniz gibi walrus operatörü bizi bir satır fazladan yazmaktan kurtardı. Kullanıcıdan alınan bilginin giriş değişkenine nasıl atandığına dikkat edin. giriş değişkeninden sonra:= işlecini kullanıyoruz ve aynı zamanda değişken atamasını yaptığımız bölümün tamamını parantez içine alıyoruz. Peki bu parantezi koymaz isek ne olur? Gelin bir örnekiledeonudeneyelim: 184 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 if giriş := len(input("Adın ne? ")) < 4: print(giriş) Eğer bu kodu çalıştırsanız ekrana True yazıldığını veya hiçbir şey yazılmadığını görebilirsiniz. Oysa önceki parantez kullandığımız kodda giriş değişkeni bir int’di. Bu örneğimizde ise ilk önce len(input("Adın ne? ")) < 4 kısmı çalışıyor ve bunun sonucu daha sonra giriş değişkenimizeatanıyor.BuyüzdengirişdeğişkenimizTrueveyaFalse,yanibirboololuyor. EğergirişdeğişkeniTrueolursaekranayazılıyor,ancakeğerFalseolursaekranayazılmıyor. Çünküififadesinin değeri deFalseoluyor.ififadesinin kontrol ettiği yer len(input("Adın ne? ")) < 4kısmıolduğuiçinifdeyimininiçinegirilmiyor. Çokönemlibirişleçolmayabiliramabazenaynıfonksiyonuikidefaçağırmakyerinebirdefa çağırmak gibi kolaylıklar sağlamaktadır. Bu konu ile alakalı daha fazla örnek için buraya17 bakabilirsiniz 13.5 Bitwise (Bitsel) İşleçleri Bu bölümde bitwise işleçlerinden söz edeceğiz, ancak bitwise işleçlerini anlayabilmek için öncelikle ikili sayı sistemi hakkında bilgi sahibi olmanız gerekecek. Görüldüğü üzere, bitwise işleçleriikilisayılartemelindeişlemleryapmamızayararsağlar. Peki,nedirbuikilisaymasistemi? İkilisayısistemi,bilgisayarlarınverileritemsiletmekiçinkullandığıtemelsayısistemidir.Her yerde duyduğunuz gibi, ekrandaki her şey size ne kadar karmaşık gelse de, bilgisayarlarımız bunları ikili (binary) tabanda temsil eder. Örneğin, “10” sayısının ikili tabanda gösterimi “1010”şeklindedir.İkilisaymasisteminde,birsayıyıoluşturanrakamlar2’ninkuvvetleriolarak hesaplanır.Busayıyı2’ninkuvvetlerinikullanarakşuşekildehesaplayabiliriz: >>> (0 * (2 ** 0)) + (1 * (2 ** 1)) + (0 * (2 ** 2)) + (1 * (2 ** 3)) 10 Tabii, daha fazlasını dokümanın ileri18 bölümlerinde anlatacağız. Şimdilik bunları bilseniz yeterli. tabularytabulary & MantıksalAnd | MantıksalOr >> Kaydırma << Kaydırma ^ MantıksalXOR ~ Tümleme Şunu da söylemeden geçmeyelim, yukarıda gördüğünüz bu işleçler çoğumuzun lise matematik derslerinde gördüğü veya göreceği sembolik mantık (namıdeğer matematiksel mantık) ilkelerine dayandığından, her işleçte sembolik mantık derslerindeki karşılıklarını da göstereceğiz. Tabii, daha önce sembolik mantıktan haberdar olmayanlar için başlamadan 17https://forum..com/t/walrus-operator/4612 18https://python-..com/sayma_sistemleri.html#ikili-sayma-sistemi 13.5. Bitwise(Bitsel)İşleçleri 185 PythonBelgeleri,Yayım4.1.3 önce ilerde işimize yarayacak olan önermelerin ne olduğuna bir bakalım. Eğer daha detaylı olaraköğrenmekisterseniz,Wikipedia’yabakmanızyeterli. Önermeler Siz hiç farketmemiş olsanız da Python’da birçok kez önerme kullandınız. Hemen birini gösterelim: a = 10 if a == 10: ... Yukarıda gördüğünüz kodda a == 10 bir önermedir. Peki önerme dediğimiz şeyi tanımlasak nasılolur?Mantıktadoğrulanabiliryadayanlışlanabilirolmakzorundaolanifadelereönerme denir.Bayağıhiçbirşeyifadeetmeyenkelimelergrubugibiduranbucümleyibirazaçıklayalım. Demekistediğimizşeyşu:Herhangibircümlemizolsun,doğruyadayanlışolmasıumrumuzda bile değil ama yanlış ya da doğru olabilmesi onun bize bir önerme olabileceğini gösteriyor. Mesela Mertcan adında bir arkadaşımız olsun. Bu arkadaş Keloğlan izlemeyi seviyor olsun. Mertcan’ınbirarkadaşınaşöylebirşeydiyelim: MertcanKeloğlanizlemeyisevmiyor. Bucümlebirönermedirancakbuönermedoğrudeğildir.Sembolikolarakdeğerinigöstermek istersek,0ilegöstermemizgerekecektir. if a == 10: ... O zaman ilk örneğimize dönersek, gerçekten de a = 10 olduğu için önerme doğrudur, yani if bloğumuzgüzelceçalışır.Sonolarak,neyinönermeolduğunusöylediğimizgibi,neyinönerme olmadığınıdabelirtelim.Mesela: Bugünhavaçokgüzel. BenceengüzelşehirErzincan’dır. Bu iki cümleyi inceleyelim. Bugün hava sana göre güzel olabilir ama bana göre olmayabilir. Ya da bir başkası en güzel şehrin İstanbul olduğunu düşünüyor olabilir. Yani bu cümlelerin doğruluğunuyadayanlışlığınıkesinolarakbelirleyemeyiz.Demekkibuikiörnektekigibiöznel cümlelerdenönermeolmaz. Benceönermeleriherkesanladı.Meraklısıiçininternetemrinizeamade. MantiksalAND(ve)İşleci(&) Bu işleç her iki tarafındaki değişkenin bitleri üzerinde mantıksal and işlemi uygular. Aslında önceki bölümde gördüğünüz and işleci ile aynı işlemi karşılıklı bitler üzerinde yapar. Mesela bunabirörnekverelim. if (True and False): # 1 = True, 0 = False ... Daha önceki örneklerimizde anlatıldığı üzere bu ifade False olacağından if bloğumuz çalışmayacaktır.MantıksalAndişlecimizdeaynıişlemikarşılıklıbitlerüzerindeyapacak. 186 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 tabularytabulary 1&1 =1 1&0 =0 0&1 =0 0&0 =0 Örneküzerindenanlatmakbutarzişleçlerinişlevinianlayabilmekiçindahauygunolacaktır. a = 10 # 0000 1010 = 10 b = 20 # 0001 0100 = 20 print(a & b) # 0000 0000 = 0 0 c = 10 # 0000 1010 = 10 d = 22 # 0001 0110 = 22 print(c & d) # 0000 0010 = 2 2 ÖrneklerdedegördüğünüzgibimantıksalAndişlecikarşılıklıbitlerdeişlemyapar.Andişlemi ile karşılaştırılmış iki bitten biri bile 0 olsa; 0 sonucunu alırsınız. 1 sonucu alabilmek için her ikibitinde1olmasıgerek. MantıksalOR(veya)İşleci(|) Bu işleç, her iki tarafındaki değişkenin bitleri üzerinde mantıksal or (veya) işlemi yapar. Bu işleç,öncekibölümdegördüğünüzorişleciileaynıişlemikarşılıklıbitlerüzerindeyapar. if (True or False): # 1 = True, 0 = False ... BuörneğimizdeparanteziçiifademizTruedeğerineeşitolacağındanifbloğumuzçalışacaktır. Mantıksalordaaynıprensibedayalıdır. tabularytabulary 1|1 =1 1|0 =1 0|1 =1 0|0 =0 Hemengüzideörneğimizigetirelim. a = 10 # 0000 1010 = 10 b = 20 # 0001 0100 = 20 print(a | b) # 0001 1110 = 30 30 13.5. Bitwise(Bitsel)İşleçleri 187 PythonBelgeleri,Yayım4.1.3 a = 10 # 0000 1010 = 10 b = 22 # 0001 0110 = 22 print(a | b) # 0001 1110 = 30 30 Örneğimizi inceleyelim, alt alta bitlerde eğer sadece bir tane ‘1’ varsa, o bit karşılaştırma sonrasında 1’e eşit olur. Zaten yukarıdaki tablomuzda belirtilmiş. Eğer karşılaştırma sonucunun0olmasınıistiyorisekherikibitinde0değerinialmasılazım. MantıksalXOR(yada)İşleci(^) Bu işleçten önceki bütün işleçlerin adı sembolik mantıktaki karşılığı ile aynıydı ancak burada durumbirazfarklı.SembolikmantıkderslerindebizXORişlecine‘yada’deriz.Buişleçdeheriki tarafındakideğişkeninbitleriüzerinde‘XOR’işlemiyapar.Tabiibuderslerde“yada”nınişlevini dahaöncegörmedik.Ozaman“yada”yıgösterelim tabularytabulary 1^1 =0 1^0 =1 0^1 =1 0^0 =0 XOR (ya da) ile bağlanan iki basit önermenin doğru olabilmesi için iki önermenin de değerininbirbirindenfarklıolmasıgerekmektedir.YaniXOR(yada)ilekarşılaştırmaişleminin 1 (doğru) olabilmesi için önermelerin birbirinden farklı doğruluk değerlerine sahip olması gerekmektedir.Tabloyugüzelceincelersenizaklınızakazınacaktır. Örneğimizüzerindendebirgörelimisterseniz. a = 10 # 0000 1010 = 10 b = 20 # 0001 0100 = 20 print(a^b) # 0001 1110 = 30 30 a = 10 # 0000 1010 = 10 b = 22 # 0001 0110 = 22 print(a^b) # 0001 1100 = 28 28 Örnekte de görüldüğü gibi alt alta olan bitlerde eğer bit değeri aynı ise karşılaştırma sonrası obitindeğeri0olacaktır.Eğerbudurumgerçekleşmezsebitimizindeğeri1olacaktır. Tümleme(Invert)İşleci(~) Tümlemeişlecidiğerişleçlerdenfarklıolarak2değerarasındakarşılaştırmayapmaz.Buişlece sembolikmantıkta“Değil”denir.Buişlecingörevialdığıdeğeritersineçevirmektir. 188 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 tabularytabulary ~1 =0 ~0 =1 Tablodan da anlaşılacağı gibi tümleme işleci aldığını tersine çevirip bize veriyor. Bu işlevin aynısınıverdiğimizdeğeredeyapacak. Hemenbirörnekgetirelim: a = 1 # 0000 0001 = 1 print(~a) # 1111 1110 = -2 -2 b = 19 # 0001 0011 = 19 print(~b) # 1110 1100 = -20 -20 Hay aksi sanki buradaki çıktılarda bir garipilik var değil mi? Evet var. Hemen açıklayalım. Şöyle ki bir bit dizisinde son bit karakterin (ya da sayının) işaretini temsil eder. Geçmiş örneklerimizde son bit hep 0 olduğu için sayımız pozitif değerdeydi. Bu örneğimizde ise ‘~’ işaretinin etkisiyle bu değerimiz 1 oldu yani negatif değerli tam sayıyı temsil etti. Ama iş burası ile de kalmıyor. Biz tümleme işlemi yaptığımız zaman aslında bitlerin değerini başka şekildehesaplıyoruz.Birkere1ile0değerlerininişleveleminideğiştirmişoluyoruz.Yaniikilinin katlarını artık 0’a göre yazıyoruz. Bu değerleri en sonunda toplayıp -1’den çıkarıyoruz. İşte böylecetümlemeişlemimizsonucuçıkanbitindeğerinihesaplayabiliriz.Amabukısımokadar daönemlideğilsadeceformüleetmekdeyeter. n-(2n+1) İştesizetümlemeişlemininsonucunugösterengüzideformül. ‘ ‘‘ ‘ Shifting(kaydırma)İşleçleri( >> << ) Kaydırmaişleçlerininsembolikmantıktabirkarşılığıyoktur.Bunlartamamenprogramlamaya özgüdür. Bu işleçler için bir tabloya da ihtiyaç duymayacağız. Hemen bir örnek verelim ve açıklamasınıyapalım. a = 64 # 0100 0000 = 64 print(a >> 3) # 0000 1000 = 8 8 b = 16 # 0001 0000 = 16 print(b << 2) # 0100 0000 = 64 64 13.5. Bitwise(Bitsel)İşleçleri 189 PythonBelgeleri,Yayım4.1.3 Zatenazçokörneklerdenneolduğuortayaçıkıyor.Oklarınsolundakisayınınbitleriniokların sağındakisayıkadaroklarınyönündekaydırıyoruz.Ancakbuişleçtebazıpüfnoktalarımızvar, onuhemengösterelim. a = 64 print(a << 1) # ... 1000 0000 = 128 Evet,buradaöncekiişleçtegösterdiğimiznegatif-pozitifolayınıyaşamadık.Pekineden?Şuana kadar ki örneklerimizde hep 8 bit üzerinden örnekler yaptık ancak Python’da bu genellikle böyleolmuyor.Bunuşöylekontroledebiliriz. import sys a = 1 sys.getsizeof(a) # 28 28 Yukarıdakikoddaanlamadığınızyerlervarsatakılmayın.Sadeceşunubilmenizyeterli.Bukod parçası size elinizdeki değişkenin boyutunu söyler. Gördüğünüz gibi ‘a’ değişkenin boyutu 28miş.Demekkibudeğişken28bittenoluşuyormuş.Pekişöylebirşeyyapsaydık. import sys a = 1 a <<= 30 sys.getsizeof(a) # 32 32 Gördüğünüz gibi değişkenimiz boyut değişikliğine uğradı. Yani bit kaydırma işleminde sola giderkendeğişkenimizingidebileceğibaşkayerikalmayıncaboyutunudeğiştirebiliyor.Ancak bunu tümeleme işleminde yapmıyor çünkü tümeleme işleminin amacına uygun değil. Bir başkapüfnoktaiseşöyle: (cid:242) Not Değer atama işleçleri bölümünde gördüğünüz “+=”, “-=” gibi ifadeleri bitsel işleçler ile de kullanabilirsiniz.(Yukarıdagördüğünüzgibi) a = 15 # 0000 1111 = 15 print(a >> 3) # 0000 0001 = 1 1 Gördüğünüz gibi bit kaydırma işleminde eğer sağda yer yoksa o değer atılır. Çünkü bitlerde değerartırımısoltarafaeklemeyaparakolurkizatenmantıklısıdabu. 190 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 (cid:242) Not Bukısımeğerprogramlamayayenibaşlıyorsanızbirazzorgelebilir.Anlayamadığınızkısım olursa telaşlanmayın ve ilerlemeye devam edin. Biraz daha temelinizi sağlamlaştırınca tekrarburayadönebilirsiniz.Eminolun,ozamanherşeydahagüzelceoturur. BitselİşleçleriKullanmanınAvantajlarıveDezavantajları Şimdibitselişleçlerimizinavantajlarınıvedezavantajlarınıgörelim. Avantajlar: 1. Performans: Bitsel işlemler genellikle daha hızlıdır çünkü bilgisayarlar üzerinde doğrudan donanım seviyesinde gerçekleştirilirler. Özellikle büyük veri setleri üzerinde çalışırkenperformansıartırabilirler. 2. BellekKullanımı:Bitselişlemlergenellikledahaazbellekkullanır.Bu,özellikleçokbüyük veriyapılarıüzerindeişlemyaparkenbellekkullanımınıazaltmayayardımcıolabilir. Dezavantajlar: 1. Okunabilirlik:Bitselişlemler,genelliklekodunokunabilirliğiniazaltabilir.Bitseviyesinde yapılanişlemler,kodunneyaptığınıanlamakiçindahafazlaçabagerektirebilir. 2. Hata Yapma Olasılığı: Bitsel işlemlerle çalışırken, yanlış operatörler veya yanlış bit işlemleri yapma olasılığı daha yüksektir. Bu, hataların bulunması ve düzeltilmesi için dahafazlazamanharcanmasınanedenolabilir. (cid:242) Not Asıl dezavantajı görünür kılmak için buraya koydum. Bitwise ile yapılan işlemler Python dilininamacınauygundeğildir.Pythonyazılımdilininamacıkullanıcıkolaylığıdır.Pythonda performans ve bellek kullanımı çok önemsenmez. Eğer böyle ihtiyaçlarınız varsa başka dillerleilgilenmenizdahadoğruolacaktır.Amabusöylediklerimden“Şimdibenbubölümü boşuna mı okudum?” diye bir sonuç çıkarmayın. Burada gösterdiğimiz şeyler neredeyse bütün programlama dillerinde mevcut. Ayrıca yaptığınız bütün işlemler dayanağını bu işleçlerden alıyor. Bu kısma özellikle dikkat etmenizi rica ediyorum. Emin olun bu yolculuktaöğrendiğinizhiçbirşeyboşunaolmayacak. 13.6 Aitlik İşleçleri Aitlik işleçleri, bir karakter dizisi ya da sayının, herhangi bir veri tipi içinde bulunup bulunmadığınısorgulamamızısağlayanişleçlerdir. Python’dabirtaneaitlikişlecibulunur.Buişleçdeinişlecidir.Buişlecişöylekullanıyoruz: >>> a = "abcd" >>> "a" in a True (sonrakisayfayadevam) 13.6. Aitlikİşleçleri 191 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> "f" in a False Gördüğünüzgibi,inadlıbuişleç,biröğenin,veritipiiçindebulunupbulunmadığınısorguluyor. Eğer bahsedilen öğe, veri tipi içinde geçiyorsa True çıktısı, eğer geçmiyorsa False çıktısı alıyoruz. Henüz bu in işlecini verimli bir şekilde kullanmamızı sağlayacak araçlardan yoksunuz. Ancak birkaç sayfa sonra öğreneceğimiz yeni araçlarla birlikte bu işleci çok daha düzgün ve verimli birşekildekullanabilecekdurumageleceğiz. 13.7 Kimlik İşleçleri Python’daherşeyin(yadabaşkabirdeyişlehernesnenin)birkimliknumarası(identity)vardır. Kabaca söylemek gerekirse, bu kimlik numarası denen şey esasında o nesnenin bellekteki adresinigösterir. Pekibirnesneninkimliknumarasınanasılulaşırız? Python’dabuişiyapmamızısağlayacakid()adlıbirfonksiyonbulunur(İngilizcedekiidentity (kimlik) kelimesinin kısaltması). Şimdi bir örnek üzerinde bu id() fonksiyonunu nasıl kullanacağımızabakalım: >>> a = 100 >>> id(a) 137990748 Çıktıdagördüğümüz137990748sayısıadeğişkeninintuttuğu100sayısınınkimliknumarasını gösteriyor. Birdeşuörneklerebakalım: >>> a = 50 >>> id(a) 505494576 >>> kardiz = "Elveda Zalim Dünya!" >>> id(kardiz) 14461728 Gördüğünüzgibi,Python’dakihernesneninkimliğieşşiz,tekvebenzersizdir. Yukarıdaverdiğimizilkörnektebiradeğişkenitanımlayıpbunundeğerini100olarakbelirlemiş veid(a)komutuyladabunesneninkimliknumarasınaulaşmıştık.Yani: 192 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 >>> a = 100 >>> id(a) 137990748 Birdeşuörneğebakalım: >>> b = 100 >>> id(b) 137990748 Gördüğünüz gibi, Python a ve b değişkenlerinin değeri için aynı kimlik numarasını gösterdi. Bu demek oluyor ki, Python iki adet 100 sayısı için bellekte iki farklı nesne oluşturmuyor. İlk kullanımdaönbelleğinealdığısayıyı,ikincikezihtiyaçolduğundabellektenalıpkullanıyor.Bu türbirönbelleklememekanizmasınıngerekçesiperformansıartırmaktır. Amabirdeşuörneklerebakalım: >>> a = 1000 >>> id(a) 15163440 >>> b = 1000 >>> id(b) 14447040 >>> id(1000) 15163632 Bu defa Python a değişkeninin tuttuğu 1000 sayısı, b değişkeninin tuttuğu 1000 sayısı ve tek başınayazdığımız1000sayısıiçinfarklıkimliknumaralarıgösterdi.Budemekoluyorki,Python a değişkeninin tuttuğu 1000 sayısı için, b değişkeninin tuttuğu 1000 sayısı için ve doğrudan girdiğimiz 1000 sayısı için bellekte üç farklı nesne oluşturuyor. Yani bu üç adet 1000 sayısı Pythonaçısındanbirbirindenfarklı... Yukarıdaki durumu görebileceğimiz başka bir yöntem de Python’daki is adlı kimlik işlecini kullanmaktır.Deneyelim: >>> a is 1000 False >>> b is 1000 False Gördüğünüz gibi, Python False (Yanlış) çıktısını suratımıza bir tokat gibi çarptı... Peki bu ne anlamageliyor? Bu şu anlama geliyor: Demek ki görünüşte aynı olan iki nesne aslında birbirinin aynı 13.7. Kimlikİşleçleri 193 PythonBelgeleri,Yayım4.1.3 olmayabiliyor. Bunun neden bu kadar önemli olduğunu ilerleyen derslerde çok daha iyi anlayacağız. Yukarıdaki durumun bir başka yansıması daha vardır. Özellikle Python’a yeni başlayıp da bu dilde yer alan is işlecini öğrenenler, bu işlecin == işleciyle aynı işleve sahip olduğu yanılgısına kapılabiliyor ve is işlecini kullanarak iki nesne arasında karşılaştırma işlemi yapmayakalkışabiliyor. AncakPython’daisişlecinikullanarakikinesnearasındakarşılaştırmayapmakgüvenlideğildir. Yani is ve == işleçleri birbirleriyle aynı işlevi görmez. Bu iki işleç nesnelerin farklı yönlerini sorgular: is işleci nesnelerin kimliklerine bakıp o nesnelerin aynı nesneler olup olmadığını kontrol ederken, == işleci nesnelerin içeriğine bakarak o nesnelerin aynı değere sahip olup olmadıklarınısorgular.Buikitanımarasındakiincefarkadikkatedin. Yani: >>> a is 1000 False Ama: >>> a == 1000 True Burada is işleci a değişkeninin tuttuğu veri ile 1000 sayısının aynı kimlik numarasına sahip olup olmadığını sorgularken, == işleci a değişkeninin tuttuğu verinin 1000 olup olmadığını denetliyor.Yaniisişlecininyaptığışeykabacaşuoluyor: >>> id(a) == id(1000) False Şimdiye kadar denediğimiz örnekler hep sayıydı. Şimdi isterseniz bir de karakter dizilerinin durumunabakalım: >>> a = "python" >>> a is "python" True BuradaTrueçıktısınıaldık.Birde==işleciilebirkarşılaştırmayapalım: >>> a == "python" True BudanormalolarakTrueçıktısıveriyor.Amaşuörneğebakarsak: >>> a = "python güçlü ve kolay bir programlama dilidir" >>> a is "python güçlü ve kolay bir programlama dilidir" False 194 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 Ama: >>> a == "python güçlü ve kolay bir programlama dilidir" True is ve == işleçlerinin nasıl da farklı sonuçlar verdiğini görüyorsunuz. Çünkü bunlardan biri nesnelerin kimliğini sorgularken, öbürü nesnelerin içeriğini sorguluyor. Ayrıca burada dikkatimizi çekmesi gereken başka bir nokta da “python” karakter dizisinin önbelleğe alınıp gerektiğinde tekrar tekrar kullanılıyorken, “python güçlü ve kolay bir programlama dilidir” karakterdizisininiseönbelleğealınmıyorolmasıdır.Aynıkarakterdizisinintekrarkullanılması gerektiğindePythonbununiçinbellekteyenibirnesnedahaoluşturuyor. Peki neden Python, örneğin, 100 sayısını ve “python” karakter dizisini önbelleklerken 1000 sayısınıve“pythongüçlüvekolaybirprogramlamadilidir”karakterdizisiniönbelleğealmıyor. Sebebi şu: Python kendi iç mekanizmasının işleyişi gereğince ‘ufak’ nesneleri önbelleğe alırken ‘büyük’ nesneler için her defasında yeni bir depolama işlemi yapıyor. Peki ufak ve büyük kavramlarının ölçütü nedir? İsterseniz Python açısından ufak kavramının sınırının ne olabileceğinişöylebirkodyardımıylasorgulayabiliriz: >>> for k in range(-1000, 1000): ... for v in range(-1000, 1000): ... if k is v: ... print(k) (cid:242) Not Burada henüz öğrenmediğimiz şeyler var. Bunları birkaç bölüm sonra ayrıntılı bir şekilde inceleyeceğiz. Bu kod -1000 ve 1000 aralığındaki iki sayı grubunu karşılaştırıp, kimlikleri aynı olan sayıları ekrana döküyor. Yani bir bakıma Python’un hangi sayıya kadar önbellekleme yaptığını gösteriyor. Buna göre -5 ile 257 arasında kalan sayılar Python tarafından ufak olarak değerlendiriliyor ve önbelleğe alınıyor. Bu aralığın dışında kalan sayılar için ise bellekte her defasındaayrıbirnesneoluşturuluyor. Buradaaldığımızsonucagöreşöylebirdenetlemeişlemiyapalım: >>> a = 256 >>> a is 256 True >>> a = 257 >>> a is 257 False >>> a = -5 >>> a is -5 (sonrakisayfayadevam) 13.7. Kimlikİşleçleri 195 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) True >>> a = -6 >>> a is -6 False Böylece Python’daki kimlik işleçlerini de incelemiş olduk. Belki programcılık maceranız boyunca id() fonksiyonunu hiç kullanmayacaksınız, ancak bu fonksiyonun arkasındaki mantığı anlamak, Python’ın kimi yerlerde alttan alta neler çevirdiğini çok daha kolay kavramanızısağlayacaktır. (cid:242) Not https://web.archive.org/web/20161121150306/http://forum.ceviz.net/t/ sozluklerin-dinamik-olarak-kopyalanmasi-ve-clear-isleci.81605/ adresindeki tartışmaya bakınız. Böylece Python’daki bütün işleçleri ayrıntılı bir şekilde incelemiş olduk. Dilerseniz şimdi bu konuylailgilibirkaçuygulamaörneğiyapalım. 13.8 Uygulama Örnekleri 13.8.1 Basit Bir Hesap Makinesi Şu ana kadar Python’da pek çok şey öğrendik. Bu öğrendiğimiz şeylerle artık kısmen yararlı bazı programlar yazabiliriz. Elbette henüz yazacağımız programlar pek yetenekli olamayacak olsa da, en azından bize öğrendiklerimizle pratik yapma imkanı sağlayacak. Bu bölümde, if, elif, else yapılarını ve öğrendiğimiz temel aritmetik işleçleri kullanarak çok basit bir hesap makinesi yapmayı deneyeceğiz. Bu arada, bu derste yeni şeyler öğrenerek ufkumuzu vebilgimizigenişletmeyideihmaletmeyeceğiz. İstersenizöncekullanıcıyabazıseçeneklersunarakişebaşlayalım: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) kare kök hesapla """ print(giriş) Burada kullanıcıya bazı seçenekler sunduk. Bu seçenekleri ekrana yazdırmak için üç tırnak işaretlerinden yararlandığımıza dikkat edin. Birden fazla satıra yayılmış bu tür ifadeleri en kolayüçtırnakişaretleriyardımıylayazdırabileceğimizibiliyorsunuzartık. 196 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 Biz burada bütün seçenekleri tek bir değişken içine yerleştirdik. Esasında her bir seçenek için ayrı bir değişken tanımlamak da mümkündür. Yani aslında yukarıdaki kodları şöyle de yazabiliriz: seçenek1 = "(1) topla" seçenek2 = "(2) çıkar" seçenek3 = "(3) çarp" seçenek4 = "(4) böl" seçenek5 = "(5) karesini hesapla" seçenek6 = "(6) karekök hesapla" print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5) Yalnız burada dikkat ederseniz, seçenekler hep yan yana diziliyor. Eğer programınızda yukarıdakişeklikullanmakisterseniz,buseçeneklerinyanyanadeğilde,altaltagörünmesini sağlamakiçin,öncekiderslerimizdeöğrendiğimizsepparametresinikullanabilirsiniz: seçenek1 = "(1) topla" seçenek2 = "(2) çıkar" seçenek3 = "(3) çarp" seçenek4 = "(4) böl" seçenek5 = "(5) karesini hesapla" seçenek6 = "(6) karekök hesapla" print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5, seçenek6, sep="\n") Buradasepparametresinindeğeriolarak\nkaçışdizisinibelirlediğimizedikkatedin.\nkaçış dizisininneişeyaradığınıhatırlıyorsunuz.Budizi,satırbaşınageçmemizisağlıyordu.Burada, ayraç olarak satır başı kaçış dizisini belirlediğimiz için her bir seçenek yan yana değil, alt alta görünecektir. Elbette sep parametresi için istediğiniz değeri belirleyebilirsiniz. Mesela her bir seçeneği satır başı işaretiyle ayırmak yerine, çift tire gibi bir işaretle ayırmayı da tercih edebilirsiniz: print(seçenek1, seçenek2, seçenek3, seçenek4, seçenek5, sep="--") Programınızdanasılbirgirişparagrafıbelirleyeceğinizkonusundaözgürsünüz.Gelinisterseniz bizbirincişekilleyolumuzadevamedelim: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla """ print(giriş) Burada giriş adlı bir değişken oluşturduk. Bu değişkenin içinde barındırdığı değeri kullanıcıların görebilmesi için print() fonksiyonu yardımıyla bu değişkeni ekrana yazdırıyoruz.Devamedelim: 13.8. UygulamaÖrnekleri 197 PythonBelgeleri,Yayım4.1.3 soru = input("Yapmak istediğiniz işlemin numarasını girin: ") Bu kod yardımıyla kullanıcıya bir soru soruyoruz. Kullanıcıdan yapmasını istediğimiz şey, yukarıda belirlediğimiz giriş seçenekleri içinden bir sayı seçmesi. Kullanıcı 1, 2, 3, 4, 5 veya 6 seçeneklerinden herhangi birini seçebilir. Kullanıcıyı, seçtiği numaranın karşısında yazan işleme yönlendireceğiz. Yani mesela eğer kullanıcı klavyedeki 1 tuşuna basarsa hesap makinemiztoplamaişlemiyapacaktır.2tuşuisekullanıcıyıçıkarmaişlemineyönlendirir... input() fonksiyonunu işlediğimiz bölümde, bu fonksiyonun değer olarak her zaman bir karakter dizisi (string) verdiğini söylemiştik. Yukarıdaki kodun çıktısı da doğal olarak bir karakterdizisiolacaktır.Bizimşuaşamadakullanıcıdankarakterdizisialmamızınbirsakıncası yok. Çünkü kullanıcının gireceği 1, 2, 3, 4, 5 veya 6 değerleriyle herhangi bir aritmetik işlem yapmayacağız. Kullanıcının gireceği bu değerler, yalnızca bize onun hangi işlemi yapmak istediğinibelirtecek.Dolayısıylainput()fonksiyonunuyukarıdakişekildekullanıyoruz. İstersenizşimdiyekadargördüğümüzkısmatoplucabakalım: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla """ print(giriş) soru = input("Yapmak istediğiniz işlemin numarasını girin: ") Bu kodları çalıştırdığımızda, ekranda giriş paragrafımız görünecek ve kullanıcıya, yapmak istediği işlemin ne olduğu sorulacaktır. Henüz kodlarımız eksik olduğu için, kullanıcı hangi sayıyıgirersegirsin,programımızhiçbirişyapmadankapanacaktır.Ohaldeyolumuzadevam edelim: if soru == "1": Böylece ilk if deyimimizi tanımlamış olduk. Buradaki yazım şekline çok dikkat edin. Bu kodlarlaPython’aşuemrivermişoluyoruz: Eğer soru adlı değişkenin değeri 1 ise, yani eğer kullanıcı klavyede 1 tuşuna basarsa... if deyimlerinin en sonuna: işaretini koymayı unutmuyoruz. Python’a yeni başlayanların en çok yaptığı hatalardan birisi, sondaki bu: işaretini koymayı unutmalarıdır. Bu işaret bize çok ufak bir ayrıntıymış gibi görünse de Python için manevi değeri çok büyüktür! Python’un bize öfkeli mesajlar göstermesini istemiyorsak bu işareti koymayı unutmayacağız. Bu arada, burada == işaretini kullandığımıza da dikkat edin. Bunun ne anlama geldiğini önceki derslerimizde öğrenmiştik. Bu işaret, iki şeyin aynı değere sahip olup olmadığını sorgulamamızı sağlıyor. Biz burada soru adlı değişkenin değerinin 1 olup olmadığını sorguladık. soru değişkeninin değeri kullanıcı tarafından belirleneceği için henüz bu değişkenin değerinin ne olduğunu bilmiyoruz. Bizim programımızda kullanıcı klavyeden 1, 2, 3, 4, 5 veya 6 değerlerinden herhangi birini seçebilir. Biz yukarıdaki kod yardımıyla, eğer 198 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 kullanıcıklavyede1tuşunabasarsaneyapılacağınıbelirleyeceğiz.Ohaldedevamedelim: if soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Böyleceilkifbloğumuzutanımlamışolduk. if deyimimizi yazdıktan sonra ne yaptığımız çok önemli. Buradaki girintileri, programımız güzel görünsün diye yapmıyoruz. Bu girintilerin Python için bir anlamı var. Eğer bu girintileri vermezsek programımız çalışmayacaktır. Eğer Python kodlarına duyarlı bir metin düzenleyici kullanıyorsanız,: işaretini koyup Enter tuşuna bastıktan sonra otomatik olarak girinti verilecektir. Eğer kullandığınız metin düzenleyici size böyle bir kolaylık sunmuyorsa Enter tuşuna bastıktan sonra klavyedeki boşluk (SPACE) tuşunu kullanarak dört vuruşluk bir girinti oluşturabilirsiniz. Bu girintiler, ilk satırda belirlediğimiz if deyimiyle gösterilecek işlemlere işaret ediyor. Dolayısıyla burada yazılan kodları Pythoncadan Türkçeye çevirecek olursakşöylebirşeyeldeederiz: eğer sorunun değeri ’1’ ise: Toplama işlemi için ilk sayı girilsin. Bu değere ’sayı1’ diyelim. Sonra ikinci sayı girilsin. Bu değere de ’sayı2’ diyelim. En son, ’sayı1’, ’+’ işleci, ’sayı2’, ’=’ işleci ve ’sayı1 + sayı2’ ekrana yazdırılsın... Gelinistersenizburayakadarolanbölümüyinetoplucagörelim: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla """ print(giriş) soru = input("Yapmak istediğiniz işlemin numarasını girin: ") if soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Bu kodları çalıştırıp, klavyede 1 tuşuna bastığımızda, bizden bir sayı girmemiz istenecektir. İlk sayımızı girdikten sonra bize tekrar bir sayı girmemiz söylenecek. Bu emre de uyup Enter tuşunabasınca,girdiğimizbuikisayınıntoplandığınıgöreceğiz.Fenasayılmaz,değilmi? Şimdi programımızın geri kalan kısmını yazıyoruz. İşin temelini kavradığımıza göre birden fazlakodbloğunuaynıandayazabiliriz: 13.8. UygulamaÖrnekleri 199 PythonBelgeleri,Yayım4.1.3 elif soru == "2": sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: ")) sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: ")) print(sayı3, "-", sayı4, "=", sayı3 - sayı4) elif soru == "3": sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: ")) sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: ")) print(sayı5, "x", sayı6, "=", sayı5 * sayı6) elif soru == "4": sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: ")) sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: ")) print(sayı7, "/", sayı8, "=", sayı7 / sayı8) elif soru == "5": sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: ")) print(sayı9, "sayısının karesi =", sayı9 ** 2) elif soru == "6": sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: ")) print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5) Bunlarlabirliktekodlarımızınbüyükbölümünütamamlamışoluyoruz.Bubölümdekitekfark, ilkifbloğununaksine,buradaelifbloklarınıkullanmışolmamız.Eğerburadabütünblokları if kullanarak yazarsanız, biraz sonra kullanacağımız else bloğu her koşulda çalışacağı için beklentinizindışındasonuçlareldeedersiniz. Yukarıdaki kodlarda az da olsa farklılık gösteren tek yer son iki elif bloğumuz. Esasında buradakifarkdapekbüyükbirfarksayılmaz.Neticedetekbirsayınınkaresinivekarekökünü hesaplayacağımıziçin,kullanıcıdanyalnızcatekbirgirişistiyoruz. Şimdidesonbloğumuzuyazalım.Azevvelçıtlattığımızgibi,busonblokbirelsebloğuolacak: else: print("Yanlış giriş.") print("Aşağıdaki seçeneklerden birini giriniz:", giriş) Çokbasitbirelsebloğuileişimizibitirdik.Bubloğunneişeyaradığınıbiliyorsunuz: Eğerkullanıcınıngirdiğideğeryukarıdakibloklardanhiçbirineuymuyorsabuelse bloğunuişlet! gibi bir emir vermiş oluyoruz bu else bloğu yardımıyla. Mesela kullanıcımız 1, 2, 3, 4, 5 veya 6seçeneklerinigirmekyerine7yazarsa,bublokişletilecek. Gelinistersenizsonkezkodlarımızıtoplucabirgörelim: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (sonrakisayfayadevam) 200 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) (5) karesini hesapla (6) karekök hesapla """ print(giriş) soru = input("Yapmak istediğiniz işlemin numarasını girin: ") if soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) print(sayı1, "+", sayı2, "=", sayı1 + sayı2) elif soru == "2": sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: ")) sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: ")) print(sayı3, "-", sayı4, "=", sayı3 - sayı4) elif soru == "3": sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: ")) sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: ")) print(sayı5, "x", sayı6, "=", sayı5 * sayı6) elif soru == "4": sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: ")) sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: ")) print(sayı7, "/", sayı8, "=", sayı7 / sayı8) elif soru == "5": sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: ")) print(sayı9, "sayısının karesi =", sayı9 ** 2) elif soru == "6": sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: ")) print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5) else: print("Yanlış giriş.") print("Aşağıdaki seçeneklerden birini giriniz:", giriş) Genel olarak baktığımızda, bütün programın aslında basit bir ‘if, elif, else’ yapısından ibaret olduğunu görüyoruz. Ayrıca bu kodlardaki simetriye de dikkatinizi çekmek isterim. Gördüğünüz gibi her ‘paragraf’ bir if, elif veya else bloğundan oluşuyor ve her blok kendi içindegirintilibiryapısergiliyor.Temelolarakşöylebirşeylekarşıkarşıyayız: Eğer böyle bir durum varsa: şöyle bir işlem yap Yok eğer şöyle bir durum varsa: (sonrakisayfayadevam) 13.8. UygulamaÖrnekleri 201 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) böyle bir işlem yap Eğer bambaşka bir durum varsa: şöyle bir şey yap Böylelikleşirinbirhesapmakinesinesahipolmuşolduk!Hesapmakinemizpekyeteneklideğil, amaolsun... Henüzbildiklerimizbunuyapmamızamüsaadeediyor.Yinedebaşlangıçtanbu noktayakadarepeyyolkatettiğimizigörüyorsunuz. Şimdibuprogramıçalıştırınveneleryapabildiğinegözatın.Buaradakodlarıdaiyiceinceleyin. Programı yeterince anladıktan sonra, program üzerinde kendinize göre bazı değişiklikler yapın,yeniözelliklerekleyin.Eksikliklerini,zayıfyönlerinibulmayaçalışın.Böylecebudersten azamifaydayısağlamışolacaksınız. 13.8.2 Sürüme Göre İşlem Yapan Program Bildiğinizgibi,şuandapiyasadaikifarklıPythonserisibulunuyor:Python2vePython3.Daha önce de söylediğimiz gibi, Python’ın 2.x serisi ile çalışan bir program Python’ın 3.x serisi ile muhtemelen çalışmayacaktır. Aynı şekilde bunun tersi de geçerlidir. Yani 3.x ile çalışan bir program2.xilebüyükihtimalleçalışmayacaktır. Bu durum, yazdığınız programların farklı Python sürümleri ile çalıştırılma ihtimaline karşı bazı önlemler almanızı gerektirebilir. Örneğin yazdığınız bir programda kullanıcılarınızdan beklentiniz, programınızı Python’ın 3.x sürümlerinden biri ile çalıştırmaları olabilir. Eğer programınız Python’ın 2.x sürümlerinden biri ile çalıştırılırsa kullanıcıya bir uyarı mesajı göstermekisteyebilirsiniz. Hatta yazdığınız bir program, aynı serinin farklı sürümlerinde dahi çalışmayı engelleyecek özellikler içeriyor olabilir. Örneğin print() fonksiyonunun flush adlı parametresi dile 3.3 sürümüilebirlikteeklendi.Dolayısıylabuparametreyikullananbirprogram,kullanıcının3.3 veyadahayüksekbirPythonsürümükullanmasınıgerektirir.Böylebirdurumda,programınızı çalıştıranPythonsürümününendüşük3.3olmasınıteminetmenizgerekir. Pekibununasılyapacaksınız? Burada aklınızda ilk olarak, kodlarınıza #!/usr/bin/env python3.3 veya #! python3.3 gibi bir satır eklemek gelmiş olabilir. Ama unutmayın, bu çözüm ancak kısıtlı bir işlevsellik sunabilir. Programımıza böyle bir satır eklediğimizde, programımızın Python’ın 3.3 sürümü ileçalıştırılmasıgerektiğinibelirtiyoruz.Ama3.3dışıbirsürümleçalıştırıldığındaneolacağını belirtmiyoruz. Böyle bir durumda, eğer programımız 3.3 dışı bir sürümle çalıştırılırsa çökecektir.Bizimburadadahakapsamlıveesnekbirçözümbulmamızgerekiyor. Hatırlarsanız önceki derslerden birinde sys adlı bir modülden söz etmiştik. Bildiğiniz gibi, bu modül içinde pek çok yararlı değişken ve fonksiyon bulunuyor. Önceki derslerimizde, bu modül içinde bulunan exit() fonksiyonu ile stdout ve version değişkenlerini gördüğümüzü hatırlıyor olmalısınız. sys modülü içinde bulunan exit() fonksiyonunun programdan çıkmamızısağladığını,stdoutdeğişkenininstandartçıktıkonumubilgisinituttuğunuveversion değişkeninindekullandığımızPythonsürümühakkındabilgiverdiğinibiliyoruz.İşteyukarıda bahsettiğimizprogramdadabusysmodülündenyararlanacağız. Buişiçin,versiondeğişkenineçokbenzeyenversion_infoadlıbirdeğişkenikullanacağız. Budeğişkeninnasılkullanıldığınaetkileşimlikabuktaberabercebakalım... 202 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 sys modülü içindeki araçları kullanabilmek için öncelikle bu modülü içe aktarmamız gerektiğinibiliyorsunuz: >>> import sys Şimdidebumodüliçindekiversion_infoadlıdeğişkeneerişelim: >>> sys.version_info Bukomutbizeşöylebirçıktıverir: sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel=’final’, serial=0) Gördüğünüz gibi, bu değişken de bize tıpkı version adlı değişken gibi, kullandığımız Python sürümühakkındabilgiveriyor. Ben yukarıdaki komutu Python3’te verdiğinizi varsaydım. Eğer yukarıdaki komutu Python3 yerinePython2’deverseydikşöylebirçıktıalacaktık: sys.version_info(major=|major2|, minor=|minor2|, micro=|micro2|, releaselevel=’final’, serial=0) version_infoveversiondeğişkenlerininverdikleriçıktınınbirbirlerindenfarklıyapıdaolduğuna dikkatedin.versiondeğişkeni,version_infodeğişkenindenfarklıolarakşöylebirçıktıverir: ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ version_info değişkeninin verdiği çıktı bizim şu anda yazmak istediğimiz programa daha uygun.Bununnedenböyleolduğunubirazsonrasizdeanlayacaksınız. Gördüğünüz gibi, version_info değişkeninin çıktısında major ve minor gibi bazı değerler var. Çıktıdan da rahatlıkla anlayabileceğiniz gibi, major, kullanılan Python serisinin ana sürüm numarasını; minor ise alt sürüm numarasını verir. Çıktıda bir de micro adlı bir değer var. Bu dakullanılanPythonserisininenaltsürümnumarasınıverir. Budeğereşuşekildeerişiyoruz: >>> sys.version_info.major Ötekideğerleredeaynışekildeulaşıyoruz: >>> sys.version_info.minor >>> sys.version_info.micro İştebuçıktılardakimajor(veyerinegörebununlabirlikteminorvemicro)değerinikullanarak, programımızın hangi Python sürümü ile çalıştırılması gerektiğini kontrol edebiliriz. Şimdi programımızıyazalım: import sys _2x_metni = """ Python’ın 2.x sürümlerinden birini kullanıyorsunuz. Programı çalıştırabilmek için sisteminizde Python’ın 3.x sürümlerinden biri kurulu olmalı.""" _3x_metni = "Programa hoşgeldiniz." (sonrakisayfayadevam) 13.8. UygulamaÖrnekleri 203 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if sys.version_info.major < 3: print(_2x_metni) else: print(_3x_metni) Gelinistersenizönceliklebukodlarıbirazinceleyelim. İlkolarakmodülümüzüiçeaktarıyoruz.Bumodüliçindekiaraçlarıkullanabilmemiziçinbunu yapmamızşart: import sys Ardından Python’ın 2.x sürümlerinden herhangi birini kullananlar için bir uyarı metni oluşturuyoruz: _2x_metni = """ Python’ın 2.x sürümlerinden birini kullanıyorsunuz. Programı çalıştırabilmek için sisteminizde Python’ın 3.x sürümlerinden biri kurulu olmalı.""" Bildiğiniz gibi Python’da değişken adları bir sayıyla başlamaz. O yüzden değişken isminin başınabirtanealtçizgiişaretikoyduğumuzadikkatedin. BudaPython3kullanıcılarıiçin: _3x_metni = "Programa hoşgeldiniz." Artık sürüm kontrolü kısmına geçebiliriz. Eğer major parametresinin değeri 3’ten küçükse _2x_metniniyazdırıyoruz.Bunundışındakibütündurumlariçinise_3x_metninibasıyoruz: if sys.version_info.major < 3: print(_2x_metni) else: print(_3x_metni) Gördüğünüzgibi,kullanılanPythonsürümünükontroletmekveeğerprogramistenmeyenbir Pythonsürümüyleçalıştırılıyorsaneyapılacağınıbelirlemeksonderecekolay. YukarıdakiçokbasitbirkodparçasıolsadabizePythonprogramlamadilinevebudilinfarklı sürümlerinedairsondereceönemlibazıbilgilerveriyor. EğerbuprogramıPython’ın3.xsürümlerindenbiriileçalıştırdıysanızşuçıktıyıalacaksınız: Programa hoşgeldiniz. Ama eğer bu programı Python’ın 2.x sürümlerinden biri ile çalıştırdıysanız, beklentinizin aksine,şöylebirhatamesajıalacaksınız: File "test.py", line 5 SyntaxError: Non-ASCII character ’\xc4’ in file test.py on line 6, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details 204 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 Biz _2x_metni adlı değişkenin ekrana basılmasını beklerken Python bize bir hata mesajı gösterdi.Aslındasizbuhatamesajınahiçyabancıdeğilsiniz.Bunudahaöncedegörmüştünüz. Hatırlarsanız önceki derslerimizde karakter kodlamalarından bahsederken, Python’ın 2.x sürümlerinde öntanımlı karakter kodlamasının ASCII olduğundan söz etmiştik. Bu yüzden programlarımızdaTürkçekarakterlerikullanırkenbazıilaveişlemleryapmamızgerekiyordu. Burada ilk olarak karakter kodlamasını UTF-8 olarak değiştirmemiz gerekiyor. Bunun nasıl yapılacağınıbiliyorsunuz.Programımızınilksatırınaşukoduekliyoruz: # -*- coding: utf-8 -*- Bu satır Python3 için gerekli değil. Çünkü Python3’te öntanımlı karakter kodlaması zaten UTF-8.AmaPython2’deöntanımlıkarakterkodlamasıASCII.OyüzdenPython2kullanıcılarını da düşünerek UTF-8 kodlamasını açıkça belirtiyoruz. Böylece programımızın Python’ın 2.x sürümlerindeTürkçekarakterleryüzündençökmesiniönlüyoruz. Ama burada bir problem daha var. Programımız Türkçe karakterler yüzünden çökmüyor çökmemesineama,budefadaTürkçekarakterleridüzgüngöstermiyor: Python’Ä±n 2.x sÃ…rÃ…mlerinden birini kullanÄ±yorsunuz. ProgramÄ± Ã§alÄ±ÅŸtÄ±rabilmek iÃ§in sisteminizde Python’Ä±n 3.x sÃ…rÃ…mlerinden biri kurulu olmalÄ±. Programımızı Python’ın 2.x sürümlerinden biri ile çalıştıranların uyarı mesajını düzgün bir şekilde görüntüleyebilmesini istiyorsanız, Türkçe karakterler içeren karakter dizilerinin en başınabir‘u’harfieklemelisiniz.Yani_2x_metniadlıdeğişkenişöyleyazmalısınız: _2x_metni = u""" Python’ın 2.x sürümlerinden birini kullanıyorsunuz. Programı çalıştırabilmek için sisteminizde Python’ın 3.x sürümlerinden biri kurulu olmalı.""" Bu karakter dizisinin en başına bir ‘u’ harfi ekleyerek bu karakter dizisini ‘unicode’ olarak tanımlamış olduk. Eğer ‘unicode’ kavramını bilmiyorsanız endişe etmeyin. İlerde bu kavramdan bolca söz edeceğiz. Biz şimdilik, içinde Türkçe karakterler geçen karakter dizilerinin Python2 kullanıcıları tarafından düzgün görüntülenebilmesi için başlarına bir ‘u’ harfieklenmesigerektiğinibilelimyeter. EğersizbirWindowskullanıcısıysanızvebütünbuişlemlerdensonrabileTürkçekarakterleri düzgün görüntüleyemiyorsanız, bu durum muhtemelen MS-DOS komut satırının kullandığı yazı tipinin Türkçe karakterleri gösterememesinden kaynaklanıyordur. Bu problemi çözmek için MS-DOS komut satırının başlık çubuğuna sağ tıklayıp ‘özellikler’ seçeneğini seçerek yazı tipini ‘Lucida Console’ olarak değiştirin. Bu işlemin ardından da komut satırında şu komutu verin: chcp 1254 BöyleceTürkçekarakterleridüzgüngörüntüleyebilirsiniz. (cid:242) Not MS-DOS’taki Türkçe karakter problemi hakkında daha ayrıntılı bilgi için https://web.archive.org/web/20150516030259/http://www..com/py2/ 13.8. UygulamaÖrnekleri 205 PythonBelgeleri,Yayım4.1.3 python-programlarini-kaydetmek.html#ms-dos-ta-turkce-karakter-problemi adresindeki makalemiziinceleyebilirsiniz. Şimdiye kadar anlattıklarımızdan öğrendiğiniz gibi, sys modülü içinde sürüm denetlemeye yarayanikifarklıdeğişkenvar.Bunlardanbiriversion,öbürüiseversion_info. Python3’tebudeğişkenlerinşuçıktılarıverdiğinizbiliyoruz: version: ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ version_info: sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel=’final’, serial=0) Gördüğünüzgibi,çıktılarınhemyapılarıbirbirindenfarklı,hemdeverdikleribilgilerarasında bazıfarklardavar.Meselaversiondeğişkeni,kullandığımızPythonsürümününhangitarihve saatte, hangi işletim sistemi üzerinde derlendiği bilgisini de veriyor. Ancak kullanılan Python sürümünün ne olduğunu tespit etmek konusunda version_info biraz daha pratik görünüyor. Budeğişkeninbizemajor,minorvemicrogibiparametreleraracılığıylasunduğusayıdeğerli verileri işleçlerle birlikte kullanarak bu sayılar üzerinde aritmetik işlemler yapıp, kullanılan Pythonsürümünükontroledebiliyoruz. version değişkeni bize bir karakter dizisi verdiği için, bu değişkenin değerini kullanarak herhangi bir aritmetik işlem yapamıyoruz. Mesela version_info değişkeniyle yukarıda yaptığımızbüyüktür-küçüktürsorgulamasınıversiondeğişkeniyletabiikiyapamayız. Yukarıdaki örnekte seriler arası sürüm kontrolünü nasıl yapacağımızı gördük. Bunun için kullandığımızkodşuydu: if sys.version_info.major < 3: ... Burada kullanılan Python serisinin 3.x’ten düşük olduğu durumları sorguladık. Peki aynı serininfarklısürümlerinidenetlemekistersekneyapacağız?MeselaPython’ın3.2sürümünü sorgulamakisterseknasılbirkodkullanacağız? Bununiçinşöylebirşeyyazabiliriz: if sys.version_info.major == 3 and sys.version_info.minor == 2: ... Gördüğünüzgibiburadaversion_infodeğişkenininhemmajorhemdeminorparametrelerini kullandık.Ayrıcahemanasürüm,hemdealtsürümiçinbellibirkoşultalepettiğimizdenötürü andadlıBoolişlecindendeyararlandık.Çünkükoşulungerçekleşmesi,anasürümün3vealt sürümün2olmasınabağlı. Yukarıdakiişlemiçinversiondeğişkeninidekullanabilirdik.Dikkatlicebakın: if "3.2" in sys.version: ... Bildiğinizgibi,versiondeğişkeniPython’ın3.xsürümlerindeşunabenzerbirçıktıveriyor: 206 Bölüm13. İşleçler PythonBelgeleri,Yayım4.1.3 ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ İşte biz burada in işlecini kullanarak, version değişkeninin verdiği karakter dizisi içinde ‘3.2’ diyebirifadearadık. Bu konuyu daha iyi anlamak için kendi kendinize bazı denemeler yapmanızı tavsiye ederim. Nekadarçokörnekkodyazarsanız,okadarçoktecrübekazanırsınız. 13.8. UygulamaÖrnekleri 207 14 BÖLÜM Döngüler (Loops) ŞimdiyekadaröğrendiklerimizsayesindePython’laufaktefekprogramlaryazabilecekdüzeye geldik. Mesela öğrendiğimiz bilgiler yardımıyla bir önceki bölümde çok basit bir hesap makinesiyazabilmiştik.Yalnızohesapmakinesindefarkettiysenizçokönemlibireksiklikvardı. Hesap makinemizle hesap yaptıktan sonra programımız kapanıyor, yeni hesap yapabilmek içinprogramıyenidenbaşlatmamızgerekiyordu. Hesapmakinesiprogramındakisorun,örneğin,aşağıdakiprogramiçindegeçerlidir: tuttuğum_sayı = 23 bilbakalım = int(input("Aklımdan bir sayı tuttum. Bil bakalım kaç tuttum? ")) if bilbakalım == tuttuğum_sayı: print("Tebrikler! Bildiniz...") else: print("Ne yazık ki tuttuğum sayı bu değildi...") Burada tuttuğum_sayı adlı bir değişken belirledik. Bu değişkenin değeri 23. Kullanıcıdan tuttuğumuz sayıyı tahmin etmesini istiyoruz. Eğer kullanıcının verdiği cevap tuttuğum_sayı değişkeninin değeriyle aynıysa (yani 23 ise), ekrana ‘Tebrikler!...’ yazısı dökülecektir. Aksi halde‘Neyazıkki...’cümlesiekranadökülecektir. Bu program iyi, hoş, ama çok önemli bir eksiği var. Bu programı yalnızca bir kez kullanabiliyoruz. Yani kullanıcı yalnızca bir kez tahminde bulunabiliyor. Eğer kullanıcı bir kez daha tahminde bulunmak isterse programı yeniden çalıştırması gerekecek. Bunun hiç iyi bir yöntem olmadığı ortada. Halbuki yazdığımız bir program, ilk çalışmanın ardından kapanmasa, biz bu programı tekrar tekrar çalıştırabilsek, programımız sürekli olarak başa dönse ve program ancak biz istediğimizde kapansa ne iyi olurdu değil mi? Yani mesela yukarıdaki örnekte kullanıcı bir sayı tahmin ettikten sonra, eğer bu sayı bizim tuttuğumuz sayıylaaynıdeğilse,kullanıcıyatekrartahminetmefırsatıverebilsekçokhoşolurdu... Yukarıdaaçıklamayaçalıştığımızsüreç,yanibirsürecintekrartekrardevametmesiPython’da 208 PythonBelgeleri,Yayım4.1.3 ‘döngü’(loop)olarakadlandırılır. İşte bu bölümde, programlarımızın sürekli olarak çalışmasını nasıl sağlayabileceğimizi, yani programlarımızıbirdöngüiçinenasılsokabileceğimiziöğreneceğiz. Python’daprogramlarımızıtekrartekrarçalıştırabilmekiçindöngüadıverilenbazıifadelerden yararlanacağız. Python’daikitanedöngübulunur:whilevefor Dilersenizişewhiledöngüsüilebaşlayalım. 14.1 while Döngüsü İngilizce bir kelime olan while, Türkçede ‘... iken, ... olduğu sürece’ gibi anlamlara gelir. Python’da while bir döngüdür. Bir önceki bölümde söylediğimiz gibi, döngüler sayesinde programlarımızınsürekliolarakçalışmasınısağlayabiliriz. Bu bölümde Python’da while döngüsünün ne olduğunu ve ne işe yaradığını anlamaya çalışacağız.Önceliklewhiledöngüsününtemellerinikavrayarakişebaşlayalım. Basitbirwhiledöngüsükabacaşunabenzer: a = 1 while a == 1: Buradaaadlıbirdeğişkenoluşturduk.Budeğişkenindeğeri1.Birsonrakisatırdaisewhile a == 1:gibibirifadeyazdık.Enbaştadasöylediğimizgibiwhilekelimesi,‘... iken,olduğusürece’ gibianlamlartaşıyor.Pythonprogramlamadilindekianlamıdabunaoldukçayakındır.Burada while a == 1ifadesiprogramımızaşöylebiranlamkatıyor: adeğişkeninindeğeri1olduğusürece... Gördüğünüz gibi cümlemiz henüz eksik. Yani belli ki bunun bir de devamı olacak. Ayrıca while ifadesinin sonundaki: işaretinden anladığımız gibi, bundan sonra gelecek satır girintili yazılacak.Devamedelim: a = 1 while a == 1: print("bilgisayar çıldırdı!") BuradaPython’aşuemrivermişolduk: adeğişkeninindeğeri1olduğusürece,ekrana‘bilgisayarçıldırdı!’yazısınıdök! Bu programı çalıştırdığımızda Python verdiğimiz emre sadakatle uyacak ve a değişkeninin değeri1olduğumüddetçedebilgisayarımızınekranına‘bilgisayarçıldırdı!’yazısınıdökecektir. Programımızın içinde a değişkeninin değeri 1 olduğu ve bu değişkenin değerini değiştirecek herhangi bir şey bulunmadığı için Python hiç sıkılmadan ekrana ‘bilgisayar çıldırdı!’ yazısını basmayadevamedecektir.Eğersizdurdurmazsanızbudurumsonsuzakadardevamedebilir. Bu çılgınlığa bir son vermek için klavyenizde Ctrl+C veya Ctrl+Z tuşlarına basarak programı durmayazorlayabilirsiniz. 14.1. whileDöngüsü 209 PythonBelgeleri,Yayım4.1.3 Burada programımızı sonsuz bir döngüye sokmuş olduk (infinite loop). Esasında sonsuz döngüler genellikle bir program hatasına işaret eder. Yani çoğu durumda programcının arzu ettiği şey bu değildir. O yüzden doğru yaklaşım, döngüye soktuğumuz programlarımızı durduracakbirölçütbelirlemektir.Yaniöylebirkodyazmalıyızki,adeğişkeninin1olandeğeri bir noktadan sonra artık 1 olmasın ve böylece o noktaya ulaşıldığında programımız dursun. KullanıcınınCtrl+Ctuşlarınabasarakprogramıdurdurmakzorundakalmasıpekhoşolmuyor. Gelinistersenizbusoyutifadeleribirazsomutlaştıralım. Öncelikleşusatırıyazarakişebaşlıyoruz: a = 1 Buradanormalbirşekildeadeğişkenine1değeriniatadık.Şimdidevamediyoruz: a = 1 while a < 10: whileileverdiğimizilkörnektewhile a == 1gibibirifadekullanmıştık.Buifade; a’nındeğeri1olduğumüddetçe... gibibiranlamageliyordu. while a < 10ifadesiise; a’nındeğeri10’danküçükolduğumüddetçe... anlamına gelir. İşte burada programımızın sonsuz döngüye girmesini engelleyecek bir ölçüt koymuş olduk. Buna göre, a değişkeninin şimdiki değeri 1’dir. Biz, a’nın değeri 10’dan küçük olduğumüddetçebirişlemyapacağız.Devamedelim: a = 1 while a < 10: print("bilgisayar yine çıldırdı!") Ne oldu? İstediğimizi elde edemedik, değil mi? Programımız yine sonsuz döngüye girdi. Bu sonsuzdöngüyükırmakiçinCtrl+C(veyaCtrl+Z)’yebasmamızgerekecekyine... Sizce buradaki hata nereden kaynaklandı? Yani neyi eksik yaptık da programımız sonsuz döngüye girmekten kurtulamadı? Aslında bunun cevabı çok basit. Biz yukarıdaki kodları yazarakPython’aşuemrivermişolduk: a’nındeğeri10’danküçükolduğumüddetçeekrana‘bilgisayaryineçıldırdı!’yazısını bas! a değişkeninin değeri 1. Yani 10’dan küçük. Dolayısıyla Python’ın ekrana o çıktıyı basmasını engelleyecekherhangibirşeyyok... Şimdibuprobleminasılaşacağımızıgörelim: a = 1 while a < 10: a += 1 print("bilgisayar yine çıldırdı!") 210 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 Burada a += 1 satırını ekledik kodlarımızın arasına. += işlecini anlatırken söylediğimiz gibi, bu satır, a değişkeninin değerine her defasında 1 ekliyor ve elde edilen sonucu tekrar a değişkenine atıyor. En sonunda a’nın değeri 10’a ulaşınca da, Python ekrana ‘bilgisayar yine çıldırdı!’ cümlesini yazmayı bırakıyor. Çünkü while döngüsü içinde belirttiğimiz ölçüte göre, programımızındevamedebilmesiiçinadeğişkeninindeğerinin10’danküçükolmasıgerekiyor. a’nındeğeri10’aulaştığıandabuölçütbozulacaktır.GelinistersenizbukodlarıPython’ınnasıl algıladığınabirbakalım: 1. Pythonönceliklea = 1satırınıgörüyorvea’nındeğerini1yapıyor. 2. Daha sonra a’nın değeri 10’dan küçük olduğu müddetçe... (while a < 10) satırını görüyor. 3. Ardındana’nındeğerini,1artırıyor(a += 1)vea’nındeğeri2oluyor. 4. a’nındeğeri(yani2)10’danküçükolduğuiçinPythonekranailgiliçıktıyıveriyor. 5. İlkdöngüyübitirenPythonbaşadönüyorvea’nındeğerinin2olduğunugörüyor. 6. a’nındeğeriniyine1artırıyorvea’yı3yapıyor. 7. a’nındeğerihâlâ10’danküçükolduğuiçinekranayineilgiliçıktıyıveriyor. 8. İkinci döngüyü de bitiren Python yine başa dönüyor ve a’nın değerinin 3 olduğunu görüyor. 9. Yukarıdaki adımları tekrar eden Python, a’nın değeri 9 olana kadar ilerlemeye devam ediyor. 10. a’nın değeri 9’a ulaştığında Python a’nın değerini bir kez daha artırınca bu değer 10’a ulaşıyor. 11. Pythona’nındeğerininartık10’danküçükolmadığınıgörüyorveprogramdançıkıyor. Yukarıdakikodlarışöyleyazarsakbelkidurumdahaanlaşılırolabilir: a = 1 while a < 10: a += 1 print(a) Burada Python’un arkada ne işler çevirdiğini daha net görebiliyoruz. Kodlarımız içine eklediğimiz while döngüsü sayesinde Python her defasında a değişkeninin değerini kontrol ediyor ve bu değer 10’dan küçük olduğu müddetçe a değişkeninin değerini 1 artırıp, yeni değeriekranabasıyor.Budeğişkenindeğeri10’aulaştığındaise,budeğerinartık10’danküçük olmadığınıanlayıpbütünişlemleridurduruyor. Gelinistersenizbuwhiledöngüsünüdahaönceyazdığımızhesapmakinemizeuygulayalım: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla (sonrakisayfayadevam) 14.1. whileDöngüsü 211 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) """ print(giriş) anahtar = 1 while anahtar == 1: soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ if soru == "q": print("çıkılıyor...") anahtar = 0 elif soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) print(sayı1, "+", sayı2, "=", sayı1 + sayı2) elif soru == "2": sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: ")) sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: ")) print(sayı3, "-", sayı4, "=", sayı3 - sayı4) elif soru == "3": sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: ")) sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: ")) print(sayı5, "x", sayı6, "=", sayı5 * sayı6) elif soru == "4": sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: ")) sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: ")) print(sayı7, "/", sayı8, "=", sayı7 / sayı8) elif soru == "5": sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: ")) print(sayı9, "sayısının karesi =", sayı9 ** 2) elif soru == "6": sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: ")) print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5) else: print("Yanlış giriş.") print("Aşağıdaki seçeneklerden birini giriniz:", giriş) Buradailaveolarakşusatırlarıgörüyorsunuz: anahtar = 1 (sonrakisayfayadevam) 212 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) while anahtar == 1: soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ if soru == "q": print("çıkılıyor...") anahtar = 0 Bukodlardayaptığımızşeyaslındaçokbasit.Öncelikledeğeri1olananahtaradlıbirdeğişken tanımladık. Bir alt satırda ise, programımızın sürekli olarak çalışmasını sağlayacak olan while döngümüzü yazıyoruz. Programımız, anahtar değişkeninin değeri 1 olduğu müddetçe çalışmayadevamedecek.Dahaöncededediğimizgibi,eğerbuanahtardeğişkeninindeğerini programın bir noktasında değiştirmezsek programımız sonsuza kadar çalışmaya devam edecektir. Çünkü biz programımızı anahtar değişkeninin değeri 1 olduğu sürece çalışmaya ayarladık. İşte programımızın bu tür bir sonsuz döngüye girmesini önlemek için bir if bloğuoluşturuyoruz.Bunagöre,eğerkullanıcıklavyedeqtuşunabasarsaprogramımızönce çıkılıyor... çıktısı verecek, ardından da anahtar değişkeninin 1 olan değerini 0 yapacaktır. Böyleceartıkanahtar’ındeğeri1olmayacağıiçinprogramımızçalışmayasonverecektir. Buradakimantığınnekadarbasitolduğunugörmeniziisterim.Öncebirdeğişkentanımlıyoruz, ardındanbudeğişkenindeğeriaynıkaldığımüddetçeprogramımızıçalışmayaayarlıyoruz.Bu döngüyü kırmak için de başta tanımladığımız o değişkene başka bir değer atıyoruz. Burada anahtar değişkenine atadığımız 1 ve 0 değerleri tamamen tesadüfidir. Yani siz bu değerleri istediğinizgibideğiştirebilirsiniz.Meselayukarıdakikodlarışöyledeyazabilirsiniz: anahtar = "hoyda bre!" ’ ’ ’ #anahtar ın değeri hoyda bre! olduğu müddetçe aşağıdaki bloğu #çalıştırmaya devam et. while anahtar == "hoyda bre!": soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ if soru == "q": print("çıkılıyor...") anahtar = "dur yolcu!" ’ ’ ’ ’ ’ #anahtar ın değeri artık hoyda bre! değil, dur yolcu #olduğu için döngüden çık ve böylece programı sona erdirmiş ol. Gördüğünüz gibi, amaç herhangi bir değişkene herhangi bir değer atamak ve o değer aynı kaldığı müddetçe programın çalışmaya devam etmesini sağlamak. Kurduğumuz bu döngüyü kırmakiçindeodeğişkeneherhangibaşkabirdeğeratamak... Yukarıda verdiğimiz son örnekte önce anahtar adlı bir değişken atayıp, while döngüsünün işleyişinibudeğişkenindeğerinegöreyapılandırdık.Amaaslındayukarıdakikodlarıçokdaha basitbirşekildedeyazabiliriz.Dikkatlicebakın: while True: soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ (sonrakisayfayadevam) 14.1. whileDöngüsü 213 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if soru == "q": print("çıkılıyor...") break Buyapıyıhesapmakinemizeuygulayalım: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla """ print(giriş) while True: soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ if soru == "q": print("çıkılıyor...") break elif soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) print(sayı1, "+", sayı2, "=", sayı1 + sayı2) elif soru == "2": sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: ")) sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: ")) print(sayı3, "-", sayı4, "=", sayı3 - sayı4) elif soru == "3": sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: ")) sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: ")) print(sayı5, "x", sayı6, "=", sayı5 * sayı6) elif soru == "4": sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: ")) sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: ")) print(sayı7, "/", sayı8, "=", sayı7 / sayı8) elif soru == "5": sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: ")) print(sayı9, "sayısının karesi =", sayı9 ** 2) (sonrakisayfayadevam) 214 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) elif soru == "6": sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: ")) print(sayı10, "sayısının karekökü = ", sayı10 ** 0.5) else: print("Yanlış giriş.") print("Aşağıdaki seçeneklerden birini giriniz:", giriş) Bu yapı sayesinde anahtar gibi bir değişken atama zorunluluğundan kurtulmuş olduk. Yukarıdakikodlarınnasılçalıştığınıaçıklayalım: whileTrueifadesişöylebiranlamagelir: Trueolduğumüddetçe... Peki ne True olduğu müddetçe? Burada neyin True olması gerektiğini belirtmediğimiz için, aslındabukodparçasışuanlamageliyor: Aksibelirtilmediğisüreceçalışmayadevamet! Eğeryukarıdakiaçıklamayıbirazbulanıkbulduysanızşuörneğiinceleyebilirsiniz: while True: print("Bilgisayar çıldırdı!") Bu kodları çalıştırdığınızda ekrana sürekli olarak Bilgisayar çıldırdı! çıktısı verilecektir. Bu döngüden çıkabilmek için Ctrl+C tuşlarına basmanız gerekiyor. Yukarıdaki kodların sonsuz döngüyegirmesininsorumlusuwhileTruesatırıdır.ÇünküburadabizPython’a; Aksibelirtilmediğisüreceçalışmayadevamet! emri veriyoruz. Python da bu emrimizi sadakatle yerine getiriyor. Böyle bir durumda sonsuzdöngüyüengellemekiçinprogramımızınbiryerindePython’abudöngüdençıkmasını sağlayacak bir emir vermemiz gerekiyor. Biz hesap makinesi programımızda bu döngüyü şu şekildekırdık: if soru == "q": print("çıkılıyor...") break Dikkat ederseniz burada break adlı yeni bir araç görüyoruz. Bu aracın tam olarak ne işe yaradığını ilerleyen sayfalarda inceleyeceğiz. Şimdilik yalnızca şunu bilelim: break kelimesi İngilizce’de ‘kırmak, koparmak, bozmak’ gibi anlamlara gelir. Bu aracın yukarıdaki görevi döngüyü‘kırmak’tır.Dolayısıylakullanıcıklavyedeqtuşunabastığında,while Trueifadesiile çalışmayabaşlayandöngükırılacakveprogramımızsonaerecektir. Buyapıyıdahaiyianlayabilmekiçinşöylebasitbirörnekdahaverelim: #Aksi belirtilmediği sürece kullanıcıya #aşağıdaki soruyu sormaya devam et! while True: soru = input("Nasılsınız, iyi misiniz?") (sonrakisayfayadevam) 14.1. whileDöngüsü 215 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’ ’ #Eğer kullanıcı q tuşuna basarsa... if soru == "q": break #döngüyü kır ve programdan çık. Görüyorsunuz,aslındamantıkgayetbasit: Bir döngü oluştur ve bu döngüden çıkmak istediğinde, programın bir yerinde bu döngüyüsonaerdirecekbirkoşulmeydangetir. Bumantığıyukarıdakiörneğeşuşekildeuyguladık: while True: ifadesi yardımıyla bir döngü oluştur ve kullanıcı bu döngüden çıkmak istediğinde(yaniqtuşunabastığında),döngüyükırveprogramısonaerdir. Gelinistersenizbukonuyudahanetkavramakiçinbirörnekdahaverelim: tekrar = 1 while tekrar <= 3: tekrar += 1 input("Nasılsınız, iyi misiniz?") Buradaprogramımızkullanıcıyaüçkez‘Nasılsınız,iyimisiniz?’sorusunusoracakveardından kapanacaktır. Bu kodlarda while döngüsünü nasıl kullandığımıza dikkat edin. Aslında programınmantığıçokbasit: 1. Öncelikledeğeri1olantekraradlıbirdeğişkentanımlıyoruz. 2. Bu değişkenin değeri 3’e eşit veya 3’ten küçük olduğu müddetçe (while tekrar <= 3) değişkenindeğerine1ekliyoruz(tekrar += 1). 3. Başkabirdeyişlebool(tekrar <= 3)ifadesiTrueolduğumüddetçedeğişkenindeğerine 1ekliyoruz. 4. tekrar değişkenine her 1 ekleyişimizde kullanıcıya ‘Nasılsınız, iyi misiniz?’ sorusunu soruyoruz(input("Nasılsınız, iyi misiniz?")). 5. tekrar değişkeninin değeri 3’ü aştığında bool(tekrar <= 3) ifadesi artık False değeri verdiğiiçinprogramımızsonaeriyor. Yukarıdaki uygulamada Python’ın alttan alta neler çevirdiğini daha iyi görmek için bu uygulamayışöyleyazmayıdeneyin: tekrar = 1 while tekrar <= 3: print("tekrar: ", tekrar) tekrar += 1 input("Nasılsınız, iyi misiniz?") print("bool değeri: ", bool(tekrar <= 3)) Daha önce de dediğimiz gibi, bir Python programının nasıl çalıştığını anlamanın en iyi yolu, program içinde uygun yerlere print() fonksiyonları yerleştirerek arka planda hangi kodlarınhangiçıktılarıverdiğiniizlemektir.İşteyukarıdadabuyöntemikullandık.Yanitekrar değişkenininin değerini ve bool(tekrar <= 3) ifadesinin çıktısını ekrana yazdırarak arka taraftanelerolupbittiğinicanlıcanlıgörmeimkanınakavuştuk. 216 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 Yukarıdakiprogramıçalıştırdığımızdaşunabenzerçıktılargörüyoruz: tekrar: 1 Nasılsınız, iyi misiniz? evet bool değeri: True tekrar: 2 Nasılsınız, iyi misiniz? evet bool değeri: True tekrar: 3 Nasılsınız, iyi misiniz? evet bool değeri: False Gördüğünüz gibi, tekrar değişkeninin değeri her döngüde 1 artıyor. tekrar <= 3 ifadesinin bool değeri, tekrar adlı değişkenin değeri 3’ü aşana kadar hep True olacaktır. Bu değişkenin değeri 3’ü aştığı anda tekrar <= 3 ifadesinin bool değeri False’a dönüyor ve böylece while döngüsüsonaeriyor. Peki size şöyle bir soru sorsam: Acaba while döngüsünü kullanarak 1’den 100’e kadar olan aralıktakiçiftsayılarınasılbulursunuz? Çokbasit: a = 0 while a < 100: a += 1 if a % 2 == 0: print(a) Gördüğünüzgibi,whiledöngüsününiçinebiradetifbloğuyerleştirdik. YukarıdakikodlarışuşekildeTürkçeyeçevirebiliriz: a değişkeninin değeri 100’den küçük olduğu müddetçe a değişkeninin değerini 1 artır. Bu değişkenin değerini her artırışında yeni değerin 2’ye tam bölünüp bölünmediğini kontrol et. Eğer a modülüs 2 değeri 0 ise (if a % 2 == 0), yani a’nındeğeribirçiftsayıise,budeğeriekranayazdır. Gördüğünüz gibi, while döngüsü son derece kullanışlı bir araçtır. Üstelik kullanımı da son derece kolaydır. Bu döngüyle bol bol pratik yaparak bu döngüyü rahatça kullanabilecek durumagelebilirsiniz. Enbaştadasöylediğimizgibi,Python’dawhiledışındabirdefordöngüsüvardır.Enazwhile kadarönemlibirdöngüolanfordöngüsününnasılkullanıldığınıanlamayaçalışalımşimdide. 14.1. whileDöngüsü 217 PythonBelgeleri,Yayım4.1.3 14.2 for Döngüsü Etrafta yazılmış Python programlarının kaynak kodlarını incelediğinizde, içinde for döngüsü geçmeyen bir program kolay kolay bulamazsınız. Belki while döngüsünün kullanılmadığı programlar vardır. Ancak for döngüsü Python’da o kadar yaygındır ve o kadar geniş bir kullanım alanına sahiptir ki, hemen hemen bütün Python programları bu for döngüsünden enazbirkezyararlanır. Pekinedirbufordöngüsüdenenşey? for da tıpkı while gibi bir döngüdür. Yani tıpkı while döngüsünde olduğu gibi, programlarımızınbirdenfazlasayıdaçalışmasınısağlar.Ancakfordöngüsüwhiledöngüsüne göre biraz daha yeteneklidir. while döngüsü ile yapamayacağınız veya yaparken çok zorlanacağınızşeylerifordöngüsüyardımıylaçokkolaybirşekildehalledebilirsiniz. Yalnız, söylediğimiz bu cümleden, for döngüsünün while döngüsüne bir alternatif olduğu sonucunu çıkarmayın. Evet, while ile yapabildiğiniz bir işlemi for ile de yapabilirsiniz çoğu zaman, ama bu döngülerin, belli vakalar için tek seçenek olduğu durumlar da vardır. Zira bu ikidöngününçalışmamantığıbirbirindenfarklıdır. Şimdigelelimfordöngüsününnasılkullanılacağına... Dikkatlicebakın: tr_harfler = "şçöğüİı" for harf in tr_harfler: print(harf) Burada öncelikle tr_harfler adlı bir değişken tanımladık. Bu değişken Türkçeye özgü harfleri tutuyor.Dahasonrabirfordöngüsükurarak,tr_harfleradlıdeğişkeninherbiröğesinitektek ekranayazdırdık. Pekibufordöngüsününasılkurduk? fordöngülerininsözdizimişöyledir: for değişken_adı in değişken: yapılacak_işlem BusözdiziminiTürkçeolarakşöyleifadeedebiliriz: değişken içindeki her bir öğeyi değişken_adı olarak adlandır: ve bu öğelerle bir işlem yap. Busoyutyapılarıkendiörneğimizeuygulayarakdurumudahanetanlamayaçalışalım: tr_harfler adlı değişken içindeki her bir öğeyi harf olarak adlandır: ve harf olarak adlandırılan bu öğeleri ekrana yazdır. Yukarıdaki örnekte bir for döngüsü yardımıyla tr_harfler adlı değişken içindeki her bir öğeyi ekrana yazdırdık. Esasında for döngüsünün yeteneklerini düşündüğümüzde bu örnek pek heyecanvericideğil.Ziraaynıişiaslındaprint()fonksiyonuiledeyapabilirdik: 218 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 tr_harfler = "şçöğüİı" print(*tr_harfler, sep="\n") Aslındabuişlemiwhileiledeyapmakmümkün(Bukodlardaki,henüzöğrenmediğimizkısmı şimdilikgörmezdengelin): tr_harfler = "şçöğüİı" a = 0 while a < len(tr_harfler): print(tr_harfler[a], sep="\n") a += 1 while döngüsü kullanıldığında işi uzattığımızı görüyorsunuz. Dediğimiz gibi, for döngüsü while döngüsüne göre biraz daha yeteneklidir ve while ile yapması daha zor (veya uzun) olan işlemleri for döngüsü ile çok daha kolay bir şekilde yapabiliriz. Ayrıca for döngüsü ile while döngüsünün çalışma mantıkları birbirinden farklıdır. for döngüsü, üzerinde döngü kurulabilecek veri tiplerinin her bir öğesinin üzerinden tek tek geçer ve bu öğelerin her biri üzerindebirişlemyapar.whiledöngüsüiseherhangibirifadeninbooldeğerinikontroleder vebudeğerinbooldeğeriFalseolanakadar,belirlenenişlemiyapmayısürdürür. Bu arada, biraz önce ‘üzerinde döngü kurulabilecek veri tipleri’ diye bir kavramdan söz ettik. Örneğin karakter dizileri, üzerinde döngü kurulabilecek bir veri tipidir. Ama sayılar öyle değildir.Yanisayılarüzerindedöngükuramayız.Mesela: >>> sayılar = 123456789 >>> for sayı in sayılar: ... print(sayı) ... Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’int’ object is not iterable Buradaki hata mesajından da göreceğiniz gibi int (tam sayı) türündeki nesneler üzerinde döngü kuramıyoruz. Hata mesajında görünen not iterable (üzerinde döngü kurulamaz) ifadesiylekastedilendebudur. Gelinistersenizfordöngüsüilebirörnekdahavererekdurumuiyiceanlamayaçalışalım: sayılar = "123456789" for sayı in sayılar: print(int(sayı) * 2) Burada sayılar adlı değişkenin her bir öğesini sayı olarak adlandırdıktan sonra, int() fonksiyonuyardımıylabuöğeleritekteksayıyaçevirdikveherbiröğeyi2ileçarptık. fordöngüsününmantığınıazçokanlamışolmalısınız.Budöngübirdeğişkeniçindekiherbir öğeyitektekelealıp,ikinoktaüstüsteişaretindensonrayazdığımızkodbloğunubuöğelere tektekuyguluyor. for kelimesi İngilizcede ‘için’ anlamına gelir. Döngünün yapısı içinde geçen in ifadesini de tanıyorsunuz. Biz bu ifadeyi ‘Aitlik İşleçleri’ konusunu işlerken de görmüştük. Hatırlarsanız inişlecibiröğeninbirveritipiiçindebulunupbulunmadığınısorguluyordu.Mesela: 14.2. forDöngüsü 219 PythonBelgeleri,Yayım4.1.3 >>> a = ".com" >>> "h" in a True “h”öğesi“.com”adlıkarakterdizisiiçindegeçtiğiiçin"h" in akoduTrueçıktısıveriyor. Birdeşunabakın: >>> "b" in a False “b” öğesi “.com” karakter dizisi içinde bulunmuyor. Dolayısıyla "b" in a sorgulaması Falseçıktısıveriyor. in kelimesi İngilizcede ‘içinde’ anlamına geliyor. Dolayısıyla for falanca in filanca: yazdığımızdaaslındaşöylebirşeydemişoluyoruz: filancaiçindefalancaadınıverdiğimizherbiröğeiçin... Yanişukod: for s in "": print(s) Şuanlamageliyor: “”karakterdizisiiçindesadınıverdiğimizherbiröğeiçin: söğesiniekranabasmaişlemigerçekleştir! Yadaşukod: sayılar = "123456789" for i in sayılar: if int(i) > 3: print(i) Şuanlamageliyor: sayılardeğişkeniiçindeiadınıverdiğimizherbiröğeiçin: eğersayıyadönüştürülmüşideğeri3’tenbüyükse: iöğesiniekranabasmaişlemigerçekleştir! Yukarıdaki temsili kodların Türkçesi bozuk olsa da for döngüsünün çalışma mantığını anlamaya yardımcı olacağını zannediyorum. Ama yine de, eğer bu döngünün mantığını henüz kavrayamadıysanız hiç endişe etmeyin. Zira bu döngüyü oldukça sık bir biçimde kullanacağımıziçin,sizistemesenizdebudöngükafanızdayeretmişolacak. Bufordöngüsünübirazdahaiyianlayabilmekiçinsonbirörnekyapalım: tr_harfler = "şçöğüİı" parola = input("Parolanız: ") (sonrakisayfayadevam) 220 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for karakter in parola: if karakter in tr_harfler: print("parolada Türkçe karakter kullanılamaz") Bu program, kullanıcıya bir parola soruyor. Eğer kullanıcının girdiği parola içinde Türkçe karakterlerden herhangi biri varsa kullanıcıyı Türkçe karakter kullanmaması konusunda uyarıyor. Buradaki for döngüsünü nasıl kurduğumuzu görüyorsunuz. Aslında burada şu TürkçecümleyiPythonca’yaçevirmişolduk: paroladeğişkeniiçindekarakteradınıverdiğimizherbiröğeiçin: eğerkarakterdeğişkenitr_harfleradlıdeğişkeniçindegeçiyorsa: ‘paroladaTürkçekarakterkullanılamaz’uyarısınıgöster! Buradakullandığımızfordöngüsüsayesindekullanıcınıngirdiğiparolaadlıdeğişkeniçindeki bütünkarakterleretektekbakıp,eğerbakılankaraktertr_harfleradlıdeğişkeniçindegeçiyorsa kullanıcıyıuyarıyoruz. Aslında for döngüsüyle ilgili söyleyeceklerimiz bu kadar değil. Ama henüz bu döngüyle kullanılan önemli araçları tanımıyoruz. Gerçi zaten bu döngüyü bundan sonra sık sık kullandığımızıgöreceksiniz. Gelinistersenizyenibirkonuyageçmedenöncedöngülerleilgiliufakbirörnekverelim: Örneğin kullanıcıya bir parola belirletirken, belirlenecek parolanın 8 karakterden uzun, 3 karakterdenkısaolmamasınısağlayalım: while True: parola = input("Bir parola belirleyin: ") if not parola: print("parola bölümü boş geçilemez!") elif len(parola) > 8 or len(parola) < 3: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") else: print("Yeni parolanız", parola) break Burada öncelikle, programınızın sürekli olarak çalışmasını sağlamak için bir while döngüsü oluşturduk. Buna göre, aksi belirtilmedikçe (while True) programımız çalışmaya devam edecek. while döngüsünü kurduktan sonra kullanıcıya bir parola soruyoruz (parola = input("Bir parola belirleyin: ")) Eğer kullanıcı herhangi bir parola belirlemeden doğrudan Enter tuşuna basarsa, yani parola değişkeninin bool değeri False olursa (if not parola), kullanıcıya ‘parola bölümü boş geçilemez!’uyarısıveriyoruz. Eğer kullanıcı tarafından belirlenen parolanın uzunluğu 8 karakterden fazlaysa ya da 3 karakterden kısaysa, ‘parola 8 karakterden uzun 3 karakterden kısa olmamalı’ uyarısı veriyoruz. 14.2. forDöngüsü 221 PythonBelgeleri,Yayım4.1.3 Yukarıdakikoşullarharicidurumlariçinise(else),belirlenenyeniparolayıkullanıcıyagösterip döngüdençıkıyoruz(break). Buarada,hatırlarsanızeval()fonksiyonunuanlatırkenşöylebirörnekvermiştik: print(""" Basit bir hesap makinesi uygulaması. İşleçler: + toplama - çıkarma * çarpma / bölme Yapmak istediğiniz işlemi yazıp ENTER tuşuna basın. (Örneğin 23 ve 46 sayılarını çarpmak için 23 * 46 yazdıktan sonra ENTER tuşuna basın.) """) veri = input("İşleminiz: ") hesap = eval(veri) print(hesap) Bu programdaki eksiklikleri ve riskleri biliyorsunuz. Böyle bir program yazdığınızda, eval() fonksiyonunukontrolsüzbirşekildekullandığınıziçinönemlibirgüvenlikaçığınasebepolmuş oluyorsunuz.Gelinistersenizbudersteöğrendiğimizbilgileridekullanarakyukarıdakieval() fonksiyonuiçinbasitbirkontrolmekanizmasıkuralım: izinli_karakterler = "0123456789+-/*= " print(""" Basit bir hesap makinesi uygulaması. İşleçler: + toplama - çıkarma * çarpma / bölme Yapmak istediğiniz işlemi yazıp ENTER tuşuna basın. (Örneğin 23 ve 46 sayılarını çarpmak için 23 * 46 yazdıktan sonra ENTER tuşuna basın.) """) while True: veri = input("İşleminiz: ") (sonrakisayfayadevam) 222 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if veri == "q": print("çıkılıyor...") break for s in veri: if s not in izinli_karakterler: print("Neyin peşindesin?!") quit() hesap = eval(veri) print(hesap) Burada öncelikle programımızı bir while döngüsü içine aldık. Böylece programımızın ne zamansonaereceğinikendimizbelirleyebileceğiz.Bunagöreeğerkullanıcıklavyede‘q’tuşuna basarsawhiledöngüsüsonaerecek. Buprogramdabiziözellikleilgilendirenkısımşu: izinli_karakterler = "0123456789+-/*= " for s in veri: if s not in izinli_karakterler: print("Neyin peşindesin?!") quit() hesap = eval(veri) Gördüğünüz gibi, ilk olarak izinli_karakterler adlı bir değişken tanımladık. Program içinde kullanılmasına izin verdiğimiz karakterleri bu değişken içine yazıyoruz. Buna göre kullanıcı yalnızca0,1,2,3,4,5,6,7,8ve9sayılarını,+,-,/,*ve=işleçlerini,ayrıcaboşlukkarakterini (’‘)kullanabilecek. Kullanıcının girdiği veri üzerinde bir for döngüsü kurarak, veri içindeki her bir karakterin izinli_karakterler değişkeni içinde yer alıp almadığını denetliyoruz. İzin verilen karakterler dışında herhangi bir karakterin girilmesi Neyin peşindesin?! çıktısının verilip programdan tamamençıkılmasına(quit())yolaçacaktır. Eğer kullanıcı izinli karakterleri kullanarak bir işlem gerçekleştirmişse hesap = eval(veri) koduaracılığıyla,kullanıcınınyaptığıişlemieval()fonksiyonunagönderiyoruz. Böylece eval() fonksiyonunu daha güvenli bir hale getirebilmek için basit bir kontrol mekanizmasının nasıl kurulabileceğini görmüş olduk. Kurduğumuz kontrol mekanizmasının esası, kullanıcının girebileceği veri türlerini sınırlamaya dayanıyor. Böylece kullanıcı mesela şöyletehlikelibirkomutgiremiyor: __import__("os").system("dir") Çünkü bu komutu yazabilmesi için gereken karakterler izinli_karakterler değişkeni içinde tanımlı değil. Kullanıcı yalnızca basit bir hesap makinesinde kullanılabilecek olan sayıları ve işleçlerigirebiliyor. 14.2. forDöngüsü 223 PythonBelgeleri,Yayım4.1.3 14.3 İlgili Araçlar Elbette döngüler tek başlarına bir şey ifade etmezler. Döngülerle işe yarar kodlar yazabilmemiz için bazı araçlara ihtiyacımız var. İşte bu bölümde döngüleri daha verimli kullanmamızısağlayacakbazıfonksiyonvedeyimlerdensözedeceğiz.İlkolarakrange()adlı birfonksiyondanbahsedelim. 14.3.1 range Fonksiyonu rangekelimesiİngilizcede‘aralık’anlamınagelir.BizPython’darange()fonksiyonunubellibir aralıktabulunansayılarıgöstermekiçinkullanıyoruz.Örneğin: >>> for i in range(0, 10): ... print(i) ... 0 1 2 3 4 5 6 7 8 9 Gördüğünüzgibi,range(0, 10)kodusayesindevefordöngüsünüdekullanarak,0ile10(10 hariç)aralığındakisayılarıekranayazdırdık. Yukarıdaki kodda range() fonksiyonuna 0 ve 10 olmak üzere iki adet parametre verdiğimizi görüyorsunuz.Burada0sayısı,aralıktakiilksayıyı,10sayısıisearalıktakisonsayıyıgösteriyor. Yanirange()fonksiyonununformülüşöyledir: range(ilk_sayı, son_sayı) Bu arada, range(ilk_sayı, son_sayı) kodunun verdiği çıktıya ilk_sayının dahil olduğuna, amason_sayınındahilolmadığınadikkatedin. Eğer range() fonksiyonunun ilk parametresi 0 olacaksa, bu parametreyi belirtmesek de olur. Yani mesela 0’dan 10’a kadar olan sayıları listeleyeceksek range() fonksiyonunu şöyle yazmamızyeterliolacaktır: >>> for i in range(10): ... print(i) range() fonksiyonunun ilk_sayı parametresi verilmediğinde Python ilk parametreyi 0 olarak alır. Yani range(10) gibi bir kodu Python range(0, 10) olarak algılar. Elbette, eğer aralıktaki ilksayı0’danfarklıolacaksabusayıyıaçıkaçıkbelirtmekgerekir: >>> for i in range(3, 20): ... print(i) 224 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 Burada3’tenitibaren20’yekadarolansayılarekranadökülecektir. Hatırlarsanız, biraz önce, kullanıcının 3 karakterden kısa, 8 karakterden uzun parola belirlemesini engelleyen bir uygulama yazmıştık. O uygulamayı range() fonksiyonunu kullanarakdayazabiliriz: while True: parola = input("parola belirleyin: ") if not parola: print("parola bölümü boş geçilemez!") elif len(parola) in range(3, 9): #eğer parolanın uzunluğu 3 ile 8 karakter #aralığında ise... print("Yeni parolanız", parola) break else: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") Bu fonksiyonu kullanarak bir döngünün kaç kez çalışacağını da belirleyebilirsiniz. Aşağıdaki kodlarıdikkatliceinceleyin: for i in range(3): parola = input("parola belirleyin: ") if not parola: print("parola bölümü boş geçilemez!") elif len(parola) in range(3, 8): print("Yeni parolanız", parola) break elif i == 2: print("parolayı 3 kez yanlış girdiniz.", "Lütfen 30 dakika sonra tekrar deneyin!") else: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") Buradaif i == 2kodusayesindefordöngüsüiçindebelirttiğimiziadlıdeğişkenindeğeri2 olduğuanda‘parolayı3kezyanlışgirdiniz...’uyarısıgösterilecektir.Dahaöncedebirkaçyerde ifade ettiğimiz gibi, eğer yukarıdaki kodların çalışma mantığını anlamakta zorlanıyorsanız, programın uygun yerlerine print() fonksiyonu yerleştirerek arka planda Python’ın neler çevirdiğinidahanetgörebilirsiniz.Örneğin: for i in range(3): print(i) parola = input("parola belirleyin: ") if not parola: print("parola bölümü boş geçilemez!") elif len(parola) in range(3, 8): (sonrakisayfayadevam) 14.3. İlgiliAraçlar 225 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Yeni parolanız", parola) break elif i == 2: print("parolayı 3 kez yanlış girdiniz.", "Lütfen 30 dakika sonra tekrar deneyin!") else: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") Gördüğünüzgibi,ideğişkenininbaşlangıçtakideğeri0.Budeğerherdöngüde1artıyorvebu değişkenindeğeri2olduğuandaif i == 2bloğudevreyegiriyor. range()fonksiyonununyetenekleriyukarıdaanlattıklarımızlasınırlıdeğildir.Bufonksiyonun bazı başka maharetleri de bulunur. Hatırlarsanız yukarıda bu fonksiyonun formülünü şöyle vermiştik: range(ilk_sayı, son_sayı) Buna göre range() fonksiyonu iki parametre alıyor. Ama aslında bu fonksiyonun üçüncü bir parametresidahavardır.Bunagöreformülümüzügüncelleyelim: range(ilk_sayı, son_sayı, atlama_değeri) Formüldeki son parametre olan atlama_değeri, aralıktaki sayıların kaçar kaçar ilerleyeceğini gösterir.Yani: >>> for i in range(0, 10, 2): ... print(i) ... 0 2 4 6 8 Gördüğünüz gibi, son parametre olarak verdiğimiz 2 sayısı sayesinde 0’dan 10’a kadar olan sayılarikişerikişeratlayarakekranadökülüyor. Buarada,birşeydikkatiniziçekmişolmalı: range() fonksiyonu üç farklı parametre alan bir fonksiyon. Eğer ilk parametre 0 olacaksa bu parametreyibelirtmekzorundaolmadığımızıbiliyoruz.Yani: >>> range(10) Python bu kodu range(0, 10) olarak algılayıp buna göre değerlendiriyor. Ancak eğer range() fonksiyonunda üçüncü parametreyi de kullanacaksak, yani range(0, 10, 2) gibi bir komut vereceksek, üç parametrenin tamamını da belirtmemiz gerekiyor. Eğer burada bütün parametreleri belirtmezsek Python hangi sayının hangi parametreye karşılık geldiğini anlayamaz. Yani mesela 0’dan 10’a kadar olan sayıları ikişer ikişer atlayarak ekrana dökmek içinşöylebirşeyyazmayaçalıştığımızıdüşünün: 226 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 >>> for i in range(10, 2): ... print(i) BuradaPythonneyapmayaçalıştığınızıanlayamaz.Paranteziçindeilkdeğerolarak10,ikinci değer olarak ise 2 yazdığınız için, Python bu 10 sayısını başlangıç değeri; 2 sayısını ise bitiş değeri olarak algılayacaktır. Dolayısıyla da Python bu durumda sizin 10’dan 2’ye kadar olan sayıları listelemek istediğinizi zannedecek, range() fonksiyonuyla bu şekilde geriye doğru sayamayacağımız için de boş bir çıktı verecektir. Bu yüzden, Python’un şaşırmaması için yukarıdakiörneğişuşekildeyazmalıyız: >>> for i in range(0, 10, 2): ... print(i) Kısacası,eğerrange()fonksiyonununkaçarkaçarsayacağınıdabelirtmekistiyorsak,parantez içinde,gereklibütünparametreleribelirtmeliyiz. Gördüğünüz gibi, range() fonksiyonunu kullanarak belirli bir aralıktaki sayıları alabiliyoruz. Pekibusayılarıterstenalabilirmiyiz?Elbette: >>> for i in range(10, 0, -1): ... print(i) ... 10 9 8 7 6 5 4 3 2 1 Burada range() fonksiyonunu nasıl yazdığımıza çok dikkat edin. Sayıları tersten alacağımız için,ilkparametre10,ikinciparametreise0.Üçüncüparametreolarakiseeksideğerlibirsayı veriyoruz.Eğersayılarıhemtersten,hemdemesela3’er3’eratlayarakyazmakistersenizşöyle birkomutverebilirsiniz: >>> for i in range(10, 0, -3): ... print(i) ... 10 7 4 1 Bu arada, etkileşimli kabukta range(10) gibi bir komut verdiğinizde range(0, 10) çıktısı aldığınızı görüyorsunuz. Bu çıktı, verdiğimiz komutun 0 ile 10 arası sayıları elde etmemizi sağlayacağını belirtiyor, ama bu sayıları o anda bize göstermiyor. Daha önce verdiğimiz örneklerden de anlaşılacağı gibi, 0-10 aralığındaki sayıları görebilmek için range(10) ifadesi üzerinde bir for döngüsü kurmamız gerekiyor. range(10) ifadesinin taşıdığı sayıları görebilmek için for döngüsü kurmak tek seçenek değildir. Bu işlem için yıldızlı 14.3. İlgiliAraçlar 227 PythonBelgeleri,Yayım4.1.3 parametrelerden de yararlanabiliriz. print() fonksiyonunu incelediğimiz derste yıldızlı parametrelerinnasılkullanıldığınıgöstermiştik.Dilersenizşimdibuparametretipinirange() fonksiyonunanasıluygulayabileceğimizigörelim: >>> print(*range(10)) 0 1 2 3 4 5 6 7 8 9 print() fonksiyonunun sep parametresi yardımıyla bu çıktıyı istediğiniz gibi düzenleyebileceğinizi biliyorsunuz. Mesela çıktıdaki sayıları birbirlerinden virgülle ayırmak içinşöylebirkomutverebiliyoruz: >>> print(*range(10), sep=", ") 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Böylece range() fonksiyonunu enine boyuna incelemiş ve bu fonksiyonun ne işe yaradığını, nasıl kullanılacağını anlamamızı sağlayan örnekler vermiş olduk. Artık başka bir konuyu geçebiliriz. 14.3.2 pass Deyimi pass kelimesi İngilizcede ‘geçmek, pas geçmek’ gibi anlamlara gelir. Python’daki kullanımı da bu anlama oldukça yakındır. Biz bu deyimi Pyhon’da ‘görmezden gel, hiçbir şey yapma’ anlamındakullanacağız. Dilersenizpassdeyiminitarifetmeyeçalışmakyerinebudeyimibirörneküzerindeaçıklamaya çalışalım. Hatırlarsanızyukarıdaşöylebirörnekvermiştik: while True: parola = input("parola belirleyin: ") if not parola: print("parola bölümü boş geçilemez!") elif len(parola) in range(3, 8): #eğer parolanın uzunluğu 3 ile 8 karakter #aralığında ise... print("Yeni parolanız", parola) break else: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") Burada mesela eğer kullanıcı parolayı boş bırakırsa ‘parola bölümü boş geçilemez!’ uyarısı gösteriyoruz.Şimdioifbloğunuşöyleyazdığımızıdüşünün: while True: parola = input("parola belirleyin: ") if not parola: (sonrakisayfayadevam) 228 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pass elif len(parola) in range(3, 8): #eğer parolanın uzunluğu 3 ile 8 karakter #aralığında ise... print("Yeni parolanız", parola) break else: print("parola 8 karakterden uzun 3 karakterden kısa olmamalı") Burada,eğerkullanıcıparolayıboşbırakırsaprogramımızhiçbirşeyyapmadanyolunadevam edecektir.Yaniburadapassdeyimiyardımıylaprogramımızaşuemrivermişoluyoruz: Eğer kullanıcı parolayı boş geçerse görmezden gel. Hiçbir şey yapmadan yoluna devamet! Başkabirörnekdahaverelim: while True: sayı = int(input("Bir sayı girin: ")) if sayı == 0: break elif sayı < 0: pass else: print(sayı) Burada eğer kullanıcı 0 sayısını girerse programımız sona erer (break deyimini biraz sonra inceleyeceğiz). Eğer kullanıcı 0’dan küçük bir sayı girerse, yani kullanıcının girdiği sayı eksi değerli ise, pass deyimininin etkisiyle programımız hiçbir şey yapmadan yoluna devam eder. Bu koşulların dışındaki durumlarda ise programımız kullanıcının girdiği sayıları ekrana yazdıracaktır. Yukarıda anlatılan durumların dışında, pass deyimini kodlarınız henüz taslak aşamasında olduğu zaman da kullanabilirsiniz. Örneğin, diyelim ki bir kod yazıyorsunuz. Programın gidişatına göre, bir noktada yapmanız gereken bir işlem var, ama henüz ne yapacağınıza karar vermediniz. Böyle bir durumda pass deyiminden yararlanabilirsiniz. Mesela birtakım ifdeyimleriyazmayıdüşünüyorolun: if .....: böyle yap elif .....: şöyle yap else: pass Buradahenüzelsebloğundaneyapılacağınakararvermemişolduğunuziçin,orayabirpass 14.3. İlgiliAraçlar 229 PythonBelgeleri,Yayım4.1.3 koyarakdurumuşimdilikgeçiştiriyorsunuz.Programsonhalinegelenekadarorayabirşeyler yazmışolacaksınız. Sözün özü, pass deyimlerini, herhangi bir işlem yapılmasının gerekli olmadığı durumlar için kullanıyoruz. İlerde işe yarar programlar yazdığınızda, bu pass deyiminin göründüğünden dahafaydalıbiraraçolduğunuanlayacaksınız. 14.3.3 break Deyimi Python’da break özel bir deyimdir. Bu deyim yardımıyla, devam eden bir süreci kesintiye uğratabiliriz.Budeyiminkullanıldığıbasitbirörnekverelim: >>> while True: ... parola = input("Lütfen bir parola belirleyiniz:") ... if len(parola) < 5: ... print("Parola 5 karakterden az olmamalı!") ... else: ... print("Parolanız belirlendi!") ... break Burada,eğerkullanıcınıngirdiğiparolanınuzunluğu5karakterdenazsa,Parola5karakterden azolmamalı!uyarısıgösterilecektir.Eğerkullanıcı5karakterdenuzunbirparolabelirlemişse, kendisine ‘Parolanız belirlendi!’ mesajını gösterip, break deyimi yardımıyla programdan çıkıyoruz. Gördüğünüz gibi, break ifadesinin temel görevi bir döngüyü sona erdirmek. Buradan anlayacağımız gibi, break ifadesinin her zaman bir döngü içinde yer alması gerekiyor. Aksi haldePythonbizeşöylebirhataverecektir: SyntaxError: ’break’ outside loop Yani: SözDizimiHatası: ‘‘break‘‘ döngü dışında .. 14.3.4 continue Deyimi continueilginçbirdeyimdir.İstersenizcontinuedeyiminianlatmayaçalışmakyerinebununla ilgilibirörnekverelim: while True: s = input("Bir sayı girin: ") if s == "iptal": break if len(s) <= 3: continue print("En fazla üç haneli bir sayı girebilirsiniz.") Buradaeğerkullanıcıklavyedeiptalyazarsaprogramdançıkılacaktır.Bunu; 230 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 if s == "iptal": break satırıylasağlamayıbaşardık. Eğer kullanıcı tarafından girilen sayı üç haneli veya daha az haneli bir sayı ise, continue ifadesininetkisiyle: >>> print("En fazla üç haneli bir sayı girebilirsiniz.") satırıesgeçilecekvedöngününenbaşınagidilecektir. Eğerkullanıcınıngirdiğisayıdakihaneüçtenfazlaysaekrana: En fazla üç haneli bir sayı girebilirsiniz. cümlesiyazdırılacaktır. Dolayısıyla buradan anladığımıza göre, continue deyiminin görevi kendisinden sonra gelen her şeyin es geçilip döngünün başına dönülmesini sağlamaktır. Bu bilgiye göre, yukarıdaki programda eğer kullanıcı, uzunluğu üç karakterden az bir sayı girerse continue deyiminin etkisiyle programımız döngünün en başına geri gidiyor. Ama eğer kullanıcı, uzunluğu üç karakterdenfazlabirsayıgirerse,ekrana‘Enfazlaüçhanelibirsayıgirebilirsiniz,’cümlesinin yazdırıldığınıgörüyoruz. 14.3.5 else Deyimi Biz else deyimini koşullu durumlarda da görmüştük, ancak else deyimi döngüler ile de kullanılabilmektedir.Tabiidöngülerilekullanıldığındafarklıbirişiüstlenmektedir.elsedeyimi döngülerilebirliktekullanılırkenbreakdeyimiilebirliktebiranlamkazanır.Şöylebirkodumuz olduğunuvarsayalım: for i in range(5): print(i) else: print("else çalıştı.") Kodumuzukaydedipçalıştırdığımızdabuçıktıyıalıyoruz: 1 2 3 4 else çalıştı. >>> Peki şimdi else ifadesi ne işe yaradı? Aslında pek de işe yaramadı, else ifadesini yazmadan da aynı çıktıları alabilirdik. Dediğimiz gibi Python’da else ifadesi döngüler ile birlikte kullanılacaksabreakifadesiilebirliktebiranlamkazanır.Eğerdöngübreakifadesikullanılarak sonlandırıldı ise else çalışmaz, döngü break ifadesi ile sonlandırılmadı ise else bölümü çalışır.Yukarıdakiörneğimizdezatenbreakdeyimibulunmadığıiçinelsebölümüçalıştı.Şimdi çalışmayacağıbirörnekverelim: 14.3. İlgiliAraçlar 231 PythonBelgeleri,Yayım4.1.3 a = 0 while True: a += 1 print(a) if a==3: break else: print("else çalıştı.") Şimdiprogramımızıçalıştırdığımızdaşusonucualmaktayız: 1 2 3 Gördüğünüz gibi a değişkenimiz 3 olduğunda döngümüz break ifadesi ile kırılıyor ve bu yüzdenelseçalışmıyor.elseifadesinihemforhemdewhiledöngüsüilekullanabileceğimizi unutmayalım. Şimdi bu konu ile ilgili işe yarar bir örnek verelim. Bir karakter dizimiz var ve ’a’ harfinin bu dizidebulunupbulunmadığınıkontroletmekistiyoruz.Eğerbulunuyorsaekranabunubelirten biryazıyazacağız: karater_dizisi = "Merhaba Dünya" for harf in karater_dizisi: if harf == ’a’: print("a harfi bulundu.") Ancakbuprogramıçalıştırdığımızdaşöylebirsonuçlakarşılaşıyoruz: a harfi bulundu. a harfi bulundu. a harfi bulundu. >>> Gördüğünüz gibi her ’a’ harfi için bir defa a harfi bulundu. yazılıyor. Eğer biz bir defa ’a’ harfinerastladığımızdadöngüdençıkmakistiyorsakbunuşuşekildeyazabiliriz: karater_dizisi = "Merhaba Dünya" for harf in karater_dizisi: if harf == ’a’: print("a harfi bulundu.") break Kodumuzuçalıştırıyoruz: a harfi bulundu. >>> Pekişimdi’a’harfininbulunmadığıdurumdadaa harfi bulunmadı.yazmakistersekbunu nasılyaparız?Bazıdeğişkenleroluşturupififadesiilebunuyapmakmümkündürancakelse ifadesiiledebuişihemenhalledebiliyoruz: 232 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 karater_dizisi = "Bu yAzıdA küçük A yok." for harf in karater_dizisi: if harf == ’a’: print("a harfi bulundu.") break else: print("a harfi bulunmadı.") Kodumuzu çalıştırdığımızda break ifadesi hiç çalışmadığı için else ifadesinin çalıştığını görebiliriz: a harfi bulunmadı. >>> Evet, else ifadesi de Python’da döngüler ile bu şekilde kullanılabiliyor. Peki olmasa da olur muydu? Olurdu. else ifadesinin bu kullanım şekli de Python’daki çoğu kolaylıklardan biri sadece... Konuilealakalıdahaçokörnekiçinburaya19 bakabilirsiniz. 14.4 Örnek Uygulamalar Python programlama dilinde döngülerin neye benzediğini öğrendik. Bu bölümde ayrıca döngülerle birlikte kullanabileceğimiz başka araçları da tanıdık. Şimdi dilerseniz bu öğrendiklerimizipekiştirmekiçinbirkaçufakçalışmayapalım. 14.4.1 Karakter Dizilerinin İçeriğini Karşılaştırma Diyelimkielinizdeşöyleikifarklımetinvar: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" Siz burada, ilk_metin adlı değişken içinde bulunan, ama ikinci_metin adlı değişken içinde bulunmayan öğeleri ayıklamak istiyorsunuz. Yani bu iki metnin içeriğini karşılaştırıp, farklı öğeleri bulmayı amaçlıyorsunuz. Bu işlem için, bu bölümde öğrendiğimiz döngülerden ve dahaönceöğrendiğimizbaşkaaraçlardanyararlanabilirsiniz.Şimdidikkatlicebakın: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" for s in ilk_metin: if not s in ikinci_metin: print(s) Bukodlarıbirdosyayakaydedipçalıştırdığımızdaşuçıktıyıalıyoruz: 19https://forum..com/t/while-else-ve-for-else/4439 14.4. ÖrnekUygulamalar 233 PythonBelgeleri,Yayım4.1.3 a a ş ş a Demek ki ilk_metin adlı değişkende olup da ikinci_metin adlı değişkende olmayan öğeler bunlarmış... Bu kodlarda anlayamayacağınız hiçbir şey yok. Ama dilerseniz biz yine de bu kodları tek tek inceleyelim. İlkolarakdeğişkenlerimizitanımladık: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" Amacımız ilk_metin’de olan, ama ikinci_metin’de olmayan öğeleri görmek. Bunun için ilk_metin’deki öğeleri tek tek ikinci_metin’deki öğelerle karşılaştırmamız gerekiyor. Tahmin edebileceğiniz gibi, bir metnin bütün öğelerine tek tek bakabilmenin en iyi yolu for döngülerinikullanmaktır.Ohaldedöngümüzüyazalım: ’ ’ ’ for s in ilk_metin: #ilk_metin deki, s adını verdiğimiz bütün öğeler için ’ ’ ’ if not s in ikinci_metin: #eğer s adlı bu öğe ikinci_metin de yoksa ’ ’ print(s) # s adlı öğeyi ekrana bas Gördüğünüz gibi, döngüleri (for), bool işleçlerini (not) ve aitlik işleçlerini (in) kullanarak, istediğimiz şeyi rahatlıkla yapabiliyoruz. Burada kullandığımız if deyimi, bir önceki satırda for döngüsü ile üzerinden geçtiğimiz öğeleri süzmemizi sağlıyor. Burada temel olarak şu üç işlemiyapıyoruz: 1. ilk_metiniçindekibütünöğelerinüzerindengeçiyoruz, 2. Buöğeleribellibirölçütegöresüzüyoruz, 3. Ölçüteuyanöğeleriekranabasıyoruz. Elbette yukarıda yaptığımız işlemin tersini yapmak da mümkündür. Biz yukarıdaki kodlarda ilk_metin’de olan, ama ikinci_metin’de olmayan öğeleri süzdük. Eğer istersek ikinci_metin’de olan,amailk_metin’deolmayanöğeleridesüzebiliriz.Mantığımızyineaynı: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" ’ ’ ’ for s in ikinci_metin: #ikinci_metin deki, s adını verdiğimiz bütün öğeler␣ için ˓→ ’ ’ ’ if not s in ilk_metin: #eğer s adlı bu öğe ilk_metin de yoksa ’ ’ print(s) # s adlı öğeyi ekrana bas Budabizeşuçıktıyıveriyor: u ı o (sonrakisayfayadevam) 234 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) r y e u ı r u e e e u Gördüğünüz gibi, yaptığımız tek şey, ilk_metin ile ikinci_metin’in yerlerini değiştirmek oldu. Kullandığımızmantıkisedeğişmedi. Bu arada, yukarıdaki çıktıda bizi rahatsız eden bir durum var. Çıktıda bazı harfler birbirini tekrarediyor.Aslındatemelolaraksadeceşuharflervar: u ı o r y e Amametiniçindebazıharflerbirdenfazlasayıdageçtiğiiçin,doğalolarakçıktıdadabuharfler birden fazla sayıda görünüyor. Ama tabii ki, eğer biz istersek farklı olan her harften yalnızca birtanesiniçıktıdagörmeyidetercihedebiliriz.Bununiçinşöylebirkodyazabiliriz: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" fark = "" for s in ikinci_metin: if not s in ilk_metin: if not s in fark: fark += s print(fark) Burada da anlayamayacağımız hiçbir şey yok. Bu kodlardaki bütün parçaları tanıyoruz. Her zamankigibiöncelikledeğişkenlerimizitanımladık: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" Daha sonra fark adlı boş bir karakter dizisi tanımlıyoruz. Metinler içindeki farklı karakter dizilerinifarkadlıbukarakterdizisiiçindedepolayacağız. Ardındandafordöngümüzüyazıyoruz: 14.4. ÖrnekUygulamalar 235 PythonBelgeleri,Yayım4.1.3 ’ ’ ’ for s in ikinci_metin: # ikinci_metin de s dediğimiz bütün öğeler için ’ ’ ’ if not s in ilk_metin: # eğer s ilk_metin de yoksa ’ ’ ’ if not s in fark: # eğer s fark ta da yoksa fark += s # bu öğeyi fark değişkenine ekle print(fark) # fark değişkenini ekrana bas Uyguladığımız mantığın ne kadar basit olduğunu görüyorsunuz. Bu kodlarda basitçe şu işlemleriyapıyoruz: 1. ikinci_metindeğişkeniiçindekibütünöğelerinüzerindentektekgeç, 2. Eğerbudeğişkendekiherhangibiröğeilk_metin’devefark’tayoksaoöğeyifark’aekle. 3. Sonolarakdafark’ıekranabas. Bu kodlarda dikkatimizi çeken ve üzerinde durmamız gereken bazı noktalar var. Burada özelliklefarkdeğişkenineöğeeklemeişlemininasılyaptığımızadikkatedin. Pythonprogramlamadilindeöncedenoluşturduğumuzbirkarakterdizisinibaşkabirkarakter dizisiilebirleştirdiğimizdebuişlemilkoluşturduğumuzkarakterdizisinietkilemez.Yani: >>> a = ’’ >>> a + ’.com’ ’.com’ Buradasankiaadlıözgünkarakterdizisinideğiştirmişizve‘.com’değerinieldeetmişiz gibigörünüyor.Amaaslındaa’nındurumundahiçbirdeğişiklikyok: >>> a ’’ Gördüğünüz gibi, a değişkeninin değeri hâlâ ‘’. Bu durumun nedeni, birleştirme işlemlerinin bir değiştirme işlemi olmamasıdır. Yani mesela iki karakter dizisini birleştirdiğinizde birleşen karakter dizileri üzerinde herhangi bir değişiklik olmaz. Bu durumda yapabileceğimiz tek şey, karakter dizisine eklemek istediğimiz öğeyi de içeren yeni birkarakterdizisioluşturmaktır.Yani: >>> a = ’’ >>> a = a + ’.com’ >>> print(a) .com Buradasankideğeri‘’olanaadlıbirdeğişkene‘.com’değerinieklemişizgibigörünüyor, ama aslında biz burada a değişkenini yok edip, ‘.com’ değerini içeren, a adlı başka bir değişkentanımladık.Budurumunasılteyitedeceğinizibiliyorsunuz: >>> a = ’’ >>> id(a) 15063200 (sonrakisayfayadevam) 236 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> a = a + ’.com’ >>> id(a) 15067960 Buradaid()fonksiyonunukullanarakkarakterdizilerininkimliklerinisorguladık.Gördüğünüz gibi, isimleri aynı da olsa, aslında ortada iki farklı a değişkeni var. Kimlik numaralarının farklı olmasından anladığımıza göre, ilk başta tanımladığımız a değişkeni ile a = a + ’.com’ satırıylaoluşturduğumuzadeğişkenibirbirindenfarklı. Bu arada, eğer istersek yukarıdaki değer atama işlemini, önceki bölümlerde öğrendiğimiz değeratamaişleçleriyardımıylakısaltabileceğimizidebiliyorsunuz: >>> a += ’.com’ İşte ilk_metin ile ikinci_metin değişkenleri arasındaki farklı harfleri yalnızca birer kez yazdırmakiçinkullandığımızkodlardadayukarıdakiişlemiyaptık: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" fark = ’’ for s in ikinci_metin: if not s in ilk_metin: if not s in fark: fark += s print(fark) Gördüğünüz gibi, önce boş bir fark değişkeni oluşturduk. Daha sonra bu değişkene for döngüsüiçindeyenideğerleratayabilmek(dahadoğrusuatarmışgibiyapmak)içinfark += s gibibirkodkullandık.Böylecefordöngüsününherdönüşündesadınıverdiğimizherbiröğeyi tek tek fark değişkenine yolladık. Böylece program sonunda elimizde, farklı öğeleri yalnızca birerkeziçerenfarkadlıbirdeğişkenolmuşoldu.Dediğimizgibi,ilkbaştatanımladığımızboş fark değişkeni ile, program sonunda farklı değerleri içeren fark değişkeni aslında aynı değil. Yanibizilkfarkdeğişkeninedöngününherdönüşündeyenibiröğeeklemekyerine,döngünün her dönüşünde yeni bir fark değişkeni oluşturmuş oluyoruz. Ama programın sonunda sanki fark değişkenine her defasında yeni bir değer atamışız gibi görünüyor ve bu da bizim işimizi görmemizeyetiyor... Programın başındaki ve sonundaki fark değişkenlerinin aslında birbirinden farklı olduğunu teyitetmekiçinşukodlarıkullanabilirsiniz: ilk_metin = "asdasfddgdhfjfdgdşfkgjdfklgşjdfklgjdfkghdfjghjklsdhajlsdhjkjhkhjjh" ikinci_metin = "sdfsuıdoryeuıfsjkdfhdjklghjdfklruseldhfjlkdshfljskeeuf" fark = "" print("fark’ın ilk tanımlandığı zamanki kimlik numarası: ", id(fark)) for s in ikinci_metin: (sonrakisayfayadevam) 14.4. ÖrnekUygulamalar 237 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if not s in ilk_metin: if not s in fark: fark += s print("fark’ın program sonundaki kimlik numarası: ", id(fark)) Gördüğünüzgibi,gerçektendeortadaikifarklıfarkdeğişkenivar.Budurumuid()fonksiyonu yardımıyladoğrulayabiliyoruz. Pekibubilgininbizenefaydasıvar? Şimdilik şu kadarını söyleyelim: Eğer o anda muhatap olduğunuz bir veri tipinin mizacını, huyunu-suyunubilmezsenizyazdığınızprogramlardaçokkötüsürprizlerlekarşılaşabilirsiniz. Birkaç bölüm sonra başka veri tiplerini de öğrendikten sonra bu durumu daha ayrıntılı bir şekildeinceleyeceğiz. Buarada,tahminedebileceğinizgibiyukarıdakifordöngüsünüşöyledeyazabilirdik: for s in ikinci_metin: if not s in ilk_metin and not s in fark: fark += s Buradaikifarklıifdeyiminiikifarklısatırdayazmakyerine,budeyimleriandişleciilebirbirine bağladık. Bu örnek ile ilgili söyleyeceklerimiz şimdilik bu kadar. Gelin biz şimdi isterseniz bilgilerimizi pekiştirmekiçinbaşkabirörnekdahayapalım. 14.4.2 Dosyaların İçeriğini Karşılaştırma Biröncekiörnektekarakterdizilerininiçeriğininasılkarşılaştırabileceğimizigösterenbirörnek vermiştik.Şimdide,gerçekhayattakarşınızaçıkmasıdahaolasıbirdurumolmasıbakımından, dosyalarıniçeriğininasılkarşılaştıracağımızadairbirörnekverelim. Esasında karakter dizilerinin içeriğini birbirleriyle nasıl karşılaştırıyorsak, dosyaların içeriğini de benzer şekilde karşılaştırabiliriz. Mesela içeriği şu olan isimler1.txt adlı bir dosyamız olduğunuvarsayalım: Ahmet Mehmet Sevgi Sinan Deniz Ege Efe Ferhat Fırat Zeynep Hazan Mahmut Celal (sonrakisayfayadevam) 238 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Cemal Özhan Özkan Yineiçeriğişuolanbirdeisimler2.txtadlıbaşkabirdosyadahaolduğunudüşünelim: Gürsel Mehmet Sevgi Sami Deniz Ege Efe Ferhat Fırat Tülay Derya Hazan Mahmut Tezcan Cemal Özhan Özkan Özcan Dilek Amacımız bu iki dosyanın içeriğini karşılaştırıp, farklı öğeleri ortaya sermek. Dediğimiz gibi, biröncekiörnekteizlediğimizyoluburadadatakipedebiliriz.Dikkatlicebakın: d1 = open("isimler1.txt") # dosyayı açıyoruz d1_satırlar = d1.readlines() # satırları okuyoruz d2 = open("isimler2.txt") d2_satırlar = d2.readlines() for i in d2_satırlar: if not i in d1_satırlar: print(i) d1.close() d2.close() Gerçekten de mantığın bir önceki örnekle tamamen aynı olduğunu görüyorsunuz. Biz henüz Python’da dosyaların nasıl işleneceğini öğrenmedik, ama daha önce gördüğümüz open() fonksiyonuyardımıylaenazındandosyalarıaçabilecekkadarbiliyoruzdosyaişlemlerininnasıl yürütüleceğini... Burada farklı olarak readlines() adlı bir metot görüyoruz. Biz burada bu metodun ayrıntılarına inmeyeceğiz, ama şimdilik dosya içeriğinin satırlar halinde okunmasını sağladığınıbilelimyeter. Bu arada, eğer çıktıda Türkçe karakterleri düzgün görüntüleyemiyorsanız open() 14.4. ÖrnekUygulamalar 239 PythonBelgeleri,Yayım4.1.3 fonksiyonununencodingadlıbirparametresivasıtasıylaiçeriğiUTF-8olarakkodlayabilirsiniz: d1 = open("isimler1.txt", encoding="utf-8") # dosyayı açıyoruz d1_satırlar = d1.readlines() # satırları okuyoruz d2 = open("isimler2.txt", encoding="utf-8") d2_satırlar = d2.readlines() for i in d2_satırlar: if not i in d1_satırlar: print(i) d1.close() d2.close() Bu şekilde Türkçe karakterleri düzgün bir şekilde görüntüleyebiliyor olmanız lazım. Eğer Windows’taTürkçekarakterlerihaladüzgüngörüntüleyemiyorsanızencodingparametresinde ‘utf-8’yerine‘cp1254’adlıdilkodlamasınıkullanmayıdeneyebilirsiniz: encoding = "cp1254" Yukarıdaki örneklerde bir içerik karşılaştırması yapıp, farklı öğeleri ayıkladık. Aynı şekilde benzeröğeleriayıklamakdamümkündür.Buişleminnasılyapılacağınıazçoktahminettiğinizi zannediyorum: d1 = open("isimler1.txt") d1_satırlar = d1.readlines() d2 = open("isimler1.txt") d2_satırlar = d2.readlines() for i in d2_satırlar: if i in d1_satırlar: print(i) d1.close() d2.close() Burada bir öncekinden farklı olarak if not i in d1_satırlar kodu yerine, doğal olarak, if i in d1_satırlarkodunukullandığımızadikkatedin. Dosyalar üzerinde yaptığımız işlemleri tamamladıktan sonra close() metodu ile bunları kapatmayıunutmuyoruz: d1.close() d2.close() 240 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 14.4.3 Karakter Dizisindeki Karakterleri Sayma Yukarıdakiörneklerdeiçerikkarşılaştırmayailişkinbirkaçörnekverdik.Şimdiyinebilgilerimizi pekiştirmekiçinbaşkabirkonuyailişkinörneklerverelim. Meselaelimizdeşöylebirmetinolduğunuvarsayalım: Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır. Yapmamız gereken bir istatistik çalışması gereğince bu metinde her harfin kaç kez geçtiğini hesaplamanızgerekiyor. Bununiçinşöylebirprogramyazabiliriz: metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır.""" harf = input("Sorgulamak istediğiniz harf: ") sayı = ’’ for s in metin: if harf == s: sayı += harf print(len(sayı)) Buradaönceliklemetnimizibirdeğişkenolaraktanımladık.Ardındandakullanıcıyahangiharfi sorgulamakistediğinisorduk. Bu kodlarda tanımladığımız sayı adlı değişken, sorgulanan harfi, metinde geçtiği sayıda içinde barındıracaktır. Yani mesela metin 5 tane a harfi varsa sayı değişkeninin değeri aaaaa olacaktır. Sonrakisatırlardafordöngümüzütanımlıyoruz: ’ ’ for s in metin: # metin içinde s adını verdiğimiz her bir öğe için ’ ’ if harf == s: # eğer kullanıcıdan gelen harf s ile aynıysa sayı += harf # kullanıcıdan gelen bu harfi sayı değişkenine yolla 14.4. ÖrnekUygulamalar 241 PythonBelgeleri,Yayım4.1.3 Dediğimiz gibi, sayı değişkeni, sorgulanan harfi, metinde geçtiği sayıda barındırıyor. Dolayısıyla bir harfin metinde kaç kez geçtiğini bulmak için sayı değişkeninin uzunluğunu yazdırmamızyeterliolacaktır: print(len(sayı)) Dilerseniz yukarıdaki programı yazmak için daha farklı bir mantık da kullanabilirsiniz. Dikkatlicebakın: metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır.""" harf = input("Sorgulamak istediğiniz harf: ") sayı = 0 for s in metin: if harf == s: sayı += 1 print(sayı) Burada sayı değişkeninin ilk değeri 0 olarak belirledik. Döngü içinde de, sorgulanan harfin metin içinde her geçişinde sayı değişkeninin değerini 1 sayı artırdık. Dolayısıyla sorgulanan harfin metinde kaç kez geçtiğini bulmak için sayı değişkeninin son değerini yazdırmamız yeterlioldu. 14.4.4 Dosya içindeki Karakterleri Sayma Dilerseniz bir önceki örnekte kullandığımız metnin program içinde bir değişken değil de, meselabirdosyadanokunanbirmetinolduğunuvarsayalımşimdi: hakkında = open("hakkında.txt", encoding="utf-8") harf = input("Sorgulamak istediğiniz harf: ") sayı = 0 for karakter_dizisi in hakkında: for karakter in karakter_dizisi: if harf == karakter: sayı += 1 print(sayı) (sonrakisayfayadevam) 242 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) hakkında.close() Buradayaptığımızilkişelbettedosyamızıaçmakoldu: hakkında = open("hakkında.txt", encoding="utf-8") Bu komutla, hakkında.txt adlı dosyayı UTF-8 kodlaması ile açtık. Daha sonra kullanıcıya, sorgulamakistediğiharfisoruyoruz: harf = input("Sorgulamak istediğiniz harf: ") Ardından da sorgulanan harfin dosyada kaç kez geçtiği bilgisini tutacak olan sayı adlı bir değişkentanımlıyoruz: sayı = 0 Sırageldifordöngümüzütanımlamaya: for karakter_dizisi in hakkında: for karakter in karakter_dizisi: if harf == karakter: sayı += 1 Bu döngüyü anlamakta bir miktar zorlanmış olabilirsiniz. Her zaman söylediğimiz gibi, Python’da bir kod parçasını anlamanın en iyi yöntemi, gerekli yerlere print() fonksiyonları yerleştirerek,programınverdiğiçıktılarıincelemektir: for karakter_dizisi in hakkında: print(karakter_dizisi) #for karakter in karakter_dizisi: # if harf == karakter: # sayı += 1 Gördüğünüz gibi, ilkfor döngüsünün hemen sonrasına bir print()fonksiyonu yerleştirerek bu döngünün verdiği çıktıları inceliyoruz. Bu arada, amacımıza hizmet etmeyen satırları da yorumiçinealaraketkisizleştirdiğimizedikkatedin. Çıktıyabaktığımızzaman,şöylebirdurumlakarşılaşıyoruz: Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına aldanarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı (sonrakisayfayadevam) 14.4. ÖrnekUygulamalar 243 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır. Burada her bir satır ayrı bir karakter dizisidir. Eğer her bir satırın ayrı bir karakter dizisi olduğunu daha net bir şekilde görmek istiyorsanız repr() adlı özel bir fonksiyondan yararlanabilirsiniz: for karakter_dizisi in hakkında: print(repr(karakter_dizisi)) #for karakter in karakter_dizisi: # if harf == karakter: # sayı += 1 Bukodlarbukezşöylebirçıktıverir: ’Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı\n’ ’tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,\n’ ’isminin Python olmasına aldanarak, bu programlama dilinin, adını piton\n’ ’yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama␣ dilinin\n’ ˓→ ’adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty\ n’ ˓→ ’Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı\n’ ’gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa\ n’ ˓→ ’da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil\n’ ’edilmesi neredeyse bir gelenek halini almıştır.’ Bu çıktıya çok dikkatlice bakın. repr() fonksiyonu sayesinde Python’ın alttan alta neler çevirdiğinibarizbirbiçimdegörüyoruz.Karakterdizisininbaşlangıçvebitişinigösterentırnak işaretleri ve \n kaçış dizilerinin görünür vaziyette olması sayesinde her bir satırın ayrı bir karakterdizisiolduğunudahanetbirşekildegörebiliyoruz. Biz yazdığımız kodlarda, kullanıcıdan bir harf girmesini istiyoruz. Kullandığımız algoritma gereğince bu harfi metindeki karakter dizileri içinde geçen her bir karakterle tek tek karşılaştırmamızgerekiyor.input()metoduaracılığıylakullanıcıdantekbirkarakteralıyoruz. Kullandığımız for döngüsü ise bize bir karakter yerine her satırda bir karakter dizisi veriyor. Dolayısıyla mesela kullanıcı ‘a’ harfini sorgulamışsa, ilk for döngüsü bu harfin karşısına ‘Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcın’ adlı karakter dizisini çıkaracaktır. Dolayısıyla bizim bir seviye daha alta inerek, ilk for döngüsünden elde edilen değişkenüzerindebaşkabirfordöngüsüdahakurmamızgerekiyor.Buyüzdenşöylebirkod yazıyoruz: for karakter_dizisi in hakkında: for karakter in karakter_dizisi: ... 244 Bölüm14. Döngüler(Loops) PythonBelgeleri,Yayım4.1.3 Böyleceiçiçeikifordöngüsüoluşturmuşoluyoruz.İstersenizbuanlattığımızşeyleridahanet görmekiçinyineprint()fonksiyonundanyararlanabilirsiniz: hakkında = open("hakkında.txt", encoding="utf-8") harf = input("Sorgulamak istediğiniz harf: ") sayı = 0 for karakter_dizisi in hakkında: for karakter in karakter_dizisi: print(karakter) # if harf == karakter: # sayı += 1 #print(sayı) karakterdeğişkenindeğeriniekranayazdırarakPython’ınalttanaltanelerçevirdiğinidahanet görebiliyoruz. Kodların geri kalanında ise, kullanıcının sorguladığı harfin, for döngüsü ile üzerinden geçtiğimiz karakter_dizisi adlı değişken içindeki karakterlerle eşleşip eşleşmediğini denetliyoruz. Eğer eşleşiyorsa, her eşleşmede sayı değişkeninin değerini 1 sayı artırıyoruz. Böyleceenelimizdesorgulananharfinmetiniçindekaçkezgeçtiğibilgisiolmuşoluyor. Sonolarakda,ilkbaştaaçtığımızdosyayıkapatıyoruz: hakkında.close() Nihayet bir konunun daha sonuna ulaştık. Döngüler ve döngülerle ilişkili araçları da epey ayrıntılıbirşekildeincelediğimizegöregönülrahatlığıylabirsonrakikonuyageçebiliriz. 14.4. ÖrnekUygulamalar 245 15 BÖLÜM Hata Yakalama Şimdiye kadar yazdığımız bütün programlar, dikkat ettiyseniz tek bir ortak varsayım üzerine kurulu. Buna göre biz, yazdığımız programın kullanıcı tarafından nasıl kullanılmasını istiyorsak, her zaman o şekilde kullanılacağını varsayıyoruz. Örneğin sayıları toplayan bir program yazdığımızda, kullanıcının her zaman sayı değerli bir veri gireceğini düşünüyoruz. Ancak bütün iyi niyetimize rağmen, yazdığımız programlarda işler her zaman beklediğimiz gibi gitmeyebilir. Örneğin, dediğimiz gibi, yazdığımız programı, kullanıcının bir sayı girmesi temeli üzerine kurgulamışsak, kullanıcının her zaman sayı değerli bir veri gireceğinden emin olamayız. Meselaşöylebirprogramyazdığımızıdüşünün: veri1 = input("Karekökünü hesaplamak istediğiniz sayı: ") karekök = int(veri1) ** 0.5 print(veri1, "sayısının karekökü: ", karekök) veri2 = input("Karesini hesaplamak istediğiniz sayı: ") kare = int(veri2) ** 2 print(veri2, "sayısının karesi: ", kare) Bukodlardakisorunuanlamayaçalışmadanöncedilersenizkodlarışöylebirinceleyelim. Gördüğünüz gibi, burada kullanıcının gireceği sayılara göre karekök ve kare alma işlemleri yapıyoruz. Bu kodlarda gördüğümüz ** işleci yardımıyla bir sayının herhangi bir kuvvetini hesaplayabileceğimizi biliyorsunuz. Mesela 217’nin kaç ettiğini hesaplamak için ** işlecini kullanabiliyoruz: >>> 21 ** 7 1801088541 Yine bildiğiniz gibi, bu işleçten, bir sayının karesini hesaplamak için de yararlanabiliyoruz. 246 PythonBelgeleri,Yayım4.1.3 Çünküneticedebirsayınınkaresi,osayının2.kuvvetidir: >>> 12 ** 2 144 Aynı şekilde, eğer bir sayının, 0.5’inci kuvvetini hesaplarsak o sayının karekökünü bulmuş oluyoruz.(Bubilgileriöncekikonulardanhatırlıyorolmalısınız): >>> 144 ** 0.5 12 Kodlarımızıincelediğimizegöre,buprogramdakiaksaklıklarıirdelemeyebaşlayabiliriz. Bu program, kullanıcı sayı değerli bir veri girdiği müddetçe sorunsuz bir şekilde çalışacaktır. Pekiyakullanıcısayıdeğerlibirveriyerinebaşkabirşeygirerseneolur? Örneğin kullanıcı yukarıdaki programa bir sayı yerine, (bilerek veya bilmeyerek) içinde harf barındıranbirverigirerseşunabenzerbirhataalır: Traceback (most recent call last): File "deneme.py", line 2, in <module> karekök = int(veri1) ** 0.5 ValueError: invalid literal for int() with base 10: ’fds’ Yazdığınız programların bu tür hatalar vermesi normaldir. Ancak son kullanıcı açısından düşündüğümüzde,kullanıcınınyukarıdakigibibirhatamesajıgörmesiyerine,hatanınneden kaynaklandığınıyadaneyiyanlışyaptığınıdahaaçıkbirşekildeifadeedenbirmesajalmasıçok daha mantıklı olacaktır. Zira yukarıdaki hata mesajı programcılar açısından anlamlı olabilir, ancaksonkullanıcıaçısındanbüsbütünanlaşılmazdır! Dediğimiz gibi, programınızın çalışma esnasında bu tür hatalar vermesi normal. Çünkü yapmaya çalıştığınız işlem, kullanıcının belli tipte bir veri girmesine bağlı. Burada sizin bir programcı olarak göreviniz, yazdığınız programın çalışma esnasında vermesi muhtemel hataları önceden kestirip, programınızda buna göre bazı önlemler almanızdır. İşte biz de bu bölümdebuönlemlerinasılalacağımızıanlamayaçalışacağız. 15.1 Hata Türleri Biz bu bölümde hatalardan bahsedeceğimizi söylemiştik. Ancak her şeyden önce ‘hata’ kavramının çok boyutlu olduğunu hatırlatmakta fayda var. Özellikle programcılık açısından hatakavramınınneanlamageldiğinibirazincelememizgerekiyor. Bizbubölümdehatalarıüçfarklıbaşlıkaltındaelealacağız: 1. ProgramcıHataları(Error) 2. ProgramKusurları(Bug) 3. İstisnalar(Exception) Öncelikleprogramcıhatalarındanbahsedelim. 15.1. HataTürleri 247 PythonBelgeleri,Yayım4.1.3 Programcıdan kaynaklanan hatalar doğrudan doğruya programı yazan kişinin dikkatsizliğinden ötürü ortaya çıkan bariz hatalardır. Örneğin şu kod bir programcı hatası içerir: >>> print "Merhaba Python!" Bukoduçalıştırdığınızdaşöylebirhatamesajıgörürsünüz: >>> print "Merhaba Python!" File "<stdin>", line 1 print "Merhaba Python!" ^ SyntaxError: invalid syntax Buhatamesajındabiziilgilendirenkısımsoncümledeyeralıyor:SyntaxError,yaniSözdizimi hatası. Bu hatalar, programlama diline ilişkin bir özelliğin yanlış kullanımından veya en basit şekildeprogramcınınyaptığıyazımhatalarındankaynaklanır.Programcınınhatalarıgenellikle SyntaxError şeklinde ortaya çıkar. Bu hatalar çoğunlukla programcı tarafından farkedilir ve program kullanıcıya ulaşmadan önce programcı tarafından düzeltilir. Bu tür hataların tespiti diğerhatalarakıyaslakolaydır.Çünkübutürhatalarprogramınızınçalışmasınıengellediğiiçin bunlarıfarketmemekpekmümkündeğildir... Programkusurları,başkabirdeyişlebug’lariseçokdahakarmaşıktır.Kusurluprogramlarçoğu zaman herhangi bir hata vermeden çalışır. Ancak programın ürettiği çıktılar beklediğiniz gibi değildir. Örneğin yazdığınız programda bir formül hatası yapmış olabilirsiniz. Bu durumda programınız hiçbir şey yokmuş gibi çalışır, ancak formül hatalı olduğu için hesaplamaların sonuçlarıyanlıştır.Örneğindahaöncekiderslerimizdeyazdığımızşuprogramyukarıdakigibi birkusuriçerir: sayı1 = input("Toplama işlemi için ilk sayıyı girin: ") sayı2 = input("Toplama işlemi için ikinci sayıyı girin: ") print(sayı1, "+", sayı2, "=", sayı1 + sayı2) Bu programda kullanıcı veri girdiği zaman, programımız toplama işlemi değil karakter dizisi birleştirme işlemi yapacaktır. Böyle bir program çalışma sırasında hata vermeyeceği için buradaki sorunu tespit etmek, özellikle büyük programlarda çok güçtür. Yani sizin düzgün çalıştığınızannettiğinizprogramaslındagizlidengizliyebirbugbarındırıyorolabilir. Aynı şekilde, mesela eval() fonksiyonunun dikkatsizce kullanıldığı programlar da güvenlik açısından kusurludur. Yani bu tür programlar bir güvenlik kusuru (security bugveyasecurity flaw)barındırır. Dediğimiz gibi, program kusurları çok boyutlu olup, burada anlattığımızdan çok daha karmaşıktır. Gelelimüçüncükategoriolanistisnalara(exceptions)... İstisnalar,adındandaazçokanlaşılacağıgibi,birprogramınçalışmasısırasındaortayaçıkan, normaldenfarklı,istisnaidurumlardır.Örneğinşuprogramabakalım: 248 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") ilk_sayı = int(ilk_sayı) ikinci_sayı = int(ikinci_sayı) print(ilk_sayı, "/", ikinci_sayı, "=", ilk_sayı / ikinci_sayı) Buradailksayıyıikincisayıyabölenbirprogramyazdık.Buprogramhertürlübölmeişlemini yapabilir.Amaburadahesabakatmamızgerekenikişeyvar: 1. Kullanıcısayıyerine,sayıdeğerliolmayanbirveritipigirebilir.Meselailksayıyakarşılık 23,ikincisayıyakarşılık‘fdsfd’gibibirşeyyazabilir. 2. Kullanıcı bir sayıyı 0’a bölmeye çalışabilir. Mesela ilk sayıya karşılık 23, ikinci sayıya karşılık0yazabilir. İlkdurumdaprogramımızşöylebirhataverir: ilk sayı: 23 ikinci sayı: fdsfd Traceback (most recent call last): File "deneme.py", line 5, in <module> ikinci_sayı = int(ikinci_sayı) ValueError: invalid literal for int() with base 10: ’fdsfd’ Buradaki sorun, sayı değerli olmayan bir verinin, int() fonksiyonu aracılığıyla sayıya çevrilmeyeçalışılıyorolması. İkincidurumdaiseprogramımızşöylebirhataverir: ilk sayı: 23 ikinci sayı: 0 Traceback (most recent call last): File "deneme.py", line 7, in <module> print(ilk_sayı, "/", ikinci_sayı, "=", ilk_sayı / ikinci_sayı) ZeroDivisionError: division by zero Buradaki sorun ise, bir sayının 0’a bölünmeye çalışılıyor olması. Matematikte sayılar 0’a bölünemez... İşte bu iki örnekte gördüğümüz ValueError ve ZeroDivisionError birer istisnadır. Yani kullanıcıların,kendilerindensayıbeklenirkensayıdeğerliolmayanverigirmesiveyabirsayıyı 0’abölmeyeçalışmasıistisnaibirerdurumdurveyazdığımızprogramlarınexception(istisna) üretmesineyolaçar. Böylece hata (error), kusur (bug) ve istisna (exception) arasındaki farkları şöyle bir gözden geçirmiş olduk. Yalnız burada şunu söylemekte yarar var: Bu üç kavram arasındaki fark belli belirsizdir.Yanibukavramlarınçoğuyerdebirbirlerininyerinekullanıldığınıdagörebilirsiniz. Örneğin exception kavramı için Türkçe’de çoğu zaman ‘hata’ kelimesini kullanıyoruz. Zaten dikkat ederseniz bu bölümün başlığı da ‘İstisna Yakalama’ değil, ‘Hata Yakalama’dır. Aynı şekilde, İngilizcede de bu kavramların çoğu yerde birbirlerinin yerine kullanıldığını görebilirsiniz.Dolayısıyla,konuyakarşıözelbirilginizyoksa,hata,kusurveistisnakavramlarını birbirindenayırmakiçinkendinizizorlamanızagerekyok.Buüçkavramçoğuzamanbirbirinin 15.1. HataTürleri 249 PythonBelgeleri,Yayım4.1.3 yerinekullanılıyordaolsa,aslındaaralarındabazıfarklarolduğunuöğrenmişsenizbubölüm amacınaulaşmışdemektir. Konuylailgilitemelbilgileriedindiğimizegöreasılmeseleyegeçebiliriz... 15.2 try... except... Bir önceki bölümde hatalardan ve hataları yakalamaktan söz ettik. Peki bu hataları nasıl yakalayacağız? Python’da hata yakalama işlemleri için try... except... bloklarından yararlanılır. Hemen birörnekverelim: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except ValueError: print("Lütfen sadece sayı girin!") Biliyoruz ki, bir veriyi sayıya dönüştürmek istediğimizde eğer kullanıcı sayı değerli bir veri yerine harf değerli bir veri girerse programımız çöker. Dolayısıyla int(ilk_sayı) ve int(ikinci_sayı) kodları, kullanıcının gireceği veri türüne göre hata üretme potansiyeline sahiptir.Oyüzden,buradahatavereceğinibildiğimizokodlarıtrybloğuiçinealdık. Yine bildiğimiz gibi, veri dönüştürme işlemi sırasında kullanıcının uygun olmayan bir veri girmesihalindeüretilecekhatabirValueError’dır.Dolayısıylaexceptbloğuiçineyazacağımız hata türünün adı da ValueError olacaktır. O yüzden ValueError adlı hatayı yakalayabilmek içinşusatırlarıyazdık: except ValueError: print("Lütfen sadece sayı girin!") BuradabukodlarlaPython’aşuemrivermişolduk: Eğer try bloğu içinde belirtilen işlemler sırasında bir ValueError ile karşılaşırsan bunu görmezden gel ve normal şartlar altında kullanıcıya göstereceğin hata mesajınıgösterme.OnunyerinekullanıcıyaLütfen sadece sayı girin!uyarısını göster. Yukarıda Türkçeye çevirdiğimiz emri Pythoncada nasıl ifade ettiğimize dikkat edin. Temel olarakşöylebiryapıylakarşıkarşıyayız: try: hata verebileceğini bildiğimiz kodlar except HataAdı: hata durumunda yapılacak işlem Gelinistersenizbirörnekdahaverelim. 250 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 Hatırlarsanız bir sayının 0’a bölünmesinin mümkün olmadığını, böyle bir durumda programımızın hata vereceğini söylemiştik. Bu durumu teyit etmek için etkileşimli kabukta şukodudeneyebilirsiniz: >>> 2 / 0 Bukodşöylebirhatamesajıverecektir: >>> 2 / 0 Traceback (most recent call last): File "<stdin>", line 1, in <module> ZeroDivisionError: division by zero Dahaöncedesöylediğimizgibi,buhatamesajındabiziilgilendirenkısımZeroDivisionError. Demekkibirsayı0’abölündüğündePythonZeroDivisionErrorveriyormuş.Ohaldeşöylebir kodyazabiliriz: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except ZeroDivisionError: print("Bir sayıyı 0’a bölemezsiniz!") Gördüğünüzgibi,Python’ınZeroDivisionErrorvereceğinibildiğimizdurumlarakarşıbuhata türünü yakalama yoluna gidiyoruz. Böylece kullanıcıya anlamsız ve karmaşık hata mesajları göstermek ve daha da kötüsü, programımızın çökmesine sebep olmak yerine daha anlaşılır mesajlarüretiyoruz. Yukarıdaki kodlarda özellikle bir nokta dikkatinizi çekmiş olmalı: Dikkat ederseniz yukarıdaki kodlar aslında bir değil iki farklı hata üretme potansiyeline sahip. Eğer kullanıcı sayı değerli veri yerine harf değerli bir veri girerse ValueError, eğer bir sayıyı 0’a bölmeye çalışırsadaZeroDivisionErrorhatasıalıyoruz.Pekiaynıkodlardaikifarklıhatatürününasıl yakalayacağız? Çokbasit: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except ZeroDivisionError: print("Bir sayıyı 0’a bölemezsiniz!") except ValueError: print("Lütfen sadece sayı girin!") 15.2. try... except... 251 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi çözüm gayet mantıklı. Birden fazla hata türü üreteceğini bildiğimiz kodları yinetekbirtrybloğuiçinealıyoruz.Hatatürleriniiseayrıexceptbloklarıiçindeelealıyoruz. Bir program yazarken, en iyi yaklaşım, yukarıda yaptığımız gibi, her hata türü için kullanıcıya ayrı bir uyarı mesajı göstermektir. Böylece kullanıcılarımız bir hatayla karşılaştıklarında sorununasılçözebileceklerikonusundaenazındanbirfikirsahibiolabilirler. Dediğimiz gibi, her hata için ayrı bir mesaj göstermek en iyisidir. Ama tabii dilerseniz hata türlerinigruplayıphepsiiçintekbirhatamesajıgöstermeyidetercihedebilirsiniz.Bununasıl yapacağımızıgörelim: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except (ValueError, ZeroDivisionError): print("Bir hata oluştu!") Gördüğünüzgibi,buradaValueErrorveZeroDivisionErroradlıhatatürlerinitekbirparantez içindetopladık.Buradadikkatedeceğimiznokta,buhatatürlerinigruplarkenbunlarıparantez içinealmakvebirbirlerindenvirgülleayırmaktır. Bu arada, gördüğünüz gibi yukarıdaki programlar sadece bir kez çalışıp kapanıyor. Ama biz buprogramlarıtekrartekrarnasılçalıştırabileceğimizigayetiyibiliyoruz: while True: ilk_sayı = input("ilk sayı (Programdan çıkmak için q tuşuna basın): ") if ilk_sayı == "q": break ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except (ValueError, ZeroDivisionError): print("Bir hata oluştu!") print("Lütfen tekrar deneyin!") Python’dahatayakalamanınenyaygınyoluyukarıdagösterdiğimizgibikodlarıtry... except bloklarıiçinealmaktır.Programcılıkmaceranızınbüyükbölümündebuyapıyıkullanacaksınız. Amabazen,karşıkarşıyaolduğunuzdurumaveyaihtiyacınızagöretry... exceptbloklarının farklıvaryasyonlarınıkullanmanızgerekebilir.İşteşimdibizdebufarklıvaryasyonlarınneler olduğunuincelemeyeçalışacağız. 252 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 15.3 try... except... as... Bildiğinizgibi,Pythonbirprogramınçalışmasıesnasındahataüretirkençıktıdahatatürünün adıylabirliktekısabirhataaçıklamasıveriyor.Yanimeselaşöylebirçıktıüretiyor: ValueError: invalid literal for int() with base 10: ’f’ Burada ‘ValueError’ hata türünün adı, ‘invalid literal for int() with base 10: ‘f” ise hatanın açıklamasıdır.Eğeristersek,yazdığımızprogramdabuhataaçıklamasınaerişebiliriz.Dikkatlice bakın: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except ValueError as hata: print(hata) Buprogramıçalıştırıpsayıdeğerliolmayanbirverigirersekhataçıktısışöyleolacaktır: invalid literal for int() with base 10: ’f’ Gördüğünüz gibi, bu defa çıktıda hata türünün adı (ValueError) görünmüyor. Onun yerine sadecehataaçıklamasıvar. Diyelim ki kullanıcıya olası bir hata durumunda hem kendi yazdığınız hata mesajını, hem de özgün hata mesajını göstermek istiyorsunuz. İşte yukarıdaki yapı böyle durumlarda işe yarayabilir: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except ValueError as hata: print("Sadece sayı girin!") print("orijinal hata mesajı: ", hata) Bu arada, biraz önce yaptığımız gibi, hata türlerini grupladığınızda da bu yöntemi kullanabilirsiniz: ilk_sayı = input("ilk sayı: ") ikinci_sayı = input("ikinci sayı: ") try: sayı1 = int(ilk_sayı) sayı2 = int(ikinci_sayı) (sonrakisayfayadevam) 15.3. try... except... as... 253 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(sayı1, "/", sayı2, "=", sayı1 / sayı2) except (ValueError, ZeroDivisionError) as hata: print("Bir hata oluştu!") print("orijinal hata mesajı: ", hata) Burada except falancaHata as filanca yapısını kullanarak falancaHata’yı filanca olarak isimlendiriyor ve daha sonra bu ismi istediğimiz gibi kullanabiliyoruz. Böylece bütün hata türleri için hem kendi yazdığınız mesajı görüntüleyebiliyor, hem de özgün hata mesajını da çıktıyaeklediğimiziçin,kullanıcıyahatahakkındaenazındanbirfikirsahibiolmaimkanıvermiş oluyoruz. 15.4 try... except... else... Daha önce de dediğimiz gibi, Python’da hata yakalama işlemleri için çoğunlukla try... except... bloklarını bilmek yeterli olacaktır. İşlerimizin büyük kısmını sadece bu blokları kullanarak halledebiliriz. Ancak Python bize bu konuda, zaman zaman işimize yarayabilecek başka araçlar da sunmaktadır. İşte try... except... else... blokları da bu araçlardan biridir.Bubölümdekısacabubloklarınneişeyaradığındansözedeceğiz. Öncelikle try... except... else... bloğunun ne işe yaradığına bakalım. Esasında biz bu else deyimini daha önce de ‘koşullu ifadeler’ konusunu işlerken görmüştük. Buradaki kullanımıdazatenhemenhemenaynıdır.Diyelimkielimizdeşöylebirşeyvar: try: bölünen = int(input("bölünecek sayı: ")) bölen = int(input("bölen sayı: ")) print(bölünen/bölen) except ValueError: print("hata!") Burada eğer kullanıcı sayı yerine harf girerse ValueError hatası alırız. Bu hatayı except ValueError: ifadesiyle yakalıyoruz ve hata verildiğinde kullanıcıya bir mesaj göstererek programımızınçökmesiniengelliyoruz.Amabiliyoruzki,bukodlarıçalıştırdığımızdaPython’ın verebileceğitekhataValueErrordeğildir.Eğerkullanıcıbirsayıyı0’abölmeyeçalışırsaPython ZeroDivisionErroradlıhatayıverecektir.Dolayısıylabuhatayıdayakalamakiçinşöylebirşey yazabiliriz: try: bölünen = int(input("bölünecek sayı: ")) bölen = int(input("bölen sayı: ")) print(bölünen/bölen) except ValueError: print("Lütfen sadece sayı girin!") except ZeroDivisionError: print("Bir sayıyı 0’a bölemezsiniz!") Bu şekilde hem ValueError hatasını hem de ZeroDivisionError hatasını yakalamış oluruz. Bu kodların özelliği, except... bloklarının tek bir try... bloğunu temel almasıdır. Yani biz buradabütünkodlarımızıtekbirtry...bloğuiçinetıkıştırıyoruz.Bublokiçindegerçekleşen 254 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 hatalarıdadahasonratektekexcept...bloklarıyardımıylayakalıyoruz.Amaeğerbizistersek bukodlardaverilebilecekhatalarıgruplamayıdatercihedebiliriz: try: bölünen = int(input("bölünecek sayı: ")) bölen = int(input("bölen sayı: ")) except ValueError: print("Lütfen sadece sayı girin!") else: try: print(bölünen/bölen) except ZeroDivisionError: print("Bir sayıyı 0’a bölemezsiniz!") Burada yaptığımız şey şu: İlk try... except... bloğu yardımıyla öncelikle int(input()) fonksiyonu ile kullanıcıdan gelecek verinin sayı olup olmadığını denetliyoruz. Ardından bir else... bloğu açarak, bunun içinde ikinci try... except... bloğumuzu devreye sokuyoruz. Burada da bölme işlemini gerçekleştiriyoruz. Kullanıcının bölme işlemi sırasında 0 sayısını girmesi ihtimaline karşı da except ZeroDivisionError ifadesi yardımıyla olası hatayı göğüslüyoruz. Bu şekilde bir kodlamanın bize getireceği avantaj, hatalar üzerinde belli bir kontrol sağlamamıza yardımcı olmasıdır. Yukarıdaki kodlar sayesinde hatalara bir nevi ‘teker teker gelin!’ mesajı vermiş oluyoruz. Böylelikle her blok içinde sadece almayı beklediğimizhatayıkarşılıyoruz.Meselayukarıdailktry...bloğuiçindekidönüştürmeişlemi yalnızca ValueError hatası verebilir. else: bloğundan sonraki try... bloğunda yer alan işlemiseancakZeroDivisionErrorverecektir.Bizyukarıdakullandığımızyapısayesindeher bir hatayı tek tek ve yeri geldiğinde karşılıyoruz. Bu durumun aksine, bölümün ilk başında verdiğimiztry... exceptbloğundahemValueErrorhemdeZeroDivisionErrorhatalarının gerçekleşme ihtimali bulunuyor. Dolayısıyla biz orada bütün hataları tek bir try... bloğu içine sıkıştırmış oluyoruz. İşte else: bloğu bu sıkışıklığı gidermiş oluyor. Ancak sizi bir konuda uyarmak isterim: Bu yapı, her akla geldiğinde kullanılacak bir yapı değildir. Büyük programlarda bu tarz bir kullanım kodlarınızın darmadağın olmasına, kodlarınız üzerindeki denetimi tamamen kaybetmenize de yol açabilir. Sonunda da elinizde bölük pörçük bir kod yığını kalabilir. Zaten açıkça söylemek gerekirse try... except... else... yapısının çok genişbirkullanımalanıyoktur.Buyapıancakçoknadirdurumlardakullanılmayıgerektirebilir. Dolayısıylabuüçlüyapıyıhiçkullanmadanbirömrürahatlıklageçirebilirsiniz. 15.5 try... except... finally... try... except... else... yapılarının dışında, Python’ın bize sunduğu bir başka yapı da try... except... finally...yapılarıdır.Bunuşöylekullanıyoruz: try: ...bir takım işler... except birHata: ...hata alınınca yapılacak işlemler... finally: ...hata olsa da olmasa da yapılması gerekenler... finally.. bloğunun en önemli özelliği, programın çalışması sırasında herhangi bir hata gerçekleşse de gerçekleşmese de işletilecek olmasıdır. Eğer yazdığınız programda mutlaka 15.5. try... except... finally... 255 PythonBelgeleri,Yayım4.1.3 amamutlakaişletilmesigerekenbirkısımvarsa,okısmıfinally...bloğuiçineyazabilirsiniz. finally...bloğuözellikledosyaişlemlerindeişimizeyarayabilir.HenüzPython’dadosyalarla nasılçalışacağımızıöğrenmedik,amabenşimdiliksizeenazındandosyalarlaçalışmaprensibi hakkındabirşeylersöyleyeyim. GenelolarakPython’dadosyalarlaçalışabilmekiçinönceliklebilgisayardabulunanbirdosyayı okuma veya yazma kipinde açarız. Dosyayı açtıktan sonra bu dosyayla ihtiyacımız olan birtakım işlemler gerçekleştiririz. Dosyayla işimiz bittikten sonra ise dosyamızı mutlaka kapatmamız gerekir. Ancak eğer dosya üzerinde işlem yapılırken bir hata ile karşılaşılırsa dosyamızıkapatmaişleminigerçekleştirdiğimizbölümehiçulaşılamayabilir.İştefinally... bloğuböylebirdurumdaişimizeyarayacaktır: try: dosya = open("dosyaadı", "r") ...burada dosyayla bazı işlemler yapıyoruz... ...ve ansızın bir hata oluşuyor... except IOError: print("bir hata oluştu!") finally: dosya.close() Buradafinally...bloğuiçineyazdığımızdosya.close()ifadesidosyamızıgüvenlibirşekilde kapatmayayarıyor.Bublok,yazdığımızprogramhataversedevermesedeişletilecektir. 15.6 raise Bazen, yazdığımız bir programda, kullanıcının yaptığı bir işlem normal şartlar altında hata vermeyecek olsa bile biz ona ‘Python tarzı’ bir hata mesajı göstermek isteyebiliriz. Böyle bir durumda ihtiyacımız olan şey Python’ın bize sunduğu raise adlı deyimdir. Bu deyim yardımıyladurumaözgühatamesajlarıüretebiliriz.Birörnekverelim: bölünen = int(input("bölünecek sayı: ")) if bölünen == 23: raise Exception("Bu programda 23 sayısını görmek istemiyorum!") bölen = int(input("bölen sayı: ")) print(bölünen/bölen) Burada eğer kullanıcı 23 sayısını girerse, kullanıcıya bir hata mesajı gösterilip programdan çıkılacaktır. Biz bu kodlarda Exception adlı genel hata mesajını kullandık. Burada Exception yerine her istediğimizi yazamayız. Yazabileceklerimiz ancak Python’da tanımlı hata mesajları olabilir.ÖrneğinNameError,TypeError,ZeroDivisionError,IOError,vb... Birörnekverelim: tr_karakter = "şçğüöıİ" parola = input("Parolanız: ") (sonrakisayfayadevam) 256 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for i in parola: if i in tr_karakter: raise TypeError("Parolada Türkçe karakter kullanılamaz!") else: pass print("Parola kabul edildi!") Bu kodlar çalıştırıldığında, eğer kullanıcı, içinde Türkçe karakter geçen bir parola yazarsa kendisine TypeError tipinde bir hata mesajı gösteriyoruz. Eğer kullanıcının parolası Türkçe karakter içermiyorsa hiçbir şey yapmadan geçiyoruz ve bir sonraki satırda kendisine ‘Parola kabuledildi!’mesajınıgösteriyoruz. raise deyimini, bir hata mesajına ek olarak bir işlem yapmak istediğimizde de kullanabiliriz. Örneğin: try: bölünen = int(input("bölünecek sayı: ")) bölen = int(input("bölen sayı: ")) print(bölünen/bölen) except ZeroDivisionError: print("bir sayıyı 0’a bölemezsiniz") raise Burada, eğer kullanıcı bir sayıyı 0’a bölmeye çalışırsa, normal bir şekilde ZeroDivisionError hatası verilecek ve programdan çıkılacaktır. Ama bu hata mesajıyla birlikte kullanıcıya ‘bir sayıyı 0’a bölemezsiniz,’ uyarısını da gösterme imkanını elde edeceğiz. Yani burada except ZeroDivisionError bloğunu herhangi bir hatayı engellemek için değil, hataya ilave bilgi eklemek için kullanıyoruz. Bunu yapmamızı sağlayan şey tabii ki bu kodlar içinde görünen raiseadlıdeyimdir... 15.7 assert Bazen programımızda bir hata yaptığımızda bu hatayı bulmakta zorlanabiliriz. print fonksiyonunu kullanarak bu hatamızı bulmaya çalışabiliriz ancak bu da programımız ekrana çok fazla yazdırma işlemi yapıyorsa gözden kaçabilir. Böyle durumlarda assert ifadesini kullanabiliriz.assertifadesiaynızamandahatayükseltmeninkısabiryoludur.Ancakassert ifadesinikullanaraksadeceAssertionErrortüründebirhatayükseltebiliriz.Normalderaise kullanmamızdahadoğruolacaktır.Dediğimizgibiassertifadesihızlıbirşekildekodumuzdaki hatalarıbelirlemekiçinkullanılır.Şimdişöylebirkodumuzolduğunudüşünelim: giriş = input("Merhaba! Adın ne? ") if len(giriş) == 0: raise AssertionError("İsim bölümü boş.") print("Hoşgeldiniz.") Bukoduassertkullanarakşuşekildedeyazabilirdik: 15.7. assert 257 PythonBelgeleri,Yayım4.1.3 giriş = input("Merhaba! Adın ne? ") assert len(giriş) != 0 , "İsim bölümü boş." print("Hoşgeldiniz.") Dikkatedersenizassertifadesininşuşekildekullanıldığınıgörebilirsiniz: assert ifade , mesaj BuradaifadebirboolyaniTrueveyaFalseolabileceğigibi,(aynıif’dekigibi)boolfonksiyonu ile birlikte kullanılabilecek bir nesne de olabilir. Sonuç olarak eğer ifade’nin değeri True ise assert ifademiz çalışmayacak, False ise çalışacaktır. Yani assert ifademizin içine doğru olmasını istediğimiz durumu yazmalıyız ki eğer yanlış olursa hata yükseltsin. Zaten assert kelimesi“iddiaetmek”anlamınagelir.Yanibizassertifadesinikullanarakbirifadenindoğru olduğunu iddia ediyoruz, bu iddiamız yanlış ise Python bir hata yükseltiyor. Ayrıca assert ifademiz çalıştığında bir hata yükseleceği için program da sonlanacaktır, yani bu özelliği istemediğimizbirdurumgerçekleştiğindeprogramısonlandırmakiçindekullanabiliriz.mesaj isehataverildiğindeekranayazılmasınıistediğimizmesajdır.Tabiikiraiseifadesindeolduğu gibi burada da bir mesaj vermek zorunda değiliz. Yani assert ifadesini şu şekilde de kullanabiliriz: assert ifade Şimdibaştakiörneğimizegeridönersek: giriş = input("Merhaba! Adın ne? ") assert len(giriş) != 0 , "İsim bölümü boş." print("Hoşgeldiniz.") Bukodumuzuçalıştırdığımızda: Merhaba! Adın ne? Ali Hoşgeldiniz. >>> giriş değişkenimizin uzunluğu 0 olmadığı için bir hata verilmedi. Şimdi aynı kodu çalıştırıp hiçbirşeyyazmadanentertuşunabasalım: .. code-block:: pycon >>> Merhaba! Adın ne? Traceback (most recent call last): File "C:\Users\Kullanıcı\Desktop\assert_ifadesi.py", line 2, in <module> assert len(giriş) != 0 , "İsim bölümü boş." AssertionError: İsim bölümü boş. Gördüğünüz gibi assert ifadesini de bu şeklide kullanıyoruz. Burada bir şeye dikkat etmek lazımkiassertbirfonksiyondeğildir,buyüzdenparantezlerileşuşekildekullanılmamalıdır: assert(ifade) Bu kullanım hata vermeyecek olsa da farkında olmadan -ileride öğreneceğimiz bir konu- bir demetoluşturmuşoluyoruz. 258 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 Sonolarakbüyükbirprojeyazdığımızda,şuörnektekigibi: giriş = input("Merhaba! Adın ne? ") if len(giriş) == 0: raise AssertionError("İsim bölümü boş.") print("Hoşgeldiniz.") if ve raise ifadesi kullanmak yerine assert kullanmamızın iki avantajından bahsedelim. Öncelikle istediğiniz zaman geliştirme arayüzünüzün “Bul (Find)” özelliğini kullanarak bu anahtar kelimeleri bulup silebilir veya yorum satırı haline getirebilirsiniz. Bu özellik uzun bir kod yazdığımızda zaman kazanmamızı sağlar. İkinci olarak da python yorumlayıcısını komut satırından-Oparametresi(optimizeanlamınagelir)ileşuşekildeçağırdığımızda: C:\Users\User> python -O kod_dosyası kod_dosyası programımızdaki bütün assert ifadeleri python yorumlayıcısı tarafından yok sayılır ve hiçbiri çalıştırılmaz. Yani assert ifadelerinin hepsini yorum satırı haline getirmek istediğimizdebununileuğraşmakyerinebuözelliğikullanabiliriz. Konuilealakalıdahaçokörnekiçinburaya20 bakabilirsiniz. 15.8 Bütün Hataları Yakalamak Şimdiyekadaryaptığımızbütünörneklerdeexcept...bloğunubirhatamesajıadıylabirlikte kullandık.Yaniörneklerimizşunabenziyordu: try: ....birtakım işler... except ZeroDivisionError: ...hata mesajı... Yukarıdaki kod yardımıyla sadece ZeroDivisionError adlı hatayı yakalayabiliriz. Eğer yazdığımızprogrambaşkabirhatadahaveriyorsa,ohatamesajıyukarıdakibloklarınkapsamı dışında kalacaktır. Ama eğer istersek yukarıdaki kodu şu şekilde yazarak olası bütün hataları yakalayabiliriz: try: ....birtakım işler... except: ...hata mesajı... Gördüğünüz gibi, burada herhangi bir hata adı belirtmedik. Böylece Python, yazdığımız programdahangihataoluşursaoluşsunhepsiniyakalayabilecektir. Bu yöntem gözünüze çok pratik görünmüş olabilir, ama aslında hiç de öyle sayılmaz. Hatta oldukça kötü bir yöntem olduğunu söyleyebiliriz bunun. Çünkü bu tarz bir kod yazımının bazı dezavantajları vardır. Örneğin bu şekilde bütün hata mesajlarını aynı kefeye koyarsak, programımızda ne tür bir hata oluşursa oluşsun, kullanıcıya hep aynı mesajı göstermek zorunda kalacağız. Bu da, herhangi bir hata durumunda kullanıcıyı ne yapması gerektiği 20https://forum..com/t/assert-deyimi-nasil-kullanilir/231 15.8. BütünHatalarıYakalamak 259 PythonBelgeleri,Yayım4.1.3 konusundadoğrudüzgünbilgilendiremeyeceğimizanlamınageliyor.Yanikullanıcıbirhataya sebepolduğundatersliğinneredenkaynaklandığınıtamolarakkestiremeyecektir. Ayrıca,eğerkendimizbirprogramgeliştirirkensürekliolarakbutarzbiryazımıbenimsersek, kendi kodlarımızdaki hataları da maskelemiş oluruz. Dolayısıyla, Python yukarıdaki geniş kapsamlı except... bloğu nedeniyle programımızdaki bütün hataları gizleyeceği için, programımızdaki potansiyel aksaklıkları görme imkanımız olmaz. Dolayısıyla bu tür bir yapıdanolabildiğincekaçınmaktafaydavar.Ancakelbetteböylebirkodyazmanızıgerektiren birdurumladakarşılaşabilirsiniz.Örneğin: try: birtakım kodlar except ValueError: print("Yanlış değer") except ZeroDivisionError: print("Sıfıra bölme hatası") except: print("Beklenmeyen bir hata oluştu!") Burada olası bütün hata türlerini yakaladıktan sonra, bunların dışında bizim o anda öngöremediğimizbirhatanınoluşmasıihtimalinekarşıexcept:kodunukullanarakkullanıcıya genel bir hata mesajı göstermeyi tercih edebiliriz. Böylece beklenmeyen bir hata meydana gelmesidurumundadaprogramımızçökmekyerineçalışmayadevamedebilecektir. 15.9 Örnek Uygulama Hata yakalama konusunu bütün ayrıntılarıyla inceledik. Gelin şimdi isterseniz ufak bir örnek yapalım. Hatırlarsanızbirkaçbölümönceşöylebiruygulamayazmıştık: import sys _2x_metni = """ Python’ın 2.x sürümlerinden birini kullanıyorsunuz. Programı çalıştırabilmek için sisteminizde Python’ın 3.x sürümlerinden biri kurulu olmalı.""" _3x_metni = "Programa hoşgeldiniz." if sys.version_info.major < 3: print(_2x_metni) else: print(_3x_metni) Bu programın ne iş yaptığını biliyorsunuz. Bu program yardımıyla, kullanıcılarımızın bilgisayarlarındaki Python sürümünü kontrol edip, programımızın kullanılan sürüme göre tepkivermesinisağlıyoruz. Ancak burada çok ciddi bir problem var. Python’ın 2.7 öncesi sürümlerinde sys modülünün version_info() metodu farklı çıktılar verir. Mesela Python’ın 2.7 öncesi sürümlerinde version_info() metodunun major, minor veya micro gibi nitelikleri bulunmaz. Bu nitelikler 260 Bölüm15. HataYakalama PythonBelgeleri,Yayım4.1.3 Python programlama diline 2.7 sürümüyle birlikte geldi. Dolayısıyla yukarıdaki programı Python’ın 2.7 öncesi sürümlerinden biriyle çalıştıran kullanıcılarınız istediğiniz çıktıyı alamayacak, Python bu kullanıcalara şuna benzer bir hata mesajı göstererek programın çökmesinesebepolacaktır: AttributeError: ’tuple’ object has no attribute ’major’ Python’ın2.7öncesisürümlerininkuruluolduğubilgisayarlardadaprogramınızınenazından çökmemesivemakulbirçıktıverebilmesiiçinyukarıdakikodlarşöyleyazabilirsiniz: import sys _2x_metni = """ Python’ın 2.x sürümlerinden birini kullanıyorsunuz. Programı çalıştırabilmek için sisteminizde Python’ın 3.x sürümlerinden biri kurulu olmalı.""" _3x_metni = "Programa hoşgeldiniz." try: if sys.version_info.major < 3: print(_2x_metni) else: print(_3x_metni) except AttributeError: print(_2x_metni) Gördüğünüz gibi, AttributeError adlı hatayı vereceğini bildiğimiz kısmı bir try... except bloğu içine aldık. Eğer programımız AttributeError hatasını veriyorsa, programımızın çalıştırıldığı sistem Python’ın 2.7 sürümünden daha düşük bir sürümü kullanıyor demektir. Oyüzdenkullanıcıya_2x_metni’nigösteriyoruz. Elbetteyukarıdakiprogramıyazmanınçokdahadüzgünyollarıvardır.Amabizhatayakalama yöntemlerinin buna benzer durumlarda da bir alternatif olarak kullanılabileceğini bilelim. Ayrıca, dediğimiz gibi, try... except blokları yukarıdaki sorunun çözümü için en uygun araçlarolmasada,bazıdurumlardahatayıönlemeninmakultekyoludur. 15.9. ÖrnekUygulama 261 16 BÖLÜM Karakter Dizileri Buraya gelene kadar Python programlama diline ilişkin epey bilgi edindik. Artık yazdığımız programlarda input() fonksiyonu sayesinde kullanıcıyla iletişim kurabiliyor; if, elif, else deyimleri yardımıyla programlarımızın karar vermesini sağlayabiliyor; işleçler ve döngüler yoluylaprogramlarımızıistediğimizsayıdaçalıştırabiliyoruz.Eğerburayakadarolanbölümleri dikkatlice takip ettiyseniz, şu ana kadar öğrendiklerinize dayanarak, Python’ı giriş düzeyinde bildiğinizi rahatlıkla iddia edebilirsiniz. Zira şimdiye kadar öğrendiklerinizi kullanarak ufak tefekdeolsaişeyararprogramlaryazabilecekdurumdasınız. Buraya kadar öğrendiğimiz bilgiler Python programlama dilinin temellerini oluşturuyordu. Temel Python bilgilerini edindiğimize göre, artık başlangıç-orta düzey arası konuları incelemeyebaşlayabileceğiz. Bubölümde,öncekiderslerdeüstünkörübakıpgeçtiğimizbirkonuolankarakterdizileriniçok dahaderinlemesineelealacağız.Pythonprogramlamadiliiçindekiöneminedeniylebubölüm epeyuzunolacak. Aslındabizkarakterdizisikavramınınneolduğunubiliyoruz.Çokkababirşekildeifadeetmek gerekirse, karakter dizileri, adından da anlaşılacağı gibi, karakterlerin bir araya gelmesiyle oluşan bir dizidir. Karakter dizileri; tek, çift veya üç tırnak içinde gösterilen, öteki veri tiplerindendebutırnaklararacılığıylaayırtedilenözelbirveritipidir.Teknikolarakifadeetmek gerekirse,birnesneyitype()fonksiyonuyardımıylasorguladığımızda,eğer<class‘str’>çıktısı alıyorsakbunesnebirkarakterdizisidir. Her ne kadar ayrıntılarına girmemiş de olsak, dediğimiz gibi, biz karakter dizilerini daha ilk bölümlerden bu yana her fırsatta kullanıyoruz. Dolayısıyla bu veri tipinin ne olduğu konusundabirsıkıntımızyok.Bubölümde,şimdiyekadarkarakterdizileriileilgiliöğrendiğimiz şeylereekolarak,karakterdizilerinmetotlarındandasözedeceğiz. Pekibu‘metot’denenşeydeneoluyor? Kabaca ifade etmek gerekirse, metotlar Python’da nesnelerin niteliklerini değiştirmemizi, sorgulamamızı veya bu nesnelere yeni özellikler katmamızı sağlayan araçlardır. Metotlar sayesindekarakterdizileriniistediğimizgibieğipbükebileceğiz. Elbette bu bölümde bahsedeceğimiz tek şey karakter dizilerinin metotları olmayacak. Bu 262 PythonBelgeleri,Yayım4.1.3 bölümde aynı zamanda karakter dizilerinin yapısı ve özelliklerine dair söyleyeceklerimiz de olacak. Python’da şimdiye kadar yapabildiğimiz şeylerin sizi tatmin etmekten uzak olduğunu, daha fazlasını yapabilmek için sabırsızlandığınızı tahmin edebiliyorum. O halde ne duruyoruz, hiç vakitkaybetmedenyolakoyulalım. 16.1 Karakter Dizilerinin Öğelerine Erişmek Pythonileprogramlamayaparkenkarakterdizileriileikişekildekarşılaşabilirsiniz:Birincisi,bir karakterdizisinidoğrudankendiniztanımlamışolabilirsiniz.İkincisi,karakterdizisisizebaşka bir kaynak aracılığıyla gelmiş olabilir (mesela input() fonksiyonu yardımıyla kullanıcıdan aldığınızbirveri). Python’da kendi tanımladığınız ya da herhangi başka bir kaynaktan gelen karakter dizilerine erişmeninbirkaçfarklıyoluvardır.Örneğin: >>> nesne = "karakter dizisi" Burada değeri “karakter dizisi” olan nesne adlı bir değişken tanımladık. Yazdığımız programlardabudeğişkeneerişmekiçin,değişkeninadınıkullanmamızyeterlidir.Örneğin: >>> print(nesne) Bukomutbizekarakterdizisinintamamınıverecektir. Bir karakter dizisini yukarıda gördüğümüz gibi kendimiz tanımlayabiliriz. Bunun dışında, meselainput()fonksiyonuylakullanıcıdanaldığımızverilerindebirerkarakterdizisiolacağını biliyoruz: veri = input("Herhangi bir şey: ") Tıpkı kendi tanımladığımız karakter dizilerinde olduğu gibi, kullanıcıdan gelen karakter dizilerinideaşağıdakikomutyardımıylaekrandagörüntüleyebiliriz: print(veri) Bukomutdabizeverideğişkeninintuttuğukarakterdizisinintamamınıverecektir. Ayrıcaistersekbukarakterdizilerinibirfordöngüsüiçinealabilir,böylecebudizininöğelerine tektekdeerişebiliriz: for karakter in nesne: print(karakter) fordöngüsüyleeldeettiğimizbuetkiyişukodlaryardımıyladaeldeedebileceğimizigayetiyi biliyorolmalısınız: print(*nesne, sep="\n") Önceki derslerde verdiğimiz örneklerden de bildiğiniz gibi, karakter dizilerinin öğelerine yukarıdakiyöntemlerletektekerişebilmemizsayesindeherhangibirişlemikarakterdizilerinin bütünöğelerinebirçırpıdauygulayabiliyoruz.Mesela: 16.1. KarakterDizilerininÖğelerineErişmek 263 PythonBelgeleri,Yayım4.1.3 nesne = "123456789" for n in nesne: print(int(n) * 2) Burada nesne değişkeni içindeki sayı değerli karakter dizilerini n olarak adlandırdıktan sonra, n değişkenlerinin her birini tek tek 2 sayısı ile çarptık. Yani çarpma işlemini karakter dizisinin bütün öğelerine tek seferde uygulayabildik. Bu arada, yukarıdaki örnekte nesne değişkeninin her bir öğesini for döngüsü içinde int() fonksiyonu yardımıyla tam sayıya çevirdiğimizi görüyorsunuz. Daha önce de defalarca söylediğimiz gibi, Python’da o anda elinizdeolanverinintipinibilmenizçokönemlidir.Eğerkendiyazdığınızveyameselainput() fonksiyonundan gelen bir verinin karakter dizisi olduğunu bilmezseniz yukarıdaki kodları şu şekildeyazmagafletinedüşebilirsiniz: nesne = "123456789" for n in nesne: print(n * 2) Bukodlarçalıştırıldıktansonrahiçbeklemediğinizsonuçlarverecektir: 11 22 33 44 55 66 77 88 99 Gördüğünüz gibi, aslında nesne içindeki öğeleri 2 ile çarpmak isterken, biz her bir öğeyi iki kez ekrana yazdırmış olduk. Çünkü bildiğiniz gibi karakter dizileri ile aritmetik işlemler yapamıyoruz.Eğersayıdeğerlikarakterdizileriarasındaaritmetikişlemyapacaksaköncelikle bu karakter dizilerini sayıya çevirmemiz gerekir. Ayrıca gerçek bir program içinde yukarıdaki gibi bir durumun ne kadar yıkıcı sonuçlar doğuracabileceğini düşünün. Yukarıdaki program çalışmasırasındahiçbirhatavermeyeceğiiçin,sizprogramınızındüzgünçalıştığınızannederek hayatınıza devam edeceksiniz. Ama belki de yukarıdaki sinsi hata yüzünden, programınızı kullananbirşirketveri,zamanveparakaybınauğrayacak. Yukarıdaki örneklerde bir şey daha dikkatinizi çekmiş olmalı: Gördüğünüz gibi, karakter dizisinin öğelerine erişirken bu öğelerin tamamını elde ediyoruz. Mesela print(nesne) komutunuverdiğimizdeveyanesnedeğişkeninibirdöngüiçinealdığımızdasonuçolarakelde ettiğimiz şey, ilgili karakter dizisinin tamamıdır. Yani aslında karakter dizisinin hangi öğesine erişeceğimizi seçemiyoruz. Peki ya biz bir karakter dizisinin öğelerinin tamamına değil de, sadece tek bir öğesine erişmek istersek ne yapacağız? Mesela yukarıdaki örnekte nesne adlı değişkeniçindekisayılarıntamamınıdeğildesadecetekbiröğesini(veyabellibirölçütegöre yalnızcabazıöğelerini)2ileçarpmakisterseknasılbiryolizleyeceğiz? Python’dakarakterdizilerininiçindekiöğelerinbirsırasıvardır.Örneğin“Python”dediğimizde, bu karakter dizisinin ilk öğesi olan “P” karakterinin sırası 0’dır. “y” karakteri ise 1. sıradadır. Aynışekildedevamedersek,“t”karakteri2.,“h”karakteri3.,“o”karakteri4.,“n”karakteriise 264 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 5.sıradayeralır. Buanlattığımızsoyutdurumubirörneklesomutlaştırmayaçalışalım: Dedik ki, “Python” gibi bir karakter dizisinin her bir öğesinin belli bir sırası vardır. İşte eğer biz bu karakter dizisinin bütün öğelerini değil de, sadece belli karakterlerini almak istersek, karakterdizisindekiöğelerinsahipolduğubusıradanyararlanacağız. Diyelim ki “Python” karakter dizisinin ilk karakterini almak istiyoruz. Yani biz bu karakter dizisininsadece“P”harfineulaşmayıamaçlıyoruz. Buisteğimizinasılyerinegetirebileceğimizibasitbirörneküzerindegöstermeyeçalışalım: >>> kardiz = "Python" Burada değeri “Python” olan kardiz adlı bir değişken tanımladık. Şimdi bu karakter dizisinin ilköğesineerişeceğiz: >>> kardiz[0] ’P’ Burada yaptığımız işleme çok dikkat edin. Karakter dizisinin istediğimiz bir öğesine ulaşmak için,ilgiliöğeninsırasınıköşeliparantezleriçindebelirttik.Bizbuörnektekarakterdizisininilk öğesineulaşmakistediğimiziçinköşeliparanteziçinde0sayısınıkullandık. Şimdi de, ilk verdiğimiz örnekteki nesne değişkeni içinde yer alan sayılar arasından sadece birini2ileçarpmakistediğimizidüşünelim: >>> nesne = "123456789" >>> int(nesne[1]) * 2 4 Buradadaönceliklenesnedeğişkenininbirincisırasındayeralanöğeyi(dikkat:sıfırıncısırada yeralanöğeyideğil!)eldeetmekiçinköşeliparantezleriçinde1sayısınıkullandık.Dahasonra int() fonksiyonu yardımıyla bu karakter dizisini tam sayıya çevirdik, ki bununla aritmetik işlem yapabilelim... Son olarak da elimizdeki tam sayıyı 2 ile çarparak istediğimiz sonuca ulaştık. Elbetteyukarıdakikodlarışöyledeyazabilirdik: >>> nesne = "123456789" >>> sayı = int(nesne[1]) >>> sayı * 2 4 Belkifarkındasınız,belkidedeğilsiniz,amaaslındaşunoktadakarakterdizilerininçokönemli birözelliğiilekarşıkarşıyayız.Gördüğünüzgibi,yukarıdabahsettiğimizsırakavramısayesinde Python’da karakter dizilerinin bütün öğelerine tek tek ve herhangi bir sıra gözetmeksizin erişmemizmümkün.Meselayukarıdakiilkörnektekardiz[0]gibibiryapıkullanarakkarakter dizisininsıfırıncı(yaniilk)öğesini,nesne[1]gibibiryapıkullanarakdakarakterdizisininbirinci (yaniaslındaikinci)öğesinialabildik. Buyapınınmantığınıkavramakiçinşuörnekleridikkatliceinceleyin: 16.1. KarakterDizilerininÖğelerineErişmek 265 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "Python" >>> kardiz[0] ’P’ >>> kardiz[1] ’y’ >>> kardiz[3] ’h’ >>> kardiz[5] ’n’ >>> kardiz[2] ’t’ >>> kardiz[4] ’o’ >>> nesne = "123456789" >>> nesne[0] ’1’ >>> nesne[1] ’2’ >>> nesne[2] ’3’ >>> nesne[3] ’4’ >>> nesne[4] ’5’ >>> nesne[5] (sonrakisayfayadevam) 266 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’6’ >>> nesne[6] ’7’ >>> nesne[7] ’8’ >>> nesne[8] ’9’ Buradaşöylebirformülyazabiliriz: karakter_dizisi[öğe_sırası] Bu formülü uygulayarak karakter dizilerinin her bir öğesine tek tek erişmemiz mümkün. Burada çok önemli bir noktaya daha dikkatinizi çekmek isterim. Yukarıdaki örneklerden de gördüğünüz gibi, Python’da öğe sıralaması 0’dan başlıyor. Yani bir karakter dizisinin ilk öğesinin sırası 0 oluyor. Python programlama dilini özellikle yeni öğrenenlerin en sık yaptığı hatalardan biri de bir karakter dizisinin ilk öğesine ulaşmak için 1 sayısını kullanmalarıdır. Aslaunutmayın,Pythonsaymayaherzaman0’danbaşlar.Dolayısıylabirkarakterdizisininilk öğesinin sırası 0’dır. Eğer ilk öğeye ulaşayım derken 1 sayısını kullanırsanız ulaştığınız öğe ilk öğedeğil,ikinciöğeolacaktır.Buayrıntıyıgözdenkaçırmamayadikkatetmelisiniz. Karakterdizilerininöğelerinetektekerişirkendikkatetmemizgerekenönemlinoktalardanbiri de,öğesırasıbelirtirken,karakterdizisinintoplamuzunluğudışınaçıkmamaktır.Yanimesela 7 karakterlik bir karakter dizimiz varsa, bu karakter dizisinin son öğesinin sırası 6 olacaktır. Çünkü biliyorsunuz, Python saymaya 0’dan başlıyor. Dolayısıyla ilk karakterin sırası 0 olacağı için,7karakterlikbirkarakterdizisindesonöğeninsırası6olacaktır.Örneğin: >>> kardiz = "" >>> len(kardiz) 7 Gördüğünüz gibi, “” adlı karakter dizisinin uzunluğu 7. Yani bu karakter dizisi içinde 7 adetkaraktervar.Bukarakterdizisiniincelemeyedevamedelim: >>> kardiz[0] ’i’ Dediğimizgibi,karakterdizisininilköğesininsırası0.Dolayısıylasonöğeninsırası6olacaktır: >>> kardiz[6] ’a’ Budurumuşöyleformüleedebiliriz: 16.1. KarakterDizilerininÖğelerineErişmek 267 PythonBelgeleri,Yayım4.1.3 >>> kardiz[len(kardiz)-1] Yani; Birkarakterdizisininuzunluğunun1eksiği,okarakterdizisininsonöğesiniverir. Yukarıdakiformülüeğerşöyleyazsaydıkhataalırdık: >>> kardiz[len(kardiz)] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: string index out of range Çünkülen(kardiz)kodubizekarakterdizisininuzunluğunuveriyor.Yaniyukarıdaki“” karakter dizisini göz önüne alırsak, len(kardiz) çıktısı 7 olacaktır. Dolayısıyla “” karakterdizisininsonöğesineulaşmakistersekbudeğerin1eksiğinialmamızgerekiyor.Yani len(kardiz)-1. Şuanakadaröğesırasıolarakhepartıdeğerlisayılarkullandık.Ancakisterseköğesırasıolarak eksideğerlisayılarıdakullanabiliriz.Eğerbirkarakterdizisineöğesırasıolarakeksideğerlibir sayıverirsekPythonokarakterdizisinisondanbaşadoğruokumayabaşlayacaktır.Yani: >>> kardiz[-1] ’a’ Gördüğünüzgibi-1sayısıkarakterdizisiniterstenokuyup,sondanbaşadoğruilköğeyiveriyor. Dolayısıyla,yukarıdaanlattığımızlen(kardiz)-1yöntemininyanısıra,-1sayısınıkullanarakda karakterdizilerininsonkarakterinieldeedebiliyoruz.Birdeşunabakalım: >>> kardiz[-2] ’z’ Dediğimiz gibi, eksi değerli sayılar karakter dizisindeki karakterleri sondan başa doğru elde etmemizisağlar.Dolayısıyla-2sayısı,karakterdizisindesondanbiröncekikarakteriverecektir. Karakter dizilerinin öğelerine tek tek erişmek amacıyla öğe sırası belirtirken, karakter dizisinin toplam uzunluğu dışına çıkmamamız gerektiğini söylemiştik. Peki karakter dizisinin uzunluğunu aşan bir sayı verirsek ne olur? Ne olacağını yukarıdaki örneklerden birinde görmüştükaslında.Amakonununönemindendolayıbirkezdahatekraredelim. >>> kardiz = "" >>> kardiz[7] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: string index out of range ...veya: 268 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 >>> kardiz[-8] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: string index out of range Eğer karakter dizisinin uzunluğunu aşan bir sayı belirtirsek Python bize IndexError türünde birhatamesajıverecektir. Gördüğünüz gibi, kardiz[0], kardiz[1], kardiz[2], vb. komutlarla karakter dizisinin öğelerine erişebiliyoruz. Burada öğe sıralarını tek tek yazmak yerine range() fonksiyonunu kullanarakdaöğeleretektekerişebilirsiniz: for i in range(7): print(kardiz[i]) Bu kodlarda, kardiz[0], kardiz[1], kardiz[2] şeklinde öğe sıralarını tek tek elle yazmak yerine, range(7) aralığındaki sayıları bir for döngüsüne alıyoruz. Böylece Python kardiz[öğe_sırası]gibibiryapıiçindeöğe_sırasıyerinerange(7)aralığındakibütünsayıları (yani0,1,2,3,4,5,6sayılarını)tektekuyguluyor. Buradaaklınızahemenşöylebirsorugelmişolabilir: Biz kendi tanımladığımız karakter dizisinin uzunluğunun toplam 7 karakter olduğunu bildiğimiz için yukarıdaki örnekte range() fonksiyonunu range(7) şeklinde kullanabildik. Ama başka kaynaktan gelen bir karakter dizisinin uzunluğununasılbileceğiz? Aslında bu sorunun cevabı çok basit. Uzunluğunu bilmediğiniz karakter dizileri için range() fonksiyonuyla birlikte len() fonksiyonundan yararlanabilirsiniz. Nasıl mı? Hemen bir örnek verelim: for karakter in range(len(kardiz)): print(kardiz[karakter]) Burada range() fonksiyonuna verdiğimiz len(kardiz) parametresine dikkatlice bakın. Biz kardiz adlı değişkenin tuttuğu karakter dizisinin 7 karakterden oluştuğunu biliyoruz. Ama eğer bu karakter dizisini biz belirlememişsek, karakter dizisinin tam olarak kaç karakterden oluşacağını bilemeyiz. Bu kodlarda len(kardiz) ifadesini kullanarak, sabit bir değer belirlemektenkaçınmışoluyoruz.Böylece,meselakullanıcıdanaldığımızbirkarakterdizisinin kaçkarakterdenoluştuğunubelirlemegöreviniPython’abırakmışoluyoruz.Karakterdizisinin uzunluğu ne ise (len(kardiz)), Python range() fonksiyonuna o sayıyı parametre olarak kendisiatayacaktır. Yukarıdaki durumu daha iyi anlayabilmek için bir örnek daha verelim. Diyelim ki kullanıcıya isminisorup,kendisineşöylebirçıktıvermekistiyorsunuz: isminizin 1. harfi ... isminizin 2. harfi ... isminizin 3. harfi ... ... Bunuyapabilmekiçinşöylebiruygulamayazabilirsiniz: 16.1. KarakterDizilerininÖğelerineErişmek 269 PythonBelgeleri,Yayım4.1.3 isim = input("isminiz: ") for i in range(len(isim)): print("isminizin {}. harfi: {}".format(i, isim[i])) Gördüğünüz gibi, kullanıcının girdiği kelimenin uzunluğu kaç ise o sayı otomatik olarak range() fonksiyonuna atanıyor. Diyelim ki kullanıcı Ferhat ismini girmiş olsun. Bu kelimede toplam6karaktervar.DolayısıylaPythonforsatırınışöyleyorumlayacaktır: for i in range(6): ... Pythonfordöngüsününilkturundaşöylebirişlemgerçekleştirir: print("isminizin {}. harfi: {}".format(0, isim[0])) İkinciturdaiseşöylebirişlem: print("isminizin {}. harfi: {}".format(1, isim[1])) Bu döngü 6 sayısına gelene kadar devam eder. Burada i adlı değişkenin değerinin her döngüde nasıl değiştiğine dikkat edin. Python i adını verdiğimiz değişkene, for döngüsünün her turunda sırasıya 0, 1, 2, 3, 4 ve 5 sayılarını atayacağı için isim adlı değişkenin öğeleri isim[öğe_sırası] formülü sayesinde tek tek ekrana dökülecektir. Yalnız bu kodların çıktısında iki nokta dikkatinizi çekmiş olmalı. Birincisi, isminizin Şekil 1: Annenizin kızlık soyadının 0. harfi 0. harfi f gibi bir çıktıyı kullanıcılarınız [kaynak?] yadırgayabilir. Çünkü ‘0. harf’ çok yapay duran bir ifade. Onun yerine ilk harfi ‘1. harf’ olarak adlandırmamız çok daha mantıklı olacaktır.Bununiçinkodlarınızaşubasiteklemeyiyapabilirsiniz: isim = input("isminiz: ") for i in range(len(isim)): print("isminizin {}. harfi: {}".format(i+1, isim[i])) Burada ilk i değişkeninin değerini 1 sayı artırdık. Böylece 0 sayısı 1’e, 1 sayısı 2’ye, 2 sayısı 3’e... dönüşmüşoldu.Buşekildekullanıcılarınızaçokdahadoğalgörünenbirçıktıverebilmiş oluyorsunuz. Eğer bu işlemi yapmazsanız, kullanıcılarınızın ‘doğal görünmeyen’ bir çıktı almalarınınyanısıra,programınızınverdiğiçıktıkimidurumlardaepeyyanıltıcıdaolabilir... 21https://pic.twitter.com/u1IE6Mma 270 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 16.2 Karakter Dizilerini Dilimlemek Bir önceki bölümde bir karakter dizisinin istediğimiz öğesini, o öğenin sırasını belirterek nasıl elde edebileceğimizi gördük. Bu bölümde de benzer bir şey yapacağız. Ama burada yapacağımız şey, bir önceki bölümde yaptığımız işleme göre biraz daha kapsamlı bir işlem olacak. Bu bölümde karakter dizilerini ‘dilimlemekten’ söz edeceğiz. Peki ‘dilimlemek’ derken neyi kastediyoruz? Aslında burada gerçek anlamda ‘karpuz gibi dilimlemekten’ söz ediyoruz... Şu örnek,nedemekistediğimizidahanetortayakoyacaktır: >>> site = "www..com" >>> site[4:11] ’’ >>> site[12:15] ’com’ >>> site[0:3] ’www’ Gördüğünüz gibi, karakter dizisine köşeli parantez içinde bazı değerler vererek bu karakter dizisini dilim dilim ayırdık. Peki bunu nasıl yaptık? Yukarıdaki örneklerde şöyle bir yapı gözümüzeçarpıyor: karakter_dizisi[alınacak_ilk_öğenin_sırası:alınacak_son_öğenin_sırasının_bir_ fazlası] ˓→ Buformülüçokbasitbirörneğeuygulayalım: >>> karakter_dizisi = "istanbul" >>> karakter_dizisi[0:3] ’ist’ Burada alacağımız ilk öğenin sıra numarası 0. Yani “istanbul” karakter dizisindeki ‘i’ harfi. Alacağımız son öğenin sıra numarasının 1 fazlası ise 3. Yani 2. sıradaki ‘t’ harfi. İşte karakter_dizisi[0:3] dediğimizde, Python 0. öğe ile 3. öğe arasında kalan bütün öğeleri bize verecektir. Bizim örneğimizde bu aralıktaki öğeler ‘i’, ‘s’ ve ‘t’ harfleri. Dolayısıyla Python bize‘istanbul’kelimesindeki‘ist’kısmınıdilimleyipveriyor. Bubilgilerikullanarakşöylebiruygulamayazalım: site1 = "www.google.com" site2 = "www..com" site3 = "www.yahoo.com" site4 = "www.gnu.org" (sonrakisayfayadevam) 16.2. KarakterDizileriniDilimlemek 271 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for isim in site1, site2, site3, site4: print("site: ", isim[4:-4]) BuörnekPython’dadilimlemeişlemlerininyapısıveözelliklerihakkındabizeepeybilgiveriyor. Gördüğünüz gibi, hem artı hem de eksi değerli sayıları kullanabiliyoruz. Önceki bölümden hatırlayacağınızgibi,eğerverilensayıeksideğerliysePythonkarakterdizisinisağdansola(yani sondan başa doğru) okuyacaktır. Yukarıdaki örnekte isim[4:-4] yapısını kullanarak, site1, site2, site3, site4 adlı karakter dizilerini, ilk dört ve son dört karakterler hariç olacak şekilde dilimledik.Böyleceelimizdeilkdörtvesondörtkarakterarasındakibütünkarakterlerkalmış oldu.Yani“google”,“”,“yahoo”ve“gnu”. Bütünbuanlattıklarımızıdahaiyianlayabilmekiçinbirörnekdahaverelim: ata1 = "Akıllı bizi arayıp sormaz deli bacadan akar!" ata2 = "Ağa güçlü olunca kul suçlu olur!" ata3 = "Avcı ne kadar hile bilirse ayı da o kadar yol bilir!" ata4 = "Lafla pilav pişse deniz kadar yağ benden!" ata5 = "Zenginin gönlü oluncaya kadar fukaranın canı çıkar!" Burada beş adet atasözü verdik. Bizim görevimiz, bu atasözlerinin sonunda bulunan ünlem işaretleriniortadankaldırmak: for ata in ata1, ata2, ata3, ata4, ata5: print(ata[0:-1]) Burada yaptığımız şey şu: ata1, ata2, ata3, ata4 ve ata5 adlı değişkenlerin her birini ata olarak adlandırdıktan sonra ata adlı değişkenin en başından en sonuna kadar olan kısmı dilimleyip aldık. Yani ata[0] ile ata[-1] arasında kalan bütün karakterleri elde etmiş olduk. Peki bu ünlem işaretlerini kaldırdıktan sonra bunların yerine birer nokta koymak istersek ne yapacağız? Odaçokbasitbirişlem: for ata in ata1, ata2, ata3, ata4, ata5: print(ata[0:-1] + ".") Gördüğünüzgibi,sonkarakterolanünlemişaretiniattıktansonraonunyerinebirnoktaişareti koymakiçinyaptığımıztekşey,dilimlediğimizkarakterdizisine,artıişareti(+)yardımıylabir. karakterieklemektenibarettir. Böylece karakter dizilerini nasıl dilimleyeceğimizi öğrenmiş olduk. Bu konuyu kapatmadan önce dilimlemeye ilişkin bazı ayrıntılardan söz edelim. Diyelim ki elimizde şöyle bir karakter dizisivar: >>> kardiz = "Sana Gül Bahçesi Vadetmedim" Bukarakterdizisiiçindensadece‘Sana’kısmınıdilimlemekiçinşöylebirşeyyazabileceğimizi biliyorsunuz: >>> kardiz[0:4] ’Sana’ 272 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 Burada 0. karakterden 4. karaktere kadar olan kısmı dilimlemiş oluyoruz. Python bize bu tür durumlarda şöyle bir kolaylık sağlar: Eğer karakter dizisi içinden alınan ilk karakterin sırasını gösteren sayı 0 ise, bu sayıyı belirtmesek de olur. Yani kardiz[0:4] kodunu şöyle de yazabiliriz: >>> kardiz[:4] ’Sana’ Gördüğünüzgibi,ilksırasayısınıyazmazsakPythonilksayıyı0kabulediyor. Şimdideaynıkarakterdizisiiçindeki‘Vadetmedim’kısmınıdilimlemeyeçalışalım: >>> kardiz[17:27] ’Vadetmedim’ Burada da 17. karakter ile 27. karakter arasında kalan bütün karakterleri dilimledik. Tıpkı, alacağımız ilk karakterin sırası 0 olduğunda bu sayıyı belirtmemize gerek olmadığı gibi, alacağımızsonkarakterinsırasıkarakterdizisininsonuncukarakterinedenkgeliyorsaosayıyı dayazmamızagerekyok.Yaniyukarıdakikardiz[17:27]kodunuşöyledeyazabiliriz: >>> kardiz[17:] ’Vadetmedim’ Python’dakibudilimlemeözelliğinikullanarakkarakterdizileriniistediğinizgibieğipbükebilir, eviripçevirebilirsiniz. Python’dakibudilimlemeyapısıilkbakıştagözünüzebirazkarmaşıkmışgibigörünebilir.Ama aslındahiçdeöyledeğildir.Buyapınınmantığınıbirkezkavradıktansonrakodlarınızıhatasız birşekildeyazabilirsiniz. Dilimleme yapısını daha iyi anlayabilmek için kendi kendinize bazı denemeler yapmanızı tavsiyeederim.Buyapınınnasılçalıştığınıanlamanıneniyiyolubolbolörnekkodyazmaktır. 16.3 Karakter Dizilerini Ters Çevirmek Eğer amacınız bir karakter dizisini ters çevirmek, yani karakter dizisi içindeki her bir öğeyi terstenyazdırmaksabirazönceöğrendiğimizdilimlemeyönteminikullanabilirsiniz.Dikkatlice bakın: >>> kardiz[::-1] ’midemtedaV iseçhaB lüG anaS’ Gördüğünüz gibi, “Sana Gül Bahçesi Vadetmedim” adlı karakter dizisi içindeki bütün karakterlersondanbaşadoğruekranadizildi. AslındabukomutlaPython’aşöylebiremirvermişoluyoruz: kardizdeğişkeniiçindekibütünkarakterleri,ensonkarakterdenilkkarakterekadar sondanbaşadoğrutektekekranayazdır! 16.3. KarakterDizileriniTersÇevirmek 273 PythonBelgeleri,Yayım4.1.3 Bildiğiniz gibi, eğer almak istediğimiz karakter, dizi içindeki ilk karakterse bu karakterin dizi içindeki sırasını belirtmemize gerek yok. Aynı şekilde, eğer almak istediğimiz karakter, dizi içindeki son karakterse, bu karakterin de dizi içindeki sırasını belirtmemize gerek yok. İşte yukarıdakiörnektebukuraldanyararlandık. Eğer bir karakter dizisinin tamamının değil de, sadece belli bir kısmının ters çevrilmiş halini eldeetmekistiyorsanızelbetteyapmanızgerekenşey,almakistediğinizilkvesonkarakterlerin sırasınıparanteziçindebelirtmekolacaktır.Meselayukarıdakikarakterdizisindesadece‘Gül’ kelimesinitersçevirmekistersekşöylebirşeyyazabiliriz: >>> kardiz[7:4:-1] ’lüG’ Yukarıdakiörnek,karakterdizisidilimlemeyeilişkinolarakbizebazıbaşkaipuçlarıdaveriyor. Gördüğünüz gibi, köşeli parantez içinde toplam üç adet parametre kullanabiliyoruz. Yani formülümüzşöyle: kardiz[ilk_karakter:son_karakter:atlama_sayısı] Birörnekverelim: >>> kardiz = "istanbul" >>> kardiz[0:8:1] ’istanbul’ Burada“istanbul”adlıkarakterdizisininbütünöğelerinibirerbirerekranadöktük.Birdeşuna bakalım: >>> kardiz[0:8:2] ’itnu’ Burada ise “istanbul” adlı karakter dizisinin bütün öğelerini ikişer ikişer atlayarak ekrana döktük.Yanibirkarakteryazıpbirkarakteratladık(istanbul). Python’ınkurallarıgereğinceyukarıdakikoduşöyleyazabileceğimizidebiliyorsunuz: >>> kardiz[::2] ’itnu’ Eğerkarakterdizisinitersçevirmekistiyorsak,yukarıdakiörneğieksideğerlibiratlamasayısı ileyazmamızgerekir: >>> kardiz = "istanbul" >>> kardiz[::-1] ’lubnatsi’ >>> kardiz[::-2] (sonrakisayfayadevam) 274 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’lbas’ Dediğimizgibi,yukarıdakiyöntemikullanarakkarakterdizilerinitersçevirebilirsiniz.Amaeğer istersenizreversed()adlıbirfonksiyondandayararlanabiliriz. Gelelimbufonksiyonunnasılkullanılacağına... Önceşöylebirdenemeyapalım: >>> reversed("Sana Gül Bahçesi Vadetmedim") <reversed object at 0x00E8E250> Gördüğünüz gibi, bu fonksiyonu düz bir şekilde kullandığımızda bize bir ‘reversed’ nesnesi vermekleyetiniyor.Bunabenzerbirolguylarange()fonksiyonundadakarşılaşmıştık: >>> range(10) range(0, 10) Hatırlarsanız,range(10)gibibirkomutuniçeriğinigörebilmekiçinbukomutüzerindebirfor döngüsükurmamızgerekiyordu: for i in range(10): print(i) ...veya: print(*range(10)) Aynıdurumreversed()fonksiyonuiçindegeçerlidir: for i in reversed("Sana Gül Bahçesi Vadetmedim"): print(i, end="") ...veya: print(*reversed("Sana Gül Bahçesi Vadetmedim"), sep="") Dilimleme veya reversed() fonksiyonunu kullanma yöntemlerinden hangisi kolayınıza geliyorsaonutercihedebilirsiniz. 16.4 Karakter Dizilerini Alfabe Sırasına Dizmek Python’dakarakterdizilerininöğelerinetektekulaşma,öğeleridilimlemevetersçevirmenin yanısıra, bu öğeleri alfabe sırasına dizmek de mümkündür. Bunun için sorted() adlı bir fonksiyondanyararlanacağız: >>> sorted("kitap") [’a’, ’i’, ’k’, ’p’, ’t’] 16.4. KarakterDizileriniAlfabeSırasınaDizmek 275 PythonBelgeleri,Yayım4.1.3 Nasılinput()fonksiyonuçıktıolarakbirkarakterdizisivelen()fonksiyonubirsayıveriyorsa, sorted() fonksiyonu da bize çıktı olarak, birkaç bölüm sonra inceleyeceğimiz ‘liste’ adlı bir veritipiverir. Amatabiieğeristersenizbuçıktıyıalıştığınızbiçimdealabilirsiniz: print(*sorted("kitap"), sep="") ...veya: for i in sorted("kitap"): print(i, end="") Birörnekdahaverelim: >>> sorted("elma") [’a’, ’e’, ’l’, ’m’] Gördüğünüz gibi, sorted() fonksiyonunu kullanmak çok kolay, ama aslında bu fonksiyonun önemlibirproblemivar.Dikkatlicebakın: >>> sorted("çiçek") [’e’, ’i’, ’k’, ’ç’, ’ç’] Burada Türkçe bir karakter olan ‘ç’ harfinin düzgün sıralanamadığını görüyoruz. Bu sorun bütünTürkçekarakterleriçingeçerlidir. Busorunuaşmakiçinşöylebiryöntemdeneyebilirsiniz: >>> import locale >>> locale.setlocale(locale.LC_ALL, "Turkish_Turkey.1254") #Windows için >>> locale.setlocale(locale.LC_ALL, "tr_TR") #GNU/Linux için >>> sorted("çiçek", key=locale.strxfrm) [’ç’, ’ç’, ’e’, ’i’, ’k’] Buradalocaleadlıbirmodüldenyararlandık.localedetıpkısys,osvekeywordgibibirmodül olup,içindepekçokdeğişkenvefonksiyonbarındırır. locale modülü bize belli bir dilin kendine has özelliklerine göre programlama yapma imkanı verir. Örneğin bu modülünün içinde yer alan fonksiyonlardan biri olan setlocale() fonksiyonunu kullanarak, programımızda öntanımlı dil ayarlarına uygun bir şekilde programlamayapmaolanağısağlarız. Bu modülü ilerleyen derslerde daha ayrıntılı bir şekilde inceleyeceğiz. O yüzden locale modülünübirkenarabırakıpyolumuzadevamedelim. YukarıdakiörnekteTürkçekarakterleridoğrusıralayabilmekiçinsorted()fonksiyonununasıl kullandığımızadikkatedin: >>> sorted("çiçek", key=locale.strxfrm) 276 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 Buradasorted()metodununkeyadlıözelbirparametresinelocale.strxfrmdeğerinivererek Türkçeyeduyarlıbirsıralamayapılmasınısağladık.Yukarıdakiyöntempekçokdurumdaişinize yarar.Ancakbuyöntemtekbiryerdeişeyaramaz.Dikkatlicebakın: >>> sorted("afgdhkıi", key=locale.strxfrm) [’a’, ’d’, ’f’, ’g’, ’h’, ’i’, ’ı’, ’k’] Gördüğünüzgibi,buyöntem‘i’harfini‘ı’harfindenöncegetiriyor.HalbukiTürkalfabesinegöre bunun tersi olmalıydı. Buna benzer problemlerle İngiliz alfabesi dışındaki pek çok alfabede karşılaşırsınız.DolayısıylabusadeceTürkçeyeözgübirsorundeğil. Busorunakarşışöylebirkoddayazabilirsiniz: >>> harfler = "abcçdefgğhıijklmnoöprsştuüvyz" >>> çevrim = {i: harfler.index(i) for i in harfler} >>> sorted("afgdhkıi", key=çevrim.get) [’a’, ’d’, ’f’, ’g’, ’h’, ’ı’, ’i’, ’k’] Gördüğünüz gibi burada ilk iş olarak Türk alfabesindeki bütün harfleri harfler adlı bir değişkeneatadık.Dahasonraiseşöylebirkodyazdık: >>> çevrim = {i: harfler.index(i) for i in harfler} Burada henüz öğrenmediğimiz bir yapı var, ama ne olup bittiğini daha iyi anlamak için bu çevrimdeğişkenininiçeriğinikontroletmeyideneyebilirsiniz: >>> print(çevrim) {’ğ’: 8, ’ı’: 10, ’v’: 26, ’g’: 7, ’ş’: 22, ’a’: 0, ’c’: 2, ’b’: 1, ’e’: 5, ’d’: 4, ’ç’: 3, ’f’: 6, ’i’: 11, ’h’: 9, ’k’: 13, ’j’: 12, ’m’: 15, ’l’: 14, ’o’: 17, ’n’: 16, ’p’: 19, ’s’: 21, ’r’: 20, ’u’: 24, ’t’: 23, ’ö’: 18, ’y’: 27, ’z’: 28, ’ü’: 25} Bu çıktıya dikkatlice bakarsanız, her bir harfin bir sayıya karşılık gelecek şekilde birbiriyle eşleştirildiğini göreceksiniz. Mesela ‘ğ’ harfi 8 ile, ‘f’ harfi 6 ile eşleşmiş. Yine dikkatlice bakarsanız, biraz önce bize sorun çıkaran ‘ı’ harfinin 10, ‘i’ harfinin ise 11 ile eşleştiğini göreceksiniz.Evet,doğrutahminettiniz.Harflerisayılarlaeşleştirerek,Python’ınharfleryerine sayılarısıralamasınısağlayacağız.Bunudayinekeyparametresinikullanarakyapıyoruz: >>> sorted("afgdhkıi", key=çevrim.get) Buyapıyıdahaiyianlayabilmekiçinkendikendinizebazıdenemeleryapın.Eğerburadaolan biteni anlamakta zorlanıyorsanız hiç endişe etmeyin. Bir-iki bölüm sonra bunları da kolayca anlayabilecekdurumageleceksiniz.Bizimburadabubilgilerivermektekiamacımız,Python’ın Türkçeharflerlesıralamaişleminisorunsuzbirşekildeyapabileceğinigöstermektir.Buesnada bir-ikiyenibilgikırıntısıdakapmanızısağlayabildiysekkendimizibaşarılısayacağız. 16.4. KarakterDizileriniAlfabeSırasınaDizmek 277 PythonBelgeleri,Yayım4.1.3 16.5 Karakter Dizileri Üzerinde Değişiklik Yapmak Bu kısımda karakter dizilerinin çok önemli bir özelliğinden söz edeceğiz. Konumuz karakter dizileri üzerinde değişiklik yapmak. İsterseniz neyle karşı karşıya olduğumuzu anlayabilmek içinçokbasitbirörnekverelim. Elimizdeşöylebirkarakterdizisiolduğunudüşünün: >>> meyve = "elma" Amacımızbukarakterdizisininilkharfinibüyütmekolsun. Bununiçindilimlemeyöntemindenyararlanabileceğimizibiliyorsunuz: >>> "E" + meyve[1:] ’Elma’ Burada“E”harfiile,meyvedeğişkenininilkharfidışındakalanbütünharfleribirleştirdik. Birörnekdahaverelim. Elimizdeşöyledörtadetinternetsitesiadresiolsun: site1 = "www.google.com" site2 = "www..com" site3 = "www.yahoo.com" site4 = "www.gnu.org" Bizimamacımızbuadreslerinherbirininbaştarafınahttp://ifadesinieklemek.Bununiçinde yinekarakterdizisibirleştirmeişlemlerindenyararlanabiliriz.Dikkatliceinceleyin: site1 = "www.google.com" site2 = "www..com" site3 = "www.yahoo.com" site4 = "www.gnu.org" for i in site1, site2, site3, site4: print("http://", i, sep="") Eğer www. kısımlarını atmak isterseniz karakter dizisi birleştirme işlemleri ile birlikte dilimlemeyönteminidekullanmanızgerekir: for i in site1, site2, site3, site4: print("http://", i[4:], sep="") Belki farkındayız, belki de değiliz, ama aslında yukarıdaki örnekler karakter dizileri hakkında bize çok önemli bir bilgi veriyor. Dikkat ettiyseniz yukarıdaki örneklerde karakter dizileri üzerinde bir değişiklik yapmışız gibi görünüyor. Esasında öyle de denebilir. Ancak burada önemli bir ayrıntı var. Yukarıdaki örneklerde gördüğümüz değişiklikler kalıcı değildir. Yani aslında bu değişikliklerin orijinal karakter dizisi üzerinde hiçbir etkisi yoktur. Gelin isterseniz bunuteyitedelim: 278 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 >>> kardiz = "" >>> "İ" + kardiz[1:] ’’ Dediğimizgibi,sankiburada“”karakterdizisini“”karakterdizisineçevirmişizgibi duruyor.Amaaslındaöyledeğil: >>> print(kardiz) Gördüğünüz gibi, kardiz değişkeninin orijinalinde hiçbir değişiklik yok. Ayrıca burada "İ" + kardiz[1:] satırı ile elde ettiğiniz sonuca tekrar ulaşmanızın imkanı yok. Bu değişiklik kaybolmuşdurumda.Pekibununsebebinedir? Bunun nedeni, karakter dizilerinin değiştirilemeyen (immutable) bir veri tipi olmasıdır. Python’da iki tür veri tipi bulunur: değiştirilemeyen veri tipleri (immutable datatypes) ve değiştirilebilen veri tipleri (mutable datatypes). Bizim şimdiye kadar gördüğümüz veri tipleri (sayılarvekarakterdizileri),değiştirilemeyenveritipleridir.Henüzdeğiştirilebilenbirveritipi görmedik.Amabirkaçbölümsonradeğiştirilebilenveritiplerinideinceleyeceğiz. Neyse... Dediğimizgibi,karakterdizileriüzerindeyaptığımızdeğişikliklerinkalıcıolmamasının nedeni, karakter dizilerinin değiştirilemeyen bir veri tipi olmasıdır. Python’da bir karakter dizisini bir kez tanımladıktan sonra bu karakter dizisi üzerinde artık değişiklik yapamazsınız. Eğer bir karakter dizisi üzerinde değişiklik yapmanız gerekiyorsa, yapabileceğiniz tek şey o karakter dizisini yeniden tanımlamaktır. Mesela yukarıdaki örnekte kardiz değişkeninin tuttuğukarakterdizisinideğiştirmekistersenizşöylebirkodyazabilirsiniz: >>> kardiz = "İ" + kardiz[1:] >>> print(kardiz) Burada yaptığımız şey kardiz değişkeninin değerini değiştirmek değildir. Biz burada aslında bambaşka bir kardiz değişkeni daha tanımlıyoruz. Yani ilk kardiz değişkeni ile sonraki kardiz değişkeni aynı şeyler değil. Bunu teyit etmek için önceki derslerimizde gördüğümüz id() fonksiyonundanyararlanabilirsiniz: >>> kardiz = "" >>> id(kardiz) 3075853248 >>> kardiz = "İ" + kardiz[1:] >>> id(kardiz) 3075853280 Gördüğünüz gibi, ilk kardiz değişkeni ile sonraki kardiz değişkeni farklı kimlik numaralarına sahip. Yani bu iki değişken bellek içinde farklı adreslerde tutuluyor. Daha doğrusu, ikinci kardiz,ilkkardiz’isilipüzerineyazıyor. 16.5. KarakterDizileriÜzerindeDeğişiklikYapmak 279 PythonBelgeleri,Yayım4.1.3 Her ne kadar kardiz = "İ" + kardiz[1:] kodu kardiz’in değerini aslında değiştirmiyor olsa da, sanki kardiz değişkeninin tuttuğu karakter dizisi değişiyormuş gibi bir etki elde ediyoruz. Budabizimemnunetmeyeyetiyor... Yukarıdaki örnekte karakter dizisinin baş kısmı üzerinde değişiklik yaptık. Eğer karakter dizisininortasındakalanbirkısmıdeğiştirmekistersenizdeşöylebirşeyyazabilirsiniz: >>> kardiz = "" >>> kardiz = kardiz[:3] + "İH" + kardiz[5:] >>> kardiz ’istİHza’ Gördüğünüz gibi, yukarıdaki kodlarda karakter dizilerini dilimleyip birleştirerek, yani bir bakımakesipbiçerekistediğimizçıktıyıeldeettik. Meselailkörnektekardizdeğişkenininilkkarakteridışındakalankısmını(kardiz[1:])“İ”harfi ilebirleştirdik("İ" + kardiz[1:]"). İkinci örnekte ise kardiz değişkeninin ilk üç karakterine “İH” ifadesini ekledik ve sonra buna kardizdeğişkeninin5.karakterindensonrakikısmınıilaveettik. Karakter dizileri üzerinde değişiklik yapmanızın hangi durumlarda gerekli olacağını gösteren birörnekdahaveripbukonuyukapatalım. Diyelimki,birkelimeiçindekiseslivesessizharfleribirbirindenayırmanızgerekenbirprogram yazıyorsunuz. Yani mesela amacınız ‘istanbul’ kelimesi içinde geçen ‘i’, ‘a’ ve ‘u’ harflerini bir yerde, ‘s’, ‘t’, ‘n’, ‘b’ ve ‘l’ harflerini ise ayrı bir yerde toplamak. Bunun için şöyle bir program yazabilirsiniz: sesli_harfler = "aeıioöuü" sessiz_harfler = "bcçdfgğhjklmnprsştvyz" sesliler = "" sessizler = "" kelime = "istanbul" for i in kelime: if i in sesli_harfler: sesliler += i else: sessizler += i print("sesli harfler: ", sesliler) print("sessiz harfler: ", sessizler) BuradaöncelikleşukodlaryardımıylaTürkçedekiseslivesessizharfleribelirliyoruz: sesli_harfler = "aeıioöuü" sessiz_harfler = "bcçdfgğhjklmnprsştvyz" Ardındanda,seslivesessizharfleriniayıklayacağımızkelimedekisesliharflervesessizharfler içinboşbirerkarakterdizisitanımlıyoruz: 280 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 sesliler = "" sessizler = "" Programımıziçindeilgiliharfleri,oharfinaitolduğudeğişkeneatayacağız. Kelimemiz“istanbul”: kelime = "istanbul" Şimdi bu kelime üzerinde bir for döngüsü kuruyoruz ve kelime içinde geçen herbir harfe tektekbakıyoruz.Kelimeiçindegeçenharflerden,sesli_harflerdeğişkenindetanımlıkarakter dizisinde geçenleri sesliler adlı değişkene atıyoruz. Aksi durumda ise, yani kelime içinde geçen harflerden, sessiz_harfler değişkeninde tanımlı karakter dizisinde geçenleri, sessizler adlıdeğişkenegönderiyoruz: for i in kelime: if i in sesli_harfler: sesliler += i else: sessizler += i Bunun için for döngüsü içinde basit bir ‘if-else’ bloğu tanımladığımızı görüyorsunuz. Ayrıca bunu yaparken, sesliler ve sessizler adlı değişkenlere, for döngüsünün her bir dönüşünde yenibirharfgönderip,budeğişkenleri,döngününherdönüşündeyenibaştantanımladığımıza dikkatedin.Çünkü,dediğimizgibi,karakterdizilerideğiştirilemeyenveritipleridir.Birkarakter dizisiüzerindedeğişiklikyapmakistiyorsak,okarakterdizisinibaştantanımlamamızgerekir. 16.6 Üç Önemli Fonksiyon Karakterdizilerinintemelözelliklerihakkındasöyleyeceklerimizinsonunageldiksayılır.Biraz sonrakarakterdizilerininçokönemlibirparçasıolanmetotlardansözedeceğiz.Amaisterseniz metotlara geçmeden önce, çok önemli üç fonksiyondan söz edelim. Bu fonksiyonlar sadece karakterdizileriiledeğil,başkaveritipleriileçalışırkendeişlerimizibirhaylikolaylaştıracak. 16.6.1 dir() İlk olarak dir() adlı özel bir fonksiyondan söz edeceğiz. Bu metot bize Python’daki bir nesnenin özellikleri hakkında bilgi edinme imkanı verecek. Mesela karakter dizilerinin bize hangimetotlarısunduğunugörmekiçinbufonksiyonuşöylekullanabiliriz: >>> dir(str) [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__getnewargs__’, ’__gt__’, ’__hash__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mod__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rmod__’, ’__rmul__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’capitalize’, ’center’, ’count’, ’encode’, ’endswith’, ’expandtabs’, ’find’, ’format’, ’format_map’, ’index’, ’isalnum’, ’isalpha’, (sonrakisayfayadevam) 16.6. ÜçÖnemliFonksiyon 281 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’isdecimal’, ’isdigit’, ’isidentifier’, ’islower’, ’isnumeric’, ’isprintable’, ’isspace’, ’istitle’, ’isupper’, ’join’, ’ljust’, ’lower’, ’lstrip’, ’maketrans’, ’partition’, ’replace’, ’rfind’, ’rindex’, ’rjust’, ’rpartition’, ’rsplit’, ’rstrip’, ’split’, ’splitlines’, ’startswith’, ’strip’, ’swapcase’, ’title’, ’translate’, ’upper’, ’zfill’] İngilizcede ‘karakter dizisi’nin karşılığının string, bu kelimenin kısaltmasının da ‘str’ olduğunu hatırlıyor olmalısınız. İşte dir() fonksiyonuna parametre olarak bu ‘str’ kelimesini verdiğimizde,Pythonbizekarakterdizilerininbütünmetotlarınılisteliyor. Karakter dizileri dışında, şimdiye kadar öğrendiğimiz başka bir veri tipi de sayılar. Biz Python’da sayıların tam sayılar (integer), kayan noktalı sayılar (float) ve karmaşık sayılar (complex)olaraküçeayrıldığınıdabiliyoruz.Örnekolmasıaçısındandir()fonksiyonunubir desırasıyla,tamsayılar,kayannoktalısayılarvekarmaşıksayılarüzerindedeuygulayalım: >>> dir(int) >>> dir(float) >>> dir(complex) Gördüğünüz gibi, dir() fonksiyonunu kullanmak için, metotlarını listelemek istediğimiz nesneyi alıp dir() fonksiyonuna parametre olarak veriyoruz. Örneğin yukarıda karakter dizileri için str; tam sayılar için int; kayan noktalı sayılar için float; karmaşık sayılar için ise complexparametrelerinikullandık. dir() fonksiyonunu kullanabilmek için tek yöntemimiz, sorgulamak istediğimiz nesnenin adını kullanmak değil. Mesela karakter dizilerinin metotlarını sorgulamak için ‘str’ kelimesini kullanabileceğimizgibi,herhangibirkarakterdizisinidekullanabiliriz.Yani: >>> dir("") Burada dir() fonksiyonuna parametre olarak boş bir karakter dizisi verdik. Bu kodun dir(str) kodundan hiçbir farkı yoktur. Bu komut da bize karakter dizilerinin metotlarını listeler. Aynıetkiyidilersekşöyledeeldeedebiliriz: >>> a = "karakter" >>> dir(a) Karakter dizilerinin metotlarını listelemek için, siz hangi yöntem kolayınıza geliyorsa onu kullanabilirsiniz.Busatırlarınyazarıgenellikleşuyöntemikullanıyor: >>> dir("") dir("") komutunun çıktısından da göreceğiniz gibi, karakter dizilerinin epey metodu var. Metotlistesiiçindebiziilgilendirenlerbaşındaveyasonunda_işaretiolmayanlar.Yanişunlar: >>> for i in dir(""): ... if "_" not in i[0]: (sonrakisayfayadevam) 282 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ... print(i) ... Buaradabumetotlarılistelemekiçinnasılbirkodkullandığımızadikkatedin: for i in dir(""): if "_" not in i[0]: print(i) Buradadir("")komutununiçerdiğiherbirmetodatektekbakıyoruz.Bumetotlariçinde,ilk harfi _ karakteri olmayan bütün metotları listeliyoruz. Böylece istediğimiz listeyi elde etmiş oluyoruz.İstersenizilgilendiğimizmetotlarınsayısınıdaçıktıyaekleyebiliriz: sayaç = 0 for i in dir(""): if "_" not in i[0]: sayaç += 1 print(i) print("Toplam {} adet metot ile ilgileniyoruz.".format(sayaç)) Buradada,ilkkarakteri_olmayanherbirmetotiçinsayaçdeğişkeninindeğerini1artırıyoruz. Böyleceprogramınsonundasayaçdeğişkeniilgilendiğimizmetotsayısınıgöstermişoluyor. Eğer her metodun soluna, sıra numarasını da eklemek isterseniz elbette şöyle bir kod da yazabilirsiniz: sayaç = 0 for i in dir(""): if "_" not in i[0]: sayaç += 1 print(sayaç, i) print("Toplam {} adet metot ile ilgileniyoruz.".format(sayaç)) Bu noktada bir parantez açalım. Yukarıdaki yöntemi kullanarak metotları numaralandırabilirsiniz. Ama aslında Python bize numaralandırma işlemleri için özel birfonksiyonsunar.Şimdiistersenizbuözelfonksiyonuinceleyelim. 16.6.2 enumerate() Eğer yazdığınız bir programda numaralandırmaya ilişkin işlemler yapmanız gerekiyorsa Python’ın size sunduğu çok özel bir fonksiyondan yararlanabilirsiniz. Bu fonksiyonun adı enumerate(). Gelelimbufonksiyonunnasılkullanılacağına... Önceşöylebirdenemeyapalım: 16.6. ÜçÖnemliFonksiyon 283 PythonBelgeleri,Yayım4.1.3 >>> enumerate("") <enumerate object at 0x00E3BC88> Tıpkı reversed() fonksiyonunun bir ‘reversed’ nesnesi vermesi gibi, bu fonksiyonun da bize yalnızcabir‘enumerate’nesnesiverdiğinigörüyorsunuz. reversed()fonksiyonunukullanabilmekiçinşöylebirkodyazmıştık: >>> print(*reversed("")) enumerate()içindebenzerbirşeyideneyebiliriz: >>> print(*enumerate("")) Buradaşuçıktıyıaldık: (0, ’i’) (1, ’s’) (2, ’t’) (3, ’i’) (4, ’h’) (5, ’z’) (6, ’a’) Enumerate kelimesi İngilizcede ‘numaralamak, numaralandırmak’ gibi anlamlara gelir. Dolayısıylaenumerate()fonksiyonu,kendisineparametreolarakverilendeğerhakkındabize iki farklı bilgi verir: Bir öğe ve bu öğeye ait bir sıra numarası. Yukarıdaki çıktıda gördüğünüz şeydeişteherbiröğeninkendisiveoöğeyeaitbirsıranumarasıdır. Yukarıdakiçıktıyıdahaiyianlayabilmekiçinbirfordöngüsükullanmakdahaaçıklayıcıolabilir: >>> for i in enumerate(""): ... print(i) ... (0, ’i’) (1, ’s’) (2, ’t’) (3, ’i’) (4, ’h’) (5, ’z’) (6, ’a’) Gördüğünüz gibi, gerçekten de bu fonksiyon bize bir öğe (mesela ‘i’ harfi) ve bu öğeye ait bir sıranumarası(mesela0)veriyor. Hatırlarsanız, enumerate() fonksiyonunu öğrenmeden önce, dir("") komutundan elde ettiğimizçıktılarışuşekildenumaralandırabileceğimizisöylemiştik: sayaç = 0 for i in dir(""): if "_" not in i[0]: sayaç += 1 print(sayaç, i) Amaartıkenumerate()fonksiyonunuöğrendiğimizegöre,aynıişiçokdahaverimlibirşekilde gerçekleştirebiliriz: 284 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 for sıra, metot in enumerate(dir("")): print(sıra, metot) enumerate()metodununverdiğiherbirçıktınınikiöğeliolduğunubiliyoruz(öğeninkendisive oöğeninsıranumarası).Yukarıdakikodlaryardımıyla,buöğelerinherbiriniayrıbirdeğişkene (sıra ve metot) atamış oluyoruz. Böylece bu çıktıyı manipüle etmek bizim için daha kolay oluyor.Meselabuözelliğikullanarakmetotvesıranumarasınınyerlerinideğiştirebiliriz: >>> for sıra, metot in enumerate(dir("")): ... print(metot, sıra) ... __add__ 0 __class__ 1 __contains__ 2 __delattr__ 3 __doc__ 4 __eq__ 5 __format__ 6 __ge__ 7 (...) Pratikolmasıaçısındanşöylebirörnekdahaverelim: >>> for sıra, metot in enumerate(dir("")): ... print(sıra, metot, len(metot)) ... 0 __add__ 7 1 __class__ 9 2 __contains__ 12 3 __delattr__ 11 4 __doc__ 7 5 __eq__ 6 (...) Burada, dir("") ile elde ettiğimiz metotların sırasını (sıra), bu metotların adlarını (metot) ve herbirmetodunkaçkarakterdenoluştuğunu(len(metot))gösterenbirçıktıeldeettik. Bu arada, gördüğünüz gibi, enumerate() fonksiyonu numaralandırmaya 0’dan başlıyor. Elbette eğer isterseniz bu fonksiyonun numaralandırmaya kaçtan başlayacağını kendiniz de belirleyebilirsiniz.Dikkatlicebakın: >>> for sıra, harf in enumerate("", 1): ... print(sıra, harf) ... 1 i 2 s 3 t 4 i 5 h (sonrakisayfayadevam) 16.6. ÜçÖnemliFonksiyon 285 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 6 z 7 a Burada ‘’ kelimesi içindeki harfleri numaralandırdık. Bunu yaparken de numaralandırmaya1’denbaşladık.Bununiçinenumerate()fonksiyonunaikincibirparametre verdiğimizedikkatedin. enumerate() fonksiyonunu da incelediğimize göre önemli bir başka fonksiyondan daha söz edebiliriz. 16.6.3 help() Python’la ilgili herhangi bir konuda yardıma ihtiyacınız olduğunda, internetten araştırma yaparak pek çok ayrıntılı belgeye ulaşabilirsiniz. Ama eğer herhangi bir nesne hakkında hızlı bir şekilde ve İngilizce olarak yardım almak isterseniz help() adlı özel bir fonksiyondan yararlanabilirsiniz. Bufonksiyonuikifarklışekildekullanıyoruz.Birinciyöntemde,etkileşimlikabuğahelp()yazıp Enterdüğmesinebasıyoruz: >>> help() Welcome to Python 3.3! This is the interactive help utility. If this is your first time using Python, you should definitely check out the tutorial on the Internet at http://docs.python.org/3.3/tutorial/. Enter the name of any module, keyword, or topic to get help on writing Python programs and using Python modules. To quit this help utility and return to the interpreter, just type "quit". To get a list of available modules, keywords, or topics, type "modules", "keywords", or "topics". Each module also comes with a one-line summary of what it does; to list the modules whose summaries contain a given word such as "spam", type "modules spam". help> Gördüğünüz gibi, Python bu komutu verdiğimizde özel bir yardım ekranı açıyor bize. Bu ekranda>>>yerinehelp>ifadesininolduğunadikkatedin.Meseladir()fonksiyonuhakkında bilgialmakiçinhelp>ifadesindenhemensonra,hiçboşlukbırakmadan,şukomutuverebiliriz: help> dir Bukomutbizeşuçıktıyıveriyor: Help on built-in function dir in module builtins: dir(...) dir([object]) -> list of strings (sonrakisayfayadevam) 286 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the␣ attributes ˓→ of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise the default dir() logic is used and returns: for a module object: the module’s attributes. for a class object: its attributes, and recursively the attributes of␣ its bases. ˓→ for any other object: its attributes, its class’s attributes, and recursively the attributes of its class’s base classes. Gördüğünüzgibi,dir()fonksiyonununneişeyaradığıvenasılkullanıldığıkonusundaayrıntılı bir bilgi ediniyoruz. Bu arada, hakkında bilgi almak istediğimiz fonksiyonu parantezsiz yazdığımızadikkatedin. Örnekolmasıaçısındanmeselabirdelen()fonksiyonuhakkındabilgiedinelim: help> len Help on built-in function len in module builtins: len(...) len(object) -> integer Return the number of items of a sequence or mapping. ‘help’ekranındançıkmakiçinEnterdüğmesinebasabilirveyaquitkomutuverebilirsiniz. En başta da dediğimiz gibi Python’da etkileşimli kabuk üzerinde İngilizce yardım almak için iki farklı yöntem kullanabiliyoruz. Bu yöntemlerden ilkini yukarıda anlattık. İkincisi ise doğrudan etkileşimli kabukta şu komutu kullanmaktır: (Mesela dir() fonksiyonu hakkında yardımalalım...) >>> help(dir) Help on built-in function dir in module builtins: dir(...) dir([object]) -> list of strings If called without an argument, return the names in the current scope. Else, return an alphabetized list of names comprising (some of) the␣ attributes ˓→ of the given object, and of attributes reachable from it. If the object supplies a method named __dir__, it will be used; otherwise the default dir() logic is used and returns: for a module object: the module’s attributes. for a class object: its attributes, and recursively the attributes of␣ its bases. ˓→ (sonrakisayfayadevam) 16.6. ÜçÖnemliFonksiyon 287 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for any other object: its attributes, its class’s attributes, and recursively the attributes of its class’s base classes. Gördüğünüz gibi, ‘help’ ekranını açmadan, doğrudan etkileşimli kabuk üzerinden de help() fonksiyonunuherhangibirfonksiyongibikullanıp,hakkındayardımalmakistediğimiznesneyi help()fonksiyonununparantezleriiçineparametreolarakyazabiliyoruz. Böylece dir(), enumerate() ve help() adlı üç önemli fonksiyonu da geride bırakmış olduk. Dilersenizşimdikarakterdizilerinedairbirkaçufaknotdüşelim. 16.7 Notlar Hatırlarsanızdöngülerianlatırkenşöylebirörnekvermiştik: tr_harfler = "şçöğüİı" a = 0 while a < len(tr_harfler): print(tr_harfler[a], sep="\n") a += 1 Bukodlarınfordöngüsüileyazılabilecekolanşukodlaraalternatifolduğundansözetmiştik: tr_harfler = "şçöğüİı" for tr_harf in tr_harfler: print(tr_harf) Yukarıdaki while örneğini verirken, henüz karakter dizilerinin öğelerine tek tek nasıl erişebileceğimiziöğrenmemiştik.Amaartıkbukonuyudaöğrendiğimiziçinyukarıdakiwhile döngüsünürahatlıklaanlayabiliyoruz: while a < len(tr_harfler): print(tr_harfler[a], sep="\n") a += 1 Burada yaptığımız şey şu: a değişkeninin değeri tr_harfler değişkeninin uzunluğundan (len(tr_harfler)) küçük olduğu müddetçe a değişkeninin değerini 1 sayı artırıp yine a değişkeninegönderiyoruz(a += 1). while döngüsünün her dönüşünde de, a değişkeninin yeni değeri yardımıyla tr_harfler adlı karakterdizisininöğelerinetektekvesıraylaerişiyoruz(print(tr_hafler[a])). Yinehatırlarsanız,öncekiderslerimizdesysadlıbirmodüliçindekiversionadlıbirdeğişkenden söz etmiştik. Bu değişken bize kullandığımız Python’ın sürümünü bir karakter dizisi olarak veriyordu: >>> import sys >>> sys.version Buradanşuçıktıyıalıyoruz: 288 Bölüm16. KarakterDizileri PythonBelgeleri,Yayım4.1.3 ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ Bu çıktıda, kullandığımız Python sürümünün dışında başka birtakım bilgiler de var. İşte biz eğer istersek, bu bölümde öğrendiğimiz bilgileri kullanarak bu karakter dizisinin istediğimiz kısmını,meselasadecesürümbilgisinikarakterdizisininiçindendilimleyipalabiliriz: >>> sys.version[:5] 3.7.0 Elbette, yukarıdaki karakter dizisini elde etmek için, kullanması ve yönetmesi daha kolay bir araçolanversion_infodeğişkenindendeyararlanabilirdiniz: >>> ’{}.{}.{}’.format(sys.version_info.major, sys.version_info.minor, sys. version_info.micro) ˓→ 3.7.0 Ancak burada şöyle bir sorun olduğunu biliyorsunuz: Python’ın 2.7 öncesi sürümlerinde version_info’nun major, minor ve micro gibi nitelikleri yok. Dolayısıyla 2.7 öncesi sürümlerde version_info’yu kullanırken hata almamak için try... except bloklarından yararlanabileceğimizi görmüştük. Ancak version_info’yu bütün Python sürümlerinde güvenli birşekildekullanmanınbaşkabiryöntemidahavar.Dikkatlicebakın: >>> major = sys.version_info[0] >>> minor = sys.version_info[1] >>> micro = sys.version_info[2] >>> print(major, minor, micro, sep=".") 3.7.0 Bu yöntem bütün Python sürümlerinde çalışır. Dolayısıyla, farklı Python sürümlerinde çalışmasını tasarladığınız programlarınızda sürüm kontrolünü sys.version_info’nun major, minorveyamicronitelikleriileyapmakyerineyukarıdakiyöntemleyapabilirsiniz: if sys.version_info[1] < 3: print("Kullandığınız Python sürümü eski!") Gördüğünüz gibi, karakter dizisi dilimleme işlemleri pek çok farklı kullanım alanına sahip. Programlama maceranız boyunca karakter dizilerinin bu özelliğinden bol bol yararlanacağınızdanhiçkuşkunuzolmasın. 16.7. Notlar 289 17 BÖLÜM Karakter Dizilerinin Metotları Geçen bölümde karakter dizilerinin genel özelliklerinden söz ettik. Bu ikinci bölümde ise karakter dizilerini biraz daha ayrıntılı bir şekilde incelemeye ve karakter dizilerinin yepyeni özelliklerinigörmeyebaşlayacağız. Hatırlarsanız,geçenbölümünenbaşında,metotdiyebirşeydensözedeceğimizisöylemiştik. Oradadakabacatarifettiğimizgibi,metotlarPython’danesnelerinniteliklerinideğiştirmemizi, sorgulamamızı veya bu nesnelere yeni özellikler katmamızı sağlayan araçlardır. Metotlar sayesindekarakterdizileriniistediğimizgibieğipbükebileceğiz. Geçen bölümün sonlarına doğru, bir karakter dizisinin hangi metotlara sahip olduğunu şu komutyardımıylalisteleyebileceğimiziöğrenmiştik: >>> dir("") Bu komutu verdiğinizde aldığınız çıktıdan da gördüğünüz gibi, karakter dizilerinin 40’ın üzerinde metodu var. Dolayısıyla metot sayısının çokluğu gözünüzü korkutmuş olabilir. Ama aslındabunahiçlüzumyok.Çünküprogramcılıkmaceranızdabumetotlarınbazılarınıyaçok nadiren kullanacaksınız, ya da hiç kullanmayacaksınız. Çok kullanılan metotlar belli başlıdır. Elbette bütün metotlar hakkında fikir sahibi olmak gerekir. Zaten siz de göreceksiniz ki, bu metotlar kullandıkça aklınızda kalacak. Doğal olarak çok kullandığınız metotları daha kolay öğreneceksiniz. Eğer bir program yazarken hangi metodu kullanmanız gerektiğini veya kullanacağınız metodun ismini hatırlayamazsanız etkileşimli kabukta dir("") gibi bir komut verip çıkan sonucu incelemek pek zor olmasa gerek. Ayrıca hatırlayamadığınız bir metot olması durumunda dönüp bu sayfaları tekrar gözden geçirme imkanına da sahipsiniz. Unutmayın, bütün metotları ve bu metotların nasıl kullanıldığını ezbere bilmeniz zaten beklenmiyor. Metotları hatırlayamamanız gayet normal. Böyle bir durumda referans kitaplarınabakmakendoğalhakkınız. 290 PythonBelgeleri,Yayım4.1.3 17.1 replace() Karakterdizisimetotlarıarasındainceleyeceğimizilkmetotreplace()metoduolacak.replace kelimesi Türkçede ‘değiştirmek, yerine koymak’ gibi anlamlar taşır. İşte bu metodun yerine getirdiği görev de tam olarak budur. Yani bu metodu kullanarak bir karakter dizisi içindeki karakterleribaşkakarakterlerledeğiştirebileceğiz. Pekibumetodunasılkullanacağız?Hemenbirörnekverelim: >>> kardiz = "elma" Burada “elma” değerini taşıyan kardiz adlı bir karakter dizisi tanımladık. Şimdi bu karakter dizisininiçindegeçen“e”harfini“E”iledeğiştirelim.Dikkatlicebakın: >>> kardiz.replace("e", "E") ’Elma’ Gördüğünüzgibi,replace()sondereceyararlıvekullanımıoldukçakolaybirmetot.Buarada bu ilk metodumuz sayesinde Python’daki metotların nasıl kullanılacağı konusunda da bilgi edinmişolduk.Yukarıdakiörneklerinbizegösterdiğigibişöylebirformüllekarşıkarşıyayız: karakter_dizisi.metot(parametre) Metotlar karakter dizilerinden nokta ile ayrılır. Python’da bu yönteme ‘noktalı gösterim’ (dot notation)adıverilir. Bu arada metotların görünüş ve kullanım olarak fonksiyonlara ne kadar benzediğine dikkat edin.Tıpkıfonksiyonlardaolduğugibi,metotlardabirtakımparametreleralabiliyor. Yukarıdakiörnekte,replace()metodununikifarklıparametrealdığınıgörüyoruz.Bumetoda verdiğimizilkparametredeğiştirmekistediğimizkarakterdizisinigösteriyor.İkinciparametre isebirinciparametredebelirlediğimizkarakterdizisininyerinenekoyacağımızıbelirtiyor.Yani replace()metoduşöylebirformülesahiptir: karakter_dizisi.replace(eski_karakter_dizisi, yeni_karakter_dizisi) Gelinistersenizelimizinalışmasıiçinreplace()metoduylabirkaçörnekdahaverelim: >>> kardiz = "memleket" >>> kardiz.replace("ket", "KET") ’memleKET’ Burada gördüğünüz gibi, replace() metodu aynı anda birden fazla karakteri değiştirme yeteneğinedesahip. replace()metodununikiparametredenoluştuğunu,ilkparametrenindeğiştirilecekkarakter dizisini, ikinci parametrenin ise ilk karakter dizisinin yerine geçecek yeni karakter dizisini gösterdiğini söylemiştik. Aslında replace() metodu üçüncü bir parametre daha alır. Bu parametreisebirkarakterdizisiiçindekikarakterlerinkaçtanesinindeğiştirileceğinigösterir. Eğer bu parametreyi belirtmezsek replace() metodu ilgili karakterlerin tamamını değiştirir. Yani: 17.1. replace() 291 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "memleket" >>> kardiz.replace("e", "") ’mmlkt’ Gördüğünüz gibi, replace() metodunu iki parametre ile kullanıp üçüncü parametreyi belirtmediğimizde, “memleket” kelimesi içindeki bütün “e” harfleri boş karakter dizisi ile değiştiriliyor(yanibiranlamdasiliniyor). Şimdişuörneğebakalım: >>> kardiz.replace("e", "", 1) ’mmleket’ Burada replace() metodunu üçüncü bir parametre ile birlikte kullandık. Üçüncü parametre olarak1sayısınıverdiğimiziçinreplace()metodusadecetekbir“e”harfinisildi. Buüçüncüparametreyi,silmekistediğinizharfsayısıkadarartırabilirsiniz.Mesela: >>> kardiz.replace("e", "", 2) ’mmlket’ >>> kardiz.replace("e", "", 3) ’mmlkt’ Buradailkörnekteüçüncüparametreolarak2sayısınıkullandığımıziçin,‘replace’işleminden karakterdizisiiçindeki2adet“e”harfietkilendi.Üçüncüörnekteise“memleket”adlıkarakter dizisiiçindegeçenüçadet“e”harfideğişikliktenetkilendi. Karakterdizilerikonusununilkbölümünde‘değiştirilebilirlik’(mutability)üzerinesöylediğimiz şeylerin burada da geçerli olduğunu unutmayın. Orada da söylediğimiz gibi, karakter dizileri değiştirilemeyenveritipleridir.Dolayısıylaeğerbirkarakterdizisiüzerindedeğişiklikyapmak istiyorsanız,okarakterdizisinibaştantanımlamalısınız.Örneğin: >>> meyve = "elma" >>> meyve = meyve.replace("e", "E") >>> meyve ’Elma’ Böylecereplace()metodunuincelemişolduk.Sıradaüçönemlimetotvar. 292 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 17.2 split(), rsplit(), splitlines() Şimdi size şöyle bir soru sorduğumu düşünün: Acaba aşağıdaki karakter dizisinde yer alan bütünkelimelerinilkharfininasılalırız? >>> kardiz = "İstanbul Büyükşehir Belediyesi" Yanidiyorumkiburada“İBB”gibibirçıktıyınasıleldeederiz? Sadece bu karakter dizisi söz konusu ise, elbette karakter dizilerinin dilimlenme özelliğinden yararlanarak,kardizdeğişkeniiçindeki“İ”,“B”,ve“B”harflerinitektekalabiliriz: >>> print(kardiz[0], kardiz[9], kardiz[20], sep="") İBB Ancak bu yöntemin ne kadar kullanışsız olduğu ortada. Çünkü bu metot yalnızca “İstanbul Büyükşehir Belediyesi” adlı karakter dizisi için geçerlidir. Eğer karakter dizisi değişirse bu yöntemdeçöpegider.Busorunagenelbirçözümüretebilseknegüzelolurdu,değilmi? İştePython’dabusorunuçözmemizisağlayacakçokgüzelbirmetotbulunur.Bumetodunadı split(). Bu metodun görevi karakter dizilerini belli noktalardan bölmektir. Zaten split kelimesi Türkçede ‘bölmek, ayırmak’ gibi anlamlara gelir. İşte bu metot, üzerine uygulandığı karakter dizileriniparçalarınaayırır.Örneğin: >>> kardiz = "İstanbul Büyükşehir Belediyesi" >>> kardiz.split() [’İstanbul’, ’Büyükşehir’, ’Belediyesi’] Gördüğünüz gibi bu metot sayesinde “İstanbul Büyükşehir Belediyesi” adlı karakter dizisini kelimelerebölmeyibaşardık.Eğerbuçıktıüzerinebirfordöngüsüuygularsakşöylebirsonuç eldeederiz: >>> for i in kardiz.split(): ... print(i) ... İstanbul Büyükşehir Belediyesi Artıkbubilgiyikullanarakşöylebirprogramyazabiliriz: kardiz = input("Kısaltmasını öğrenmek istediğiniz kurum adını girin: ") for i in kardiz.split(): print(i[0], end="") Burada kullanıcı hangi kurum adını girerse girsin, bu kurum adının her kelimesinin ilk harfi ekranadökülecektir.Örneğinkullanıcıburada“TürkiyeBüyükMilletMeclisi”ifadesinigirmişse split()metoduönceliklebuifadeyialıpşuşekledönüştürür: 17.2. split(),rsplit(),splitlines() 293 PythonBelgeleri,Yayım4.1.3 [’Türkiye’, ’Büyük’, ’Millet’, ’Meclisi’] Dahasonrabizbuçıktıüzerindebirfordöngüsükurarsakbukelimegrubununherbiröğesine tektekmüdahaleetmeimkanınaerişiriz.Örneğinyukarıdakiprogramdabukelimegrubunun herbiröğesininilkharfinitektekekranadöktükve“TBMM”çıktısınıeldeettik. Yukarıdaki örneklerde split() metodunu herhangi bir parametre içermeyecek şekilde kullandık. Yani metodun parantezleri içine herhangi bir şey eklemedik. split() metodunu bu şekilde parametresiz olarak kullandığımızda bu metot karakter dizilerini bölerken boşluk karakterini ölçüt alacaktır. Yani karakter dizisi içinde karşılaştığı her boşluk karakterinde bir bölme işlemi uygulayacaktır. Ama bazen istediğimiz şey, bir karakter dizisini boşluklardan bölmekdeğildir.Meselaşuörneğebakalım: >>> kardiz = "Bolvadin, Kilis, Siverek, İskenderun, İstanbul" Eğer bu karakter dizisi üzerine split() metodunu parametresiz olarak uygularsak şöyle bir çıktıeldeederiz: [’Bolvadin,’, ’Kilis,’, ’Siverek,’, ’İskenderun,’, ’İstanbul’] split()metodunaherhangibirparametrevermediğimiziçinbumetotkarakterdizisiiçindeki kelimeleri boşluklardan böldü. Bu yüzden karakter dizisi içindeki virgül işaretleri de bölünen kelimeleriçindegörünüyor: >>> kardiz = kardiz.split() >>> for i in kardiz: ... print(i) ... Bolvadin, Kilis, Siverek, İskenderun, İstanbul Bu arada tıpkı replace() metodunu anlatırken gösterdiğimiz gibi, kardiz.split() ifadesini de yine kardiz adını taşıyan bir değişkene atadık. Böylece kardiz.split() komutu ile elde ettiğimiz değişiklik kaybolmamış oldu. Karakter dizilerinin değiştirilemeyen bir veri tipi olduğunu biliyorsunuz. Dolayısıyla yukarıdaki karakter dizisi üzerine split() metodunu uyguladığımızda aslında orijinal karakter dizisi üzerinde herhangi bir değişiklik yapmış olmuyoruz. Çıktıda görünen değişikliğin orijinal karakter dizisini etkileyebilmesi için eski karakter dizisini silip, yerine yeni değerleri yazmamız gerekiyor. Bunu da kardiz = kardiz.split()gibibirkomutlahallediyoruz. Nerede kalmıştık? Gördüğünüz gibi split() metodu parametresiz olarak kullanıldığında karakterdizisiniboşluklardanbölüyor.Amayukarıdakiörnektekarakterdizisiniboşluklardan değildevirgüllerdenbölsekçokdahaanlamlıbirçıktıeldeedebiliriz. Dikkatliceinceleyin: >>> kardiz = "Bolvadin, Kilis, Siverek, İskenderun, İstanbul" >>> kardiz = kardiz.split(",") >>> print(kardiz) (sonrakisayfayadevam) 294 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) [’Bolvadin’, ’ Kilis’, ’ Siverek’, ’ İskenderun’, ’ İstanbul’] >>> for i in kardiz: ... print(i) ... Bolvadin Kilis Siverek İskenderun İstanbul Gördüğünüz gibi, split() metodu tam da istediğimiz gibi, karakter dizisini bu kez boşluklardan değil virgüllerden böldü. Peki bunu nasıl başardı? Aslında bu sorunun cevabı gayet net bir şekilde görünüyor. Dikkat ederseniz yukarıdaki örnekte split() metoduna parametreolarakvirgülkarakterdizisiniverdik.Yanişöylebirşeyyazdık: kardiz.split(",") Bu sayede split() metodu karakter dizisini virgüllerden bölmeyi başardı. Tahmin edebileceğiniz gibi, split() metoduna hangi parametreyi verirseniz bu metot ilgili karakter dizisiniokarakteringeçtiğiyerlerdenbölecektir.Yanimeselasizbumetoda“l”parametresini verirseniz,bumetotda‘l’harfigeçenyerdenkarakterdizisinibölecektir: >>> kardiz.split("l") [’Bo’, ’vadin, Ki’, ’is, Siverek, İskenderun, İstanbu’, ’’] >>> for i in kardiz.split("l"): ... print(i) ... Bo vadin, Ki is, Siverek, İskenderun, İstanbu Eğer parametre olarak verdiğiniz değer karakter dizisi içinde hiç geçmiyorsa karakter dizisi üzerindeherhangibirdeğişiklikyapılmaz: >>> kardiz.split("z") [’Bolvadin, Kilis, Siverek, İskenderun, İstanbul’] Aynı şey, split() metodundan önce öğrendiğimiz replace() metodu için de geçerlidir. Yani eğer değiştirilmek istenen karakter, karakter dizisi içinde yer almıyorsa herhangi bir işlem yapılmaz. split() metodu çoğunlukla, yukarıda anlattığımız şekilde parametresiz olarak veya tek parametre ile kullanılır. Ama aslında bu metot ikinci bir parametre daha alır. Bu ikinci parametre,karakterdizisininkaçkezbölüneceğinibelirler: 17.2. split(),rsplit(),splitlines() 295 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "Ankara Büyükşehir Belediyesi" >>> kardiz.split(" ", 1) [’Ankara’, ’Büyükşehir Belediyesi’] >>> kardiz.split(" ", 2) [’Ankara’, ’Büyükşehir’, ’Belediyesi’] Gördüğünüz gibi, ilk örnekte kullandığımız 1 sayısı sayesinde bölme işlemi karakter dizisi üzerinebirkezuygulandı.İkinciörnekteise2sayısınınetkisiylekarakterdizimizikikezbölme işleminemaruzkaldı. Elbette, split() metodunun ikinci parametresini kullanabilmek için ilk parametreyi de mutlakayazmanızgerekir.AksihaldePythonneyapmayaçalıştığınızıanlayamaz: >>> kardiz.split(2) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: Can’t convert ’int’ object to str implicitly Gördüğünüzgibi,ilkparametreyiesgeçipdoğrudanikinciparametreyiyazmayaçalıştığımızda Pythonparametreolarakverdiğimiz2sayısınınbölmeölçütüolduğunuzannediyor.Yukarıdaki hatayı engellemek için bölme ölçütünü de açıkça belirtmemiz gerekir. Yukarıdaki örnekte bölme ölçütümüz bir adet boşluk karakteri idi. Bildiğiniz gibi, bölme ölçütü herhangi bir şey olabilir.Meselavirgül. >>> arkadaşlar = "Ahmet, Mehmet, Kezban, Mualla, Süreyya, Veli" >>> arkadaşlar.split(",", 3) [’Ahmet’, ’ Mehmet’, ’ Kezban’, ’ Mualla, Süreyya, Veli’] Burada da bölme ölçütü olarak virgül karakterini kullandık ve arkadaşlar adlı karakter dizisi üzerine3kezbölmeişlemiuyguladık.İlkbölmeişlemi“Ahmet”karakterdizisini;ikincibölme işlemi “Mehmet” karakter dizisini; üçüncü bölme işlemi ise “Kezban” karakter dizisini ayırdı. arkadaşlar adlı karakter dizisinin geri kalanını oluşturan “Mualla, Süreyya, Veli” kısmı ise herhangibirbölmeişleminetabitutulmadantekparçaolarakkaldı. split()metoduylasonbirörnekveripyolumuzadevamedelim. Bildiğinizgibisysmodülününversiondeğişkenibizebirkarakterdizisiveriyor: ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ Bukarakterdizisiiçindenyalnızcasürümkısmınıayıklamakiçinkarakterdizilerinindilimlenme özelliğindenyararlanabiliyoruz: >>> sürüm = sys.version >>> print(sürüm[:5]) 3.7.0 296 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 Buişleminbirbenzerinisplit()metoduyladayapabiliriz.Dikkatliceinceleyin: >>> sürüm = sys.version >>> sürüm.split() [’3.3.0’, ’(v3.3.0:bd8afb90ebf2,’, ’Sep’, ’29’, ’2012,’, ’10:55:48)’, ’[MSC’, ’v.1600’, ’32’, ’bit’, ’(Intel)]’] Gördüğünüzgibi,sys.versionkomutunasplit()metodunuuyguladığımızda,üzerindeişlem yapması çok daha kolay olan bir veri tipi elde ediyoruz. Bu veri tipinin adı ‘liste’. Önceki derslerimizdeöğrendiğimizdir()fonksiyonunundalisteadlıbuveritipiniverdiğinihatırlıyor olmalısınız. İlerleyen derslerde, tıpkı karakter dizileri ve sayılar adlı veri tipleri gibi, liste adlı veritipinidebütünayrıntılarıylainceleyeceğiz.Şimdilikbizsadecebazıdurumlardalisteveri tipininkarakterdizilerinekıyasladahakullanışlıbirveritipiolduğunubilelimyeter. Yukarıdaki örnekten de gördüğünüz gibi, sys.version komutunun çıktısını split() metodu yardımıylaboşluklardanbölerekbirlisteeldeettik.Bulisteninilköğesi,kullandığımızPython serisininsürümnumarasınıverecektir: >>> print(sürüm.split()[0]) 3.7.0 Böylecesplit()metodunuöğrenmişolduk.Gelelimrsplit()metoduna... rsplit()metoduheryönüylesplit()metodunabenzer.split()ilersplit()arasındakitek fark,split()metodununkarakterdizisinisoldansağa,rsplit()metodununisesağdansola doğru okumasıdır. Şu örnekleri dikkatlice inceleyerek bu iki metot arasındaki farkı bariz bir şekildegörebilirsiniz: >>> kardiz.split(" ", 1) [’Ankara’, ’Büyükşehir Belediyesi’] >>> kardiz.rsplit(" ", 1) [’Ankara Büyükşehir’, ’Belediyesi’] Gördüğünüz gibi, split() metodu karakter dizisini soldan sağa doğru okuduğu için bölme işlemini“Ankara”karakterdizisineuyguladı.rsplit()metoduisekarakterdizisinisağdansola soğruokuduğuiçinbölmeişlemini“Belediyesi”adlıkarakterdizisineuyguladı. rsplit() metodunun pek yaygın kullanılan bir metot olmadığını belirterek splitlines() metodunageçelim. Bildiğiniz gibi, split() metodunu bir karakter dizisini kelime kelime ayırabilmek için kullanabiliyoruz. splitlines() metodunu ise bir karakter dizisini satır satır ayırmak için kullanabiliriz. Mesela elinizde uzun bir metin olduğunu ve amacınızın bu metin içindeki herbir satırı ayrı ayrı almak olduğunu düşünün. İşte splitlines() metoduyla bu amacınızı gerçekleştirebilirsiniz.Hemenbirörnekverelim: metin = """Python programlama dili Guido Van Rossum adlı Hollandalı bir␣ programcı ˓→ tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,␣ (sonrakisayfayadevam) 17.2. split(),rsplit(),splitlines() 297 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) isminin ˓→ Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton␣ yılanından ˓→ gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir␣ İngiliz ˓→ komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.""" print(metin.splitlines()) Buprogramıçalıştırdığınızdaşöylebirçıktıalırsınız: [’Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı ’, "tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin", ’Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını ’, ’düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından ’, ’gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz ’, "komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek ", ’adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama ’, ’dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek ’, ’halini almıştır diyebiliriz.’] Gördüğünüzgibi,metnimizEntertuşunabastığımıznoktalardanbölündü.Bizhenüzbuçıktıyı nasıl değerlendireceğimizi ve bu çıktıdan nasıl yararlanacağımızı bilmiyoruz. Ayrıca şu anda buçıktıgözünüzeçokanlamlıgörünmemişolabilir.Ama‘Listeler’adlıkonuyuöğrendiğimizde buçıktısizeçokdahaanlamlıgörünecek. splitlines() metodu yukarıdaki gibi parametresiz olarak kullanılabileceği gibi, bir adet parametreiledekullanılabilir.Bunubirörneküzerindegösterelim: metin = """Python programlama dili Guido Van Rossum adlı Hollandalı bir␣ programcı ˓→ tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,␣ isminin ˓→ Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton␣ yılanından ˓→ gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir␣ İngiliz ˓→ komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.""" print(metin.splitlines(True)) Buprogramıçalıştırdığımızdaşunabenzerbirsonuçeldeederiz: 298 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 [’Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı \n’, "tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin \n", ’Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını \n’, ’düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından \n’, ’gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz \n’, "komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek \n", ’adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama \n’, ’dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek \n’, ’halini almıştır diyebiliriz.’] Gördüğünüz gibi, parametresiz kullanımda, program çıktısında satır başı karakterleri (\n) görünmüyor. Ama eğer splitlines() metoduna parametre olarak True verirsek program çıktısında satır başı karakterleri de görünüyor. Yazdığınız programlarda ihtiyacınıza göre splitlines()metodunuparametreliolarakveyaparametresizbirşekildekullanabilirsiniz. 17.3 lower() Mutlaka karşılaşmışsınızdır. Bazı programlarda kullanıcıdan istenen veriler büyük-küçük harfe duyarlıdır. Yani mesela kullanıcıdan bir parola isteniyorsa, kullanıcının bu parolayı büyük-küçükharfedikkatederekyazmasıgerekir.Buprogramlaraçısından,örneğin‘parola’ve ‘Parola’aynıkelimelerdeğildir.Meselakullanıcınınparolası‘parola’ise,bukullanıcıprograma ‘Parola’yazarakgiremez. Bazı başka programlarda ise bu durumun tam tersi söz konusudur. Yani büyük-küçük harfe duyarlı programların aksine bazı programlar da kullanıcıdan gelen verinin büyük harfli mi yoksa küçük harfli mi olduğunu önemsemez. Kullanıcı doğru kelimeyi büyük harfle de yazsa,küçükharfledeyazsaprogramistenenişlemigerçekleştirir.MeselaGoogle’dayapılan aramalar bu mantık üzerine çalışır. Örneğin ‘kitap’ kelimesini Google’da aratıyorsanız, bu kelimeyi büyük harfle de yazsanız, küçük harfle de yazsanız Google size aynı sonuçları gösterecektir. Google açısından, aradığınız kelimeyi büyük ya da küçük harfle yazmanızın bir önemiyoktur. Şimdişöylebirprogramyazdığımızıdüşünün: kişi = input("Aradığınız kişinin adı ve soyadı: ") if kişi == "Ahmet Öz": print("email: aoz@hmail.com") print("tel : 02121231212") print("şehir: istanbul") elif kişi == "Mehmet Söz": print("email: msoz@zmail.com") print("tel : 03121231212") print("şehir: ankara") elif kişi == "Mahmut Göz": print("email: mgoz@jmail.com") print("tel : 02161231212") (sonrakisayfayadevam) 17.3. lower() 299 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("şehir: istanbul") else: print("Aradığınız kişi veritabanında yok!") Bu programın doğru çalışabilmesi için kullanıcının, örneğin, Ahmet Öz adlı kişiyi ararken büyük-küçükharfedikkatetmesigerekir.EğerkullanıcıAhmetÖzyazarsaokişiyleilgilibilgileri alabilir, ama eğer mesela Ahmet öz yazarsa bilgileri alamaz. Peki acaba biz bu sorunun üstesinden nasıl gelebiliriz? Yani programımızın büyük-küçük harfe duyarlı olmamasını nasıl sağlayabiliriz? Bu işi yapmanın iki yolu var: Birincisi if bloklarını her türlü ihtimali düşünerek yazabiliriz. Mesela: if kişi == "Ahmet Öz" or kişi == "Ahmet öz" or kişi == "ahmet öz": ... Ama burada bazı problemler var. Birincisi, kullanıcının kaç türlü veri girebileceğini kestiremeyebilirsiniz. İkincisi, kestirebilseniz bile, her kişi için olasılıkları girmeye çalışmak eziyettenbaşkabirşeydeğildir... İşteburadaimdadımızalower()metoduyetişecek.Dikkatliceinceleyin: kişi = input("Aradığınız kişinin adı ve soyadı: ") kişi = kişi.lower() if kişi == "ahmet öz": print("email: aoz@hmail.com") print("tel : 02121231212") print("şehir: istanbul") elif kişi == "mehmet söz": print("email: msoz@zmail.com") print("tel : 03121231212") print("şehir: ankara") elif kişi == "mahmut göz": print("email: mgoz@jmail.com") print("tel : 02161231212") print("şehir: istanbul") else: print("Aradığınız kişi veritabanında yok!") Artıkkullanıcı‘ahmetöz’deyazsa,‘AhmetÖz’deyazsa,hatta‘AhMeTöZ’deyazsaprogramımız doğruçalışacaktır.Pekibunasıloluyor?Elbettelower()metodusayesinde... Yukarıdaki örneklerin de bize gösterdiği gibi, lower() metodu, karakter dizisindeki bütün harfleriküçükharfeçeviriyor.Örneğin: >>> kardiz = "ELMA" (sonrakisayfayadevam) 300 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> kardiz.lower() ’elma’ >>> kardiz = "arMuT" >>> kardiz.lower() ’armut’ >>> kardiz = "PYTHON PROGRAMLAMA" >>> kardiz.lower() ’python programlama’ Eğer karakter dizisi zaten tamamen küçük harflerden oluşuyorsa bu metot hiçbir işlem yapmaz: >>> kardiz = "elma" >>> kardiz.lower() ’elma’ İşte verdiğimiz örnek programda da lower() metodunun bu özelliğinden yararlandık. Bu metot sayesinde, kullanıcı ne tür bir kelime girerse girsin, bu kelimeler her halükarda küçük harfeçevrileceğiiçin,ifbloklarıkullanıcıdangelenveriyiyakalayabilecektir. Gördüğünüz gibi, son derece kolay ve kullanışlı bir metot bu. Ama bu metodun bir problemi var.Şuörneğidikkatliceinceleyin: >>> il = "İSTANBUL" >>> print(il.lower()) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "C:\Python33\lib\encodings\cp857.py", line 19, in encode return codecs.charmap_encode(input,self.errors,encoding_map)[0] UnicodeEncodeError: ’charmap’ codec can’t encode character ’\u0307’ in position 1: character maps to <undefined> Buradaki problem ‘İ’ harfinden kaynaklanıyor. Python programlama dili bu harfi Türkçeye uygunbirşekildeküçültemediğiiçinyukarıdakihatayıalıyoruz.Yukarıdakihatanıntamolarak neanlamageldiğinibirkaçbölümsonraanlayacaksınız.BizşimdiliksadecePython’ın‘İ’harfini Türkçeyeuygunolarakküçültemediğinibilelimyeter. Birdeşuörneğebakalım: >>> il = "ADIYAMAN" >>> print(il.lower()) adiyaman Gördüğünüzgibi,Pythonprogramlamadili‘I’harfinidedüzgünküçültemiyor.‘I’harfininküçük 17.3. lower() 301 PythonBelgeleri,Yayım4.1.3 biçimi‘ı’olmasıgerekirken,bumetot‘I’harfini‘i’diyeküçültüyor.Yani: >>> "I".lower() ’i’ Pekibudurumdaneyapacağız?Elimizkolumuzbağlıoturacakmıyız?Elbettehayır!Bizbutür küçük sorunları aşabilecek kadar Python bilgisine sahibiz. ‘İ’ ve ‘I’ harfleri ile ilgili problemi, yalnızcamevcutbilgilerimizikullanarakrahatlıklaçözebiliriz: iller = "ISPARTA, ADIYAMAN, DİYARBAKIR, AYDIN, BALIKESİR, AĞRI" iller = iller.replace("I", "ı").replace("İ", "i").lower() print(iller) Bukodlarlayaptığımızşeyçokbasit: 1. İlk replace() metoduyla karakter dizisi içinde geçen bütün ‘I’ harflerini, ‘ı’ ile değiştiriyoruz. 2. İkinci replace() metoduyla karakter dizisi içinde geçen bütün ‘İ’ harflerini ‘i’ ile değiştiriyoruz. 3. Bu iki işlemin ardından karakter dizisi içinde geçen ‘I’ ve ‘İ’ harflerini küçültmüş olduk. Ancak öteki harfler henüz küçülmedi. O yüzden de karakter dizimiz üzerine bir de lower() metodunu uyguluyoruz. Böylece bütün harfler düzgün bir şekilde küçülmüş oluyor. 4. Bukodlardafarklımetotlarıuçucanasıleklediğimizedikkatedin. Bu örnek size şunu göstermiş olmalı: Aslında programlama dediğimiz şey gerçekten de çok basit parçaların uygun bir şekilde birleştirilmesinden ibaret. Tıpkı bir yap-bozun parçalarını birleştirmekgibi... Ayrıca bu örnek sizi bir gerçekle daha tanıştırıyor: Gördüğünüz gibi, artık Python’da o kadar ilerlediniz ki Python’ın problemlerini tespit edip bu problemlere çözüm dahi üretebiliyorsunuz! 17.4 upper() Bu metot biraz önce öğrendiğimiz lower() metodunun yaptığı işin tam tersini yapar. Hatırlarsanız lower() metodu yardımıyla karakter dizileri içindeki harfleri küçültüyorduk. upper()metoduisebuharfleribüyütmemizisağlar. Örneğin: >>> kardiz = "kalem" >>> kardiz.upper() ’KALEM’ lower()metodunuanlatırken,kullanıcıdangelenverileribellibirdüzenesokmakkonusunda bu metodun oldukça faydalı olduğunu söylemiştik. Kullanıcıdan gelen verilerin lower() metodu yardımıyla standart bir hale getirilmesi sayesinde, kullanıcının girdiği kelimelerin 302 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 büyük-küçük harfli olmasının önemli olmadığı programlar yazabiliyoruz. Elbette eğer isterseniz kullanıcıdan gelen bütün verileri lower() metoduyla küçük harfe çevirmek yerine, upper() metoduyla büyük harfe çevirmeyi de tercih edebilirsiniz. Python programcıları genellikle kullanıcı verilerini standart bir hale getirmek için bütün harfleri küçültmeyi tercih eder,amatabiikisizinbununtersiniyapmakistemenizinönündehiçbirengelyok. Diyelimki,şehirleregörehavadurumubilgisiverenbirprogramyazmakistiyorsunuz.Bunun içinşöylebirkodyazarakişebaşlayabilirsiniz: şehir = input("Hava durumunu öğrenmek için bir şehir adı girin: ") if şehir == "ADANA": print("parçalı bulutlu") elif şehir == "ERZURUM": print("karla karışık yağmurlu") elif şehir == "ANTAKYA": print("açık ve güneşli") else: print("Girdiğiniz şehir veritabanında yok!") Buradaprogramımızındoğruçalışabilmesi,kullanıcınınşehiradlarınıbüyükharflegirmesine bağlıdır. Örneğin programımız ‘ADANA’ cevabını kabul edecek, ama mesela ‘Adana’ cevabını kabul etmeyecektir. Bunu engellemek için lower() metodunu kullanabileceğimizi biliyoruz. Busorunuçözmekiçinaynışekildeupper()metodunudakullanabiliriz: şehir = input("Hava durumunu öğrenmek için bir şehir adı girin: ") şehir = şehir.upper() if şehir == "ADANA": print("parçalı bulutlu") elif şehir == "ERZURUM": print("karla karışık yağmurlu") elif şehir == "ANTAKYA": print("açık ve güneşli") else: print("Girdiğiniz şehir veritabanında yok!") Burada yazdığımız şehir = şehir.upper() kodu sayesinde artık kullanıcı şehir adını büyük harfledegirse,küçükharfledegirseprogramımızdüzgünçalışacaktır. Hatırlarsanız lower() metodunu anlatırken bu metodun bazı Türkçe karakterlerle problemi olduğunu söylemiştik. Aynı sorun, tahmin edebileceğiniz gibi, upper() metodu için de geçerlidir. Dikkatliceinceleyin: 17.4. upper() 303 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "istanbul" >>> kardiz.upper() ’ISTANBUL’ lower()metoduTürkçe’deki‘I’harfini‘i’şeklindeküçültüyordu.upper()metoduise‘i’harfini yanlışolarak‘I’şeklindebüyütüyor.Elbettebusorundaçözülemeyecekgibideğil.Buradada lower()metoduiçinuyguladığımızyönteminbirbenzeriniuygulayacağız: iller = "istanbul, izmir, siirt, mersin" iller = iller.replace("i", "İ").upper() print(iller) Bu kodlarla, önce karakter dizisi içinde geçen ‘i’ harflerini ‘İ’ ile değiştiriyoruz. Böylece şöyle birşeyeldeetmişoluyoruz: İstanbul, İzmİr, sİİrt, mersİn Gördüğünüz gibi öteki harfler eski hallerinde kaldı. Öteki harfleri de büyütebilmek için karakterdizisineupper()metodunuuygulamamızyeterliolacaktır. Bir sorunun daha üstesinden geldiğimize göre kendimizden emin bir şekilde bir sonraki metodumuzuincelemeyegeçebiliriz. 17.5 islower(), isupper() Yukarıda öğrendiğimiz lower() ve upper() adlı metotlar karakter dizileri üzerinde bazı değişiklikler yapmamıza yardımcı oluyor. Karakter dizileri üzerinde birtakım değişiklikler yapmamızısağlayanbutürmetotlara‘değiştiricimetotlar’adıverilir.Butürmetotlarındışında bir de ‘sorgulayıcı metotlar’dan söz edebiliriz. Sorgulayıcı metotlar, değiştirici metotların aksine, bir karakter dizisi üzerinde değişiklik yapmamızı sağlamaz. Bu tür metotların görevi karakter dizilerinin durumunu sorgulamaktır. Sorgulayıcı metotlara örnek olarak islower() veisupper()metotlarınıverebiliriz. Bildiğinizgibi,lower()metodubirkarakterdizisinitamamenküçükharflerdenoluşacakşekle getiriyordu. islower() metodu ise bir karakter dizisinin tamamen küçük harflerden oluşup oluşmadığınısorguluyor. Hemenbirörnekverelim: >>> kardiz = "" >>> kardiz.islower() True “”tamamenküçükharflerdenoluşanbirkarakterdizisiolduğuiçinislower()sorgusu Trueçıktısıveriyor.Birdeşunabakalım: >>> kardiz = "Ankara" >>> kardiz.islower() (sonrakisayfayadevam) 304 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) False “Ankara” ise içinde bir adet büyük harf barındırdığı için islower() sorgusuna False cevabı veriyor. Yazdığınız programlarda, örneğin, kullanıcıdan gelen verinin sadece küçük harflerden oluşmasını istiyorsanız bu metottan yararlanarak kullanıcıdan gelen verinin gerçekten tamamenküçükharflerdenoluşupoluşmadığınıdenetleyebilirsiniz: veri = input("Adınız: ") if not veri.islower(): print("Lütfen isminizi sadece küçük harflerle yazın") isupper() metodu da islower() metodunun yaptığı işin tam tersini yapar. Bildiğiniz gibi, upper() metodu bir karakter dizisini tamamen büyük harflerden oluşacak şekle getiriyordu. isupper()metoduisebirkarakterdizisinintamamenbüyükharflerdenoluşupoluşmadığını sorguluyor: >>> kardiz = "" >>> kardiz.isupper() True >>> kardiz = "python" >>> kardiz.isupper() False Tıpkı islower() metodunda olduğu gibi, isupper() metodunu da kullanıcıdan gelen verinin büyükharflimiyoksaküçükharflimiolduğunudenetlemekiçinkullanabilirsiniz. Örneğin, internet kültüründe kullanıcıların forum ve e.posta listesi gibi yerlerde tamamı büyük harflerden oluşan kelimelerle yazması kaba bir davranış olarak kabul edilir. Kullanıcıların tamamı büyük harflerden oluşan kelimeler kullanmasını engellemek için yukarıdakimetotlardanyararlanabilirsiniz: veri = input("mesajınız: ") böl = veri.split() for i in böl: if i.isupper(): print("Tamamı büyük harflerden oluşan kelimeler kullanmayın!") Burada kullanıcının girdiği mesaj içindeki her kelimeyi tek tek sorgulayabilmek için öncelikle split() metodu yardımıyla karakter dizisini parçalarına ayırdığımıza dikkat edin. böl = veri.split() satırının tam olarak ne işe yaradığını anlamak için bu programı bir de o satır olmadançalıştırmayıdeneyebilirsiniz. islower() ve isupper() metotları programlamada sıklıkla kullanılan karakter dizisi metotlarından ikisidir. Dolayısıyla bu iki metodu iyi öğrenmek programlama maceranız 17.5. islower(),isupper() 305 PythonBelgeleri,Yayım4.1.3 sırasındaişleriniziepeykolaylaştıracaktır. 17.6 endswith() Tıpkı isupper() ve islower() metotları gibi, endswith() metodu da sorgulayıcı metotlardan biridir. endswith() metodu karakter dizileri üzerinde herhangi bir değişiklik yapmamızı sağlamaz.Bumetodungörevikarakterdizisinindurumunusorgulamaktır. Bumetotyardımıylabirkarakterdizisininhangikarakterdizisiilebittiğinisorgulayabiliyoruz. Yaniörneğin: >>> kardiz = "" >>> kardiz.endswith("a") True Burada, değeri “” olan kardiz adlı bir karakter dizisi tanımladık. Daha sonra da kardiz.endswith("a") ifadesiyle bu karakter dizisinin “a” karakteri ile bitip bitmediğini sorguladık. Gerçekten de “” karakter dizisinin sonunda “a” karakteri bulunduğu için PythonbizeTruecevabıverdi.Birdeşunabakalım: >>> kardiz.endswith("z") False BudefadaFalseçıktısıaldık.Çünkükarakterdizimiz‘z’harfiylebitmiyor. Gelinistersenizelimizialıştırmakiçinbumetotlabirkaçörnekdahayapalım: d1 = "python.ogg" d2 = "tkinter.mp3" d3 = "pygtk.ogg" d4 = "movie.avi" d5 = "sarki.mp3" d6 = "filanca.ogg" d7 = "falanca.mp3" d8 = "dosya.avi" d9 = "perl.ogg" d10 = "c.avi" d11 = "c++.mp3" for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: if i.endswith(".mp3"): print(i) Bu örnekte, elimizde farklı uzantılara sahip bazı dosyalar olduğunu varsaydık ve bu dosya adlarının herbirini ayrı birer değişken içinde depoladık. Gördüğünüz gibi, dosya uzantıları .ogg,.mp3veya.avi.Bizimburadaamacımızelimizdekimp3dosyalarınılistelemek.Buişlem içinendswith()metodundanyararlanabiliyoruz.Buradayaptığımızşeyşu: Öncelikle d1, d2, d3, d4, d5, d6, d7, d8, d9, d10 ve d11 adlı değişkenleri bir for döngüsü içinealıyoruzvebudeğişkenlerininherbirininiçeriğinitektekkontrolediyoruz(for i in d1, 306 Bölüm17. KarakterDizilerininMetotları PythonBelgeleri,Yayım4.1.3 d2, d3, d4, d5, d6, d7, d8, d9, d10, d11:). Ardından, eğer baktığımız bu değişkenlerin değerleri “.mp3” ifadesi ile bitiyorsa (if i.endswith(".mp3"):), ölçüte uyan bütün karakter dizileriniekranadöküyoruz(print(i)). Yukarıdakiörneği,dilerseniz,endswith()metodunukullanmadanşöyledeyazabilirsiniz: for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: if i[-4:len(i)] == ".mp3": print(i) Burada karakter dizilerinin dilimlenebilme özelliğinden yararlandık. Ancak gördüğünüz gibi, dilimlenecek kısmı ayarlamaya uğraşmak yerine endswith() metodunu kullanmak çok daha mantıklıvekolaybiryöntemdir. Yukarıdakiörnektedegördüğünüzgibi,endswith()metoduözellikledosyauzantılarınagöre dosyatürlerinitespitetmedeoldukçaişeyararbirmetottur. 17.7 startswith() Bu metot, biraz önce gördüğümüz endswith() metodunun yaptığı işin tam tersini yapar. Hatırlarsanız endswith() metodu bir karakter dizisinin hangi karakter veya karakterlerle bittiğini denetliyordu. startswith() metodu ise bir karakter dizisinin hangi karakter veya karakterlerlebaşladığınıdenetler: >>> kardiz = "python" >>> kardiz.startswith("p") True >>> kardiz.startswith("a") False Gördüğünüz gibi, eğer karakter dizisi gerçekten belirtilen karakterle başlıyorsa Python True çıktısı,yokeğerbelirtilenkarakterlebaşlamıyorsaFalseçıktısıveriyor. Bumetodungerçekhayattanasılkullanılabileceğinedairbirörnekverelim: d1 = "python.ogg" d2 = "tkinter.mp3" d3 = "pygtk.ogg" d4 = "movie.avi" d5 = "sarki.mp3" d6 = "filanca.ogg" d7 = "falanca.mp3" d8 = "dosya.avi" d9 = "perl.ogg" d10 = "c.avi" d11 = "c++.mp3" for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: (sonrakisayfayadevam) 17.7. startswith() 307 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if i.startswith("p"): print(i) Burada ‘p’ harfiyle başlayan bütün dosyaları listeledik. Elbette aynı etkiyi şu şekilde de elde edebilirsiniz: for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: if i[0] == "p": print(i) Sadece tek bir harfi sorguluyorsanız yukarıdaki yöntem de en az startswith() metodunu kullanmak kadar pratiktir. Ama birden fazla karakteri sorguladığınız durumlarda elbette startswith()çokdahamantıklıbirterciholacaktır: for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: if i.startswith("py"): print(i) Yukarıdayazdığımızkodudilimlemetekniğindenyararlanarakyenidenyazmakistersenizşöyle birşeyleryapmanızgerekiyor: for i in d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: if i[:2] == "py": print(i) Dediğim gibi, birden fazla karakteri sorguladığınız durumlarda, dilimlemek istediğiniz kısmın karakter dizisi içinde hangi aralığa denk geldiğini hesaplamaya uğraşmak yerine, daha kolay biryöntemolanstartswith()metodundanyararlanmayıtercihedebilirsiniz. Böylece karakter dizilerinin 2. bölümünü de bitirmiş olduk. Sonraki bölümde yine karakter dizilerininmetotlarındansözetmeyedevamedeceğiz. 308 Bölüm17. KarakterDizilerininMetotları 18 BÖLÜM Karakter Dizilerinin Metotları (Devamı) Karakter dizileri konusunun en başında söylediğimiz gibi, karakter dizileri metot yönünden bir hayli zengin bir veri tipidir. Bir önceki bölümde karakter dizileri metotlarının bir kısmını incelemiştik.Bubölümdeyinemetotlarıincelemeyedevamedeceğiz. 18.1 capitalize() Hatırlarsanız, bir önceki bölümde öğrendiğimiz startswith() ve endswith() metotları karakterdizileriüzerindeherhangibirdeğişiklikyapmıyordu.Buikimetodungörevi,karakter dizilerini sorgulamamızı sağlamaktı. Şimdi göreceğimiz capitalize() metodu ise karakter dizileri üzerinde değişiklik yapmamızı sağlayacak. Dolayısıyla bu capitalize() metodu da ‘değiştiricimetotlar’danbiridirdiyebiliriz. Hatırlarsanız, upper() ve lower() metotları bir karakter dizisi içindeki bütün karakterleri etkiliyordu.Yanimeselaupper()metodunubirkarakterdizisineuygularsak,okarakterdizisi içindeki bütün karakterler büyük harfe dönecektir. Aynı şekilde lower() metodu da bir karakterdizisiiçindekibütünkarakterleriküçükharfeçevirir. Şimdi göreceğimiz capitalize() metodu da upper() ve lower() metotlarına benzemekle birlikte onlardan biraz daha farklı davranır: capitalize() metodunun görevi karakter dizilerininyalnızcailkharfinibüyütmektir.Örneğin: >>> a = "python" >>> a.capitalize() ’Python’ Bumetodukullanırkendikkatetmemizgerekenbirnoktavar:Bumetotbirkarakterdizisinin yalnızcailkharfinibüyütür.Yanibirdenfazlakelimedenoluşankarakterdizilerinebumetodu uyguladığımızda bütün kelimelerin ilk harfi büyümez. Yalnızca ilk kelimenin ilk harfi büyür. Yani: 309 PythonBelgeleri,Yayım4.1.3 >>> a = "python programlama dili" >>> a.capitalize() ’Python programlama dili’ “python programlama dili” üç kelimeden oluşan bir karakter dizisidir. Bu karakter dizisi üzerine capitalize() metodunu uyguladığımızda bu üç kelimenin tamamının ilk harfleri büyümüyor.Yalnızcailk‘python’kelimesininilkharfibumetottanetkileniyor. Buaradacapitalize()metodunukullanırkenbirşeydikkatiniziçekmişolmalı.Bumetodun da,tıpkıupper()velower()metotlarındaolduğugibi,Türkçekarakterlerdenbazılarıileufak birproblemivar.Meselaşuörneğebirbakın: >>> kardiz = "istanbul" >>> kardiz.capitalize() ’Istanbul’ ‘istanbul’ kelimesinin ilk harfi büyütüldüğünde ‘İ’ olması gerekirken ‘I’ oldu. Bildiğiniz gibi bu problem ‘ş’, ‘ç’, ‘ö’, ‘ğ’ ve ‘ü’ gibi öteki Türkçe karakterlerde karşımıza çıkmaz. Sadece ‘i’ ve ‘İ’ harflerikarakterdizisimetotlarındabizeproblemçıkaracaktır.Amaendişeetmemizehiçgerek yok.Busorunudabasitbir‘if-else’yapısıylaçözebilecekkadarPythonbilgisinesahibiz: kardiz = "istanbul büyükşehir belediyesi" if kardiz.startswith("i"): kardiz = "İ" + kardiz[1:] kardiz = kardiz.capitalize() print(kardiz) Burada yaptığımız şey şu: Eğer değişkenin tuttuğu karakter dizisi ‘i’ harfi ile başlıyorsa, "İ" + kardiz[1:] kodunu kullanarak karakter dizisinin ilk harfi dışında kalan kısmıyla ‘İ’ harfini birleştiriyoruz. Bu yapıyı daha iyi anlayabilmek için etkileşimli kabukta şu denemeleri yapabilirsiniz: >>> kardiz = "istanbul" >>> kardiz[1:] ’stanbul’ Gördüğünüz gibi, kardiz[1:] kodu bize karakter dizisinin ilk harfi hariç geri kalan kısmını veriyor. Bu yapıyı dilimleme konusundan hatırlıyor olmalısınız. İşte biz dilimleme tekniğinin bu özelliğinden yararlanarak, karakter dizisinin ilk harfini kesip, baş tarafa bir adet ‘İ’ harfi ekliyoruz: >>> "İ" + kardiz[1:] ’İstanbul’ Hatırlarsanızkarakterdizilerinindeğiştirilemeyenbirveritipiolduğunusöylemiştik.Oyüzden, 310 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 karakter dizisinin “stanbul” kısmını ‘İ’ harfiyle birleştirdikten sonra, bu değişikliğin kalıcı olabilmesi için kardiz = "İ" + kardiz[1:] kodu yardımıyla, yaptığımız değişikliği tekrar kardizadlıbirdeğişkeneatıyoruz. Böylece; if kardiz.startswith("i"): kardiz = "İ" + kardiz[1:] kodlarının ne yaptığını anlamış olduk. Kodların geri kalanında ise şöyle bir kod bloğu görüyoruz: kardiz = kardiz.capitalize() Buna göre, hangi harfle başlarsa başlasın Python’ın standart capitalize() metodunu bu karakterdizisiüzerineuyguluyoruz. Son olarak da print(kardiz) kodunu kullanarak yeni karakter dizisini ekrana yazdırıyoruz ve böylece capitalize() metodundaki Türkçe karakter sorununu kıvrak bir çalımla aşmış oluyoruz. 18.2 title() Bu metot biraz önce öğrendiğimiz capitalize() metoduna benzer. Bildiğiniz gibi capitalize()metodubirkarakterdizisininyalnızcailkharfinibüyütüyordu.title()metodu da karakter dizilerinin ilk harfini büyütür. Ama capitalize() metodundan farklı olarak bu metot, birden fazla kelimeden oluşan karakter dizilerinin her kelimesinin ilk harflerini büyütür. Bunubirörneküzerindeanlatsaksanırımdahaiyiolacak: >>> a = "python programlama dili" >>> a.capitalize() ’Python programlama dili’ >>> a.title() ’Python Programlama Dili’ capitalize() metodu ile title() metodu arasındaki fark bariz bir biçimde görünüyor. Dediğimizgibi,capitalize()metoduyalnızcailkkelimeninilkharfinibüyütmekleyetinirken, title()metodukarakterdizisiiçindekibütünkelimelerinilkharflerinibüyütüyor. Tahmin edebileceğiniz gibi, capitalize() metodundaki Türkçe karakter problemi title() metoduiçindegeçerlidir.Yani: >>> kardiz = "istanbul" >>> kardiz.title() ’Istanbul’ (sonrakisayfayadevam) 18.2. title() 311 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> kardiz = "istanbul büyükşehir belediyesi" >>> kardiz.title() ’Istanbul Büyükşehir Belediyesi’ Gördüğünüz gibi, burada da Python ‘i’ harfini düzgün büyütemedi. Ama tabii ki bu bizi durduramaz!Çözümümüzhazır: kardiz = "istanbul" if kardiz.startswith("i"): kardiz = "İ" + kardiz[1:] kardiz = kardiz.title() else: kardiz = kardiz.title() print(kardiz) Bu kodların capitalize() metodunu anlatırken verdiğimiz koda ne kadar benzediğini görüyorsunuz. Bu iki kod hemen hemen birbirinin aynısı. Tek fark, en sondaki kardiz.capitalize() kodunun burada kardiz.title() olması ve if bloğu içine ek olarak kardiz = kardiz.title() satırını yazmış olmamız. kardiz.capitalize() kodunun neden kardiz.title() koduna dönüştüğünü açıklamaya gerek yok. Ama eğer kardiz = kardiz.title() kodunun ne işe yaradığını tam olarak anlamadıysanız o satırı silin ve kardiz değişkeninindeğerini“istanbulbüyükşehirbelediyesi”yapın.Yani: kardiz = "istanbul büyükşehir belediyesi" if kardiz.startswith("i"): kardiz = "İ" + kardiz[1:] else: kardiz = kardiz.title() print(kardiz) Bukodlarıbuşekildeçalıştırırsanızşuçıktıyıalırsınız: İstanbul büyükşehir belediyesi Buradayalnızcailkkelimeninilkharfibüyüdü.Halbukititle()metodununişleyişigereğince karakter dizisi içindeki bütün kelimelerin ilk harflerinin büyümesi gerekiyordu. İşte o satır bütün kelimelerin ilk harflerinin büyümesini sağlıyor. Eğer bir kelimenin ilk harfi zaten büyükse title() metodu bu harfe dokunmaz, ama karakter dizisi içindeki öbür kelimelerin ilkharfleriniyinedebüyütür. İşte yukarıda title() metodunun bu özelliğinden faydalanıyoruz. kardiz = "İ" + kardiz[1:]komutukarakterdizisininilkkelimesininilkharfinidüzgünbirşekildebüyütüyor, ama geri kalan kelimelere hiçbir şey yapmıyor. kardiz = kardiz.title() komutu ise karakter dizisi içindeki geri kalan kelimelerin ilk harflerini büyütüyor. Böylece istediğimiz çıktıyı elde edebilmiş oluyoruz. Yalnız bu kodlarda bir şey dikkatinizi çekmiş olmalı. kardiz = kardiz.title() komutunu program içinde iki yerde kullandık. Programcılıktaki en önemli 312 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 ilkelerden biri de mümkün olduğunca tekrardan kaçınmaktır. Eğer yazdığınız bir programda aynı kodları program boyunca tekrar tekrar yazıyorsanız muhtemelen bir yerde hata yapıyorsunuzdur. Öyle bir durumda yapmanız gereken şey kodlarınızı tekrar gözden geçirip, tekrar eden kodları nasıl azaltabileceğinizi düşünmektir. İşte burada da böyle bir tekrar söz konusu.Biztekraradüşmektenkurtulmakiçinyukarıdakikodlarışöyledeyazabiliriz: kardiz = "istanbul büyükşehir belediyesi" if kardiz.startswith("i"): kardiz = "İ" + kardiz[1:] kardiz = kardiz.title() print(kardiz) kardiz = kardiz.title()komutunuhemifbloğunda,hemdeelsebloğundakullandığımız için, programımız her koşulda bu kodu zaten çalıştıracak. O yüzden bu satırı if bloğuna yazdıktansonrabirdeaynışeyielsebloğuiçineyazmakgereksiz.Onunyerineelsebloğunu tamamenkaldırıp,osatırıifbloğununçıkışınayerleştirebiliriz. Eskikodlardakimantıkişleyişişöyleidi: 1. kardizadlıbirdeğişkentanımla 2. Eğerkardiz‘i’harfiilebaşlıyorsa(if),kardiz’inilkharfihariçgerikalankısmıile‘İ’harfini birleştir. 3. Dahasonrakardizdeğişkeninetitle()metodunuuygula. 4. Eğer kardiz ‘i’ harfi ile değil de başka bir harfle başlıyorsa (else), kardiz değişkenine title()metodunuuygula. 5. Sonolarakkardizdeğişkeniniyazdır. Tekraredenkodlarıçıkardıktansonraisekodlarımızınmantıkişleyişişöyleoldu: 1. kardizadlıbirdeğişkentanımla 2. Eğerkardiz‘i’harfiilebaşlıyorsa(if),kardiz’inilkharfihariçgerikalankısmıile‘İ’harfini birleştir. 3. Dahasonrakardizdeğişkeninetitle()metodunuuygula. 4. Sonolarakkardizdeğişkeniniyazdır. Gördüğünüzgibi,aynısonucadahakısabiryoldanulaşabiliyoruz. Amabirdakika!Buradabirsorunvar! Bu kodlar ‘i’ harfinin karakter dizisinin yalnızca en başında yer aldığı durumlarda düzgün çalışacaktır.Bukodlarmeselaşukarakterdizisinidüzgünbüyütemez: on iki ada Aynışekildebukodlarşukarakterdizisinidebüyütemez: hükümet istifa! 18.2. title() 313 PythonBelgeleri,Yayım4.1.3 Çünkü bu karakter dizilerinde ‘i’ harfi karakter dizisini oluşturan kelimelerin ilkinde yer almıyor. Bizim yazdığımız kod ise yalnızca ilk kelime düşünülerek yazılmış. Peki bu sorunun üstesindennasılgeleceğiz? Evet, doğru tahmin ettiniz. Bizi kurtaracak şey split() metodu ve basit bir for döngüsü. Dikkatlicebakın: kardiz = "on iki ada" for kelime in kardiz.split(): if kelime.startswith("i"): kelime = "İ" + kelime[1:] kelime = kelime.title() print(kelime, end=" ") Bu defa istediğimizi gerçekleştiren bir kod yazabildik. Bu kodlar, ‘i’ harfi karakter dizisini oluşturan kelimelerin hangisinde bulunursa bulunsun, karakter dizisini Türkçeye uygun bir şekildebüyütebilecektir. Bir önceki kodlara göre, bu son kodlardaki tek farkın split() metodu ve for döngüsü olduğunadikkatedin. Bu kodları daha iyi anlayabilmek için etkileşimli kabukta kendi kendinize bazı deneme çalışmalarıyapabilirsiniz: >>> kardiz = "on iki ada" >>> kardiz.split() [’on’, ’iki’, ’ada’] >>> for kelime in kardiz.split(): ... print(kelime[0]) ... o i a Gördüğünüz gibi, split() metodu "on iki ada" adlı karakter dizisini kelimelerine ayırıyor. İşte biz de kelimelerine ayrılmış bu yapı üzerinde bir for döngüsü kurarak herbir öğenin ilk harfinin‘i’olupolmadığınıkontroledebiliyoruz. 18.3 swapcase() swapcase() metodu da büyük-küçük harfle ilgili bir metottur. Bu metot bir karakter dizisi içindekibüyükharfleriküçükharfe;küçükharfleridebüyükharfedönüştürür.Örneğin: >>> kardiz = "python" >>> kardiz.swapcase() (sonrakisayfayadevam) 314 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’PYTHON’ >>> kardiz = "PYTHON" >>> kardiz.swapcase() ’python’ >>> kardiz = "Python" >>> kardiz.swapcase() ’pYTHON’ Gördüğünüzgibi,bumetotaynendediğimizgibiişliyor.Yaniküçükharfleribüyükharfe;büyük harflerideküçükharfedönüştürüyor. Yinetahminedebileceğinizgibi,bumetodundabazıTürkçekarakterlerleproblemivar: >>> kardiz = "" >>> kardiz.swapcase() ’ISTIHZA’ Busorunudaaşmaktabiikibizimelimizde: kardiz = "istanbul" for i in kardiz: if i == ’İ’: kardiz = kardiz.replace(’İ’, ’i’) elif i == ’i’: kardiz = kardiz.replace(’i’, ’İ’) else: kardiz = kardiz.replace(i, i.swapcase()) print(kardiz) Daha önceki örneklerde de olduğu gibi, bu kodlarda da ‘i’ ve ‘I’ harflerini tek tek kontrolden geçiriyoruz. Eğer bir karakter dizisi içinde bu iki harften biri varsa, bunların büyük harf veya küçük harf karşılıklarını elle yerine koyuyoruz. Bu karakterler dışında kalan karakterlere ise doğrudanswapcase()metodunuuygulayarakistediğimizsonucueldeediyoruz.Bukodlarda kafanıza yatmayan yerler varsa, kodlar içinde kendinize göre bazı eklemeler çıkarmalar yaparakneyinneişeyaradığınıdahakolayanlayabilirsiniz. 18.3. swapcase() 315 PythonBelgeleri,Yayım4.1.3 18.4 casefold() Bu metot işlev olarak lower() metoduna çok benzer. Hatta Türkçe açısından, bu metodun lower()metodundanhiçbirfarkıyoktur.Ancakbazıbaşkadillerde,bumetotbazıharfleriçin lower()metodununverdiğindenfarklıbirçıktıverir.ÖrneğinAlmancadaki‘ß’harfibuduruma birörnekolabilir: >>> "ß".lower() ’ß’ >>> "ß".casefold() ’ss’ Gördüğünüzgibi,lower()vecasefold()metotlarıbuharfefarklıdavranıyor. Türkçedekiİ-isorunubumetotiçindeaynengeçerlidir. 18.5 strip(), lstrip(), rstrip() Bu başlıkta birbiriyle bağlantılı üç adet karakter dizisi metodunu inceleyeceğiz. Bu metotlar strip(),lstrip()verstrip().İlkolarakstrip()metoduylabaşlayalım. Zaman zaman, içinde anlamsız ya da gereksiz karakterler barındıran metinleri bu anlamsız ve gereksiz karakterlerden temizlemeniz gereken durumlarla karşılaşabilirsiniz. Örneğin arkadaşınızdan gelen bir e.postada her satırın başında ve/veya sonunda > gibi bir karakter olabilir. Arkadaşınızdan gelen bu e.postayı kullanabilmek için öncelikle metin içindeki o > karakterlerinisilmenizgerekebilir.Hepimizinbildiğigibi,butürkarakterlerielletemizlemeye kalkışmaksonderecesıkıcıvezamanalıcıbiryöntemdir.AmaartıksizbirPythonprogramcısı olduğunuzagörebutürangaryalarıPython’adevredebilirsiniz. Yukarıda bahsettiğimiz duruma yönelik bir örnek vermeden önce dilerseniz strip() metoduylailgiliçokbasitörneklervererekbaşlayalımişe: >>> kardiz = " " Burada değeri “ “ olan kardiz adlı bir karakter dizisi tanımladık. Dikkat ederseniz bu karakter dizisinin sağında ve solunda birer boşluk karakteri var. Bazı durumlarda kullanıcıdan ya da başka kaynaktan gelen karakter dizilerinde bu tür istenmeyen boşluklar olabilir. Ama sizin kullanıcıdan veya başka bir kaynaktan gelen o karakter dizisini düzgün kullanabilmeniz için öncelikle o karakter dizisinin sağında ve solunda bulunan boşluk karakterlerinden kurtulmanız gerekebilir. İşte böyle anlarda strip() metodu yardımınıza yetişecektir.Dikkatliceinceleyin: >>> kardiz = " " >>> print(kardiz) ’ ’ >>> kardiz.strip() ’’ 316 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,strip()metodunukullanarak,karakterdizisininorijinalindebulunansağlı solluboşlukkarakterlerinibirçırpıdaortadankaldırdık. strip() metodu yukarıdaki örnekte olduğu gibi parametresiz olarak kullanıldığında, bir karakter dizisinin sağında veya solunda bulunan belli başlı karakterleri kırpar. strip() metodununöntanımlıolarakkırptığıkarakterlerşunlardır: tabularytabulary ‘‘ boşlukkarakteri \t sekme(TAB)oluşturankaçışdizisi \n satırbaşınageçirenkaçışdizisi \r imleciaynısatırınbaşınadöndürenkaçışdizisi \v düşeysekmeoluşturankaçışdizisi \f yenibirsayfayageçirenkaçışdizisi Yani eğer strip() metoduna herhangi bir parametre vermezsek bu metot otomatik olarak karakterdizilerininsağındavesolundabulunanyukarıdakikarakterlerikırpacaktır.Ancakeğer bizistersekstrip()metodunabirparametrevererekbumetodunistediğimizherhangibaşka birkarakterikırpmasınıdasağlayabiliriz.Örneğin: >>> kardiz = "python" >>> kardiz.strip("p") ’ython’ Burada strip() metoduna parametre olarak “p” karakter dizisini vererek, strip() metodunun,karakterdizisininbaşındabulunan“p”karakteriniortadankaldırmasınısağladık. Yalnız strip() metodunu kullanırken bir noktaya dikkat etmelisiniz. Bu metot bir karakter dizisinin hem başında, hem de sonunda bulunan karakterlerle ilgilenir. Mesela şu örneğe bakalım: >>> kardiz = "kazak" >>> kardiz.strip("k") ’aza’ Gördüğünüzgibi,strip()metoduna“k”parametresinivererek,“kazak”adlıkarakterdizisinin hembaşındakihemdesonundaki“k”harflerinikırpmayıbaşardık.Eğerbumetodaverdiğiniz parametre karakter dizisinde geçmiyorsa, bu durumda strip() metodu herhangi bir işlem yapmaz.Yadaaradığınızkarakter,karakterdizisininyalnızcatekbirtarafında(meselasadece başındaveyasadecesonunda)geçiyorsa,strip()metodu,ilgilikarakterhangitaraftaysaonu siler.Aranankarakterinbulunmadığıtaraflailgilenmez. strip() metodunu anlatmaya başlarken, içinde gereksiz yere > işaretlerinin geçtiği e.postalardan söz etmiş ve bu e.postalardaki o gereksiz karakterleri elle silmenin ne kadar da sıkıcı bir iş olduğunu söylemiştik. Eğer e.postalarınızda bu tip durumlarla sık sık karşılaşıyorsanız, gereksiz karakterleri silme görevini sizin yerinize Python yerine getirebilir. Şimdişukodlarıdikkatliceinceleyin: metin = """ > Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı␣ (sonrakisayfayadevam) 18.5. strip(),lstrip(),rstrip() 317 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) tarafından ˓→ > 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python > olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını␣ düşünür. ˓→ > Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından␣ gelmez. ˓→ > Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz␣ komedi ˓→ > grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek␣ adlandırmıştır. ˓→ > Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok␣ yerde ˓→ > bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır␣ diyebiliriz. ˓→ """ for i in metin.split(): print(i.strip("> "), end=" ") Buprogramıçalıştırdığınızdaşöylebirçıktıeldeedeceksiniz: Python programlama dili Guido Van Rossum adlı Hollandalı bir programcı␣ tarafından ˓→ 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını␣ düşünür. ˓→ Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek␣ adlandırmıştır. ˓→ Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok␣ yerde ˓→ bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır␣ diyebiliriz. ˓→ Gördüğünüz gibi, her satırın başında bulunan ‘> ‘ karakterlerini ufacık birkaç kod yardımıyla rahatlıklatemizledik.Buradastrip()metoduylabirliktesplit()metodunudakullandığımızı görüyorsunuz.split()metoduileöncemetinadlıkarakterdizisiniparçaladık.Dahasonrada strip()metoduyardımıylabaştaraftakiistenmeyenkarakterleritemizledik. Yukarıdakiörnekteverdiğimizmetin,istenmeyenkarakterleriyalnızcatekbirtaraftaiçeriyor. Ama elbette istenmeyen karakterler, karakter dizisinin ne tarafında olursa olsun strip() metodubukarakterleribaşarıylakırpacaktır. Bu bölümün başlığında strip() metodu ile birlikte lstrip() ve rstrip() adlı iki metodun daha adı geçiyordu. strip() metodunun ne işe yaradığını öğrendik. Peki bu lstrip() ve rstrip()metotlarıneişeyarıyor? lstrip()metodundanbaşlayalımanlatmaya... strip() metodunu anlatırken, bu metodun bir karakter dizisinin sağında ve solunda bulunan istenmeyen karakterleri kırptığını söylemiştik. Ancak bazen, istediğimiz şey bu 318 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 olmayabilir. Yani biz bir karakter dizisinin hem sağında, hem de solunda bulunan gereksiz karakterleri değil, yalnızca sağında veya yalnızca solunda bulunan gereksiz karakterleri kırpmak isteyebiliriz. Örneğin strip() metodunu anlatırken verdiğimiz “kazak” örneğini ele alalım.Şöylebirkomutunneyapacağınıbiliyorsunuz: >>> "kazak".strip("k") Bu komut hem sol, hem de sağ taraftaki “k” karakterlerini kırpacaktır. Ama peki ya biz sadecesoltaraftaki“k”karakteriniatmakistersekneolacak?İşteböylebirdurumdastrip() metodundandeğil,lstrip()metodundanfaydalanacağız. lstrip() metodu bir karakter dizisinin sol tarafındaki gereksiz karakterlerden kurtulmamızı sağlar.Meselabubilgiyiyukarıdakiörneğeuygulayalım: >>> "kazak".lstrip("k") ’azak’ Gördüğünüzgibi,lstrip()metoduyalnızcasolbaştaki“k”harfiyleilgilendi.Sağtaraftaki“k” harfine ise dokunmadı. Eğer sol taraftaki karakteri değil de yalnızca sağ taraftaki karakteri uçurmakistemenizhalindeiserstrip()metodundanyararlanacaksınız: >>> "kazak".rstrip("k") ’kaza’ Bu arada, yukarıdaki metotları doğrudan karakter dizileri üzerine uygulayabildiğimize de dikkatedin.Yanişuikiyöntemdeuygunvedoğrudur: >>> kardiz = "karakter dizisi" >>> kardiz.metot_adı() veya: >>> "karakter dizisi".metot_adı() 18.6 join() Hatırlarsanız şimdiye kadar öğrendiğimiz metotlar arasında split() adlı bir metot vardı. Bu metodunneişeyaradığınıvenasılkullanıldığınıbiliyorsunuz: >>> kardiz = "Beşiktaş Jimnastik Kulübü" >>> bölünmüş = kardiz.split() >>> print(bölünmüş) [’Beşiktaş’, ’Jimnastik’, ’Kulübü’] Gördüğünüz gibi split() metodu bir karakter dizisini belli yerlerden bölerek parçalara ayırıyor.Bunoktadainsanınaklınaşöylebirsorugeliyor:Diyelimkielimizdeböylebölünmüş birkarakterdizisigrubuvar.Bizbugrupiçindekikarakterdizilerinitekrarbirleştirmekistersek neyapacağız? 18.6. join() 319 PythonBelgeleri,Yayım4.1.3 Şimdişukodlaraçokdikkatlicebakın: >>> " ".join(bölünmüş) ’Beşiktaş Jimnastik Kulübü’ Gördüğünüzgibi,“BeşiktaşJimnastikKulübü”adlıkarakterdizisininilkhalinitekrareldeettik. Yanibukarakterdizisineait,bölünmüşparçalarıtekrarbirarayagetirdik.Ancakbuişiyapan kodgözünüzünebiraztuhafveanlaşılmazgörünmüşolabilir. İlk başta dikkatimizi çeken şey, bu metodun öbür metotlara göre biraz daha farklı bir yapıya sahipmiş gibi görünmesi. Ama belki yukarıdaki örneği şöyle yazarsak bu örnek biraz daha anlaşılırgelebilirgözünüze: >>> birleştirme_karakteri = " " >>> birleştirme_karakteri.join(bölünmüş) Burada da tıpkı öteki metotlarda olduğu gibi, join() metodunu bir karakter dizisi üzerine uyguladık. Bu karakter dizisi bir adet boşluk karakteri. Ayrıca gördüğünüz gibi join() metodu bir adet de parametre alıyor. Bu örnekte join() metoduna verdiğimiz parametre bölünmüşadlıdeğişken.Aslındaşöylebirdüşününceyukarıdakikodlarınsankişöyleyazılması gerekiyormuşgibigelebilirsize: >>> bölünmüş.join(birleştirme_karakteri) Ama bu kullanım yanlıştır. Üstelik kodunuzu böyle yazarsanız Python size bir hata mesajı gösterecektir: >>> bölünmüş.join(birleştirme_karakteri) Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’list’ object has no attribute ’join’ Buradaki hata mesajı bize şöyle diyor: ‘liste nesnesinin join adlı bir niteliği yoktur!’. Bu cümledeki ‘liste nesnesi’ ifadesine özellikle dikkatinizi çekmek istiyorum. Biz şimdiye kadar ikitürnesne(yadabaşkabirifadeyleveritipi)görmüştük.Bunlarkarakterdizilerivesayılardı. Buradakarşımızaüçüncübirnesneçıkıyor.Gördüğümüzkadarıylabuyeninesneninadı‘liste’. (Liste adlı veri tipini birkaç bölüm sonra en ince ayrıntısına kadar inceleyeceğiz. Python’da böylebirveritipiolduğunubilmemizbizimiçinşimdilikyeterli.) İşteyukarıdakihatayıalmamızınnedeni,aslındakarakterdizilerineaitbirmetotolanjoin() metodunu bir liste üzerinde uygulamaya çalışmamız. Böyle bir durumda da Python doğal olarak bizi ‘liste nesnelerinin join adlı bir niteliği olmadığı’ konusunda uyarıyor. Bütün bu anlattıklarımız bizi şu sonuca ulaştırıyor: Bir veri tipine ait metotlar doğal olarak yalnızca o veritipiüzerindekullanılabilir.Meselayukarıdakiörnektegördüğümüzgibi,birkarakterdizisi metoduolanjoin()’ibaşkabirveritipineuygulamayaçalışırsakhataalırız. Sonuç olarak, join() adlı metodu bölünmüş adlı değişkene uygulayamayacağımızı anlamış bulunuyoruz. O halde bu metotla birlikte kullanılmak üzere bir karakter dizisi bulmamız gerekiyor. En başta da söylediğimiz gibi, join() metodunun görevi bölünmüş karakter dizisi gruplarını birleştirmektir.Bumetotgöreviniyerinegetirirken,yanikarakterdizisigruplarınıbirleştirirken 320 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 birbirleştirmekarakterineihtiyaçduyar.Bizimörneğimizdebubirleştirmekarakteribiradet boşluktur.Durumudahaiyianlayabilmekiçinörneğimizitekrargözümününönünegetirelim: >>> kardiz = "Beşiktaş Jimnastik Kulübü" >>> bölünmüş = kardiz.split() >>> print(bölünmüş) [’Beşiktaş’, ’Jimnastik’, ’Kulübü’] >>> kardiz = " ".join(bölünmüş) >>> print(kardiz) Beşiktaş Jimnastik Kulübü Gördüğünüz gibi, orijinal karakter dizisinin bölünmüş parçalarını, her bir parçanın arasında bir adet boşluk olacak şekilde yeniden birleştirdik. Elbette sadece boşluk karakteri kullanabileceğizdiyebirkaideyok.Meselaşuörneklerebakın: >>> kardiz = "-".join(bölünmüş) Beşiktaş-Jimnastik-Kulübü >>> kardiz = "".join(bölünmüş) BeşiktaşJimnastikKulübü İlkörnekte,bölünmüşkarakterdizilerini-işaretiilebirleştirdik.İkinciörnekteisebukarakter dizilerini birleştirmek için boş bir karakter dizisi kullandık. Yani parçaları birleştirirken arada boşlukolmamasınısağladık. join() metodu ile bol bol pratik yaparak bu metodu hakkıyla öğrenmenizi tavsiye ederim. Zira programcılık maceranız boyunca en sık kullanacağınız karakter dizisi metotları listesinin enbaşlarındabumetotyeralır. 18.7 count() Tıpkıdahaönceöğrendiğimizsorgulayıcımetotlargibi,count()metodudabirkarakterdizisi üzerinde herhangi bir değişiklik yapmamızı sağlamaz. Bu metodun görevi bir karakter dizisi içinde belli bir karakterin kaç kez geçtiğini sorgulamaktır. Bununla ilgili hemen bir örnek verelim: >>> şehir = "Kahramanmaraş" >>> şehir.count("a") 5 Buradananlıyoruzki,“Kahramanmaraş”adlıkarakterdizisiiçindetoplam5adet“a”karakteri geçiyor. count()metoduyaygınolarakyukarıdakiörnektegörüldüğüşekildesadecetekbirparametre ile kullanılır. Ama aslında bu metot toplam 3 parametre alır. Şimdi şu örnekleri dikkatlice inceleyin: 18.7. count() 321 PythonBelgeleri,Yayım4.1.3 >>> şehir = "adana" >>> şehir.count("a") 3 >>> şehir.count("a", 1) 2 >>> şehir.count("a", 2) 2 >>> şehir.count("a", 3) 1 >>> şehir.count("a", 4) 1 İlk örnekte count() metodunu tek bir parametre ile birlikte kullandığımız için “adana” adlı karakterdizisiiçindekibütün“a”harflerinintoplamsayısıçıktıolarakverildi. İkinci örnekte ise count() metoduna ikinci bir parametre daha verdik. Bu ikinci parametre, count() metodunun bir karakteri saymaya başlarken karakter dizisinin kaçıncı sırasından başlayacağınıgösteriyor.Buörnekteikinciparametreolarak1sayısınıverdiğimiziçin,Python saymaya “adana” karakter dizisinin 1. sırasından başlayacak. Dolayısıyla 0. sıradaki “a” harfi sayımişleminindışındakalacağıiçintoplam“a”sayısı3değil2olarakgörünecek.Gördüğünüz gibi,sonrakiörneklerdedeaynımantığıtakipettiğimiziçinaradığımızkarakterintoplamsayısı örnektenörneğefarklılıkgösteriyor. Peki bu metodu gerçek programlarda ne amaçla kullanabilirsiniz? Bu metodu kullanarak, örneğin, kullanıcıyı aynı karakterden yalnızca bir adet girmeye zorlayabilirsiniz. Bunun için meselaşöylebiryapıkullanabilirsiniz: parola = input("parolanız: ") kontrol = True for i in parola: if parola.count(i) > 1: kontrol = False if kontrol: print(’Parolanız onaylandı!’) else: print(’Parolanızda aynı harfi bir kez kullanabilirsiniz!’) Burada kontrol değişkeninin değerini True olarak belirledik. Eğer parola içindeki harflerden herhangibiri1’denfazlageçiyorsabudurumdakontroldeğişkeninindeğeriniFalseyapıyoruz: 322 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 for i in parola: if parola.count(i) > 1: kontrol = False Daha sonra da kontrol değişkeninin durumuna göre kullanıcıya parolanın onaylandığı veya onaylanmadığı bilgisini veriyoruz. Buna göre eğer kontrol değişkeninin değeri True ise şu çıktıyıveriyoruz: Parolanız onaylandı! Aksihaldeşuçıktıyıveriyoruz: Parolanızda aynı harfi bir kez kullanabilirsiniz! Yukarıdakine benzer durumların dışında count() metodunu şöyle durumlarda da kullanabilirsiniz: kelime = input("Herhangi bir kelime: ") for harf in kelime: print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf, kelime, kelime.count(harf))) Buradaamacımızkullanıcınıngirdiğibirkelimeiçindekibütünharflerinokelimeiçindekaçkez geçtiğini bulmak. count() metodunu kullanarak bu işi çok kolay bir şekilde halledebiliyoruz. Kullanıcınınmesela‘adana’kelimesinigirdiğinivarsayarsakyukarıdakiprogramşöylebirçıktı verecektir: a harfi adana kelimesinde 3 kez geçiyor! d harfi adana kelimesinde 1 kez geçiyor! a harfi adana kelimesinde 3 kez geçiyor! n harfi adana kelimesinde 1 kez geçiyor! a harfi adana kelimesinde 3 kez geçiyor! Ancak burada şöyle bir problem var: ‘adana’ kelimesi içinde birden fazla geçen harfler (mesela ‘a’ harfi) çıktıda birkaç kez tekrarlanıyor. Yani mesela ‘a’ harfinin geçtiği her yerde programımız ‘a’ harfinin kelime içinde kaç kez geçtiğini rapor ediyor. İstediğiniz davranış bu olabilir. Ama bazı durumlarda her harfin kelime içinde kaç kez geçtiği bilgisinin yalnızca bir kez raporlanmasını isteyebilirsiniz. Yani siz yukarıdaki gibi bir çıktı yerine şöyle bir çıktı elde etmekistiyorolabilirsiniz: a harfi adana kelimesinde 3 kez geçiyor! d harfi adana kelimesinde 1 kez geçiyor! n harfi adana kelimesinde 1 kez geçiyor! Böylebirçıktıeldeedebilmekiçinşöylebirprogramyazabilirsiniz: kelime = input("Herhangi bir kelime: ") sayaç = "" (sonrakisayfayadevam) 18.7. count() 323 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for harf in kelime: if harf not in sayaç: sayaç += harf for harf in sayaç: print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf, kelime, kelime.count(harf))) Gelinistersenizbukodlarışöylebirinceleyelim. Bukodlardaönceliklekullanıcıdanherhangibirkelimegirmesiniistiyoruz. Daha sonra sayaç adlı bir değişken tanımlıyoruz. Bu değişken, kullanıcının girdiği kelime içindeki harfleri tutacak. Bu değişken, kelime değişkeninden farklı olarak, kullanıcının girdiği sözcükiçindebirdenfazlageçenharflerdenyalnızcatekbirörnekiçerecek. Değişkenimizi tanımladıktan sonra bir for döngüsü kuruyoruz. Bu döngüye dikkatlice bakın. Kullanıcının girdiği kelime içinde geçen harflerden her birini yalnızca bir kez alıp sayaç değişkenine gönderiyoruz. Böylece elimizde her harften sadece bir adet olmuş oluyor. BuradaPython’ınarkaplandanelerçevirdiğinidahaiyianlayabilmekiçinistersenizdöngüden sonra şöyle bir satır ekleyerek sayaç değişkeninin içeriğini inceleyebilir, böylece burada kullandığımızfordöngüsününnasılçalıştığınıdahaiyigörebilirsiniz: print("sayaç içeriği: ", sayaç) İlkdöngümüzsayesinde,kullanıcınıngirdiğikelimeiçindekiherharfitekeindirerek,buharfleri sayaç değişkeni içinde topladık. Şimdi yapmamız gereken şey, sayaç değişkenine gönderilen her bir harfin, kelime adlı değişken içinde kaç kez geçtiğini hesaplamak olmalı. Bunu da yine birfordöngüsüileyapabiliriz: for harf in sayaç: print("{} harfi {} kelimesinde {} kez geçiyor!".format(harf, kelime, kelime.count(harf))) Burada yaptığımız şey şu: count() metodunu kullanarak, sayaç değişkeninin içindeki her bir harfin, kelime değişkeninin içinde kaç kez geçtiğini buluyoruz. Bu döngünün nasıl çalıştığını dahaiyianlayabilmekiçin,istersenizbudöngüyüşuşekildesadeleştirebilirsiniz: for harf in sayaç: print(harf, kelime, kelime.count(harf)) Gördüğünüz gibi, sayaç değişkeni içindeki herbir harfin kelime adlı karakter dizisi içinde kaç kezgeçtiğinitekteksorguladık. Yukarıdaki örneklerde count() metodunun iki farklı parametre aldığını gördük. Bu metot bunların dışında üçüncü bir parametre daha alır. Bu üçüncü parametre ikinci parametreyle ilişkilidir.Dilersenizbuilişkiyibirörneküzerindegörelim: >>> kardiz = "python programlama dili" >>> kardiz.count("a") (sonrakisayfayadevam) 324 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 3 >>> kardiz.count("a", 15) 2 Bu örneklerden anladığımıza göre, “python programlama dili” adlı karakter dizisi içinde toplam 3 adet ‘a’ harfi var. Eğer bu karakter dizisi içindeki ‘a’ harflerini karakter dizisinin en başındanitibarendeğilde,15.karakterdenitibarensaymayabaşlarsakbudurumda2adet‘a’ harfibuluyoruz.Şimdideşuörneğebakalım: >>> kardiz.count("a", 15, 17) 1 Burada, 15. karakter ile 17. karakter arasında kalan ‘a’ harflerini saymış olduk. 15. karakter ile17.karakterarasındatoplam1adet‘a’harfiolduğuiçindePythonbize1sonucunuverdi. Bütünbuörneklerdensonracount()metodunailişkinolarakşöylebirtespittebulunabiliriz: count() metodu bir karakter dizisi içinde belli bir karakterin kaç kez geçtiğini sorgulamamızısağlar.Örneğinbumetoducount("a")şeklindekullanırsakPython bize karakter dizisi içindeki bütün “a” harflerinin sayısını verecektir. Eğer bu metoda2.ve3.parametrelerideverirsek,sorgulamaişlemikarakterdizisininbelli bir kısmında gerçekleştirilecektir. Örneğin count("a", 4, 7) gibi bir kullanım, bize karakter dizisinin 4. ve 7. karakterleri arasında kalan “a” harflerinin sayısını verecektir. Böylecebirmetodudahaayrıntılıbirşekildeincelemişolduk.Artıkbaşkabirmetotincelemeye geçebiliriz. 18.8 index(), rindex() Bubölümünbaşındakarakterdizilerinindilimlenmeözelliğindensözederken,karakterdizisi içindeki her harfin bir sırası olduğunu söylemiştik. Örneğin “python” adlı karakter dizisinde ‘p’ harfinin sırası 0’dır. Aynı şekilde ‘n’ harfinin sırası ise 5’tir. Karakterlerin, bir karakter dizisi içinde hangi sırada bulunduğunu öğrenmek için index() adlı bir metottan yararlanabiliriz. Örneğin: >>> kardiz = "python" >>> kardiz.index("p") 0 >>> kardiz.index("n") 5 Eğer sırasını sorguladığımız karakter, o karakter dizisi içinde bulunmuyorsa, bu durumda Pythonbizebirhatamesajıgösterir: 18.8. index(),rindex() 325 PythonBelgeleri,Yayım4.1.3 >>> kardiz.index("z") Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: substring not found Bu metodun özelliği, sorguladığımız karakterin, karakter dizisi içinde geçtiği ilk konumu vermesidir.Yaniörneğin: >>> kardiz = "adana" >>> kardiz.index("a") 0 “adana” adlı karakter dizisi içinde 3 adet ‘a’ harfi var. Ancak biz index() metodu yardımıyla “adana” karakter dizisi içindeki ‘a’ harfinin konumunu sorgularsak, Python bize ‘a’ harfinin geçtiği ilk konumu, yani 0. konumu, bildirecektir. Halbuki “adana” karakter dizisi içinde 2. ve 4. sıralarda da birer ‘a’ harfi var. Ancak index() metodu 0. konumdaki ‘a’ harfini gördükten sonrakarakterdizisiningerikalanınabakmaz. index()metodunubizyukarıdatekbirparametreilebirliktekullandık.Buparametre,karakter dizisi içinde konumunu öğrenmek istediğimiz karakteri gösteriyor. Ama bu metot aslında toplam3parametrealır.Şuörnekleridikkatliceinceleyelim: >>> kardiz = "adana" >>> kardiz.index("a") 0 Buradanormalbirşekildeindex()metodunutekbirparametreilebirliktekullandık.Böylece Pythonbize‘a’harfininkarakterdizisiiçindeilkolarakhangisıradabulunduğunugösterdi.Bir deşuörneğebakalım: >>> kardiz.index("a", 1) 2 Gördüğünüz gibi, bu defa index() metoduna ikinci bir parametre daha verdik. index() metodunun ikinci parametresi, Python’ın aramaya kaçıncı sıradan itibaren başlayacağını gösteriyor. Biz yukarıdaki örnekte Python’ın aramaya 1. sıradan itibaren başlamasını istedik. BuyüzdenPython0.sıradaki“a”karakteriniesgeçtive2.sıradabulunan“a”karakterinigördü. Birdeşunabakalım: >>> kardiz.index("a", 3) Bu defa Python’ın aramaya 3. sıradan başlamasını istedik. Dolayısıyla Python 0. ve 2. sıralardaki‘a’harflerinigörmezdengelipbize4.sıradaki‘a’harfininsırasınıbildirdi. Gelelimindex()metodunun3.parametresine... Dilerseniz3.parametreninneişeyaradığını birörneküzerindegösterelim: 326 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 >>> kardiz = "adana" >>> kardiz.index("a", 1, 3) 2 Hatırlarsanız, bundan önce count() adlı bir metot öğrenmiştik. O metot da toplam 3 parametre alıyordu. count() metodunda kullandığımız 2. ve 3. parametrelerin görevlerini hatırlıyor olmalısınız. İşte index() metodunun 2. ve 3. parametreleri de aynen count() metodundaki gibi çalışır. Yani Python’ın sorgulama işlemini hangi sıra aralıklarından gerçekleştireceğini gösterir. Mesela yukarıdaki örnekte biz “adana” karakter dizisinin 1. ve 3. sıralarıarasındaki‘a’harflerinisorguladık.YaniyukarıdakiörnektePython‘a’harfiniaramaya 1. konumdan başladı ve aramayı 3. konumda kesti. Böylece “adana” karakter dizisinin 2. sırasındaki‘a’harfininkonumunubizebildirdi. Gördüğünüzgibi,index()metodubizearadığımızkarakterinyalnızcailkkonumunubildiriyor. Pekibizmesela“adana”karakterdizisiiçindekibütün‘a’harflerininsırasınıöğrenmekistersek neyapacağız? Bu isteğimizi yerine getirmek için karakter dizisinin her bir sırasını tek tek kontrol etmemiz yeterliolacaktır.Yanişöylebirşeyyazmamızgerekiyor: kardiz = "adana" print(kardiz.index("a", 0)) print(kardiz.index("a", 1)) print(kardiz.index("a", 2)) print(kardiz.index("a", 3)) print(kardiz.index("a", 4)) Buradaki mantığı anladığınızı sanıyorum. Bildiğiniz gibi, index() metodunun ikinci parametresi sayesinde karakter dizisi içinde aradığımız bir karakteri hangi konumdan itibaren arayacağımızı belirleyebiliyoruz. Örneğin yukarıdaki kodlarda gördüğünüz ilk print()satırı‘a’karakterini0.konumdanitibarenarıyorvegördüğüilk‘a’harfininkonumunu raporluyor. İkinci print() satırı ‘a’ karakterini 1. konumdan itibaren arıyor ve gördüğü ilk ‘a’ harfinin konumunu raporluyor. Bu süreç karakter dizisinin sonuna ulaşılıncaya kadar devamediyor.Böylecekarakterdizisiiçindegeçenbütün‘a’harflerininkonumunueldeetmiş oluyoruz. Elbette yukarıdaki kodları, sadece işin mantığını anlamanızı sağlamak için bu şekilde verdik. Tahmin edebileceğiniz gibi, yukarıdaki kod yazımı son derece verimsiz bir yoldur. Ayrıca gördüğünüz gibi, yukarıdaki kodlar sadece 5 karakter uzunluğundaki karakter dizileri için geçerlidir. Halbuki programlamada esas alınması gereken yöntem, kodlarınızı olabildiğince genel amaçlı tutup, farklı durumlarda da çalışabilmesini sağlamaktır. Dolayısıyla yukarıdaki mantığışuşekildekodlaradökmekçokdahaakıllıcabiryololacaktır: kardiz = "adana" for i in range(len(kardiz)): print(kardiz.index("a", i)) Gördüğünüzgibi,yukarıdakikodlaryardımıyla,biröncekiverimsizkodlarıhemkısalttık,hem de daha geniş kapsamlı bir hale getirdik. Hatta yukarıdaki kodları şöyle yazarsanız karakter dizisivebukarakterdizisiiçindearanacakkarakterikullanıcıdandaalabilirsiniz: 18.8. index(),rindex() 327 PythonBelgeleri,Yayım4.1.3 kardiz = input("Metin girin: ") aranacak = input("Aradığınız harf: ") for i in range(len(kardiz)): print(kardiz.index(aranacak, i)) Bu kodlarda bazı problemler dikkatinizi çekmiş olmalı. Mesela, aranan karakter dizisinin bulunduğukonumlarçıktıdatekrarediyor.Örneğin,kullanıcının“adana”karakterdizisiiçinde ‘a’harfiniaramakistediğinivarsayarsakprogramımızşöylebirçıktıveriyor: 0 2 2 4 4 Burada2ve4sayılarınınbirdenfazlageçtiğinigörüyoruz.Bunuengellemekiçinşöylebirkod yazabiliriz: kardiz = input("Metin girin: ") aranacak = input("Aradığınız harf: ") for i in range(len(kardiz)): if i == kardiz.index(aranacak, i): print(i) Bu kodlarla yaptığımız şey şu: Öncelikle karakter dizisinin uzunluğunu gösteren sayı aralığı üzerinde bir for döngüsü kuruyoruz. Kullanıcının burada yine “adana” karakter dizisini girdiğini varsayarsak, “adana” karakter dizisinin uzunluğu 5 olduğu için for döngümüz şöyle görünecektir: for i in range(5): ... Dahasonrafordöngüsüiçindetanımladığımızideğişkeninindeğerinin,karakterdizisiiçinde aradığımız karakterin konumu ile eşleşip eşleşmediğini kontrol ediyoruz ve değeri eşleşen sayılarıprint()fonksiyonunukullanarakekranadöküyoruz. Eğerbukodlarilkbakıştagözünüzeanlaşılmazgöründüysebukodlarıbirdeşuşekildeyazarak arkaplandanelerolupbittiğinidahanetgörebilirsiniz: kardiz = input("Metin girin: ") aranacak = input("Aradığınız harf: ") for i in range(len(kardiz)): print("i’nin değeri: ", i) if i == kardiz.index(aranacak, i): print("%s. sırada 1 adet %s harfi bulunuyor" %(i, aranacak)) else: print("%s. sırada %s harfi bulunmuyor" %(i, aranacak)) Gördüğünüz gibi index() metodu bir karakter dizisi içindeki karakterleri ararken karakter 328 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 dizisinisoldansağadoğruokuyor.Python’dabuişlemintersidemümkündür.Yaniisterseniz Python’ın, karakter dizisini soldan sağa doğru değil de, sağdan sola doğru okumasını da sağlayabilirsiniz. Bu iş için rindex() adlı bir metottan yararlanacağız. Bu metot her yönden index() metoduyla aynıdır. index() ve rindex() metotlarının birbirinden tek farkı, index() metodunun karakter dizilerini soldan sağa, rindex() metodunun ise sağdan sola doğru okumasıdır.Hemenbirörnekledurumuaçıklamayaçalışalım: >>> kardiz = "adana" >>> kardiz.index("a") 0 >>> kardiz.rindex("a") 4 Bu iki örnek, index() ve rindex() metotları arasındaki farkı gayet net bir şekilde ortaya koyuyor.index()metodu,karakterdizisinisoldansağadoğruokuduğuiçin“adana”karakter dizisinin 0. sırasındaki ‘a’ harfini yakaladı. rindex() metodu ise karakter dizisini sağdan sola doğruokuduğuiçin“adana”karakterdizisinin4.sırasındaki‘a’harfiniyakaladı... 18.9 find, rfind() find() ve rfind() metotları tamamen index() ve rindex() metotlarına benzer. find() ve rfind() metotlarının görevi de bir karakter dizisi içindeki bir karakterin konumunu sorgulamaktır: >>> kardiz = "adana" >>> kardiz.find("a") 0 >>> kardiz.rfind("a") 4 Pekiindex()/rindex()vefind()/rfind()metotlarıarasındanefarkvar? index()verindex()metotlarıkarakterdizisiiçindekikarakterisorgularken,eğerokarakteri bulamazsabirValueErrorhatasıverir: >>> kardiz = "adana" >>> kardiz.index("z") Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: substring not found Amafind()verfind()metotlarıböylebirdurumda-1çıktısıverir: 18.9. find,rfind() 329 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "adana" >>> kardiz.find("z") -1 Buikimetotçiftiarasındakitekfarkbudur. 18.10 center() Center kelimesi İngilizce’de ‘orta, merkez, ortalamak’ gibi anlamlara gelir. Bu anlama uygun olarak,center()metodunukarakterdizileriniortalamakiçinkullanabilirsiniz.Örneğin: for metot in dir(""): print(metot.center(15)) Gördüğünüzgibicenter()metodubiradetparametrealıyor.Buparametre,karakterdizisine uygulanacak ortalama işleminin genişliğini gösteriyor. Bu parametrenin nasıl bir etki ortaya çıkardığınıdahaiyianlayabilmekiçinistersenizbirikibasitörnekverelim: >>> kardiz = "python" Burada6karakterlikbirkarakterdizisitanımladık.Şimdidikkatlicebakın: >>> kardiz.center(1) ’python’ Burada ise center() metoduna parametre olarak 1 sayısını verdik. Ancak bu parametre karakter dizimizinin uzunluğundan az olduğu için çıktı üzerinde herhangi bir etkisi olmadı. Birdeşunabakalım: >>> kardiz.center(10) ’ python ’ Çıktıdakitırnakişaretlerinebakarak,‘python’kelimesininortalandığınıgörebilirsiniz.Buradan şu sonucu çıkarıyoruz: center() metoduna verilen genişlik parametresi aslında bir karakter dizisinin toplam kaç karakterlik bir yer kaplayacağını gösteriyor. Mesela yukarıdaki örnekte bu metoda verdiğimiz 10 sayısı "python" adlı karakter dizisinin toplam 10 karakterlik bir yer kaplayacağınıgösteriyor.Kaplanacakyerekarakterdizisininkendisidedahildir.Yani10olarak belirttiğimizboşlukadedinin6’sı‘python’kelimesininkendisitarafındanişgalediliyor.Geriye kalan4boşluklukmesafeisekarakterdizisininsolvesağtarafınapaylaştırılıyor. center() metodunun karakter dizileri üzerindeki etkisini daha net olarak görmek için şöyle birdöngükurabilirsiniz: >>> for i in range(1, 20): ... kardiz.center(i) ... ’python’ (sonrakisayfayadevam) 330 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’python’ ’python’ ’python’ ’python’ ’python’ ’ python’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ ’ python ’ Buörnekte,karakterdizisininheradımdanasılortayadoğrukaydığıaçıkçagörülüyor.Dikkat ederseniz çıktının ilk altı satırında karakter dizisinin konumu değişmiyor. Ancak center() metoduna verilen parametrenin değeri karakter dizisinin uzunluğunu aştığı anda karakter dizisiortayadoğruilerlemeyebaşlıyor. center() metodu genellikle yukarıdaki gösterdiğimiz şekilde tek bir parametre ile birlikte kullanılır.Ancakbumetotaslındabirparametredahaalır.Şuörneğiinceleyelim: >>> kardiz = "elma" >>> kardiz.center(10, "-") ’---elma---’ Gördüğünüz gibi, center() metoduna verdiğimiz “-” değeri sayesinde “elma” karakteri ortalanırken,sağvesoltaraftakiboşluklarada“-”karakterieklenmişoldu. 18.11 rjust(), ljust() Bu metotlar da tıpkı bir önceki center() metodu gibi karakter dizilerini hizalama vazifesi görür.rjust()metodubirkarakterdizisinisağayaslarken,ljust()metodukarakterdizisini solayaslar.Meselaşuikikodparçasınınçıktılarınıinceleyin: >>> for i in dir(""): ... print(i.ljust(20)) >>> for i in dir(""): ... print(i.rjust(20)) ljust() metodu bize özellikle karakter dizilerinin hizalama işlemlerinde yardımcı oluyor. Bu metot yardımıyla karakter dizilerimizi sola yaslayıp, sağ tarafına da istediğimiz karakterleri yerleştirebiliyoruz.Hemenbirörnekverelim: 18.11. rjust(),ljust() 331 PythonBelgeleri,Yayım4.1.3 >>> kardiz = "tel no" >>> kardiz.ljust(10, ".") ’tel no....’ Burada olan şey şu: ljust() metodu, kendisine verilen 10 parametresinin etkisiyle 10 karakterlikbiralanoluşturuyor.Bu10karakterlikalanıniçineönce6karakterlikyerkaplayan “telno”ifadesini,gerikalan4karakterlikboşluğaise“.”karakteriniyerleştiriyor.Eğerljust() metoduna verilen sayı karakter dizisinin uzunluğundan az yer tutarsa, karakter dizisinin görünüşünde herhangi bir değişiklik olmayacaktır. Örneğin yukarıdaki örnekte karakter dizimizinuzunluğu6.Dolayısıylakodumuzuşuşekildeyazarsakbirsonuçeldeedemeyiz: >>> kardiz.ljust(5, ".") ’tel no’ Gördüğünüz gibi, karakter dizisinde herhangi bir değişiklik olmadı. ljust() metoduna verdiğimiz“.”karakterinigörebilmemiziçin,verdiğimizsayıcinsliparametreninenazkarakter dizisininboyununbirfazlasıolmasıgerekir: >>> kardiz.ljust(7, ".") ’tel no.’ ljust()metoduylailgilibasitbirörnekdahaverelim: >>> for i in "elma", "armut", "patlıcan": ... i.ljust(10, ".") ... ’elma......’ ’armut.....’ ’patlıcan..’ Gördüğünüz gibi, bu metot karakter dizilerini şık bir biçimde sola hizalamamıza yardımcı oluyor. rjust()metoduise,ljust()metodununyaptığıişintamtersiniyapar.Yanikarakterdizilerini soladeğilsağayaslar: >>> for i in "elma", "armut", "patlıcan": ... i.rjust(10, ".") ... ’......elma’ ’.....armut’ ’..patlıcan’ ljust() ve rjust() metotları, kullanıcılarınıza göstereceğiniz çıktıların düzgün görünmesini sağlamakaçısındanoldukçafaydalıdır. 332 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 18.12 zfill() Bu metot kimi yerlerde işimizi epey kolaylaştırabilir. zfill() metodu yardımıyla karakter dizilerininsoltarafınaistediğimizsayıdasıfırekleyebiliriz: >>> a = "12" >>> a.zfill(3) ’012’ Bumetoduşöylebirişiçinkullanabilirsiniz: >>> for i in range(11): ... print(str(i).zfill(2)) 00 01 02 03 04 05 06 07 08 09 10 Burada str() fonksiyonunu kullanarak, range() fonksiyonundan elde ettiğimiz sayıları birer karakterdizisineçevirdiğimizedikkatedin.Çünküzfill()karakterdizilerininbirmetodudur. Sayılarındeğil... 18.13 partition(), rpartition() Bumetotyardımıylabirkarakterdizisinibellibirölçütegöreüçebölüyoruz.Örneğin: >>> a = "istanbul" >>> a.partition("an") (’ist’, ’an’, ’bul’) Eğer partition() metoduna parantez içinde verdiğimiz ölçüt karakter dizisi içinde bulunmuyorsaşusonuçlakarşılaşırız: >>> a = "istanbul" >>> a.partition("h") (’istanbul’, ’’, ’’) Gelelim rpartition() metoduna... Bu metot da partition() metodu ile aynı işi yapar, amayöntemibirazfarklıdır.partition()metodukarakterdizilerinisoldansağadoğruokur. 18.12. zfill() 333 PythonBelgeleri,Yayım4.1.3 rpartition() metodu ise sağdan sola doğru. Peki bu durumun ne gibi bir sonucu vardır? Hemengörelim: >>> b = "" >>> b.partition("i") (’’, ’i’, ’stihza’) Gördüğünüz gibi, partition() metodu karakter dizisini ilk ‘i’ harfinden böldü. Şimdi aynı işlemirpartition()metoduileyapalım: >>> b.rpartition("i") (’ist’, ’i’, ’hza’) rpartition() metodu ise, karakter dizisini sağdan sola doğru okuduğu için ilk ‘i’ harfinden değil,son‘i’harfindenböldükarakterdizisini. partition() ve rpartition() metotları, ölçütün karakter dizisi içinde bulunmadığı durumlardadafarklıtepkilerverir: >>> b.partition("g") (’’, ’’, ’’) >>> b.rpartition("g") (’’, ’’, ’’) Gördüğünüz gibi, partition() metodu boş karakter dizilerini sağa doğru yaslarken, rpartition()metodusoladoğruyasladı. 18.14 encode() Bu metot yardımıyla karakter dizilerimizi istediğimiz kodlama sistemine göre kodlayabiliriz. Python 3.x’te varsayılan karakter kodlaması utf-8’dir. Eğer istersek şu karakter dizisini utf-8 yerinecp1254ilekodlayabiliriz: >>> "çilek".encode("cp1254") 18.15 expandtabs() Bumetotyardımıylabirkarakterdizisiiçindekisekmeboşluklarınıgenişletebiliyoruz.Örneğin: >>> a = "elma\tbir\tmeyvedir" >>> a.expandtabs(10) ’elma bir meyvedir’ 334 Bölüm18. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 Böylece bir metot grubunu daha geride bırakmış olduk. Gördüğünüz gibi bazı metotlar sıklıkla kullanılabilme potansiyeli taşırken, bazı metotlar pek öyle sık kullanılacakmış gibi görünmüyor... Sonrakibölümdemetotlarıincelemeyedevamedeceğiz. 18.15. expandtabs() 335 19 BÖLÜM Karakter Dizilerinin Metotları (Devamı) Karakter dizileri konusunun 4. bölümüne geldik. Bu bölümde de karakter dizilerinin metotlarınıincelemeyedevamedeceğiz. 19.1 str.maketrans(), translate() Buikimetotbirbiriylebağlantılıolduğuvegenelliklebirliktekullanıldığıiçin,bunlarıbirarada göreceğiz. Dilersenizbuikimetodunneişeyaradığınıanlatmayaçalışmakyerinebirörneküzerindenbu metotlarıngörevinianlamayıdeneyelim. Şöyle bir vaka hayal edin: Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri kullanamıyoruz. Böyle durumlarda, elimizdeki bir metni, cümleyi veya kelimeyi Türkçe karakteriçermeyecekbirhalegetirmemizgerekebiliyor.Örneğinşucümleyielealalım: Bildiğinizgibi,internetüzerindebazenTürkçekarakterlerikullanamıyoruz. İşte buna benzer bir cümleyi kimi zaman Türkçe karakterlerinden arındırmak zorunda kalabiliyoruz. Eğer elinizde Türkçe yazılmış bir metin varsa ve sizin amacınız bu metin içinde geçen Türkçeye özgü karakterleri noktasız benzerleriyle değiştirmek ise str.maketrans() ve translate()metotlarındanyararlanabilirsiniz. Örneğimizşucümleidi: Bildiğinizgibi,internetüzerindebazenTürkçekarakterlerikullanamıyoruz. Amacımızbucümleyişuşekildedeğiştirmek: Bildiginizgibi,internetuzerindebazenTurkcekarakterlerikullanamiyoruz. Bununiçinşöylebirkodyazabilirsiniz: kaynak = "şçöğüıŞÇÖĞÜİ" hedef = "scoguiSCOGUI" (sonrakisayfayadevam) 336 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) çeviri_tablosu = str.maketrans(kaynak, hedef) metin = "Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri␣ kullanamıyoruz." ˓→ print(metin.translate(çeviri_tablosu)) Bukodlarıçalıştırdığımızdaşöylebirçıktıeldeederiz: Bildiginiz gibi, internet uzerinde bazen Turkce karakterleri kullanamiyoruz. Gördüğünüz gibi, “kaynak” adlı karakter dizisi içinde belirttiğimiz bütün harfler “hedef” adlı karakter dizisi içindeki harflerle tek tek değiştirildi. Böylece Türkçeye özgü karakterleri (‘şçöğüıŞÇÖĞÜİ’)enyakınnoktasızbenzerleriyle(‘scoguiSCOGUI’)değiştirmişolduk. Peki yukarıda nasıl bir süreç işledi de biz istediğimiz sonucu elde edebildik. Dilerseniz yukarıdaki kodlara biraz daha yakından bakalım. Mesela çeviri_tablosu adlı değişkenin çıktısınabakarakstr.maketrans()metodununalttanaltanelerkarıştırdığınıgörelim: kaynak = "şçöğüıŞÇÖĞÜİ" hedef = "scoguiSCOGUI" çeviri_tablosu = str.maketrans(kaynak, hedef) print(çeviri_tablosu) Bukodlarıçalıştırdığımızdaşöylebirçıktıalıyoruz: {214: 79, 231: 99, 220: 85, 199: 67, 304: 73, 305: 105, 286: 71, 246: 111, 351: 115, 252: 117, 350: 83, 287: 103} Bu çıktı size tamamen anlamsız görünmüş olabilir. Ama aslında son derece anlamlı ve bir o kadar da önemli bir çıktıdır bu. Gelin isterseniz bu çıktının yapısını biraz inceleyelim. (Buna benzerbirçıktıyısorted()metodunuincelerkendegörmüştük) Gördüğünüz gibi, tamamen sayılardan oluşan bir çıktı bu. Burada birbirlerinden virgül ile ayrılmışsayıçiftlerigörüyoruz.Busayıçiftlerinidahanetgörebilmekiçinbuçıktıyıderlitoplu birhalegetirelim: {214: 79, 231: 99, 220: 85, 199: 67, 304: 73, 305: 105, 286: 71, 246: 111, 351: 115, 252: 117, 350: 83, 287: 103} 19.1. str.maketrans(),translate() 337 PythonBelgeleri,Yayım4.1.3 Bu şekilde sanırım çıktımız biraz daha anlam kazandı. Gördüğünüz gibi, iki nokta üst üste işaretinin solunda ve sağında bazı sayılar var. Tahmin edebileceğiniz gibi, soldaki sayılar sağdakisayılarlailişkili. Pekibütünbusayılarneanlamageliyorvebusayılararasındanetürbirilişkivar? Teknik olarak, bilgisayarların temelinde sayılar olduğunu duymuşsunuzdur. Bilgisayarınızda gördüğünüz her karakter aslında bir sayıya karşılık gelir. Zaten bilgisayarlar ‘a’, ‘b’, ‘c’, vb. kavramlarıanlayamaz.Bilgisayarlarınanlayabildiğitekşeysayılardır.Meselasizklavyeden‘a’ harfinigirdiğinizdebilgisayarbunu97olarakalgılar.Yadasiz‘i’harfigirdiğinizde,bilgisayarın gördüğü tek şey 105 sayısıdır... Bu durumu Python’daki chr() adlı özel bir fonksiyon yardımıylateyitedebiliriz.Dikkatliceinceleyin: >>> chr(97) ’a’ >>> chr(105) ’i’ >>> chr(65) ’A’ Gördüğünüz gibi, gerçekten de her sayı bir karaktere karşılık geliyor. İsterseniz bir de yukarıdakisayıgrubundakisayılarıdenetleyelim: for i in 214, 231, 220, 199, 304, 305, 286, 246, 351, 252, 350, 287: print(i, chr(i)) Bukodlarıçalıştırdığımızdaşuçıktıyıeldeediyoruz: 214 Ö 231 ç 220 Ü 199 Ç 304 İ 305 ı 286 Ğ 246 ö 351 ş 252 ü 350 Ş 287 ğ Buçıktısayesindebazışeylerzihninizdeyavaşyavaşaçıklığakavuşuyorolmalı.Buçıktımesela 214sayısının‘Ö’harfine,220sayısının‘Ü’harfine,305sayısınında‘ı’harfinekarşılıkgeldiğini gösteriyor. Burada iki nokta işaretinin sol tarafında kalan sayıların karakter karşılıklarını gördük. Bir de ikinoktaişaretininsağtarafındakalansayılarabakalım: 338 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 for i in 79, 99, 85, 67, 73, 105, 71, 111, 115, 117, 83, 103: print(i, chr(i)) Budaşuçıktıyıverdi: 79 O 99 c 85 U 67 C 73 I 105 i 71 G 111 o 115 s 117 u 83 S 103 g Burada da mesela 79 sayısının ‘O’ harfine, 85 sayısının ‘U’ harfine, 105 sayısının da ‘i’ harfine karşılıkgeldiğinigörüyoruz. Yukarıdakiveyukarıdanbiröncekikodlarınçıktılarınıbirarayagetirirsenizşöylebirdurumla karşıkarşıyaolduğunuzugörürsünüz: Ö O ç c Ü U Ç C İ I ı i Ğ G ö o ş s ü u Ş S ğ g Bütünbusöylediklerimizdenşusonuççıkıyor: çeviri_tablosu = str.maketrans(kaynak, hedef) satırı, kaynak ve hedef olarak adlandırdığımız karakter dizilerini birleştirip, bu değişkenler içindeki herbir karakteri birbiriyleeşleştiriyor.Yaniaşağıdakigibibirişlemyapıyor: çeviri_tablosu = {"Ö": "O", "ç": "c", "Ü": "U", "Ç": "C", "İ": "I", "ı": "i", "Ğ": "G", "ö": "o", "ş": "s", (sonrakisayfayadevam) 19.1. str.maketrans(),translate() 339 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) "ü": "u", "Ş": "S", "ğ": "g"} Burada çeviri_tablosu değişkeni içinde gösterdiğimiz biçimin Python’daki adı ‘sözlük’tür. Sözlükler de tıpkı karakter dizileri gibi bir veri tipidir. Bunları da birkaç bölüm sonra ayrıntılı birbiçimdeinceleyeceğiz.Bizburada,bazışeylerianlamamızıkolaylaştıracağıiçinsözlükadlı veri tipini oldukça genel bir biçimde sizlere tanıttık. Dediğim gibi, bu veri tipinin ayrıntılarını daha sonra inceleyeceğiz, ama yine de şu noktada sözlükleri kenarından köşesinden de olsa tanımamızbizimiçinfaydalıolacaktır. Dediğimgibi,yukarıdaçeviri_tablosuadıylagösterdiğimizşeybirsözlüktür.Busözlüğünnasıl çalıştığınıgörmekiçinşöylebirkodyazalım: çeviri_tablosu = {"Ö": "O", "ç": "c", "Ü": "U", "Ç": "C", "İ": "I", "ı": "i", "Ğ": "G", "ö": "o", "ş": "s", "ü": "u", "Ş": "S", "ğ": "g"} print(çeviri_tablosu["Ö"]) Bukodlarıbirdosyayakaydedipçalıştırırsanızşöylebirçıktıalırsınız: O Gördüğünüz gibi, sözlük içinde geçen “Ö” adlı öğeyi parantez içinde belirttiğimiz zaman, Pythonbizebuöğeninkarşısındakideğeriveriyor.Sözlükiçinde“Ö”öğesininkarşılığı“O”harfi olduğuiçindeçıktımız“O”oluyor.Birdeşunlarabakalım: çeviri_tablosu = {"Ö": "O", "ç": "c", "Ü": "U", "Ç": "C", "İ": "I", "ı": "i", "Ğ": "G", "ö": "o", "ş": "s", "ü": "u", "Ş": "S", "ğ": "g"} (sonrakisayfayadevam) 340 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(çeviri_tablosu["Ö"]) print(çeviri_tablosu["ç"]) print(çeviri_tablosu["Ü"]) print(çeviri_tablosu["Ç"]) print(çeviri_tablosu["İ"]) print(çeviri_tablosu["ı"]) print(çeviri_tablosu["Ğ"]) print(çeviri_tablosu["ö"]) print(çeviri_tablosu["Ş"]) print(çeviri_tablosu["ğ"]) Bukodlarıçalıştırdığımızdaiseşöylebirçıktıalıyoruz: O c U C I i G o S g Gördüğünüz gibi, sözlük içinde iki nokta üst üste işaretinin sol tarafında görünen öğeleri parantez içinde yazarak, iki nokta üst üste işaretinin sağ tarafındaki değerleri elde edebiliyoruz. Bütünbuanlattıklarımızdansonraşusatırlarıgayetiyianlamışolmalısınız: kaynak = "şçöğüıŞÇÖĞÜİ" hedef = "scoguiSCOGUI" çeviri_tablosu = str.maketrans(kaynak, hedef) Burada Python, kaynak ve hedef adlı değişkenler içindeki karakter dizilerini birer birer eşleştirerekbizebirsözlükveriyor.Busözlükte: "ş" harfi "s" harfine; "ç" harfi "c" harfine; "ö" harfi "o" harfine; "ğ" harfi "g" harfine; "ü" harfi "u" harfine; "ı" harfi "i" harfine; "Ş" harfi "S" harfine; "Ç" harfi "C" harfine; "Ö" harfi "O" harfine; "Ğ" harfi "G" harfine; "Ü" harfi "U" harfine; "İ" harfi "I" harfine 19.1. str.maketrans(),translate() 341 PythonBelgeleri,Yayım4.1.3 karşılıkgeliyor... Kodlarıngerikalanındaiseşusatırlarıgörmüştük: metin = "Bildiğiniz gibi, internet üzerinde bazen Türkçe karakterleri␣ kullanamıyoruz." ˓→ print(metin.translate(çeviri_tablosu)) Burada da orijinal metnimizi tanımladıktan sonra translate() adlı metot yardımıyla, çeviri tablosundaki öğe eşleşmesi doğrultusunda metnimizi tercüme ediyoruz. Bu kodlarda metin.translate(çeviri_tablosu) satırının yaptığı tek şey çeviri_tablosu adlı sözlükteki eşleşmekriterlerinimetinadlıkarakterdizisineuygulamaktanibarettir. Karakterdizilerininbumaketrans()adlımetodukullanımolarakgözünüzeötekimetotlardan farklı görünmüş olabilir. Daha açık bir dille ifade etmek gerekirse, bu metodu bir karakter dizisiüzerinedeğildestrüzerineuyguluyorolmamız,yanistr.maketrans()yazıyorolmamız sizişaşırtmışolabilir.Eğeranlamanızıkolaylaştıracaksa; çeviri_tablosu = str.maketrans(kaynak, hedef) satırınışuşekildedeyazabilirsiniz: çeviri_tablosu = ’’.maketrans(kaynak, hedef) Yani maketrans() metodunu boş bir karakter dizisi üzerine de uygulayabilirsiniz. Neticede maketrans() karakter dizilerinin bir metodudur. Bu metot hangi karakter dizisi üzerine uygulandığıyladeğil,parametreolarakhangideğerlerialdığıyla(bizimörneğimizdekaynakve hedef)ilgilenir.Dolayısıylabumetoduilgili-ilgisizhertürlükarakterdizisineuygulayabilirsiniz: çeviri_tablosu = ’mahmut’.maketrans(kaynak, hedef) çeviri_tablosu = ’zalim dünya!’.maketrans(kaynak, hedef) Ama tabii dikkat dağıtmamak açısından en uygun hareket, bu karakter dizisini str üzerine uygulamakolacaktır: çeviri_tablosu = str.maketrans(kaynak, hedef) Buküçükayrıntıyadadikkatiçektiğimizegöreyolumuzadevamedebiliriz... Yukarıda verdiğimiz örnek vasıtasıyla str.maketrans() ve translate() adlı metotları epey ayrıntılıbirşekildeincelemişolduk.Dilersenizpratikolmasıaçısındanbirörnekdahaverelim: (cid:242) Not .com sitemizin forum üyelerinden Barbaros Akkurt http://www..com/forum/viewtopic.php?f=25&t=6322 (arşivlinki)adresindeşöylebir problemdenbahsediyor: “Ben on parmak Türkçe F klavye kullanıyorum. Bunun için, bazı tuş kombinasyonları ile veya sistem tepsisi üzerindeki klavye simgesine tıklayarak Türkçe Q - Türkçe F değişimi yapıyorum. Bazen bunu yapmayı unutuyorum ve bir metne bakarak yazıyorsam gözüm ekranda olmuyor. Bir paragrafı yazıp bitirdikten sonra ekranda bir karakter salatası görünceçokbozuluyorum.” 342 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 İşteböylebirdurumdayukarıdakiikimetodukullanarakokaraktersalatasınıdüzeltebilirsiniz. Karaktersalatamızşuolsun: Bfjflrköakdhsıyteuaidjslydbdcusldvdjks? Bunagörekodlarımızıyazmayabaşlayabiliriz.Önceliklemetnimizitanımlayalım: metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?" Şimdidesırasıylaqvefklavyedüzenlerinibirerkarakterdizisihalinegetirelim: q_klavye_düzeni = "qwertyuıopğüasdfghjklşi,zxcvbnmöç." f_klavye_düzeni = "fgğıodrnhpqwuieaütkmlyşxjövcçzsb.," Burada amacımız yanlışlıkla q klavye düzeninde yazıldığı için karman çorman bir hale gelmiş metni düzgün bir şekilde f klavye düzenine dönüştürmek. Yani burada çıkış noktamız (kaynağımız) q_klavye_düzeni iken, varış noktamız (hedefimiz) f_klavye_düzeni. Buna göre çeviritablomuzuoluşturabiliriz: çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni) Tıpkı bir önceki örnekte olduğu gibi, burada da çeviri_tablosu adlı değişkeni print() fonksiyonunukullanarakyazdırırsanızşöylebirçıktıylakarşılaşırsınız: {231: 46, 287: 113, 44 : 120, 46 : 44, 305: 110, 246: 98, 351: 121, 97 : 117, 98 : 231, 99 : 118, 100: 101, 101: 287, 102: 97, 103: 252, 104: 116, 105: 351, 106: 107, 107: 109, 108: 108, 109: 115, 110: 122, 111: 104, 112: 112, 113: 102, 114: 305, 115: 105, 116: 111, (sonrakisayfayadevam) 22https://web.archive.org/web/20150913015518/http://www..com/forum/viewtopic.php?f=25&t=63 19.1. str.maketrans(),translate() 343 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 117: 114, 118: 99, 119: 103, 120: 246, 121: 100, 122: 106, 252: 119} Tahmin edebileceğiniz gibi, bu sözlükte iki nokta üst üste işaretinin solundaki sayılar q_klavye_düzeni adlı değişken içindeki karakterleri; sağındaki sayılar ise f_klavye_düzeni adlı değişkeniçindekikarakterleritemsilediyor. Sonolaraktranslate()metoduyardımıylasözlüktekiöğeeşleşmesinimetinadlıdeğişkenin üzerineuyguluyoruz: print(metin.translate(çeviri_tablosu)) Kodlarıtoplucagörelim: metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?" q_klavye_düzeni = "qwertyuıopğüasdfghjklşi,zxcvbnmöç." f_klavye_düzeni = "fgğıodrnhpqwuieaütkmlyşxjövcçzsb.," çeviri_tablosu = str.maketrans(q_klavye_düzeni, f_klavye_düzeni) print(metin.translate(çeviri_tablosu)) Neeldeettiniz? Yukarıdaki iki örnekte de gördüğümüz gibi, str.maketrans() metodu kaynak ve hedef karakter dizilerini alıp bunları birleştirerek bize bir sözlük veri tipinde bir nesne veriyor. Yani tıpkıinput()fonksiyonununbizebirkarakterdizisiverdiğigibi,str.maketrans()metoduda bizebirsözlükveriyor. Eğer isterseniz, sözlüğü str.maketrans() metoduna oluşturtmak yerine, kendiniz de bir sözlükoluşturarakstr.maketrans()metodunaparametreolarakatayabilirsiniz.Örneğin: metin = "Bfjflrk öa kdhsı yteua idjslyd bdcusldvdj ks?" sözlük = {"q": "f", "w": "g", "e": "ğ", "r": "ı", "t": "o", "y": "d", "u": "r", "ı": "n", "o": "h", "p": "p", "ğ": "q", (sonrakisayfayadevam) 344 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) "ü": "w", "a": "u", "s": "i", "d": "e", "f": "a", "g": "ü", "h": "t", "j": "k", "k": "m", "l": "l", "ş": "y", "i": "ş", ",": "x", "z": "j", "x": "ö", "c": "v", "v": "c", "b": "ç", "n": "z", "m": "s", "ö": "b", "ç": ".", ".": ","} çeviri_tablosu = str.maketrans(sözlük) print(metin.translate(çeviri_tablosu)) Burada birbiriyle eşleşecek karakterleri kendimiz yazıp bir sözlük oluşturduk ve bunu parametre olarak doğrudan str.maketrans() metoduna verdik. Bu kodlarda kaynak ve hedef diye iki ayrı karakter dizisi tanımlamak yerine tek bir sözlük oluşturduğumuz için, str.maketrans() metodunu iki parametreyle değil, tek parametreyle kullandığımıza dikkat edin.Ayrıcasözlüğünasıloluşturduğumuzudadikkatliceinceleyin. Sözlükteki öğe çiftlerini böyle alt alta yazmamızın nedeni zorunluluk değil, bir tercihtir. İstersekbusözlüğüşöyledetanımlayabilirdik: sözlük = {"q": "f", "w": "g", "e": "ğ", "r": "ı", "t": "o", "y": "d", "u": "r", "ı": "n", "o": "h", "p": "p", "ğ": "q", "ü": "w", "a": "u", "s": "i", "d": "e", "f": "a", "g": "ü", "h": "t", "j": "k", "k": "m", "l": "l", "ş": "y", "i": "ş", ",": "x", "z": "j", "x": "ö", "c": "v", "v": "c", "b": "ç", "n": "z", "m": "s", "ö": "b", "ç": ".", ".": ","} Buradadaöğeçiftleriniyanyanayazdık.Buikiyöntemdenhangisisizedahaokunaklıgeliyorsa onutercihedebilirsiniz. Şimdisizebirsorusormamaizinverin.Acabaaşağıdakimetiniçindegeçenbütünsesliharfleri silindesem,nasılbirkodyazarsınız? Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton 19.1. str.maketrans(),translate() 345 PythonBelgeleri,Yayım4.1.3 yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse birgelenekhalinialmıştırdiyebiliriz. Aklınızailkolarakşöylebirkodyazmakgelebilir: metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.""" sesli_harfler = "aeıioöuüAEIİOÖUÜ" yeni_metin = "" for i in metin: if not i in sesli_harfler: yeni_metin += i print(yeni_metin) Burada öncelikle metin adlı bir değişken tanımlayarak metnimizi bu değişken içine yerleştirdik.ArdındandaTürkçedekisesliharfleriiçerenbirkarakterdizisitanımladık. Daha sonra da yeni_metin adlı boş bir karakter dizisi oluşturduk. Bu karakter dizisi, orijinal metnin, sesli harfler ayıklandıktan sonraki halini barındıracak. Biliyorsunuz, karakter dizileri değiştirilemeyen (immutable) bir veri tipidir. Dolayısıyla bir karakter dizisi içinde yaptığımız değişikliklerikoruyabilmekiçinbudeğişiklikleribaşkabirdeğişkeniçindetutmamızgerekiyor. Bu kodların ardından bir for döngüsü tanımlıyoruz. Buna göre, metin içinde geçen her bir karaktere tek tek bakıyoruz (for i in metin:) ve bu karakterler arasında, sesli_harfler değişkeni içinde geçmeyenleri, yani bütün sessiz harfleri (if not i in sesli_harfler:) tek tekyeni_metinadlıdeğişkeneyolluyoruz(yeni_metin += i). Sonolarakdayeni_metinadlıkarakterdizisiniekranabasıyoruz.Böyleceorijinalmetiniçindeki bütünsesliharfleriayıklamışoluyoruz. Yukarıdaki, gayet doğru ve geçerli bir yöntemdir. Böyle bir kod yazmanızın hiçbir sakıncası yok. Ama eğer isterseniz aynı işi str.maketrans() ve translate() metotları yardımıyla da halledebilirsiniz: metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu (sonrakisayfayadevam) 346 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.""" silinecek = "aeıioöuüAEIİOÖUÜ" çeviri_tablosu = str.maketrans(’’, ’’, silinecek) print(metin.translate(çeviri_tablosu)) Burada da öncelikle metnimizi bir karakter dizisi içine yerleştirdik. Daha sonra da şu kodu yazdık: silinecek = "aeıioöuüAEIİOÖUÜ" Bukodlaryardımıyla,metiniçindençıkarmakistediğimizharfleritektekbelirledik. Ardından str.maketrans() fonksiyonumuzu yazarak çeviri tablosunu oluşturduk. Burada ilk iki parametrenin boş birer karakter dizisi olduğuna dikkat ediyoruz. İlk iki parametreyi bu şekilde yazmamızın nedeni şu: Biz orijinal metin içindeki herhangi bir şeyi değiştirmek istemiyoruz.Bizimamacımızorijinalmetiniçindekisesliharflerisilmek.Tabiioikiparametreyi yazmasak da olmaz. O yüzden o iki parametrenin yerine birer tane boş karakter dizisi yerleştiriyoruz. Bunoktadaçeviri_tablosuadlıdeğişkeniyazdıraraknelerolupbittiğinidahanetgörebilirsiniz: {214: None, 97 : None, 101: None, 65 : None, 105: None, 111: None, 304: None, 305: None, 220: None, 117: None, 246: None, 73 : None, 79 : None, 252: None, 85 : None, 69 : None} Gördüğünüzgibi,silinecekadlıdeğişkeniçindekibütünkarakterlerNonedeğeriyleeşleşiyor... None‘hiç,sıfır,yokluk’gibianlamlaragelir.DolayısıylaPython,ikinoktaüstüsteişaretininsol tarafındakikarakterlerlekarşılaştığındabunlarınyerinebireradet‘yokluk’koyuyor!Yanisonuç olarakbukarakterlerimetindensilmişoluyor... BukodlardaikinoktaüstüsteişaretininsolundakikarakterlerinNoneileeşleşmesinisağlayan 19.1. str.maketrans(),translate() 347 PythonBelgeleri,Yayım4.1.3 şey, str.maketrans() metoduna verdiğimiz üçüncü parametredir. Eğer o parametreyi yazmazsak, yani kodlarımızı şu şekle getirirsek çeviri_tablosu değişkeninin çıktısı farklı olacaktır: metin = """Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı tarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan, isminin Python olmasına bakarak, bu programlama dilinin, adını piton yılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin adı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty Python adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı gösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa da, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil edilmesi neredeyse bir gelenek halini almıştır diyebiliriz.""" silinecek = "aeıioöuüAEIİOÖUÜ" çeviri_tablosu = str.maketrans(’’, ’’) print(çeviri_tablosu) Bukodlarıçalıştırdığımızdaşöylebirçıktıalırız: {} Gördüğünüz gibi, elde ettiğimiz şey boş bir sözlüktür. Sözlük boş olduğu, yani değiştirilecek herhangi bir karakter olmadığı için bu kodlar orijinal metin üzerinde herhangi bir değişiklik yapmaz. İstersenizüçüncüparametreninneişeyaradığınıvenasılçalıştığınıdahaiyianlayabilmekiçin dahabasitbirörnekverelim: metin = "Cem Yılmaz" kaynak = "CY" hedef = "cy" silinecek = "eıa " çeviri_tablosu = str.maketrans(kaynak, hedef, silinecek) print(metin.translate(çeviri_tablosu)) Burada ‘C’ ve ‘Y’ harflerini sırasıyla ‘c’ ve ‘y’ harfleriyle eşleştirdik. Bu nedenle orijinal metin içindeki‘C’ve‘Y’harfleriyerlerinisırasıyla‘c’ve‘y’harflerinebıraktı.Silinecekkarakterlerolarak ise ‘e’, ‘ı’, ‘a’ ve boşluk karakterlerini seçtik. Böylece ‘Cem Yılmaz’ adlı orijinal metin içindeki boşlukkarakteridesilinerek,bumetin‘cmylmz’karakterdizisinedönüştü. 348 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 19.2 isalpha() Bu metot yardımıyla bir karakter dizisinin ‘alfabetik’ olup olmadığını denetleyeceğiz. Peki ‘alfabetik’nedemek? Eğer bir karakter dizisi içinde yalnızca alfabe harfleri (‘a’, ‘b’, ‘c’ gibi...) varsa o karakter dizisi için‘alfabetik’diyoruz.Birörneklebunudoğrulayalım: >>> a = "kezban" >>> a.isalpha() True Ama: >>> b = "k3zb6n" >>> b.isalpha() False 19.3 isdigit() Bumetotdaisalpha()metodunabenzer.Bununyardımıylabirkarakterdizisininsayısalolup olmadığınıdenetleyebiliriz.Sayılardanoluşankarakterdizilerine‘sayıdeğerlikarakterdizileri’ adıverilir.Örneğinşubir‘sayıdeğerlikarakterdizisi’dir: >>> a = "12345" Metodumuzyardımıylabunudoğrulayabiliriz: >>> a.isdigit() True Amaşukarakterdizisisayısaldeğildir: >>> b = "123445b" Hemenkontroledelim: >>> b.isdigit() False 19.2. isalpha() 349 PythonBelgeleri,Yayım4.1.3 19.4 isalnum() Bu metot, bir karakter dizisinin ‘alfanümerik’ olup olmadığını denetlememizi sağlar. Peki ‘alfanümerik’nedir? Dahaöncebahsettiğimizmetotlardanhatırlayacaksınız: Alfabetikkarakterdizileri,alfabeharflerindenoluşankarakterdizileridir. Sayısalkarakterdizileri,sayılardanoluşankarakterdizileridir. Alfanümerik karakter dizileri ise bunun birleşimidir. Yani sayı ve/veya harflerden oluşan karakter dizilerine alfanümerik karakter dizileri adı verilir. Örneğin şu karakter dizisi alfanümerikbirkarakterdizisidir: >>> a = "123abc" İstersenizhemenbuyenimetodumuzyardımıylabunudoğrulayalım: >>> a.isalnum() True Eğer denetleme sonucunda True alıyorsak, o karakter dizisi alfanümeriktir. Bir de şuna bakalım: >>> b = "123abc>" >>> b.isalnum() False b değişkeninin tuttuğu karakter dizisinde alfanümerik karakterlerin yanısıra (“123abc”), alfanümerik olmayan bir karakter dizisi de bulunduğu için (“>”), b.isalnum() şeklinde gösterdiğimizdenetlemeninsonucuFalse(yanlış)olarakgörünecektir. Dolayısıyla, bir karakter dizisi içinde en az bir adet alfanümerik olmayan bir karakter dizisi bulunursa(bizimörneğimizde">"),okarakterdizisialfanümerikolmayacaktır. 19.5 isdecimal() Bumetotyardımıylabirkarakterdizisininondalıksayıcinsindenolupolmadığınıdenetliyoruz. Meselaaşağıdakiörnekondalıksayıcinsindenbirkarakterdizisidir: >>> a = "123" >>> a.isdecimal() True Amaşuisekayannoktalı(floating-point)sayıcinsindenbirkarakterdizisidir: >>> a = "123.3" >>> a.isdecimal() (sonrakisayfayadevam) 350 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) False Dolayısıylaa.isdecimal()komutuFalseçıktısıverir... 19.6 isidentifier() Identifier kelimesi Türkçede ‘tanımlayıcı’ anlamına gelir. Python’da değişkenler, fonksiyon ve modül adlarına ‘tanımlayıcı’ denir. İşte başlıkta gördüğümüz isidentifier() metodu, neyin tanımlayıcı olup neyin tanımlayıcı olamayacağını denetlememizi sağlar. Hatırlarsanız değişkenler konusundan bahsederken, değişken adı belirlemenin bazı kuralları olduğunu söylemiştik.Bunagöre,örneğin,değişkenadlarıbirsayıilebaşlayamıyordu.Dolayısıylaşöyle birdeğişkenadıbelirleyemiyoruz: >>> 1a = 12 Dediğimiz gibi, değişkenler birer tanımlayıcıdır. Dolayısıyla bir değişken adının geçerli olup olmadığınıisidentifier()metoduyardımıyladenetleyebiliriz: >>> "1a".isidentifier() False Demekki"1a"ifadesiniherhangibirtanımlayıcıadıolarakkullanamıyoruz.Yanibuadasahip bir değişken, fonksiyon adı veya modül adı oluşturamıyoruz. Ama mesela "liste1" ifadesi geçerlibirtanımlayıcıdır.Hemendenetleyelim: >>> "liste1".isidentifier() True 19.7 isnumeric() Bu metot bir karakter dizisinin nümerik olup olmadığını denetler. Yani bu metot yardımıyla birkarakterdizisininsayıdeğerliolupolmadığınıdenetleyebiliriz: >>> "12".isnumeric() True >>> "dasd".isnumeric() False 19.6. isidentifier() 351 PythonBelgeleri,Yayım4.1.3 19.8 isspace() Bu metot yardımıyla bir karakter dizisinin tamamen boşluklardan oluşup oluşmadığını denetleyebiliriz.EğerkarakterdizimizboşluklardanoluşuyorsabumetotTrueçıktısıverecek, ama eğer karakter dizimizin içinde bir tane bile boşluk harici karakter varsa bu metot False çıktısıverecektir: >>> a = " " >>> a.isspace() True >>> a = " " >>> a.isspace() True >>> a = "" #karakter dizimiz tamamen boş. İçinde boşluk karakteri bile yok... >>> a.isspace() False >>> a = "fd" >>> a.isspace() False 19.9 isprintable() Hatırlarsanız önceki derslerimizde \n, \t, \r ve buna benzer karakterlerden söz etmiştik. Örneğin \n karakterinin ‘satır başı’ anlamına geldiğini ve bu karakterin görevinin karakter dizisinibiraltsatıraalmakolduğunusöylemiştik.Örnekverelim: >>> print("birinci satır\nikinci satır") birinci satır ikinci satır Bu örnekte \n karakterinin öteki karakterlerden farklı olduğunu görüyorsunuz. Mesela “b” karakteri komut çıktısında görünüyor. Ama \n karakteri çıktıda görünmüyor. \n karakteri elbette yukarıdaki kodlar içinde belli bir işleve sahip. Ancak karakter dizisindeki öteki karakterlerden farklı olarak \n karakteri ekranda görünmüyor. İşte Python’da bunun gibi, ekranda görünmeyen karakterlere ‘basılmayan karakterler’ (non-printing characters) adı verilir. ‘b’, ‘c’, ‘z’, ‘x’, ‘=’, ‘?’, ‘!’ ve benzeri karakterler ise ‘basılabilen karakterler’ (printable characters) olarak adlandırılır. İşte başlıkta gördüğünüz isprintable() metodu da karakterlerin bu yönünü sorgular. Yani bir karakterin basılabilen bir karakter mi yoksa basılmayanbirkaraktermiolduğunusöylerbize.Örneğin: 352 Bölüm19. KarakterDizilerininMetotları(Devamı) PythonBelgeleri,Yayım4.1.3 >>> karakter = "a" >>> karakter.isprintable() True Demekki“a”karakteribasılabilenbirkaraktermiş.Birdeşunabakalım: >>> karakter = "\n" >>> karakter.isprintable() False Demekki\nkarakterigerçektendebasılamayanbirkaraktermiş. Basılamayan karakterlerin listesini görmek için https://www.asciitable.com/ adresini ziyaret edebilirsiniz. Listedeki ilk 32 karakter (0’dan başlayarak 32’ye kadar olan karakterler) ve listedeki127.karakterbasılamayankarakterlerdir. 19.9. isprintable() 353 20 BÖLÜM Karakter Dizilerini Biçimlendirmek Bu bölüme gelinceye kadar, Python’da karakter dizilerinin biçimlendirilmesine ilişkin epey söz söyledik. Ancak bu konu ile ilgili bilgilerimiz hem çok dağınık, hem de çok yüzeysel. İşte bu bölümde amacımız, daha önce farklı yerlerde dile getirdiğimiz bu önemli konuya ait bilgi kırıntılarını bir araya toplayıp, karakter dizisi biçimlendirme konusunu, Python bilgimiz elverdiğiölçüdeayrıntılıbirşekildeelealmakolacak. Şu ana kadar yaptığımız örneklere bakarak, programlama maceranız boyunca karakter dizileriyle bol bol haşır neşir olacağınızı anlamış olmalısınız. Bundan sonra yazdığınız programlardadakarakterdizilerininsizepekçokfarklıbiçimlerdegeldiğinetanıkolacaksınız. Farklı farklı biçimlerde elinize ulaşan bu karakter dizilerini, muhtemelen, sadece alt alta ve rastgele bir şekilde ekrana yazdırmakla yetinmeyeceksiniz. Bu karakter dizilerini, yazdığınız programlardakullanabilmekiçin,programınızauygunşekillerdebiçimlendirmenizgerekecek. Dilerseniz neden bahsettiğimizi daha net bir şekilde anlatabilmek için çok basit bir örnek verelim. Diyelim ki, yazdığınız bir programda kullanmak üzere, kullanıcıdan isim bilgisi almanız gerekiyor.Programınızınişleyişigereğince,eğerisim5karakterseveyabundanküçükseismin tamamı görüntülenecek, ama eğer isim 5 karakterden büyükse 5 karakteri aşan kısım yerine üçnoktaişaretikoyulacak.YanieğerisimFıratisebuismintamamıgörüntülenecek.Amaeğer isimmeselaAbdullahise,ozamanbuisimAbdul... şeklindegörüntülenecek. Buamacaulaşmakiçinilkdenememiziyapalım: isim = input("isminiz: ") if len(isim) <= 5: print(isim[:5]) else: print(isim[:5], "...") Buradaneldeettiğimizçıktıihtiyacımızıkısmenkarşılıyor.Amaçıktıtamistediğimizgibideğil. Çünkünormaldeismebitişikolmasıgerekenüçnoktaişareti,isimdenbirboşlukileayrılmış. Yanibizşöylebirçıktıisterken: 354 PythonBelgeleri,Yayım4.1.3 Abdul... Şöylebirçıktıeldeediyoruz: Abdul ... Busorunuşuşekildehalledebiliriz: isim = input("isminiz: ") if len(isim) <= 5: print(isim[:5]) else: print(isim[:5] + "...") veya: isim = input("isminiz: ") if len(isim) <= 5: print(isim[:5]) else: print(isim[:5], "...", sep="") Yukarıdaki gibi basit durumlarda klasik karakter dizisi birleştirme yöntemlerini kullanarak işinizi halledebilirsiniz. Ama daha karmaşık durumlarda, farklı kaynaklardan gelen karakter dizileriniihtiyaçlarınızagörebirarayagetirmek,karakterdizisibirleştirmeyöntemleriilepek mümkünolmayacakveyaçokzorolacaktır. Meselaşöylebirdurumdüşünün: Yazdığınız programda kullanıcıya bir parola soruyorsunuz. Amacınız bu parolanın, programınızdabelirlediğinizölçütlereuyupuymadığınıtespitetmek.Eğerkullanıcıtarafından belirlenenparolauygunsaonaşuçıktıyıgöstermekistiyorsunuz(parolanınb5tY6golduğunu varsayalım): .. code-block:: pycon Girdiğinizparola(b5tY6g)kurallarauygunbirparoladır! Buçıktıyıeldeetmekiçinşöylebirkodyazabilirsiniz: parola = input("parola: ") print("Girdiğiniz parola (" + parola + ") kurallara uygun bir paroladır!") Gördüğünüzgibi,sadecekarakterdizisibirleştirmeyöntemlerinikullanarakistediğimizçıktıyı eldeettik,amafarkettiysenizbudefaişlerbirazdaolsazorlaştı. Bir de uzun ve karmaşık bir metnin içine dışarıdan değerler yerleştirmeniz gereken şöyle bir metinlekarşıkarşıyaolduğunuzudüşünün: 355 PythonBelgeleri,Yayım4.1.3 Sayın ......... .... tarihinde yapmış olduğunuz, ........ hakkındaki başvurunuz incelemeye␣ alınmıştır. ˓→ Size .... işgünü içinde cevap verilecektir. Saygılarımızla, ...... Böylebirmetiniçinedışarıdandeğeryerleştirmekiçinkarakterdizisibirleştirmeyöntemlerine başvurmakişiniziepeyzorlaştıracaktır. İşte klasik karakter dizisi birleştirme işlemlerinin yetersiz kaldığı veya işleri büsbütün zorlaştırdığı bu tür durumlarda Python’ın size sunduğu ‘karakter dizisi biçimlendirme’ araçlarındanyararlanabilirsiniz. Bununiçinbizbubölümdeikifarklıyöntemdensözedeceğiz: 1. %işaretiilebiçimlendirme 2. format()metoduilebiçimlendirme. % işareti ile biçimlendirme, karakter dizisi biçimlendirmenin eski yöntemidir. Bu yöntem ağırlıklı olarak Python’ın 3.x sürümlerinden önce kullanılıyordu. Ama Python’ın 3.x sürümlerinde de bu yöntemi kullanma imkanımız var. Her ne kadar bu yöntem Python3’te geçerliliğinikorusadamuhtemelenileridedildentamamenkaldırılacak.Ancakhemetraftabu yöntemle yazılmış eski programlar olması, hem de bu yöntemin halen geçerliliğini koruması nedeniylebuyöntemi(kendimizkullanmayacakbileolsak)mutlakaöğrenmemizgerekiyor. format() metodu ise Python’ın 3.x sürümleri ile dile dahil olan bir özelliktir. Python’ın 2.x sürümlerindebumetodukullanamazsınız.Dilingeleceğindebumetotolduğuiçin,yeniyazılan kodlardaformat()metodunukullanmakdahaakıllıcaolacaktır. Bizbusayfalardayukarıdaadınıandığımızherikiyöntemideinceleyeceğiz.İlkolarak%işareti ilebiçimlendirmedensözedelim. 20.1 % İşareti ile Biçimlendirme (Eski Yöntem) Daha önce de söylediğimiz gibi, Python programlama dilinin 3.x sürümlerinden önce, bir karakter dizisini biçimlendirebilmek için % işaretinden yararlanıyorduk. Bununla ilgili basit birörnekverelim: parola = input("parola: ") print("Girdiğiniz parola (%s) kurallara uygun bir paroladır!" %parola) Bu programı çalıştırıp parola girdiğinizde, yazdığınız parola çıktıda parantez içinde görünecektir. Yukarıdakiyapıyıincelediğimizdeikinoktagözümüzeçarpıyor: 356 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 1. İlkolarak,karakterdizisininiçindebir%işaretivebunabitişikolarakyazılmışbirsharfi görüyoruz. 2. İkincisi,karakterdizisinindışında%parolagibibirifadedahavar. Rahatlıkla tahmin edebileceğiniz gibi, bu ifadeler birbiriyle doğrudan bağlantılıdır. Dilerseniz bu yapıyı açıklamaya geçmeden önce bir örnek daha verelim. Bu örnek sayesinde benim açıklamama gerek kalmadan karakter dizisi biçimlendirme mantığını derhal kavrayacağınızı zannediyorum: print("%s ve %s iyi bir ikilidir!" %("Python", "Django")) Dediğimgibi,bubasitörnekkarakterdizilerininnasılbiçimlendirildiğinigayetaçıkbirşekilde gösteriyor.Dilersenizyapıyışöylebirinceleyelim: 1. Python’da%syapısı,karakterdizisiiçindebiryertutmavazifesigörür. 2. %syapısıbiranlamdadeğişkenlerebenzer.Tıpkıdeğişkenlerdeolduğugibi,%syapısının değerideğişebilir. 3. Bir karakter dizisi içindeki her %s ifadesi için, karakter dizisi dışında bu ifadeye karşılık gelen bir değer olmalıdır. Python, karakter dizisi içinde geçen her %s ifadesinin yerine, karakter dizisi dışındaki her bir değeri tek tek yerleştirir. Bizim örneğimizde karakter dizisiiçindekiilk%sifadesininkarakterdizisidışındakikarşılığı“Python”;karakterdizisi içindekiikinci%sifadesininkarakterdizisidışındakikarşılığıise“Django”’dur. 4. Eğer karakter dizisi içindeki %s işaretlerinin sayısı ile karakter dizisi dışında bu işaretlere karşılık gelen değerlerin sayısı birbirini tutmazsa Python bize bir hata mesajı gösterecektir.Mesela: >>> print("Benim adım %s, soyadım %s" %"") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: not enough arguments for format string Gördüğünüz gibi bu kodlar hata verdi. Çünkü karakter dizisi içindeki iki adet %s ifadesine karşılık, karakter dizisinin dışında tek bir değer var (“”). Halbuki bizim şöyle bir kod yazmamızgerekiyordu: >>> isim = "" >>> print("%s adlı kişinin mekanı www.%s.com adresidir." %(isim,␣ isim)) ˓→ Budefaherhangibirhatamesajıalmadık.Çünkübukodlarda,olmasıgerektiğigibi,karakter dizisiiçindekiikiadet%sifadesinekarşılık,dışarıdadaikiadetdeğervar. Eğer karakter dizisi içinde tek bir %s ifadesi varsa, karakter dizisi dışında buna karşılık gelen değeri gösterirken, bu değeri parantez içine almamıza gerek yok. Ama eğer karakter dizisi içinde birden fazla %s işareti varsa, bunlara karşılık gelen değerleri parantez içinde gösteriyoruz. Mesela yukarıdaki parola örneğinde, karakter dizisinin içinde tek bir %s ifadesi var. Dolayısıyla karakter dizisi dışında bu ifadeye karşılık gelen parola değişkenini parantez içine almıyoruz. Ama “Python” ve “Django” örneğinde karakter dizisi içinde iki adet %s ifadesi yer aldığı için, karakter dizisi dışında bu ifadelere karşılık gelen “Python” ve “Django” kelimeleriniparanteziçindegösteriyoruz. 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 357 PythonBelgeleri,Yayım4.1.3 Bütünbuanlattıklarımızısindirebilmekiçindilersenizbirörnekverelim: kardiz = "" for sıra, karakter in enumerate(kardiz, 1): print("%s. karakter: ’%s’" %(sıra, karakter)) Gördüğünüzgibi,“”adlıkarakterdizisiiçindekiherbirharfinsırasınıveharfinkendisini uygun bir düzen içinde ekrana yazdırdık. Karakter sırasının ve karakterin kendisinin cümle içindegeleceğiyerleri%sişaretleriilegösteriyoruz.Pythondaherbirdeğeri,ilgilikonumlara tektekyerleştiriyor. Hatırlarsanız önceki derslerimizde basit bir hesap makinesi örneği vermiştik. İşte şimdi öğrendiklerimizi o programa uygularsak karakter dizisi biçimlendiricileri üzerine epey pratik yapmışoluruz: giriş = """ (1) topla (2) çıkar (3) çarp (4) böl (5) karesini hesapla (6) karekök hesapla """ print(giriş) a = 1 while a == 1: soru = input("Yapmak istediğiniz işlemin numarasını girin (Çıkmak için q): ") ˓→ if soru == "q": print("çıkılıyor...") a = 0 elif soru == "1": sayı1 = int(input("Toplama işlemi için ilk sayıyı girin: ")) sayı2 = int(input("Toplama işlemi için ikinci sayıyı girin: ")) ’ #İlk %s ye karşılık gelen değer : sayı1 ’ #İkinci %s ye karşılık gelen değer: sayı2 ’ #Üçüncü %s ye karşılık gelen değer: sayı1 + sayı2 print("%s + %s = %s" %(sayı1, sayı2, sayı1 + sayı2)) elif soru == "2": sayı3 = int(input("Çıkarma işlemi için ilk sayıyı girin: ")) sayı4 = int(input("Çıkarma işlemi için ikinci sayıyı girin: ")) print("%s - %s = %s" %(sayı3, sayı4, sayı3 - sayı4)) elif soru == "3": (sonrakisayfayadevam) 358 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) sayı5 = int(input("Çarpma işlemi için ilk sayıyı girin: ")) sayı6 = int(input("Çarpma işlemi için ikinci sayıyı girin: ")) print("%s x %s = %s" %(sayı5, sayı6, sayı5 * sayı6)) elif soru == "4": sayı7 = int(input("Bölme işlemi için ilk sayıyı girin: ")) sayı8 = int(input("Bölme işlemi için ikinci sayıyı girin: ")) print("%s / %s = %s" %(sayı7, sayı8, sayı7 / sayı8)) elif soru == "5": sayı9 = int(input("Karesini hesaplamak istediğiniz sayıyı girin: ")) ’ #İlk %s ye karşılık gelen değer : sayı9 ’ #İkinci %s ye karşılık gelen değer: sayı9 ** 2 print("%s sayısının karesi = %s" %(sayı9, sayı9 ** 2)) elif soru == "6": sayı10 = int(input("Karekökünü hesaplamak istediğiniz sayıyı girin: ")) print("%s sayısının karekökü = %s" %(sayı10, sayı10 ** 0.5)) else: print("Yanlış giriş.") print("Aşağıdaki seçeneklerden birini giriniz:", giriş) Buarada,gördüğünüzgibi,Python’dabiçimdüzenleyiciolarakkullanılansimgeaynızamanda ‘yüzde’(%)anlamınadageliyor.Ohaldesizeşöylebirsorusorayım:Acaba0’dan100’ekadar olan sayıların başına birer yüzde işareti koyarak bu sayıları nasıl gösterirsiniz? %0, %1, %10, %15gibi... Önceşöylebirşeydeneyelim: >>> for i in range(100): ... print("%s" %i) ... Bu kodlar tabii ki sadece 0’dan 100’e kadar olan sayıları ekrana dökmekle yetinecektir. Sayılarınbaşında%işaretinigöremeyeceğiz. Birdeşöylebirşeydeneyelim: >>> for i in range(100): ... print("%%s" %i) ... Traceback (most recent call last): File "<stdin>", line 2, in <module> TypeError: not all arguments converted during string formatting Budefadahatamesajıaldık.Halbukidoğrucevapşuolmalıydı: >>> for i in range(100): ... print("%%%s" %i) ... 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 359 PythonBelgeleri,Yayım4.1.3 Burada % işaretini arka arkaya iki kez kullanarak bir adet % işareti elde ettik. Daha sonra da normalbirşekilde%sbiçiminikullandık.Yaniüçadet‘%’işaretiniyanyanagetirmişolduk. Bütün bu örneklerden sonra, karakter dizisi biçimlendiricilerinin işimizi ne kadar kolaylaştırdığını görmüş olmalısınız. İstediğimiz etkiyi elde etmek için karakter dizisi biçimlendiricilerini kullanmak, karakter dizilerini birleştirme işlemlerinden yararlanmaya göreçokdahaesnekbiryöntemdir.Hattabazıdurumlardakarakterdizisibiçimlendiricilerini kullanmakmakultekyöntemdir. Yukarıdaverdiğimizörnekler,%silebiçimlendirmekonusununentemelyönlerinigösteriyor. Amaaslındabuaracıkullanarakçokdahakarmaşıkbiçimlendirmeişlemlerideyapabiliriz. Yaniyukarıdakiörneklerde%syapısınıenbasitşekildemeselaşöylekullandık: >>> print("Karakter dizilerinin toplam %s adet metodu vardır" %len(dir(str))) Ama eğer istersek bundan daha karmaşık biçimlendirme işlemleri de gerçekleştirebiliriz. Şu örneğebakın: >>> for i in dir(str): ... print("%15s" %i) Gördüğünüz gibi % ile s işaretleri arasına bir sayı yerleştirdik. Bu sayı, biçimlendirilecek karakter dizisinin toplam kaç karakterlik yer kaplayacağını gösteriyor. Durumu daha net görebilmeniziçinşöylebirörnekverelim: >>> print("|%15s|" %"") | | Karakterdizisininbaşınavesonunaeklediğimiz‘|’işaretlerisayesindekarakterdizisininnasıl veneşekildehizalandığınıdahabelirginbirşekildegörebiliyoruz.Aslındayukarıdakiörneğin yaptığı iş size hiç yabancı değil. Aynı etkiyi, karakter dizisi metotlarından rjust() ile de yapabileceğimizibiliyorsunuz: >>> print("".rjust(15)) Aynen yukarıdaki çıktıyı rjust() metodunu kullanarak elde etmek için ise şöyle bir şey yazabilirsiniz: >>> print("|%s|" %"".rjust(15)) | | Yukarıdakiörnekte“”karakterdizisinisağadoğruyasladık.Solayaslamakiçinisenegatif sayılardanyararlanabilirsiniz: >>> print("|%-15s|" %"") | | Tıpkıbirazönceverdiğimizörnektekigibi,aynıetkiyiljust()metoduyladaeldeedebilirsiniz: 360 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 >>> print("|%s|" %"".ljust(15)) | | Gördüğünüz gibi, %s yapısını farklı şekillerde kullanarak epey karmaşık çıktılar elde edebiliyoruz. Ama aslında karakter dizisi biçimlendiricilerini kullanarak yapabileceklerimiz bunlarla da sınırlı değildir. Mesela size şöyle bir soru sorduğumu düşünün: Acaba aşağıdaki içeriğesahipbirHTMLşablonununasıleldeedebiliriz? <html> <head> <title> {{ sayfa başlığı }} </title> </head> <body> <h1> {{ birinci seviye başlık }} </h1> <p>Web sitemize hoşgeldiniz! Konumuz: {{ konu }}</p> </body> </html> Burada bütün değişkenler tek bir değere sahip olacak. Örneğin değişkenimiz Python ProgramlamaDiliiseyukarıdakişablonşöylebirHTMLsayfasıüretecek: <html> <head> <title> Python Programlama Dili </title> </head> <body> <h1> Python Programlama Dili </h1> <p>Web sitemize hoşgeldiniz! Konumuz: Python Programlama Dili</p> </body> </html> Aklınızailkolarakşöylebirçözümgelmişolabilir: sayfa = """ <html> <head> <title> %s </title> </head> <body> <h1> %s </h1> <p>Web sitemize hoşgeldiniz! Konumuz: %s</p> </body> </html> """ print(sayfa % ("Python Programlama Dili", "Python Programlama Dili", (sonrakisayfayadevam) 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 361 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) "Python Programlama Dili")) Bu gayet makul ve doğru bir çözümdür. Ancak gördüğünüz gibi yukarıdaki kodlarda bizi rahatsız eden bir nokta var. Bu kodlarda aynı karakter dizisini (“Python Programlama Dili”) üç kez tekrar ediyoruz. En baştan beri söylediğimiz gibi, kod yazarken tekrarlardan olabildiğince kaçınmaya çalışmamız programımızın performansını artıracaktır. Burada da tekrardankaçınmakamacıylaşöylebirkodyazmayıtercihedebiliriz.Dikkatliceinceleyin: sayfa = """ <html> <head> <title> %(dil)s </title> </head> <body> <h1> %(dil)s </h1> <p>Web sitemize hoşgeldiniz! Konumuz: %(dil)s</p> </body> </html> """ print(sayfa % {"dil": "Python Programlama Dili"}) Gördüğünüzgibi,yukarıdakikodlarbiziaynıkarakterdizisinitekrartekraryazmazahmetinden kurtardı. Peki ama nasıl? Gelin isterseniz bu yapıyı daha iyi anlayabilmek için daha basit bir örnekverelim: print("depoda %(miktar)s kilo %(ürün)s kaldı" %{"miktar": 25, "ürün": "elma"}) Buradaşöylebiryapıylakarşıkarşıyayız: "%(değişken_adı)s" % {"değişken_adı": "değişken_değeri"} {“değişken_adı”:“değişken_değeri”}yapısıylaöncekiderslerimizdekarşılaşmıştınız.Dolayısıyla bu yapının temel olarak ne işe yaradığını biliyorsunuz. Hatta bu yapının adının ‘sözlük’ olduğunu da öğrenmiştiniz. İşte burada, sözlük adlı veri tipinden yararlanarak değişken adlarıiledeğişkendeğerlerinieşleştirdik.Böyleceaynışeyleritekrartekraryazmamızagerek kalmadı.Ayrıcayukarıdakiörnektedeğerlerisırasınagöredeğil,isminegöreçağırdığımıziçin, karakterdizisiiçindekideğerlerinsırasınıtakipetmezahmetindendekurtulmuşolduk. Böylece%yapısınıntümtemelayrıntılarınıöğrenmişolduk.Artık%işaretininbaşkayönlerini incelemeyebaşlayabiliriz. 362 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 20.1.1 Biçimlendirme Karakterleri Biraz önce, Python’da eski usul karakter dizisi biçimlendirme yöntemi olan % işareti üzerine en temel bilgileri edindik. Buraya kadar öğrendiklerimiz, yazdığımız programlarda genellikle yolumuzu yordamımızı bulmamıza yetecektir. Ama isterseniz şimdi karakter dizisi biçimlendirme konusunu biraz daha derinlemesine ele alalım. Mesela Python’daki biçimlendirmekarakterlerininnelerolduğunuinceleyelim. s Önceki örneklerden de gördüğünüz gibi, Python’da biçim düzenleme işlemleri için %s adlı bir yapıdan faydalanıyoruz. Bu yapıyı şöyle bir masaya yatırdığımızda aslında bu yapının iki parçadan oluştuğunu görebiliriz. Bu parçalar % ve s karakterleridir. Burada gördüğümüz parçalardan%sabit,sisedeğişkendir.Yani%sabitdeğerinibazıharflerlebirliktekullanarak, farklıkarakterdizisibiçimlendirmeişlemlerigerçekleştirebiliriz. Bizöncekisayfalardaverdiğimizörneklerdebusimgeyisharfiylebirliktekullandık.Örneğin: >>> print("Benim adım %s" %"") Bukodlardakiskarakteriİngilizcestring,yani‘karakterdizisi’ifadesininkısaltmasıdır.Esasında en yaygın çift de budur. Yani etraftaki Python programlarında yaygın olarak %s yapısını görürüz. Ancak Python’da % biçim düzenleyicisiyle birlikte kullanılabilecek tek karakter s değildir. Daha önce de dediğimiz gibi, s karakteri string, yani ‘karakter dizisi’ ifadesinin kısaltmasıdır.Yaniaslında%syapısıPython’daözelolarakkarakterdizilerinitemsileder. Pekibunedemekoluyor? Bir karakter dizisi içinde %s yapısını kullandığımızda, dışarıda buna karşılık gelen değerin de birkarakterdizisiveyakarakterdizisineçevrilebilecekbirdeğerolmasıgerekir.Python’daher şey bir karakter dizisi olarak temsil edilebilir. Dolayısıyla bütün işlemlerinizde % işaretini s karakteri ile birlikte kullanabilirsiniz. Ama bazı özel durumlarda % işaretini s dışında başka harflerlebirliktekullanmanızdagerekebilir. Biz % yapısı ile ilgili verdiğimiz ilk örneklerde bu yapının s karakteri ile birlikte kullanılışını gösteren pek çok örnek verdiğimiz için % ile s birlikteliği üzerinde daha fazla durmayacağız. Bununyerine,%ilebirliktekullanılanötekikarakterleriinceleyeceğiz.Ohaldeyolakoyulalım. d Bir önceki başlıkta gördüğümüz s harfi nasıl karakter dizilerini temsil ediyorsa, d harfi de sayılarıtemsileder.İstersenizküçükbirörnekleaçıklamayaçalışalımdurumu: >>> print("Şubat ayı bu yıl %d gün çekiyor" %28) Şubat ayı bu yıl 28 gün çekiyor. Gördüğünüzgibi,%işaretiylebirliktebudefasyerinedharfinikullandık.Bunauygunolarak dadıştarafta28sayısınıkullandık.Pekiyukarıdakiifadeyişöyledeyazamazmıydık? >>> print("Şubat ayı bu yıl %s gün çekiyor" %28) 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 363 PythonBelgeleri,Yayım4.1.3 Elbetteyazabilirdik.Bukoddabizedoğruçıktıverecektir.Çünküdahaöncededediğimizgibi, s harfi karakter dizilerini ve karakter dizisine çevrilebilen değerleri temsil eder. Python’da sayılar karakter dizisine çevrilebildiği için %s gibi bir yapıyı hata almadan kullanabiliyoruz. Amameselaşöylebirşeyyazamayız: >>> print("Şubat ayı bu yıl %d gün çekiyor" %"yirmi sekiz") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: %d format: a number is required, not str Gördüğünüz gibi bu defa hata aldık. Çünkü d harfi yalnızca sayı değerleri temsil edebilir. Bu harflebirliktekarakterdizilerinikullanamayız. Doğrusunu söylemek gerekirse, d harfi aslında tam sayı (integer) değerleri temsil eder. Eğer bu harfin kullanıldığı bir karakter dizisinde değer olarak mesela bir kayan noktalı sayı (float) verirsek, bu değer tamsayıya çevrilecektir. Bunun ne demek olduğunu hemen bir örnekle görelim: >>> print("%d" %13.5) 13 Gördüğünüzgibi,%difadesi,13.5sayısınınondalıkkısmınıçıktıdagöstermiyor.Çünküdharfi sadecetamsayılarıtemsiletmeişlevigörüyor. Burada şöyle bir soru aklınıza gelmiş olabilir: ‘Acaba %d ifadesi ile hiç uğraşmasak, bunun yerineheryerde%sifadesinikullansakolmazmı?’. Çoğu zaman olur, ama mesela şöyle bir durum düşünün: Yazdığınız programda kullanıcıdan sadece tam sayı girmesini istiyor olabilirsiniz. Yani mesela kullanıcının ondalık sayı girmesi halinde, siz bu sayının sadece tam sayı kısmını almak istiyor olabilirsiniz. Örneğin kullanıcı 23.8 gibi bir sayı girmişse, siz bu sayıda ihtiyacınız olan 23 kısmını almak isteyebilirsiniz. İşte bu %d işaretinden yararlanarak, kullanıcının girdiği ondalık sayının sadece tam sayı kısmını çekebilirsiniz: sayı = input("sayı: ") print("%d" %float(sayı)) Elbette Python’da bir ondalık sayının sadece taban kısmını almanın başka yöntemleri de vardır.Amayukarıdaverdiğimizörnekbirondalıksayınınsadecetabanınıalmanıngayetbasit veetkilibiryoludur. %s yapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme tekniklerini %d ile de kullanabilirsiniz.Örneğin: >>> print("|%7d|" %23) | 23| >>> print("|%-7d|" %23) |23 | 364 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 veya: >>> print("%(sayı)d" % {"sayı": 23}) 23 %syapısınaekolarak,sayınınkaplayacağıalandakiboşluklarabirer0dayerleştirebilirsiniz: >>> print("%05d" %23) 00023 ...veya: >>> print("%.5d" %23) 00023 Hatta hem sayının kaplayacağı boşluk miktarını hem de bu boşlukların ne kadarının 0 ile doldurulacağınıdabelirleyebilirsiniz: >>> print("%10.5d" %23) 00023 Burada 23 sayısının toplam 10 boşlukluk bir yer kaplamasını ve bu 10 adet boşluğun 5 tanesininiçine0sayılarınınve23sayısınınsığdırılmasınıistedik. Birdeşunabakalım: >>> print("%010.d" %23) 0000000023 Burada ise 23 sayısının toplam 10 boşlukluk bir yer kaplamasını ve bu 10 adet boşluğa 23 sayısıyerleştirildiktensonraartakalankısmın0sayılarıiledoldurulmasınıistedik. Bu arada, son örnekte yaptığımız şeyi, daha önce öğrendiğimiz zfill() metoduyla da yapabileceğimizibiliyorsunuz: >>> "23".zfill(10) ’0000000023’ Yukarıdaki kullanımlar ilk bakışta gözünüze karışık görünmüş olabilir. Ama eğer yeterince pratik yaparsanız, aslında bu biçimlerin hiç de o kadar karmaşık olmadığını anlarsınız. İstersenizbubiçimlerleneleryapabileceğimizişöylebirkısacatarifedelim: d harfi, % işaretiyle birlikte kullanıldığında sayıları temsil eder. Bu iki karakterin en temel kullanımışöyledir: >>> "%d" %10 ’10’ 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 365 PythonBelgeleri,Yayım4.1.3 dharfiile%işaretiarasınabirpozitifveyanegatifsayıgetirerek,temsiledileceksayınıntoplam kaçboşluktanoluşanbiralaniçineyerleştirileceğinibelirleyebiliyoruz: >>> "%5d" %10 ’ 10’ Burada 10 sayısını toplam 5 boşlukluk bir alan içine yerleştirdik. Gördüğünüz gibi, bir pozitif sayıkullandığımızda,sayımızkendisineayrılanalaniçindesağayaslanıyor.Eğerbusayıyısola yaslamakisterseknegatifsayılardanyararlanabiliriz: >>> "%-5d" %10 ’10 ’ Eğer sağa yasladığımız bir sayının sol tarafını sıfırla doldurmak istersek, hizalama miktarını belirtmekiçinkullandığımızsayınınsolunabirsıfırekleyebiliriz: >>> "%05d" %10 ’00010’ Aynıetkiyişuşekildedeeldeedebilirsiniz: >>> "%.5d" %10 ’00010’ Eğernoktaişaretindenöncebirsayıbelirtirseniz,karakterdizisiobelirttiğinizsayıkadarsağa yaslanacaktır.Yani: >>> "%10.5d" %10 ’ 00010’ ... veyasola: >>> "%-10.5d" %10 ’00010 ’ Her iki şekilde de, karakter dizisini toplam 10 boşluktan oluşan bir alan içine yerleştirmiş olduk. Bu toplam alanın 5 boşlukluk kısmı sayının kendisi ve sayının soluna gelecek 0’lar arasındapaylaştırıldı. Gördüğünüzgibi,biçimlendirmemantığınınaslındaokadardakorkulacakbiryanıyok.Kendi kendinize yukarıdakilere benzer örnekler yaparak bu yapıyı daha iyi bir şekilde anlamaya çalışabilirsiniz. 366 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 i Bu harf de integer, yani ‘tam sayı’ kelimesinin kısaltmasıdır. Kullanım ve işlev olarak, d harfindenhiçbirfarkıyoktur. o Buharfoctal(sekizli)kelimesininkısaltmasıdır.Adındandaanlaşılacağıgibi,sekizlidüzendeki sayılarıtemsileder.Dolayısıylabuharfikullanarakonludüzendekibirsayıyısekizlidüzendeki karşılığınadönüştürebilirsiniz.Örneğin: >>> print("%i sayısının sekizli düzendeki karşılığı %o sayısıdır." %(10, 10)) 10 sayısının sekizli düzendeki karşılığı 12 sayısıdır. (cid:242) Not %dyapısınıanlatırkengösterdiğimizileridüzeybiçimlendirmetekniklerinintamamını%o iledekullanabilirsiniz. x Bu harf hexadecimal, yani onaltılı düzendeki sayıları temsil eder. Dolayısıyla bu harfi kullanarakonludüzendekibirsayıyıonaltılıdüzendekikarşılığınaçevirebilirsiniz: >>> print("%i sayısının onaltılı düzendeki karşılığı %x sayısıdır." %(20, 20)) 20 sayısının onaltılı düzendeki karşılığı 14 sayısıdır. Buradaki ‘x’ küçük harf olarak kullanıldığında, onaltılı düzende harfle gösterilen sayılar da küçükharfletemsiledilecektir: >>> print("%i sayısının onaltılı düzendeki karşılığı %x sayısıdır." %(10, 10)) 10 sayısının onaltılı düzendeki karşılığı a sayısıdır. (cid:242) Not %d yapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme tekniklerinin tamamını %x iledekullanabilirsiniz. 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 367 PythonBelgeleri,Yayım4.1.3 X Bu da tıpkı x harfinde olduğu gibi, onaltılı düzendeki sayıları temsil eder. Ancak bunun farkı, harflegösterilenonaltılısayılarıbüyükharfletemsiletmesidir: >>> print("%i sayısının onaltılı düzendeki karşılığı %X sayısıdır." %(10, 10)) 10 sayısının onaltılı düzendeki karşılığı A sayısıdır. (cid:242) Not %dyapısınıanlatırkengösterdiğimizileridüzeybiçimlendirmetekniklerinintamamını%X iledekullanabilirsiniz. f Python’da karakter dizilerini biçimlendirirken s harfinden sonra en çok kullanılan harf f harfidir.Buharfİngilizce’dekifloat,yani‘kayannoktalısayı’kelimesininkısaltmasıdır.Adından daanlaşılacağıgibi,karakterdizileriiçindekikayannoktalısayılarıtemsiletmekiçinkullanılır. >>> print("Dolar %f TL olmuş..." %1.4710) Dolar 1.471000 TL olmuş... Bu çıktı sizi biraz şaşırtmış olabilir. Çünkü gördüğünüz gibi, çıktıda bizim eklemediğimiz hanelervar. Python’da bir karakter dizisi içindeki sayıyı %f yapısı ile kayan noktalı sayıya çevirdiğimizde noktadansonraöntanımlıolarak6haneyeralacaktır.Yanimesela: >>> print("%f" %10) 10.000000 Gördüğünüz gibi, gerçekten de 10 tam sayısı %f yapısı ile kayan noktalı sayıya dönüştürüldüğündenoktadansonra6adetsıfırasahipoluyor. Başkabirörnekdahaverelim: >>> print("%f"%23.6) 23.600000 Bu örnek, %f yapısının, kayan noktalı sayıların noktadan sonraki hane sayısını da 6’ya tamamladığını gösteriyor. Ama elbette biz istersek, daha önce öğrendiğimiz teknikleri kullanarak,noktadansonrakaçhaneolacağınıbelirleyebiliriz: >>> print("%.2f" % 10) 10.00 368 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 %f yapısında, % ile f arasına .2 gibi bir ifade yerleştirerek noktadan sonra 2 hane olmasını sağladık. (cid:242) Not Dahaöncegösterdiğimizileridüzeybiçimlendirmetekniklerini%f iledekullanabilirsiniz. c Bu harf de Python’daki önemli karakter dizisi biçimlendiricilerinden biridir. Bu harf tek bir karakteritemsileder: >>> print("%c" %"a") a Ama: >>> print("%c" %"") Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: %c requires int or char Gördüğünüz gibi, c harfi sadece tek bir karakteri kabul ediyor. Karakter sayısı birden fazla olduğundabukomuthataveriyor. c harfinin bir başka özelliği de ASCII tablosunda sayılara karşılık gelen karakterleri de gösterebilmesidir: >>> print("%c" %65) A ASCIItablosunda65sayısı‘A’harfinekarşılıkgeldiğiiçinyukarıdakikomutunçıktısı‘A’harfini gösteriyor.EğeristersenizcharfinikullanarakbütünASCIItablosunuekranadökebilirsiniz: >>> for i in range(128): ... print("%s ==> %c" %(i, i)) (cid:242) Not %s yapısını anlatırken gösterdiğimiz ileri düzey biçimlendirme tekniklerinin tamamını %c iledekullanabilirsiniz. BöylecePython’da%işaretikullanaraknasılbiçimlendirmeyapabileceğimiziöğrenmişolduk. Dilersenizpratikolmasıaçısından,karakterdizisibiçimlendiricilerininkullanımınıgösterenbir örnekvererekbubölümünoktalayalım. Dikkatliceinceleyin: 20.1. %İşaretiileBiçimlendirme(EskiYöntem) 369 PythonBelgeleri,Yayım4.1.3 for sıra, karakter in enumerate(dir(str)): if sıra % 3 == 0: print("\n", end="") print("%-20s" %karakter, end="") Burada, gördüğünüz gibi, karakter dizisi metotlarını bir tablo görünümü içinde ekrana yazdırdık.Şusatırlaryardımıylatablodakisütunsayısını3olarakbelirledik: if sıra % 3 == 0: print("\n", end="") Burada modülüs işlecini nasıl kullandığımıza çok dikkat edin. sıra değişkeninin değerini 3’e böldüğümüzde kalan değerin 0 olduğu her sayıda satır başına geçiyoruz. Böylece her 3. sütundabirsatıraşağıgeçilmişoluyor. Bununlailgilibirörnekdahaverelim: for i in range(20): print("%5d%5o%5x" %(i, i, i)) Burada0’dan20’yekadarolansayılarınonlu,sekizliveonaltılıdüzendekikarşılıklarınıbirtablo görünümü içinde ekrana çıktı verdik. Bu arada, eğer isterseniz yukarıdaki kodları şöyle de yazabileceğinizibiliyorsunuz: for i in range(20): print("%(deger)5d%(deger)5o%(deger)5x" %({"deger": i})) Buradada,tablomuzubiçimlendirmekiçin‘sözlük’adınıverdiğimizyapıdanyararlandık. 20.2 format() Metodu ile Biçimlendirme (Yeni Yöntem) En başta da söylediğimiz gibi, % işaretini kullanarak karakter dizisi biçimlendirme eskide kalmış bir yöntemdir. Bu yöntem ağırlıklı olarak Python’ın 2.x sürümlerinde kullanılıyordu. Her ne kadar bu yöntemi Python’ın 3.x sürümlerinde de kullanmak mümkün olsa da yeni yazılan kodlarda bu yöntem yerine biraz sonra göreceğimiz format() metodunu kullanmak çokdahaakıllıcaolacaktır.Çünkümuhtemelen%ilebiçimlendirmeyöntemi,ilerikibirPython sürümünde dilden tamamen kaldırılacak. Bu yüzden bu eski metoda fazla bel bağlamamak gerekiyor. Dahaöncekiderslerimizdeverdiğimizörneklersayesindeformat()metodununtemelolarak nasıl kullanılacağını biliyoruz. Ama isterseniz biz yine de bütünlük açısından format() metodununtemelkullanımınıburadatekrarelealalım. format()metodunuenbasitşekildeşöylekullanıyoruz: >>> print("{} ve {} iyi bir ikilidir!".format("Django", "Python")) Django ve Python iyi bir ikilidir! Gördüğünüzgibi,eskiyöntemdeki%işaretinekarşılık,yeniyöntemde{}işaretinikullanıyoruz. Çokbasitbirörnekdahaverelim: 370 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 isim = input("İsminiz: ") print("Merhaba {}. Nasılsın?".format(isim)) Elbettebuörneğişuşekildedeyazabilirdik: isim = input("İsminiz: ") print("Merhaba", isim + ".", "Nasılsın?") Burada format() metodunu ve biçim düzenleyicileri hiç kullanmadan, sadece karakter dizilerinibirleştirerekistediğimizçıktıyıeldeettik.Amasizdegörüyorsunuz;karakterdizilerini birleştirmekleuğraşacağımızaformat()metodunukullanmakhemdahapratiktir,hemdebu şekildeyazdığımızkodlardahaokunaklıolur. Yukarıdaki örnekte format() metodunu tek bir parametre ile birlikte kullandık (isim). Bu parametre (tıpkı eski % işaretinde olduğu gibi), karakter dizisi içindeki {} işaretine karşılık geliyor. Bukonuyudahaiyianlayabilmekiçinbirörnekdahaverelim: kalkış = input("Kalkış yeri: ") varış = input("Varış yeri: ") isim_soyisim = input("İsim ve soyisim: ") bilet_sayısı = input("Bilet sayısı: ") print("""{} noktasından {} noktasına, 14:30 hareket saatli sefer için {} adına {} adet bilet ayrılmıştır!""".format(kalkış, varış, isim_soyisim, bilet_sayısı)) Gördüğünüz gibi, {} işaretleri karakter dizisi içinde bir ‘yer tutma’ görevi görüyor. Tutulan bu yerlereneleringeleceğiniformat()metodununparametrelerivasıtasıylabelirliyoruz. Elbetteeğeristersenizyukarıdakiörneğişuşekildedeyazabilirsiniz: kalkış = input("Kalkış yeri: ") varış = input("Varış yeri: ") isim_soyisim = input("İsim ve soyisim: ") bilet_sayısı = input("Bilet sayısı: ") metin = "{} noktasından {} noktasına, 14:30 hareket saatli \ sefer için {} adına {} adet bilet ayrılmıştır!" print(metin.format(kalkış, varış, isim_soyisim, bilet_sayısı)) Ancak yaygın olarak kullanılan yöntem, karakter dizisini herhangi bir değişkene atamadan, doğrudan format() metoduna bağlamaktır. Elbette hangi yöntem kolayınıza geliyorsa onu tercihetmekteözgürsünüz.Amaözelliklebiçimlendirilecekkarakterdizisininçokuzunolduğu durumlarda,yukarıdakigibi,karakterdizisiniöncebirdeğişkeneatayıp,sonradabudeğişken üzerineformat()metodunuuygulamakdahamantıklıolabilir. Verdiğimiz bu örneği, her zaman olduğu gibi, format() metoduna başvurmadan yazmak da mümkündür: 20.2. format()MetoduileBiçimlendirme(YeniYöntem) 371 PythonBelgeleri,Yayım4.1.3 kalkış = input("Kalkış yeri: ") varış = input("Varış yeri: ") isim_soyisim = input("İsim ve soyisim: ") bilet_sayısı = input("Bilet sayısı: ") print(kalkış, "noktasından", varış, "noktasına, 14:30 hareket saatli \ sefer için", isim_soyisim, "adına", bilet_sayısı, "adet bilet ayrılmıştır!") Tıpkı daha önce verdiğimiz örnekte olduğu gibi, burada da format() metodunu kullanmak karakter dizilerini birleştirme yöntemine göre daha mantıklı ve kolay görünüyor. Ayrıca bir karakter dizisi karmaşıklaştıkça bu karakter dizisini sadece karakter dizisi birleştirme yöntemleriylebiçimlendirmeyeçalışmakbirsüresonratambireziyethalinialabilir.Oyüzden, ‘Ben format() metodunu öğrenmesem de olur,’ diye düşünmeyin sakın. Mesela şöyle bir programıformat()metodukullanmadanyazmayaçalışmakhiçakılkârıdeğildir: kodlama = "utf-8" site_adı = "Python Programlama Dili" dosya = open("deneme.html", "w", encoding=kodlama) içerik = """ <html> <head> <meta http-equiv="Content-Type" content="text/html; charset={}" /> <title>{}</title> </head> <body> <h1>.com web sitesine hoş geldiniz!</h1> <p><b>{}</b> için bir Türkçe belgelendirme projesi...</p> </body> </html> """ print(içerik.format(kodlama, site_adı, site_adı), file=dosya) dosya.close() Buradaşusatırınbirkısmıhariçbütünkodlarıanlayabilecekdüzeydesiniz: dosya = open("deneme.html", "w", encoding=kodlama) Bu kodlarla, deneme.html adlı bir dosya oluşturduğumuzu biliyorsunuz. Daha önceki derslerimizde birkaç kez gördüğümüz open() fonksiyonu Python’da dosya oluşturmamıza imkan veriyor. Bu fonksiyon içinde kullandığımız üç parametrenin ilk ikisi size tanıdık gelecektir. İlk parametre dosyanın adını, ikinci parametre ise bu dosyanın hangi kipte açılacağını gösteriyor. Burada kullandığımız “w” parametresi deneme.html adlı dosyanın yazma kipinde açılacağını gösteriyor. Bu fonksiyona atadığımız encoding parametresi ise oluşturulacak dosyanın kodlama biçimini gösteriyor. Bu da Türkçe karakterlerin dosyada düzgüngörüntülenebilmesiaçısındanönemtaşıyor. Kümeparantezlerini,yukarıdakiörneklerdegörüldüğüşekildeiçiboşolarakkullanabilirsiniz. 372 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 Böyle bir durumda Python, karakter dizisi içindeki küme parantezleriyle, karakter dizisi dışındaki değerleri teker teker ve sırasıyla eşleştirecektir. Ama isterseniz küme parantezleri içine birer sayı yazarak, karakter dizisi dışındaki değerlerin hangi sırayla kullanılacağını belirleyebilirsiniz.Örneğin: >>> "{0} {1}".format("Fırat", "Özgül") ’Fırat Özgül’ Küme parantezleri içinde sayı kullanabilme imkanı sayesinde değerlerin sırasını istediğiniz gibidüzenleyebilirsiniz: >>> "{1} {0}".format("Fırat", "Özgül") ’Özgül Fırat’ Hattabuözelliksayesindedeğerleribirkezyazıp,birdenfazlasayıdatekraredebilirsiniz: >>> "{0} {1} ({1} {0})".format("Fırat", "Özgül") ’Fırat Özgül (Özgül Fırat)’ Dolayısıyla, {} işaretleri içinde öğelerin sırasını da belirterek, biraz önce verdiğimiz HTML sayfasıörneğinişuşekildeyazabilirsiniz: kodlama = "utf-8" site_adı = "Python Programlama Dili" dosya = open("deneme.html", "w", encoding=kodlama) içerik = """ <html> <head> <meta http-equiv="Content-Type" content="text/html; charset={0}" /> <title>{1}</title> </head> <body> <h1>.com web sitesine hoş geldiniz!</h1> <p><b>{1}</b> için bir Türkçe belgelendirme projesi...</p> </body> </html> """ print(içerik.format(kodlama, site_adı), file=dosya) dosya.close() Gördüğünüzgibi,öğelerinsıranumarasınıbelirtmemizsayesinde,karakterdizisiiçindeikikez ihtiyaç duyduğumuz site_adı adlı değişkeni format() metodu içinde iki kez yazmak zorunda kalmadık. Yukarıdaki örnekler bize, format() metodunun parametrelerine sıra numarasına göre 20.2. format()MetoduileBiçimlendirme(YeniYöntem) 373 PythonBelgeleri,Yayım4.1.3 erişebileceğimizi gösteriyor. Biz aynı zamanda bu metodun parametrelerine isme göre de erişebiliriz.Çokbasitbirörnek: print("{dil} dersleri".format(dil="python")) Buyöntemikullanarak,aynıdeğişkenibirkaçfarklıyerdekullanabilirsiniz: sayfa = """ <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <title>{konu}</title> </head> <body> <h1>.com web sitesine hoş geldiniz!</h1> <p><b>{konu}</b> için bir Türkçe belgelendirme projesi...</p> </body> </html> """ print(sayfa.format(konu="Python Programlama Dili")) format() metodunun yetenekleri yukarıda gösterdiğimiz şeylerle sınırlı değildir. Tıpkı eski biçimlendirmeyöntemindeolduğugibi,{}işaretleriarasındabazısayılarkullanarak,karakter dizileriüzerindehizalamaişlemlerideyapabiliriz. Dikkatlicebakın: >>> print("{:>15}".format("")) Bu gösterim gözünüze oldukça yabancı ve karışık gelmiş olabilir. Ama aslında hiç de öyle anlaşılmaz bir yanı yoktur bu kodların. Gördüğünüz gibi, burada öncelikle: adlı bir işaretten yararlanıyoruz.Buişaretinardından>adlıbaşkabirişaretgörüyoruz.Sonolarakda15sayısını kullanıyoruz. : işareti, bir biçimlendirme işlemi yapacağımızı gösteriyor. > işareti ise bu biçimlendirmenin birhizalamaişlemiolacağınıhaberveriyor.Ensondaki15sayısıisebuhizalamaişleminin15 karakterlik bir alan ile ilgili olduğunu söylüyor. Bu şekilde karakter dizisini 15 karakterlik bir alan içine yerleştirip karakter dizisini sağa yasladık. Yukarıdaki çıktıyı daha iyi anlayabilmek içinkodlarışöyledeyazabilirsiniz: >>> print("|{:>15}|".format("")) | | Gördüğünüzgibi,karakterdizimiz,kendisineayrılan15karakterlikalaniçindesağayaslanmış vaziyetteduruyor. Eğeraynıkarakterdizisinisolayaslamakistersenizşöylebirşeyyazabilirsiniz: 374 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 >>> print("|{:<15}|".format("")) | | Budefa<adlıişarettenyararlandığımızadikkatedin. Yukarıdaki yöntemi kullanarak, karakter dizilerini sola veya sağa yaslamanın yanısıra, kendilerineayrılanalaniçindeortalayabilirsinizde: >>> print("|{:^15}|".format("")) | | Gördüğünüzgibi,python3ilegelenformat()metodunuhizalamaişlemleriiçinkullanırkenüç farklıişarettenyararlanıyoruz: tabularytabulary > sağayaslama < solayaslama ^ ortalama Yukarıdaki işaretler, yaptıkları işi çağrıştırdıkları için, bunları akılda tutmak çok zor olmasa gerek. Mesela örnek olması açısından, eski biçimlendirme yönteminin son kısmında verdiğimizşuörneği: for sıra, karakter in enumerate(dir(str)): if sıra % 3 == 0: print("\n", end="") print("%-20s" %karakter, end="") ... birdeyeniformat()metoduylayazalım: for sıra, karakter in enumerate(dir(str)): if sıra % 3 == 0: print("\n", end="") print("{:<20}".format(karakter), end="") Bu örneği inceleyerek, eski ile yeni yöntem arasında nelerin değiştiğini, neyin neye karşılık geldiğinigörebilirsiniz. 20.2.1 Biçimlendirme Karakterleri Hatırlarsanız Python2’de geçerli olan eski biçimlendirme yönteminde % karakteri ile bazı harfleri birlikte kullanarak karakter dizileri üzerinde biçimlendirme ve dönüştürme işlemleri yapabiliyorduk.AynışeyPython3ilebirliktegelenbuformat()metoduiçindegeçerlidir.Yani benzer harfleri kullanarak format() metodu ile de karakter dizileri üzerinde biçimlendirme vedönüştürmeişlemleriyapabiliriz. format()metoduilebirlikteşuharflerikullanabiliyoruz: 20.2. format()MetoduileBiçimlendirme(YeniYöntem) 375 PythonBelgeleri,Yayım4.1.3 s Buharfkarakterdizilerinitemsileder. Yalnızbubiçimlendiricikarakterlerin{}işaretleriiçindekikullanımıilkbakıştagözünüzebiraz karışıkgelebilir: >>> print("{:s}".format("karakter dizisi")) karakter dizisi Bu arada, harfleri {} yapısının içinde nasıl kullandığımıza dikkat edin. Gördüğünüz gibi biçimlendirme karakterini kullanırken, karakterin sol tarafına bir adet: işareti de yerleştiriyoruz.Birörnekverelim: print("{:s} ve {:s} iyi bir ikilidir!".format("Python", "Django")) Yalnız,sharfikarakterdizilerinitemsilettiğiiçin,{}işaretleriarasındabuharfikullandığımızda, format() metodunun alabileceği parametreyi karakter dizisiyle sınırlandırmış oluruz. Dolayısıyla bu harfi kullandıktan sonra format() metodu içinde sadece karakter dizilerini kullanabiliriz.EğersayıkullanırsakPythonbizebirhatamesajıgösterecektir: >>> print("{:s}".format(12)) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: Unknown format code ’s’ for object of type ’int’ Bu yüzden, eğer amacınız format() metoduna parametre olarak karakter dizisi vermekse, {} işaretleriiçindeherhangibirharfkullanmamakdahaakıllıcaolabilir: print("{} ve {} iyi bir ikilidir!".format("Python", "Django")) c Buharf0ile256arasısayılarınASCIItablosundakikarşılıklarınıtemsileder: >>> print("{:c}".format(65)) A d Buharfsayılarıtemsileder: >>> print("{:d}".format(65)) 65 EğersayıdışındabirdeğerkullanırsanızPythonsizebirhatamesajıgösterir: 376 Bölüm20. KarakterDizileriniBiçimlendirmek PythonBelgeleri,Yayım4.1.3 >>> print("{:d}".format("65")) Traceback (most recent call last): File "<stdin>", line 1, in <module> ValueError: Unknown format code ’d’ for object of type ’str’ o Buharfonludüzendekisayılarısekizlidüzendekikarşılıklarınaçevirir: >>> print("{:o}".format(65)) 101 x Buharfonludüzendekisayılarıonaltılıdüzendekikarşılıklarınaçevirir: >>> print("{:x}".format(65)) 41 X Tıpkıxharfindeolduğugibi,buharfdeonludüzendekisayılarıonaltılıdüzendekikarşılıklarına çevirir: >>> "{:X}".format(65) ’41’ PekixileXharfiarasındanefarkvar?Farkşudur:x;onaltılıdüzendeharflegösterilensayıları küçük harf şeklinde temsil eder. X işareti bu sayıları büyük harf şeklinde temsil eder. Bu ikisi arasındakifarkıdahanetgörmekiçinşöylebirkodyazabilirsiniz: >>> for i in range(20): ... print("{:x}{:10X}".format(i, i)) ... 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 (sonrakisayfayadevam) 20.2. format()MetoduileBiçimlendirme(YeniYöntem) 377 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 9 9 a A b B c C d D e E f F 10 10 11 11 12 12 13 13 Gördüğünüzgibigerçektendexharfionaltılıdüzendeharflerlegösterilensayılarıküçükharf olarak;Xharfiisebüyükharfolaraktemsilediyor. b Buişaret,onludüzendekisayılarıikilidüzendekikarşılıklarınaçevirir: >>> "{:b}".format(2) ’10’ f Buişaret,eskibiçimlendirmeyönteminianlatırkengösterdiğimizf işaretiylebenzerbirişleve sahiptir: print("{:.2f}".format(50)) 50.00 , :işaretini,işareti(basamakayracı)ilebirliktekullanarak,sayılarıbasamaklarınaayırabilirsiniz: >>> "{:,}".format(1234567890) ’1,234,567,890’ BöylecePython’dakarakterdizisibiçimlendirmeninhemeskihemdeyeniyöntemini,şuana kadarkiPythonbilgimizelverdiğiölçüdeayrıntılıbirşekildeincelemişolduk.Buradakibilgileri kullanarakbolbolörnekyapmakbukonuyudahaiyianlamanızayardımcıolacaktır. 378 Bölüm20. KarakterDizileriniBiçimlendirmek 21 BÖLÜM f-string Daha önceki bölümlerde format() fonksiyonuyla karakter dizilerini nasıl biçimlendirebileceğimizi görmüştük. 3.6 sürümü ile Python’a eklenen f-string yapısı da buna benzer bir şekilde çalışıyor. Öncelikle format() fonksiyonunu nasıl kullandığımızı hatırlayalım: isim = ’Buğra’ print(’Selam {kime}!’.format(kime=isim)) BuradaöncelikleisimadındabirdeğişkentanımladıkvebudeğişkeneBuğradeğeriniatadık. Dahasonrada‘Selam{isim}!’diyebirkarakterdizisiniekranayazdırdık.format()fonksiyonunu kullanarakPython’ayazdırmaişleminiyapmadanöncekarakterdizimizdekikimekısımınıisim değişkeninindeğeriiledeğiştirmesigerektiğinisöyledik. format() fonksiyonumuz kendisine verdiğimiz değerleri kapsama alanı içerisinde uygun yerlere yerleştirir. Hatırlarsanız format() fonksiyonunu ilgilendiren kısımları süslü parantezleriniçineyazıyorduk.Yukarıdakiörneğişuşekildedeyapabiliriz: isim = ’Buğra’ print(’Selam {}!’.format(isim)) Bu sefer format() fonksiyonuna belirli bir yer göstermediğimiz için sırasıyla ilgili alanlara verdiğimiz parametreleri dolduracak. Zaten bir parametre ve bir alan olduğu için yukarıdaki örnekle aynı çıktıyı alacağız. format() fonksiyonunu bu kadar hatırlamak yeter, hadi f-string’leregeçelim! 379 PythonBelgeleri,Yayım4.1.3 21.1 Kullanım Stringnedirhepimizbiliyoruz,Türkçeyekarakterdizisiolarakçeviriyoruz.Buyapıyadaf-string diyoruz çünkü bu yapıyı kullanmak istediğimiz stringin (karakter dizisinin) başına f veya F ekliyoruz. Yani bir ön ek ekleyerek Python’a artık onun normal, sıradan bir karakter dizisi olmadığınıvebirönişlemdengeçmesigerektiğinibelirtiyoruz: "Selam Dünya!" # Normal bir karakter dizisi f"Selam Dünya!" # Bu artık bir f-string (cid:242) Not f-string’leri kullanabilmeniz için Python 3.6 ya da daha yeni bir sürüm kullanmamız gerektiğiniunutmayalım! Bu örnekte f-string’imizin normal bir karakter dizisinden farkı yok gibi görünüyor. Aslında şuanlık bir farkı yok. Çünkü biz f-string’in özelliklerini henüz kullanmadık. Yukarıda format() fonksiyonuiçinyazdığımızörneğibirdef-stringiçinyazalım: >>> isim = ’Buğra’ >>> print(f’Selam {isim}!’) Bu örneği de çalıştırdığınızda yukarıdaki örneklerin çıktılarıyla aynı çıktıyı verdiğini göreceksiniz. Ama çok daha düzenli bir görünümle elde ettik bu sefer aynı çıktıyı. format() fonksiyonunailgileneceğikısımları,işlemyapacağıkısımları,süslüparantezlerilebelirttiğimizi biliyoruz. f-string için de aynı şey geçerli ancak ufak bir farkla. Artık harici bir işlem yapılıp karakter dizimiz düzenlenmiyor, işlemler doğrudan karakter dizimiz içinde gerçekleştirilip yerinikendialıyor! Birörnekdahahazırlayalımveüzerindekonuşalım: >>> isim = ’Buğra’ >>> yas = 18 >>> f’Onun adı {isim} ve o {yas} yaşında.’ ’Onun adı Buğra ve o 18 yaşında.’ Aynıörneğiformat()fonksiyonuiledeyazıparasındakifarkabakalım: >>> isim = ’Buğra’ >>> yas = 18 >>> "Onun adı {} ve o {} yaşında.".format(isim, yas) ’Onun adı Buğra ve o 18 yaşında.’ Yukarıdaki kodu en basit haliyle değişken isimleri kullanmadan yazdım, yani değişkenleri sırasıyla ilgili yerlere yerleştirecek. Buna rağmen f-string örneğimizdekinden çok daha uzun olduveokunabilirlikazaldı. Aynızamandaf-string’leriniçindePythonişlemlerideyapabiliriz: >>> birinci_rakam = 5 >>> ikinci_rakam = 3 (sonrakisayfayadevam) 380 Bölüm21. f-string PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> f’Rakamların toplamı {birinci_rakam + ikinci_rakam} eder.’ ’Rakamların toplamı 8 eder.’ Hadisadecetoplamaişlemiyapanbirhesapmakinesiyapalım: birinci_sayi = int(input(’Birinci sayıyı girin: ’)) ikinci_sayi = int(input(’İkinci sayıyı girin: ’)) print(f’Sayıların toplamı {birinci_sayi + ikinci_sayi} eder.’) Kullanıcının girdiği sayıları toplayan bir hesap makinesi yaptık. Az önce f-string’lerin içinde Python kodu yazabildiğimizi öğrenmiştik. Bu bilgimizi de kullanıp bu basit programı daha güncelhalegetirelim: >>> f’Sayıların toplamı { int(input("Birinci sayıyı girin: ")) + int(input( "İkinci sayıyı girin: ")) } eder.’ ˓→ Birinci sayıyı girin: 10 İkinci sayıyı girin: 7 ’Sayıların toplamı 17 eder.’ Kullanıcıdangirdilerif-string’iniçindealarakteksatırlıkbirhesapmakinesiyazmışolduk. (cid:242) Not f-string’iniçindePythonkoduyazmakherzamaneniyiyololmayabilir. 21.2 f-string Formatlama Özellikleri f-string ifadelerinde süslü parantezler ({}) yazılan ifadenin bir operatörüdür. f-string içerisindesüslüparantezyazabilmekiçingenelkaçışkarakteriolanterseğikçizgi(\)yerine{ veya}parantezi2defaeklenir: >>> fstring = "f-string" >>> f"{{ {fstring}: f’{{ifade}}’ şeklinde kullanılır. }}" "{ f-string: f’{ifade}’ şeklinde kullanılır. }" Formatlanacakifadedensonra=işaretieklenerekdeğişkenadıilebirliktesahipolduğudeğerin reprhalieldeedilebilir.printiledebugedildiğidurumlardapratikbirşekildekullanılabilir: >>> kaynak = "Python " >>> yıl = "2022" >>> f"{kaynak=} {yıl=}" kaynak=’Python ’ yıl=’2022’ f-stringileformatlamayapılırkenyazılanifadedensonraeklenen:’dansonraekformatlama işlemlerigerçekleştirilebilir. string metodlarında anlatılan center, ljust, rjust, zfill metodlarının f-string içerisinde: işaretinden sonra karakter uzunluğu yazılarak, belirtilen karakter alanında hizalama 21.2. f-stringFormatlamaÖzellikleri 381 PythonBelgeleri,Yayım4.1.3 yapılabilir: >>> = "Python Istihza" >>> f"{:^30}" # "".center(30) ’ Python Istihza ’ ’ ’ >>> f"{:-^30}" # "".center(30, - ) ’--------Python Istihza--------’ >>> f"{:30}" # "".ljust(30) ’Python Istihza ’ >>> f"{:>30}" # "".just(30) ’ Python Istihza’ >>> f"{:>030}" # "".zfill(30) ’0000000000000000Python Istihza’ (cid:242) Not Etkileşimli kabuk (interactive shell) içinde çıktıları elde etmek için print kullanımasına ihtiyaçyoktur. f-stringve.formatiçingenelnotasyonşuşekildedir: [[dolgu_karakteri]hizalama][işaret][#][0][genişlik][grup_karakteri][. ondalık][veri_tıpı] ˓→ dolgu_karakteri : <her hangi bir karakter> hizalama : "<" | ">" | "^" | "=" işaret : "+" | "-" | " " (yalnızca sayı tipi) genişlik : pozitif sayı grup_karakteri : "_" | "," (yalnızca sayı tipi) ondalık : pozitif sayı (yalnızca sayı tipi) veri_tıpı : "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o " | "s" | "x" | "X" | "%" ˓→ Yukarıdaverilenörneklerdenbirinikısacaaçıklamakgerekirse: f"{:-^30}" dolgu_karakteri : - hizalama : ^ genişlik : 30 Sayıformatlamaörnekleri >>> sayı = 123 >>> f"{sayı:>6}" ’ 123’ >>> f"{sayı:0>+6}" ’00+123’ >>> f"{sayı:0=+6}" ’+00123’ >>> f"Binary: {sayı:b} | Octal: {sayı:o} | Hexadecimal: {sayı:x}" (sonrakisayfayadevam) 382 Bölüm21. f-string PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’Binary: 1111011 | Octal: 173 | Hexadecimal: 7b’ >>> f"Binary: {sayı:#b} | Octal: {sayı:#o} | Hexadecimal: {sayı:#x}" ’Binary: 0b1111011 | Octal: 0o173 | Hexadecimal: 0x7b’ >>> ondalık = 0.123 >>> f"{ondalık:.2f}" # f | F ondalık formatlama ’0.12’ >>> f"{ondalık:.5f}" ’0.12300’ >>> f"{ondalık:.5g}" # g | G fazla sıfırlar dahil edilmez ’0.123’ >>> sayı = 123456 >>> f"{sayı:_}" ’123_456’ >>> f"{sayı:-^15_}" ’----123_456----’ >>> f"{sayı:,}" ’123,456’ >>> işlem = 1 / 12 >>> f"{işlem:.2%}" # Sonucun 100 ile çarpılmış halini yüzde olarak çıktı␣ verir ˓→ ’8.33%’ Formatlamaiçinkullanılanoperatörlerdeğişkenilekullanılmasıdurumundadeğişkenlerin{} içineyazılmasıgerekmektedir. >>> selam = "Hello, World!" >>> hizalama = {"Sol": "<", "Orta": "^", "Sağ": ">"} >>> genişlik = 25 >>> for hiza, operatör in hizalama.items(): ... print(f"{hiza:>5}: ’{selam:{operatör}{genişlik}}’") ... Sol: ’Hello, World! ’ Orta: ’ Hello, World! ’ Sağ: ’ Hello, World!’ 21.2. f-stringFormatlamaÖzellikleri 383 22 BÖLÜM Listeler ve Demetler Bubölümegelenekadaryalnızcaikifarklıveritipigörmüştük.Bunlardanbirikarakterdizileri, öteki ise sayılardı. Ancak tabii ki Python’daki veri tipleri yalnızca bu ikisiyle sınırlı değildir. Python’dakarakterdizilerivesayılarındışında,başkaamaçlarahizmeteden,başkaveritipleri devardır.İştebizbubölümdeikifarklıveritipidahaöğreneceğiz.Bubölümdeelealacağımız veritiplerininadı‘liste’(list)ve‘demet’(tuple). Bu bölümde birer veri tipi olarak listeler ve demetlerden söz etmenin yanısıra liste ve demetlerin metotlarından da bahsedeceğiz. Listelerle demetleri öğrendikten sonra Python’dakihareketimkanınızınbirhayligenişlediğinetanıkolacaksınız. Python programlama diline yeni başlayan biri, karakter dizilerini öğrendikten sonra bu dilde her şeyi karakter dizileri yardımıyla halledebileceğini zannedebilir. O yüzden yeni bir veri tipi ile karşılaştığında (örneğin listeler veya demetler), bu yeni veri tipi ona anlamsız ve gereksizmiş gibi görünebilir. Aslında daha önce de söylediğimiz gibi, bir programlama dilini yeni öğrenenlerin genel sorunudur bu. Öğrenci, bir programlama dilini oluşturan minik parçalarıöğrenirken,öğrencininzihnibuparçalarınneişineyarayacağıkonusundaşüpheyle dolar. Sanki gereksiz şeylerle vakit kaybediyormuş gibi hissedebilir. En önemli ve en büyük programların, bu minik parçaların sistematik bir şekilde birleştirilmesiyle ortaya çıkacak olması öğrencinin kafasına yatmayabilir. Halbuki en karmaşık programların bile kaynak kodlarını incelediğinizde görecekleriniz karakter dizileri, listeler, demetler, sayılar ve buna benzer başka veri tiplerinden ibarettir. Nasıl en lezzetli yemekler birkaç basit malzemenin bir araya gelmesi ile ortaya çıkıyorsa, en abidevi programlar da ilk bakışta birbiriyle ilgisiz görünençokbasitparçalarıninceliklibirşekildebirleştirilmesindenoluşur. O halde bu noktada, Python programlama diline yeni başlayan hemen herkesin sorduğu o soruyu soralım kendimize: ‘Neden farklı veri tipleri var? Bu veri tiplerinin hepsine gerçekten ihtiyacımolacakmı?’ Busoruyubaşkabirsoruylacevaplamayaçalışalım:‘Acabanedenfarklıgiysitiplerivar?Neden kot pantolon, kumaş pantolon, tişört, gömlek ve buna benzer ayrımlara ihtiyaç duyuyoruz?’ Busorununcevabıçokbasit:‘Çünküfarklıdurumlarafarklıgiysitürleriuygundur!’ Örneğin ev taşıyacaksanız, herhalde kumaş pantolon ve gömlek giymezsiniz üzerinize. Buna benzer bir şekilde iş görüşmesine giderken de kot pantolon ve tişört doğru bir tercih 384 PythonBelgeleri,Yayım4.1.3 olmayabilir. İşte buna benzer sebeplerden, programlama dillerinde de belli durumlarda belli veri tiplerini kullanmanız gerekir. Örneğin bir durumda karakter dizilerini kullanmak uygunken, başka bir durumda listeleri veya demetleri kullanmak daha mantıklı olabilir. Zira herveritipininkendinehasgüçlüvezayıfyanlarıvardır.Veritiplerinivebunlarınayrıntılarını öğrendikçe,hangiveritipininhangisoruniçindahakullanışlıolduğunukestirebilecekduruma geleceğinizdenhiçkuşkunuzolmasın. Bizbubölümdelistelerivedemetleriolabildiğinceayrıntılıbirşekildeinceleyeceğiz.Oyüzden buveritipleriniincelerkenkonuyubirkaçfarklıbölümeayıracağız. Listelerivedemetleriincelemeyelistelerdenbaşlayalım... 22.1 Listeler Giriş bölümünde de değindiğimiz gibi, listeler Python’daki veri tiplerinden biridir. Tıpkı karakterdizilerivesayılargibi... 22.1.1 Liste Tanımlamak Listeleritanımaya,buveritipininasıltanımlayacağımızıöğrenerekbaşlayalım. Hatırlarsanızbirkarakterdizisitanımlayabilmekiçinşöylebiryolizliyorduk: >>> kardiz = "karakter dizisi" Yani herhangi bir öğeyi karakter dizisi olarak tanımlayabilmek için yapmamız gereken tek şey o öğeyi tırnak içine almaktı. Herhangi bir öğeyi (tek, çift veya üç) tırnak içine aldığımızda karakterdizimizitanımlamışoluyoruz.Listetanımlamakiçindebunabenzerbirşeyyapıyoruz. Dikkatlicebakın: >>> liste = ["öğe1", "öğe2", "öğe3"] Gördüğünüz gibi, liste tanımlamak da son derece kolay. Bir liste elde etmek için, öğeleri birbirindenvirgülleayırıp,bunlarınhepsiniköşeliparantezleriçinealıyoruz. Karakter dizilerini anlatırken, herhangi bir nesnenin karakter dizisi olup olmadığından emin olmak için type() fonksiyonundan yararlanabileceğimizi söylemiştik. Eğer bir nesne type() fonksiyonuna<class‘str’>cevabıveriyorsaonesnebirkarakterdizisidir.Listeleriçindebuna benzerbirsorgulamayapabiliriz: >>> liste = ["öğe1", "öğe2", "öğe3"] >>> type(liste) <class ’list’> Bu çıktıdan anlıyoruz ki, liste veri tipi type() fonksiyonuna <class ‘list’> cevabı veriyor. Dolayısıyla, eğer bir nesne type() fonksiyonuna <class ‘list’> cevabı veriyorsa o nesnenin bir listeolduğunurahatlıklasöyleyebiliriz. Yukarıda tanımladığımız liste adlı listeye baktığımızda dikkatimizi bir şey çekiyor olmalı. Bu listeye şöyle bir baktığımızda, aslında bu listenin, içinde üç adet karakter dizisi barındırdığını görüyoruz.Gerçektendelisteler,birveyadahafazlaveritipiniiçindebarındırankapsayıcıbir veritipidir.Meselaşulisteyebirbakalım: 22.1. Listeler 385 PythonBelgeleri,Yayım4.1.3 >>> liste = ["Ahmet", "Mehmet", 23, 65, 3.2] Gördüğünüz gibi, liste içinde hem karakter dizileri (“Ahmet”, “Mehmet”), hem de sayılar (23, 65,3.2)var. Dahası,listeleriniçindebaşkalistelerdebulunabilir: >>> liste = ["Ali", "Veli", ["Ayşe", "Nazan", "Zeynep"], 34, 65, 33, 5.6] Bulisteadlıdeğişkenintipinisorgularsakşöylebirçıktıalacağımızıbiliyorsunuz: >>> type(liste) <class ’list’> Birdeşunudeneyelim: for öğe in liste: print("{} adlı öğenin veri tipi: {}".format(öğe, type(öğe))) Bukodlarıçalıştırdığımızdadaşöylebirçıktıalıyoruz: Ali adlı öğenin veri tipi: <class ’str’> Veli adlı öğenin veri tipi: <class ’str’> [’Ayşe’, ’Nazan’, ’Zeynep’] adlı öğenin veri tipi: <class ’list’> 34 adlı öğenin veri tipi: <class ’int’> 65 adlı öğenin veri tipi: <class ’int’> 33 adlı öğenin veri tipi: <class ’int’> 5.6 adlı öğenin veri tipi: <class ’float’> Bukodlarbizeşunugösteriyor:Farklıöğeleribirarayagetiripbunlarıköşeliparantezleriçine alırsak ‘liste’ adlı veri tipini oluşturmuş oluyoruz. Bu listenin öğeleri farklı veri tiplerine ait olabilir. Yukarıdaki kodların da gösterdiği gibi, liste içinde yer alan “Ali” ve “Veli” öğeleri birer karakterdizisi;[‘Ayşe’,‘Nazan’,‘Zeynep’]adlıöğebirliste;34,65ve33öğeleribirertamsayı;5.6 öğesiisebirkayannoktalısayıdır.İştefarklıveritiplerineaitbuöğelerinhepsibirarayagelerek listedenenveritipinioluşturuyor.Yukarıdakiörnektendegördüğünüzgibi,birlisteniniçinde başka bir liste de yer alabiliyor. Örneğin burada listemizin öğelerinden biri, [‘Ayşe’, ‘Nazan’, ‘Zeynep’]adlıbaşkabirlistedir. Hatırlarsanızkarakterdizilerininbelirleyiciözelliğitırnakişaretleriidi.Yukarıdakiörneklerden degördüğünüzgibilistelerinbelirleyiciözelliğideköşeliparantezlerdir.Mesela: >>> karakter = "" Buboşbirkarakterdizisidir.Şuiseboşbirliste: >>> liste = [] Tıpkıkarakterdizilerindeolduğugibi,listelerledeikişekildekarşılaşabilirsiniz: 1. Listeyikendiniztanımlamışolabilirsiniz. 2. Listesizebaşkabirkaynaktangelmişolabilir. 386 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 Yukarıdakiörneklerdebirlisteyikendimizinnasıltanımlayacağımızıöğrendik.Pekilistelerbize başkahangikaynaktangelebilir? Hatırlarsanız karakter dizilerinin metotlarını sıralamak için dir() adlı bir fonksiyondan yararlanmıştık. Mesela karakter dizilerinin bize hangi metotları sunduğunu görmek için bu fonksiyonu şöyle kullanmıştık: >>> dir(str) Bukomutbizeşuçıktıyıvermişti: [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__getnewargs__’, ’__gt__’, ’__hash__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mod__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rmod__’, ’__rmul__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’capitalize’, ’center’, ’count’, ’encode’, ’endswith’, ’expandtabs’, ’find’, ’format’, ’format_map’, ’index’, ’isalnum’, ’isalpha’, ’isdecimal’, ’isdigit’, ’isidentifier’, ’islower’, ’isnumeric’, ’isprintable’, ’isspace’, ’istitle’, ’isupper’, ’join’, ’ljust’, ’lower’, ’lstrip’, ’maketrans’, ’partition’, ’replace’, ’rfind’, ’rindex’, ’rjust’, ’rpartition’, ’rsplit’, ’rstrip’, ’split’, ’splitlines’, ’startswith’, ’strip’, ’swapcase’, ’title’, ’translate’, ’upper’, ’zfill’] Artıkbuçıktısizeçokdahaanlamlıgeliyorolmalı.Gördüğünüzgibiçıktımızköşeliparantezler arasında yer alıyor. Yani aslında yukarıdaki çıktı bir liste. Dilerseniz bunu nasıl teyit edebileceğinizibiliyorsunuz: >>> komut = dir(str) >>> type(komut) <class ’list’> Gördüğünüz gibi, tıpkı input() fonksiyonundan gelen verinin bir karakter dizisi olması gibi, dir()fonksiyonundangelenveritipidebirlistedir. dir() fonksiyonu dışında, başka bir şeyin daha bize liste verdiğini biliyoruz. Bu şey, karakter dizilerininsplit()adlımetodudur: >>> kardiz = "İstanbul Büyükşehir Belediyesi" >>> kardiz.split() [’İstanbul’, ’Büyükşehir’, ’Belediyesi’] Görüyorsunuz, split() metodunun çıktısı da köşeli parantezler içinde yer alıyor. Demek ki buçıktıdabirlistedir. Peki bir fonksiyonun bize karakter dizisi mi, liste mi yoksa başka bir veri tipi mi verdiğini bilmeninnefaydasıvar? Her zaman söylediğimiz gibi, Python’da o anda elinizde olan verinin tipini bilmeniz son dereceönemlidir.Aksihaldeoveriyinasıleviripçevireceğinizi,overiyleneleryapabileceğinizi 22.1. Listeler 387 PythonBelgeleri,Yayım4.1.3 bilemezsiniz.Mesela‘İstanbulBüyükşehirBelediyesi’ifadesinielealalım.Buifadeyleilgilisize şöylebirsorusorduğumudüşünün:‘Acababuifadeninilkharfininasılalırız?’ Eğer bu ifade size input() fonksiyonundan gelmişse, yani bir karakter dizisiyse uygulayacağınız yöntem farklı, split() metoduyla gelmişse, yani liste ise uygulayacağınız yöntemfarklıolacaktır. Eğerbuifadebirkarakterdizisiiseilkharfişuşekildealabilirsiniz: >>> kardiz = "İstanbul Büyükşehir Belediyesi" >>> kardiz[0] ’İ’ Amaeğerbuifadebirlisteiseyukarıdakiyöntemsizefarklıbirsonuçverir: >>> liste = kardiz.split() >>> liste[0] ’İstanbul’ Çünkü “İstanbul Büyükşehir Belediyesi” adlı karakter dizisinin ilk öğesi “İ” karakteridir, ama [‘İstanbul’, ‘Büyükşehir’, ‘Belediyesi’] adlı listenin ilk öğesi “İ” karakteri değil, “İstanbul” kelimesidir. Gördüğünüz gibi, bir nesnenin hangi veri tipine ait olduğunu bilmek o nesneyle neleri nasıl yapabileceğimizi doğrudan etkiliyor. O yüzden programlama çalışmalarınız esnasında veri tiplerinekarşıherzamanuyanıkolmalısınız. (cid:242) Not Python’da bir nesnenin hangi veri tipine ait olduğunu bilmenin neden bu kadar önemli olduğunu gerçek bir örnek üzerinde görmek isterseniz .com/forum/viewtopic.php?f=43&t=6223 (arşiv linki) adresindeki tartışmayı inceleyebilirsiniz. Hernekadarkarakterdizilerivelistelerikifarklıveritipiolsavebuikiveritipininbirbirinden çokfarklıyönleriveyetenekleriolsada,buikiveritipiarasındaönemlibenzerliklerdevardır. Örneğin karakter dizilerini işlerken öğrendiğimiz pek çok fonksiyonu listelerle birlikte de kullanabilirsiniz.Meselakarakterdizileriniincelerkenöğrendiğimizlen()fonksiyonulistelerin boyutunuhesaplamadadakullanılabilir: >>> diller = ["İngilizce", "Fransızca", "Türkçe", "İtalyanca", "İspanyolca"] >>> len(diller) 5 Karakterdizilerikarakterlerdenoluşanbirveritipiolduğuiçinlen()fonksiyonukarakterdizisi içindekikarakterlerinsayısınıveriyor.Listelerisebaşkaveritiplerinibirarayatoplayanbirveri tipiolduğuiçinlen()fonksiyonulisteiçindekiveritiplerininsayısınısöylüyor. 23https://web.archive.org/web/20161124155954/http://www..com/forum/viewtopic.php?f=43&t=62 388 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 len() fonksiyonu dışında, range() fonksiyonuyla listeleri de birlikte kullanabilirsiniz. Mesela herhangibirkaynaktansizeşunlargibiikiöğelilistelergeliyorolabilir: [0, 10] [6, 60] [12, 54] [67, 99] Buikiöğelilisteleritekbirlisteiçindetopladığımızıdüşünürsekşöylebirkodyazabiliriz: sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]] for i in sayılar: print(*range(*i)) Eğer ilk bakışta bu kod gözünüze anlaşılmaz göründüyse bu kodu parçalara ayırarak inceleyebilirsiniz. Burada öncelikle bir for döngüsü oluşturduk. Bu sayede sayılar adlı listedeki öğelerin üzerinden tek tek geçebileceğiz. Eğer döngü içinde sadece öğeleri ekrana yazdırıyor olsaydık şöylebirkodumuzolacaktı: for i in sayılar: print(i) Bukodbizeşöylebirçıktıverecektir: [0, 10] [6, 60] [12, 54] [67, 99] range() fonksiyonunun nasıl kullanıldığını hatırlıyorsunuz. Yukarıdaki listelerde görünen ilk sayılarrange()fonksiyonununilkparametresi,ikincisayılariseikinciparametresiolacak.Yani herdöngüdeşöylebirşeyeldeetmemizgerekiyor: range(0, 10) range(6, 60) range(12, 54) range(67, 99) Aslındakodlarımızışöyleyazarakyukarıdakiçıktıyıeldeedebilirdik: sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]] for i in sayılar: print(range(i[0], i[1])) Yukarıdaki açıklamalarda gördüğünüz gibi, i değişkeninin çıktısı ikişer öğeli bir liste oluyor. İşte burada yaptığımız şey, bu ikişer öğeli listelerin ilk öğesini (i[0]) range() fonksiyonunun ilk parametresi, ikinci öğesini (i[1]) ise range() fonksiyonunun ikinci parametresi olarak atamaktan ibaret. Ancak ilk derslerimizden hatırlayacağınız gibi, bunu yapmanın daha kısa 22.1. Listeler 389 PythonBelgeleri,Yayım4.1.3 bir yolu var. Bildiğiniz gibi, öğelerden oluşan dizileri ayrıştırmak için yıldız işaretinden yararlanabiliyoruz.Dolayısıylayukarıdakikodlarışöyleyazmakdahapratikolabilir: sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]] for i in sayılar: print(range(*i)) Gördüğünüz gibi, i değişkeninin soluna bir yıldız ekleyerek bu değişken içindeki değerleri ayrıştırdıkveşöylebirçıktıeldeettik: range(0, 10) range(6, 60) range(12, 54) range(67, 99) Hatırlarsanız, range(0, 10) gibi bir kod yazdığımızda Python bize 0 ile 10 arasındaki sayıları doğrudan göstermiyordu. Aralıktaki sayıları görmek için range() fonksiyonunun çıktısını bir döngüiçinealmalıyız: for i in range(0, 10): print(i) range(0, 10) çıktısını görmek için döngü kurmak yerine yine yıldız işaretinden yararlanabiliyoruz.Örneğin: >>> print(*range(0, 10)) 0 1 2 3 4 5 6 7 8 9 Aynışeyiyukarıdakikodlaradauygularsakşöylebirşeyeldeederiz: sayılar = [[0, 10], [6, 60], [12, 54], [67, 99]] for i in sayılar: print(*range(*i)) Gördüğünüz gibi, yıldız işaretini hem i değişkenine, hem de range() fonksiyonuna ayrı ayrı uygulayarakistediğimizsonucueldeettik. Buarada,yukarıdakiörnekbizelistelerhakkındaönemlibirbilgideverdi.Karakterdizilerinin öğelerine erişmek için nasıl kardiz[öğe_sırası] gibi bir formülden yararlanıyorsak, listelerin öğelerine erişmek için de aynı şekilde liste[öğe_sırası] gibi bir formülden yararlanabiliyoruz. Listelerin öğelerine nasıl ulaşacağımızın ayrıntılarını biraz sonra göreceğiz. Ama biz şimdi listelereilişkinönemlibirfonksiyonuinceleyerekyolumuzadevamedelim. 390 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 22.1.2 list() Fonksiyonu Yukarıdaki örneklerden de gördüğünüz gibi liste oluşturmak için öğeleri belirleyip bunları köşeli parantezler içine almamız yeterli oluyor. Bu yöntemin dışında, liste oluşturmanın bir yöntemidahabulunur.Meselaelimizdeşöylebirkarakterdizisiolduğunudüşünelim: >>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz" Sorumuzşuolsun:‘Acababukarakterdizisinilisteyenasılçeviririz?’ Karakter dizilerini anlatırken split() adlı bir metottan söz etmiştik. Bu metot karakter dizilerini belli bir ölçüte göre bölmemizi sağlıyordu. split() metoduyla elde edilen verinin birlisteolduğunubiliyorsunuz.Örneğin: >>> isimler = "ahmet mehmet cem" >>> isimler.split() [’ahmet’, ’mehmet’, ’cem’] Ancak split() metodunun bir karakter dizisini bölüp bize bir liste verebilmesi için karakter dizisininbellibirölçütegörebölünebilirdurumdaolmasıgerekiyor.Meselayukarıdakiisimler adlıkarakterdizisibellibirölçütegörebölünebilirdurumdadır.Neden?Çünkükarakterdizisi içindeki her parça arasında bir boşluk karakteri var. Dolayısıyla split() metodu bu karakter dizisiniboşluklardanbölebiliyor.Aynışeyşukarakterdizisiiçindegeçerlidir: >>> isimler = "elma, armut, çilek" Bu karakter dizisini oluşturan her bir parça arasında bir adet virgül ve bir adet boşluk karakterivar.Dolayısıylabizbukarakterdizisinisplit()metodunukullanarak“virgül+boşluk karakteri”ölçütünegörebölebiliriz: >>> isimler.split(", ") [’elma’, ’armut’, ’çilek’] Ancakbölümünbaşındatanımladığımızalfabeadlıkarakterdizisibirazfarklıdır: >>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz" Gördüğünüzgibi,bukarakterdizisitekbirparçadanoluşuyor.Dolayısıylabukarakterdizisini öğelerinebölmemizisağlayacakbirölçütyok.Yanibukarakterdizisinişuşekildebölemeyiz: >>> alfabe.split() [’abcçdefgğhıijklmnoöprsştuüvyz’] Elbettebukarakterdizisiniistersenizfarklışekillerdebölebilirsiniz.Mesela: >>> alfabe.split("i") [’abcçdefgğhı’, ’jklmnoöprsştuüvyz’] 22.1. Listeler 391 PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,bizburadaalfabekarakterdizisini“i”harfindenbölebildik.Amaistediğimiz şeybudeğil.Bizaslındaşöylebirçıktıeldeetmekistiyoruz: [’a’, ’b’, ’c’, ’ç’, ’d’, ’e’, ’f’, ’g’, ’ğ’, ’h’, ’ı’, ’i’, ’j’, ’k’, ’l’, ’m’, ’n’, ’o’, ’ö’, ’p’, ’r’, ’s’, ’ş’, ’t’, ’u’, ’ü’, ’v’, ’y’, ’z’] Yani bizim amacımız, alfabe karakter dizisi içindeki her bir öğeyi birbirinden ayırmak. İşte Türk alfabesindeki harflerden oluşan bu karakter dizisini, list() adlı bir fonksiyondan yararlanarakistediğimizşekildebölebiliriz: >>> harf_listesi = list(alfabe) >>> print(harf_listesi) [’a’, ’b’, ’c’, ’ç’, ’d’, ’e’, ’f’, ’g’, ’ğ’, ’h’, ’ı’, ’i’, ’j’, ’k’, ’l’, ’m’, ’n’, ’o’, ’ö’, ’p’, ’r’, ’s’, ’ş’, ’t’, ’u’, ’ü’, ’v’, ’y’, ’z’] Böylecelist()fonksiyonuyardımıylabukarakterdizisinitekhamledelisteyeçevirmişolduk. Peki bir karakter dizisini neden listeye çevirme ihtiyacı duyarız? Şu anda listelerle ilgili pek çok şeyi henüz bilmediğimiz için ilk bakışta bu çevirme işlemi gözünüze gereksizmiş gibi görünebilir, ama ilerleyen zamanda sizin de göreceğiniz gibi, bazı durumlarda listeleri manipüleetmekkarakterdizilerinimanipüleetmeyekıyaslaçokdahakolaydır.Oyüzdenkimi zamankarakterdizilerinilisteyeçevirmekdurumundakalabilirsiniz. list() fonksiyonunun yaptığı işi, daha önce öğrendiğimiz str(), int() ve float() fonksiyonlarının yaptığı işle kıyaslayabilirsiniz. list() fonksiyonu da tıpkı str(), int() ve float() fonksiyonları gibi bir dönüştürme fonksiyonudur. Örneğin int() fonksiyonunu kullanaraksayıdeğerlikarakterdizilerinisayıyadönüştürebiliyoruz: >>> k = "123" >>> int(k) 123 Bu dönüştürme işlemi sayesinde sayılar üzerinde aritmetik işlem yapma imkanımız olabiliyor. İşte list() fonksiyonu da buna benzer bir amaca hizmet eder. Mesela input() fonksiyonundangelenbirkarakterdizisiiletoplamaçıkarmayapabilmekiçinnasılbukarakter dizisini önce sayıya dönüştürmemiz gerekiyorsa, bazı durumlarda bu karakter dizisini (veya başkaveritiplerini)listeyeçevirmemizdegerekebilir.Böylebirdurumdalist()fonksiyonunu kullanarakfarklıveritiplerinirahatlıklalisteyeçevirebiliriz. Yukarıdakiişlevlerinindışında,list()fonksiyonuboşbirlisteoluşturmakiçindekullanılabilir: >>> li = list() >>> print(li) [] Yukarıdaki kodlardan gördüğünüz gibi, boş bir liste oluşturmak için liste = [] koduna alternatifolaraklist()fonksiyonundandayararlanabilirsiniz. list() fonksiyonunun önemli bir görevi de range() fonksiyonunun, sayı aralığını ekrana 392 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 basmasınısağlamaktır.Bildiğinizgibi,range()fonksiyonutekbaşınabirsayıaralığınıekrana dökmez.Bufonksiyonbizeyalnızcaşöylebirçıktıverir: >>> range(10) range(0, 10) Busayıaralığınıekranadökmekiçinrange()fonksiyonuüzerindebirfordöngüsükurmamız gerekir: >>> for i in range(10): ... print(i) ... 0 1 2 3 4 5 6 7 8 9 Bubölümdeverdiğimizörneklerdeaynıişişöyledeyapabileceğimiziöğrenmiştik: >>> print(*range(10)) 0 1 2 3 4 5 6 7 8 9 Bugöreviyerinegetirmeninüçüncübiryoludalist()fonksiyonunukullanmaktır: >>> list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Aslında burada yaptığımız şey range(10) ifadesini bir listeye dönüştürmekten ibarettir. Buradarangetüründebirveriyilisttüründebirveriyedönüştürüyoruz: >>> type(range(10)) <class ’range’> >>> li = list(range(10)) >>> type(li) <class ’list’> Gördüğünüz gibi, yukarıdaki üç yöntem de aralıktaki sayıları ekrana döküyor. Yalnız dikkat ederseniz bu üç yöntemin çıktıları aslında görünüş olarak birbirlerinden ince farklarla ayrılıyor. Yazdığınız programda nasıl bir çıktıya ihtiyacınız olduğuna bağlı olarak yukarıdaki yöntemlerdenherhangibirinitercihedebilirsiniz. 22.1. Listeler 393 PythonBelgeleri,Yayım4.1.3 Böylece Python’da listelerin ne olduğunu ve bu veri tipinin nasıl oluşturulacağını öğrenmiş olduk.Ohaldebiradımdahaataraklistelerinbaşkaözelliklerinedeğinelim. 22.1.3 Listelerin Öğelerine Erişmek Tıpkı karakter dizilerinde olduğu gibi, listelerde de her öğenin bir sırası vardır. Hatırlarsanız karakterdizilerininöğelerineşuşekildeulaşıyorduk: >>> kardiz = "python" >>> kardiz[0] ’p’ Bu bölümdeki birkaç örnekte de gördüğünüz gibi, listelerin öğelerine ulaşırken de aynı yöntemikullanabiliyoruz: >>> meyveler = ["elma", "armut", "çilek", "kiraz"] >>> meyveler[0] ’elma’ Yalnız yöntem aynı olsa da yukarıdaki iki çıktı arasında bazı farklar olduğunu da gözden kaçırmayın.Birkarakterdizisinin0.öğesinialdığımızdaokarakterdizisininilkkarakterinialmış oluyoruz.Birlistenin0.öğesinialdığımızdaiseolisteninilköğesinialmışoluyoruz. Sayma yöntemi olarak ise karakter dizileri ve listelerde aynı mantık geçerli. Hem listelerde hem de karakter dizilerinde Python saymaya 0’dan başlıyor. Yani karakter dizilerinde olduğu gibi,listelerdedeilköğeninsırası0. Eğer bu listenin öğelerinin hepsine tek tek ulaşmak isterseniz for döngüsünden yararlanabilirsiniz: meyveler = ["elma", "armut", "çilek", "kiraz"] for meyve in meyveler: print(meyve) Bulistedekiöğelerinumaralandırmakdamümkün: meyveler = ["elma", "armut", "çilek", "kiraz"] for öğe_sırası in range(len(meyveler)): print("{}. {}".format(öğe_sırası, meyveler[öğe_sırası])) ...veyaenumerate()fonksiyonunukullanarakşöylebirşeydeyazabiliriz: for sıra, öğe in enumerate(meyveler, 1): print("{}. {}".format(sıra, öğe)) Dediğimiz gibi, liste öğelerine ulaşmak için kullandığımız yöntem, karakter dizilerinin öğelerine ulaşmak için kullandığımız yöntemle aynı. Aslında karakter dizileri ile listeler arasındakibenzerlikbununlasınırlıdeğildir.Benzerlikleribirkaçörneküzerindegösterelim: 394 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 >>> meyveler = ["elma", "armut", "çilek", "kiraz"] >>> meyveler[-1] ’kiraz’ Karakter dizilerinde olduğu gibi, öğe sırasını eksi değerli bir sayı yaptığımızda liste öğeleri sondan başa doğru okunuyor. Dolayısıyla meyveler[-1] komutu bize meyveler adlı listenin sonöğesiniveriyor. >>> meyveler[0:2] [’elma’, ’armut’] Karakter dizileri konusunu işlerken öğrendiğimiz dilimleme yöntemi listeler için de aynen geçerlidir. Orada öğrendiğimiz dilimleme kurallarını listelere de uygulayabiliyoruz. Örneğin listeöğelerinitersçevirmekiçinşöylebirkodyazabiliyoruz: >>> meyveler[::-1] [’kiraz’, ’çilek’, ’armut’, ’elma’] Bu bölümün başında da söylediğimiz gibi, liste adlı veri tipi, içinde başka bir liste de barındırabilir.Bunaşöylebirörnekvermiştik: >>> liste = ["Ali", "Veli", ["Ayşe", "Nazan", "Zeynep"], 34, 65, 33, 5.6] Bulistedekiöğelerşunlardır: Ali Veli [’Ayşe’, ’Nazan’, ’Zeynep’] 34 65 33 5.6 Gördüğünüz gibi, bu liste içinde [‘Ayşe’, ‘Nazan’, ‘Zeynep’] gibi bir liste daha var. Bu liste ana listeninöğelerindenbiridirvebudaötekiöğelergibiteköğelikbiryerkaplar.Yani: >>> len(liste) 7 Bu çıktıdan anlıyoruz ki, listemiz toplam 7 öğeden oluşuyor. Listenin 2. sırasında yer alan listenin kendisi üç öğeden oluştuğu halde bu öğe ana liste içinde sadece tek öğelik bir yer kaplıyor.Yani2.sıradakilisteninöğeleritekteksayılmıyor.Pekiböylebirlisteiçindekigömülü listeninöğelerinieldeetmekistersekneyapacağız?Yanimeselaiçegeçmişlistenintamamını değil de, örneğin sadece “Ayşe” öğesini almak istersek ne yapmamız gerekiyor? Dikkatlice bakın: 22.1. Listeler 395 PythonBelgeleri,Yayım4.1.3 >>> liste[2][0] ’Ayşe’ “Nazan”öğesinialmakiçin: >>> liste[2][1] ’Nazan’ “Zeynep”öğesinialmakiçin: >>> liste[2][2] ’Zeynep’ Gördüğünüz gibi, iç içe geçmiş listelerin öğelerini almak oldukça basit. Yapmamız gereken tekşey,gömülülisteninönceanalistedekikonumunu,ardındandaalmakistediğimizöğenin gömülülistedekikonumunubelirtmektir. İstersekgömülülisteyiayrıbirlisteolarakdaalabiliriz: >>> yeni_liste = liste[2] >>> yeni_liste [’Ayşe’, ’Nazan’, ’Zeynep’] Böylecebulisteninöğelerinenormalbirşekildeulaşabiliriz: >>> yeni_liste[0] ’Ayşe’ >>> yeni_liste[1] ’Nazan’ >>> yeni_liste[2] ’Zeynep’ Eğerbirlisteninöğelerineerişmeyeçalışırken,varolmayanbirsırasayısıbelirtirsenizPython sizebirhatamesajıgösterecektir: >>> liste = range(10) >>> print(len(liste)) 10 Burada range() fonksiyonundan yararlanarak 10 öğeli bir liste tanımladık. Bu listenin son öğesininşuformülegörebulunabileceğinikarakterdizilerikonusundanhatırlıyorolmalısınız: 396 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 >>> liste[len(liste)-1] 9 Demekkibulisteninsonöğesi9sayısıimiş... Birdeşunudeneyelim: >>> liste[10] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: range object index out of range Gördüğünüzgibi,listemizde10.öğediyebirşeyolmadığıiçinPythonbizeIndexErrortipinde birhatamesajıgösteriyor.Çünkübulisteninsonöğesininsırasılen(liste)-1,yani9’dur. 22.1.4 Listelerin Öğelerini Değiştirmek Hatırlarsanız karakter dizilerinden söz ederken bunların değiştirilemez (immutable) bir veri tipi olduğunu söylemiştik. Bu özellikten ötürü, bir karakter dizisi üzerinde değişiklik yapmak istediğimizdeokarakterdizisiniyenidenoluşturuyoruz.Örneğin: >>> kardiz = "" >>> kardiz = "İ" + kardiz[1:] >>> kardiz ’’ Listeler ise değiştirilebilen (mutable) bir veri tipidir. Dolayısıyla listeler üzerinde doğrudan değişiklik yapabiliriz. Bir liste üzerinde değişiklik yapabilmek için o listeyi yeniden tanımlamamızagerekyok.Şuörneğidikkatliceinceleyin: >>> renkler = ["kırmızı", "sarı", "mavi", "yeşil", "beyaz"] >>> print(renkler) [’kırmızı’, ’sarı’, ’mavi’, ’yeşil’, ’beyaz’] >>> renkler[0] = "siyah" >>> print(renkler) [’siyah’, ’sarı’, ’mavi’, ’yeşil’, ’beyaz’] Liste öğelerini nasıl değiştirdiğimize çok dikkat edin. Yukarıdaki örnekte renkler adlı listenin 0.öğesinideğiştirmekistiyoruz.Bununiçinşöylebirformülkullandık: renkler[öğe_sırası] = yeni_öğe Örnekolmasıaçısından,aynılistenin2.sırasındaki“mavi”adlıöğeyi“mor”yapalımbirde: >>> renkler[2] = "mor" >>> print(renkler) (sonrakisayfayadevam) 22.1. Listeler 397 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) [’siyah’, ’sarı’, ’mor’, ’yeşil’, ’beyaz’] Gördüğünüz gibi, listeler üzerinde değişiklik yapmak son derece kolay. Sırf bu özellik bile, neden bazı durumlarda listelerin karakter dizileri yerine tercih edilebileceğini gösterecek güçtedir. Liste öğelerini değiştirmeye çalışırken, eğer var olmayan bir sıra numarasına atıfta bulunursanızPythonsizeIndexErrortipindebirhatamesajıgösterecektir: >>> renkler[10] = "pembe" Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list assignment index out of range Sıranumaralarınıkullanaraklistelerüzerindedahailginçişlemlerdeyapabilirsiniz.Meselaşu örneğebakın: >>> liste = [1, 2, 3] >>> liste[0:len(liste)] = 5, 6, 7 >>> print(liste) [5, 6, 7] Buradalisteadlılisteninbütünöğelerinibirçırpıdadeğiştirdik.Pekibununasılyaptık? Yukarıdakiörneğişuşekildeyazarsakbirazdahaaçıklayıcıolabilir: >>> liste[0:3] = 5, 6, 7 Bukodlarlayaptığımızşey,listenin0.ve3.öğesiarasındakalanbütünöğelerinyerine5,6ve 7öğeleriniyerleştirmektenibarettir. Karakterdizilerindenhatırlayacağınızgibi,eğersıranumarasıbirkarakterdizisininilköğesine karşılık geliyorsa o sıra numarasını belirtmeyebiliriz. Aynı şekilde eğer sıra numarası bir karakterdizisininsonöğesinekarşılıkgeliyorsaosıranumarasınıdabelirtmeyebiliriz.Bukural listeleriçindegeçerlidir.Dolayısıylayukarıdakiörneğişöyledeyazabilirdik: >>> liste[:] = 5, 6, 7 Sıra numaralarını kullanarak gerçekten son derece enteresan işlemler yapabilirsiniz. Sıra numaraları ile neler yapabileceğinizi görmek için kendi kendinize ve hayal gücünüzü zorlayarakbazıdenemeleryapmanızıtavsiyeederim. 398 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 22.1.5 Listeye Öğe Eklemek Listeler büyüyüp küçülebilen bir veri tipidir. Yani Python’da bir listeye istediğiniz kadar öğe ekleyebilirsiniz.Diyelimkielimizdeşöylebirlistevar: >>> liste = [2, 4, 5, 7] Bulisteyeyenibiröğeekleyebilmekiçinşöylebirkodyazabiliriz: >>> liste + [8] [2, 4, 5, 7, 8] Bu örnek, bize listeler hakkında önemli bir bilgi veriyor. Python’da + işareti kullanarak bir listeye öğe ekleyecekseniz, eklediğiniz öğenin de liste olması gerekiyor. Mesela bir listeye doğrudankarakterdizileriniveyasayılarıekleyemezsiniz: >>> liste + 8 Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can only concatenate list (not "int") to list >>> liste + "8" Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can only concatenate list (not "str") to list Listelere + işareti ile ekleyeceğiniz öğelerin de bir liste olması gerekiyor. Aksi halde Python bizebirhatamesajıgösteriyor. 22.1.6 Listeleri Birleştirmek Bazıdurumlardaelinizefarklıkaynaklardanfarklılistelergelebilir.Böylebirdurumdabufarklı listeleri tek bir liste halinde birleştirmeniz gerekebilir. Tıpkı karakter dizilerinde olduğu gibi, listelerdedebirleştirmeişlemleriiçin+işlecindenyararlanabilirsiniz. Diyelimkielimizdeşöyleikiadetlistevar: >>> derlenen_diller = ["C", "C++", "C#", "Java"] >>> yorumlanan_diller = ["Python", "Perl", "Ruby"] Buikifarklılisteyitekbirlistehalinegetirmekiçinşöylebirkodyazabiliriz: >>> programlama_dilleri = derlenen_diller + yorumlanan_diller [’C’, ’C++’, ’C#’, ’Java’, ’Python’, ’Perl’, ’Ruby’] Buişleminsonucunugörelim: 22.1. Listeler 399 PythonBelgeleri,Yayım4.1.3 >>> print(programlama_dilleri) Gördüğünüz gibi, derlenen_diller ve yorumlanan_diller adlı listelerin öğelerini programlama_dilleriadlıtekbirlisteiçindetopladık. Programcılık maceranız boyunca listeleri birleştirmenizi gerektiren pek çok farklı durumla karşılaşabilirsiniz. Örneğin şöyle bir durum düşünün: Diyelim ki kullanıcı tarafından girilen sayılarınortalamasınıhesaplayanbirprogramyazmakistiyorsunuz.Bununiçinşöylebirkod yazabilirsiniz: sayılar = 0 for i in range(10): sayılar += int(input("not: ")) print(sayılar/10) Buprogramkullanıcının10adetsayıgirmesineizinverip,programçıkışında,girilensayıların ortalamasınıverecektir. Peki girilen sayıların ortalaması ile birlikte, hangi sayıların girildiğini de göstermek isterseniz nasılbirkodyazarsınız? Eğerböylebirşeyikarakterdizileriileyazmayakalkışırsanızepeyeziyetçekersiniz.Amaşöyle birkodyardımıylaistediğinizşeyibasitbirşekildeeldeedebilirsiniz: sayılar = 0 notlar = [] for i in range(10): veri = int(input("{}. not: ".format(i+1))) sayılar += veri notlar += [veri] print("Girdiğiniz notlar: ", *notlar) print("Not ortalamanız: ", sayılar/10) Burada kullanıcıdan gelen verileri her döngüde tek tek notlar adlı listeye gönderiyoruz. Böylece programın sonunda, kullanıcıdan gelen veriler bir liste halinde elimizde bulunmuş oluyor. Bu arada, yukarıdaki kodlarda dikkatinizi bir şey çekmiş olmalı. Kullanıcıdan gelen verileri notlaradlılisteyegönderirkenşöylebirkodyazdık: notlar += [veri] Buradaki[veri]ifadesinedikkatedin.Bukodyardımıylakullanıcıdangelenveriadlıdeğişkeni liste haline getiriyoruz. Bu yöntem bizim için yeni bir şey. Peki neden burada list() fonksiyonundanyararlanmadık? Bunuanlamakiçinlist()fonksiyonununçalışmamantığınıanlamamızgerekiyor. Elinizdeşöylebirkarakterdizisiolduğunudüşünün: 400 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 >>> alfabe = "abcçdefgğhıijklmnoöprsştuüvyz" Diyelim ki siz bu karakter dizisindeki bütün öğeleri tek tek bir listeye atmak istiyorsunuz. Bu işiçinlist()fonksiyonunukullanabileceğimizidahaöncesöylemiştik: >>> liste = list(alfabe) Pekilist()fonksiyonubukarakterdizisininöğelerinilisteyeatarkennasılbiryöntemizliyor? Aslındalist()fonksiyonununyaptığıişşunaeşdeğerdir: liste = [] alfabe = "abcçdefgğhıijklmnoöprsştuüvyz" for harf in alfabe: liste += harf print(liste) list()fonksiyonudatamolarakböyleçalışır.Yanibirkarakterdizisiüzerindedöngükurarak, okarakterdizisininherbiröğesinitektekbirlisteyeatar. for döngülerini işlerken, bu döngünün sayılar üzerinde çalışmayacağını söylemiştik. Çünkü sayılar, karakter dizilerinin aksine, üzerinde döngü kurulabilen bir veri tipi değildir. Bunu bir örneküzerindetekrargörelim: >>> for i in 12345: ... print(i) ... Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’int’ object is not iterable Gördüğünüz gibi, 12345 sayısı üzerinde döngü kuramıyoruz. Aynı hata mesajını list() fonksiyonundadagörürsünüz: >>> list(12345) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’int’ object is not iterable Dediğimizgibi,tıpkıfordöngüsündeolduğugibi,list()fonksiyonudaancak,üzerindedöngü kurulabilennesnelerüzerindeçalışabilir.Mesela: >>> list("12345") [’1’, ’2’, ’3’, ’4’, ’5’] Bubilgilerinışığında,yukarıdayazdığımızkodlarınşuşekildeyazılmasıhalindePython’ınbize hatamesajıgöstereceğinisöyleyebiliriz: 22.1. Listeler 401 PythonBelgeleri,Yayım4.1.3 notlar = [] for i in range(10): veri = int(input("{}. not: ".format(i+1))) notlar += list(veri) print("Girdiğiniz notlar: ", *notlar) Kullanıcıdangelenverideğeriniint()fonksiyonuylasayıyadönüştürdüğümüziçinvesayılar da üzerinde döngü kurulabilen bir veri tipi olmadığı için list() fonksiyonuna parametre olarakatanamaz. Pekikullanıcıdangelenverideğerinisayıyadönüştürmeden,karakterdizisibiçimindelist() fonksiyonunaparametreolarakverirsekneolur?Budurumdalist()fonksiyonuçalışır,ama istediğimizgibibirsonuçvermez.Şukodlarıdikkatliceinceleyin: notlar = [] for i in range(10): veri = input("{}. not: ".format(i+1)) notlar += list(veri) print("Girdiğiniz notlar: ", *notlar) Bu kodları çalıştırdığınızda, tek haneli sayılar düzgün bir şekilde listeye eklenir, ancak çift ve daha fazla haneli sayılar ise listeye parça parça eklenir. Örneğin 234 sayısını girdiğinizde listeye 2, 3 ve 4 sayıları tek tek eklenir. Çünkü, yukarıda da dediğim gibi, list() fonksiyonu, aslındakarakterdizileriüzerinebirfordöngüsükurar.Yani: >>> for i in "234": ... print(i) 2 3 4 Dolayısıyla listeye 234 sayısı bir bütün olarak değil de, parça parça eklendiği için istediğiniz sonucualamamışolursunuz. Pekibusorununüstesindennasılgeleceğiz?Aslındabusorununçözümüçokbasittir.Eğerbir verininlisteyeparçaparçadeğilde,birbütünolarakeklenmesiniistiyorsanız[]işaretlerinden yararlanabilirsiniz.Tıpkışuörnekteolduğugibi: liste = [] while True: sayı = input("Bir sayı girin: (çıkmak için q) ") if sayı == "q": break sayı = int(sayı) (sonrakisayfayadevam) 402 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if sayı not in liste: liste += [sayı] print(liste) else: print("Bu sayıyı daha önce girdiniz!") Gördüğünüz gibi, kullanıcı tarafından aynı verinin birden fazla girilmesini önlemek için de listelerdenyararlanabiliyoruz. Yalnız burada şunu söyleyelim: Gerçek programlarda listelere öğe eklemek veya listeleri birleştirmek gibi işlemler için yukarıdaki gibi + işlecinden yararlanmayacağız. Yukarıda gösterdiğimiz yöntem de doğru olmakla birlikte, bu iş için genellikle liste metotlarından yararlanılır.Bumetotlarıbirazdangöreceğiz. 22.1.7 Listeden Öğe Çıkarmak Birlistedenöğesilmekiçindeladlıifadedenyararlanabilirsiniz.Örneğin: >>> liste = [1, 5, 3, 2, 9] >>> del liste[-1] >>> liste [1, 5, 3, 2] 22.1.8 Listeleri Silmek Python’dalisteleritamamensilmekdemümkündür.Örneğin: >>> liste = [1, 5, 3, 2, 9] >>> del liste >>> liste Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name ’liste’ is not defined 22.1.9 Listeleri Kopyalamak Diyelimki,yazdığınızbirprogramda,varolanbirlisteyikopyalamak,yaniaynılistedenbirtane dahaüretmekistiyorsunuz.Meselaelimizdeşöylebirlisteolsun: >>> li1 = ["elma", "armut", "erik"] Amacımız bu listeden bir tane daha oluşturmak. İlk olarak aklınıza şöyle bir yöntem gelmiş olabilir: 22.1. Listeler 403 PythonBelgeleri,Yayım4.1.3 >>> li2 = li1 Gerçektendebuyöntembizeaynıöğeleresahipikilisteverdi: >>> print(li1) ["elma", "armut", "erik"] >>> print(li2) ["elma", "armut", "erik"] Gelinşimdiilklistemizolanli1üzerindebirdeğişiklikyapalım.Meselabulistenin“elma”olan ilköğesini“karpuz”olarakdeğiştirelim: >>> li1[0] = "karpuz" >>> print(li1) ["karpuz", "armut", "erik"] Gördüğünüz gibi, li1 adlı listenin ilk öğesini başarıyla değiştirdik. Şimdi şu noktada, li2 adlı öbürlistemizindurumunukontroledelim: >>> print(li2) ["karpuz", "armut", "erik"] Odane!Bizbirazönceli1üzerindedeğişiklikyapmıştık,amagörünüşegörebudeğişiklikten li2 de etkilenmiş. Muhtemelen beklediğiniz şey bu değildi. Yani siz li2 listesinin içeriğinin aynı kalıp, değişiklikten yalnızca li1 listesinin etkilenmesini istiyordunuz. Biraz sonra bu isteğinizinasılyerinegetirebileceğinizigöstereceğiz.Amaöncedilerseniz,birlisteüzerindeki değişikliktenötekilistenindenedenetkilendiğinianlamayaçalışalım. Hatırlarsanız, listelerin değiştirilebilir (mutable) bir veri tipi olduğunu söylemiştik. Listeler bu özellikleriyle karakter dizilerinden ayrılıyor. Zira biraz önce li1 ve li2 üzerinde yaptığımız işleminbirbenzerinikarakterdizileriileyaparsakfarklıbirsonuçalırız.Dikkatlicebakın: >>> a = "elma" Burada, değeri “elma” olan a adlı bir karakter dizisi tanımladık. Şimdi bu karakter dizisini kopyalayalım: >>> b = a >>> a ’elma’ >>> b ’elma’ Böyleceaynıdeğeresahipikifarklıkarakterdizimizolmuşoldu. 404 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 Şimdiaadlıkarakterdizisiüzerindedeğişiklikyapalım.Amabizbiliyoruzki,birkarakterdizisini değiştirmenintekyolu,okarakterdizisiniyenidentanımlamaktır: >>> a = "E" + a[1:] >>> a ’Elma’ Burada yaptığımız şeyin bir ‘değişiklik’ olmadığına dikkatinizi çekmek isterim. Çünkü aslında biz burada varolan a adlı değişken üzerinde bir değişiklik yapmak yerine, yine a adı taşıyan başkabirdeğişkenoluşturuyoruz. Pekibu‘değişiklikten’öbürkarakterdizisietkilendimi? >>> b ’elma’ Gördüğünüzgibi,budeğişiklikötekikarakterdizisinietkilememiş.Bununsebebinin,karakter dizilerinindeğiştirilemeyen(immutable)birveritipiolmasıolduğunusöylemiştik. Gelinistersenizbuolgununderinlerineinelimbiraz... Yukarıdaavebadlıikideğişkenvar.Bunlarınkimliklerinikontroledelim: >>> id(a) 15182784 >>> id(b) 15181184 Gördüğünüz gibi, bu iki değişken farklı kimlik numaralarına sahip. Bu durumu şu şekilde de teyitedebileceğimizibiliyorsunuz: >>> id(a) == id(b) False Demek ki gerçekten de id(a) ile id(b) birbirinden farklıymış. Yani aslında biz aynı nesne üzerindebirdeğişiklikyapmakyerine,farklıbirnesneoluşturmuşuz. Bu sonuç bize, bu iki karakter dizisinin bellekte farklı konumlarda saklandığını gösteriyor. Dolayısıyla Python, bir karakter dizisini kopyaladığımızda bellekte ikinci bir nesne daha oluşturuyor. Bu nedenle birbirinden kopyalanan karakter dizilerinin biri üzerinde yapılan herhangi bir işlem öbürünü etkilemiyor. Ama listelerde (ve değiştirilebilir bütün veri tiplerinde)durumfarklı.Şimdişuörnekleredikkatlicebakın: >>> liste1 = ["ahmet", "mehmet", "özlem"] Bulisteyikopyalayalım: 22.1. Listeler 405 PythonBelgeleri,Yayım4.1.3 >>> liste2 = liste1 Elimizdeaynıöğeleresahipikilistevar: >>> liste1 [’ahmet’, ’mehmet’, ’özlem’] >>> liste2 [’ahmet’, ’mehmet’, ’özlem’] Bulistelerinkimliknumaralarınıkontroledelim: >>> id(liste1) 14901376 >>> id(liste2) 14901376 >>> id(liste1) == id(liste2) True Gördüğünüz gibi, liste1 ve liste2 adlı listeler aynı kimlik numarasına sahip. Yani bu iki nesne birbiriyle aynı. Dolayısıyla birinde yaptığınız değişiklik öbürünü de etkiler. Eğer birbirinden kopyalananlistelerinbirbirinietkilemesiniistemiyorsanız,önünüzdebirkaçseçenekvar. İlkseçeneğegöreşöylebirkodyazabilirsiniz: Önceözgünlistemizioluşturalım: >>> liste1 = ["ahmet", "mehmet", "özlem"] Şimdibulisteyikopyalayalım: >>> liste2 = liste1[:] Buradaliste1’ikopyalarken,listeyibaştansonadilimlediğimizedikkatedin. Bakalımliste1’dekideğişikliköbürünüdeetkiliyormu: >>> liste1[0] = "veli" >>> liste1 [’veli’, ’mehmet’, ’özlem’] >>> liste2 [’ahmet’, ’mehmet’, ’özlem’] 406 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,liste1’deyaptığımızdeğişiklikliste2’yeyansımadı.Demekkiyöntemimizişe yaramış. Aynıişiyapmakiçinkullanabileceğimizikinciyöntemiselist()fonksiyonunukullanmaktır: Önceözgünlistemizigörelim: >>> liste1 = ["ahmet", "mehmet", "özlem"] Şimdibulisteyikopyalayalım: >>> liste2 = list(liste1) Artıkelimizdebirbirininkopyasıdurumundaikifarklılistevar: >>> liste2 [’ahmet’, ’mehmet’, ’özlem’] >>> liste1 [’ahmet’, ’mehmet’, ’özlem’] Şimdiliste2üzerindebirdeğişiklikyapalım: >>> liste2[0] = ’veli’ liste2’yikontroledelim: >>> liste2 [’veli’, ’mehmet’, ’özlem’] Bakalımliste1budeğişikliktenetkilenmişmi: >>> liste1 [’ahmet’, ’mehmet’, ’özlem’] Gördüğünüz gibi, her şey yolunda. Dilerseniz bu nesnelerin birbirinden farklı olduğunu id() fonksiyonuaracılığıylateyitedebileceğinizibiliyorsunuz. Listelerikopyalamanınüçüncübiryöntemidahavar.Buyöntemidebirsonrakibölümdeliste metotlarınıincelerkenelealacağız. 22.1. Listeler 407 PythonBelgeleri,Yayım4.1.3 22.1.10 Liste Üreteçleri (List Comprehensions) Şimdi Python’daki listelere ilişkin çok önemli bir konuya değineceğiz. Bu konunun adı ‘liste üreteçleri’.İngilizce’debuna“ListComprehension”adıveriliyor. Adındandaanlaşılacağıgibi,listeüreteçleriningörevilisteüretmektir.Basitbirörnekileliste üreteçlerikonusunagirişyapalım: liste = [i for i in range(1000)] Burada 0’dan 1000’e kadar olan sayıları tek satırda bir liste haline getirdik. Bu kodların söz dizimineçokdikkatedin.Aslındayukarıdakikodşuşekildedeyazılabilir: liste = [] for i in range(1000): liste += [i] Buradaöncelisteadlıboşbirlistetanımladık.Dahasonra0ile1000aralığındabütünsayıları bu boş listeye teker teker gönderdik. Böylece elimizde 0’dan 1000’e kadar olan sayıları tutan bir liste olmuş oldu. Aynı iş için liste üreteçlerini kullandığımızda ise bu etkiyi çok daha kısa biryoldanhalletmişoluyoruz.Listeüreteçlerinikullandığımızkodutekrarönümüzealalım: liste = [i for i in range(1000)] Gördüğünüz gibi, burada önceden boş bir liste tanımlamamıza gerek kalmadı. Ayrıca bu kodlarda for döngüsünün parantezler içine alınarak nasıl sadeleştirildiğine de dikkatinizi çekmekisterim.Şukod: for i in range(1000): liste += [i] Listeüreteçlerinikullandığımızdaşukodadönüşüyor: [i for i in range(1000)] Pek çok durumda liste üreteçleri öbür seçeneklere kıyasla bir alternatif olma işlevi görür. Yani liste üreteçleri ile elde edeceğiniz sonucu başka araçlarla da elde edebilirsiniz. Mesela yukarıdaki kodların yaptığı işlevi yerine getirmek için başka bir seçenek olarak list() fonksiyonundandayararlanabileceğimizibiliyorsunuz: liste = list(range(1000)) Bu basit örneklerde liste üreteçlerini kullanmanın erdemi pek göze çarpmıyor. Ama bazı durumlarda liste üreteçleri öteki alternatiflere kıyasla çok daha pratik bir çözüm sunar. Böyle durumlarda başka seçeneklere başvurup yolunuzu uzatmak yerine liste üreteçlerini kullanarakişinizikısayoldanhalledebilirsiniz. Örneğin 0 ile 1000 arasındaki çift sayıları listelemek için liste üreteçlerini kullanmak, alternatiflerinegöredahamakulbirterciholabilir: liste = [i for i in range(1000) if i % 2 == 0] Aynıişifordöngüsüileyapmakiçinşöylebirkodyazmamızgerekir: 408 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 liste = [] for i in range(1000): if i % 2 == 0: liste += [i] Gördüğünüzgibi,listeüreteçleribizeaynıişidahakısabiryoldanhalletmeimkanıtanıyor.Bu arada for döngüsünün ve bu döngü içinde yer alan if deyiminin liste üreteçleri içinde nasıl göründüğünedikkatediyoruz. Liste üreteçleri ile ilgili bir örnek daha verelim. Mesela elinizde şöyle bir liste olduğunu düşünün: liste = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] Buradaiçiçegeçmiş4adetlistevar.Bulisteninbütünöğelerinitekbirlisteyenasılalabiliriz? Yanişöylebirçıktıyınasıleldeederiz? [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] fordöngülerinikullanarakşöylebirkodyazabiliriz: liste = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] tümü = [] for i in liste: for z in i: tümü += [z] print(tümü) Listeüreteçleriisedahakısabirçözümsunar: liste = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] tümü = [z for i in liste for z in i] print(tümü) Bu liste üreteci gerçekten de bize kısa bir çözüm sunuyor, ama bu tip iç içe geçmiş for döngülerinden oluşan liste üreteçlerinde bazen okunaklılık sorunu ortaya çıkabilir. Yani bu tür iç içe geçmiş for döngülerinden oluşan liste üreteçlerini anlamak, alternatif yöntemlere göredahazorolabilir. Bazı durumlarda ise liste üreteçleri bir sorunun çözümü için tek makul yol olabilir. Diyelim 22.1. Listeler 409 PythonBelgeleri,Yayım4.1.3 ki bir X.O.X Oyunu (Tic Tac Toe) yazıyorsunuz. Bu oyunda oyuncular oyun tahtası üzerine X veya O işaretlerinden birini yerleştirecek. Oyuncunun bu oyunu kazanabilmesi için, X veya O işaretlerinden birisinin oyun tahtası üzerinde belli konumlarda bulunması gerekiyor. Yani meselaXişaretininoyunukazanabilmesiiçinbuişaretinoyuntahtasıüzerindeşuşekildebir dizilimesahipolmasıgerekir: O X O ___ X O ___ X ___ Bu dizilime göre oyunu X işareti kazanır. Peki X işaretinin, oyunu kazanmasını sağlayacak bu dizilimeulaştığınınasıltespitedeceksiniz? Bunun için öncelikle oyun tahtası üzerinde hangi dizilim şekillerinin galibiyeti getireceğini gösteren bir liste hazırlayabilirsiniz. Mesela yukarıdaki gibi 3x3 boyutundaki bir oyun tahtasındaXişaretininoyunukazanabilmesiiçinşudizilimlerdenherhangibirinesahipolması gerekir: [0, 0], [1, 0], [2, 0] X ___ ___ X ___ ___ X ___ ___ [0, 1], [1, 1], [2, 1] ___ X ___ ___ X ___ ___ X ___ [0, 2], [1, 2], [2, 2] ___ ___ X ___ ___ X ___ ___ X [0, 0], [0, 1], [0, 2] X X X ___ ___ ___ (sonrakisayfayadevam) 410 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ___ ___ ___ [1, 0], [1, 1], [1, 2] ___ ___ ___ X X X ___ ___ ___ [2, 0], [2, 1], [2, 2] ___ ___ ___ ___ ___ ___ X X X [0, 0], [1, 1], [2, 2] X ___ ___ ___ X ___ ___ ___ X [0, 2], [1, 1], [2, 0] ___ ___ X ___ X ___ X ___ ___ Aynı dizilimler O işareti için de geçerlidir. Dolayısıyla bu kazanma ölçütlerini şöyle bir liste içindetoplayabilirsiniz: kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]], [[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]] Oyun sırasında X veya O işaretlerinin aldığı konumu bu kazanma ölçütleri ile karşılaştırarak 22.1. Listeler 411 PythonBelgeleri,Yayım4.1.3 oyunu kimin kazandığını tespit edebilirsiniz. Yani kazanma_ölçütleri adlı liste içindeki, iç içe geçmişlistelerdenherhangibiriileoyununherhangibiraşamasındatamameneşleşenişaret, oyunukazanmışdemektir. Bir sonraki bölümde bu bahsettiğimiz X.O.X Oyununu yazacağız. O zaman bu sürecin nasıl işlediğinidahaayrıntılıbirşekildeinceleyeceğiz.Şimdilikyukarıdakidurumutemsiledenbasit birörnekverereklisteüreteçlerininkullanımınıincelemeyedevamedelim. Örneğin elinizde, yukarıda bahsettiğimiz kazanma ölçütlerini temsil eden şöyle bir liste olduğunudüşünün: liste1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24], [25, 26, 27], [28, 29, 30], [31, 32, 33]] Birdeşöylebirliste: liste2 = [1, 27, 88, 98, 50, 9, 28, 45, 54, 66, 61, 23, 10, 33, 22, 12, 6, 99, 63, 26, 87, 25, 77, 5, 16, 93, 99, 44, 59, 69, 34, 10, 60, 92, 61, 44, 5, 3, 23, 99, 79, 51, 89, 63, 53, 31, 76, 41, 49, 10, 88, 63, 55, 43, 40, 71, 16, 49, 78, 41, 35, 97, 33, 76, 25, 81, 15, 99, 64, 20, 33, 6, 89, 81, 44, 53, 59, 75, 27, 15, 64, 36, 72, 78, 34, 36, 20, 41, 41, 75, 56, 30, 86, 46, 9, 42, 21, 64, 26, 52, 77, 65, 64, 12, 38, 1, 35, 20, 73, 71, 37, 35, 72, 38, 100, 52, 16, 49, 79] Burada amacınız liste1 içinde yer alan iç içe geçmiş listelerden hangisinin liste2 içindeki sayıların alt kümesi olduğunu, yani liste2 içindeki sayıların, liste1 içindeki üçlü listelerden hangisiylebirebireşleştiğinibulmak.Bununiçinşöylebirkodyazabiliriz: for i in liste1: ortak = [z for z in i if z in liste2] if len(ortak) == len(i): print(i) Bu kodlar ilk bakışta gözünüze çok karmaşık gelmiş olabilir. Ama aslında hiç de karmaşık değildirbukodlar.ŞimdibukodlarıTürkçe’yeçevirelim: 1.satır:liste1adlılistedekiherbiröğeyeiadınıverelim 2. satır: i içindeki, liste2’de de yer alan her bir öğeye de z adını verelim ve bunları ortak adlı birlistedetoplayalım. 3.satır:eğerortakadlılisteninuzunluğuideğişkenininuzunluğuileaynıysa 4.satır:i’yiekranabasalımveböylecealtkümeyibulmuşolalım. 412 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 Eğerbusatırlarıanlamaktazorlukçekiyorsanızokumayadevamedin.Birazsonravereceğimiz örnek programda da bu kodları görecek ve bu kodların ne işe yaradığını orada daha iyi anlayacaksınız. 22.1.11 Örnek Program: X.O.X Oyunu Şu ana kadar Python programlama dili hakkında epey bilgi edindik. Buraya kadar öğrendiklerimizi kullanarak işe yarar programlar yazabiliyoruz. Belki farkındasınız, belki de değilsiniz,amaözelliklelistelerkonusunuöğrenmemizbizeçokşeykazandırdı. Biröncekibölümde,birX.O.XOyunuyazacağımızdansözetmişvebuoyununPython’lanasıl yazılabileceğinedairbazıipuçlarıdavermiştik.İştebubölümde,Pythonprogramlamadilinde şimdiyekadaröğrendiklerimizikullanarakbuoyunuyazacağız. Yazacağımız oyunun İngilizce adı Tic Tac Toe. Bu oyunun ne olduğunu ve kurallarını bir önceki bölümde kabataslak bir şekilde vermiştik. Eğer isterseniz oyun kurallarına wikipedia.org/wiki/Çocuk_oyunları#X_O_X_OYUNU24 adresindendebakabilirsiniz. Oyunuvekurallarınıbildiğinizivarsayarakkodlamayabaşlayalım. Buradailkyapmamızgerekenşey,üzerindeoyunoynanacaktahtayıçizmekolmalı.Amacımız şöylebirgörüntüeldeetmek: ___ ___ ___ ___ ___ ___ ___ ___ ___ Bu tahtada oyuncu soldan sağa ve yukarıdan aşağıya doğru iki adet konum bilgisi girecek ve oyunuoynayankişiningireceğibukonumlara“X”ve“O”harfleriişaretlenecek. Böyle bir görüntü oluşturmak için pek çok farklı yöntem kullanılabilir. Ama oyuncunun her konum bilgisi girişinde, X veya O işaretini tahta üzerinde göstereceğimiz için tahta üzerinde oyun boyunca sürekli birtakım değişiklikler olacak. Bildiğiniz gibi karakter dizileri, üzerinde değişiklik yapmaya müsait bir veri tipi değil. Böyle bir görev için listeler daha uygun bir araç olacaktır.Oyüzdentahtayıoluşturmadalistelerikullanmayıtercihedeceğiz. tahta = [["___", "___", "___"], ["___", "___", "___"], ["___", "___", "___"]] Gördüğünüz gibi, burada iç içe geçmiş üç adet listeden oluşan bir liste var. print(tahta) komutunu kullanarak bu listeyi ekrana yazdırırsanız listenin yapısı daha belirgin bir şekilde ortayaçıkacaktır: [[’___’, ’___’, ’___’], [’___’, ’___’, ’___’], [’___’, ’___’, ’___’]] Oyuntahtasınıoluşturduğumuzagöre,şimdiyapmamızgerekenşeybuoyuntahtasınıdüzgün birşekildeoyuncuyagöstermekolmalı.Dediğimizgibi,oyuncuşöylebirçıktıgörmeli: 24https://tr.wikipedia.org/wiki/%C3%87ocuk_oyunlar%C4%B1#XOX 22.1. Listeler 413 PythonBelgeleri,Yayım4.1.3 ___ ___ ___ ___ ___ ___ ___ ___ ___ Bugörüntüyüeldeetmekiçinşukodlarıyazıyoruz: print("\n"*15) for i in tahta: print("\t".expandtabs(30), *i, end="\n"*2) Bu kodlarda bilmediğiniz hiçbir şey yok. Burada gördüğünüz her şeyi önceki derslerde öğrenmiştiniz. Yukarıdaki kodları yazarken tamamen, elde etmek istediğimiz görüntüye odaklanıyoruz. Mesela print("\n"*15) kodunu yazmamızın nedeni, oyun tahtası için ekranda boş bir alan oluşturmak.Buetkiyieldeetmekiçin15adetyenisatırkarakteribastıkekrana.Bukodlaelde edilenetkiyidahaiyigörebilmekiçinbukoduprogramdançıkarmayıdeneyebilirsiniz. Alttaki satırda ise bir for döngüsü tanımladık. Bu döngünün amacı tahta adlı listedeki “__” öğelerinidüzgünbirşekildeoyuncuyagösterebilmek.Oyuntahtasının,ekranı(yaklaşıkolarak da olsa) ortalamasını istiyoruz. O yüzden, tahta öğelerine soldan girinti verebilmek için print() fonksiyonunun ilk parametresini "\t".expandtabs(30) şeklinde yazdık. Karakter dizilerinin expandtabs() adlı metodunu önceki derslerimizden hatırlıyor olmalısınız. Bu metodu kullanarak sekme (TAB) karakterlerini genişletebiliyorduk. Burada da “\t” karakterini bumetotyardımıylagenişletereklisteöğelerinisolbaştangirintiledik. print() fonksiyonunun ikinci parametresi ise *i. Bu parametrenin ne iş yaptığını anlamak içinşöylebirkodyazalım: tahta = [["___", "___", "___"], ["___", "___", "___"], ["___", "___", "___"]] for i in tahta: print(i) Bukodlarıçalıştırdığımızdaşöylebirçıktıeldeederiz: [’___’, ’___’, ’___’] [’___’, ’___’, ’___’] [’___’, ’___’, ’___’] Gördüğünüz gibi, iç içe geçmiş üç adet listeden oluşan tahta adlı liste içindeki bu iç listeler ekranadöküldü.Birdeşunabakın: tahta = [["___", "___", "___"], ["___", "___", "___"], ["___", "___", "___"]] (sonrakisayfayadevam) 414 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for i in tahta: print(*i) Bukodlarçalıştırıldığındaşuçıktıyıverir: ___ ___ ___ ___ ___ ___ ___ ___ ___ Bu defa liste yapısını değil, listeyi oluşturan öğelerin kendisini görüyoruz. Yıldız işaretinin, birliktekullanıldığıöğelerüzerindenasılbiretkiyesahipolduğunuyineöncekiderslerimizden hatırlıyorsunuz.Meselaşuörneğebakın: kardiz = "" for i in kardiz: print(i, end=" ") print() Bukodlarşuçıktıyıveriyor: i s t i h z a Aynıçıktıyıbasitçeşuşekildedeeldeedebileceğimizibiliyorsunuz: kardiz = "" print(*kardiz) İşte oyun tahtasını ekrana dökmek için kullandığımız kodda da benzer bir şey yaptık. Yıldız işaretiyardımıyla,tahtaadlılisteyi oluşturaniçiçe geçmişlisteleriliste dışınaçıkarıpdüzgün birşekildekullanıcıyagösterdik. print()fonksiyonuiçindekisonparametremizşu:end="\n"*2 Bu parametrenin ne işe yaradığını kolaylıkla anlayabildiğinizi zannediyorum. Bu parametre de istediğimiz çıktıyı elde etmeye yönelik bir çabadan ibarettir. tahta adlı liste içindeki iç içe geçmiş listelerin her birinin sonuna ikişer adet “\n” karakteri yerleştirerek, çıktıdaki satırlar arasında yeterli miktarda aralık bıraktık. Eğer oyun tahtasındaki satırların biraz daha aralıklı olmasınıistersenizbuparametredeki2çarpanınıartırabilirsiniz.Mesela:end="\n"*3 Şimdi yapmamız gereken şey, oyundaki kazanma ölçütlerini belirlemek. Hatırlarsanız bu konuyabiröncekibölümdedeğinmiştik.Oyüzdenaşağıdasöyleyeceklerimizinbirbölümüne zatenaşinasınız.Buradaöncedensöylediğimizbazışeylerinyenidenüzerindengeçeceğiz. Dediğim gibi, kodların bu bölümünde, hangi durumda oyunun biteceğini ve kazananın kim olacağınıtespitedebilmemizgerekiyor.Meselaoyunsırasındaşöylebirgörüntüortayaçıkarsa hemenoyunudurdurup“OKAZANDI!”gibibirçıktıverebilmemizlazım: O O O ___ X X ___ ___ ___ 22.1. Listeler 415 PythonBelgeleri,Yayım4.1.3 Veyaşöylebirdurumda“XKAZANDI!”diyebilmeliyiz: X O ___ X O O X ___ ___ Yukarıdaki iki örnek üzerinden düşünecek olursak, herhangi bir işaretin şu konumlarda bulunmasıoişaretinkazandığınıgösteriyor: yukarıdan aşağıya 0; soldan sağa 0 yukarıdan aşağıya 1; soldan sağa 0 yukarıdan aşağıya 2; soldan sağa 0 veya: yukarıdan aşağıya 0; soldan sağa 0 yukarıdan aşağıya 0; soldan sağa 1 yukarıdan aşağıya 0; soldan sağa 2 İşte bizim yapmamız gereken şey, bir işaretin oyun tahtası üzerinde hangi konumlarda bulunması halinde oyunun biteceğini tespit etmek. Yukarıdaki örnekleri göz önüne alarak bununiçinşöylebirlistehazırlayabiliriz: kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]], [[0, 0], [0, 1], [0, 2]]] Burada iki adet listeden oluşan, kazanma_ölçütleri adlı bir listemiz var. Liste içinde, her biri üçeröğedenoluşanşulistelerigörüyoruz: [[0, 0], [1, 0], [2, 0]] [[0, 0], [0, 1], [0, 2]] Bulistelerdekendiiçindeikişeröğelibazılistelerdenoluşuyor.Meselailklisteiçindeşulisteler var: [0, 0], [1, 0], [2, 0] İkincilisteiçindeiseşulisteler: [0, 0], [0, 1], [0, 2] Burada her bir liste içindeki ilk sayı oyun tahtasında yukarıdan aşağıya doğru olan düzlemi; ikincisayıisesoldansağadoğruolandüzlemigösteriyor. Tabiikioyuniçindekitekkazanmaölçütübuikisiolmayacak.Ötekikazanmaölçütlerinidetek tektanımlamalıyız: kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]], [[0, 0], [0, 1], [0, 2]], (sonrakisayfayadevam) 416 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]] İşteXveyaOişaretlerikazanma_ölçütleriadlılistedebelirtilenkoordinatlardabulunduğunda, ilgiliişaretinoyunukazandığınıilanedipoyundançıkabileceğiz. Yukarıdaki açıklamalardan da anlayacağınız gibi, X ve O işaretlerinin oyun tahtasındaki konumu, oyunun gidişatı açısından önem taşıyor. O yüzden şu şekilde iki farklı liste daha tanımlamamızdafaydavar: x_durumu = [] o_durumu = [] Bu değişkenler sırasıyla X işaretinin ve O işaretinin oyun içinde aldıkları konumları kaydedecek. Bu konumlarla, bir önceki adımda tanımladığımız kazanma ölçütlerini karşılaştırarakoyunukiminkazandığınıtespitedebileceğiz. Gördüğünüz gibi, oyunda iki farklı işaret var: X ve O. Dolayısıyla oynama sırası sürekli olarak bu iki işaret arasında değişmeli. Mesela oyuna 0 işareti ile başlanacaksa, 0 işaretinin yerleştirilmesinden sonra sıranın X işaretine geçmesi gerekiyor. X işareti de yerleştirildikten sonrasıratekrar0işaretinegeçmeliveoyunsüresincebuböyledevamedebilmeli. Busürekliliğisağlamakiçinşöylebirkodyazabiliriz: sıra = 1 while True: if sıra % 2 == 0: işaret = "X".center(3) else: işaret = "O".center(3) sıra += 1 print() print("İŞARET: {}\n".format(işaret)) Burada sayıların tek veya çift olma özelliğinden yararlanarak X ve O işaretleri arasında geçiş yaptık. Önce sıra adlı bir değişken tanımlayıp bunun değerini 1 olarak belirledik. while döngüsünde ise bu değişkenin değerini her defasında 1 artırdık. Eğer sayının değeri çiftse işaretX;tekseOolacak.BuaradaXveOadlıkarakterdizilerini,center()metoduyardımıyla ortaladığımızadikkatedin. YukarıdakikodlarıbuşekildeçalıştırdığınızdaXveOharflerininçokhızlıbirşekildeekrandan geçtiğini göreceksiniz. Eğer ekranda son hız akıp giden bu verileri yavaşlatmak ve neler olup bittiğinidahanetgörmekistersenizyukarıdakikodlarışöyleyazabilirsiniz: from time import sleep sıra = 1 (sonrakisayfayadevam) 22.1. Listeler 417 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) while True: if sıra % 2 == 0: işaret = "X".center(3) else: işaret = "O".center(3) sıra += 1 print() print("İŞARET: {}\n".format(işaret)) sleep(0.3) Bukodlardahenüzöğrenmediğimizparçalarvar.Amaşimdilikbubilmediğinizparçalaradeğil, sonuca odaklanın. Burada yaptığımız şey, while döngüsü içinde her bir print() fonksiyonu arasına 0.3 saniyelik duraklamalar eklemek. Böylece programın akışı yavaşlamış oluyor. Biz deişaretdeğişkenininherdöngüdebirX,birOoluşunudahanetbirşekildegörebiliyoruz. (cid:242) Not Asıl program içinde X ve O karakterlerinin geçişini özellikle yavaşlatmamıza gerek kalmayacak. Programın ilerleyen satırlarında input() fonksiyonu yardımıyla kullanıcıdan verigirişiisteyeceğimiziçinXveO’larınakışızatendoğalolarakduraklamışolacak. whiledöngümüzüyazmayadevamedelim: x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30)) if x == "q": break y = input("soldan sağa [1, 2, 3]: ".ljust(30)) if y == "q": break x = int(x)-1 y = int(y)-1 Burada X veya O işaretlerini tahta üzerinde uygun yerlere yerleştirebilmek için kullanıcının konum bilgisi girmesini istiyoruz. x değişkeni yukarıdan aşağıya doğru olan düzlemdeki konumu, y değişkeni ise soldan sağa doğru olan düzlemdeki konumu depolayacak. Oyunda kullanıcının girebileceği değerler 1, 2 veya 3 olacak. Mesela oyuncu O işareti için yukarıdan aşağıya1;soldansağa2değerinigirmişseşöylebirgörüntüeldeedeceğiz: ___ O ___ ___ ___ ___ ___ ___ ___ Burada ljust() metotlarını, kullanıcıya gösterilecek verinin düzgün bir şekilde hizalanması amacıylakullandık. 418 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 Eğerkullanıcıxveyaydeğişkenlerindenherhangibirine“q”cevabıverirseoyundançıkıyoruz. Yukarıdaki kodların son iki satırında ise kullanıcıdan gelen karakter dizilerini birer sayıya dönüştürüyoruz. Bu arada, bildiğiniz gibi Python saymaya 0’dan başlıyor. Ama insanlar açısından doğal olan saymaya 1’den başlamaktır. O yüzden mesela kullanıcı 1 sayısını girdiğinde Python’ın bunu 0 olarak algılamasını sağlamamız gerekiyor. Bunun için x ve y değerlerinden1çıkarıyoruz. Kullanıcıdangereklikonumbilgilerinialdığımızagöre,bubilgileredayanarakXveOişaretlerini oyuntahtasıüzerineyerleştirebiliriz.Şimdişukodlarıdikkatliceinceleyin: print("\n"*15) if tahta[x][y] == "___": tahta[x][y] = işaret if işaret == "X".center(3): x_durumu += [[x, y]] elif işaret == "O".center(3): o_durumu += [[x, y]] sıra += 1 else: print("\nORASI DOLU! TEKRAR DENEYİN\n") Buradaöncelikle15adetsatırbaşıkarakteribasıyoruz.Böyleceoyuntahtasıiçinekrandaboş bir alan oluşturmuş oluyoruz. Bu satır tamamen güzel bir görüntü elde etmeye yönelik bir uygulamadır. Yani bu satırı yazmasanız da programınız çalışır. Veya siz kendi zevkinize göre dahafarklıbirgörünümeldeetmeyeçalışabilirsiniz. İkinci satırda gördüğümüz if tahta[x][y] == "___": kodu, oyun tahtası üzerindeki bir konumun halihazırda boş mu yoksa dolu mu olduğunu tespit etmemizi sağlıyor. Amacımız oyuncunun aynı konuma iki kez giriş yapmasını engellemek. Bunun için tahta üzerinde x ve y konumlarına denk gelen yerde “___” işaretinin olup olmadığına bakmamız yeterli olacaktır. Eğerbakılankonumda“___”işaretivarsaorasıboşdemektir.Okonumaişaretkoyulabilir.Ama eğer o konumda “___” işareti yoksa X veya O işaretlerinden biri var demektir. Dolayısıyla o konuma işaret koyulamaz. Böyle bir durumda kullanıcıya “ORASI DOLU! TEKRAR DENEYİN” uyarısınıgösteriyoruz. Oyuntahtasıüzerindedeğişiklikyapabilmekiçinnasılbiryolizlediğimizedikkatedin: tahta[x][y] = işaret Mesela oyuncu yukarıdan aşağıya 1; soldan sağa 2 sayısını girmişse, kullanıcıdan gelen sayılardan1çıkardığımıziçin,Pythonyukarıdakikoduşöyledeğerlendirecektir: tahta[0][1] = işaret Yanitahtaadlılisteiçindekiilklisteninikincisırasınailgiliişaretyerleştirilecektir. Ayrıcayukarıdakikodlardaşusatırlarıdagörüyoruz: if işaret == "X".center(3): x_durumu += [[x, y]] elif işaret == "O".center(3): o_durumu += [[x, y]] 22.1. Listeler 419 PythonBelgeleri,Yayım4.1.3 Eğer işaret sırası X’te ise oyuncunun girdiği konum bilgilerini x_durumu adlı değişkene, eğer işaret sırası O’da ise konum bilgilerini o_durumu adlı değişkene yolluyoruz. Oyunu hangi işaretin kazandığını tespit edebilmemiz açısından bu kodlar büyük önem taşıyor. x_durumu ve o_durumu değişkenlerini kazanma_ölçütleri adlı liste ile karşılaştırarak oyunu kiminkazandığınakararvereceğiz. Buarada,oyununenbaşındatanımladığımızsıraadlıdeğişkeniifbloğuiçindeartırdığımıza dikkat edin. Bu sayede, kullanıcının yanlışlıkla aynı konuma iki kez işaret yerleştirmeye çalışmasıhalindeişaretsırasıdeğişmeyecek.YanimeselaoandasıraX’teiseveoyuncuyanlış birkonumgirdiysesırayineX’teolacak.Eğersıradeğişkeniniifbloğuiçineyazmazsak,yanlış konumgirildiğindeişaretsırasıO’ageçecektir. İstersenizşimdiyekadaryazdığımızkodlarışöylebirtoplucagörelim: tahta = [["___", "___", "___"], ["___", "___", "___"], ["___", "___", "___"]] print("\n"*15) for i in tahta: print("\t".expandtabs(30), *i, end="\n"*2) kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]], [[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]] x_durumu = [] o_durumu = [] sıra = 1 while True: if sıra % 2 == 0: işaret = "X".center(3) else: işaret = "O".center(3) print() print("İŞARET: {}\n".format(işaret)) x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30)) if x == "q": break y = input("soldan sağa [1, 2, 3]: ".ljust(30)) if y == "q": break (sonrakisayfayadevam) 420 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) x = int(x)-1 y = int(y)-1 print("\n"*15) if tahta[x][y] == "___": tahta[x][y] = işaret if işaret == "X".center(3): x_durumu += [[x, y]] elif işaret == "O".center(3): o_durumu += [[x, y]] sıra += 1 else: print("\nORASI DOLU! TEKRAR DENEYİN\n") Gördüğünüzgibiepeykodyazmışız.Kodlarımızıtoplucaincelediğimizegöreyazmayadevam edebiliriz: for i in tahta: print("\t".expandtabs(30), *i, end="\n"*2) Bu kodların ne işe yaradığınız biliyorsunuz. Oyun tahtasının son durumunu kullanıcıya göstermekiçinkullanıyoruzbukodları. Sıra geldi oyunun en önemli kısmına. Bu noktada oyunu kimin kazandığını belirlememiz gerekiyor.Dikkatliceinceleyin: for i in kazanma_ölçütleri: o = [z for z in i if z in o_durumu] x = [z for z in i if z in x_durumu] if len(o) == len(i): print("O KAZANDI!") quit() if len(x) == len(i): print("X KAZANDI!") quit() Bu kodları anlayabilmek için en iyi yol uygun yerlere print() fonksiyonları yerleştirerek çıktıları incelemektir. Mesela bu kodları şöyle yazarak o ve x değişkenlerinin değerlerini izleyebilirsiniz: for i in kazanma_ölçütleri: o = [z for z in i if z in o_durumu] x = [z for z in i if z in x_durumu] print("o: ", o) print("x: ", x) if len(o) == len(i): print("O KAZANDI!") quit() (sonrakisayfayadevam) 22.1. Listeler 421 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if len(x) == len(i): print("X KAZANDI!") quit() Bu kodlar içindeki en önemli öğeler o ve x adlı değişkenlerdir. Burada, o_durumu veya x_durumuadlılistelerdekideğerlerlekazanma_ölçütleriadlılistedekideğerlerikarşılaştırarak, ortakdeğerlerioveyaxdeğişkenlerineyolluyoruz.Eğerortaköğesayısı3’eulaşırsa(if len(o) == len(i): veya if len(x) == len(i):), bu sayıyı yakalayan ilk işaret hangisiyse oyunu o kazanmışdemektir. Kodlarımızınsonhalişöyleoldu: tahta = [["___", "___", "___"], ["___", "___", "___"], ["___", "___", "___"]] print("\n"*15) for i in tahta: print("\t".expandtabs(30), *i, end="\n"*2) kazanma_ölçütleri = [[[0, 0], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 2], [1, 2], [2, 2]], [[0, 0], [0, 1], [0, 2]], [[1, 0], [1, 1], [1, 2]], [[2, 0], [2, 1], [2, 2]], [[0, 0], [1, 1], [2, 2]], [[0, 2], [1, 1], [2, 0]]] x_durumu = [] o_durumu = [] sıra = 1 while True: if sıra % 2 == 0: işaret = "X".center(3) else: işaret = "O".center(3) print() print("İŞARET: {}\n".format(işaret)) x = input("yukarıdan aşağıya [1, 2, 3]: ".ljust(30)) if x == "q": break y = input("soldan sağa [1, 2, 3]: ".ljust(30)) if y == "q": break (sonrakisayfayadevam) 422 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) x = int(x)-1 y = int(y)-1 print("\n"*15) if tahta[x][y] == "___": tahta[x][y] = işaret if işaret == "X".center(3): x_durumu += [[x, y]] elif işaret == "O".center(3): o_durumu += [[x, y]] sıra += 1 else: print("\nORASI DOLU! TEKRAR DENEYİN\n") for i in tahta: print("\t".expandtabs(30), *i, end="\n"*2) for i in kazanma_ölçütleri: o = [z for z in i if z in o_durumu] x = [z for z in i if z in x_durumu] if len(o) == len(i): print("O KAZANDI!") quit() if len(x) == len(i): print("X KAZANDI!") quit() Gördüğünüz gibi, sadece şu ana kadar öğrendiğimiz bilgileri kullanarak bir oyun yazabilecek duruma geldik. Burada küçük parçaları birleştirerek bir bütüne nasıl ulaştığımızı özellikle görmenizi isterim. Dikkat ederseniz, yukarıdaki programda sadece karakter dizileri, sayılar, listeler ve birkaç fonksiyon var. Nasıl sadece 7 nota ile müzik şaheserleri meydana getirilebiliyorsa,yalnızca4-5veritipiilededünyayıayağakaldıracakprogramlardayazılabilir. Listeleritemelolarakincelediğimizegörebirazdademetlerdensözedebiliriz. 22.1. Listeler 423 PythonBelgeleri,Yayım4.1.3 22.2 Demetler Demetler, özellikle görünüş olarak listelere çok benzeyen bir veri tipidir. Bu veri tipi de, tıpkı listelergibi,farklıveritipleriniiçindebarındırankapsayıcıbirveritipidir. 22.2.1 Demet Tanımlamak Demet tanımlamanın birkaç farklı yolu vardır. Nasıl karakter dizilerinin ayırt edici özelliği tırnakişaretleri,listelerinayırtediciözelliğiiseköşeliparantezişaretleriise,demetlerinayırt edici özelliği de normal parantez işaretleridir. Dolayısıyla bir demet tanımlamak için normal parantezişaretlerindenyararlanacağız: >>> demet = ("ahmet", "mehmet", 23, 45) >>> type(demet) <class ’tuple’> Gördüğünüz gibi, karakter dizilerinin type() sorgusuna str, listelerin ise list cevabı vermesi gibi,demetlerdetype()sorgusunatuplecevabıveriyor. Yalnız, dediğimiz gibi Python’da demet tanımlamanın birden fazla yolu vardır. Mesela yukarıdakidemetişöyledetanımlayabiliriz: >>> demet = "ahmet", "mehmet", 23, 45 Gördüğünüz gibi, parantez işaretlerini kullanmadan, öğeleri yalnızca virgül işareti ile ayırdığımızdadaeldeettiğimizşeybirdemetoluyor. Demetoluşturmakiçintuple()adlıbirfonksiyondandayararlanabilirsiniz.Bufonksiyon,liste oluşturanlist()fonksiyonunaçokbenzer: >>> tuple(’abcdefg’) (’a’, ’b’, ’c’, ’d’, ’e’, ’f’, ’g’) Bufonksiyonukullanarakbaşkaveritiplerinidemetedönüştürebilirsiniz: >>> tuple(["ahmet", "mehmet", 34, 45]) (’ahmet’, ’mehmet’, 34, 45) Burada, [“ahmet”, “mehmet”, 34, 45] adlı bir listeyi tuple() fonksiyonu yardımıyla demete dönüştürdük. 424 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 22.2.2 Tek Öğeli bir Demet Tanımlamak Teköğelibirkarakterdizisioluşturabilmekiçinşuyoluizliyordukhatırlarsanız: >>> kardiz = ’A’ Buteköğelibirkarakterdizisidir.Birdeteköğelibirlistetanımlayalım: >>> liste = [’ahmet’] Budateköğelibirlistedir.Gelinbirdeteköğelibirdemetoluşturmayaçalışalım: >>> demet = (’ahmet’) Bu şekilde tek öğeli bir demet oluşturduğunuzu zannediyorsunuz, ama aslında oluşturduğunuzşeybasitbirkarakterdizisindenibaret!Gelinkontroledelim: >>> type(demet) <class ’str’> Python programlama dilinde tek öğeli bir demet oluşturma işlemi biraz ‘tuhaf’tır. Eğer tek öğeyesahipbirdemetoluşturacaksakşöylebirşeyyazmalıyız: >>> demet = (’ahmet’,) veya: >>> demet = ’ahmet’, Gördüğünüz gibi, tek öğeli bir demet tanımlarken, o tek öğenin yanına bir tane virgül işareti yerleştiriyoruz.Böylecedemettanımlamakisterken,yanlışlıklaaleladebirşekilde‘ahmet’adlı birkarakterdizisini‘demet’adlıbirdeğişkeneatamamışoluyoruz... 22.2.3 Demetlerin Öğelerine Erişmek Eğer bir demet içinde yer alan herhangi bir öğeye erişmek isterseniz, karakter dizileri ve listelerdenhatırladığınızyöntemikullanabilirsiniz: >>> demet = (’elma’, ’armut’, ’kiraz’) >>> demet[0] ’elma’ >>> demet[-1] ’kiraz’ >>> demet[:2] (’elma’, ’armut’) 22.2. Demetler 425 PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,dahaönceöğrendiğimizindekslemevedilimlemekurallarıaynendemetler içindegeçerli. 22.2.4 Demetlerle Listelerin Birbirinden Farkı En başta da söylediğimiz gibi, demetlerle listeler birbirine çok benzer. Ama demetlerle listelerinbirbirindençokönemlibazıfarklarıdavardır.Buikiveritipiarasındakienönemlifark şudur;listelerdeğiştirilebilir(mutable)birveritipiiken,demetlerdeğiştirilemez(immutable) bir veri tipidir. Yani tıpkı karakter dizileri gibi, demetler de bir kez tanımlandıktan sonra bunlarınüzerindedeğişiklikyapmakmümkündeğildir: >>> demet = (’elma’, ’armut’, ’kiraz’) >>> demet[0] = ’karpuz’ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’tuple’ object does not support item assignment Gördüğünüz gibi, demetin herhangi bir öğesini değiştirmeye çalıştığımızda Python bize bir hatamesajıgösteriyor. Bu bakımdan, eğer programın akışı esnasında üzerinde değişiklik yapmayacağınız veya değişiklik yapılmasını istemediğiniz birtakım veriler varsa ve eğer siz bu verileri liste benzeri bir taşıyıcı içine yerleştirmek istiyorsanız, listeler yerine demetleri kullanabilirsiniz. Ayrıca demetler üzerinde işlem yapmak listelere kıyasla daha hızlıdır. Dolayısıyla, performans avantajınedeniyledelisteleryerinedemetlerikullanmakisteyebilirsiniz. Tahmin edebileceğiniz gibi, tıpkı karakter dizilerinde olduğu gibi, önceden tanımlanmış bir demetin üzerinde değişiklik yapabilmek için, örneğin bir demetle başka bir demeti birleştirmekiçinodemetiyenidentanımlamakdamümkündür: >>> demet = (’ahmet’, ’mehmet’) >>> demet = demet + (’selin’,) Eğer sadece demet + (’selin’,) demiş olsaydık özgün demet üzerinde herhangi bir değişiklik yapmış olmayacaktık. Siz bu olguya karakter dizilerinden de aşinasınız. O yüzden, özgün demet üzerinde herhangi bir değişiklik yapabilmek için, daha doğrusu özgün demet üzerinde bir değişiklik yapmış gibi görünebilmek için, özgün demeti sıfırdan tanımlamamız gerekiyor... Burada ayrıca ‘ahmet’ ve ‘mehmet’ öğelerinden oluşan bir demete ‘selin’ öğesini nasıl eklediğimize de dikkat edin. Asla unutmamalısınız: Python programlama dilinde sadece aynı türverileribirbiriylebirleştirebilirsiniz.Meselayukarıdakiörnekte‘selin’adlıöğeyidemetadlı demetebirkarakterdizisiolarakekleyemezsiniz: >>> demet = demet + ’selin’ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: can only concatenate tuple (not "str") to tuple Bu arada, yukarıdaki kodu şöyle yazdığınızda da aslında bir demetle karakter dizisini birleştirmeyeçalışıyorolduğunuzadikkatedin: 426 Bölüm22. ListelerveDemetler PythonBelgeleri,Yayım4.1.3 >>> demet = demet + (’selin’) Hatırlarsanız,teköğelibirdemettanımlayabilmekiçinparanteziçindekiteköğeninyanınabir virgül işareti yerleştirmemiz gerekiyordu. Aksi halde demet değil, karakter dizisi tanımlamış oluyorduk. Zaten bir Python programcısı olarak, demetler üzerinde çalışırken en sık yapacağınız hata da demet tanımlamaya çalışırken yanlışlıkla karakter dizisi tanımlamak olacaktır. Dediğimiz ve yukarıda da örneklerle gösterdiğimiz gibi, bir demeti yeni baştan tanımlayarak da o demet üzerinde değişiklik yapmış etkisi elde edebilirsiniz. Ancak elbette bir araya topladığınız veriler üzerinde sık sık değişiklikler yapacaksanız demetler yerine listeleri tercih etmelisiniz. 22.2.5 Demetlerin Kullanım Alanı Demetleri ilk öğrendiğinizde bu veri tipi size son derece gereksizmiş gibi gelebilir. Ama aslında oldukça yaygın kullanılan bir veri tipidir bu. Özellikle programların ayar (conf) dosyalarında bu veri tipi sıklıkla kullanılır. Örneğin Python tabanlı bir web çatısı (framework) olan Django’nun settings.py adlı ayar dosyasında pek çok değer bir demet olarak saklanır. Mesela bir Django projesinde web sayfalarının şablonlarını (template) hangi dizin altında saklayacağınızıbelirlediğinizayarşöylegörünür: TEMPLATE_DIRS = (’/home/projects/djprojects/blog/templates’,) Burada, şablon dosyalarının hangi dizinde yer alacağını bir demet içinde gösteriyoruz. Bu demetiçinebirdenfazladizinadıyazabilirdik.Amabizbütünşablondosyalarınıtekbirdizin altında tutmayı tercih ettiğimiz için tek öğeli bir demet tanımlamışız. Bu arada, daha önce de söylediğimiz gibi, demetlerle ilgili en sık yapacağınız hata, tek öğeli demet tanımlamaya çalışırken aslında yanlışlıkla bir karakter dizisi tanımlamak olacaktır. Örneğin yukarıdaki TEMPLATE_DIRSdeğişkeninişöyleyazsaydık: TEMPLATE_DIRS = (’/home/projects/djprojects/blog/templates’) Aslındabirdemetdeğil,aleladebirkarakterdizisitanımlamışolurduk... 22.2. Demetler 427 23 BÖLÜM Listelerin ve Demetlerin Metotları 23.1 Listelerin Metotları Burada,geçenbölümdekaldığımızyerdendevamedeceğizlistelerianlatmaya.Ağırlıklıolarak bu bölümde listelerin metotlarından söz edeceğiz. ‘Metot’ kavramını karakter dizilerinden hatırlıyorsunuz.Karakterdizilerinianlatırkenbolmiktardametotgörmüştük. Python’dabütünveritipleribizebirtakımmetotlarsunar.Bumetotlaryardımıyla,ilgiliveritipi üzerindeönemlideğişikliklerveyasorgulamalaryapabiliyoruz. Hatırlarsanız bir veri tipinin hangi metotlara sahip olduğunu görmek için dir() fonksiyonundan yararlanıyorduk. Listelerde de durum farklı değil. Dolayısıyla şu komut bizelistelerinmetotlarınısıralayacaktır: >>> dir(list) [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__delitem__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__gt__’, ’__hash__’, ’__iadd__’, ’__imul__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__reversed__’, ’__rmul__’, ’__setattr__’, ’__setitem__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’append’, ’clear’, ’copy’, ’count’, ’extend’, ’index’, ’insert’, ’pop’, ’remove’, ’reverse’, ’sort’] Gördüğünüz gibi, tıpkı karakter dizilerinde olduğu gibi, listelerin metotlarını görmek için de dir() fonksiyonuna parametre olarak veri tipinin teknik adını veriyoruz. Python’da listelerin teknik adı list olduğu için bu komutu dir(list) şeklinde kullanıyoruz. Elbette, eğer istersek, listelerin metotlarını almak için herhangi bir listeyi de kullanabiliriz. Mesela boş bir liste kullanalım: >>> dir([]) 428 PythonBelgeleri,Yayım4.1.3 Bu komut da dir(list) ile aynı çıktıyı verecektir. Bu listede bizi ilgilendiren metotlar ise şunlardır: >>> [i for i in dir(list) if not "_" in i] [’append’, ’clear’, ’copy’, ’count’, ’extend’, ’index’, ’insert’, ’pop’, ’remove’, ’reverse’, ’sort’] Metotlar, bir programcının hayatını önemli ölçüde kolaylaştıran araçlardır. Bu yüzden, ‘Listeler’ konusunun ilk bölümünde öğrendiğimiz listeye öğe ekleme, öğe çıkarma, öğe değiştirme, öğe silme gibi işlemleri orada anlattığımız yöntemlerle değil, biraz sonra göreceğimiz metotlar aracılığıyla yapmayı tercih edeceğiz. Ama tabii ki, metotları tercih edecek olmamız, birinci bölümde anlattığımız yöntemleri bir kenara atmanızı gerektirmez. Unutmayın,birdildekiherhangibirözelliğisizkullanmasanızbile,etraftabuözelliğikullanan başkaprogramcılarvar.Dolayısıylaenazındanbaşkalarınınyazdığıkodlarıanlayabilmekiçin dahiolsa,kendinizinkullanmayacağıyöntemveyollarıöğrenmenizgerekir. append()metoduylabaşlayalım... 23.1.1 append() append kelimesi İngilizcede ‘eklemek, ilave etmek, iliştirmek’ gibi anlamlara gelir. append() metodunun görevi de kelime anlamıyla uyumludur. Bu metodu, bir listeye öğe eklemek için kullanıyoruz.Mesela: >>> liste = ["elma", "armut", "çilek"] >>> liste.append("erik") Bu metot, yeni öğeyi listenin en sonuna ekler. Mesela yukarıdaki örnekte “erik” adlı karakter dizisilistede“çilek”adlıkarakterdizisininsağınaeklendi. Hatırlarsanız bir önceki bölümde listeye öğe ekleme işini + işleci ile de yapabileceğimizi söylemiştik.Dolayısıyla,aslındayukarıdakikoduşöyledeyazabiliriz: >>> liste = ["elma", "armut", "çilek"] >>> liste = liste + ["erik"] >>> print(liste) [’elma’, ’armut’, ’çilek’, ’erik’] Buikiyöntembirbiriyleaynısonucuversedehempratiklikhemdeişleyişbakımındanbuiki yönteminbirbirindenfarklıolduğunugörüyoruz. Pratiklik açısından bakarsak, append() metodununu kullanmanın + işlecini kullanmaya kıyasla daha kolay olduğunu herhalde kimse reddetmeyecektir. Bu iki yöntem işleyiş bakımındandabirbirindenayrılıyor.Zira+işlecinikullandığımızdalisteyeyenibiröğeeklerken aslında liste adlı başka bir liste daha oluşturmuş oluyoruz. Hatırlarsanız önceki bölümlerde listelerin değiştirilebilir (mutable) veri tipleri olduğunu söylemiştik. İşte append() metodu sayesindelistelerinbuözelliğindensonunakadaryararlanabiliyoruz.+işlecinikullandığımızda ise, orijinal listeyi değiştirmek yerine yeni bir liste oluşturduğumuz için, sanki listelere karakterdizisimuamelesiyapmışgibioluyoruz.Gördüğünüzgibi,listeyeappend()metodunu uyguladıktansonrabunubirdeğişkeneatamamızagerekkalmıyor.append()metoduorijinal 23.1. ListelerinMetotları 429 PythonBelgeleri,Yayım4.1.3 liste üzerinde doğrudan değişiklik yapmamıza izin verdiği için daha az kod yazmamızı ve programımızındahaperformanslıçalışmasınısağlıyor. + işleci ile append() metodu işlev olarak birbirine benzese de bu iki yöntem arasında önemli farklılıklardavardır.Meselaşuörneğebirgözatalım: işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"] platformlar = ["IPhone", "Android", "S60"] hepsi = işletim_sistemleri + platformlar print(hepsi) [’Windows’, ’GNU/Linux’, ’Mac OS X’, ’IPhone’, ’Android’, ’S60’] Buradaikifarklılisteyi,+işlecikullanarakbirleştirdik.Aynıişiappend()metoduylaşuşekilde yapabiliriz: işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"] platformlar = ["IPhone", "Android", "S60"] for i in platformlar: işletim_sistemleri.append(i) print(işletim_sistemleri) Burada platformlar adlı liste üzerinde bir for döngüsü kurmamızın nedeni, append() metodunun yalnızca tek bir parametre alabilmesidir. Yani bu metodu kullanarak bir listeye birdenfazlaöğeekleyemezsiniz: >>> liste = [1, 2, 3] >>> liste.append(4, 5, 6) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: append() takes exactly one argument (3 given) Busebeple,ekleyeceğinizlisteninöğeleriüzerindebirfordöngüsükurmanızgerekir: >>> liste = [1, 2, 3] >>> for i in [4, 5, 6]: ... liste.append(i) ... >>> print(liste) [1, 2, 3, 4, 5, 6] Birlisteyebirdenfazlaöğeeklemekiçinaklınızaşöylebiryöntemdegelmişolabilir: >>> liste = [1, 2, 3] >>> liste.append([4, 5, 6]) Ancakbukomutunçıktısıpekbeklediğinizgibiolmayabilir: 430 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 >>> print(liste) [1, 2, 3, [4, 5, 6]] Gördüğünüzgibi,[4, 5, 6]öğesilisteyetekparçaolarakeklendi.Eğeristediğinizşeybuysa neâlâ!Amadeğilse,fordöngüsüyada+işleciileistediğinizçıktıyıeldeedebilirsiniz. Şöyle bir örnek daha düşünün: Diyelim ki kullanıcının girdiği bütün sayıları birbiriyle çarpan biruygulamayazmakistiyoruz.Bununiçinşöylebirkodyazabiliriz: sonuç = 1 while True: sayı = input("sayı (hesaplamak için q): ") if sayı == "q": break sonuç *= int(sayı) print(sonuç) Burada kullanıcı her döngüde bir sayı girecek ve programımız girilen bu sayıyı sonuç değişkenininoankideğeriyleçarparakyinesonuçdeğişkeninegönderecek.Böylecekullanıcı tarafından girilen bütün sayıların çarpımını elde etmiş olacağız. Kullanıcının ‘q’ harfine basmasıyla birlikte de sonuç değişkeninin değeri ekranda görünecek. Yalnız burada birkaç sorun var. Diyelim ki kullanıcı hiçbir sayı girmeden ‘q’ harfine basarsa, sonuç değişkeninin 1 olan değeri ekranda görünecek ve bu şekilde kullanıcı yanlış bir sonuç elde etmiş olacak. Ayrıcaçarpmaişlemiiçinenaz2adetsayıgerekiyor.Dolayısıylakullanıcı2’denazsayıgirerse de programımız yanlış sonuç verecektir. Kullanıcının yeterli miktarda sayı girip girmediğini tespitedebilmekiçinyinelistelerdenvelistelerinappend()metodundanyararlanabiliriz: kontrol = [] sonuç = 1 while True: sayı = input("sayı (hesaplamak için q): ") if sayı == "q": break kontrol.append(sayı) sonuç *= int(sayı) if len(kontrol) < 2: print("Yeterli sayı girilmedi!") else: print(sonuç) Burada önceki koda ilave olarak, kontrol adlı boş bir liste tanımladık. Bu liste kullanıcının girdiği sayıları depolayacak. Bir önceki örnekte kullanıcının girdiği sayıları hiçbir yerde depolamadık. Orada yaptığımız şey her döngüde kullanıcı tarafından girilen sayıyı sonuç değişkeninin değeriyle çarpıp yine sonuç değişkenine göndermekti. Dolayısıyla kullanıcı tarafından girilen sayılar bir yerde tutulmadığı için kaybolup gidiyordu. Burada ise kontrol adlı liste, kullanıcı tarafından girilen sayıları tuttuğu için, bu sayıları daha sonra istediğimiz 23.1. ListelerinMetotları 431 PythonBelgeleri,Yayım4.1.3 gibikullanabilmeimkanınakavuşuyoruz. Ayrıca bu ikinci kodlarda kontrol değişkeninin boyutuna bakarak kullanıcının 2’den az sayı girip girmediğini denetliyoruz. Eğer kontrol listesinin uzunluğu 2’den azsa kullanıcı çarpma işlemiiçinyeterlisayıgirmemişdemektir.Böylebirdurumdaçarpmaişleminiyapmakyerine, kullanıcıya‘Yeterlisayıgirilmedi!’şeklindebiruyarımesajıgösteriyoruz. append() metodu listelerin en önemli metotlarından biridir. Hem kendi yazdığınız, hem de başkalarının yazdığı programlarda append() metodunu sıkça göreceksiniz. Dolayısıyla listelerinhiçbirmetodunubilmesenizbileappend()metodunuöğrenmelisiniz. 23.1.2 extend() extend kelimesi İngilizcede ‘genişletmek, yaymak’ gibi anlamlara gelir. İşte extend() adlı metotdakelimeanlamınauygunolaraklisteleri‘genişletir’. Şöyle bir düşündüğünüzde extend() metodunun append() metoduyla aynı işi yaptığını zannedebilirsiniz.Amaaslındabuikimetotişleyişolarakbirbirindençokfarklıdır. append()metodunukullanarakyazdığımızşukodadikkatlicebakın: li1 = [1, 3, 4] li2 = [10, 11, 12] li1. append(li2) print(li1) append()metodunuanlatırkensöylediğimizgibi,bumetotbirlisteyeherdefasındasadecetek biröğeeklenmesineizinverir.Yukarıdaolduğugibi,eğerbumetodukullanarakbirlisteyeyine birlisteeklemeyeçalışırsanız,eklediğinizlistetekbiröğeolarakeklenecektir.Yaniyukarıdaki kodlarsizeşöylebirçıktıverecektir: [1, 3, 4, [10, 11, 12]] Gördüğünüz gibi, [10, 11, 12] listesi öteki listeye tek bir liste halinde eklendi. İşte extend() metodu bu tür durumlarda işinize yarayabilir. Mesela yukarıdaki örneği bir de extend() metodunukullanarakyazalım: li1 = [1, 3, 4] li2 = [10, 11, 12] li1. extend(li2) print(li1) Budefaşöylebirçıktıalıyoruz: [1, 3, 4, 10, 11, 12] Gördüğünüzgibi,extend()metodutamdakelimeanlamınauygunolaraklisteyiyeniöğelerle genişletti. Hatırlarsanızappend()metodunuanlatırkenşöylebirörnekvermiştik: 432 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"] platformlar = ["IPhone", "Android", "S60"] hepsi = işletim_sistemleri + platformlar print(hepsi) Burada + işlecini kullanarak işletim_sistemleri ve platformlar adlı listeleri birleştirerek hepsi adlı tek bir liste elde ettik. Aynı etkiyi append() metodunu kullanarak şu şekilde elde edebileceğimizidesöylemiştikorada: işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"] platformlar = ["IPhone", "Android", "S60"] for i in platformlar: işletim_sistemleri.append(i) print(işletim_sistemleri) Esasında, append() metodunu kullanmaya kıyasla, burada + işlecini kullanmak sanki daha pratikmişgibigörünüyor.Birdeşunabakın: işletim_sistemleri = ["Windows", "GNU/Linux", "Mac OS X"] platformlar = ["IPhone", "Android", "S60"] işletim_sistemleri.extend(platformlar) print(işletim_sistemleri) Gördüğünüzgibi,buörnekteextend()metodunukullanmakappend()metodunukullanmaya göredahapratikvemakul.Çünkübirlisteyetekteköğeeklemekaçısındanappend()metodu daha uygundur, ama eğer yukarıda olduğu gibi bir listeye başka bir liste ekleyeceksek extend()metodunukullanmayıtercihedebiliriz. 23.1.3 insert() Bildiğinizgibi,+işleci,append()veextend()metotlarıöğelerilisteninsonunaekliyor.Pekibiz biröğeyilisteninsonunadeğilde,listeiçindebaşkabirkonumaeklemekistersekneyapacağız? İştebununiçininsert()adlıbaşkabirmetottanyararlanacağız. insert kelimesi ‘yerleştirmek, sokmak’ gibi anlamlara gelir. insert() metodu da bu anlama uygunolarak,öğelerilisteninistediğimizbirkonumunayerleştirir.Dikkatliceinceleyin: >>> liste = ["elma", "armut", "çilek"] >>> liste.insert(0, "erik") >>> print(liste) [’erik’, ’elma’, ’armut’, ’çilek’] Gördüğünüz gibi insert() metodu iki parametre alıyor. İlk parametre, öğenin hangi konumayerleştirileceğini,ikinciparametreiseyerleştirileceköğeninneolduğunugösteriyor. Yukarıdakiörnekte“erik”öğesinilistenin0.konumuna,yanilisteninenbaşınayerleştiriyoruz. ìnsert() metodu özellikle dosya işlemlerinde işinize yarar. Diyelim ki elimizde içeriği şöyle olandeneme.txtadlıbirdosyavar: 23.1. ListelerinMetotları 433 PythonBelgeleri,Yayım4.1.3 Ahmet Özkoparan Mehmet Veli Serdar Güzel Zeynep Güz Bizimamacımız,‘AhmetÖzkoparan’satırındansonra‘FerhatYaz’diyebirsatırdahaeklemek. Yanidosyamızışuhalegetirmekistiyoruz: Ahmet Özkoparan Ferhat Yaz Mehmet Veli Serdar Güzel Zeynep Güz Biz henüz Python’da dosya işlemlerinin nasıl yapılacağını öğrenmedik. Ama hatırlarsanız bundan önceki bölümlerde birkaç yerde open() adlı bir fonksiyondan bahsetmiş ve bu fonksiyonun dosya işlemlerinde kullanıldığını söylemiştik. Mesela yukarıda bahsettiğimiz deneme.txtadlıdosyayıaçmakiçinopen()fonksiyonunuşuşekildekullanabiliriz: f = open("deneme.txt", "r") Buradadeneme.txtadlıdosyayıokumamodundaaçmışolduk.Şimdidosyaiçeriğiniokuyalım: içerik = f.readlines() Bu satır sayesinde dosya içeriğini bir liste halinde alabildik. Eğer yukarıdaki kodlara şu eklemeyiyaparsanız,dosyaiçeriğinigörebilirsiniz: print(içerik) [’Ahmet Özkoparan\n’, ’Mehmet Veli\n’, ’Serdar Güzel\n’, ’Zeynep Güz\n’, ’\n’] Gördüğünüzgibi,dosyaiçeriğibasitbirlistedenibaret.Dolayısıylalistelerleyapabildiğimizher şeyiiçerikadlıdeğişkenledeyapabiliriz.Yanibulisteyeöğeekleyebilir,listedenöğeçıkarabilir yadabulisteyibaşkabirlisteilebirleştirebiliriz. Dosyaiçeriğinibirlisteolarakaldığımızagöreşimdibulisteye“AhmetÖzkoparan”öğesinden sonra“FerhatYaz”öğesiniekleyelim.Dikkatlicebakın: içerik.insert(1, "Ferhat Yaz\n") Dediğimiz gibi, f.readlines() satırı bize dosya içeriğini bir liste olarak verdi. Amacımız “Ahmet Özkoparan” öğesinden sonra “Ferhat Yaz” öğesini eklemek. Bunun için, liste metotlarındanbiriolaninsert()metodunukullanaraklistenin1.sırasına“FerhatYaz”öğesini ekledik.Burada“FerhatYaz”öğesinenadlısatırbaşıkarakterinideilaveettiğimizedikkatedin. Bueklemeyinedenyaptığımızıanlamakiçinsatırbaşıkarakteriniçıkarmayıdeneyebilirsiniz. içerik adlı değişkenin değerini istediğimiz biçime getirdiğimize göre bu listeyi tekrar deneme.txtadlıdosyayayazabiliriz.Amabununiçinöncelikledeneme.txtadlıdosyayıyazma modundaaçmamızgerekiyor.Python’dadosyalaryaokumayadayazmamodundaaçılabilir. Okuma modunda açılan bir dosyaya yazılamaz. O yüzden dosyamızı bir de yazma modunda açmamızgerekiyor: 434 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 g = open("deneme.txt", "w") open() fonksiyonunun ilk parametresi dosya adını gösterirken, ikinci parametresi dosyanın hangimoddaaçılacağınıgösteriyor.Bizburadadeneme.txtadlıdosyayıyazmamodundaaçtık. Buradaki “w” parametresi İngilizcede ‘yazmak’ anlamına gelen write kelimesinin ilk harfidir. Birazönceisedeneme.txtdosyasını“r”,yaniokuma(read)modundaaçmıştık. Dosyamızartıküzerineyazmayahazır.Dikkatlicebakın: g.writelines(içerik) Burada,birazönceistediğimizbiçimegetirdiğimiziçerikadlılisteyidoğrudandosyayayazdık. Buişlemiçinwritelines()adlıözelbirmetottanyararlandık.Bumetotlarıbirkaçbölümsonra ayrıntılıolarakinceleyeceğiz.Bizşimdiliksadecesonucaodaklanalım. Yapmamızgerekensonişlem,açıkdosyalarıkapatmakolmalı: f.close() g.close() Şimdikodlaratoplucabirbakalım: f = open("deneme.txt", "r") içerik = f.readlines() içerik.insert(1, "Ferhat Yaz\n") g = open("deneme.txt", "w") g.writelines(içerik) f.close() g.close() Gördüğünüzgibiyaptığımızişlemşubasamaklardanoluşuyor: 1. Öncelikledosyamızıokumamodundaaçıyoruz(f = open("deneme.txt", "r")) 2. Ardındandosyaiçeriğinibirlisteolarakalıyoruz(içerik = f.readlines()) 3. Aldığımız bu listenin 2. sırasına “Ferhat Yaz” öğesini ekliyoruz (içerik.insert(1, "Ferhat Yaz\n")) 4. Listeyi istediğimiz şekle getirdikten sonra bu defa dosyamızı yazma modunda açıyoruz (g = open("deneme.txt", "w")) 5. Birazöncedüzenlediğimizlisteyidosyayayazıyoruz(g.writelines(içerik)) 6. Son olarak da, hem yaptığımız değişikliklerin etkin hale gelebilmesi hem de işletim sisteminin programımıza tahsis ettiği kaynakların serbest kalması için dosyalarımızı kapatıyoruz(f.close()veg.close()) Buradainsert()metodununbizenasılkolaylıksağladığınadikkatedin.insert()metoduda listelerinönemlimetotlarındanbiridirvedediğimizgibi,özellikledosyalarımanipüleederken epeyişimizeyarar. 23.1. ListelerinMetotları 435 PythonBelgeleri,Yayım4.1.3 23.1.4 remove() Bumetotlistedenöğesilmemizisağlar.Örneğin: >>> liste = ["elma", "armut", "çilek"] >>> liste.remove("elma") >>> liste [’armut’, ’çilek’] 23.1.5 reverse() Daha önce verdiğimiz örneklerde, liste öğelerini ters çevirmek için dilimleme yöntemini kullanabileceğimiziöğrenmiştik: >>> meyveler = ["elma", "armut", "çilek", "kiraz"] >>> meyveler[::-1] [’kiraz’, ’çilek’, ’armut’, ’elma’] Eğeristersek,buişiçin,karakterdizileriniincelerkenöğrendiğimizreversed()fonksiyonunu dakullanabiliriz: >>> reversed(meyveler) Bukomutbizeşuçıktıyıverir: <list_reverseiterator object at 0x00DC9810> Demekkireversed()fonksiyonunubirlisteüzerineuyguladığımızda‘list_reverseiterator’adı verilen bir nesne elde ediyoruz. Bu nesnenin içeriğini görmek için birkaç farklı yöntemden yararlanabiliriz.Örneğin: >>> print(*reversed(meyveler)) kiraz çilek armut elma ... veya: >>> print(list(reversed(meyveler))) [’kiraz’, ’çilek’, ’armut’, ’elma’] ... yada: >>> for i in reversed(meyveler): ... print(i) ... kiraz çilek (sonrakisayfayadevam) 436 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) armut elma Gördüğünüz gibi, Python’da bir listeyi ters çevirmenin pek çok yöntemi var. Dilerseniz şimdi buyöntemlerebirtanedahaekleyelim. Python’da listelerin öğelerini ters çevirmek için yukarıdaki yöntemlere ek olarak listelerin reverse()metodunudakullanabilirsiniz: >>> liste = ["elma", "armut", "çilek"] >>> liste.reverse() >>> liste [’çilek’, ’armut’, ’elma’] İhtiyacınızolançıktınıntürüneveşeklinegöreyukarıdakiyöntemlerdenherhangibirinitercih edebilirsiniz. 23.1.6 pop() Tıpkıremove()metodugibi,bumetotdabirlistedenöğesilmemizisağlar: >>> liste = ["elma", "armut", "çilek"] >>> liste.pop() Ancak bu metot, remove() metodundan biraz farklı davranır. pop() metodunu kullanarak bir liste öğesini sildiğimizde, silinen öğe ekrana basılacaktır. Bu metot parametresiz olarak kullanıldığında listenin son öğesini listeden atar. Alternatif olarak, bu metodu bir parametre ilebirliktedekullanabilirsiniz.Örneğin: >>> liste.pop(0) Bukomutlistenin0.öğesinilistedenatarveatılanöğeyiekranabasar. 23.1.7 sort() Yinelistelerinönemlibirmetoduilekarşıkarşıyayız.sort()adlıbuönemlimetotbirlistenin öğelerini belli bir ölçüte göre sıraya dizmemizi sağlar. Basit bir örnek verelim. Diyelim ki elimizdeşöylebirlistevar: üyeler = [’Ahmet’, ’Mehmet’, ’Ceylan’, ’Seyhan’, ’Mahmut’, ’Zeynep’, ’Abdullah’, ’Kadir’, ’Kemal’, ’Kamil’, ’Selin’, ’Senem’, ’Sinem’, ’Tayfun’, ’Tuna’, ’Tolga’] Bulistedekiisimlerimeselaalfabesırasınadizmekiçinsort()metodunukullanabiliriz: >>> üyeler.sort() >>> print(üyeler) (sonrakisayfayadevam) 23.1. ListelerinMetotları 437 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) [’Abdullah’, ’Ahmet’, ’Ceylan’, ’Kadir’, ’Kamil’, ’Kemal’, ’Mahmut’, ’Mehmet’, ’Selin’, ’Senem’, ’Seyhan’, ’Sinem’, ’Tayfun’, ’Tolga’, ’Tuna’, ’Zeynep’] Bu metot elbette yalnızca harfleri alfabe sırasına dizmek için değil sayıları sıralamak için de kullanılabilir: >>> sayılar = [1, 0, -1, 4, 10, 3, 6] >>> sayılar.sort() >>> print(sayılar) [-1, 0, 1, 3, 4, 6, 10] Gördüğünüz gibi, sort() metodu öğeleri artan sıralamaya tabi tutuyor. Yani öğeler ‘a, b, c’ veya1,2,3şeklindesıralanıyor.Bununtersiniyapmakdamümkündür.YaniistersekPython’ın sıralamaişlemini‘c,b,a’şeklindeyapmasınıdasağlayabiliriz.Bununiçinsort()metodunun reverseparametresinikullanacağız: >>> üyeler = [’Ahmet’, ’Mehmet’, ’Ceylan’, ’Seyhan’, ’Mahmut’, ’Zeynep’, ’Abdullah’, ’Kadir’, ’Kemal’, ’Kamil’, ’Selin’, ’Senem’, ’Sinem’, ’Tayfun’, ’Tuna’, ’Tolga’] >>> üyeler.sort(reverse=True) Gördüğünüz gibi sort() metodunun reverse adlı bir parametresine verdiğimiz True değeri sayesindelisteöğeleriniterssıraladık.BuparametreninöntanımlıdeğeriFalse’tur.Yanisort() metodu öntanımlı olarak öğeleri artıra artıra sıralar. Öğeleri azalta azalta sıralamak için reverseparametresininFalseolanöntanımlıdeğeriniTrueyapmamızyeterliolacaktır. Gelin isterseniz sort() metodunu kullanarak bir örnek daha verelim. Elimizde şöyle bir liste olsun: >>> isimler = ["Ahmet", "Işık", "İsmail", "Çiğdem", "Can", "Şule"] Bulistedekiisimlerialfabesırasınadizelim: >>> isimler.sort() >>> isimler [’Ahmet’, ’Can’, ’Işık’, ’Çiğdem’, ’İsmail’, ’Şule’] Gördüğünüz gibi, çıktı pek beklediğimiz gibi değil. Tıpkı karakter dizilerini anlatırken öğrendiğimiz sorted() fonksiyonunda olduğu gibi, listelerin sort() metodu da Türkçe karakterleri düzgün sıralayamaz. Eğer Türkçe karakterleri sıralamamız gereken bir program yazıyorsak bizim sort() metodunun işleyişine müdahale etmemiz gerekir. Temel olarak, sorted() fonksiyonunu anlatırken söylediklerimiz burada da geçerlidir. Orada bahsettiğimiz locale modülü burada da çoğu durumda işimizi halletmemizi sağlar. Ama sorted() fonksiyonunu anlatırken de söylediğimiz gibi, locale modülü burada da ‘i’ ve ‘ı’ harflerini düzgün sıralayamaz. Türkçe harflerin tamamını düzgün sıralayabilmek için şöyle bir kod yazabiliriz: 438 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 harfler = "abcçdefgğhıijklmnoöprsştuüvyz" çevrim = {harf: harfler.index(harf) for harf in harfler} isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule"] isimler.sort(key=lambda x: çevrim.get(x[0])) print(isimler) Bu kodların bir kısmını anlayabiliyor, bir kısmını ise anlayamıyor olabilirsiniz. Çünkü burada henüz işlemediğimiz konular var. Zamanı geldiğinde bu kodların tamamını anlayabilecek duruma geleceksiniz. Siz şimdilik sadece bu kodlardan ne çıkarabildiğinize bakın yeter. Zaten bizim buradaki amacımız, sort() metodunun Türkçe harfleri de düzgün bir şekilde sıralayabileceğinigöstermektenibarettir. Bu arada ufak bir uyarı yapmadan geçmeyelim: Yukarıdaki kodlar da esasında Türkçe kelimeleritamanlamıyladüzgünbirşekildesıralamakiçinyeterlideğil.‘GömülüFonksiyonlar’ konusunuincelerken,yerigeldiğindebukonuyatekrardeğinip,Türkçekelimelerinnasıldoğru, tamveeksiksizbirbiçimdesıralanacağınıdatümayrıntılarıylainceleyeceğiz. 23.1.8 index() Karakter dizileri konusunu anlatırken bu veri tipinin index() adlı bir metodu olduğundan söz etmiştik hatırlarsanız. İşte liste veri tipinin de index() adında ve karakter dizilerinin index()metoduylaaynıişiyapanbirmetodubulunur.Bumetotbirlisteöğesininlisteiçindeki konumunusöylerbize: >>> liste = ["elma", "armut", "çilek"] >>> liste.index("elma") 0 Karakter dizilerinin index() metoduyla ilgili söylediğimiz her şey listelerin index() metodu içindegeçerlidir. 23.1.9 count() Karakter dizileri ile listelerin ortak metotlarından biri de count() metodudur. Tıpkı karakter dizilerinde olduğu gibi, listelerin count() metodu da bir öğenin o veri tipi içinde kaç kez geçtiğinisöyler: >>> liste = ["elma", "armut", "elma", "çilek"] >>> liste.count("elma") 2 Karakter dizilerinin count() metoduyla ilgili söylediğimiz her şey listelerin count() metodu içindegeçerlidir. 23.1. ListelerinMetotları 439 PythonBelgeleri,Yayım4.1.3 23.1.10 copy() Hatırlarsanız, geçen bölümde, listeleri, birbirlerini etkilemeyecek şekilde kopyalamak için şu ikiyöntemikullanmıştık: >>> liste1 = ["ahmet", "mehmet", "özlem"] >>> liste2 = liste1[:] ve: >>> liste2 = list(liste1) İşteaynıişiçinyukarıdakilereekolarakcopy()adlıbirmetottandayararlanabiliriz.Dikkatlice bakın: >>> liste2 = liste1.copy() Hangiyöntemiseçeceğinizsizekalmış... 23.1.11 clear() Listelerleilgiliolarakelealacağımızsonmetodunadıclear().Bumetodungörevibirlistenin içeriğinisilmektir. Diyelimkielimizdeşöylebirlistevar: >>> liste = [1, 2, 3, 5, 10, 20, 30, 45] Bulisteniniçiniboşaltmakiçinclear()metodunukullanabiliriz: >>> liste.clear() >>> liste [] Bu metodun del sözcüğünden farklı olduğunu dikkat edin. clear() metodu listenin içeriğini boşaltırken,delsözcüğülisteyiolduğugibiortadankaldırır. 23.2 Demetlerin Metotları Listelerinmetotlarınıincelediğimizegöre,artıkdemetlerinmetotlarınabakabiliriz. Geçen bölümde de söylediğimiz gibi, listeler ve demetler birbirine benzer. Aralarındaki en önemli fark, listelerin değiştirilebilir bir veri tipi iken, demetlerin değiştirilemez bir veri tipi olmasıdır.Elbettebufark,ikiveritipininmetotlarındadakendinigösterir.Demetlerüzerinde değişiklikyapamadığımıziçin,buveritipideğişiklikyapmayayarayanmetotlarasahipdeğildir. Demetlerinhangimetotlarıolduğunuşukomutlagörebilirsiniz: >>> dir(tuple) Gördüğünüzgibi,buveritipininbiziilgilendirenikimetoduvar: 440 Bölüm23. ListelerinveDemetlerinMetotları PythonBelgeleri,Yayım4.1.3 1. index() 2. count() 23.2.1 index() Listeler ve karakter dizileri konusunu anlatırken bu veri tiplerinin index() adlı bir metodu olduğundan söz etmiştik hatırlarsanız. İşte demet veri tipinin de index() adında ve listelerle karakterdizilerininindex()metoduylaaynıişiyapanbirmetodubulunur.Bumetotbirdemet öğesinindemetiçindekikonumunusöylerbize: >>> demet = ("elma", "armut", "çilek") >>> demet.index("elma") 0 Listelerin ve karakter dizilerinin index() metoduyla ilgili söylediğimiz her şey demetlerin index()metoduiçindegeçerlidir. 23.2.2 count() Karakterdizileri,listelervedemetlerinortakmetotlarındanbiridecount()metodudur.Tıpkı karakterdizilerivelistelerdeolduğugibi,demetlerincount()metodudabiröğeninoveritipi içindekaçkezgeçtiğinisöyler: >>> demet = ("elma", "armut", "elma", "çilek") >>> demet.count("elma") 2 Karakter dizilerinin ve listelerin count() metoduyla ilgili söylediğimiz her şeydemetlerin count()metoduiçindegeçerlidir. 23.2. DemetlerinMetotları 441 24 BÖLÜM Sayma Sistemleri Sayılar olmadan bilgisayar ve programlama düşünülemez. O yüzden, önceki derslerimizde karakter dizilerini anlatırken şöyle bir değinip geçtiğimiz sayılar konusunu, sayma sistemleri konusunu da ilave ederek, birer programcı adayı olan bizleri yakından ilgilendirdiği için mümkünolduğuncaayrıntılıbirşekildeelealmayaçalışacağız. SayılarveSaymaSistemlerikonusunuikifarklıbölümdeinceleyeceğiz. Sayılarkonusununtemelinioluşturduğuiçin,önceliklesaymasistemlerindensözedelim. Öncelikle ‘sayma sistemi’ kavramını tanımlayarak işe başlayalım. Nedir bu ‘sayma sistemi’ denenşey? Saymaişlemininhangiölçütleregöreyapılacağınıbelirleyenkurallarbütününesaymasistemi adıverilir. Dünyadayaygınolarakkullanılandörtfarklısaymasistemivardır.Bunlar,onlu,sekizli,onaltılı veikilisaymasistemleridir.Budördüarasındaenyaygınkullanılansaymasistemiise,tabiiki, onlusistemdir.İnsanlarınelleriveayaklarındaonparmakolduğunudüşünürsek,busistemin nedendahayaygınkullanıldığınıanlamakaslındahiçdezordeğil! Onlu sistemin yaygınlığını düşünerek, sayma sistemleri konusunu anlatmaya onlu sayma sistemindenbaşlayalım. 24.1 Onlu Sayma Sistemi Biz insanlar genellikle hesap işlemleri için onlu sayma sistemini kullanırız. Hepinizin bildiği gibi bu sistem; 0, 1, 2, 3, 4, 5, 6, 7, 8 ve 9 olmak üzere toplam on rakamdan oluşur. Yani sayılarıgösteren,birbirindenfarklıtoplamonsimge(rakam)vardırbusistemde.Buonsimgeyi kullanarak,olasıbütünsayılarıgösterebiliriz. Buaradaterminolojiileilgiliufakbiraçıklamayapalım: Rakamlar, sayıları göstermeye yarayan simgelerdir. Onlu sayma sisteminde toplam on farklı rakamvardır.Bütünrakamlarbirersayıdır,amabütünsayılarbirerrakamdeğildir.Örneğin8 442 PythonBelgeleri,Yayım4.1.3 hembirrakamhemdebirsayıdır.Ancakmesela32birsayıolupbusayı,3ve2adlıikifarklı rakamınbirarayagetirilmesiilegösterilir.Yani32sayısıtekbaşınabirrakamdeğildir. Açıklamamızıdayaptığımızagöreyolumuzadevamedebiliriz. İnsanlaryukarıdabahsettiğimizbuonlusistemevebusistemioluşturanrakamlara/simgelere o kadar alışmıştır ki, çoğu zaman başka bir sistemin varlığından veya var olma olasılığından haberdarbiledeğildir. Amaelbettedünyaüzerindekiteksaymasistemionlusistemolmadığıgibi,sayılarıgöstermek içinkullanılabilecekrakamlardayukarıdakilerlesınırlıdeğildir. Nihayetinderakamdediğimizşeylerinsanicadıbirtakımsimgelerdenibarettir.Elbettedoğada ‘2’ veya ‘7’ diye bir şey bulunmaz. Bizim yaygın olarak yukarıdaki şekilde gösterdiğimiz rakamlar Arap rakamlarıdır. Mesela Romalılar yukarıdakiler yerine I, II, III, IV, V, VI, VII, VIII, IXveXgibifarklısimgelerkullanıyordu... Neticede2veIIaynıkavramaişaretediyor.Sadece kullanılansimgelerbirbirindenfarklı,okadar. Onlu sayma sisteminde bir sayıyı oluşturan rakamlar 10’un kuvvetleri olarak hesaplanır. Örneğin 1980 sayısını ele alalım. Bu sayıyı 10’un kuvvetlerini kullanarak şu şekilde hesaplayabiliriz: >>> (0 * (10 ** 0)) + (8 * (10 ** 1)) + (9 * (10 ** 2)) + (1 * (10 ** 3)) 1980 Gördüğünüz gibi, sayının en sağındaki basamak 10’un 0. kuvveti olacak şekilde, sola doğru kuvvetiartırarakilerliyoruz. Gelelimötekisaymasistemlerine... 24.2 Sekizli Sayma Sistemi Onlu sayma sisteminin aksine sekizli sayma sisteminde toplam sekiz rakam bulunur. Bu rakamlarşunlardır: 0,1,2,3,4,5,6,7 Gördüğünüzgibi,onlusistemdetoplamonfarklısimgevarken,sekizlisistemdetoplamsekiz farklısimgevar. Bu bölümün en başında da söylediğimiz gibi, insanlar onlu sayma sistemine ve bu sistemi oluşturan simgelere o kadar alışmıştır ki, çoğu zaman başka bir sistemin varlığından veya varolmaolasılığındanhaberdarbiledeğildir.Hattabaşkasaymasistemlerindenbirvesileyle haberdar olup, bu sistemleri öğrenmeye çalışanlar onlu sayma sistemine olan alışkanlıkları nedeniyle yeni sayma sistemlerini anlamakta dahi zorluk çekebilirler. Bunun birincil nedeni, iyitanıdıklarınızannettiklerionlusistemideaslındaokadariyitanımıyorolmalarıdır. O halde başka sayma sistemlerini daha iyi anlayabilmek için öncelikle yaygın olarak kullandığımızsaymasistemininnasılişlediğinianlamayaçalışalım: Onlusistemdetoplamonfarklısimgebulunur: 0,1,2,3,4,5,6,7,8,9 9’danbüyükbirsayıyıgöstermekgerektiğindesimgelistesininenbaşınadönülürvebasamak sayısıbirartırılarak,sembollerbirleştirilir: 24.2. SekizliSaymaSistemi 443 PythonBelgeleri,Yayım4.1.3 10,11,12,13,14,15,16,17,18,19,20,...,99,100,...,999,1000 İştebukuralötekisaymasistemleriiçindegeçerlidir.Meselasekizlisaymasisteminielealalım. Dediğimizgibi,sekizlisistemdetoplamsekizfarklısimgebulunur: 0,1,2,3,4,5,6,7 Bu sistemde 7’den büyük bir sayıyı göstermek gerektiğinde, tıpkı onlu sistemde olduğu gibi, simge listesinin en başına dönüyoruz ve basamak sayısını bir artırarak sembolleri birleştiriyoruz: 10,11,12,13,14,15,16,17,20,...,77,100 Onlu sayma sistemi ile sekizli sayma sistemi arasındaki farkı daha belirgin bir şekilde görebilmekiçinşukodlarıyazalım: sayı_sistemleri = ["onlu", "sekizli"] print(("{:^5} "*len(sayı_sistemleri)).format(*sayı_sistemleri)) for i in range(17): print("{0:^5} {0:^5o}".format(i)) Bukodlardaöğrenmediğimizveanlayamayacağımızhiçbirşeyyok.Bukodlarıoluşturanbütün parçalarıöncekiderslerimizdeayrıntılıolarakincelemiştik. Bukodlardanşöylebirçıktıalacağız: onlu sekizli 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 10 9 11 10 12 11 13 12 14 13 15 14 16 15 17 16 20 Gördüğünüz gibi, onlu sistemde elimizde toplam on farklı simge olduğu için, elimizdeki simgeleri kullanarak 10. sayıya kadar ilerleyebiliyoruz. Bu noktadan sonra simge stoğumuz tükendiğiiçinenbaşadönüpbirbasamakartırıyoruzvesimgeleribirbiriylebirleştirerekyeni sayılareldeediyoruz. Sekizli sistemde ise elimizde yalnızca sekiz farklı simge olduğu için, elimizdeki simgeleri kullanarak ancak 8. sayıya kadar gelebiliyoruz. Öteki sayıları gösterebilmek için bu noktadan 444 Bölüm24. SaymaSistemleri PythonBelgeleri,Yayım4.1.3 sonrabaşadönüpbirartırmamızvesimgeleribirbiriylebirleştirerekyenisayılareldeetmemiz gerekiyor. Sekizli sayma sisteminde bir sayıyı oluşturan rakamlar 8’in kuvvetleri olarak hesaplanır. Örneğin sekizli sayma sistemindeki 3674 sayısını ele alalım. Bu sayıyı 8’in kuvvetlerini kullanarakşuşekildehesaplayabiliriz: >>> (4 * (8 ** 0)) + (7 * (8 ** 1)) + (6 * (8 ** 2)) + (3 * (8 ** 3)) 1980 Buhesaplamaşeklinionlusaymasistemindenhatırlıyorolmalısınız.Gördüğünüzgibi,sekizli sistemdeki bir sayının her bir basamağını 8’in kuvvetleri olarak hesapladığımızda, bu sayının onlusistemdekikarşılığınıeldeediyoruz. 24.3 On Altılı Sayma Sistemi Şuanakadaronluvesekizlisaymasistemlerindenbahsettik.Önemlibirbaşkasaymasistemi deonaltılısaymasistemidir. Onlusaymasistemindeonfarklırakam,sekizlisaymasistemindesekizfarklırakamolduğunu öğrenmiştik. On altılı sayma sisteminde ise, tahmin edebileceğiniz gibi, on altı farklı rakam bulunur: 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f Şimdiye kadar öğrenmiş olduğumuz sayma sistemleri arasındaki farkı daha net görmek için birazönceyazdığımızkodlaraonaltılısaymasisteminideekleyelim: sayı_sistemleri = ["onlu", "sekizli", "on altılı"] print(("{:^8} "*len(sayı_sistemleri)).format(*sayı_sistemleri)) for i in range(17): print("{0:^8} {0:^8o} {0:^8x}".format(i)) Buradanşöylebirçıktıalacağız: onlu sekizli on altılı 0 0 0 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5 6 6 6 7 7 7 8 10 8 9 11 9 10 12 a 11 13 b 12 14 c (sonrakisayfayadevam) 24.3. OnAltılıSaymaSistemi 445 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 13 15 d 14 16 e 15 17 f 16 20 10 Gördüğünüzgibi,onlusistemdebirbirindenfarklıtoplam10adetrakam/simgevarken,sekizli sistemde toplam 8 farklı simge, on altılı sistemde ise toplam 16 farklı simge var. Yani onlu sistemdeolasıbütünsayılareldeki10farklısimgevebunlarınkombinasyonununkullanılması yoluyla; sekizli sistemde 8 farklı simge ve bunların kombinasyonunun kullanılması yoluyla; on altılı sistemde ise 16 farklı simge ve bunların kombinasyonunun kullanılması yoluyla gösteriliyor. Bu sebeple onlu sistemde 9 sayısından itibaren bir basamak artırılıp simge listesinin başına dönülürken, sekizli sistemde 7 sayısından itibaren; on altılı sistemde ise f sayısındanitibarenbaşadönülüyor. Onaltılısistemde9sayısındansonragelenharfleriyadırgamışolabilirsiniz.Budurumuşöyle düşünün: Sayı dediğimiz şeyler insan icadı birtakım simgelerden ibarettir. Daha önce de söylediğimizgibi,doğada‘2’veya‘7’diyebirşeygöremezsiniz... İşte on altılık sistemdeki sayıları gösterebilmek için de birtakım simgelere ihtiyaç var. İlk on simge, onluk sayma sistemindekilerle aynı. Ancak 10’dan sonraki sayıları gösterebilmek için elimizde başka simge yok. On altılık sistemi tasarlayanlar, bir tercih sonucu olarak, eksik sembollerialfabeharfleriyletamamlamayıtercihetmişler.AlfabeharfleriyerinepekalaRoma rakamlarını da tercih edebilirlerdi. Eğer bu sistemi tasarlayanlar böyle tercih etmiş olsaydı bugünonaltılıksistemişöylegösteriyorolabilirdik: 0 1 2 3 4 5 6 7 8 9 I II III IV V VI Bugünbusayılarıbuşekildekullanmıyorolmamızınteksebebi,sistemitasarlayanlarınbunu böyletercihetmemişolmasıdır... On altılı sayma sisteminde bir sayıyı oluşturan rakamlar 16’nın kuvvetleri olarak hesaplanır. Peki ama bu sayma sistemindeki a, b, c, d, e ve f harfleriyle nasıl aritmetik işlem yapacağız? Örneğin on altılı sayma sistemindeki 7bc sayısını ele alalım. Bu sayının onlu sistemdeki karşılığını 16’nın kuvvetlerini kullanarak hesaplayabiliriz hesaplamasına, ama peki yukarıda bahsettiğimizharflerneolacak?Yanişöylebirişlemtabiikimümkündeğil: 446 Bölüm24. SaymaSistemleri PythonBelgeleri,Yayım4.1.3 >>> ((c * 16 ** 0)) + ((b * 16 ** 1)) + ((7 * 16 ** 2)) Elbette c ve b sayılarını herhangi bir aritmetik işlemde kullanamayız. Bunun yerine, bu harflerinonlusistemdekikarşılıklarınıkullanacağız: a–>10 b–>11 c–>12 d–>13 e–>14 f–>15 Bunagöre: >>> ((12 * (16 ** 0)) + ((11 * (16 ** 1)) + ((7 * (16 ** 2)) 1980 Demekkionaltılısistemdeki‘7bc’sayısınınonlusistemdekikarşılığı1980’miş. 24.4 İkili Sayma Sistemi Bildiğiniz,veyaoradaburadaduymuşolabileceğinizgibi,bilgisayarlarıntemelindeikitanesayı vardır:0ve1.Bilgisayarlarbütünişlemlerisadecebuikisayıileyerinegetirir. Onlu, sekizli ve on altılı sayı sistemleri dışında, özellikle bilgisayarların altyapısında tercih edilen bir başka sayı sistemi daha bulunur. İşte bu sistemin adı ikili (binary) sayı sistemidir. Nasıl onlu sistemde 10, sekizli sistemde 8, on altılı sistemde ise sayıları gösteren 16 farklı simgevarsa,busayısistemindedesayılarıgösterentoplamikifarklısembolvardır:0ve1. İkilisayısistemindeolasıbütünsayılariştebuikisimgeilegösterilir. Gelinistersenizdurumudahanetbirşekildegörebilmekiçinyukarıdaverdiğimizsayısistemi tablosunaikilisayılarıdaekleyelim: sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"] print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri)) for i in range(17): print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i)) Bukodlarşuçıktıyıverecektir: onlu sekizli on altılı ikili 0 0 0 0 1 1 1 1 2 2 2 10 3 3 3 11 (sonrakisayfayadevam) 24.4. İkiliSaymaSistemi 447 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 4 4 4 100 5 5 5 101 6 6 6 110 7 7 7 111 8 10 8 1000 9 11 9 1001 10 12 a 1010 11 13 b 1011 12 14 c 1100 13 15 d 1101 14 16 e 1110 15 17 f 1111 16 20 10 10000 Burada, onlu, sekizli ve on altılı sayı sistemleri için geçerli olan durumun aynen ikili sayı sistemiiçindegeçerliolduğunurahatlıklagörebiliyoruz.İkilisayısistemindekimevcutsayıları gösterebilmemiz için toplam iki farklı simge var. Bunlar: 0 ve 1. İkili sayı sisteminde 0 ve 1 diye saymaya başlayıp üçüncü sayıyı söylememiz gerektiğinde, elimizde 0 ve 1’den başka simge olmadığı için bir basamak artırıp simge listesinin başına dönüyoruz ve böylece onluk düzendeki 2 sayısını ikili düzende gösterebilmek için 0 ve 1’den sonra 10 simgesini kullanıyoruz. Busöylediklerimizdensonraİnternetüzerindesıkçakarşılaştığınızşusözünanlamınıherhalde artıkdahaiyianlıyorolmalısınız: İnsanlar10’aayrılır:İkilisistemibilenlervebilmeyenler! Bu arada, elbette ikili düzendeki 10 sayısı ‘on’ şeklinde telaffuz edilmiyor. Bu sayıyı “bir-sıfır” diyeseslendiriyoruz... İkilisaymasistemindebirsayıyıoluşturanrakamlar2’ninkuvvetleriolarakhesaplanır.Örneğin ikili sayma sistemindeki 1100 sayısını ele alalım. Bu sayıyı 2’nin kuvvetlerini kullanarak şu şekildehesaplayabiliriz: >>> (0 * (2 ** 0)) + (0 * (2 ** 1)) + (1 * (2 ** 2)) + (1 * (2 ** 3)) 12 Demekki‘1100’sayısıonlusistemde12sayısınakarşılıkgeliyormuş. 24.5 Sayma Sistemlerini Birbirine Dönüştürme Sıklıkla kullanılan dört farklı sayma sistemini öğrendik. Peki biz bir sayma sisteminden öbürüne dönüştürme işlemi yapmak istersek ne olacak? Örneğin onlu sistemdeki bir sayıyı ikilisistemenasılçevireceğiz? Python programlama dilinde bu tür işlemleri kolaylıkla yapmamızı sağlayan birtakım fonksiyonlar bulunur. Ayrıca özel fonksiyonları kullanmanın yanısıra karakter dizisi biçimlendirme (string formatting) yöntemlerini kullanarak da sayma sistemlerini birbirine dönüştürebiliriz.Bizburadaherikiyöntemidetektekinceleyeceğiz. 448 Bölüm24. SaymaSistemleri PythonBelgeleri,Yayım4.1.3 Gelin isterseniz bu dönüştürme işlemleri için hangi özel fonksiyonların olduğuna bakalım önce. 24.5.1 Fonksiyon Kullanarak bin() Bufonksiyonbirsayınınikili(binary)sayısistemindekikarşılığınıverir: >>> bin(2) ’0b10’ Bu fonksiyonun çıktı olarak bir karakter dizisi verdiğine dikkat edin. Bu karakter dizisinin ilk iki karakteri (‘0b’), o sayının ikili sisteme ait bir sayı olduğunu gösteren bir işarettir. Bu bilgilerdenyolaçıkarak,yukarıdakikarakterdizisiningerçekikilikısmınıalmakiçinşuyöntemi kullanabilirsiniz: >>> bin(2)[2:] ’10’ hex() Bufonksiyon,herhangibirsayıyıalıp,osayınınonaltılısistemdekikarşılığınıverir: >>> hex(10) ’Oxa’ Tıpkı bin() fonksiyonunda olduğu gibi, hex() fonksiyonunun da çıktı olarak bir karakter dizisi verdiğine dikkat edin. Hatırlarsanız bin() fonksiyonunun çıktısındaki ilk iki karakter (0b), o sayının ikili sisteme ait bir sayı olduğunu gösteren bir işaret olarak kullanılıyordu. hex()fonksiyonununçıktısındakiilkikikarakterde(0x),osayınınonaltılısistemeaitbirsayı olduğunugösteriyor. oct() Bufonksiyon,herhangibirsayıyıalıp,osayınınsekizlisistemdekikarşılığınıverir: >>> oct(10) ’0o12’ Tıpkı bin() ve hex() fonksiyonlarında olduğu gibi, oct() fonksiyonunun da çıktı olarak bir karakterdizisiverdiğinedikkatedin.Hatırlarsanızbin()vehex()fonksiyonlarınınçıktısındaki ilk iki karakter (0b ve 0x), o sayıların hangi sisteme ait sayılar olduğunu gösteriyordu. Aynı şekilde oct() fonksiyonunun çıktısındaki ilk iki karakter de (0o), o sayının sekizli sisteme ait birsayıolduğunugösteriyor. 24.5. SaymaSistemleriniBirbirineDönüştürme 449 PythonBelgeleri,Yayım4.1.3 int() Aslında biz bu fonksiyonu yakından tanıyoruz. Bildiğiniz gibi bu fonksiyon herhangi bir sayı veya sayı değerli karakter dizisini tam sayıya (integer) dönüştürmek için kullanılıyor. int() fonksiyonunun şimdiye kadar gördüğümüz işlevi dışında bir işlevi daha bulunur: Biz bu fonksiyonukullanarakherhangibirsayıyıonlusistemdekikarşılığınadönüştürebiliriz: >>> int(’7bc’, 16) 1980 Gördüğünüz gibi, bu fonksiyonu kullanırken dikkat etmemiz gereken bazı noktalar var. İlkin, eğer int() fonksiyonunu yukarıdaki gibi bir dönüştürme işlemi için kullanacaksak, bu fonksiyona verdiğimiz ilk parametrenin bir karakter dizisi olması gerekiyor. Dikkat etmemizgerekenikincinokta,int()fonksiyonunaverdiğimizikinciparametreninniteliği.Bu parametre, dönüştürmek istediğimiz sayının hangi tabanda olduğunu gösteriyor. Yukarıdaki örneğegörebiz,onaltıtabanındaki7bcsayısınıontabanınadönüştürmekistiyoruz. Birdeşuörneklerebakalım: >>> int(’1100’, 2) 12 >>> int(’1100’, 16) 4352 İlkörnekte,ikilisistemdeki1100sayısınıonlusistemeçeviriyoruzve12sayısınıeldeediyoruz. İkinci örnekte ise on altılı sistemdeki 1100 sayısını onlu sisteme çeviriyoruz ve 4352 sayısını eldeediyoruz. 24.5.2 Biçimlendirme Yoluyla Esasında biz karakter dizisi biçimlendirme yöntemlerini kullanarak dönüştürme işlemlerini nasılgerçekleştireceğimizibiliyoruz.Bizburadazatenöğrendiğimizbubilgileritekrarederek öğrendiklerimizipekiştirmeamacıgüdeceğiz. b Bukarakterikullanarakbirsayıyıikilidüzendekikarşılığınadönüştürebiliriz: >>> ’{:b}’.format(12) ’1100’ Bukarakter,bin()fonksiyonuylaaynıişiyapar. 450 Bölüm24. SaymaSistemleri PythonBelgeleri,Yayım4.1.3 x Bukarakterikullanarakbirsayıyıonaltılıdüzendekikarşılığınadönüştürebiliriz: >>> ’{:x}’.format(1980) ’7bc’ Bukarakter,hex()fonksiyonuylaaynıişiyapar. o Bukarakterikullanarakbirsayıyısekizlidüzendekikarşılığınadönüştürebiliriz: >>> ’{:o}’.format(1980) ’3674’ Bukarakter,oct()fonksiyonuylaaynıişiyapar. Bütün bu anlattıklarımızdan sonra (eğer o zaman anlamakta zorluk çekmişseniz) aşağıdaki kodlarıdahaiyianlamışolmalısınız: sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"] print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri)) for i in range(17): print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i)) Bu arada, yukarıda bir sayının, karakter dizisi biçimlendirme yöntemleri kullanılarak ikili, sekizli ve on altılı düzene nasıl çevrileceğini gördük. Bir sayıyı onlu düzene çevirmek için ise sadece int() fonksiyonunu kullanabiliyoruz. Böyle bir çevirme işlemini karakter dizisi biçimlendirme yöntemlerini kullanarak yapamıyoruz. Ama elbette, eğer başka bir sayma sisteminden onlu sisteme çevirdiğiniz bir sayıyı herhangi bir karakter dizisi içinde biçimlendirmekistersenizşöylebirkodkullanabilirsiniz: >>> n = ’7bc’ >>> "{} sayısının onlu karşılığı {:d} sayısıdır.".format(n, int(n, 16)) ...veya: >>> n = ’7bc’ >>> "{} sayısının onlu karşılığı {} sayısıdır.".format(n, int(n, 16)) Zira bildiğiniz gibi, Python’da onlu sayıları temsil eden harf d harfidir. Eğer {} yapısı içinde herhangi bir harf kullanmazsanız yukarıdaki durumda Python {:d} yazmışsınız gibi davranacaktır. 24.5. SaymaSistemleriniBirbirineDönüştürme 451 PythonBelgeleri,Yayım4.1.3 24.6 Sayma Sistemlerinin Birbirlerine Karşı Avantajları Böylece dört farklı sayı sisteminin hangi mantık üzerine işlediğini anlamış olduk. Ayrıca sayı sistemleriarasındadönüştürmeişlemlerinideöğrendik. İştebilgisayarlarbusayısistemleriarasındasadeceikilisayısistemini‘anlayabilir’.Aslındabu da hiç mantıksız değil. Bilgisayar dediğimiz şey, üzerinden elektrik geçen devrelerden ibaret bir makinedir. Eğer bir devrede elektrik yoksa o devrenin değeri ~0 volt iken, o devreden elektrik geçtiğinde devrenin değeri ~5 volttur. Gördüğünüz gibi, ortada iki farklı değer var: ~0 volt ve ~5 volt. Yukarıda anlattığımız gibi, ikili (binary) sayma sisteminde de iki değer bulunur: 0 ve 1. Dolayısıyla ikili sayma sistemi bilgisayarın iç işleyişine en uygun sistemdir. ikili sistemde ~0 volt’u 0 ile, ~5 volt’u ise 1 ile temsil edebiliyoruz. Yani devreden elektrik geçtiğinde o devrenin değeri 1, elektrik geçmediğinde ise 0 olmuş oluyor. Tabii bilgisayar açısından bakıldığında devrede elektrik vardır veya yoktur. Biz insanlar bu ikili durumu daha kolaybirşekildetemsiledebilmekiçinherbirduruma0ve1gibibiradveriyoruz. Bilgisayarın işlemcisi sadece bu iki farklı durumu kullanarak her türlü hesaplama işlemini gerçekleştirebilir. Bu sebeple ikili sayı sistemi bilgisayarın çalışma mantığı için gayet yeterli ve uygundur. İkili sayı sistemi yerine mesela onlu sayı sistemini kullanmak herhalde simge israfından başka bir şey olmazdı. Neticede, dediğimiz gibi, bilgisayarın işleyebilmesi için iki farklısimgeyeterlidir. Dediğimiz gibi, ikili sayma sistemi bilgisayarın yapısına gayet uygundur. Ama biz insanlar açısından sadece iki simge yardımıyla saymaya çalışmak epey zor olacaktır. Ayrıca sayı büyüdükçe, ikili sistemde sayının kapladığı alan hızla ve kolayca artacak, yığılan bu sayıları idareetmekhiçdekolayolmayacaktır.İştebunoktadadevreyeonaltılı(hexadecimal)sayılar girer.Busaymasistemindetoplam16farklırakam/simgeolduğuiçin,büyüksayılarçokdaha azyerkaplayacakşekildegösterilebilir. Bildiğiniz gibi, ikili sayma sistemindeki her bir basamağa ‘bit’ adı verilir. İkili sayma sistemini kullanarak, 0’dan 256’ya kadar sayabilmek için toplam 8 bitlik (yani 8 hanelik) bir yer kullanmanız gerekir. On altılı sistemde ise bu işlemi sadece iki basamakla halledebilirsiniz. Yanionaltılısistemde00ileFFarasınatoplam255tanesayısığdırılabilir.Dolayısıylaonaltılı sistemikullanarak,çokbüyüksayılarıçokazyerkullanarakgösterebilirsiniz: >>> for i in range(256): ... print(i, bin(i)[2:], hex(i)[2:]) ... 0 0 0 (...) 255 11111111 ff >>> Gördüğünüzgibi,onlusistemde255şeklinde,ikilisistemdeise11111111şeklindegösterilen sayı on altılı sistemde yalnızca ff şeklinde gösterilebiliyor. Dolayısıyla, kullanım açısından, biz insanlar için on altılık sayma sisteminin ikili sisteme kıyasla çok daha pratik bir yöntem olduğunusöyleyebiliriz. Ayrıca on altılı sistem, az alana çok veri sığdırabilme özelliği nedeniyle HTML renk kodlarının gösterilmesinde de tercih edilir. Örneğin beyaz rengi temsil etmek için on altılı sistemdeki #FFFFFF ifadesini kullanmak rgb(255,255,255) ifadesini kullanmaya kıyasla çok dahamantıklıdır.Hatta#FFFFFFifadesini#FFFşeklindekısaltmaimkanıdahivardır. 452 Bölüm24. SaymaSistemleri 25 BÖLÜM Sayılar Geçenbölümdesaymasistemleriniayrıntılıbirşekildeinceledik.Bubölümdeiseyinebununla bağlantılı bir konu olan sayılar konusunu ele alacağız. Esasında biz sayıların ne olduğuna ve Python’da bunların nasıl kullanılacağına dair tamamen bilgisiz değiliz. Buraya gelene kadar, sayılar konusunda epey şey söyledik aslında. Mesela biz Python’da üç tür sayı olduğunu biliyoruz: 1. TamSayılar(integers) 2. KayanNoktalıSayılar(floatingpointnumbersveyakısacafloats) 3. KarmaşıkSayılar(complexnumbers) Eğerbirveritype(veri)sorgulamasınaintcevabıveriyorsaoveribirtamsayıdır.Eğerbirveri type(veri)sorgulamasınafloatcevabıveriyorsaoveribirkayannoktalısayıdır.Eğerbirveri type(veri)sorgulamasınacomplexcevabınıveriyorsaoveribirkarmaşıksayıdır. Meselaşunlarbirertamsayıdır: 15,4,33 Şunlarbirerkayannoktalısayıdır: 3.5,6.6,2.3 Şunlarsabirerkarmaşıksayıdır: 3+3j,5+2j,19+10j Ayrıca şimdiye kadar öğrendiklerimiz sayesinde bu sayıların çeşitli fonksiyonlar yardımıyla birbirlerinedönüştürülebileceğinidebiliyoruz: tabularytabulary Fonksiyon Görevi Örnek int() Birveriyitamsayıyadönüştürür int(’2’) float() Birveriyikayannoktalısayıyadönüştürür float(2) complex() Birveriyikarmaşıksayıyadönüştürür complex(2) 453 PythonBelgeleri,Yayım4.1.3 Dediğimiz gibi, bunlar bizim zaten sayılara dair bildiğimiz şeyler. Elbette bir de henüz öğrenmediklerimizvar. Gelinşimdibunlarınnelerolduğunuinceleyelim. 25.1 Sayıların Metotları Tıpkı öteki veri tiplerinde olduğu gibi, sayıların da bazı metotları bulunur. Bu metotları kullanaraksayılarüzerindeçeşitliişlemlergerçekleştirebiliriz. 25.1.1 Tam Sayıların Metotları Dediğimizgibi,Python’dabirkaçfarklısayıtipibulunur.Bizilkolaraktamsayı(integer)denen sayıtipininmetotvenitelikleriniinceleyeceğiz. Önceliklehangimetotlarveniteliklerlekarşıkarşıyaolduğumuzabakalım: >>> [i for i in dir(int) if not i.startswith("_")] [’bit_length’, ’conjugate’, ’denominator’, ’from_bytes’, ’imag’, ’numerator’, ’real’, ’to_bytes’] Bulistedeşimdilikbiziilgilendirentekbirmetotvar.Bumetodunadıbit_length(). bit_length() Bilgisayarlarhakkındabilmemizgerekenenönemlibilgilerdenbirişudur:Bilgisayarlarancak veancaksayılarlaişlemyapabilir.Bilgisayarlarınişlemyapabildiğisayılardaonlusistemdeki sayılardeğil,ikilisistemdekisayılardır.Yani0’larve1’ler. Bilgisayar terminolojisinde bu 0’lar ve 1’lerden oluşan herbir basamağa ‘bit’ adı verilir. Yani ikilisaymasisteminde‘0’ ve‘1’sayılarındanherbiri1bit’tir.Mesela onlusistemde2sayısının ikili sistemdeki karşılığı olan 10 sayısı iki bit’lik bir sayıdır. Onlu sistemdeki 100 sayısının ikili sistemdekikarşılığıolan1100100sayısıiseyedibitlikbirsayıdır. Budurumudahanetbirşekildegörebilmekiçinşukodlarıyazalım: >>> for i in range(11): ... print(i, bin(i)[2:], len(bin(i)[2:]), sep="\t") ... 0 0 1 1 1 1 2 10 2 3 11 2 4 100 3 5 101 3 6 110 3 7 111 3 8 1000 4 9 1001 4 10 1010 4 454 Bölüm25. Sayılar PythonBelgeleri,Yayım4.1.3 Burada ikinci sütundaki sayılar ilk sütundaki sayıların ikili sistemdeki karşılıklarıdır. Üçüncü sütundaki sayılar ise her bir sayının kaç bit olduğunu, yani bir bakıma ikili sayma sisteminde kaçbasamağasahipolduğunugösteriyor. İşte herhangi bir tam sayının kaç bit’lik bir yer kapladığını öğrenmek için, tam sayıların metotlarındanbiriolanbit_length()metodundanyararlanacağız: >>> sayı = 10 >>> sayı.bit_length() 4 Demek ki 10 sayısı bellekte dört bitlik bir yer kaplıyormuş. Yani bu sayının ikili sistemdeki karşılığıolan1010sayısıdörtbasamaktanoluşuyormuş. Yukarıdakiörneklerdenderahatlıklaçıkarabileceğinizgibi,bit_length()metodu,ikilisayma sistemindekibirsayıüzerinelen()fonksiyonununuygulanmasıileeşdeğerdir.Yani: >>> len(bin(10)[2:]) == (10).bit_length() True Buaradaşusonörnektebirşeydikkatiniziçekmişolmalı:bit_length()metodunudoğrudan sayılarüzerineuygulayamıyoruz.Yani: >>> 10.bit_length() File "<stdin>", line 1 10.bit_length() ^ SyntaxError: invalid syntax Bu metodu sayılarla birlikte kullanabilmek için iki seçeneğimiz var: bit_length() metodunu uygulamakistediğimizsayıyıöncebirdeğişkeneatayabiliriz: >>> a = 10 >>> a.bit_length() 4 ...veyailgilisayıyıparanteziçinealabiliriz: >>> (10).bit_length() 4 Bu durum, yani sayıyı parantez içinde gösterme zorunluluğu, 10 sayısının sağına bir nokta işaretikoyduğumuzda,Python’ınbusayıyıbirkayannoktalısayıolarakdeğerlendirmesinden kaynaklanıyor.Yanibiz‘10’yazıp,bit_length()metodunubusayıyabağlamaamacıylasayının sağına bir nokta koyduğumuz anda, Python bu sayının bir kayan noktalı sayı olduğunu zannediyor.ÇünküPythonaçısından,10.sayısıbirkayannoktalısayıdır.Bunuteyitedelim: >>> type(10.) <class ’float’> 25.1. SayılarınMetotları 455 PythonBelgeleri,Yayım4.1.3 Kayannoktalısayılarınbit_length()adlıbirmetoduolmadığıiçindePython’ınbizebirhata mesajıgöstermektenbaşkayapabileceğibirşeykalmıyor. 25.1.2 Kayan Noktalı Sayıların Metotları Python’datamsayılardışındakayannoktalısayılarındaolduğunubiliyoruz.Busayıtipininşu metotlarıvardır: >>> [i for i in dir(float) if not i.startswith("_")] [’as_integer_ratio’, ’conjugate’, ’fromhex’, ’hex’, ’imag’, ’is_integer’, ’real ’] ˓→ Bizbumetotlararasından,as_integer_ratio()veis_integer()adlımetotlarlailgileneceğiz. as_integer_ratio() Bumetot,birbirinebölündüğündeilgilikayannoktalısayıyıverenikiadettamsayıverirbize. Örneküzerindenaçıklayalım: >>> sayı = 4.5 >>> sayı.as_integer_ratio() (9, 2) 9sayısını2sayısınaböldüğümüzde4.5sayısınıeldeederiz.İşteas_integer_ratio()metodu, bu9ve2sayılarınıbizeayrıayrıverir. is_integer() Bir kayan noktalı sayının ondalık kısmında 0 harici bir sayının olup olmadığını kontrol etmek içinbumetodukullanıyoruz.Örneğin: >>> (12.0).is_integer() True >>> (12.5).is_integer() False 456 Bölüm25. Sayılar PythonBelgeleri,Yayım4.1.3 25.1.3 Karmaşık Sayıların Metotları Gelelimkarmaşıksayılarınmetotveniteliklerine... >>> [i for i in dir(complex) if not i.startswith("_")] [’conjugate’, ’imag’, ’real’] Gördüğünüzgibi,karmaşıksayılarındabirkaçtanemetotveniteliğivar.Bizbunlararasından imagverealadlınitelikleriinceleyeceğiz. imag Bir gerçek bir de sanal kısımdan oluşan sayılara karmaşık sayılar (complex) adı verildiğini biliyorsunuz.Örneğinşubirkarmaşıksayıdır: 12+4j İşteimagadlınitelik,bizebirkarmaşıksayınınsanalkısmınıverir: >>> c = 12+4j >>> c.imag 4.0 real realadlınitelikbizebirkarmaşıksayınıngerçekkısmınıverir: >>> c = 12+4j >>> c.real 12.0 25.2 Aritmetik Fonksiyonlar Pythonprogramlamadili,bizesayılarlarahatçalışabilmemiziçinbazıfonksiyonlarsunar.Bu fonksiyonlarıkullanarak,karmaşıkaritmetikişlemlerikolaycayapabiliriz. BizbubölümdePython’ınbizesunduğubugömülüfonksiyonlarıtektekinceleyeceğiz. Gömülüfonksiyonlar,Pythonprogramlamadilinde,herhangibirözelişlemyapmamızagerek olmadan, kodlarımız içinde doğrudan kullanabileceğimiz fonksiyonlardır. Biz şimdiye kadar pekçokgömülüfonksiyonlazatentanışmıştık.Oyüzdengömülüfonksiyonlarbizimyabancısı olduğumuzbirkonudeğil.Meselaburayagelenekadargördüğümüz,len(),range(),type(), open(), print() ve id() gibi fonksiyonların tamamı birer gömülü fonksiyondur. Biz bu fonksiyonlarıilerleyenderslerdeçokdahaayrıntılıbirşekildeinceleyeceğiz.Amaşuandabile fonksiyonlarkonusundaepeybilgiyesahibiz. Şimdiye kadar öğrendiğimiz gömülü fonksiyonlardan şu listede yer alanlar, matematik işlemlerindekullanılmayauygunolanlardır: 25.2. AritmetikFonksiyonlar 457 PythonBelgeleri,Yayım4.1.3 1. complex() 2. float() 3. int() 4. pow() 5. round() 6. hex() 7. oct() 8. bin() Bizbufonksiyonlarınneişeyaradığınıöncekiderslerimizdezatenayrıntılıolarakincelemiştik. O yüzden burada bunlardan söz etmeyeceğiz. Onun yerine, henüz öğrenmediğimiz, ama mutlakabilmemizgerekengömülüfonksiyonlarıelealacağız. Ohaldehiçvakitkaybetmedenyolakoyulalım... 25.2.1 abs() Bufonksiyonbizebirsayınınmutlakdeğeriniverir: >>> abs(-2) 2 >>> abs(2) 2 25.2.2 divmod() Bufonksiyon,birsayınınbirsayıyabölünmesiişlemindebölümüvekalanıverir: >>> divmod(10, 2) (5, 0) 10sayısı2sayısınabölündüğünde‘bölüm’5,‘kalan’ise0’dır. Birörnekdahaverelim: >>> divmod(14, 3) (4, 2) Busonuçtangördüğünüzgibi,aslındadivmod()fonksiyonuşukodlarlaaynıişiyapıyor: >>> 14 // 3, 14 % 3 Bu fonksiyonun gerçekleştirdiği bölme işleminin bir ‘taban bölme’ işlemi olduğuna özellikle dikkatiniziçekmekistiyorum. 458 Bölüm25. Sayılar PythonBelgeleri,Yayım4.1.3 25.2.3 max() Sizeşöylebirsorusorduğumudüşünün:Acabaaşağıdakilistedeyeralansayılarınenbüyüğü kaçtır? [882388, 260409, 72923, 692476, 131925, 259114, 47630, 84513, 25413, 614654, 239479, 299159, 175488, 345972, 458112, 791030, 243610, 413702, 565285, 773607, 131583, 979177, 247202, 615485, 647512, 556823, 242460, 852928, 893126, 792435, 273904, 544434, 627222, 601984, 966446, 384143, 308858, 915106, 914423, 826315, 258342, 188056, 934954, 253918, 468223, 262875, 462902, 370061, 336521, 367829, 147846, 838385, 605377, 175140, 957437, 105779, 153499, 435097, 9934, 435761, 989066, 357279, 341319, 420455, 220075, 28839, 910043, 891209, 975758, 140968, 837021, 526798, 235190, 634295, 521918, 400634, 385922, 842289, 106889, 742531, 359913, 842431, 666182, 516933, 22222, 445705, 589281, 709098, 48521, 513501, 277645, 860937, 655966, 923944, 7895, 77482, 929007, 562981, 904166, 619260, 616293, 203512, 67534, 615578, 74381, 484273, 941872, 110617, 53517, 402324, 156156, 839504 , 625325, 694080, 904277, 163914, 756250, 809689, 354050, 523654, 26723, 167882, 103404, 689579, 121439, 158946, 485258, 850804, 650603, 717388, 981770, 573882, 358726, 957285, 418479, 851590, 960182, 11955, 894146, 856069, 369866, 740623, 867622, 616830, 894801, 827179, 580024, 987174, 638930, 129200, 214789, 45268, 455924, 655940, 335481, 845907, 942437, 759380, 790660, 432715, 858959, 289617, 757317, 982063, 237940, 141714, 939369, 198282, 975017, 785968, 49954, 854914, 996780, 121633, 436419, 471, 776271, 91626, 209175, 894281, 417963, 624464, 736535, 418888, 506194, 591087, 64075, 50252, 952943, 25878, 217085, 223996, 416042, 484123, 810460, 423284, 956886, 237772, 960241, 601551, 830147, 449088, 364567, 337281, 524358, 980387, 393760, 619710, 100181, 96738, 275199, 553783, 975654, 662536, 979103, 869504, 702350, 174361, 970250, 267625, 661580, 444662, 871532, 881977, 981660, 446047, 508758, 530694, 608789, 339540, 242774, 637473, 874011, 732999, 511638, 744144, 710805, 641326, 88085, 128487, 59732, 739340, 443638, 830333, 832136, 882277, 403538, 441349, 721048, 32859] İşteböylebirsoruyuçözmekiçinmax()fonksiyonundanyararlanabilirsiniz.Yukarıdakilisteyi sayılaradlıbirdeğişkeneatadığımızıvarsayarsak,aşağıdakikodbizelistedekienbüyüksayıyı verecektir: >>> max(sayılar) Yukarıdakiörneklerdemax()fonksiyonunukullanarakbirdiziiçindekienbüyüksayıyıbulduk. Peki bu fonksiyonukullanarakbir dizi içindeki enuzunkarakter dizisini bulabilir miyiz? Evet, bulabiliriz. Diyelimkielimizdeşöylebirlistevar: isimler = ["ahmet", "mehmet", "necla", "sedat", "abdullah", "gıyaseddin", "sibel", "can", "necmettin", "savaş", "özgür"] Amacımızbulisteiçindekienuzunkelimeyibulmak.İştebunumax()fonksiyonuileyapabiliriz. Dikkatlicebakın: 25.2. AritmetikFonksiyonlar 459 PythonBelgeleri,Yayım4.1.3 print(max(isimler, key=len)) Bukodlarıçalıştırdığımızda,listedekienuzunisimolan‘gıyaseddin’ieldeedeceğiz. Gördüğünüz gibi, max() fonksiyonu key adlı özel bir parametre daha alıyor. Bu parametreye biz ‘len’ değerini verdik. Böylece max() fonksiyonu liste içindeki öğeleri uzunluklarına göre sıralayıpenuzunöğeyibizesundu. Hatırlarsanızgeçenbölümdeşöylebirkodyazmıştık: sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"] print(("{:^9} "*len(sayı_sistemleri)).format(*sayı_sistemleri)) for i in range(17): print("{0:^9} {0:^9o} {0:^9x} {0:^9b}".format(i)) Bu kodlar, farklı sayma sistemleri arasındaki farkları daha net görmemizi sağlamıştı. Yalnız burada dikkat ettiyseniz, sayı_sistemleri adlı listeye her öğe ekleyişimizde, listedeki en uzun değeridikkatealarakkarakterdizisibiçimlendiricileriiçindeki,öğelerarasındanekadarboşluk bırakılacağını belirleyen sayıları güncelliyorduk. Mesela yukarıdaki örnekte, öğeler arasında yeterince boşluk bırakabilmek için bu sayıyı 9 olarak belirlemiştik. İşte şimdi öğrendiğimiz max() fonksiyonunu kullanarak bu sayının otomatik olarak belirlenmesini sağlayabiliriz. Dikkatliceinceleyin: sayı_sistemleri = ["onlu", "sekizli", "on altılı", "ikili"] en_uzun = len(max(sayı_sistemleri, key=len)) print(("{:^{aralık}} "*len(sayı_sistemleri)).format(*sayı_sistemleri,␣ aralık=en_uzun)) ˓→ for i in range(17): print("{0:^{1}} {0:^{1}o} {0:^{1}x} {0:^{1}b}".format(i, en_uzun)) Gördüğünüz gibi, max() fonksiyonunu ve bu fonksiyonun key parametresini kullanarak, oluşturduğumuz tablodaki öğelerin arasına uygun boşluğu otomatik olarak eklemiş olduk. Bununiçin,sayı_sistemleriadlılistedekienuzunöğeninuzunlukmiktarınıtemelaldık. 25.2.4 min() Bufonksiyon,max()fonksiyonunyaptığıişintamtersiniyapar.Yanibufonksiyonukullanarak birdiziiçindekienküçüksayıyıbulabilirsiniz: >>> min(sayılar) Tıpkı max() fonksiyonunda olduğu gibi, min() fonksiyonunda da key parametresini kullanabilirsiniz. Mesela max() fonksiyonunu anlatırken verdiğimiz isim listesindeki en kısa ismibulabilmekiçinşukoduyazabilirsiniz: print(min(isimler, key=len)) 460 Bölüm25. Sayılar PythonBelgeleri,Yayım4.1.3 25.2.5 sum() Bufonksiyonbirdiziiçindeyeralanbütünsayılarıbirbiriyletoplar.Örneğin: >>> a = [10, 20, 43, 45 , 77, 2, 0, 1] >>> sum(a) 198 Eğerbufonksiyonun,toplamaişleminibellibirsayınınüzerinegerçekleştirmesiniistiyorsanız şukoduyazabilirsiniz: >>> sum(a, 10) 208 sum()fonksiyonunabuşekildeikincibirparametreverdiğinizde,buikinciparametretoplam değereeklenecektir. 25.2. AritmetikFonksiyonlar 461 26 BÖLÜM Temel Dosya İşlemleri Hatırlarsanız print() fonksiyonunu anlatırken, bu fonksiyonun file adlı bir parametresi olduğundan söz etmiştik. Bu parametre yardımıyla print() fonksiyonunun çıktılarını bir dosyaya gönderebiliyorduk. Böylece print() fonksiyonunun bu özelliği sayesinde, Python’daki‘DosyaGirdi/Çıktısı’(FileI/O)konusuyladailkkeztanışmışolmuştuk. Ayrıca print() fonksiyonu dışında, open() adlı başka bir fonksiyon yardımıyla da dosyaları açabileceğimizi ve bu dosyaların üzerinde çeşitli işlemleri gerçekleştirebileceğimizi öğrenmiştik. Ancak gerek print() fonksiyonunun file parametresi, gerekse open() fonksiyonuyla şimdiye kadar yaptığımız örnekler aracılığıyla öğrendiklerimiz dosyalara ilişkinçoksınırlıişlemleriyerinegetirmemizisağlıyordu. İşte biz bu bölümde, dosya girdi/çıktısı konusuna ilişkin bildiklerimizi bir adım öteye götüreceğizvegerçekanlamdadosyalarınasılmanipüleedeceğimiziöğreneceğiz. Programcılık maceramız boyunca dosyalarla bol bol muhatap olacaksınız. O yüzden bu konuyuolabildiğinceayrıntılıveanlaşılırbirşekildeanlatmayaçalışacağız. Dediğimiz gibi, biz esasında bu noktaya gelinceye kadar çeşitli fonksiyonlar ve bunların birtakım parametreleri aracılığıyla dosya işlemlerinden az da olsa zaten söz etmiştik. Dolayısıyla aslında tamamen yabancısı olduğunuz bir konuyla karşı karşıya olmanız gibi bir durum söz konusu değil. Biz bu bölümde, zaten aşina olduğumuz bir konuyu çok daha derinlemesineelealacağız. Pythonprogramlamadilindedosyalarlauğraşırkenbütündosyaişlemleriiçintemelolaraktek birfonksiyondanyararlanacağız.Bufonksiyonusizzatentanıyorsunuz.Fonksiyonumuzunadı open(). 462 PythonBelgeleri,Yayım4.1.3 26.1 Dosya Oluşturmak Dediğimizgibi,Pythonprogramlamadilindedosyaişlemleriiçinopen()adlıbirfonksiyondan yararlanacağız.İştedosyaoluşturmakiçindebufonksiyonukullanacağız. Önceki derslerimizde verdiğimiz örneklerden de bildiğiniz gibi, open() fonksiyonunu temel olarakşöylekullanıyoruz: f = open(dosya_adı, kip) (cid:242) Not open()fonksiyonudosya_adıvekipdışındabaşkaparametrelerdealır.İlerleyensayfalarda buparametrelerdendesözedeceğiz. Mesela“tahsilat.txt”adlıbirdosyayıyazmakipindeaçmakiçinşöylebirkomutkullanıyoruz: tahsilat_dosyası = open("tahsilat_dosyası.txt", "w") Burada ‘tahsilat_dosyası.txt’ ifadesi dosyamızın adını belirtiyor. “w” harfi ise bu dosyanın yazmakipindeaçıldığınısöylüyor. Yukarıdaki komutu çalıştırdığınızda, o anda hangi dizin altında bulunuyorsanız o dizin içinde tahsilat_dosyası.txtadlıboşbirdosyanınoluştuğunugöreceksiniz. Bu arada, dosya adını yazarken, dosya adı ile birlikte o dosyanın hangi dizin altında oluşturulacağınıdabelirleyebilirsiniz.Örneğin: dosya = open("/dosyayı/oluşturmak/istediğimiz/dizin/dosya_adı", "w") Eğer dosya adını dizin belirtmeden yazarsanız, oluşturduğunuz dosya, o anda hangi dizin altındabulunuyorsanızoradaoluşacaktır. Ayrıca dosyayı barındıran dizin adlarını yazarken, dizinleri ayırmak için ters taksim (\) yerine düz taksim (/) kullanmaya dikkat edin. Aksi halde, dizin adı oluşturmaya çalışırken yanlışlıkla kaçışdizilerioluşturabilirsiniz.Esasındasizbuolguyahiçyabancıdeğilsiniz.Zirakaçışdizilerini anlatırkenşöylebirörnekverdiğimizihatırlıyorolmalısınız: print("C:\aylar\nisan\toplam masraf") İşteeğerbuörnekteolduğugibiterstaksimişaretleriileoluşturulmuşdizinadlarıkullanırsanız programınızhataverecektir: >>> open("C:\aylar\nisan\toplam masraf\masraf.txt", "w") Traceback (most recent call last): File "<stdin>", line 1, in <module> OSError: [Errno 22] Invalid argument: ’C:\x07ylar\nisan\toplam masraf\masraf.txt ’ ˓→ Bunun sebebi, bildiğiniz gibi, Python’ın \a, \n ve \t ifadelerini birer kaçış dizisi olarak algılamasıdır. Bu durumdan kaçabilmek için, dizin adlarını ters taksim işareti ile ayırmanın dışında,radlıkaçışdizisindendeyararlanabilirsiniz: 26.1. DosyaOluşturmak 463 PythonBelgeleri,Yayım4.1.3 >>> open(r"C:\aylar\nisan\toplam masraf\masraf.txt", "w") ...veyaterstaksimişaretleriniçiftleyebilirsiniz: >>> open("C:\\aylar\\nisan\\toplam masraf\\masraf.txt", "w") Bu şekilde, eğer bilgisayarınızda C:\aylar\nisan\toplam masraf\ adlı bir dizin varsa, o dizin içindemasraf.txtadlıbirdosyaoluşturulacaktır. BöylecePythonprogramlamadilindeboşbirdosyanınnasıloluşturulacağınıöğrenmişolduk. Ohaldegelinistersenizşimdibudosyanıniçininasıldolduracağımızıöğrenelim. 26.2 Dosyaya Yazmak Birdosyayı,yukarıdagösterdiğimizşekildeyazmakipindeaçtığımızzaman,Pythonbizimiçin içiboşbirdosyaoluşturacaktır.Pekibizbudosyanıniçininasıldolduracağız? Python programlama dilinde, open() fonksiyonu ile yazma kipinde açtığımız bir dosyaya bir veriyazabilmekiçindosyalarınwrite()adlımetodundanyararlanacağız. Sizaslındabumetodundanasılkullanılacağınıçokiyibiliyorsunuz: dosya.write(yazılacak_şeyler) Gelinbuformülüsomutlaştıracakbirörnekverelim.Meselayukarıdaoluşturduğumuztahsilat dosyasınıniçinebazıverilergirelim. Öncedosyamızınasıloluşturacağımızıhatırlayalım: ths = open("tahsilat_dosyası.txt", "w") Şimdidebudosyayaşubilgilerigirelim: ths.write("Halil Pazarlama: 120.000 TL") Yaniprogramımızşöylegörünsün: ths = open("tahsilat_dosyası.txt", "w") ths.write("Halil Pazarlama: 120.000 TL") Bu komutları verdiğinizde, tahsilat_dosyası.txt adlı dosyanın içine şu bilgilerin işlendiğini göreceksiniz: Halil Pazarlama: 120.000 TL Eğer dosyayı açtığınızda bu bilgi yerine hâlâ boş bir dosya görüyorsanız, sebebi tamponda tutulanverilerinhenüzdosyayaişlenmemişolmasıdır. (cid:242) Not Bu konuyu print() fonksiyonunun flush adlı parametresini incelerken öğrendiğimizi hatırlıyorolmalısınız. 464 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 Eğer durum böyleyse, dosyanızı kapatmanız gerekiyor. Bunu close() adlı başka bir metotla yapabildiğimizibiliyorsunuz: ths.close() Bu arada, bu söylediklerimizden, eğer yazdığınız bilgiler zaten dosyaya işlenmişse dosyayı kapatmanıza gerek olmadığı anlamını çıkarmayın. Herhangi bir şekilde açtığınız dosyaları kapatmanız, özellikle dosyanın açılmasıyla birlikte kullanılmaya başlayan ve arka planda çalışan kaynakların serbest bırakılması açısından büyük önem taşıyor. O yüzden açtığımız dosyaların tamamını programın işleyişi sona erdiğinde kapatmayı unutmuyoruz. Yani yukarıdakiprogramıtamolarakşöyleyazıyoruz: ths = open("tahsilat_dosyası.txt", "w") ths.write("Halil Pazarlama: 120.000 TL"), ths.close() Bukodlardasırasıylaşuişlemlerigerçekleştirdik: 1. tahsilat_dosyası adlı bir dosyayı yazma kipinde açarak, bu adda bir dosya oluşturulmasınısağladık, 2. write()metodunukullanarakbudosyayabazıbilgilergirdik, 3. Dosyamızayazdığımızbilgilerindosyayaişlendiğindeneminolmakveişletimsisteminin dosyanın açılması ve dosyaya veri işlenmesi için devreye soktuğu bütün kaynakları serbestbırakmakiçinclose()metoduylaprogramımızıkapattık. Bu arada, bu başlığı kapatmadan önce önemli bir bilgi daha verelim. Python’da bir dosyayı “w” kipinde açtığımızda, eğer o adda bir dosya ilgili dizin içinde zaten varsa, Python bu dosyayı sorgusuz sualsiz silip, yerine aynı adda başka bir boş dosya oluşturacaktır. Yani meselayukarıdatahsilat_dosyası.txtadlıdosyayıoluşturupiçinebirşeyleryazdıktansonrabu dosyayı yine “w” kipinde açmaya çalışırsanız, Python bu dosyanın bütün içeriğini silip, yine tahsilat_dosyası.txt adını taşıyan başka bir dosya oluşturacaktır. O yüzden dosya işlemleri sırasında bu “w” kipini kullanırken dikkat ediyoruz ve disk üzerinde var olan dosyalarımızı yanlışlıklasilmiyoruz. Böylece bir dosyanın nasıl oluşturulacağını, nasıl açılacağını ve içine birtakım bilgilerin nasıl girileceğini kabataslak da olsa öğrenmiş olduk. Şimdi de dosyaları nasıl okuyacağımızı öğrenelim. 26.3 Dosya Okumak Bir önceki başlıkta dosyaların içine bilgi girme işleminin Python programlama dilinde nasıl yapıldığını inceledik. Elbette bir dosyaya yazabilmenin yanısıra, bilgisayarınızda halihazırda varolanbirdosyayıokumakdaisteyeceksiniz.Pekibununasılyapacaksınız? Python’dabirdosyayıokumakiçinyukarıdaanlattığımızyazmayönteminebenzerbiryöntem kullanacağız.Bildiğinizgibi,birdosyayıyazmakipindeaçmakiçin“w”harfinikullanıyoruz.Bir dosyayıokumakipindeaçmakiçinise“r”harfinikullanacağız. Mesela,bilgisayarımızdavarolanfihrist.txtadlıdosyayıokumaküzereaçalım: fihrist = open("fihrist.txt", "r") 26.3. DosyaOkumak 465 PythonBelgeleri,Yayım4.1.3 Birdosyayıopen()fonksiyonuyardımıylaaçarkenkipparametresiiçin“r”harfinikullanırsak, Python o dosyayı okuma yetkisiyle açacaktır. Yalnız burada şöyle bir özellik var: Eğer bir dosyayı okuma kipinde açacaksanız, bu “r” harfini hiç belirtmeseniz de olur. Yani şu komut bilgisayarımızdakifihrist.txtadlıdosyayıokumakipindeaçacaktır: fihrist = open("fihrist.txt") DolayısıylabirdosyayıaçarkenkipbelirtmediğimizdePythonbizimodosyayıokumakipinde açmakistediğimizivarsayacaktır. Hatırlarsanız, “w” kipiyle açtığımız bir dosyaya yazmak için write() adlı bir metottan yararlanıyorduk. “r” kipiyle açtığımız bir dosyayı okumak için ise read(), readline() ve readlines()adlıüçfarklımetottanyararlanacağız. YukarıdakiüçmetotdaPython’dadosyaokumaişlemlerinigerçekleştirmemizisağlar.Pekibu metotlarınüçüdeaynıişiyapıyorsanedentekbirmetotdeğildeüçfarklımetotvar? Bu metotların üçü de dosya okumaya yarasa da, verdikleri çıktılar birbirinden farklıdır. O yüzdenfarklıamaçlariçinfarklımetodukullanmanızgerekendurumlarlakarşılaşabilirsiniz. Bu metotlar arasındaki farkı anlamanın en kolay yolu bu üç metodu sırayla kullanıp, çıktıları incelemektir. Öncelikleiçeriğişuolan,fihrist.txtadlıbirdosyamızınolduğunuvarsayalım: Ahmet Özbudak : 0533 123 23 34 Mehmet Sülün : 0532 212 22 22 Sami Sam : 0542 333 34 34 Şimdibirdosyaaçıpşukodlarıyazalım: fihrist = open("fihrist.txt") print(fihrist.read()) Bukodlarıçalıştırdığımızda,eğerkullandığınızişletimsistemiGNU/Linuxisemuhtemelenşu çıktıyıeldeedeceksiniz: Ahmet Özbudak : 0533 123 23 34 Mehmet Sülün : 0532 212 22 22 Sami Sam : 0542 333 34 34 Ama eğer bu kodları Windows’ta çalıştırdıysanız Türkçe karakterler bozuk çıkmış olabilir. Bu durumuşimdilikgörmezdengelin.Birazdanbudurumunnedeniniaçıklayacağız. Yukarıda elde ettiğimiz şey bir karakter dizisidir bunu şu şekilde teyit edebileceğinizi biliyorsunuz: fihrist = open("fihrist.txt") print(type(fihrist.read())) Gördüğünüz gibi, read() metodu bize, dosyanın bütün içeriğini bir karakter dizisi olarak veriyor.Birdeşunabakalım: fihrist = open("fihrist.txt") print(fihrist.readline()) 466 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 Buradadareadline()metodunukullandık.Bukodlarbizeşöylebirçıktıveriyor: Ahmet Özbudak : 0533 123 23 34 read() metodu bize dosya içeriğinin tamamını veriyordu. Gördüğünüz gibi readline() metodutekbirsatırveriyor.Yanibumetotyardımıyladosyalarısatırsatırokuyabiliyoruz. Bumetodunişleyiştarzınıdahaiyigörebilmekiçinbukodlarıdosyayayazıpçalıştırmakyerine etkileşimlikabuküzerindendeçalıştırabilirsiniz: >>> fihrist = open("fihrist.txt", "r") >>> print(fihrist.readline()) Ahmet Özbudak : 0533 123 23 34 >>> print(fihrist.readline()) Mehmet Sülün : 0532 212 22 22 >>> print(fihrist.readline()) Sami Sam : 0542 333 34 34 Gördüğünüzgibi,readline()metodugerçektendedosyayısatırsatırokuyor. Son satırı da okuduktan sonra, readline() metodunu tekrar çalıştırırsak ne olur peki? Bakalım: >>> print(fihrist.readline()) Gördüğünüz gibi, bu defa hiçbir çıktı almadık. Çünkü dosyada okunacak satır kalmadı. Bu yüzden de Python bize boş bir çıktı verdi. Bu durumu daha net görmek için kodu etkileşimli kabuktaprint()olmadanyazabilirsiniz: >>> fihrist.readline() ’’ Gerçekten de elimizdeki şey boş bir karakter dizisi... Demek ki bir dosya tamamen okunduktan sonra, Python otomatik olarak tekrar dosyanın başına dönmüyor. Böyle bir durumdadosyanınbaşınanasılgeridöneceğimiziinceleyeceğiz,amaistersenizbizbaşkabir konuyladevamedelim. (cid:242) Not Birdosyanıntamamıokunduktansonraotomatikolarakbaşasarılmamasıözelliğisadece readline() metodu için değil, öteki bütün dosya okuma metotları için de geçerlidir. Yani bir dosyayı read(), readline() veya readlines() metotlarından herhangi biri ile okuduğunuzdaimleçbaşadönmez. Dediğimiz ve gösterdiğimiz gibi, read() ve readline() metotları bize bir karakter dizisi döndürüyor.Buikimetotarasındakifarkise,read()metodunundosyanıntamamınıönümüze 26.3. DosyaOkumak 467 PythonBelgeleri,Yayım4.1.3 sererken, readline() metodunun dosyayı satır satır okuyup, her defasında tek bir satırı önümüzesürmesidir.Birdereadlines()metodununneyaptığınabakalım... Şukodlarıyazalım: fihrist = open("fihrist.txt") print(fihrist.readlines()) Bukodlarıyazdığımızdaşunabenzerbirçıktıalacağız: [’Ahmet Özbudak : 0533 123 23 34\n’, ’Mehmet Sülün : 0532 212 22 22\n’, ’Sami Sam : 0542 333 34 34’] Gördüğünüzgibi,budefakarakterdizisiyerinebirlisteilekarşılaşıyoruz.Demekkiread()ve readline() metotları çıktı olarak bize bir karakter dizisi verirken, readlines() metodu liste veriyormuş.Bununnedenönemlibirbilgiolduğunuartıkgayetiyibiliyorolmanızlazım.Zira birverinintipi,overiyleneleryapıpneleryapamayacağımızıdoğrudanetkiler... 26.4 Dosyaları Otomatik Kapatma Dahaöncedesöylediğimizgibi,birdosyayıaçıpbudosyaüzerindegerekliişlemleriyaptıktan sonra bu dosyayı açık bırakmamak büyük önem taşır. Dolayısıyla üzerinde işlem yaptığımız bütün dosyaları, işimiz bittikten sonra, mutlaka kapatmalıyız. Çünkü bir dosya açıldığında işletimsistemi,sistemkaynaklarınınbirkısmınıbudosyayaayırır.Eğerdosyayıaçıkbırakırsak, sistem kaynaklarını gereksiz yere meşgul etmiş oluruz. Ancak farklı sebeplerden, dosyalar açıldıktan sonra kapanmayabilir. Örneğin açtığınız dosyayı kapatmayı unutmuş olabilirsiniz. Yani programınızın hiçbir yerinde close() metodunu kullanmamışsınızdır. Bunun dışında, programınızdaki bir hata da dosyaların kapanmasını engelleyebilir. Örneğin bir dosya açıldıktan sonra programda beklenmeyen bir hata gerçekleşirse, programınız asla close() satırınaulaşamayabilir.Budurumdadaaçılandosyakapanmadanöylecebekler. Butürdurumlarakarşıikiseçeneğinizvar: 1. try... except... finally...bloklarındanyararlanmak 2. withadlıbirdeyimikullanmak Birinci yöntemden daha önce de bahsettiğimizi hatırlıyorsunuz. Hata yakalama bölümünü anlatırkenbununlailgilişöylebirörnekvermiştik: try: dosya = open("dosyaadı", "r") ...burada dosyayla bazı işlemler yapıyoruz... ...ve ansızın bir hata oluşuyor... except IOError: print("bir hata oluştu!") finally: dosya.close() Buyöntemgayetuygunveiyibiryöntemdir.AncakPythonbizebutürdurumlariçinçokdaha pratikbiryöntemsunar.Dikkatlicebakın: 468 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 with open("dosyaadı", "r") as dosya: print(dosya.read()) DosyalarımızıbuşekildeaçıpüzerlerindeişlemlerimiziyaptığımızdaPythondosyayıbizimiçin kendisi kapatacaktır. Bu şekilde bizim ayrıca bir close() satırı yazmamıza gerek yok. with deyimini kullanmamız sayesinde, dosya açıldıktan sonra arada bir hata oluşsa bile Python dosyayısağsalimkapatıpsistemkaynaklarınınisrafedilmesiniönleyecektir. 26.5 Dosyayı İleri-Geri Sarmak Dosya okumak için kullanılan metotları anlatırken, dosya bir kez okunduktan sonra imlecin otomatik olarak dosyanın başına dönmediğini görmüştük. Yani mesela read() metoduyla dosyayıbirkezokuduktansonra,dosyayıtekrarokumakistersekeldeedeceğimizşeyboşbir karakter dizisi olacaktır. Çünkü dosya okunduktan sonra okunacak başka bir satır kalmamış, imleç dosya sonuna ulaşmış ve otomatik olarak da başa dönmemiştir. Bu olguyu etkileşimli kabuküzerindedahanetbirşekildegörebileceğinizibiliyorsunuz. Pekidosyayıtamamenokuduktansonratekrarbaşadönmekistersekneyapacağız?Birdosya tamamenokunduktansonratekrarbaşadönmekiçindosyalarınseek()adlıbirmetodundan yararlanacağız. Meselaşuörneklerebakalım.BuörnekleridahaiyianlamakiçinbunlarıPython’ınetkileşimli kabuğundaçalıştırmanızıtavsiyeederim: >>> f = open("python.txt") >>> f.read() ’Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı\ntarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,\nisminin Python olmasına aldanarak, bu programlama dilinin, adını piton\nyılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin\nadı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty\nPython adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı\ngösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa\nda, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil\nedilmesi neredeyse bir gelenek halini almıştır.\n’ Burada open() fonksiyonunu kullanarak python.txt adlı bir dosyayı açıp, read() metodu yardımıyla da bu dosyanın içeriğini okuduk. Bu noktada dosyayı tekrar okumaya çalışırsak eldeedeceğimizşeyboşbirkarakterdizisiolacaktır: >>> f.read() ’’ Çünkü dosya bir kez tamamen okunduktan sonra imleç otomatik olarak başa dönmüyor. Dosyayı tekrar okumak istiyorsak, bunu başa bizim sarmamız lazım. İşte bunun için seek() metodunukullanacağız: 26.5. Dosyayıİleri-GeriSarmak 469 PythonBelgeleri,Yayım4.1.3 >>> f.seek(0) Gördüğünüzgibiseek()metodunubirparametreilebirliktekullandık.Bumetodaverdiğimiz parametre, dosya içinde kaçıncı bayt konumuna gideceğimizi gösteriyor. Biz burada 0 sayısını kullanarak dosyanın ilk baytına, yani en başına dönmüş olduk. Artık dosyayı tekrar okuyabiliriz: >>> f.read() ’Bu programlama dili Guido Van Rossum adlı Hollandalı bir programcı\ntarafından 90’lı yılların başında geliştirilmeye başlanmıştır. Çoğu insan,\nisminin Python olmasına aldanarak, bu programlama dilinin, adını piton\nyılanından aldığını düşünür. Ancak zannedildiğinin aksine bu programlama dilinin\nadı piton yılanından gelmez. Guido Van Rossum bu programlama dilini, The Monty\nPython adlı bir İngiliz komedi grubunun, Monty Python’s Flying Circus adlı\ngösterisinden esinlenerek adlandırmıştır. Ancak her ne kadar gerçek böyle olsa\nda, Python programlama dilinin pek çok yerde bir yılan figürü ile temsil\nedilmesi neredeyse bir gelenek halini almıştır.\n’ Elbette seek() metodunu kullanarak istediğiniz bayt konumuna dönebilirsiniz. Mesela eğer dosyanın 10. baytının bulunduğu konuma dönmek isterseniz bu metodu şöyle kullanabilirsiniz: >>> f.seek(10) Eğeroandadosyanınhangibaytkonumundabulunduğunuzuöğrenmekistersenizdetell() adlıbaşkabirmetottanyararlanabilirsiniz.Bumetoduparametresizolarakkullanıyoruz: >>> f.tell() 20 Buçıktıyagöreoandadosyanın20.baytınınüzerindeyiz... Bu arada, dosya içinde bulunduğumuz konumu baytlar üzerinden tarif etmemizi biraz yadırgamışolabilirsiniz.Acabanedenkarakterdeğildebayt?Birazsonrabukonuyageleceğiz. Bizşimdilikönemlibaşkabirkonuyadeğinelim. 26.6 Dosyalarda Değişiklik Yapmak Buraya kadar, Python’da bir dosyanın nasıl oluşturulacağını, boş bir dosyaya nasıl veri girileceğini ve varolan bir dosyadan nasıl veri okunacağını öğrendik. Ama varolan ve içi halihazırda dolu bir dosyaya nasıl veri ekleneceğini bilmiyoruz. İşte şimdi bu işlemin nasıl yapılacağınıtartışacağız. Ancak burada önemli bir ayrıntıya dikkatinizi çekmek istiyorum. Dosyaların neresinde değişiklikyapmakistediğinizbüyükönemtaşır.Unutmayın,dosyalarınbaşında,ortasındave sonunda değişiklik yapmak birbirlerinden farklı kavramlar olup, birbirinden farklı işlemlerin uygulanmasınıgerektirir. 470 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 Biz bu bölümde dosyaların baş tarafına, ortasına ve sonuna nasıl veri eklenip çıkarılacağını ayrıayrıtartışacağız. 26.6.1 Dosyaların Sonunda Değişiklik Yapmak Daha önce de söylediğimiz gibi, Python’da bir dosyayı açarken, o dosyayı hangi kipte açacağımızıbelirtmemizgerekiyor.Yanieğerbirdosyayıokumakistiyorsakdosyayı“r”kipinde, yazmak istiyorsak da “w” kipinde açmamız gerekiyor. Bildiğiniz gibi “w” kipi dosya içeriğini tamamensiliyor. Eğer bir dosyayı tamamen silmeden, o dosyaya ekleme yapmak veya o dosyada herhangi bir değişiklik yapmak istiyorsak, dosyamızı buraya kadar öğrendiğimiz iki kipten daha farklı birkipleaçmamızgerekiyor.Şimdiöğreneceğimizbuyenikipinadı“a”.YaniPython’daiçiboş olmayanbirdosyadadeğişiklikyapabilmekiçin“a”adlıbirkiptenyararlanacağız: f = open(dosya_adı, "a") Örneğin yukarıda verdiğimiz fihrist.txt adlı dosyayı bu kipte açalım ve dosyaya yeni bir girdi ekleyelim: with open("fihrist.txt", "a") as f: f.write("Selin Özden\t: 0212 222 22 22") Gördüğünüz gibi, dosyaya yeni eklediğimiz girdiler otomatik olarak dosyanın sonuna ilave ediliyor.Buradaşunoktayadikkatetmenizlazım.Dosyanınsonundabirsatırbaşıkarakterinin (\n)bulunupbulunmamasınabağlıolarak,dosyayaeklediğinizyenisatırlardüzgünbirşekilde biraltsatırageçebileceğigibi,dosyanınsonsatırınınyanınadaeklenebilir.Dolayısıyladuruma göreyukarıdakisatırışuşekildeyazmanızgerekebilir: with open("fihrist.txt", "a") as f: f.write("\nSelin Özden\t: 0212 222 22 22") Burada bir alt satıra geçebilmek için ‘Selin’ ifadesinden önce bir satır başı karakteri eklediğimize dikkat edin. Ayrıca eğer bu satırdan sonra bir başka satır daha ekleyecekseniz, ilgilisatırınsonunadabirsatırbaşıkarakterikoymanızgerekebilir: with open("fihrist.txt", "a") as f: f.write("Selin Özden\t: 0212 222 22 22\n") Karşı karşıya olduğunuz duruma göre, satır başı karakterlerine ihtiyacınız olup olmadığını ve ihtiyacınızvarsabunlarınereyeyerleştireceğinizikendinizdeğerlendirmelisiniz. 26.6.2 Dosyaların Başında Değişiklik Yapmak Bir önceki bölümde dosya sonuna nasıl yeni satır ekleyeceğimizi öğrendik. Ama siz programcılıkmaceranızsırasındamuhtemelendosyalarınsonunadeğilde,enbaşınaekleme yapmanızgerekendurumlarladakarşılaşacaksınız.Python’dabuişiyapmakdaçokkolaydır. Örnekolmasıaçısından,fihrist.txtadlıdosyanıniçeriğinielealalım: 26.6. DosyalardaDeğişiklikYapmak 471 PythonBelgeleri,Yayım4.1.3 Ahmet Özbudak : 0533 123 23 34 Mehmet Sülün : 0532 212 22 22 Sami Sam : 0542 333 34 34 Selin Özden : 0212 222 22 22 Dosya içeriği bu. Eğer bu dosyayı “a” kipi ile açtıktan sonra doğrudan write() metodunu kullanarak bir ekleme yaparsak, yeni değer dosyanın sonuna eklenecektir. Ama biz mesela şuveriyi: Sedat Köz : 0322 234 45 45 ‘AhmetÖzbudak:05331232334’girdisininhemenüstüne,yanidosyanınsonunadeğildeen başınaeklemekistersekneyapacağız? Öncelikleşukodlarıdeneyelim: with open("fihrist.txt", "r") as f: veri = f.read() f.seek(0) #Dosyayı başa sarıyoruz f.write("Sedat Köz\t: 0322 234 45 45\n"+veri) BukodlarıbirdosyayakaydedipçalıştırdığımızdaPythonbizeşuhatayıverecektir: Traceback (most recent call last): File "deneme.py", line 4, in <module> f.write("Sedat Köz\t: 0322 234 45 45\n"+veri) io.UnsupportedOperation: not writable Buhatayıalmamızınsebebidosyayı‘okuma’kipindeaçmışolmamız.Çünkübirdosyayıokuma kipinde açtığımızda o dosya üzerinde yalnızca okuma işlemleri yapabiliriz. Dosyaya yeni veri ekleme kısmına gelindiğinde, dosya yalnızca okuma yetkisine sahip olduğu için, Python bize yukarıdakihatamesajınıverecek,dosyanın‘yazılamaz’olduğundanşikayetedecektir. Pekidosyayı“w”karakteriyardımıylayazmakipindeaçarsakneolur?Ozamandaşumeş’um hatayıalırız: Traceback (most recent call last): File "deneme.py", line 2, in <module> veri = f.read() io.UnsupportedOperation: not readable Gördüğünüz gibi, bu kez de dosyanın okunamadığına ilişkin bir hata alıyoruz. Çünkü biz bu kez de dosyayı ‘yazma’ kipinde açtık. Ancak burada şöyle bir durum var. Bildiğiniz gibi, bir dosyayı “w” kipi ile açtığımızda, Python bize hiçbir şey sormadan varolan içeriği silecektir. Burada da yukarıda yazdığımız kodlar yüzünden dosya içeriğini kaybettik. Unutmayın, dosya okuma-yazma işlemleri belli bir takım riskleri içinde barındırır. O yüzden bu tür işlemleri yaparkenfazladandikkatgöstermeliyiz. Yukarıdadagördüğümüzgibi,dosyamızı“r”veya“w”kiplerindeaçmakişeyaramadı.Pekine yapacağız? Bunun cevabı çok basit: Dosyamızı hem okuma hem de yazma kipinde açacağız. Bununiçindefarklıbirkipkullanacağız.Dikkatlicebakın: 472 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 with open("fihrist.txt", "r+") as f: veri = f.read() f.seek(0) #Dosyayı başa sarıyoruz f.write("Sedat Köz\t: 0322 234 45 45\n"+veri) Burada “r+” adlı yeni bir kip kullandığımıza dikkat edin. “+” işareti bir dosyayı hem okuma hemdeyazmakipindeaçmamızayardımcıolur.İştebuişareti“r”kipiylebirlikte“r+”şeklinde kullanarak dosyamızı hem okuma hem de yazma kipinde açmayı başardık. Artık ilgili dosya üzerindehemokumahemdeyazmaişlemleriniaynıandagerçekleştirebiliriz. Yukarıdakikodlardailksatırınardındanşöylebirkodyazdık: veri = f.read() Böylece dosyanın bütün içeriğini veri adlı bir değişkene atamış olduk. Peki bu işlemi yapmazsakneolur?Yanimeselaşöylebirkodyazarsak: with open("fihrist.txt", "r+") as f: f.seek(0) f.write("Sedat Köz\t: 0322 234 45 45\n") Bu şekilde ‘Sedat Köz\t: 0322 234 45 45\n’ satırı, dosyadaki ilk satırı silip onun yerine geçecektir. Çünkü f.seek(0) ile dosyanın başına dönüp o noktaya, yani dosyanın ilk satırına birverieklediktensonraPythonöbürsatırlarıotomatikolarakbiraltsatırakaydırmaz.Bunun yerineilksatırdakiverilerisiliponunyerine,yenieklenensatırıgetirir.Eğeryapmakistediğiniz şey buysa ne âlâ. Bu kodları kullanabilirsiniz. Ama bizim istediğimiz şey bu değil. O yüzden veri = f.read() satırını kullanarak dosya içeriğini bir değişken içinde depoluyoruz ve böylece buverilerikaybetmemişoluyoruz. Bu satırın ardından gelen f.seek(0) satırının ne işe yaradığını biliyorsunuz. Biz yeni veriyi dosyanın en başına eklemek istediğimiz için, doğal olarak bu kod yardımıyla dosyanın en başınasarıyoruz.Böyleceşukod: f.write("Sedat Köz\t: 0322 234 45 45\n"+veri) Sedat Köz\t: 0322 234 45 45\n’ satırını dosyanın en başına ekliyor. Ayrıca burada, biraz önce veri değişkenine atadığımız dosya içeriğini de yeni eklediğimiz satırın hemen arkasına ilave ettiğimizedikkatedin.Eğerbunuyapmazsanız,elinizdesadeceSedatKöz’üniletişimbilgilerini barındıranbirdosyaolacaktır... 26.6.3 Dosyaların Ortasında Değişiklik Yapmak Gördüğünüzgibi,Python’dabirdosyanın ensonunaveenbaşınaverieklemekçokzordeğil. Birkaç satır yardımıyla bu işlemleri rahatlıkla yapabiliyoruz. Peki ya bir dosyanın en başına veyaensonunadeğilderastgelebiryerineeklemeyapmakistersekneolacak? Hatırlarsanız, Python’da her veri tipinin farklı özellikleri olduğundan, her veri tipinin farklı açılardan birbirlerine karşı üstünlükleri ya da zayıflıkları olduğundan söz etmiştik. Dediğimiz gibi, Python’da bazı işler için bazı veri tiplerini kullanmak daha pratik ve avantajlı olabilir. Örneğinkarakterdizilerideğiştirilemeyenveritipleriolduğuiçin,meselabirmetindedeğişiklik yapmamız gereken durumlarda, eğer mümkünse listeleri kullanmak daha mantıklı olabilir. Zirabildiğinizgibi,karakterdizilerininaksinelistelerdeğiştirilebilirveritipleridir. 26.6. DosyalardaDeğişiklikYapmak 473 PythonBelgeleri,Yayım4.1.3 Önceki sayfalarda bir dosyayı okurken üç farklı metottan yararlanabileceğimizi öğrenmiştik. Bu metotların read(), readline() ve readlines() adlı metotlar olduğunu biliyorsunuz. Bu üçmetottanread()adlıolanıbizeçıktıolarakbirkarakterdizisiveriyor.readline()metodu ise dosyaları satır satır okuyor ve bize yine bir karakter dizisi veriyor. Sonuncu metot olan readlines() ise bize bir liste veriyor. readline() metodundan farklı olarak readlines() metodudosyanıntamamınıbirçırpıdaokuyor. Bu üç metot arasından, adı readlines() olanının, dosyaların herhangi bir yerinde değişiklik yapmak konusunda bize yardımcı olabileceğini tahmin etmiş olabilirsiniz. Çünkü dediğimiz gibi readlines() metodu bize bir dosyanın içeriğini liste halinde veriyor. Bildiğiniz gibi listeler, üzerinde değişiklik yapılabilen veri tipleridir. Listelerin bu özelliğinden yararlanarak, dosyaların herhangi bir yerinde yapmak istediğimiz değişiklikleri rahatlıkla yapabiliriz. Şimdi dikkatlicebakınşukodlara: with open("fihrist.txt", "r+") as f: veri = f.readlines() veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n") f.seek(0) f.writelines(veri) Bukodlarıbirdosyayakaydedipçalıştırdıysanız,istediğimizişlemibaşarıylayerinegetirdiğini görmüşsünüzdür.Pekiamabukodlarnasılçalışıyor? Yukarıdaki kodlarda dikkatimizi çeken pek çok özellik var. İlk olarak gözümüze çarpan şey, dosyayı “r+” kipinde açmış olmamız. Bu şekilde dosyayı hem okuma hem de yazma kipinde açmış oluyoruz. Çünkü dosyada aynı anda hem okuma hem de yazma işlemleri gerçekleştireceğiz. Dahasonraşöylebirsatıryazdık: veri = f.readlines() Bu sayede dosyadaki bütün verileri bir liste olarak almış olduk. Liste adlı veri tipi ile ne yapabiliyorsak, bu şekilde aldığımız dosya içeriği üzerinde de aynı şeyleri yapabiliriz. Bizim amacımız bu listenin 2. sırasına yeni bir satır eklemek. Bu işlemi listelerin insert() adlı metoduyardımıylarahatlıklayapabiliriz: veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n") Bu şekilde liste üzerinde istediğimiz değişiklikleri yaptıktan sonra tekrar dosyanın başına dönmemiz lazım. Çünkü readlines() metoduyla dosyayı bir kez tam olarak okuduktan sonra imleç o anda dosyanın en sonunda bulunuyor. Eğer dosyanın en başına dönmeden herhangi bir yazma işlemi gerçekleştirirsek, yazılan veriler dosyanın sonuna eklenecektir. Bizim yapmamız gereken şey dosyanın en başına sarıp, değiştirilmiş verilerin dosyaya yazılmasınısağlamakolmalı.Bunudaşusatıryardımıylayapıyoruz: f.seek(0) Sonolarakdabütünverileridosyayayazıyoruz: f.writelines(veri) Şimdiyekadardosyayayazmaişlemleriiçinwrite()adlıbirmetottanyararlanmıştık.Burada isewritelines()adlıbaşkabirmetotgörüyoruz.Pekibuikimetotarasındakifarknedir? 474 Bölüm26. TemelDosyaİşlemleri PythonBelgeleri,Yayım4.1.3 write()metodubirdosyayayalnızcakarakterdizileriniyazabilir.Bumetotyardımıyladosyaya liste tipinde herhangi bir veri yazamazsınız. Eğer mutlaka write() metodunu kullanmak isterseniz,listeüzerindebirfordöngüsükurmanızgerekir.Ozamanyukarıdakikodlarışöyle yazmanızgerekir: with open("fihrist.txt", "r+") as f: veri = f.readlines() veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n") f.seek(0) for öğe in veri: f.write(öğe) writelines()adlımetotisebizedosyayalistetipindeverileriyazmaimkanıverir.Dolayısıyla herhangibirdöngükurmakzorundakalmadanlisteleridosyalarımızayazabiliriz. Böylece Python’da dosyaların herhangi bir yerine nasıl yazabileceğimizi öğrenmiş olduk. Bu aradaeğeristeseydikyukarıdakikodlarışöyledeyazabilirdik: with open("fihrist.txt", "r") as f: veri = f.readlines() with open("fihrist.txt", "w") as f: veri.insert(2, "Sedat Köz\t: 0322 234 45 45\n") f.writelines(veri) Bir önceki kodlardan farklı olarak bu kodlarda dosyamızı önce okuma kipinde açıp verileri veriadlıbirdeğişkeniçindesakladık.Ardındanaynıdosyayıbirkezdeyazmakipindeaçarak, gereklideğişikliklerilisteüzerindegerçekleştirdiktensonrabütünverileridosyayayazdık. Unutmayın, Python’da herhangi bir işlemi pek çok farklı şekilde gerçekleştirebilirsiniz. Biz yukarıdaolasıyöntemlerdenbazılarınıelealdık.Zatenbütünyöntemleritektekgöstermemiz pek mümkün olmazdı. Siz dosyalara ilişkin bilgilerinizi ve farklı araçları kullanarak aynı işlemleri çok daha farklı şekillerde de yapabilirsiniz. Yani karşı karşıya olduğunuz durumu değerlendirip, yukarıdaki kodlardan uygun olanını veya kendi bulduğunuz bambaşka bir yöntemikullanabilirsiniz. Bu arada, aslında yukarıdaki kodlarda uyguladığımız yöntem biraz güvensiz. Çünkü aynı dosyayı hem okuyup hem de bu dosyaya yeni veri ekliyoruz. Eğer bu işlemlerin herhangi bir aşamasında bir hata oluşursa, bütün değişiklikleri dosyaya işleyemeden dosya içeriğini tümdenkaybedebiliriz.Butürrisklerekarşıenuygunçözüm,okumaveyazmaişlemleriniayrı dosyalar üzerinde gerçekleştirmektir. Bunun nasıl yapılacağından biraz sonra söz edeceğiz. Bizşimdibaşkabirkonuyadeğinelim. 26.7 Dosyaya Erişme Kipleri Dosyalarkonusunuanlatırkenyukarıdaverdiğimizörneklerdendegördüğünüzgibi,Python’da dosyalaraerişimintürünüveniteliğinibelirleyenbazıkiplervar.Bukiplerdosyalarınaçılırken hangiyetkileresahipolacağınıveyaolmayacağınıbelirliyor.Gelinistersenizbukipleritektek elealalım. 26.7. DosyayaErişmeKipleri 475 PythonBelgeleri,Yayım4.1.3 tabularytabulary Kip Açıklaması "r" Buöntanımlıkiptir.Bukipdosyayıokumayetkisiyleaçar.Ancakbukipikullanabilmemiziçin,ilgilidosyanındisküzerindehalihazırdavarolmasıgerekir.EğerbukipteaçılmakistenendosyamevcutdeğilsePythonbizebirhatamesajıgösterecektir.Dediğimizgibi,buöntanımlıkiptir.DolayısıyladosyayıaçarkenherhangibirkipbelirtmezsekPythondosyayıbukipteaçmakistediğimizivarsayacaktır. "w" Bukipdosyayıyazmayetkisiyleaçar.Eğerbelirttiğinizaddabirdosyazatendisküzerindevarsa,Pythonhiçbirşeysormadandosyaiçeriğinisilecektir.Eğerbelirttiğinizaddabirdosyadiskteyoksa,Pythonoaddabirdosyayıotomatikolarakoluşturur. "a" Bukipdosyayıyazmayetkisiyleaçar.Eğerdosyazatendisküzerindemevcutsaiçeriğindeherhangibirdeğişiklikyapılmaz.Bukipteaçtığınızbirdosyayaeklediğinizverilervarolanverilereilaveedilir.EğerbelirttiğinizaddabirdosyayoksaPythonotomatikolarakoaddabirdosyayısiziniçinoluşturacaktır. "x" Bukipdosyayıyazmayetkisiyleaçar.Eğerbelirttiğinizaddabirdosyazatendisküzerindevarsa,Pythonvarolandosyayısilmekyerinesizebirhatamesajıgösterir.Zatenbukipin“w”kipindenfarkı,varolandosyalarısilmemesidir.Eğerbelirttiğinizaddabirdosyadiskteyoksa,bukipyardımıylaoadasahipbirdosyaoluşturabilirsiniz. "r+" Bukip,birdosyayıhemyazmahemdeokumayetkisiyleaçar.Bukipikullanabilmeniziçin,belirttiğinizdosyanındisküzerindemevcutolmasıgerekir. "w+" Bukipbirdosyayıhemyazmahemdeokumayetkisiyleaçar.Eğerdosyamevcutsaiçeriksilinir,eğerdosyamevcutdeğilseoluşturulur. "a+" Bukipbirdosyayıhemyazmahemdeokumayetkisiyleaçar.Eğerdosyazatendisküzerindemevcutsaiçeriğindeherhangibirdeğişiklikyapılmaz.Bukipteaçtığınızbirdosyayaeklediğinizverilervarolanverilereilaveedilir.EğerbelirttiğinizaddabirdosyayoksaPythonotomatikolarakoaddabirdosyayısiziniçinoluşturacaktır. "x+" Bukipdosyayıhemokumahemdeyazmayetkisiyleaçar.Eğerbelirttiğinizaddabirdosyazatendisküzerindevarsa,Pythonvarolandosyayısilmekyerinesizebirhatamesajıgösterir.Zatenbukipin“w+”kipindenfarkı,varolandosyalarısilmemesidir.Eğerbelirttiğinizaddabirdosyadiskteyoksa,bukipyardımıylaoadasahipbirdosyaoluşturupbudosyayıhemokumahemdeyazmayetkisiyleaçabilirsiniz. "rb" Bukip,metindosyalarıileikili(binary)dosyalarıayırtedensistemlerdeikilidosyalarıokumayetkisiyleaçmakiçinkullanılır.“r”kipiiçinsöylenenlerbukipiçindegeçerlidir. "wb" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıyazmayetkisiyleaçmakiçinkullanılır.“w”kipiiçinsöylenenlerbukipiçindegeçerlidir. "ab" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıyazmayetkisiyleaçmakiçinkullanılır.“a”kipiiçinsöylenenlerbukipiçindegeçerlidir. "xb" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıyazmayetkisiyleaçmakiçinkullanılır.“x”kipiiçinsöylenenlerbukipiçindegeçerlidir. "rb+" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıhemokumahemdeyazmayetkisiyleaçmakiçinkullanılır.“r+”kipiiçinsöylenenlerbukipiçindegeçerlidir. "wb+" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıhemokumahemdeyazmayetkisiyleaçmakiçinkullanılır.“w+”kipiiçinsöylenenlerbukipiçindegeçerlidir. "ab+" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıhemokumahemdeyazmayetkisiyleaçmakiçinkullanılır.“a+”kipiiçinsöylenenlerbukipiçindegeçerlidir. "xb+" Bukip,metindosyalarıileikilidosyalarıayırtedensistemlerdeikilidosyalarıhemokumahemdeyazmayetkisiyleaçmakiçinkullanılır.“x+”kipiiçinsöylenenlerbukipiçindegeçerlidir. Bütünbutabloyabaktığınızdailkbakıştasankibirsürüfarklıerişimkipiolduğunudüşünmüş olabilirsiniz. Ama aslında tabloyu biraz daha incelerseniz, temel olarak “r”, “w”, “a”, “x” ve “b” kiplerinin olduğunu, geri kalan kiplerin ise bunların kombinasyonlarından oluştuğunu göreceksiniz. Daha önce de söylediğimiz gibi, dosya işlemlerini pek çok farklı yöntemle gerçekleştirebilirsiniz. Yukarıdaki tabloyu dikkatlice inceleyerek, yapmak istediğiniz işleme uygunkipirahatlıklaseçebilirsiniz. Bu arada, yukarıdaki tabloda değindiğimiz ikili (binary) dosyalardan henüz söz etmedik. Bir sonrakibölümdebudosyatürünüdeelealacağız. 476 Bölüm26. TemelDosyaİşlemleri 27 BÖLÜM Dosyaların Metot ve Nitelikleri Dosyalara ilişkin olarak bir önceki bölümde anlattığımız şeylerin kafanıza yatması açısından size şu bilgiyi de verelim: Dosyalar da, tıpkı karakter dizileri ve listeler gibi, Python programlamadilindekiveritiplerindenbiridir.Dolayısıylatıpkıkarakterdizilerivelistelergibi, dosya(file)adlıbuveritipinindebazımetotlarıveniteliklerivardır.Gelinistersenizbumetot veniteliklerinnelerolduğunuşöylebirlisteleyelim: dosya = open("falanca_dosya.txt", "w") print(*[metot for metot in dir(dosya) if not metot.startswith("_")], sep="\n") Bukodlar,dosyaadlıveritipininbiziilgilendirenbütünmetotlarınıaltaltaekranabasacaktır. Eğeryukarıdakikodlarıanlamaktazorlukçektiyseniz,bunlarışöyledeyazabilirsiniz: dosya = open("falanca_dosya.txt", "w") for metot in dir(dosya): if not metot.startswith("_"): print(metot, sep="\n") Bildiğinizgibibukodlarbiröncekiyletamamenaynıanlamageliyor. Bu kodları çalıştırdığınızda karşınıza pek çok metot çıkacak. Biz buraya gelene kadar bu metotlarınenönemlilerinizateninceledik.İncelemediğimizyalnızcabirkaçönemlimetot(ve nitelik) kaldı. Gelin isterseniz henüz incelemediğimiz bu önemli metot ve nitelikleri gözden geçirelim. 477 PythonBelgeleri,Yayım4.1.3 27.1 closed Niteliği Bunitelik,birdosyanınkapalıolupolmadığınısorgulamamızısağlar.Dosyaadınınfolduğunu varsayarsak,buniteliğişöylekullanıyoruz: f.closed Eğerf adlıbudosyakapalıysaTrueçıktısı,açıksaFalseçıktısıverilecektir. 27.2 readable() Metodu Bumetotbirdosyanınokumayetkisinesahipolupolmadığınısorgulamamızısağlar.Eğerbir dosya“r”gibibirkipleaçılmışsa,yaniodosya‘okunabilir’özellikleisebumetotbizeTrueçıktısı verir.AmaeğerdosyayazmakipindeaçılmışsabumetotbizeFalseçıktısıverecektir. 27.3 writable() Metodu Bu metot bir dosyanın yazma yetkisine sahip olup olmadığını sorgulamamızı sağlar. Eğer bir dosya“w”gibibirkipleaçılmışsa,yaniodosya‘yazılabilir’özellikleisebumetotbizeTrueçıktısı verir.AmaeğerdosyaokumakipindeaçılmışsabumetotbizeFalseçıktısıverecektir. 27.4 truncate() Metodu Bu metot, henüz işlemediğimiz metotlar arasında en önemlilerinden biridir. Bu metot yardımıyladosyalarımızıistediğimizboyutagetirebiliyoruz. İngilizcede truncate kelimesi ‘budamak, kırpmak’ gibi anlamlara gelir. Bu metodun yaptığı iş debuanlamıylauyumludur.Bumetodutemelolarakşöylekullanıyoruz: >>> with open("falanca.txt", "r+") as f: ... f.truncate() Bukomutubuşekildekullandığımızdadosyanınbütüniçeriğisilinecektir.Yanibukodlar,sanki dosyayı“w”kipiyleaçmışsınızgibibiretkiortayaçıkaracaktır. truncate() metodu yukarıda gördüğünüz şekilde parametresiz olarak kullanılabileceği gibi, parametreliolarakdakullanılabilir.Bumetodunparantezleriarasına,dosyanınkaçbaytlıkbir boyutasahipolmasınıistediğiniziyazabilirsiniz.Örneğin: >>> with open("falanca.txt", "r+") as f: ... f.truncate(10) Bu kodlar, falanca.txt adlı dosyanın ilk 10 baytı dışındaki bütün verileri siler. Yani dosyayı yalnızca10baytlıkbirboyutasahipolacakşekildekırpar. Gelin isterseniz bu metotla ilgili bir örnek verelim. Elimizdeki dosyanın şu içeriğe sahip olduğunuvarsayalım: 478 Bölüm27. DosyalarınMetotveNitelikleri PythonBelgeleri,Yayım4.1.3 Ahmet Özbudak : 0533 123 23 34 Mehmet Sülün : 0532 212 22 22 Sami Sam : 0542 333 34 34 Amacımızdosyadakişuikisatırıtamamensilmek: Mehmet Sülün : 0532 212 22 22 Sami Sam : 0542 333 34 34 Yanidosyanınyeniiçeriğinintamolarakşöyleolmasınıistiyoruz: Ahmet Özbudak : 0533 123 23 34 Bununiçintruncate()metodundanyararlanarakşukodlarıyazabiliriz: with open("fihrist.txt", "r+") as f: f.readline() f.seek(f.tell()) f.truncate() Bu kodları bir dosyaya kaydedip çalıştırdığınızda, istediğiniz sonucu elde ettiğinizi göreceksiniz. Buradasırasıylaşuişlemlerigerçekleştirdik: 1. Önce dosyamızı hem okuma hem de yazma kipinde açtık. Çünkü aynı dosya üzerinde hemokumahemdeyazmaişlemlerigerçekleştireceğiz: with open("fihrist.txt", "r+") as f: 2. Ardındandosyadantekbirsatırokuduk: f.readline() 3. Daha sonra, truncate() metodunun imleç konumundan itibaren kırpma işlemi gerçekleştirebilmesi için imleci dosya içinde o anda bulunduğumuz konuma, yani ikinci satırın başına getirdik. Bildiğiniz gibi dosyaların tell() metodu, o anda dosya içindehangikonumdabulunduğumuzubildiriyor.Bizbirazönceyazdığımızreadline() komutu yardımıyla dosyadan bir satır okuduğumuz için, o anda ikinci satırın başında bulunuyoruz. İşte seek() metodunu ve tell() metodundan elde ettiğimiz bu konum bilgisinikullanarakimleciistediğimizkonumagetirdik: f.seek(f.tell()) 4. İmleciistediğimizkonumagetirdiğimizegöreartıkkırpmaişleminigerçekleştirebiliriz: f.truncate() Artıkelimizdeteksatırlıkbirdosyavar... truncate() metodunun, yukarıda anlattığımızdan farklı bir özelliği daha var. Her ne kadar truncate kelimesi ‘kırpmak’ anlamına gelse ve bu metotla dosya boyutlarını küçültebilsek bile,bumetodukullanarakaynızamandadosyaboyutlarınıartırabilirizde.Örneğinboyutu1 kilobaytolanbirdosyayı3kilobaytaçıkarmakiçinbumetoduşöylekullanabiliriz: 27.4. truncate()Metodu 479 PythonBelgeleri,Yayım4.1.3 >>> f = open("fihrist.txt", "r+") >>> f.truncate(1024*3) >>> f.close() Dosyanın boyutunu kontrol edecek olursanız, dosyanın gerçekten de 3 kilobayt’a çıktığını göreceksiniz. Peki bu metot bu işi nasıl yapıyor? Aslında bunun cevabı çok basit: Dosyanın sonuna gereken miktarda 0 ekleyerek... Zaten eğer fihrist.txt adlı bu dosyayı tekrar açıp okursanızbudurumukendinizdegörebilirsiniz: >>> f = open("fihrist.txt") >>> f.read() Gördüğünüzgibi,dosyasıfırlarladolu. 27.5 mode Niteliği Bunitelik,bizebirdosyanınhangikipteaçıldığınadairbilgiverir: >>> f = open("falanca.txt") >>> f.mode ’r’ Demekkibudosya“r”kipindeaçılmış... 27.6 name Niteliği Bunitelik,bizebirdosyanınadınıverir: >>> f.name ’falanca.txt’ 27.7 encoding Niteliği Bunitelik,bizebirdosyanınhangidilkodlamasıilekodlandığınısöyler: >>> f.encoding ’utf-8’ veya: >>> f.encoding ’cp1254’ #Windows 480 Bölüm27. DosyalarınMetotveNitelikleri PythonBelgeleri,Yayım4.1.3 (cid:242) Not Bu‘dilkodlaması’konusunuilerleyensayfalardaayrıntılıolarakinceleyeceğiz. Böylece dosyaların en önemli metot ve niteliklerini incelemiş olduk. Bu arada, gerek bu derste, gerekse önceki derslerde verdiğimiz örneklerden, ‘metot’ ile ‘nitelik’ kavramları arasındaki farkı anladığınızı zannediyorum. Metotlar bir iş yaparken, nitelikler bir değer gösterir. Nitelikler basit birer değişkenden ibarettir. Metotlar ise bir işin nasıl yapılacağı ile ilgili süreci tanımlar. Esasında bu ikisi arasındaki farkları çok fazla kafaya takmanıza gerek yok.Zamanla(özellikledebaşkaprogramlarınkaynakkodlarınıincelemeyebaşladığınızda)bu ikisi arasındaki farkı bariz bir biçimde göreceksiniz. O noktaya geldiğinizde, zaten kavramlar arasındakifarklarıgörmenizkonusundabizdesizeyardımcıolmayaçalışacağız. 27.7. encodingNiteliği 481 28 BÖLÜM İkili (Binary) Dosyalar Dosyalar çoğunlukla iki farklı sınıfa ayrılır: Metin dosyaları ve ikili dosyalar. Metin dosyaları derken neyi kastettiğimiz az çok anlaşılıyor. Eğer bir dosyayı bir metin düzenleyici ile açtığınızda herhangi bir dilde yazılmış ‘okunabilir’ bir metin görüyorsanız, o dosya bir metin dosyasıdır. Mesela Notepad, Gedit, Kwrite veya benzeri metin düzenleyicileri kullanarak oluşturduğunuz dosyalar birer metin dosyasıdır. Şimdiye kadar verdiğimiz bütün örnekler metindosyalarınıiçeriyordu.Peki‘ikili’(binary)dosyanedemek? İkili dosyalar ise, metin dosyalarının aksine, metin düzenleyicilerle açılamayan, açılmaya çalışıldığında ise çoğunlukla anlamsız karakterler içeren bir dosya türüdür. Resim dosyaları, müzik dosyaları, video dosyaları, MS Office dosyaları, LibreOffice dosyaları, OpenOffice dosyaları,vb.ikilidosyalaraörnektir. Önceki bölümlerde de ifade ettiğimiz gibi, bilgisayarlar yalnızca sayılarla işlem yapabilir. Bilgisayarlarınüzerindeişlemyapabildiğibusayıların0ve1adlıikisayıolduğunubiliyoruz. Peki bu iki farklı sayıyı kullanarak neler yapabiliriz? Aslında, bu iki farklı sayıyı kullanarak her türlüişlemiyapabiliriz:Basitveyakarmaşıkaritmetikhesaplamalar,metindüzenleme,resim veya video düzenleme, web siteleri hazırlama, uzaya mekik gönderme... Bütün bu işlemleri sadeceikifarklısayıkullanarakyapabiliriz.Dahadoğrusubilgisayarlaryapabilir. Durum böyle olmasına rağmen, ilk bilgisayarlar yalnızca hesaplama işlemleri için kullanılıyordu. Yani metin içeren işlemleri yapmak bilgisayarların değil, mesela daktiloların göreviolarakgörülüyordu.Budurumutelefonteknolojisiilekıyaslayabilirsiniz.Bildiğinizgibi, ilk telefonlar yalnızca iki kişi arasındaki sesli iletişimi sağlamak için kullanılıyordu. Ama yeni nesil telefonlar artık ikiden fazla kişi arasındaki sesli ve görüntülü iletişimi sağlayabilmenin yanısıra,önceleribirbirindenfarklıcihazlarlagerçekleştirilenişlemleriartıktekbaşınayerine getirebiliyor. İlkbilgisayarlardaisemetinlerin,dahadoğrusukarakterleringörevibirhaylisınırlıydı. Başta da söylediğimiz gibi, çoğunlukla dosyalar iki farklı sınıfa ayrılır: Metin dosyaları ve ikili dosyalar. Ama işin aslı sadece tek bir dosya türü vardır: İkili dosyalar (binary files). Yani bilgisayarlar açısından bütün dosyalar, içlerinde ne olursa olsun, birer ikili dosyadır ve içlerinde sadece 0’ları ve 1’leri barındırır. İşte bu 0 ve 1’lerin ne anlama geleceğini, işletim sistemlerive busistemler üzerinekurulu yazılımlarbelirler. Eğerbir dosyametin dosyasıysa 482 PythonBelgeleri,Yayım4.1.3 budosyadaki0ve1’lerbirerkarakter/harfolarakyorumlanır.Amaeğerdosyabirikilidosyaysa dosya içindeki 0 ve 1’ler özel birtakım veriler olarak ele alınır ve bu verileri okuyan yazılıma göre değer kazanır. Örneğin eğer ilgili dosya bir resim dosyasıyla, bu dosya herhangi bir resimgörüntüleyiciyazılımileaçıldığındakarşımızabirresimçıkar.Eğerilgilidosyabirvideo dosyasıyla, bu dosya bir video görüntüleyici yazılım ile açıldığında karşımıza bir video çıkar. Bu olgudan bir sonraki bölümde daha ayrıntılı olarak söz edeceğiz. Biz şimdilik işin sadece pratiğine yoğunlaşalım ve temel olarak iki farklı dosya çeşidi olduğunu varsayalım: Metin dosyalarıveikilidosyalar. Buraya gelene kadar hep metin dosyalarından söz etmiştik. Şimdi ise ikili dosyalardan söz edeceğiz. Hatırlarsanızmetindosyalarınıaçmakiçintemelolarakşöylebirkomutkullanıyorduk: f = open(dosya_adı, ’r’) Bu şekilde bir metin dosyasını okuma kipinde açmış oluyoruz. Bir metin dosyasını değil de, ikilibirdosyayıaçmakiçiniseşukomutukullanacağız: f = open(dosya_adı, ’rb’) Dosyaya erişme kiplerini gösterdiğimiz tabloda ikili erişim türlerini de verdiğimizi hatırlıyorsunuz. Pekinedenmetindosyalarıveikilidosyalariçinfarklıerişimkiplerikullanıyoruz? İşletim sistemleri satır sonları için birbirinden farklı karakterler kullanırlar. Örneğin GNU/Linux dağıtımlarında satır sonları \n karakteri ile gösterilir. Windows işletim sistemi ise satır sonlarını \r\n karakterleriyle gösterir. İşte Python herhangi bir dosyayı açarken, eğer o dosya bir metin dosyası ise, satır sonlarını gösteren karakterleri, dosyanın açıldığı işletim sistemine göre ayarlar. Yani satır sonlarını standart bir hale getirerek \n karakterine dönüştürür. Metin dosyaları ile ikili dosyalar arasında önemli bir fark bulunur: Bir metin dosyasındaki ufak değişiklikler dosyanın okunamaz hale gelmesine yol açmaz. Olabilecek en kötü şey, değiştirilen karakterin okunamaz hale gelmesidir. Ancak ikili dosyalarda ufak değişiklikler dosyanın tümden bozulmasına yol açabilir. Dolayısıyla Python’ın yukarıda bahsedilen satır sonu değişiklikleri ikili dosyaların bozulmasına yol açabilir. Yani eğer siz ikili bir dosyayı ‘rb’ yerine sadece ‘r’ gibi bir kiple açarsanız dosyanın bozulmasına yol açabilirsiniz. İkili bir dosyayı ‘rb’ (veya ‘wb’, ‘ab’, ‘xb’, vb.) gibi bir kipte açtığınızda Python satır sonlarına herhangi bir değiştirme-dönüştürme işlemi uygulamaz. Böylece dosya bozulma riskiyle karşı karşıya kalmaz. O yüzden, metin dosyalarını ve ikili dosyaları açarken farklı kipler kullanmamız gerektiğinedikkatediyoruz. 28.1 İkili Dosyalarla Örnekler Gelinistersenizbunoktadabirkaçörnekverelim. 28.1. İkiliDosyalarlaÖrnekler 483 PythonBelgeleri,Yayım4.1.3 28.1.1 PDF Dosyalarından Bilgi Alma Tıpkıresim,müzikvevideodosyalarıgibi,PDFdosyalarıdabirerikilidosyadır.Ohaldehemen önümüzebirPDFdosyasıalalımvebudosyayıokumakipindeaçalım: >>> f = open("falanca.pdf", "rb") Şimdidebudosyadan10baytlıkbirveriokuyalım: >>> f.read(10) b’%PDF-1.3\n4’ Bu çıktıda gördüğünüz ‘b’ işaretine şimdilik takılmayın. Birazdan bunun ne olduğunu bütün ayrıntılarıyla anlatacağız. Biz bu harfin, elimizdeki verinin bayt türünde bir veri olduğunu gösterenbirişaretolduğunubilelimyeter. Gördüğünüz gibi, bir PDF dosyasının ilk birkaç baytını okuyarak hem dosyanın bir PDF belgesi olduğunu teyit edebiliyoruz, hem de bu PDF belgesinin, hangi PDF sürümü ile oluşturulduğunu anlayabiliyoruz. Buna göre bu belge PDF talimatnamesinin 1.3 numaralı sürümüileoluşturulmuş. Eğerbizbubelgeyibirikilidosyaolarakdeğildebirmetindosyasıolarakaçmayaçalışsaydık şöylebirhataalacaktık: >>> f = open("falanca.pdf") >>> okunan = f.read() Traceback (most recent call last): File "<stdin>", line 1, in <module> File "C:\Python33\lib\encodings\cp1254.py", line 23, in decode return codecs.charmap_decode(input,self.errors,decoding_table)[0] UnicodeDecodeError: ’charmap’ codec can’t decode byte 0x9d in position 527: char acter maps to <undefined> Python’ın bu dosyanın bir ikili dosya olduğu konusunda bilgilendirerek, dosyanın düzgün bir şekildeaçılıpokunabilmesinisağlıyoruz. GelinbuPDFbelgesiüzerindebirazdahaçalışalım. PDFbelgelerinde,obelgehakkındabazıönemlibilgilerverenbirtakımözeletiketlerbulunur. Buetiketlerşunlardır: tabularytabulary Etiket Anlamı /Creator Belgeyioluşturanyazılım /Producer BelgeyiPDF’eçevirenyazılım /Title Belgeninbaşlığı /Author Belgeninyazarı /Subject Belgeninkonusu /Keywords Belgeninanahtarkelimeleri /CreationDate Belgeninoluşturulmazamanı /ModDate Belgenindeğiştirilmezamanı 484 Bölüm28. İkili(Binary)Dosyalar PythonBelgeleri,Yayım4.1.3 BuetiketlerintamamıbütünPDFdosyalarındatanımlıdeğildir.Amaözellikle/Produceretiketi herPDFdosyasındabulunur. ŞimdiörnekolmasıbakımındanelimizebirPDFdosyasıalalımvebunugüzelceokuyalım: >>> f = open("falanca.pdf", "rb") >>> okunan = f.read() Şimdide/Producerifadesinindosyaiçindegeçtiğinoktanınsıranumarasınıbulalım.Bildiğiniz gibi, dosyaların read() metodu bize bir karakter dizisi verir. Yine bildiğiniz gibi, karakter dizilerinin index() metodu yardımıyla bir öğenin karakter dizisi içinde geçtiği noktayı bulabiliyoruz.Yani: >>> producer_index = okunan.index(b"/Producer") Burada /Producer ifadesinin başına ‘b’ harfini yerleştirmeyi unutmuyoruz. Çünkü şu anda yaptığımızişlemikilibirdosyaiçindegeçenbirtakımbaytlarıaramaişlemidir. producer_index değişkeni, ‘/Producer’ ifadesinin ilk baytının dosya içindeki konumunu tutuyor.Kontroledelim: >>> producer_index 4077883 Budeğeringerçektende‘/Producer’ifadesininilkbaytınıdepoladığınıteyitedelim: >>> okunan[producer_index] 47 Daha önce de dediğimiz gibi, bilgisayarlar yalnızca sayıları görür. Bu sayının hangi karaktere karşılıkgeldiğinibulmakiçinchr()fonksiyonundanyararlanabilirsiniz: >>> chr(okunan[producer_index]) ’/’ Gördüğünüz gibi, gerçekten de producer_index değişkeni ‘/Producer’ ifadesinin ilk baytının dosya içindeki konumunu gösteriyor. Biz bu konumu ve bu konumun 50-60 bayt ötesini sorgularsak,PDFbelgesiniüretenyazılımınadınaulaşabiliriz.Dikkatlicebakın: >>> okunan[producer_index:producer_index+50] b’/Producer (Acrobat Distiller 2.0 for Macintosh)\r/T’ Hatta eğer bu çıktı üzerine split() metodunu uygularsak, çıktıyı daha kullanışlı bir hale getirebiliriz: >>> producer = okunan[producer_index:producer_index+50].split() >>> producer [b’/Producer’, b’(Acrobat’, b’Distiller’, b’2.0’, b’for’, b’Macintosh)’, b’/T’] 28.1. İkiliDosyalarlaÖrnekler 485 PythonBelgeleri,Yayım4.1.3 Buşekilde,ihtiyacımızolanbilgininistediğimizparçasınakolaycaulaşabiliriz: >>> producer[0] b’/Producer’ >>> producer[1] b’(Acrobat’ >>> producer[1:3] [b’(Acrobat’, b’Distiller’] Elbettebuyöntem,birPDFdosyasındangereklietiketlerialmanıneniyiyöntemideğildir.Ama henüzPythonbilgimizbukadarınıyapmamızamüsaadeediyor.Ancakyinede,yukarıdaörnek, birikilidosyadannasılverialınacağıkonusundasizeiyibirfikirverecektir. 28.1.2 Resim Dosyalarının Türünü Tespit Etme Dediğimizgibi,resimdosyaları,müzikdosyaları,videodosyalarıvebenzeridosyalarbirerikili dosyadır. Mesela resim dosyalarını ele alalım. Diyelim ki, resimlerin hangi türde olduğunu tespit eden bir program yazmak istiyorsunuz. Yani yazdığınız bu programla bir resim dosyasınınPNGmi,JPEGmi,TIFFmi,yoksaBMPmiolduğunuanlamakistiyorsunuz. Peki bir resim dosyasının hangi türde olduğunu bulmak için uzantısına baksanız olmaz mı? Asla unutmayın dosya uzantıları ile dosya biçimleri arasında doğrudan bir bağlantı yoktur. O yüzden dosya uzantıları, dosya biçimini anlamak açısından güvenilir bir yöntem değildir. Bir resim dosyasının sonuna hangi uzantıyı getirirseniz getirin, o dosya bir resim dosyasıdır. Yanimeselabirresimdosyasınınuzantısıyanlışlıklaveyabilerek.docolarakdeğiştirilmişse,o dosyabirWORDdosyasıhalinegelmez.İşteyazacağınızprogram,birresimdosyasınınuzantısı ne olursa olsun, hatta dosyanın bir uzantısı olmasa bile, o dosyanın hangi türde olduğunu söyleyebilecek. Bir resim dosyasının hangi türde olduğunu anlayabilmek için ilgili dosyanın ilk birkaç baytını okumanız yeterlidir. Bu birkaç bayt içinde o resim dosyasının türüne dair bilgileri bulabilirsiniz. Resim dosyalarının türlerini birbirinden ayırt etmenizi sağlayacak verilerin ne olduğunu, ilgili resim türünün teknik şartnamesine bakarak öğrenebilirsiniz. Ancak teknik şartnameler genellikleokumasızormetinlerdir.Buyüzden,doğrudanşartnameyiokumakyerine,Internet üzerinde kısa bir araştırma yaparak konuyu daha kolay anlamanızı sağlayacak yardımcı belgelerdendeyardımalabilirsiniz. 486 Bölüm28. İkili(Binary)Dosyalar PythonBelgeleri,Yayım4.1.3 JPEG JPEGbiçimiileilgilibilgilerihttps://jpeg.org/adresindebulabilirsiniz.JPEGdosyabiçiminidaha iyianlamanızısağlayacakyardımcıkaynakiseşudur: 1. http://www.faqs.org/faqs/jpeg-faq/part1/section-15.html Yukarıda verdiğimiz adreslerdeki bilgilere göre bir JPEG dosyasının en başında şu veriler bulunur: FF D8 FF E0 ? ? 4A 46 49 46 00 Ancak eğer ilgili JPEG dosyası bir CANON fotograf makinesi ile oluşturulmuşsa bu veri dizisi şöyledeolabilir: FF D8 FF E0 ? ? 45 78 69 66 00 Burada soru işareti ile gösterdiğimiz kısım, yani dosyanın 5. ve 6. baytları farklı JPEG dosyalarında birbirinden farklı olabilir. Dolayısıyla bir JPEG dosyasını başka resim dosyalarından ayırabilmek için dosyanın ilk dört baytına bakmamız, sonraki iki baytı atlamamızvebunlardansonragelenbeşbaytıkontroletmemizyeterliolacaktır. Yukarıda gördükleriniz birer on altılı (hex) sayıdır. Bunlar onlu düzende sırasıyla şu sayılara karşılıkgelir: 255 216 255 224 ? ? 74 70 73 70 0 255 216 255 224 ? ? 45 78 69 66 0 #canon Budizileriçindeözellikleşudörtsayıbiziyakındanilgilendiriyor: 74 70 73 70 45 78 69 66 #canon Busayılarsırasıyla‘J’,‘F’,‘I’,‘F’ve‘E’,‘x’,‘i’,‘f’harflerinekarşılıkgelir.YanibirJPEGdosyasınıayırt edebilmek için ilgili dosyanın 7-10 arası baytlarının ne olduğuna bakmamız yeterli olacaktır. Eğer bu aralıkta ‘JFIF’ veya ‘Exif’ ifadeleri varsa, o dosya bir JPEG dosyasıdır. Buna göre şöyle birkodyazabiliriz: f = open(dosya_adı, ’rb’) data = f.read(10) if data[6:11] in [b"JFIF", b"Exif"]: print("Bu dosya JPEG!") else: print("Bu dosya JPEG değil!") Buradaherhangibirresimdosyasınınilkonbaytınıokuduköncelikle: data = f.read(10) Çünküaradığımızbilgilerilkonbaytiçindeyeralıyor. Daha sonra okuduğumuz kısmın 7 ila 10. baytları arasında kalan verinin ne olduğuna bakıyoruz: 28.1. İkiliDosyalarlaÖrnekler 487 PythonBelgeleri,Yayım4.1.3 if data[6:11] in [b"JFIF", b"Exif"]: ... Eğerilgiliaralıkta‘JFIF’veya‘Exif’baytlarıyeralıyorsabudosyanınbirJPEGdosyasıolduğuna kararveriyoruz. Yukarıdaki kodları elinizdeki bir JPEG dosyasına uygulayarak kendi kendinize pratik yapabilirsiniz. Meselabenimelimded1.jpg,d2.jpgved3.jpegadlıüçfarklıJPEGdosyasıvar: dosyalar = ["d1.jpg", "d2.jpg", "d3.jpeg"] Budosyalarınilkonarbaytınıokuyorum: for f in dosyalar: okunan = open(f, ’rb’).read(10) print(okunan) Buradanşuçıktıyıalıyorum: d1.jpg b’\xff\xd8\xff\xe0\x00\x10JFIF’ d2.jpg b’\xff\xd8\xff\xe1T\xaaExif’ d3.jpeg b’\xff\xd8\xff\xe0\x00\x10JFIF’ GördüğünüzgibibuçıktılaryukarıdaJPEGdosyalarınailişkinolarakverdiğimizbaytdizilimiile uyuşuyor.Meselailkdosyayıelealalım: d1.jpg b’\xff\xd8\xff\xe0\x00\x10JFIF’ Buradaşubaytlarvar: \xff \xd8 \xff \xe0 \x00 \x10 J F I F Sayıların başındaki \x işaretleri bunların birer on altılı sayı olduğunu gösteren bir işarettir. Dolayısıylayukarıdakileridahanetinceleyebilmekiçinşöyledeyazabiliriz: ff d8 ff e0 00 10 J F I F Şimdideikincidosyanınçıktısınıelealalım: d2.jpg b’\xff\xd8\xff\xe1T\xaaExif’ Buradadaşubaytlarvar: ff d8 ff e1T aa E x i f İşte dosyaların türünü ayırt etmek için bu çıktılardaki son dört baytı kontrol etmemiz yeterli olacaktır: for f in dosyalar: okunan = open(f, ’rb’).read(10) if okunan[6:11] in [b’JFIF’, b’Exif’]: (sonrakisayfayadevam) 488 Bölüm28. İkili(Binary)Dosyalar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Evet {} adlı dosya bir JPEG!".format(f)) else: print("{} JPEG değil!".format(f)) Bu kodları elinizde bulunan farklı türdeki dosyalara uygulayarak, aldığınız çıktıları inceleyebilirsiniz. PNG PNG dosya biçiminin teknik şartnamesine http://www.libpng.org/pub/png/spec/ adresinden ulaşabilirsiniz. Ayrıca yardımcı kaynak olarak da https://www.fileformat.info/format/png/egff.htm adresindekibelgeyikullanabilirsiniz. Şartnamade, http://www.libpng.org/pub/png/spec/1.2/PNG-Rationale.html#R. PNG-file-signaturesayfasındakibilgiyegörebirPNGdosyasınınilk8baytımutlakaaşağıdaki değerleriiçeriyor: tabularytabulary onludeğer 13780787113102610 onaltılıdeğer 89504e470d0a1a0a karakterdeğeri \211PNG\r\n\032\n ŞimdielimizeherhangibirPNGdosyasıalarakbudurumuteyitedelim: >>> f = open("falanca.png", "rb") >>> okunan = f.read(8) Şartnamededesöylendiğigibi,birPNGdosyasınıötekitürlerdenayırtedebilmekiçindosyanın ilk8baytınabakmamızyeterliolacaktır.Oyüzdenbizdeyukarıdakikodlardasadeceilk8baytı okumaklayetindik. Bakalımilk8bayttanelervarmış: >>> okunan b’\x89PNG\r\n\x1a\n’ Bu değerin, şartnamedeki karakter değeri ile aynı olup olmadığını sorgulayarak herhangi bir dosyanınPNGolupolmadığınakararverebilirsiniz: >>> okunan == b"\211PNG\r\n\032\n" True Dolayısıylaşunabenzerbirkodyazarak,farklıresimdosyalarınıntürünütespitedebilirsiniz: 28.1. İkiliDosyalarlaÖrnekler 489 PythonBelgeleri,Yayım4.1.3 for f in dosyalar: okunan = open(f, ’rb’).read(10) if okunan[6:11] in [b’JFIF’, b’Exif’]: print("{} adlı dosya bir JPEG!".format(f)) elif okunan[:8] == b"\211PNG\r\n\032\n": print("{} adlı dosya bir PNG!".format(f)) else: print("Türü bilinmeyen dosya: {}".format(f)) Bu kodlarda bir resim dosyasının ilk 10 baytını okuduk. 7-11 arası baytların içinde ‘JFIF’ veya ‘Exif’baytlarıvarsaodosyanınbirJPEGolduğuna;ilk8baytb”211PNGrn032n”adlıbaytdizisine eşitsedeodosyanınbirPNGolduğunakararveriyoruz. GIF GIF şartnamesine https://www.w3.org/Graphics/GIF/spec-gif89a.txt adresinden ulaşabilirsiniz. BirdosyanınGIFolupolmadığınakararverebilmekiçinilk3baytınıokumanızyeterliolacaktır. StandartbirGIFdosyasınınilküçbaytı‘G’,‘I’ve‘F’karakterlerindenoluşur.Dosyanınsonraki 3baytıiseGIF’insürümnumarasınıverir.19.08.2024itibariyleGIFstandardınınşusürümleri bulunmaktadır: 1. 87a-Mayıs1987 2. 89a-Temmuz1989 DolayısıylastandartbirGIFdosyasınınilk6baytışöyledir: ‘GIF87a’veya‘GIF89a’ Eğer bir dosyanın GIF olup olmadığını anlamak isterseniz dosyanın ilk 3 veya 6 baytını denetlemenizyeterliolacaktır: for f in dosyalar: okunan = open(f, ’rb’).read(10) if okunan[6:11] in [b’JFIF’, b’Exif’]: print("{} adlı dosya bir JPEG!".format(f)) elif okunan[:8] == b"\211PNG\r\n\032\n": print("{} adlı dosya bir PNG!".format(f)) elif okunan[:3] == b’GIF’: print("{} adlı dosya bir GIF!".format(f)) else: print("Türü bilinmeyen dosya: {}".format(f)) 490 Bölüm28. İkili(Binary)Dosyalar PythonBelgeleri,Yayım4.1.3 TIFF TIFF şartnamesine https://www.itu.int/itudoc/itu-t/com16/tiff-fx/docs/tiff6.pdf adresinden ulaşabilirsiniz.BuşartnameyegörebirTIFFdosyasışunlardanherhangibiriilebaşlar: 1. ‘II’ 2. ‘MM’ Dolayısıyla, bir TIFF dosyasını tespit edebilmek için dosyanın ilk 2 baytına bakmanız yeterli olacaktır: for f in dosyalar: okunan = open(f, ’rb’).read(10) if okunan[6:11] in [b’JFIF’, b’Exif’]: print("{} adlı dosya bir JPEG!".format(f)) elif okunan[:8] == b"\211PNG\r\n\032\n": print("{} adlı dosya bir PNG!".format(f)) elif okunan[:3] == b’GIF’: print("{} adlı dosya bir GIF!".format(f)) elif okunan[:2] in [b’II’, b’MM’]: print("{} adlı dosya bir TIFF!".format(f)) else: print("Türü bilinmeyen dosya: {}".format(f)) BMP BMP türündeki resim dosyalarına ilişkin bilgi için https://www.loc.gov/preservation/digital/ formats/fdd/fdd000189.shtmladresinebaşvurabilirsiniz. Bunagöre,BMPdosyaları‘BM’ilebaşlar.Yani: for f in dosyalar: okunan = open(f, ’rb’).read(10) if okunan[6:11] in [b’JFIF’, b’Exif’]: print("{} adlı dosya bir JPEG!".format(f)) elif okunan[:8] == b"\211PNG\r\n\032\n": print("{} adlı dosya bir PNG!".format(f)) elif okunan[:3] == b’GIF’: print("{} adlı dosya bir GIF!".format(f)) elif okunan[:2] in [b’II’, b’MM’]: print("{} adlı dosya bir TIFF!".format(f)) elif okunan[:2] in [b’BM’]: print("{} adlı dosya bir BMP!".format(f)) else: print("Türü bilinmeyen dosya: {}".format(f)) Gördüğünüz gibi ikili dosyalar, baytların özel bir şekilde dizildiği ve özel bir şekilde yorumlandığıbirdosyatürüdür.Dolayısıylaikilidosyalarlaçalışabilmekiçin,ikilidosyanınbayt diziliminiyakındantanımakgerekiyor. 28.1. İkiliDosyalarlaÖrnekler 491 29 BÖLÜM Basit bir İletişim Modeli Bu bölümde, bilgisayarların çalışma mantığını, verileri nasıl işlediğini, sayılarla karakter dizilerininasıltemsilettiğinidahaiyivedahanetbirşekildeanlayabilmekiçinbasitbiriletişim modelikuracağız. Şimdi şöyle bir durum hayal edin: Diyelim ki, hatlar üzerinden iletilen elektrik akımı yoluyla bir arkadaşınızla haberleşmenizi sağlayacak bir sistem tasarlıyorsunuz. Bu sistem, verici tarafında elektrik akımının gönderilmesini sağlayan bir anahtardan, alıcı tarafında ise, gelen akımın şiddetine göre loş veya parlak ışık veren bir ampulden oluşuyor. Eğer vericiden gönderilen elektrik akımı düşükse alıcı loş bir ışık, eğer gelen akım yüksekse alıcı parlak bir ışıkgörecek.Elbetteeğeristersenizdüşükakım-yüksekakımkarşıtlığıyerineakımvarlığı-akım yokluğukarşıtlığınıdakullanabilirsiniz.Böylecevericidenakımgönderildiğindeampulyanar, gönderilmediğinde ise söner. Bana düşük akım-yüksek akım karşıtlığı daha kullanışlı geldiği içinböyletercihettim.Siztabiikiöbürtürlüsünüdetercihedebilirsiniz. Yukarıda bahsedildiği gibi sistemimizi kurduk diyelim. Peki ama bu sistem verici ile alıcı arasındabasitdeolsabiriletişimkurmamızınasılolacakdasağlayacak? Aslındabununcevabıvemantığıçokbasit.Gördüğünüzgibi,busistemdeikifarklıdurumsöz konusu:Loşışıkveparlakışık(veyayananampulvesönmüşampul). Bu ikili yapıyı, tahmin edebileceğiniz gibi, ikili (binary) sayma sistemi aracılığıyla rahatlıkla temsiledebiliriz.Meselaloşışıkdurumuna0,parlakışıkdurumunaise1diyebiliriz.Dolayısıyla verici,ampulünloşışıkvermesinisağlayacakdüşükbirakımgönderdiğindebunundeğerini0, ampulünyüksekışıkvermesinisağlayacakyüksekbirakımgönderdiğindeisebunundeğerini 1olarakdeğerlendirebiliriz. Burada yaptığımız dönüştürme işlemine teknik olarak ‘kodlama’ (encoding) adı verilir. Bu kodlama sistemine göre biz, iki farklı elektrik akımı değerini, yani loş ışık ve parlak ışık değerlerini sırasıyla ikili sistemdeki 0 ve 1 sayıları ile eşleştirip, loş ışığa 0, parlak ışığa ise 1dedik. Hemen anlayacağınız gibi, bahsettiğimiz bu hayali sistem, telgraf iletişimine çok benziyor. İşte gerçekte de kullanılan telgraf sistemine çok benzeyen bu basitleştirilmiş model bizim bilgisayarlarınçalışmamantığınıdadahanetbirşekildeanlamamızısağlayacak. 492 PythonBelgeleri,Yayım4.1.3 29.1 8 Bitlik bir Sistem Hatırlarsanız ikili sayma sisteminde 0’lar ve 1’lerin oluşturduğu her bir basamağa ‘bit’ adını veriyorduk. (cid:242) Not Bit kelimesi İngilizcede ‘binary’ (ikili) ve ‘digit’ (rakam) kelimelerinin birleştirilmesi ile üretilmiştir. Bu bilgiye göre mesela 0 sayısı bir bitlik bir sayı iken, 1001 sayısı dört bitlik bir sayıdır. İletişimimizi eksiksiz bir biçimde sağlayabilmemiz, yani gereken bütün karakterleri temsil edebilmemiz için, sistemimizin 8 hanelik bir sayı kapasitesine sahip olması, yani teknik bir dilleifadeetmekgerekirsesistemimizin8bitlikolmasıherhaldeyeterliolacaktır. 8bitlikbiriletişimsisteminde10’akadarşuşekildesayabiliriz: >>> for i in range(10): ... print(bin(i)[2:].zfill(8)) ... 00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 00001001 Verici tarafındaki kişi elindeki anahtar yardımıyla farklı kuvvetlere sahip sinyalleri art arda göndererek yukarıda gösterildiği gibi on farklı sayıyı alıcıya iletebilir. Sistemimizin 8 bitlik olduğunu düşünürsek karşı tarafa 0 sayısı ile birlikte toplam 2 ** 8 = 256 farklı sinyal gönderebiliriz: >>> for i in range(256): ... print(bin(i)[2:].zfill(8)) 00000000 00000001 00000010 00000011 00000100 ... ... ... 11111001 11111010 11111011 (sonrakisayfayadevam) 29.1. 8BitlikbirSistem 493 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 11111100 11111101 11111110 11111111 Gördüğünüzgibi,bizim8bitlikbusistemlegönderebileceğimizsonsinyal,yanisayı255’tir.Bu sistemlebundanbüyükbirsayıyıgönderemeyiz.Budurumukendigözlerinizlegörmekiçinşu kodlarıçalıştırın: >>> for i in range(256): ... print(bin(i)[2:], i.bit_length(), sep="\t") Burada ilk sütun 256’ya kadar olan sayıların ikili sistemdeki karşılıklarını, ikinci sütun ise bu sayıların bit uzunluğunu gösteriyor. Bu çıktıyı incelediğinizde de göreceğiniz gibi, 8 bit uzunluğasahipsonsayı255’tir.256sayısıise9bituzunluğasahiptir.Yani256sayısımecburen bizimsistemimizindışındadır: >>> bin(255)[2:] ’11111111’ >>> (255).bit_length() 8 >>> bin(256)[2:] ’100000000’ >>> (256).bit_length() 9 Dediğimizgibi,busistemdeelimizdetoplam8bitvar.Yanibusistemikullanarak0’dan256’ya kadarsayıp,busayılarıalıcıyailetebiliriz. Peki verici ile alıcı arasında birtakım sayıları gönderip alabilmek ne işimize yarar? Yani bu iş nedenbukadarönemli? Busorularıncevabınıbirazdanvereceğiz,amaondanöncedahaönemlibirkonuyadeğinelim. 494 Bölüm29. BasitbirİletişimModeli PythonBelgeleri,Yayım4.1.3 29.2 Hata Kontrolü Buraya kadar her şey yolunda. Alıcı ve verici arasındaki iletişimi elektrik akımı vasıtasıyla, 8 bitlik bir sistem üzerinden sağlayabiliyoruz. Ancak sistemimizin çok önemli bir eksiği var. Biz bu sistemde hiçbir hata kontrolü yapmıyoruz. Yani vericiden gelen mesajın doğruluğunu test eden hiçbir ölçütümüz yok. Zira alıcı ile verici arasında gidip gelen veriler pek çok farklı şekilde ve sebeple bozulmaya uğrayabilir. Örneğin, gönderilen veri alıcı tarafından doğruanlaşılamayabilirveyaelektriksinyalleriniiletenkablolardakiarızalarsinyallerindoğru iletilmesiniengelleyebilir. İşte bütün bunları hesaba katarak, iletişimin doğru bir şekilde gerçekleşebilmesini sağlamak amacıylasistemimiziçinbasitbirhatakontrolsürecitasarlayalım. Dediğimizgibi,elimizdekisistemtoplam256’yakadarsaymamızaolanaktanıyor.Çünkübizim sistemimiz8bitlikbirsistem.Busistemebirhatakontrolmekanizmasıekleyebilmekiçinveri iletimini8bitten7biteçekeceğiz.Yaniiletişimimizitoplam2**7=127sayıilesınırlayacağız. Boştakalan8.bitiisebahsettiğimizbuhatakontrolmekanizmasınaayıracağız. Pekihatakontrolmekanizmamıznasılişleyecek? Çokbasit:Vericidenalıcıyaulaşanverilerintekmiyoksaçiftmiolduğunabakacağız. Bunagöresistemimizşöyleçalışacak: Diyelimkivericialıcıyasinyalleraracılığıylaşusayıyıgöndermekistiyor: 0110111 Bu arada, bunun 7 bitlik bir sayı olduğuna dikkat edin. Dediğimiz gibi, biz kontrol mekanizmamızı kurabilmek için elimizdeki 8 bitlik kapasitenin 7 bitini kullanacağız. Boşta kalan8.bitiisekontrolmekanizmasınatahsisedeceğiz. Nediyorduk?Evet,bizkarşıtarafa7bitlikbirsayıolan0110111sayısınıgöndermekistiyoruz. Busayıyıgöndermedenönce,içindeki1’lerinmiktarınabakarakbusayınıntekmiyoksaçiftmi olduğunakararverelim.Buradatoplambeşadet1sayısıvar.Yanibusayıbirteksayıdır.Eğer göndermekistediğimizsayıbirteksayıise,karşıtarafaulaştığındadabirteksayıolmalıdır. Bizbusistemiçinşöylebirprotokoltasarlayabiliriz: Busistemdebütünsayılarkarşıtarafabir‘teksayı’olarakiletilmelidir.Eğeriletilen sayılar arasında bir çift sayı varsa, o sayı hatalı iletilmiş veya iletim esnasında bozulmuşdemektir. Peki biz iletilen bütün sayıların bir tek sayı olmasını nasıl sağlayacağız? İşte bu işlemi, boşa ayırdığımızo8.bitilegerçekleştireceğiz: Eğerkarşıtarafailetilenbirsayızatentekse,osayınınbaşına0ekleyeceğiz.Böylece sayının teklik-çiftlik durumu değişmemiş olacak. Ama eğer iletilecek sayı çiftse, o sayının başına 1 ekleyeceğiz. Böylece çift sayıyı, sistemimizin gerektirdiği şekilde, teksayıyaçevirmişolacağız. Örnek olarak 0110111 sayısını verelim. Bu sayıda toplam beş adet 1 var. Yani bu sayı bir tek sayı.Dolayısıylabusayınınbaşınabiradet0ekliyoruz: 0 0110111 29.2. HataKontrolü 495 PythonBelgeleri,Yayım4.1.3 Böylece sayımızın teklik-çiftlik durumu değişmemiş oluyor. Karşı taraf bu sayıyı aldığında 1’lerinmiktarınabakarakbuverinindoğruiletildiğindeneminoluyor. Birdeşusayıyabakalım: 1111011 Bu sayıda toplam altı adet 1 sayısı var. Yani bu sayı bir çift sayı. Bir sayının sistemimiz tarafından ‘hatasız’ olarak kabul edilebilmesi için bu sayının bir tek sayı olması gerekiyor. Bu yüzdenbizbusayıyıteksayıyaçevirmekiçinbaşınabiradet1sayıekliyoruz: 1 1111011 Böylece sayımızın içinde toplam yedi adet 1 sayısı olmuş ve böylece sayımız tek sayıya dönüşmüşoluyor. Teknik olarak ifade etmemiz gerekirse, yukarıda yaptığımız kontrol türüne ‘eşlik denetimi’ (parity check) adı verilir. Bu işlemi yapmamızı sağlayan bit’e ise ‘eşlik biti’ (parity bit) denir. İkitüreşlikdenetimibulunur: 1. Tekeşlikdenetimi(oddparitycheck) 2. Çifteşlikdenetimi(evenparitycheck) Biz kendi sistemimizde hata kontrol mekanizmasını bütün verilerin bir ‘tek sayı’ olması gerekliliği üzerine kurduk. Yani burada bir ‘tek eşlik denetimi’ gerçekleştirmiş olduk. Elbette bütünverilerinbirçiftsayıolmasıgerekliliğiüzerinedekurabilirdikbusistemi.Yaniisteseydik ‘çift eşlik denetimi’ de yapabilirdik. Bu tamamen bir tercih meselesidir. Bu tür sistemlerde yaygınolarak‘tekeşlikdenetimi’kullanıldığıiçinbizdebunutercihettik. Bu örneklerden de gördüğünüz gibi, toplam 8 bitlik kapasitemizin 7 bitini veri aktarımı için, kalan1bitiniisealınıpverilenbuverilerindoğruluğunudenetlemekiçinkullanıyoruz.Elbette kullandığımız hata kontrol mekanizması epey zayıf bir sistemdir. Ama, iletişim sistemleri arasında verilerin hatasız bir şekilde aktarılıp aktarılamadığını kontrol etmeye yarayan bir sistem olan eşlik denetiminin, bugün bilgisayarın belleklerinde (RAM) dahi kullanılmaya devamettiğinisöylemedengeçmeyelim... 29.3 Karakterlerin Temsili Yukarıdaanlattıklarımızdandagördüğünüzgibi,sistemimizikullanarak7bitüzerindentoplam 127sayıgönderebiliyoruz.Tabiikisistemimiz8bitolduğuiçin1bitdeboştakalıyor.İşteboşta duran bu 1 biti ise eşlik denetimi için kullanıyoruz. Ama elbette alıcı ile verici arasında sayı alışverişi yapmak pek de heyecan uyandırıcı bir faaliyet değil. Karşı tarafa sayısal mesajlar yerinebirtakımsözelmesajlariletebilsekherhaldeçokdahakeyifliolurdu... Şunu asla unutmayın. Eğer bir noktadan başka bir noktaya en az iki farklı sinyal yolu ile birtakım sayısal verileri gönderebiliyorsanız aynı şekilde sözel verileri de rahatlıkla gönderebilirsiniz. Tıpkı düşük voltaj ve yüksek voltaj değerlerini sırasıyla 0 ve 1 sayıları ile temsilettiğinizgibi,karakterleridebuikisayıiletemsiledebilirsiniz.Yapmanızgerekentekşey hangi sayılarınhangi karakterlerekarşılık geleceğinibelirlemekten ibarettir.Mesela elimizde sayılarlakarakterlerieşleştirenşöylebirtabloolduğunuvarsayalım: 496 Bölüm29. BasitbirİletişimModeli PythonBelgeleri,Yayım4.1.3 tabularytabulary sayı karakter sayı karakter sayı karakter sayı karakter 0 ‘a’ 1 ‘b’ 10 ‘c’ 11 ‘d’ 100 ‘e’ 101 ‘f’ 110 ‘g’ 111 ‘h’ 1000 ‘i’ 1001 ‘j’ 1010 ‘k’ 1011 ‘l’ 1100 ‘m’ 1101 ‘n’ 1110 ‘o’ 1111 ‘p’ 10000 ‘q’ 10001 ‘r’ 10010 ‘s’ 10011 ‘t’ 10100 ‘u’ 10101 ‘v’ 10110 ‘w’ 10111 ‘x’ 11000 ‘y’ 11001 ‘z’ 11010 ‘A’ 11011 ‘B’ 11100 ‘C’ 11101 ‘D’ 11110 ‘E’ 11111 ‘F’ 100000 ‘G’ 100001 ‘H’ 100010 ‘I’ 100011 ‘J’ 100100 ‘K’ 100101 ‘L’ 100110 ‘M’ 100111 ‘N’ 101000 ‘O’ 101001 ‘P’ 101010 ‘Q’ 101011 ‘R’ 101100 ‘S’ 101101 ‘T’ 101110 ‘U’ 101111 ‘V’ 110000 ‘W’ 110001 ‘X’ 110010 ‘Y’ 110011 ‘Z’ Bu tabloda toplam 52 karakter ile 52 sayı birbiriyle eşleştirilmiş durumda. Mesela vericiden 0 sinyali geldiğinde bu tabloya göre biz bunu ‘a’ harfi olarak yorumlayacağız. Örneğin karşı tarafa‘python’mesajınıiletmekiçinsırasıylaşusinyallerigöndereceğiz: 1111, 11000, 10011, 111, 1110, 1101 Gördüğünüzgibi,elimizdeki127sayının52’siniharflereayırdıkveelimizde75tanedahasayı kaldı. Eğer isterseniz geri kalan bu sayıları da birtakım başka karakterlere veya işaretlere ayırarak, alıcı ve verici arasındaki bütün iletişimin eksiksiz bir şekilde gerçekleşmesini sağlayabilirsiniz.Örneğinşöylebirtablooluşturabilirsiniz: 29.3. KarakterlerinTemsili 497 PythonBelgeleri,Yayım4.1.3 tabularytabulary sayı karakter sayı karakter sayı karakter sayı karakter 0 ‘0’ 1 ‘1’ 10 ‘2’ 11 ‘3’ 100 ‘4’ 101 ‘5’ 110 ‘6’ 111 ‘7’ 1000 ‘8’ 1001 ‘9’ 1010 ‘a’ 1011 ‘b’ 1100 ‘c’ 1101 ‘d’ 1110 ‘e’ 1111 ‘f’ 10000 ‘g’ 10001 ‘h’ 10010 ‘i’ 10011 ‘j’ 10100 ‘k’ 10101 ‘l’ 10110 ‘m’ 10111 ‘n’ 11000 ‘o’ 11001 ‘p’ 11010 ‘q’ 11011 ‘r’ 11100 ‘s’ 11101 ‘t’ 11110 ‘u’ 11111 ‘v’ 100000 ‘w’ 100001 ‘x’ 100010 ‘y’ 100011 ‘z’ 100100 ‘A’ 100101 ‘B’ 100110 ‘C’ 100111 ‘D’ 101000 ‘E’ 101001 ‘F’ 101010 ‘G’ 101011 ‘H’ 101100 ‘I’ 101101 ‘J’ 101110 ‘K’ 101111 ‘L’ 110000 ‘M’ 110001 ‘N’ 110010 ‘O’ 110011 ‘P’ 110100 ‘Q’ 110101 ‘R’ 110110 ‘S’ 110111 ‘T’ 111000 ‘U’ 111001 ‘V’ 111010 ‘W’ 111011 ‘X’ 111100 ‘Y’ 111101 ‘Z’ 111110 ‘!’ 111111 ‘”’ 1000000 ‘#’ 1000001 ‘$’ 1000010 ‘%’ 1000011 ‘&’ 1000100 “’”’ 1000101 ‘’(’ 1000110 ‘)’ 1000111 ‘*’ 1001000 ‘+’ 1001001 ‘,’ 1001010 ‘-’ 1001011 ‘.’ 1001100 ‘/’ 1001101 ‘:’ 1001110 ‘;’ 1001111 ‘<’ 1010000 ‘=’ 1010001 ‘>’ 1010010 ‘?’ 1010011 ‘@’ 1010100 ‘[’ 1010101 ‘\’ 1010110 ‘]’ 1010111 ‘^’ 1011000 ‘_’ 1011001 ‘’ 1011010 ‘{’ 1011011 ‘’ 1011100 ‘}’ 1011101 ‘~’ 1011110 ‘‘ 1011111 ‘t’ 1100000 ‘n’ 1100001 ‘r’ 1100010 ‘x0b’ 1100011 ‘x0c’ Aslında yukarıda anlattığımız sayı-karakter eşleştirme işleminin, ta en başta yaptığımız sinyal-sayıeşleştirmeişlemiylemantıkolarakaynıolduğunadikkatiniziçekmekisterim. Sistemimizi tasarlarken, iletilen iki farklı sinyali 0 ve 1 sayıları ile temsil etmiştik. Yani bu sinyalleri 0 ve 1’ler halinde kodlamıştık. Şimdi ise bu sayıları karakterlere dönüştürüyoruz. Yaniyinebirkodlama(encoding)işlemigerçekleştiriyoruz. Baştan beri anlattığımız bu küçük iletişim modeli, sayıların ve karakterlerin nasıl temsil edilebileceği konusunda bize epey bilgi verdi. Bu arada, yukarıda anlattığımız sistem her ne kadar hayali de olsa, bu sisteme benzeyen sistemlerin tarih boyunca kullanıldığını ve hatta bugün kullandığımız bütün iletişim sistemlerinin de yukarıda anlattığımız temel üzerindeşekillendiğinibelirtmedengeçmeyelim.ÖrneğintelgrafiletişimindekullanılanMors alfabesi yukarıda tarif ettiğimiz sisteme çok benzer. Mors alfabesi, kısa ve uzun sinyallerle karakterlerin eşleştirilmesi yoluyla oluşturulmuştur. Mors sisteminde farklı sinyaller (tıpkı bizimsistemimizdeolduğugibi)farklıharflerekarşılıkgelir: 498 Bölüm29. BasitbirİletişimModeli PythonBelgeleri,Yayım4.1.3 Mors alfabesinin bizim oluşturduğumuz sisteme mantık olarak ne kadar benzediğine dikkat edin. Bu sistemin benzeri biraz sonra göstereceğimiz gibi, modern bilgisayarlarda da kullanılmaktadır. 29.3. KarakterlerinTemsili 499 30 BÖLÜM Karakter Kodlama (Character Encoding) Bu bölüme gelinceye kadar Python programlama dilindeki karakter dizisi, liste ve dosya adlı veri tiplerine ilişkin epey söz söyledik. Artık bu veri tiplerine dair hemen hemen bütün ayrıntıları biliyoruz. Ancak henüz öğrenmediğimiz, ama programcılık maceramız açısından mutlakaöğrenmemizgerekençokönemlibirkonudahavar.Buönemlikonununadı,karakter kodlama. Bu bölümde ‘karakter kodlama’ adlı hayati konuyu işlemenin yanısıra, son birkaç bölümde üstünkörü bir şekilde üzerinden geçtiğimiz, ama derinlemesine incelemeye pek fırsat bulamadığımız bütün konuları da ele almaya çalışacağız. Bu konuyu bitirdikten sonra, öncekikonularıçalışırkenzihninizdeoluşmuşolabilecekboşluklarınpekçoğunundolduğunu farkedeceksiniz. Sözün özü, bu bölümde hem yeni şeyler söyleyeceğiz, hem de halihazırda öğrendiğimiz şeylerin bir kez daha üzerinden geçerek bunların zihnimizde iyiden iyiye pekişmesinisağlayacağız. Hatırlarsanız önceki derslerimizde karakter dizilerinin encode() adlı bir metodu olduğundan sözetmiştik.Aynışekilde,dosyalarındaencodingadlıbirparametresiolduğunusöylemiştik. Ayrıca bu encoding konusu, ilk derslerimizde metin düzenleyici ayarlarını anlatırken de karşımıza çıkmıştı. Orada, yazdığımız programlarda özellikle Türkçe karakterlerin düzgün görünebilmesi için, kullandığımız metin düzenleyicinin dil kodlaması (encoding) ayarlarını düzgün yapmamız gerektiğini üstüne basa basa söylemiştik. Biz şu ana kadar bu konuyu ayrıntılı olarak ele almamış da olsak, siz şimdiye kadar yazdığınız programlarda Türkçe karakterleri kullanırken halihazırda pek çok problemle karşılaşmış ve bu sorunların neden kaynaklandığınıanlamaktazorlanmışolabilirsiniz. İşte bu bölümde, o zaman henüz bilgimiz yetersiz olduğu için ertelediğimiz bu encoding konusunu bütün ayrıntılarıyla ele alacağız ve yazdığımız programlarda Türkçe karakterleri kullanırkennedensorunlarlakarşılaştığımızı,busorununtemelindeneyinyattığınıanlamaya çalışacağız. Ohaldehiçvakitkaybetmedenbuönemlikonuyuincelemeyebaşlayalım. 500 PythonBelgeleri,Yayım4.1.3 30.1 Giriş Önceki bölümlerde sık sık tekrar ettiğimiz gibi, bilgisayar dediğimiz şey, üzerinden elektrik geçendevrelerdenoluşmuşbirsistemdir.Eğerbirdevredeelektrikyoksaodevrenindeğeri0 voltiken,odevredenelektrikgeçtiğindedevrenindeğeriyaklaşık+5volttur. Gördüğünüzgibi,ortadaikifarklıdeğervar:0voltve+5volt.İkili(binary)saymasistemindede ikideğerbulunur:0ve1.İştebizbu0volt’uikilisistemde0ile,+5volt’uise1iletemsilediyoruz. Yani devreden elektrik geçtiğinde o devrenin değeri 1, elektrik geçmediğinde ise 0 olmuş oluyor.Tabiibilgisayaraçısındanbakıldığındadevredeelektrikvardırveyayoktur.Bizinsanlar buikilidurumudahakolaybirşekildemanipüleedebilmekiçinfarklıvoltajdurumlarındanher birine sırasıyla 0 ve 1 gibi bir ad veriyoruz. Yani iki farklı voltaj değerini iki farklı sayı halinde ‘kodlamış’oluyoruz... Hatırlarsanız bir önceki bölümde tasarladığımız basit iletişim modelinde de ampulün loş ışık vermesini sağlayan düşük elektrik sinyallerini 0 ile, parlak ışık vermesini sağlayan yüksek elektrik sinyallerini ise 1 ile temsil etmiştik. Bu temsil işine de teknik olarak ‘kodlama’ (encoding) adı verildiğini söylemiştik. İşte bilgisayarlar açısından da benzer bir durum söz konusudur.Bilgisayarlardada0voltve+5voltdeğerlerisırasıylaikilisaymasistemindeki0ve 1sayılarıhalindekodlanabilir. Sözün özü ilk başta yalnızca iki farklı elektrik sinyali vardır. Elbette bu elektrik sinyalleri ile doğrudan herhangi bir işlem yapamayız. Mesela elektrik sinyallerini birbiriyle toplayıp, birbirinden çıkaramayız. Ama bu sinyalleri bir sayma sistemi ile temsil edersek (yani bu sinyalleri o sayma sisteminde kodlarsak), bunları kullanarak, örneğin, aritmetik işlemleri rahatlıkla gerçekleştirebiliriz. Mesela 0 volt ile +5 voltu birbiriyle toplayamayız, ama 0 voltu ikili sistemdeki 0 sayısıyla, +5 voltu ise ikili sistemdeki 1 sayısıyla kodladıktan sonra bu ikili sayılararasındahertürlüaritmetikişlemigerçekleştirebiliriz. Bilgisayarlaryalnızcaikifarklıvoltajdurumundananladığıvebuikifarklıvoltajdurumudaikili saymasistemindekiikifarklısayıilekolaycatemsiledilebildiğiiçin,ilkbilgisayarlarçoğunlukla sadece hesap işlemlerinde kullanılıyordu. Karakterlerin/harflerin bilgisayar dünyasındaki işlevi bir hayli kısıtlıydı. Metin oluşturma işi o zamanlarda daktilo ve benzeri araçların görevi olarak görülüyordu. Bu durumu, telefon teknolojisi ile kıyaslayabilirsiniz. İlk telefonlar da yalnızcaikikişiarasındakisesliiletişimisağlamakgibikısıtlıbiramacahizmetediyordu.Bugün ise,geçmiştepekçokfarklıcihazapaylaştırılmışgörevleriakıllıtelefonlararacılığıylatekelden halledebiliyoruz. Peki bir bilgisayar yalnızca elektrik sinyallerinden anlıyorsa, biz mesela bilgisayarları nasıl oluyordametingirişiiçinkullanabiliyoruz? Busorununcevabıaslındaçokaçık:Birtakımelektriksinyallerini,birtakımaritmetikişlemleri gerçekleştirebilmekamacıylanasılbirtakımsayılarhalindekodlayabiliyorsak;birtakımsayıları da, birtakım metin işlemlerini gerçekleştirebilmek amacıyla birtakım karakterler halinde kodlayabiliriz. Pekiamanasıl? Bir önceki bölümde bahsettiğimiz basit iletişim modeli aracılığıyla bunun nasıl yapılacağını anlatmıştık. Tıpkı bizim basit iletişim sistemimizde olduğu gibi, bilgisayarlar da yalnızca elektrik sinyallerini görür. Tıpkı orada yaptığımız gibi, bilgisayarlarda da hangi elektrik sinyalinin hangi sayıya; hangi sayının da hangi karaktere karşılık geleceğini belirleyebiliriz. Daha doğrusu, bilgisayarların gördüğü bu elektrik sinyallerini sayılara ve karakterlere dönüştürebiliriz. Dışarıdan girilen karakterleri de, bilgisayarların anlayabilmesi için tam aksi 30.1. Giriş 501 PythonBelgeleri,Yayım4.1.3 istikamette sayıya, oradan da elektrik sinyallerine çevirebiliriz. İşte bu dönüştürme işlemine karakterkodlama(characterencoding)adıverilir. Bu noktada şöyle bir soru akla geliyor: Tamam, sayıları karakterlere, karakterleri de sayılara dönüştüreceğiz. Ama peki hangi sayıları hangi karakterlere, hangi karakterleri de hangi sayılara dönüştüreceğiz? Yani mesela ikili sistemdeki 0 sayısı hangi karaktere, 1 sayısı hangi karaktere,10sayısıhangikarakterekarşılıkgelecek? Siz aslında bu sorunun cevabını da biliyorsunuz. Yine bir önceki bölümde anlattığımız gibi, hangi sayıların hangi karakterlere karşılık geleceğini, sayılarla karakterlerin eşleştirildiği birtakımtablolalaryardımıylarahatlıklabelirleyebiliriz. Bu iş ilk başta kulağa çok kolaymış gibi geliyor. Esasında iş kolaydır, ama şöyle bir problem var: Herkes aynı sayıları aynı karakterlerle eşleştirmiyor olabilir. Mesela durumu bir önceki bölümde tasarladığımız basit iletişim modeli üzerinden düşünelim. Diyelim ki, başta yalnızca bir arkadaşınızla ikinizin arasındaki iletişimi sağlamak için tasarladığınız bu sistem başkalarının da dikkatini çekmiş olsun... Tıpkı sizin gibi, başkaları da loş ışık-parlak ışıkkarşıtlığıüzerindenbirbiriyleiletişimkurmayakararvermişolsun.Ancaksistemintemeli herkesçe aynı şekilde kullanılıyor olsa da, karakter eşleştirme tablolarını herkes aynı şekilde kullanmıyor olabilir. Örneğin başkaları, kendi ihtiyaçları çerçevesinde, farklı sayıların farklı karakterlerle eşleştirildiği farklı tablolar tasarlamış olabilir. Bu durumun dezavantajı, farklı sistemlerle üretilen mesajların, başka sistemlerde aslı gibi görüntülenemeyecek olmasıdır. Örneğin‘a’harfinin1010gibibirsayıylatemsiledildiğisistemleüretilenbirmesaj,aynıharfin mesela1101gibibirsayıylatemsiledildiğisistemdedüzgüngörüntülenemeyecektir.İşteaynı şeybilgisayarlariçindegeçerlidir. 1960’lı yılların ilk yarısına kadar her bilgisayar üreticisi, sayılarla karakterlerin eşleştirildiği, birbirindençokfarklıtablolarkullanıyordu.Yaniherbilgisayarüreticisifarklıkarakterlerifarklı sayılarla eşleştiriyordu. Örneğin bir bilgisayarda 10 sayısı ‘a’ harfine karşılık geliyorsa, başka bir bilgisayarda 10 sayısı ‘b’ harfine karşılık gelebiliyordu. Bu durumun doğal sonucu olarak, iki bilgisayar arasında güvenilir bir veri aktarımı gerçekleştirmek mümkün olmuyordu. Hatta dahadavahimi,aynıfirmaiçindebilebirdenfazlakaraktereşleştirmetablosununkullanıldığı olabiliyordu... Pekibusorununçözümüneolabilir? Cevapelbettestandartlaşma. Standartlaşma ilerleme ve uygarlık açısından çok önemli bir kavramdır. Standartlaşma olmadan ilerleme ve uygarlık düşünülemez. Eğer standartlaşma diye bir şey olmasaydı, mesela A4 piller boy ve en olarak standart bir ölçüye sahip olmasaydı, evde kullandığınız küçükaletlerinpilibittiğindeuygunpilisatınalmaktabüyükzorlukçekerdiniz.Banyo-mutfak musluklarındaki plastik contanın belli bir standardı olmasaydı, conta eskidiğinde yenisini alabilmek için eskisinin ölçülerini inceden inceye hesaplayıp bu ölçülere göre yeni bir conta arayışına çıkmanız gerekirdi. Herhangi bir yerden bulduğunuz contayı herhangi bir musluktakullanamazdınız.İştebudurumunaynısıbilgisayarlariçindegeçerlidir.Eğerbugün karakterlerle sayıları eşleştirme işlemi belli bir standart üzerinden yürütülüyor olmasaydı, kendibilgisayarınızdaoluşturduğunuzbirmetnibaşkabirbilgisayardaaçtığınızdaaynımetni göremezdiniz.İşte1960’lıyıllarakadarbilgisayardünyasındadaaynenbunabenzerbirsorun vardı. Yani o dönemde, hangi sayıların hangi karakterlerle eşleşeceği konusunda uzlaşma olmadığıiçin,farklıbilgisayarlararasındametindeğiştokuşupekmümkündeğildi. 1960’lı yılların başında IBM şirketinde çalışan Bob Bemer adlı bir bilim adamı bu kargaşanın sona ermesi gerektiğine karar verip, herkes tarafından benimsenecek ortak bir karakter kodlamasistemiüzerindeilkçalışmalarıbaşlattı.İşteASCII(‘aski’okunur)böylecehayatımıza 502 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 girmişoldu. Pekibu‘ASCII’denenşeytamolarakneanlamageliyor?Gelinbusorununcevabını,enbaştan başlayarakveolabildiğinceayrıntılıbirşekildevermeyeçalışalım. 30.2 ASCII Bilgisayarların iki farklı elektrik sinyali ile çalıştığını, bu iki farklı sinyalin de 0 ve 1 sayıları ile temsiledildiğini,bilgisayarlametinişlemleriyapabilmekiçinisebusayılarınbellikarakterlerle eşleştirilmesigerektiğinisöylemiştik. Yukarıda da bahsettiğimiz gibi, uygarlık ve ilerleme açısından standartlaşma önemli bir basamaktır. Şöyle düşünün: Biz bilgisayarların çalışma prensibinde iki farklı elektrik sinyali olduğunu biliyoruz. Biz insanlar olarak, işlerimizi daha kolay yapabilmek için, bu sinyalleri dahasomutbireraraçolan0ve1sayılarınaatamışız.Eğerdevredeelektrikyoksabudurumu 0ile,eğerdevredeelektrikvarsabudurumu1iletemsilediyoruz.Esasındabudabiruzlaşma gerektirir.Devredeelektrikyoksabudurumupekala0yerine1iledetemsiledebilirdik... Eğer elektrik sinyallerinin temsili üzerinde böyle bir uzlaşmazlık olsaydı, her şeyden önce hangi sinyalinhangisayıyakarşılıkgeleceğikonusundadaortakbirkararavarmamızgerekirdi. Elektriğin var olmadığı durumu 0 yerine 1 ile temsil etmek akla pek yatkın olmadığı için uzlaşmada bir problem çıkmıyor. Ama karakterler böyle değildir. Onlarca (hatta yüzlerce ve binlerce) karakterin sayılarla eşleştirilmesi gereken bir durumda, ortak bir eşleştirme düzeni üzerinde uzlaşma sağlamak hiç de kolay bir iş değildir. Zaten 1960’lı yılların başına kadar da böyle bir uzlaşma sağlanabilmiş değildi. Dediğimiz gibi, her bilgisayar üreticisi sayıları farklı karakterlerle eşleştiriyor, yani birbirlerinden tamamen farklı karakter kodlama sistemleri kullanıyordu. İşte bu kargaşayı ortadan kaldırmak gayesiyle, Bob Bemer ve ekibi hangi sayıların hangi karakterlerekarşılıkgeleceğinibellibirstandardabağlayanbirtablooluşturdu.Bustandarda ise American Standard Code for Information Interchange, yani ‘Bilgi Alışverişi için Standart AmerikanKodu’veyakısaca‘ASCII’adıverildi. 30.2.1 7 Bitlik bir Sistem ASCII adı verilen sistem, birtakım sayıların birtakım karakterlerle eşleştirildiği basit bir tablodanibarettir.Butabloyuhttps://www.asciitable.com/adresindegörebilirsiniz: 30.2. ASCII 503 PythonBelgeleri,Yayım4.1.3 İstersenizbutabloyuPythonyardımıylakendinizdeoluşturabilirsiniz: for i in range(128): if i % 4 == 0: print("\n") print("{:<3}{:>8}\t".format(i, repr(chr(i))), sep="", end="") (cid:242) Not Bu kodlarda repr() fonksiyonu dışında bilmediğiniz ve anlayamayacağınız hiçbir şey yok. Biraz sonra repr() fonksiyonundan da bahsedeceğiz. Ama dilerseniz, bu fonksiyonun ne işe yaradığı konusunda en azından bir fikir sahibi olmak için, yukarıdaki kodları bir de repr()olmadanyazmayıvealdığınızçıktıyıincelemeyideneyebilirsiniz. ASCII tablosunda toplam 128 karakterin sayılarla eşleştirilmiş durumda olduğunu görüyorsunuz. Bir önceki bölümde bahsettiğimiz basit iletişim modelinde anlattıklarımızdan da aşina olduğunuz gibi, 128 adet sayı 7 bite karşılık gelir (2**7=128). Yani 7 bit ile gösterilebileceksonsayı127’dir.DolayısıylaASCII7bitlikbirsistemdir. ASCII tablosunu şöyle bir incelediğimizde ilk 32 öğenin göze ilk başta anlamsız görünen birtakımkarakterlerdenoluştuğunugörüyoruz: 504 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 tabularytabulary sayı karakter sayı karakter sayı karakter sayı karakter 0 ‘\x00’ 1 ‘\x01’ 2 ‘\x02’ 3 ‘\x03’ 4 ‘\x04’ 5 ‘\x05’ 6 ‘\x06’ 7 ‘\x07’ 8 ‘\x08’ 9 ‘\t’ 10 ‘\n’ 11 ‘\x0b’ 12 ‘\x0c’ 13 ‘\r’ 14 ‘\x0e’ 15 ‘\x0f’ 16 ‘\x10’ 17 ‘\x11’ 18 ‘\x12’ 19 ‘\x13’ 20 ‘\x14’ 21 ‘\x15’ 22 ‘\x16’ 23 ‘\x17’ 24 ‘\x18’ 25 ‘\x19’ 26 ‘\x1a’ 27 ‘\x1b’ 28 ‘\x1c’ 29 ‘\x1d’ 30 ‘\x1e’ 31 ‘\x1f’ (cid:242) Not Bu arada, asciitable.com adresinden baktığınız tablo ile yukarıdaki tablonun birbirinden farklı olduğunu zannedebilirsiniz ilk bakışta. Ama aslında arada herhangi bir fark yok. Yalnızca iki tablonun karakterleri gösterim şekli birbirinden farklı. Örneğin asciitable.com’daki tabloda 9 sayısının ‘TAB (horizontal tab)’ adlı bir karaktere atandığını görüyoruz. Yukarıdaki tabloda ise 9 sayısının yanında \t adlı kaçış dizisi var. Gördüğünüz gibi, ‘TAB (horizontal tab)’ ifadesi ile \t ifadesi aynı karaktere atıfta bulunuyor. Yalnızca bunlarıngösterimleribirbirindenfarklı,okadar. Aslında bu karakter salatası arasında bizim tanıdığımız birkaç karakter de yok değil. Mesela 9. sıradaki \t öğesinin sekme oluşturan kaçış dizisi olduğunu söyledik. Aynı şekilde, 10. sıradaki\nöğesininsatırbaşınageçirenkaçışdizisiolduğunu,13.sıradaki\röğesininisesatırı başa alan kaçış dizisi olduğunu da biliyoruz. Bu tür karakterler ‘basılamayan’ (non-printing) karakterlerdir. Yani mesela ekranda görüntülenebilen ‘a’, ‘b’, ‘c’, ‘!’, ‘?’, ‘=’ gibi karakterlerden farklıolarakbuilk32karakterekrandagörünmez.Bunlaraaynızamanda‘kontrolkarakterleri’ (control characters) adı da verilir. Çünkü bu karakterler ekranda görüntülenmek yerine, metninakışınıkontroleder.Bukarakterlerinneişeyaradığınışutabloylatektekgösterebiliriz (tablohttps://tr.wikipedia.org/wiki/ASCIIadresindenalıntıdır): 30.2. ASCII 505 PythonBelgeleri,Yayım4.1.3 tabularytabulary Sayı Karakter Sayı Karakter 0 boş 16 veribağlantısındançık 1 başlıkbaşlangıcı 17 aygıtdenetimi1 2 metinbaşlangıcı 18 aygıtdenetimi2 3 metinsonu 19 aygıtdenetimi3 4 aktarımsonu 20 aygıtdenetimi4 5 sorgu 21 olumsuzbildirim 6 bildirim 22 zamanuyumluboştakalma 7 zil 23 aktarımbloğusonu 8 gerial 24 iptal 9 yataysekme 25 ortamsonu 10 satırbesleme/yenisatır 26 değiştir 11 dikeysekme 27 çık 12 formbesleme/yenisayfa 28 dosyaayırıcısı 13 satırbaşı 29 grupayırıcısı 14 dışarıkaydır 30 kayıtayırıcısı 15 içerikaydır 31 birimayırıcısı Gördüğünüzgibi,bunlarbirerharf,sayıveyanoktalamaişaretideğil.Oyüzdenbukarakterler ekrandagörünmez.Amabirmetindekiveri,satırveparagrafdüzenininnasılolacağını,metnin neredebaşlayıpneredebiteceğinivenasılgörüneceğinikontrolettikleriiçinönemlidirler. Geri kalan sayılar ise doğrudan karakterlere, sayılara ve noktalama işaretlerine tahsis edilmiştir: 506 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 tabularytabulary sayı karakter sayı karakter sayı karakter sayı karakter 32 ‘‘ 33 ‘!’ 34 ‘”’ 35 ‘#’ 36 ‘$’ 37 ‘%’ 38 ‘&’ 39 “’” 40 ‘(’ 41 ‘)’ 42 ‘*’ 43 ‘+’ 44 ‘,’ 45 ‘-’ 46 ‘.’ 47 ‘/’ 48 ‘0’ 49 ‘1’ 50 ‘2’ 51 ‘3’ 52 ‘4’ 53 ‘5’ 54 ‘6’ 55 ‘7’ 56 ‘8’ 57 ‘9’ 58 ‘:’ 59 ‘;’ 60 ‘<’ 61 ‘=’ 62 ‘>’ 63 ‘?’ 64 ‘@’ 65 ‘A’ 66 ‘B’ 67 ‘C’ 68 ‘D’ 69 ‘E’ 70 ‘F’ 71 ‘G’ 72 ‘H’ 73 ‘I’ 74 ‘J’ 75 ‘K’ 76 ‘L’ 77 ‘M’ 78 ‘N’ 79 ‘O’ 80 ‘P’ 81 ‘Q’ 82 ‘R’ 83 ‘S’ 84 ‘T’ 85 ‘U’ 86 ‘V’ 87 ‘W’ 88 ‘X’ 89 ‘Y’ 90 ‘Z’ 91 ‘[’ 92 ‘\’ 93 ‘]’ 94 ‘^’ 95 ‘_’ 96 ‘” 97 ‘a’ 98 ‘b’ 99 ‘c’ 100 ‘d’ 101 ‘e’ 102 ‘f’ 103 ‘g’ 104 ‘h’ 105 ‘i’ 106 ‘j’ 107 ‘k’ 108 ‘l’ 109 ‘m’ 110 ‘n’ 111 ‘o’ 112 ‘p’ 113 ‘q’ 114 ‘r’ 115 ‘s’ 116 ‘t’ 117 ‘u’ 118 ‘v’ 119 ‘w’ 120 ‘x’ 121 ‘y’ 122 ‘z’ 123 ‘{’ 124 ‘|’ 125 ‘}’ 126 ‘~’ 127 ‘x7f’ İşte 32 ile 127 arası sayılarla eşleştirilen yukarıdaki karakterler yardımıyla metin ihtiyaçlarımızınbüyükbölümünükarşılayabiliriz.YaniASCIIadıverilenbueşleştirmetablosu sayesindebilgisayarlarınsayılarlabirliktekarakterlerideişleyebilmesinisağlayabiliriz. 1960’lı yıllara gelindiğinde, bilgisayarlar 8 bit uzunluğundaki verileri işleyebiliyordu. Yani, ASCII sisteminin gerçeklendiği (yani hayata geçirildiği) bilgisayarlar 8 bitlik bir kapasiteye sahipti. Bu 8 bitin 7 biti karakterle ayrılmıştı. Dolayısıyla mevcut bütün karakterler 7 bitlik bir alana sığdırılmıştı. Boşta kalan 8. bit ise, veri aktarımının düzgün gerçekleştirilip gerçekleştirilmediğini denetlemek amacıyla ‘doğruluk kontrolü’ için kullanılıyordu. Bu kontroleteknikolarak‘eşlikdenetimi’(paritycheck),bueşlikdenetiminiyapmamızısağlayan bit’eise‘eşlikbiti’(paritybit)adıverildiğinibiliyorsunuz.Geçenbölümdebuteknikterimlerin neanlamageldiğiniaçıklamış,hattabunlarlailgilibasitbirörnekdevermiştik. Adından da anlaşılacağı gibi, ASCII bir Amerikan standardıdır. Dolayısıyla hazırlanışında İngilizce temel alınmıştır. Zaten ASCII tablosunu incelediğinizde, bu tabloda Türkçeye özgü harflerin bulunmadığını göreceksiniz. Bu sebepten, bu standart ile mesela Türkçeye özgü karakterleri gösteremeyiz. Çünkü ASCII standardında ‘ş’, ‘ç’, ‘ğ’ gibi harfler kodlanmamıştır. Özellikle Python’ın 2.x serisini kullanmış olanlar, ASCII’nin bu yetersizliğinin nelere sebep olduğunugayetiyibilir.Python’ın2.xserisindemeseladoğrudanşöylebirkodyazamayız: print("Merhaba Şirin Baba!") “Merhaba Şirin Baba! adlı karakter dizisinde geçen ‘Ş’ harfi ASCII dışı bir karakterdir. Yani bu harfASCIIiletemsiledilemez.OyüzdenböylebirkodyazıpbukoduçalıştırdığımızdaPython bizeşöylebirhatamesajıgösterecektir: 30.2. ASCII 507 PythonBelgeleri,Yayım4.1.3 File "deneme.py", line 1 SyntaxError: Non-ASCII character ’\xde’ in file deneme.py on line 1, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details Aynenanlattığımızgibi,yukarıdakihatamesajıdakodlararasındaASCIIolmayanbirkarakter yeraldığındanyakınıyor... ASCII’nin her ne kadar yukarıda bahsettiğimiz eksiklikleri olsa da bu standart son derece yaygındır ve piyasada bulunan pek çok sistemde kullanılmaya devam etmektedir. Örneğin sizekullanıcıadıveparolasoranhemenhemenbütünsistemlerbuASCIItablosunutemelalır veya bu tablodan etkilenmiştir. O yüzden çoğu yerde kullanıcı adı ve/veya parola belirlerken Türkçe karakterleri kullanamazsınız. Hatta pek çok yazı tipinde yalnızca ASCII tablosunda yer alan karakterlerin karşılığı bulunur. Bu yüzden, mesela blogunuzda kullanmak üzere seçip beğendiğiniz çoğu yazı tipi ‘ş’, ‘ç’, ‘ğ’, ‘ö’ gibi harfleri göstermeyebilir. Yukarıda ‘Merhaba Şirin Baba!’ örneğinde de gösterdiğimiz gibi, Python’ın 2.x serisinde de öntanımlı olarak ASCIIkodlamabiçimikullanılıyordu.OyüzdenPython’ın2.xsürümlerindeTürkçekarakterleri gösterebilmekiçindahafazlailaveişlemyapmakzorundakalıyorduk. Sözün özü, eğer yazdığınız veya kendiniz yazmamış da olsanız herhangi bir sebeple kullanmakta olduğunuz bir programda Türkçe karakterlere ilişkin bir hata alıyorsanız, bu durumun en muhtemel sebebi, kullandığınız programın veya sistemin, doğrudan ASCII’yi veya ASCII’ye benzer başka bir sistemi temel alarak çalışıyor olmasıdır. ASCII tablosunda görünen 128 karakter dışında kalan hiçbir karakter ASCII ile kodlanamayacağı için, özellikle farklı dillerin kullanıldığı bilgisayarlarda çalışan programlar kaçınılmaz olarak karakterlere ilişkin pek çok hata verecektir. Örneğin, karakter kodlamalarına ilişkin olarak yukarıda bahsettiğimiz ayrıntılardan habersiz bir Amerikalı programcının yazdığı bir programa Türkçe verigirdiğinizdebuprogrambirandatuhafgörünenhatalarveripçökecektir... 30.2.2 Genişletilmiş ASCII Dediğimiz gibi, ASCII 7 bitlik bir karakter kümesidir. Bu standardın ilk çıktığı dönemde 8. bitin hata kontrolü için kullanıldığını söylemiştik. Sonraki yıllarda 8. bitin hata kontrolü için kullanılmasındanvazgeçildi.Böylece8.bityineboşadüşmüşoldu.Bubitinboşadüşmesiile elimizdeyinetoplam128karakterlikbirboşlukolmuşoldu.Dediğimizgibi7bitiletoplam128 sayı-karaktereşleştirilebilirken,8bitiletoplam256sayı-karaktereşleştirilebilir.Nedeolsa: >>> 2**7 128 >>> 2**8 256 İştebufazlabit,farklıkişi,kurumveorganizasyonlartarafından,İngilizcedebulunmayanama başka dillerde bulunan karakterleri temsil etmek için kullanıldı. Ancak elbette bu fazladan bitin sağladığı 128 karakter de dünyadaki bütün karakterlerin temsil edilmesine yetmez. Bu yüzden8.bitinsunduğuboşluk,birbirindenfarklıkarakterlerigösterençeşitlitablolarınortaya çıkmasına sebep oldu. Bu birbirinden farklı tablolara genel olarak ‘kod sayfası’ adı verilir. Örneğin Microsoft şirketinin Türkiye’ye gönderdiği bilgisayarlarda tanımlı ‘cp857’ adlı kod 508 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 sayfasında128ile256aralığındaTürkçekarakterleredeyerverilmişti(bkz25). Bu tabloya baktığınızda baştan 128’e kadar olan karakterlerin standart ASCII tablosu ile aynı olduğunugöreceksiniz.128.karakterdenitibareniseTürkçeyeözgüharflertanımlanır.Mesela bu tabloda 128. karakter Türkçedeki büyük ‘ç’ harfi iken, 159. karakter küçük ‘ş’ harfidir. Bu durumuşuPythonkodlarıiledeteyitedebilirsiniz: >>> "Ç".encode("cp857") b’\x80’ >>> "ş".encode("cp857") b’\x9f’ Bu arada bu sayıların onaltılı sayma düzenine göre olduğunu biliyorsunuz. Onlu düzende bunlarınkarşılığısırasıylaşudur: >>> int("80", 16) 128 >>> int("9f", 16) 159 Burada karakter dizilerinin encode() adlı metodunu kullandığımıza dikkat edin. Bu metot yardımıylaherhangibirkarakteriherhangibirkarakterkodlamasisteminegörekodlayabiliriz. Mesela yukarıdaki iki örnekte ‘Ç’ ve ‘ş’ harflerini ‘cp857’ adlı kod sayfasına göre kodladık ve bunlarınbukodsayfasındahangisayılarakarşılıkgeldiğinibulduk. cp857numaralıkodsayfasında‘Ç’ve‘ş’harfleriyeraldığıiçin,bizbuharfleriokodsayfasına görekodlayabiliyoruz.AmameselaASCIIkodlamasistemindebuharflerbulunmaz.Oyüzden buharfleriASCIIsisteminegörekodlayamayız: >>> "Ç".encode("ascii") Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError: ’ascii’ codec can’t encode character ’\xc7’ in position 0: ordinal not in range(128) Tıpkıhatamesajındadasöylendiğigibi: Unicode Kodlama Hatası: ’ascii’ kod çözücüsü, 0 konumundaki ’\xc7’ adlı karakteri kodlayamıyor. Sayı 0-128 aralığında değil. Gerçekten de onlu sistemde 199 sayısına karşılık gelen bu onaltılı ‘\xc7’ sayısı ASCII’nin kapsadığı sayı aralığının dışında kalmakta, bu yüzden de ASCII kod çözücüsü ile kodlanamamaktadır. Dediğimiz gibi, Microsoft Türkiye’ye gönderdiği bilgisayarlarda 857 numaralı kod sayfasını 25https://learn.microsoft.com/en-us/previous-versions/cc195068(v=msdn.10) 30.2. ASCII 509 PythonBelgeleri,Yayım4.1.3 tanımlıyordu. Ama mesela Arapça konuşulan ülkelere gönderdiği bilgisayarlarda ise, bu26 adresten görebileceğiniz 708 numaralı kod sayfasını tanımlıyordu. Bu kod sayfasını incelediğinizde, 128 altı karakterlerin standart ASCII ile aynı olduğunu ancak 128 üstü karakterlerin Türkçe kod sayfasındaki karakterlerden farklı olduğunu göreceksiniz. İşte 128 üstü karakterler bütün dillerde birbirinden farklıdır. Bu farklılığın ne sonuç doğurabileceğini tahmin edebildiğinizi zannediyorum. Elbette, mesela kendi bilgisayarınızda yazdığınız bir metniArapçakonuşulanbirülkedekibilgisayaragönderdiğinizde,doğalolarakmetiniçindeki Türkçeyeözgükarakterlerinyerindebaşkakarakterlerbelirecektir. Bubölümünbaşındadasöylediğimizgibi,GenişletilmişASCIIsisteminde128ile256aralığıiçin pek çok farklı karakter eşleştirme tabloları kullanılıyordu. Mesela Microsoft şirketi bu aralık içinkendineözgübirtakımkodsayfalarıtasarlamıştı.Bukodsayfalarınaörnekolarakyukarıda cp857vecp708numaralıkodsayfalarınıörnekvermiştik. Elbette 128 ile 256 aralığını dolduran, yalnızca Microsoft’a ait kod sayfaları yoktu piyasada. Aynı aralığı farklı karakterlerle dolduran pek çok başka eşleştirme tablosu da dolaşıyordu etrafta. Örneğin özellikle Batı Avrupa dillerindeki karakterleri temsil edebilmek için oluşturulmuş ‘latin1’ (öbür adıyla ISO-8859-1) adlı karakter kümesi bugün de yaygın olarak kullanılan sistemlerinden biridir. Almancada olup da ASCII sistemi ile temsil edilemeyen ‘ö’, ‘ß’,‘ü’gibiharflerveFransızcadaolupdayineASCIIsistemiiletemsiledilemeyen‘ç’ve‘é’gibi harflerbukarakterkümesindetemsiledilebiliyordu.Eğerdilersenizbukarakterkümesinide https://www.fileformat.info/info/charset/ISO-8859-1/list.htmadresindeninceleyebilirsiniz. Yalnızburadaönemlibirayrıntıyınotdüşelim.‘GenişletilmişASCII’,standartASCIIgibigenel kabul görmüş tek bir sistem değildir.Genişletilmiş ASCII dediğimizde zaten tek bir karakter kümesi akla gelmiyor. Dolayısıyla ASCII dendiğinde anlamamız gereken şey 128 karakterlik birsayı-karaktereşleştirmetablosudur.ASCIIhiçbirzamanbu128karakterinötesinegeçipde 256karakterlikbiraralığıtemsiletmişdeğildir.Dolayısıyla127.sayınınötesindekikarakterleri kapsayan sistem ASCII değildir. ‘Genişletilmiş ASCII’ kavramı, temel ASCII sisteminde temsil edilen sayı-karakter çiftlerinin pek çok farklı kurum ve kuruluş tarafından birbirinden farklı biçimlerde‘genişletilmesiyle’oluşturulmuş,ancakASCII’ninkendisikadarstandartlaşamamış bir sistemler bütünüdür. Bu sistem içinde pek çok farklı kod sayfası (veya karakter kümesi) yer alır. Tek başına ‘Genişletilmiş ASCII’ ifadesi açıklayıcı olmayıp; ASCII’nin hangi karakter kümesinegöregenişletildiğinindebelirtilmesigerekir. Bütün bu anlattıklarımızdan şu sonucu çıkarıyoruz: ASCII bilgisayarlar arasında güvenli bir şekildeveriaktarımınısağlamakiçinatılmışenönemliveenbaşarılıadımlardanbirtanesidir. Bu güçlü standart sayesinde uzun yıllar bilgisayarlar arası temel iletişim başarıyla sağlandı. Ancak bu standardın zayıf kaldığı nokta 7 bitlik olması ve boşta kalan 8. bitin tek başına dünyadakibütündilleritemsiletmeyeyeterliolmamasıdır. 30.2.3 1 Karakter == 1 Bayt ASCIIstandardı,herkarakterin1baytiletemsiledilebileceğivarsayımıüzerinekurulmuştur. Bildiğiniz gibi, 1 bayt (geleneksel olarak) 8 bit’e karşılık gelir. Peki 1 bayt’ın 8 bit’e karşılık gelmesinin nedeni nedir? Aslında bunun özel bir nedeni yok. 1 destede neden 10 öğe, 1 düzinede de 12 öğe varsa, 1 bayt’ta da 8 bit vardır... Yani biz insanlar öyle olmasına karar verdiğimiziçin1destede10öğe,1düzinede12öğe,1bayt’taise8bitvardır. DediğimizgibiASCIIstandardı7bitlikbirsistemdir.Yanibustandarttaenbüyüksayıolan127 yalnızca7bitilegösterilebilir: 26https://learn.microsoft.com/en-us/previous-versions/cc195061(v=msdn.10) 510 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 >>> bin(127)[2:] ’1111111’ 127sayısı7bitilegösterilebileceksonsayıdır: >>> (127).bit_length() 7 >>> (128).bit_length() 8 8bitlikbirsistemolanGenişletilmişASCIIise0ile255arasısayılarıtemsiledebilir: >>> bin(255)[2:] ’11111111’ 255sayısı8bitilegösterilebileceksonsayıdır: >>> (255).bit_length() 8 >>> (256).bit_length() 9 DolayısıylaASCII’deveGenişletilmişASCII’de1baytlıkalanatoplam256karaktersığdırılabilir. Eğerdahafazlakarakteritemsiletmekisterseniz1bayttanfazlabiralanaihtiyaçduyarsınız. Buarada,olasıbiryanlışanlamayıönleyelim: 1baytolmadurumumeseladoğrudan‘a’harfininkendisiileilgilibirşeydeğildir.Yani‘a’harfi 1 bayt ile gösterilebiliyorken, mesela ‘ş’ harfi 1 bayt ile gösterilemiyorsa, bunun nedeni ‘ş’ harfininin ‘tuhaf bir harf’ olması değildir! Eğer ASCII gibi bir sistem Türkiye’de tasarlanmış olsaydı, herhalde ‘ş’ harfi ilk 128 sayı arasında kendine bir yer bulurdu. Mesela böyle bir sistemde muhtemelen ‘x’, ‘w’ ve ‘q’ harfleri, Türk alfabesinde yer almadıkları için, dışarıda kalırdı. O zaman da ‘ş’, ‘ç’, ‘ğ’ gibi harflerin 1 bayt olduğunu, ‘x’, ‘w’ ve ‘q’ gibi harflerin ise 1 baytolmadığınısöylerdik. 30.2. ASCII 511 PythonBelgeleri,Yayım4.1.3 30.3 UNICODE İlk bilgisayarların ABD çıkışlı olması nedeniyle, bilgisayarlar çoğunlukla ABD’de üretilip ABD pazarınasatılıyordu.BunedenleİngilizcealfabeyitemelalanASCIIgibibirsistembupazarın karakter temsil ihtiyaçlarını %99 oranında karşılıyordu. Ancak bilgisayarların ABD dışına çıkması ve ABD dışında da da yayılmaya başlamasının ardından, ASCII’nin yetersizlikleri de iyice görünür olmaya başladı. Çünkü ASCII tablosunda, İngilizce dışındaki dillerde bulunan aksanlıvenoktalıharflerin(é,ä,ö,çgibi)hiçbiribulunmuyordu. İlk zamanlarda insanlar aksanlı ve noktalı harfleri ASCII tablosundaki benzerleriyle değiştirerek kullanmaya razı olmuşlardı (é yerine e; ä yerine a; ö yerine o; ç yerine c gibi). Ancak bu çözüm Avrupa dillerini kullananların sorununu kısmen çözüyor da olsa, Asya dillerindeki problemi çözemez. Çünkü ASCII tablosunu kullanarak Çince ve Japonca gibi dillerdekikarakterleriherhangibirşekildetemsiletmenizmümkündeğildir. Bu sıkıntıyı kısmen de olsa giderebilmek için, yukarıda da bahsetmiş olduğumuz, 128-256 arasındakiboşluktanyararlanılmayabaşlandı.Dediğimizgibi,ASCII7bitlikbirsistemolduğu için, 8 bitlik bilgisayarlarda fazladan 1 bitin boşta kalmasına izin verir. İşte bu 1 bitlik boşluk dünyanın çeşitli ülkeleri tarafından kendi karakter ihtiyaçlarını karşılamak için kullanıldı. Dolayısıyla Almanlar 128-256 arasını farklı karakterlerle, Fransızlar başka karakterlerle, Yunanlarisebambaşkakarakterlerledoldurdular. Hatırlarsanız ASCII’nin ortaya çıkış sebebi bilgisayarlar arasında veri alışverişini mümkün kılmaktı. ASCII Amerika’daki bilgisayarlar arasında sağlıklı bir veri alışverişi gerçekleştirilmesini rahatlıkla mümkün kılıyordu. Ama bilgisayarların dünyaya yayılması ile birlikte ilk baştaki veri aktarımı problemi tekrar ortaya çıktı. Bu defa da, mesela Türkiye’den gönderilen bir metin (örneğin bir e.posta) Almanya’daki bilgisayarlarda düzgün görüntülenemeyebiliyordu. Örneğin Windows-1254 (cp1254) numaralı kod sayfası ile kodlanmış Türkçe bir metin, Almanya’da Windows-1250 numaralı kod sayfasının tanımlı olduğu bir bilgisayarda, aynı sayıların her iki kod sayfasında farklı karakterlere karşılık gelmesinedeniyledüzgüngörüntülenemez. (cid:242) Not Windows-1254adlıkodsayfasıiçinhttps://en.wikipedia.org/wiki/Windows-1254adresine; Windows-1250 adlı kod sayfası için ise https://en.wikipedia.org/wiki/Windows-1250 adresinebakabilirsiniz. İşte nasıl 1960’lı yılların başında Bob Bemer ve arkadaşları bilgisayarlar arasında sağlıklı bir veri iletişimi sağlamak için kolları sıvayıp ASCII gibi bir çözüm ürettiyse, ASCII ve GenişletilmişASCIIilekodlanamayankarakterleridekodlayıp,uluslararasındaçokgenişçaplı veri alışverişine izin verebilmek amacıyla Xerox şirketinden Joe Becker, Apple şirketinden ise LeeCollinsveMarkDavisUNICODEadlıbirçözümüzerindeilkçalışmalarıbaşlattı. PekitamolaraknedirbuUNICODEdenenşey? Aslında Unicode da tıpkı ASCII gibi bir standarttır. Unicode’un bir proje olarak ortaya çıkışı 1987 yılına dayanır. Projenin amacı, dünyadaki bütün dillerde yer alan karakterlerin tek, benzersiz ve doğru bir biçimde temsil edilebilmesidir. Yani bu projenin ortaya çıkış gayesi, ASCII’ninyetersizkaldığınoktalarıtelafietmektir. 512 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 30.3.1 Sınırsız Bitlik bir Sistem Unicode standardı ile ilgili olarak bilmemiz gereken ilk şey bu standardın ASCII’yi tamamen görmezden gelmiyor olmasıdır. Daha önce de söylediğimiz gibi, ASCII son derece yaygın ve güçlübirstandarttır.ÜstelikASCIIstandardıyaygınolarakkullanılmayadadevametmektedir. BusebepleASCIIilehalihazırdakodlanmışkarakterlerUNICODEstandardındadaaynışekilde kodlanmıştır. Dolayısıyla ASCII UNICODE sisteminin bir alt kümesi olduğu için, ASCII ile uyumluolanbütünsistemlerotomatikolarakUNICODEiledeuyumludur.Ancaktabiibunun tersigeçerlideğildir. UNICODE’unASCII’denenönemlifarkı,UNICODE’unASCII’yekıyaslaçokdahabüyükmiktarda karakterin kodlanmasına izin vermesidir. ASCII yalnızca 128 karakterin kodlanmasına izin verirkenUNICODE1.000.000’danfazlakarakterinkodlanmasınaizinverir. UNICODEsisteminidevasabirkaraktertablosuolarakhayaledebilirsiniz.BildiğinizgibiASCII 7 bitlik bir sistemdir. Bu sebeple de sadece 128 karakteri kodlayabilir. UNICODE ilk ortaya çıktığında 16 bitlik bir sistem olarak tasarlanmıştı. Dolayısıyla UNICODE daha ilk çıkışında 2**16=65536 karakterin kodlanmasına izin veriyordu. Bugün ise UNICODE sisteminin böyle kesin bir sınırı yoktur. Çünkü ‘bilmem kaç bitlik bir sistem’ kavramı UNICODE için geçerli değildir. Dediğimiz gibi, UNICODE’u, ucu bucağı olmayan dev bir karakter tablosu olarak düşünebilirsiniz. Bu tabloya istediğimiz kadar karakteri ekleyebiliriz. Bizi engelleyen sınırlı bir bit kavramı mevcut değildir. Çünkü UNICODE sisteminin kendisi, ASCII sisteminin aksine, doğrudandoğruyakarakterlerikodlamaz.UNICODE’unyaptığışeykarakterleritanımlamaktan ibarettir. Unicode sisteminde her karakter tek ve benzersiz bir ‘kod konumuna’ (code point) karşılık gelir.Kodkonumlarışuformülegöregösterilir: U+sayının_onaltılı_değeri Örneğin‘a’harfininkodkonumuşudur: u+0061 Buradaki0061sayısıonaltılıbirsayıdır.Bunuonlusayısistemineçevirebilirsiniz: >>> int("61", 16) 97 Hatırlarsanız‘a’harfininASCIItablosundakikarşılığıda97idi. Esasında ASCII ile UNICODE birbirleri ile karşılaştırılamayacak iki farklı kavramdır. Neticede ASCII bir kodlama biçimidir. UNICODE ise pek çok farklı kodlama biçimini içinde barındıran devasabirsistemdir. (cid:242) Not Unicodestandardınahttp://www.unicode.org/versions/Unicode6.2.0/UnicodeStandard-6. 2.pdf adresindenulaşabilirsiniz. 30.3. UNICODE 513 PythonBelgeleri,Yayım4.1.3 30.3.2 UTF-8 Kod Çözücüsü DediğimizgibiUNICODEdevasabirtablodanibarettir.Butablodakarakterlereilişkinbirtakım bilgiler bulunur ve bu sistemde her karakter, kod konumları ile ifade edilir. UNICODE kendi başına karakterleri kodlamaz. Bu sistemde tanımlanan karakterleri kodlama işi kod çözücüleringörevidir. UNICODE sistemi içinde UTF-1, UTF-7, UTF-8, UTF-16 ve UTF-32 adlı kod çözücüler bulunur. UTF-8,UNICODEsistemiiçindekienyaygın,enbilinenveenkullanışlıkodçözücüdür. UTF-8 adlı kod çözücünün kodlayabildiği karakterlerin listesine https://www.fileformat.info/ info/charset/UTF-8/list.htm adresinden ulaşabilirsiniz. Bu listenin sayfalar dolusu olduğuna vehersayfaya,sayfanınenaltındaki‘More...’bağlantısıileulaşabileceğinizedikkatedin. 30.3.3 1 Karakter!= 1 Bayt ASCIIsistemindeherkarakterin1bayt’akarşılıkgeldiğinisöylemiştik.Ancak1baytdünyadaki bütünkarakterlerikodlamayayetmez.Gerikalankarakterleridekodlayabilmekiçin1bayttan fazlasınaihtiyacımızvar.Meselakarakterkodlamaiçin: 1 bayt kullanırsak toplam 2**8 = 256 2 bayt kullanırsak toplam 2**16 = 65,536 3 bayt kullanırsak toplam 2**24 = 16,777,216 4 bayt kullanırsak toplam 2**32 = 4,294,967,296 karakterkodlayabiliriz.BudurumuşuPythonkodlarıiledegösterebiliriz: >>> for i in range(1, 5): ... print("{} bayt kullanırsak toplam 2**{:<2} = {:,}".format(i, i*8,␣ (2**(i*8)))) ˓→ Görünüşegörebiz4baytlıkbirsistemkullanırsakgelmişgeçmişbütünkarakterlerirahatlıkla temsil etmeye yetecek kadar alana sahip oluyoruz. Ancak burada şöyle bir durum var. Bildiğiniz gibi, 0 ile 256 aralığındaki karakterler yalnızca 1 bayt ile temsil edilebiliyor. 256 ile 65,536 arasındaki karakterler için ise 2 bayt yeter. Aynı şekilde 65,536 ile 16,777,216 aralığındaki sayılar için de 3 bayt yeterli. Bu durumda eğer biz bütün karakterleri 4 bayt ile temsiledecekolursak,korkunçderecebirisrafadüşmüşoluruz.ÇünküASCIIgibibirkodlama sistemindeyalnızca1baytiletemsiledilebilecekbirkarakterinkapladığıalanbusistemleboşu boşuna4katartmışolacaktır. Busorununçözümüelbettesabitboyutlukarakterkodlamabiçimleriyerinedeğişkenboyutlu karakterkodlamabiçimlerikullanmaktır.İşteUNICODEsistemiiçindekiUTF-8adlıkodçözücü, karakterleri değişken sayıda baytlar halinde kodlayabilir. UTF-8, UNICODE sistemi içinde tanımlanmış karakterleri kodlayabilmek için 1 ile 4 bayt arası değerleri kullanır. Böylece de bukodçözücüUNICODEsistemiiçindetanımlanmışbütünkarakterleritemsiledebilir. Budurumubirörneküzerindengöstermeyeçalışalım: harfler = "abcçdefgğhıijklmnoöprsştuüvyz" for s in harfler: print("{:<5}{:<15}{:<15}".format(s, str(s.encode("utf-8")), len(s.encode("utf-8")))) 514 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 Buradanşunabenzerbirçıktıalıyoruz: a b’a’ 1 b b’b’ 1 c b’c’ 1 ç b’\xc3\xa7’ 2 d b’d’ 1 e b’e’ 1 f b’f’ 1 g b’g’ 1 ğ b’\xc4\x9f’ 2 h b’h’ 1 ı b’\xc4\xb1’ 2 i b’i’ 1 j b’j’ 1 k b’k’ 1 l b’l’ 1 m b’m’ 1 n b’n’ 1 o b’o’ 1 ö b’\xc3\xb6’ 2 p b’p’ 1 r b’r’ 1 s b’s’ 1 ş b’\xc5\x9f’ 2 t b’t’ 1 u b’u’ 1 ü b’\xc3\xbc’ 2 v b’v’ 1 y b’y’ 1 z b’z’ 1 Burada,s.encode("utf-8")komutunun‘baytlar’(bytes)türündenbirveritipiverdiğinedikkat edin(baytlarveritipinibirsonrakibölümdeayrıntılıolarakinceleyeceğiz).Karakterdizilerinin aksine baytların format() adlı bir metodu bulunmaz. Bu yüzden, bu veri tipini format() metodunagöndermedenöncestr()fonksiyonuyardımıylakarakterdizisinedönüştürmemiz gerekiyor.Budönüştürmeişlevini,alternatifolarakşuşekildedeyapabilirdik: print("{:<5}{!s:<15}{:<15}".format(s, s.encode("utf-8"), len(s.encode("utf-8")))) Hangiyöntemiseçeceğinizpaşagönlünüzekalmış... Bizkonumuzadönelim. Yukarıdaki tabloda ilk sütun Türk alfabesindeki tek tek harfleri gösteriyor. İkinci sütun ise bu harflerinUTF-8ilekodlandığındanasılgöründüğünü.SonsütundaiseUTF-8ilekodlananTürk harflerininkaçbaytlıkyerkapladığınıgörüyoruz. Butabloyudahaiyianlayabilmekiçinmeselaburadaki‘ç’harfinielealalım: >>> ’ç’.encode(’utf-8’) b’\xc3\xa7’ 30.3. UNICODE 515 PythonBelgeleri,Yayım4.1.3 Burada Python’ın kendi yerleştirdiği karakterleri çıkarırsak (‘b’ ve ‘\x’ gibi) elimizde şu onaltılı sayıkalır: c3a7 Buonaltılısayınınonlusistemdekikarşılığışudur: >>> int(’c3a7’, 16) 50087 50087sayısınınikilisaymasistemindekikarşılığıiseşudur: >>> bin(50087) ’0b1100001110100111’ Gördüğünüz gibi, bu sayı 16 bitlik, yani 2 baytlık bir sayıdır. Bunu nasıl teyit edeceğinizi biliyorsunuz: >>> (50087).bit_length() 16 https://www.fileformat.info/info/charset/UTF-8/list.htm adresine gittiğinizde de UTF-8 tablosunda‘ç’harfinin‘c3a7’sayısıylaeşleştirildiğinigöreceksiniz. BirdeUTF-8’in‘a’harfininasıltemsilettiğinebakalım: >>> "a".encode("utf-8") b’a’ ‘a’ harfi standart ASCII harflerinden biri olduğu için Python doğrudan bu harfin kendisini gösteriyor. Eğer bu harfin hangi sayıya karşılık geldiğini görmek isterseniz şu kodu kullanabilirsiniz: >>> ord("a") 97 Dahaöncedesöylediğimizgibi,UNICODEsistemiASCIIileuyumludur.YaniASCIIsisteminde tanımlanmışbirharfhangisayıdeğerinesahipse,UNICODEiçindekibütünkodçözücüleride o harf için aynı sayıyı kullanır. Yani mesela ‘a’ harfi hem ASCII’de, hem UTF-8’de 97 sayısı ile temsiledilir.Busayı256’danküçükolduğuiçinyalnızca1baytiletemsiledilir.Ancakstandart ASCIIdışındakalankarakterler,farklıkodçözücülertarafındanfarklısayılarlaeşleştirilecektir. Bununlailgilişöylebirçalışmayapabiliriz: kod_çözücüler = [’UTF-8’, ’cp1254’, ’latin-1’, ’ASCII’] harf = ’İ’ for kç in kod_çözücüler: (sonrakisayfayadevam) 516 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) try: print("’{}’ karakteri {} ile {} olarak " "ve {} sayısıyla temsil edilir.".format(harf, kç, harf.encode(kç), ord(harf))) except UnicodeEncodeError: print("’{}’ karakteri {} ile temsil edilemez!".format(harf, kç)) Buprogramıçalıştırdığımızdaşunabenzerbirçıktıalırız: .. code-block:: pycon ‘İ’ karakteri UTF-8 ile b’xc4xb0’ olarak ve 304 sayısıyla temsil edilir ‘İ’ karakteri cp1254 ile b’xdd’ olarak ve 304 sayısıyla temsil edilir. ‘İ’ karakteri latin-1 ile temsil edilemez!‘İ’karakteriASCIIiletemsiledilemez! Buufakprogramıkullanarakhangikarakterinhangikodçözücüilenasıltemsiledildiğini(veya temsiledilipedilemediğini)görebilirsiniz. 30.3.4 Eksik Karakterler ve encode Metodu Dediğimiz ve örneklerden de gördüğümüz gibi, her karakter her kod çözücü ile çözülemeyebilir. Mesela Windows-1254 adlı kod sayfasında bulunan bir karakter Windows-1250 adlı kod sayfasında bulunamadığında, bulunmayan karakterin yerine bir soruişareti(veyabaşkabirsimge)yerleştirilecektir. Aslında siz bu olguya hiç yabancı değilsiniz. İnternette dolaşırken mutlaka anlamsız karakterlerle dolu web sayfalarıyla karşılaşmışsınızdır. Bu durumun sebebi, ilgili sayfanın dil kodlamasının(encoding)düzgünbelirtilmemişolmasıdır.YanisayfanınHTMLkodlarıarasında metacharsetetiketiyahiçyazılmamışyadayanlışyazılmıştır.Eğerbuetikethiçyazılmamışsa, Internet tarayıcınız dil kodlamasının ne olduğunu kendince tahmin etmeyece çalışacak, çoğunlukladayanlışbirkararverecektir.Tarayıcınızmetnindilinidüzgüntespitedemediğiiçin debumetniyanlışbirkaraktertablosuileeşleştirecek,okaraktertablosundatanımlanmamış karakterleryerinebirsoruişaretiveyabaşkaanlamsızbirsimgeyerleştirecektir.Metnidüzgün görüntüleyebilmekiçintarayıcınızındilkodlamasınınyapıldığımenüöğesinibulup,doğrudil kodlamasını kendiniz seçeceksiniz. Böyle bir şeyi hayatınız boyunca en az bir kez yapmak zorundakaldığınızaeminim... Birkarakterkümesindeherhangibirkarakterbulunamadığında,bulunamayanbukarakterin yerineneyingeleceği,tamamenaradakiyazılımabağlıdır.ÖrneğinsözkonusuolanbirPython programıysa,ilgilikarakterbulunamadığındaöntanımlıolarakbukarakterinyerinehiçbirşey koyulmaz.Onunyerineprogramçökmeyebırakılır... Ancakböylebirdurumdaneyapılacağını istersenizkendinizdebelirleyebilirsiniz. Bunun için karakter dizilerinin encode() metodunun errors adlı parametresinden yararlanacağız.Buparametredörtfarklıdeğeralabilir: 30.3. UNICODE 517 PythonBelgeleri,Yayım4.1.3 tabularytabulary Parametre Anlamı ‘strict’ Karaktertemsiledilemiyorsahataverilir ‘ignore’ Temsiledilemeyenkaraktergörmezdengelinir ‘replace’ Temsiledilemeyenkarakterinyerinebir‘?’işaretikoyulur ‘xmlcharrefreplace’ TemsiledilemeyenkarakteryerineXMLkarşılığıkoyulur Buparametrelerişöylekullanıyoruz: >>> "bu Türkçe bir cümledir.".encode("ascii", errors="strict") Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError: ’ascii’ codec can’t encode character ’\xfc’ in position 4: ordinal not in range(128) ‘strict’ zaten öntanımlı değerdir. Dolayısıyla eğer errors parametresine herhangi bir değer vermezsek Python sanki ‘strict’ değerini vermişiz gibi davranacak ve ilgili karakter kodlaması iletemsiledilemeyenbirkarakterilekarşılaşıldığındahataverecektir: >>> "bu Türkçe bir cümledir.".encode("ascii") Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError: ’ascii’ codec can’t encode character ’\xfc’ in position 4: ordinal not in range(128) Gelelimötekideğerlerinneyaptığına: >>> "bu Türkçe bir cümledir.".encode("ascii", errors="ignore") b’bu Trke bir cmledir.’ Gördüğünüz gibi, errors parametresine ‘ignore’ değerini verdiğimizde, temsil edilemeyen karakterlergörmezdengeliniyor: >>> "bu Türkçe bir cümledir.".encode("ascii", errors="replace") b’bu T?rk?e bir c?mledir.’ Buradaise‘replace’değerinikullandık.Böylecetemsiledilemeyenkarakterlerinyerinebirer? işaretikoyuldu: >>> "bu Türkçe bir cümledir.".encode("ascii", errors="xmlcharrefreplace") b’bu T&#252;rk&#231;e bir c&#252;mledir.’ Son olarak ise ‘xmlcharrefreplace’ değerinin ne yaptığını görüyoruz. Eğer errors parametresine ‘xmlcharrefreplace’ değerini verecek olursak, temsil edilemeyen her bir harf yerine o harfin XML karşılığı yerleştirilir. Bu değer, programınızdan alacağınız çıktıyı bir XMLdosyasındakullanacağınızdurumlardaişinizeyarayabilir. 518 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 30.3.5 Dosyalar ve Karakter Kodlama Dosyalar konusunu anlatırken, Python’da bir dosyanın open() fonksiyonu ile açılacağını söylemiştik.Bildiğinizgibiopen()fonksiyonunuşuşekildekullanıyoruz: >>> f = open(dosya_adı, dosya_açma_kipi) Burada biz open() fonksiyonunu iki farklı parametre ile birlikte kullandık. Ancak aslında belirtmemizgerekenönemlibirparametresidahavarbufonksiyonun.İştebuparametrenin adıencoding’dir. Gelinşimdibuparametreninneolduğunavenasılkullanıldığınabakalım: encoding Tahmin edebileceğiniz gibi, encoding parametresi bir dosyanın hangi kod çözücü ile açılacağınıbelirtmemizisağlar.Python’dadosyalaröntanımlıolaraklocaleadlıbirmodülün getpreferredencoding() adlı fonksiyonunun gösterdiği kod çözücü ile açılır. Siz de dosyalarınızın varsayılan olarak hangi kod çözücü ile açılacağını öğrenmek için şu komutları yazabilirsiniz: >>> import locale >>> locale.getpreferredencoding() İşte eğer siz encoding parametresini belirtmezseniz, dosyalarınız yukarıdaki çıktıda görünen kodçözücüileaçılacaktır. GNU/Linux dağıtımlarında bu çıktı çoğunlukla UTF-8 olacaktır. O yüzden GNU/Linux’ta dosyalarınız muhtemelen encoding belirtmeseniz bile düzgün görünecektir. Ancak Windows’ta locale.getpreferredencoding() değeri cp1254 olacağı için, mesela UTF-8 ile kodlanmış dosyalarınızda özellikle Türkçe karakterler düzgün görüntülenemeyecektir. O yüzden, dosyalarınızın hangi kod çözücü ile kodlanmış olduğunu open() fonksiyonuna vereceğinizencodingparametresiaracılığıylaherzamanbelirtmelisiniz: >>> f = open(dosya, encoding=’utf-8’) Diyelim ki açmak istediğiniz dosya cp1254 adlı kod çözücü ile kodlanmış olsun. Eğer siz bu dosyayıaçarkencp1254adlıkodçözücüyüdeğildebaşkabirkodçözücüyüyazarsanızelbette dosyadakikarakterlerdüzgüngörüntülenemeyecektir. Örneğin cp1254 ile kodlanmış bir belgeyi UTF-8 ile açmaya kalkışırsanız veya siz hiçbir kod çözücü belirtmediğiniz halde kullandığınız işletim sistemi öntanımlı olarak dosyaları açmak için cp1254 harici bir kod çözücüyü kullanıyorsa, dosyayı okuma esnasında şuna benzer bir hataalırsınız: >>> f = open("belge.txt", encoding="utf-8") >>> f.read(50) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "C:\Python33\lib\codecs.py", line 300, in decode (result, consumed) = self._buffer_decode(data, self.errors, final) (sonrakisayfayadevam) 30.3. UNICODE 519 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) UnicodeDecodeError: ’utf-8’ codec can’t decode byte 0xde in position 79: invalid continuation byte Gördüğünüz gibi, dosyamız bizim kullanmaya çalıştığımız kod çözücüden (UTF-8) farklı bir kod çözücü ile (cp1254) kodlanmış olduğu için, doğal olarak karakterler doğru sayılarla eşleştirilemiyor.Budakaçınılmazolarakyukarıdakihatanınverilmesinesebepoluyor. Aslında siz bu hatayı tanıyorsunuz. encode() metodunu anlatırken bunun ne olduğundan ve buhatayakarşıneleryapabileceğinizdensözetmiştik. Hatırlarsanız bu tür hatalara karşı ne tepki verileceğini belirleyebilmek için encode() metodundaerrorsadlıbirparametreyikullanabiliyorduk.İşteopen()fonksiyonundadaaynı errorsparametresibulunur. errors Dediğimiz gibi, bir dosyanın doğru görüntülenebilmesi ve okunabilmesi için, sahip olduğu kodlama biçiminin doğru olarak belirtilmesi gerekir. Ama okuyacağınız dosyaların hangi kodlama sistemine sahip olduğunu doğru tahmin etmeniz her zaman mümkün olmayabilir. Böyle durumlarda, programınızın çökmesini önlemek için çeşitli stratejiler belirlemeniz gerekir. Bir önceki bölümde verdiğimiz örnekten de gördüğünüz gibi, eğer Python, açılmaya çalışılan dosyadaki karakterleri encoding parametresinde gösterilen kod çözücü ile çözemezse öntanımlıolarakbirhatamesajıüretipprogramdançıkacaktır.Ancaksizinistediğinizşeyher zaman bu olmayabilir. Mesela dosyadaki karakterler doğru kodlanamasa bile programınızın çökmemesinitercihedebilirsiniz.İştebununiçinerrorsparametresindenyararlanacaksınız. Bu parametreyi encoding() metodundan hatırlıyorsunuz. Bu parametre orada nasıl kullanılıyorsa,open()fonksiyonundadaaynışekildekullanılır.Dikkatlicebakın: >>> f = open(dosya_adı, encoding=’utf-8’, errors=’strict’) Buzatenerrorsparametresininöntanımlıdeğeridir.Dolayısıyla‘strict’değerinibelirtmeseniz deöntanımlıolarakbudeğeribelirtmişsinizgibidavranılacaktır. >>> f = open(dosya_adı, encoding=’utf-8’, errors=’ignore’) Burada ise ‘ignore’ değerini kullanarak, Python’ın kodlanamayan karakterleri görmezden gelmesinisağlıyoruz. >>> f = open(dosya_adı, encoding=’utf-8’, errors=’replace’) ‘replace’ değeri ise kodlanamayan karakterlerin yerine \ufffd karakterini yerleştirecektir. Bu karakter işlev bakımından, encode() metodunu anlatırken gördüğümüz ‘?’ işaretine benzer. Bukaraktereteknikolarak‘UNICODEDeğiştirmeKarakteri’(UNICODEReplacementCharacter) adı verilir. Bazı yerlerde bu karakteri elmas şeklinde siyah bir küp içine yerleştirilmiş soru işaretişeklindegörebilirsiniz. Peki encode() metodunu anlatırken errors parametresi ile birlikte kullanabildiğimiz ‘xmlcharrefreplace’değeriniopen()fonksiyonuilebirliktekullanabilirmiyiz? Hayır,open()fonksiyonu,errorsparametresindebudeğerinkullanılmasınaizinvermez. 520 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 30.4 Konu ile ilgili Fonksiyonlar Bu bölümde, karakter kodlama işlemleri esnasında işimize yarayacak bazı fonksiyonları ele alacağız. 30.4.1 repr() İnceleyeceğimizilkfonksiyonunadırepr().Esasındabizbufonksiyonuöncekiderslerimizde de birkaç örnekte kullanmıştık. Belki o zaman bu fonksiyonun ne işe yaradığını deneme-yanılma yoluyla anlamış olabilirsiniz. Eğer henüz bu fonksiyonun görevini anlamadıysanız da mesele değil. Bu bölümde bu fonksiyonu ve işlevini ayrıntılı bir şekilde anlatmayaçalışacağız. Dilersenizrepr()fonksiyonunuanlatmayabirörnekilebaşlayalım. ŞimdiPython’ınetkileşimlikabuğunuaçarakşukoduyazın: >>> "Python programlama dili" BukoduyazıpENTERdüğmesinebastığınızdaşöylebirçıktıalacağınızıbiliyorsunuz: >>> ’Python programlama dili’ Dikkat ettiyseniz, yukarıdaki kodların çıktısında karakter dizisi tırnak işaretleri içinde gösteriliyor. Eğer bu karakter dizisini print() fonksiyonu içine yazarsanız o tırnak işaretleri kaybolacaktır: >>> print("Python programlama dili") Python programlama dili Pekibuikifarklıçıktınınsebebine? Pythonprogramlamadilindenesnelerikifarklışekildetemsiledilir: 1. Python’ıngöreceğişekilde 2. Kullanıcınıngöreceğişekilde Yukarıdaki ilk kullanım, yazdığımız kodu Python programlama dilinin nasıl gördüğünü gösteriyor.İkincikullanımiseaynıkodubizimnasılgördüğümüzügösteriyor.Zatenbuyüzden, etkileşimli kabukta print() fonksiyonu içinde yazmadığımız karakter dizilerinin çıktılarını ekranda görebildiğimiz halde, aynı karakter dizilerini bir dosyaya yazıp kaydettiğimizde ekrandaçıktıolarakgörebilmekiçinbunlarıprint()fonksiyonuiçineyazmamızgerekiyor. Bu söylediklerimiz biraz karmaşık gelmiş olabilir. İsterseniz ne anlatmaya çalıştığımızı daha açıkbirörneküzerindegösterelim.Şimditekraretkileşimlikabuğuaçıpşukoduçalıştıralım: >>> "birinci satır\n" Bukomutbizeşuçıktıyıverdi: ’birinci satır\n’ Şimdiaynıkodubirdeşöyleyazalım: 30.4. KonuileilgiliFonksiyonlar 521 PythonBelgeleri,Yayım4.1.3 >>> print("birinci satır\n") birinci satır Gördüğünüz gibi, ilk kodun çıktısında satır başı karakteri (\n) görünürken, ikinci kodun çıktısındabukaraktergörünmüyor(amaişleviniyerinegetiriyor.Yanisatırbaşınageçilmesini sağlıyor). İşte bunun sebebi, ilk kodun Python’ın bakış açısını yansıtırken, ikinci kodun bizim bakış açımızıyansıtmasıdır. Pekibubilgibizimneişimizeyarar? Şimdişöylebirörnekdüşünün: Diyelimkielimizdeşöylebirdeğişkenvar: >>> a = "elma " Şimdibudeğişkeniekranaçıktıolarakverelim: >>> print(a) elma Gördüğünüz gibi, bu çıktıya bakarak, a değişkeninin tuttuğu karakter dizisinin son tarafında biradetboşlukkarakteriolduğunuanlayamıyoruz.Buyüzdenbudeğişkenişöylebirprogram içindekullanmayaçalıştığımızdanedenbozukbirçıktıeldeettiğimizianlamakzorolabilir: >>> print("{} kilo {} kaldı!".format(23, a)) 23 kilo elma kaldı! Gördüğünüzgibi,“elma”karakterdizisininsontarafındabirboşlukolduğuiçin‘elma’ile‘kaldı’ kelimeleriarasındagereksizbiraçıklıkmeydanageldi. Bu boşluğu print() ile göremiyoruz, ama bu değişkeni print() olmadan yazdırdığımızda o boşlukdagörünür: >>> a ’elma ’ Bu sayede programınızdaki aksaklıkları giderme imkanı kazanmış olur, şu kodu yazarak gereksizboşluklarıatabilirsiniz: >>> print("{} kilo {} kaldı!".format(23, a.strip())) 23 kilo elma kaldı! Daha önce de dediğimiz gibi, başında print() olmayan ifadeler, bir dosyaya yazılıp çalıştırıldığında çıktıda görünmez. O halde biz yukarıdaki özellikten yazdığımız programlarda nasıl yararlanacağız? İşte burada yardımımıza repr() adlı bir fonksiyon yetişecek. Bu fonksiyonuşöylekullanıyoruz: 522 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 print(repr("karakter dizisi\n")) Bukodubirdosyayayazıpkaydettiğimizdeşöylebirçıktıalıyoruz: ’karakter dizisi\n’ Gördüğünüz gibi hem tırnak işaretleri, hem de satır başı karakteri çıktıda görünüyor. Eğer repr()fonksiyonunukullanmasaydıkşöylebirçıktıalacaktık: karakter dizisi repr() fonksiyonu özellikle yazdığımız programlardaki hataları çözmeye çalışırken çok işimize yarar. Çünkü print() fonksiyonu, kullanıcının gözüne daha cazip görünecek bir çıktı üretebilmek için arkaplanda neler olup bittiğini kullanıcıdan gizler. İşte arkaplanda neler döndüğünü, print() fonksiyonunun bizden neleri gizlediğini görebilmek için bu repr() fonksiyonundanyararlanabiliriz. (cid:242) Not repr() fonksiyonu ile ilgili gerçek hayattan bir örnek için .com/blog/windows-python-3-2de-bir-hata.html27 (arşiv linki)adresindeki yazımızı okuyabilirsiniz. Bütün bu açıklamalar bize şunu söylüyor: repr() fonksiyonu, bir karakter dizisinin Python tarafındannasıltemsiledildiğinigösterir.Yukarıdabizbufonksiyonunnasılkullanıldığınadair ayrıntıları verdik. Ancak bu fonksiyonun, yine yukarıdaki işleviyle bağlantılı olmakla birlikte birazdahafarklıgörünenbirişlevidahabulunur. Hatırlarsanız, ilk derslerimizde r adlı bir kaçış dizisinden söz etmiştik. Bu kaçış dizisini şöyle kullanıyorduk: print(r"\n") Bildiğiniz gibi, \n kaçış dizisi bir alt satıra geçmemizi sağlıyor. İşte r adlı kaçış dizisi \n kaçış dizisinin bu işlevini baskılayarak, bizim \n kaçış dizisinin kendisini çıktı olarak verebilmemizi sağlıyor. Ohaldebunoktadasizeşöylebirsorusormamaizinverin: Acaba bir değişkene atanmış kaçış dizilerinin işlevini nasıl baskılayabiliriz? Yani mesela elimizdeşöylebirdeğişkenbulunuyorolsun: yeni_satır = "\n" Bizbudeğişkenindeğerininasılekranayazdıracağız? Eğer bunu doğrudan print() fonksiyonuna gönderirsek ne olacağını biliyorsunuz: Yeni satır karakteri işlevini yerine getirecek ve biz de yeni satır karakterinin kendisini değil, yaptığı işin sonucunu(yanisatırbaşınageçildiğini)göreceğiz. İştebutürdurumlariçinderepr()fonksiyonundanyararlanabilirsiniz: 27https://web.archive.org/web/20161027213804/http://www..com/blog/windows-python-3-2de-bir-hata. html 30.4. KonuileilgiliFonksiyonlar 523 PythonBelgeleri,Yayım4.1.3 print(repr(’\n’)) Böylece satır başı karakterinin işlevi baskılanacak ve biz çıktıda bu karakterin kendisini göreceğiz. HatırlarsanızASCIIkonusunuanlatırkenşöylebirörnekvermiştik: for i in range(128): if i % 4 == 0: print("\n") print("{:<3}{:>8}\t".format(i, repr(chr(i))), sep="", end="") İşte burada, repr() fonksiyonunun yukarıda sözünü ettiğimiz işlevinden yararlanıyoruz. Eğer bu kodlarda repr() fonksiyonunu kullanmazsak, ASCII tablosunu oluşturan karakterler arasındaki \n, \a, \t gibi kaçış dizileri ekranda görünmeyecek, bunun yerine bu kaçış dizileri doğrudan işlevlerini yerine getirecek, bu da bizim istediğimiz ASCII tablosunu üretmemize engelolacaktır. 30.4.2 ascii() ascii()fonksiyonubirazönceöğrendiğimizrepr()fonksiyonunaçokbenzer.Örneğin: >>> repr("asds") "’asds’" >>> ascii("asds") "’asds’" Bu iki fonksiyon, ASCII tablosunda yer almayan karakterlere karşı tutumları yönünden birbirlerindenayrılır.Örneğin: >>> repr("İ") "’İ’" >>> ascii("İ") "’\\u0130’" Gördüğünüz gibi, repr() fonksiyonu ASCII tablosunda yer almayan karakterleri de göründükleri gibi temsil ediyor. ascii() fonksiyonu ise bu karakterlerin UNICODE kod konumlarını(codepoints)gösteriyor. Birörnekdahaverelim: >>> repr("¿") "’¿’" (sonrakisayfayadevam) 524 Bölüm30. KarakterKodlama(CharacterEncoding) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> ascii("¿") "’\\u20ac’" ascii() fonksiyonunun UNICODE kod konumlarını gösterme özelliğinin bir benzerini daha önceöğrendiğimizencode()metoduyardımıyladaeldeedebilirsiniz: >>> "¿".encode("unicode_escape") b’\\u20ac’ Ancak ascii() fonksiyonunun str tipinde, encode() metodunun ise bytes tipinde bir çıktı verdiğinedikkatedin. 30.4.3 ord() Bufonksiyon,birkarakterinsayıkarşılığınıverir: >>> ord("\n") 10 >>> ord("¿") 8364 30.4.4 chr() Bufonksiyon,birsayınınkarakterkarşılığınıverir: >>> chr(10) ’\n’ >>> chr(8364) ’¿’ 30.4. KonuileilgiliFonksiyonlar 525 31 BÖLÜM Baytlar (Bytes) ve Bayt Dizileri (Bytearrays) Bubölümegelinceyekadarveritipiolarakkarakterdizilerinden,listelerdenvedosyalardansöz etmiştik. Bu bölümde ise Python programlama dilindeki iki veri tipinden daha söz edeceğiz. Birbirleriyle doğrudan bağlantılı oldukları için bu bölümde birlikte ele alacağımız bu veri tiplerininadı‘baytlar’(bytes)ve‘baytdizileri’(bytearrays). Bubölümdeyalnızca‘baytlar’ve‘baytdizileri’adlıveritiplerindensözetmeyeceğiz.Buikiyeni veri tipini bilgi dağarcığımıza eklemenin yanısıra, önceki bölümlerde öğrendiğimiz konuları zihnimizdepekiştirmeyevesağlamlaştırmayadadevamedeceğiz. 31.1 Giriş Bilgisayar teknolojisi ve bilimi açısından ‘karakter’ tamamen soyut bir kavramdır. Son birkaç bölümdür üstüne basa basa tekrar ettiğimiz gibi, karakter dediğimiz şey, bilgisayarların anlayabildiği tek kavram olan sayılara biz insanların atadığı birtakım işaretlerden ibarettir. Dolayısıyla bilgisayarlar açısından karakterler değil, ikili sayma düzenindeki birtakım sayılar, yanibitlervebaytlarvardır. Teknik olarak 1 bit, ikili sayma sistemindeki her bir basamağa verilen isimdir. Zaten ‘bit’ kelimesinin de İngilizcede ‘ikili basamak’ anlamına gelen ‘binary digit ifadesinin kısaltması olduğunugeçenbölümdeöğrenmiştiniz. Örneğinikilisaymasistemindeki0,birbitlikbirsayıiken,100üçbitlikbirsayıdır.Bubit’lerin 8 tanesi bir araya gelince ‘bayt’ denen birimi oluşturur. Yani bayt, 8 adet bit’ten oluşan bir birimdir. Nasıl bir düzinede 10, bir destede de 12 öğe olmasını biz insanlar tercih etmiş ve belirlemişsek,birbayt’tada8bitolmasınıyinebizinsanlartercihetmişvebelirlemişizdir. Önceki derslerimizde de öğrendiğimiz gibi, 8 adet bit, yani 1 bayt, Genişletilmiş ASCII sisteminde bir adet karakteri temsil etmek için kullanılabilecek en büyük birim olarak tasarlanmıştır. Yani Genişletilmiş ASCII tablolarının en sonundaki 255 numaralı karakteri temsil edebilmek için 8 adet bit, yani toplam 1 bayt kullanmamız gerekir. Standart ASCII sistemi ise 7 bitlik bir sistem olduğu için, bir adetkarakteri temsil etmekiçin kullanılabilecek 526 PythonBelgeleri,Yayım4.1.3 en büyük birimin 7 bit olduğunu biliyorsunuz. Dolayısıyla ASCII sistemindeki son karaktere karşılıkgelen127.sayıyıtemsiledebilmekiçintoplam7bityeterlidir. FarklıbirsistemolanUTF-8isebirdenfazlabaytkullanarakçoksayıdakarakteritemsiletmeye imkan tanır. UTF-8 ile, duruma göre 1, 2, 3 veya 4 bayt kullanarak, UNICODE sistemi içinde tanımlanmış bütün karakterleri temsil edebilirsiniz. UTF-8, değişken boyutlu bir kodlama sistemiolmasısayesinde,birkarakteritemsiledebilmekiçinkaçbaytgerekiyorsa,okarakteri temsil etmek için o kadar bayt kullanır. Ama mesela UTF-32 adlı kod çözücü hangi karakter olursa olsun hepsini 4 bayt (32 bit) ile temsil eder. Bu durumda aslında tek baytla temsil edilebilecek‘a’,‘b’,‘c’gibikarakterlerdeboşuboşuna4baytyerkaplamışolur.ZatenUTF-8’in bukadaryaygınvegözdeolmasınınnedenidehemçoksayıdakarakterikodlayabilmesi,hem debuişiyaparkentasarrufluolmayıbaşarabilmesidir. Python programlama dilinde karakter dizileri UNICODE kod konumları şeklinde temsil edilir. Dolayısıyla str adı verilen veri tipi esasında karakter dizilerini birtakım UNICODE kod konumları şeklinde gösteren soyut bir yapıdır. Yani biz Python’da karakter dizileri üzerinde işlemyaparkenaslındabaytlarladeğil,UNICODEkodkonumlarıilemuhatapoluyoruz.Ancak UNICODE kod konumları da tamamen soyut kavramlardır. Bunları bilgisayarın belleğinde bu şekilde temsil edemezsiniz ya da bu kod konumlarını herhangi bir ağ üzerinden başka bilgisayarlara iletemezsiniz. Bu kod konumlarını anlamlı bir şekilde kullanabilmek için öncelikle bunları bilgisayarların anlayabileceği bir biçim olan baytlara çevirmeniz gerekir. Çünkü dediğimiz gibi bilgisayarlar yalnızca bitler ve baytlardan anlar. İşte kod çözücülerin görevidezatenbukodkonumlarınıbaytlaraçevirmektir. Esasında programcılık maceranız boyunca genellikle metin ihtiyaçlarınızı UNICODE kod konumları üzerinden halledeceksiniz. Python sistemdeki öntanımlı kod çözücüyü kullanarak bu kod konumlarını alttan alta bayta çevirip bellekte saklayacaktır. Ama eğer yazdığınız programlarda herhangi bir şekilde doğrudan baytlarla muhatap olmanız gerekirse str veri tipini değil, bytes adlı başka bir veri tipini kullanacaksınız. Örneğin ikili (binary) dosyalar üzerinde çeşitli çalışmalar yapacaksanız ve bu ikili dosyalara birtakım veriler girecekseniz, gireceğinizbuverilerbytestipindeolacaktır. Bütün bu sebeplerden ötürü, str ve bytes veri tipleri arasındaki farkı anlamak, yazdığınız programların kararlılığı ve sağlamlığı açısından büyük önem taşır. O anda elinizde olan verinin hangi tipte olduğunu bilmezseniz, bu verinin, programınızın çalışması esnasında size ne tür tuzaklar kurabileceğini de kestiremezsiniz. Örneğin bütün karakterlerin 1 bayt olduğunu ve bunların da yalnızca 0 ile 127 arası sayılarla temsil edilebileceğini zanneden yazılımcıların tasarladığı programlara Türkçe karakterler girdiğinizde nasıl bu programlar patır patır dökülüyorsa, eğer siz de baytlar ve karakterler arasındaki farkı anlamazsanız sizin yazdığınızprogramlardahiçbeklemediğinizbirandatökezleyebilir. Örneğin yazdığınız bir programın bir aşamasında programa yalnızca tek karakterlik verilerin girilmesitemeliüzerindenbirişlemyaptığınızıdüşünün.Yaniprogramınıziçindeyapacağınız birişlem,birdenfazlakaraktergirişininengellenmesinigerektiriyorolsun. Bununiçinşöylebirşeyyazmışolun: a = "k" if len(a) > 1: print("Lütfen yalnızca tek bir karakter giriniz!") else: print("Teşekkürler!") 31.1. Giriş 527 PythonBelgeleri,Yayım4.1.3 Benburadatemsiliolarakaadlıbirdeğişkenoluşturdumveörnekolmasıaçısındandabunun değerini ‘k’ olarak belirledim. Bu değerlerle programımız düzgün bir şekilde çalışır. Çünkü a değişkeninindeğeritekbirkarakterolan‘k’harfi.Amaeğeradeğişkeninindeğerimesela‘kz’ gibibirşeyolsaydıprogramımız‘Lütfenyalnızcatekbirkaraktergiriniz!’uyarısıverecekti... Şimdi bu a değişkeninin sizin tarafınızdan belirlenmediğini, bu değerin başka bir kaynaktan geldiğini düşünün. Eğer size bu değeri gönderen kaynak, bu değeri UNICODE kod konumu olarak gönderiyorsa programınız düzgün çalışır. Ama peki ya gelen bu veri bayt olarak geliyorsaneolacak? Yukarıda verdiğimiz örneğin neden önemli olduğunu, daha doğrusu bu örnekle ne demek istediğimiz ve nereye varmaya çalıştığımızı anlamamış olabilirsiniz. Ama endişe etmenize hiç gerek yok. Zira bu bölümde yukarıda sorduğumuz sorunun cevabını derinlemesine ele alacağız. Bu bölümün sonuna vardığımızda neler olup bittiğini ve baytların neden bu kadar önemliolduğunugayetiyianlıyorolacaksınız. 31.2 Eskisi ve Yenisi GelinisterseniztamolarakneilekarşıkarşıyaolduğumuzudahaiyianlayabilmekiçinPython3 öncesidurumunnasılolduğunabakalım.EğergeçmiştePythonprogramlamadilininkarakter dizileri ve baytları nasıl ele aldığını bilirsek bugünkü durumu ve dolayısıyla genel olarak karakterdizisivebaytkavramınıçokdahanetbirşekildekavrayabiliriz. Python’ın2.xsürümlerinde,birkarakterdizisitanımladığınızdaPythonbukarakterdizisinibir baytdizisiolaraktemsilediyordu.Örneğin: >>> kardiz = "e" Buradakardizadlıdeğişkenindeğeri,birbaytlıkbirkarakterdizisidir.Bunulen()fonksiyonu ileteyitedelim: >>> len(kardiz) 1 Birdeşunabakalım: >>> kardiz = "ş" Burada ise kardiz adlı değişkenin değerinin kaç baytlık bir karakter dizisi olduğu, yani bir bakıma len() fonksiyonunun ne çıktı vereceği işletim sisteminden işletim sistemine farklılık gösterir. Eğer kullandığınız işletim sistemi Windows ise muhtemelen len(kardiz) komutu 1 çıktısı verecektir. Ama eğer bu komutu GNU/Linux dağıtımlarından birinde veriyorsanız alacağınızçıktıbüyükihtimalle2olacaktır. Dediğimiz gibi, Python2’de str veri tipi bize bir dizi bayt verir. Dolayısıyla bu veri tipinin içindetuttuğukarakterdizisininkaçbaytilegösterileceği,sistemdekiöntanımlıkodçözücünün hangisi olduğuna bağlıdır. Kullandığınız işletim sisteminde öntanımlı kod çözücünün hangisi olduğunuşukomutlabulabilirsiniz: >>> import locale >>> locale.getpreferredencoding() 528 Bölüm31. Baytlar(Bytes)veBaytDizileri(Bytearrays) PythonBelgeleri,Yayım4.1.3 EğerWindowskullanıyorsanızburadanalacağınızçıktımuhtemelencp1254olacaktır.cp1254, Microsoft’unTürkçeiçinözelolarakkullandığıbirkodsayfasıolduğuiçin,128ile256sayıları arasında Türkçe karakterleri içerir. O yüzden bu kodlama sisteminde Türkçe karakterler 1 bayt ile gösterilebilir. Bu kod sayfasının içeriğinde hangi karakterlerin hangi sayılara karşılık geldiğini görmek için en.wikipedia.org/wiki/Windows-125428 adresindeki tabloyu inceleyebilirsiniz. AmaeğeryukarıdakikomutlarınçıktısıUTF-8veyabaşkabirkodçözücüise,Türkçekarakterler 1baytilegösterilemeyeceğiiçinlen(kardiz)komutu1değil,2çıktısıverecektir. Birdeşunabakalım: >>> len("¿") Bu komutu hangi işletim sisteminde verdiğinize bağlı olarak yukarıdaki komuttan alacağınız çıktıfarklıolacaktır.strtipiPython2’dekarakterdizilerinibaytolaraktemsileder.Butemsilin de hangi kurallara göre yapılacağı kullanılan kod çözücüye bağlıdır. Eğer karakter dizileri baytlara çevrilirken cp1254 adlı kod çözücü kullanılırsa, bu kod çözücü ‘=C’ simgesini tek bayt ilegösterilebildiğiiçinyukarıdakikomut1çıktısıverir.AmaUTF-8adlıkodçözücü‘=C’simgesini 3baytlagösterebildiğiiçinyukarıdakikomutunçıktısıdabunaparalelolarak3olacaktır. str veri tipi ile gösterilen bu karakter dizilerinin içindeki baytlara ulaşmak için şu yöntemi kullanabilirsiniz: >>> "ş"[0] ’\xc5’ >>> "ş"[1] ’\x9f’ Gördüğünüz gibi, str veri tipi gerçekten de bize bir dizi bayt veriyor. Eğer karakter dizilerini baytlarına göre değil de sahip oldukları karakter sayısına göre saymak isterseniz bunları UNICODEolaraktanımlanızgerekiyor: >>> len(u’ş’) 1 Python3 ile birlikte yukarıda bahsettiğimiz durumda bazı değişiklikler oldu. Artık str veri tipi UNICODE kod konumlarını döndürüyor. Dolayısıyla artık her karakter dizisi, sahip oldukları karaktersayısınagöresayılabiliyor: >>> len("ş") 1 >>> len("¿") 1 28https://en.wikipedia.org/wiki/Windows-1254 31.2. EskisiveYenisi 529 PythonBelgeleri,Yayım4.1.3 İşte eğer Python2’deki str veri tipini elde etmek istiyorsanız, Python3’te bytes adlı yeni veri tipinikullanmanızgerekiyor. 31.3 Bayt Tanımlamak BildiğinizgibiPythonprogramlamadilindeherveritipininkendineözgübirtanımlanmabiçimi var.Örneğinbirlistetanımlamakiçinşöylebirşeyyazıyoruz: >>> liste = [] Böyleceboşbirlistetanımlamışolduk.Aynışekildekarakterdizilerinideşöyletanımlıyorduk: >>> kardiz = ’’ Buşekildedeboşbirkarakterdizisitanımlamışolduk.İşteboşbirbayttanımlamakiçindeşu yapıyıkullanıyoruz: >>> bayt = b’’ Gelintanımladığımızbuveritipininbaytolduğunuteyitedelim: >>> type(bayt) <class ’bytes’ Gördüğünüz gibi, gerçekten de bayt tipinde bir veri tanımlamışız. Nasıl karakter dizileri ‘str’, listeler‘list’ifadesiylegösteriliyorsa,baytlarda‘bytes’ifadesiilegösterilir. Pekibuşekildebirbaytveritipitanımlamakneişimizeyarar? Hatırlarsanız bayt veri tipini ikili (binary) dosyaları anlatırken de görmüştük. Orada da söylediğimizgibi,ikilidosyalarıokuduğunuzdaeldeedeceğinizşeykarakterdizisideğilbayttır. Aynı şekilde, ikili dosyalara da ancak baytları yazabilirsiniz. Dolayısıyla eğer ikili dosyalarla birtakımişlemleryapacaksanızbubaytveritipiniyoğunolarakkullanacağınızdanhiçşüpheniz olmasın.Yanibaytveritipikolaycagörmezdengelebileceğinizgereksizbirveritipideğildir. 31.4 bytes() Fonksiyonu BaytveritipitemelolarakASCIIkarakterlerikabuleder.DolayısıylaASCIItablosudışındakalan karakterleridoğrudanbaytolaraktemsiledemezsiniz: >>> b’ş’ File "<stdin>", line 1 SyntaxError: bytes can only contain ASCII literal characters. AmaASCIIdışındakalankarakterleridebayt’adönüştürmeninbiryoluvar.Bununiçinbytes() adlıbirfonksiyondanyararlanacağız: >>> b = bytes("ş", "utf-8") 530 Bölüm31. Baytlar(Bytes)veBaytDizileri(Bytearrays) PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, ilgili karakterin hangi kod çözücü ile kodlanacağını belirterek, bayt tipinde birverioluşturabiliyoruz. Tahmin edebileceğiniz gibi, bytes() fonksiyonu, belirttiğimiz kod çözücü ile kodlanamayan karakterlerlekarşılaşılmasıdurumundaneyapılacağınıbelirlememizisağlayanerrorsadlıbir parametreyedesahiptir: >>> b = bytes("Fırat", "ascii", errors="xmlcharrefreplace") >>> b b’F&#305;rat’ Önceki derslerimizde errors parametresinin hangi değerleri alabileceğini tartışmıştık. Orada anlattığımızşeylerburadadageçerlidir. 31.5 Baytların Metotları Bütün veri tiplerinde olduğu gibi, bytes adlı veri tipinin de birtakım metotları bulunur. Bu metotlarınlistesinialmakiçinşukomutukullanabileceğinizibiliyorsunuz: >>> dir(bytes) Listeye baktığınızda bu metotları karakter dizilerinin metotları ile hemen hemen aynı olduğunu göreceksiniz. Baytların metotları arasında olup da karakter dizilerinin metotları arasındaolmayanmetotlarışuşekildeeldeedebilirsiniz: >>> for i in dir(bytes): ... if i not in dir(str): ... print(i) decode fromhex Gördüğünüzgibi,decode()vefromhex()adlımetotlarbaytlardavar,amakarakterdizilerinde yok.Oyüzdenbizdebubölümdeyalnızcabuikimetoduincelemekleyetineceğiz.Çünküöteki metotlarızatenkarakterdizilerindentanıyorsunuz. 31.5.1 decode Hatırlarsanızkarakterdizilerininencode()adlıbirmetoduvardı.Bumetotyardımıylakarakter dizilerinibellibirkodlamabiçiminegörekodlayabiliyor,yanibunlarıbaytlaraçevirebiliyorduk. Mesela‘İ’harfiniUTF-8ilekodlayalım: >>> "İ".encode("utf-8") b’\xc4\xb0’ Aynıharficp1254ilekodlarsakşuçıktıyıeldeederiz: 31.5. BaytlarınMetotları 531 PythonBelgeleri,Yayım4.1.3 >>> "İ".encode("cp1254") b’\xdd’ Tahminedebileceğinizgibi,buharfiASCIIilekodlayamayız: >>> "İ".encode("ascii") Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError: ’ascii’ codec can’t encode character ’\u0130’ in position 0: ordinal not in range(128) İşte bu kodlama işlemini tersine çevirebilmek, yani baytları belli bir kodlama biçimine göre karakterdizilerinedönüştürebilmekiçindecode()metodundanyararlanacağız: >>> b"\xc4\xb0".decode("utf-8") ’İ’ Bubaytlarıbirdebaşkakodlamasistemleriilekodlamayıdeneyelim: >>> b"\xc4\xb0".decode("cp1254") ’Ä(cid:176)’ Gördüğünüz gibi, cp1254 adlı kod çözücü bu baytı çözebiliyor, ama yanlış çözüyor! Çünkü bu baytın gösterdiği sayı cp1254 adlı kod sayfasında ‘İ’ye değil, başka bir karaktere karşılık geliyor. Aslında başka iki karaktere, yani C4 ve B0 ile gösterilen Ä ve ° karakterlerine karşılık geliyor... Budurumuhttps://en.wikipedia.org/wiki/Windows-1254adresinegidipkendinizde görebilirsiniz. BubaytlarıbirdeASCIIileçözmeyeçalışalım: >>> b"\xc4\xb0".decode("ascii") Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError: ’ascii’ codec can’t decode byte 0xc4 in position 0: ordinal not in range(128) Elbette, bu karakter 128’den büyük bir sayıya karşılık geldiği için ASCII tarafından çözülemeyecektir. 532 Bölüm31. Baytlar(Bytes)veBaytDizileri(Bytearrays) PythonBelgeleri,Yayım4.1.3 31.5.2 fromhex Bu metot, onaltılı sayma sistemindeki bir sayıdan oluşan bir karakter dizisini alıp, bayta dönüştürür.Bumetoduşöylekullanıyoruz: >>> bytes.fromhex("c4b0") b’\xc4\xb0’ Gördüğünüzgibi,bumetotbironaltılısayıolanc4b0’ıalıp,bizebirbaytnesnesiveriyor. 31.6 Bayt Dizileri bytes adlı veri tipi ile elde ettiğimiz veri tıpkı karakter dizileri gibi, üzerinde değişiklik yapılamayan bir veridir. Dolayısıyla bir bytes nesnesi üzerinde değişiklik yapabilmek için o nesneyitekrartanımlamamızgerekir: >>> b = b’PDF’ >>> v = b’-1.7’ >>> b = b + v >>> b b’PDF-1.7’ Ama Python programlama dilinde bytes veri tipi dışında, baytlara ilişkin ikinci veri tipi daha bulunur.bytearrayadlıbuveritipi,bytesveritipininaksine,üzerindedeğişiklikyapılabilenbir veritipidir. Python’dabytearrayveritipinişuşekildetanımlıyoruz: >>> pdf = bytearray(b’PDF-1.7’) Gördüğünüz gibi, bir bayt dizisi tanımlayabilmek için bytearray() adlı bir fonksiyondan faydalanıyoruz. 31.7 Bayt Dizilerinin Metotları Bayt dizileri bir bakıma listelerle baytların karışımı gibidir. dir(bytearray) gibi bir komutla bu veri tipinin metotlarını inceleyecek olursanız, bu veri tipinin hem baytlardan hem de listelerdenbirtakımmetotlaraldığınıgörürsünüz. Buveritipilistelerinşumetotlarınasahiptir: 1. append 2. clear 3. copy 4. count 5. extend 31.6. BaytDizileri 533 PythonBelgeleri,Yayım4.1.3 6. index 7. insert 8. pop 9. remove 10. reverse Buveritipibaytlarıniseşumetotlarınasahiptir: 1. capitalize 2. center 3. count 4. decode 5. endswith 6. expandtabs 7. find 8. fromhex 9. index 10. isalnum 11. isalpha 12. isdigit 13. islower 14. isspace 15. istitle 16. isupper 17. join 18. ljust 19. lower 20. lstrip 21. maketrans 22. partition 23. replace 24. rfind 25. rindex 26. rjust 27. rpartition 28. rsplit 534 Bölüm31. Baytlar(Bytes)veBaytDizileri(Bytearrays) PythonBelgeleri,Yayım4.1.3 29. rstrip 30. split 31. splitlines 32. startswith 33. strip 34. swapcase 35. title 36. translate 37. upper 38. zfill 31.7. BaytDizilerininMetotları 535 32 BÖLÜM Sözlükler ŞuanakadarPythonprogramlamadilindeveritipiolarakkarakterdizilerini,sayıları,listeleri, demetleri ve dosyaları öğrendik. Yeni veri tipleri öğrendikçe Python’daki hareket alanımızın dagenişlediğinisizdefarketmişsinizdir.BubölümdeyinePython’dakiönemliveritiplerinden biriniinceleyeceğiz.Budefainceleyeceğimizveritipininadısözlük.İngilizcedebunadictionary diyorlar. Sözlükler de, tıpkı daha önceki derslerimizde öğrendiğimiz karakter dizileri, sayılar, listeler, demetlervedosyalargibiprogramlamamaceramızboyuncaişlerimizibirhaylikolaylaştıracak vehareketimkanımızıgenişletecekveritiplerindenbiridir. Ötekiveritiplerindeolduğugibi,sözlüklerindebirtakımmetotlarıvardır.İştebubölümdehem genelolaraksözlüklerdensözedeceğiz,hemdebuveritipininmetotlarınıeninceayrıntısına kadarinceleyeceğiz. Sözlük denen veri tipi Python programlama dilinin son derece kullanışlı ve işe yarar araçlarından bir tanesidir. Programlama alanında ilerledikçe, bu veri tipinin neler yapabileceğinigörüpşaşıracağınızırahatlıklasöyleyebilirim. Esasındabizdahaöncekiderslerimizinbirindesözlükadlıbuveritipindenüstünkörüdeolsa sözetmiştik.Yaniaslındabuveritipiyletanışıklığımızeskiyedayanıyor. Hatırlayacaksınız, karakter dizilerinin str.maketrans() ve translate() adlı metotlarını anlatırken,Türkçeyeözgükarakterlerivebunlarınnoktasızkarşılıklarınıiçerençeviri_tablosu adınıverdiğimizşöylebirdeğişkentanımlamıştık: çeviri_tablosu = {"Ö": "O", "ç": "c", "Ü": "U", "Ç": "C", "İ": "I", "ı": "i", "Ğ": "G", "ö": "o", "ş": "s", (sonrakisayfayadevam) 536 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) "ü": "u", "Ş": "S", "ğ": "g"} Burada çeviri_tablosu değişkeni içinde gösterdiğimiz biçimin Python’daki adının ‘sözlük’ olduğunudaifadeetmiştik.İştebubölümde,oradaşöylebirdeğinipgeçtiğimizbuveritipini çokdahaayrıntılıbirşekildeelealmaimkanımızolacak. Hemeskibilgilerimizedayanarak,hemdeyukarıdaanlattıklarımızdanyolaçıkaraksözlükveri tipininneolduğunadairhalihazırdakafamızdabirfikiroluşmuşolduğunusöyleyebiliriz. Sözlüklerötekiveritiplerinekıyaslabirazfarklıbirgörünüşesahipbirveritipidir.Bizbirazdan sözlüklerinyapısınıderinlemesineinceleyeceğiz. Ancak sözlüklerin yapısını incelemeye geçmeden önce öğrenmemiz gereken bir şey var. Tıpkı öteki veri tiplerinde olduğu gibi, sözlüklerle de çalışabilmek için öncelikle bu veri tipini tanımlamışolmamızgerekiyor.Oyüzdenistersenizsözlüklerinyapısındansözetmedenönce birsözlüğünasıltanımlayacağımızdanbahsedelim. 32.1 Sözlük Tanımlamak Dediğimiz gibi, karakter dizilerini anlatırken verdiğimiz sözlük örneği sayesinde sözlüklerin neyebenzediğiniazçokbiliyoruz.Gelinistersenizsözlüklerinnasıltanımlandığınıinceleyerek buveritipininderinliklerinedoğruilkkulaçlarımızıatalım. Python programlama dilindeki sözlük veri tipi, gerçek hayatta ‘sözlük’ denince aklınıza gelen şeyeçokbenzer.Meselagerçekhayatta‘kitap’kelimesininİngilizcebirsözlüktekikarşılığıbook kelimesidir.Dolayısıyla‘kitap’ve‘book’kelimeleriarasındakiilişkiyiherhaldeşuşekildetemsil edebiliriz: kitap:book Bu manzara bize ‘kitap’ kelimesinin karşılığının ‘book’ olduğunu açık bir şekilde gösteriyor. EğerbudurumuPython’dakisözlükveritipiylegöstermekisteseydikşöylebirşeyyazacaktık: >>> kelimeler = {"kitap": "book"} Burada, içeriği sözlük veri tipi olan kelimeler adlı bir değişken tanımladık. Gördüğünüz gibi, listelere benzer bir şekilde sözlük veri tipi de içinde farklı veri tiplerini barındıran, ‘kapsayıcı’ birveritipidir.Buradasözlüğümüzikiadetkarakterdizisindenoluşuyor. Yukarıdaki sözlüğü nasıl tanımladığımıza çok dikkat edin. Nasıl ki listelerin ayırt edici özelliği köşeliparantezlerdi,sözlüklerinayırtediciözelliğidekümeparantezleridir. Esasındasözlükdediğimizşeyenbasithaliyleşöylegörünür: >>> sözlük = {} Buörnekboşbirsözlüktür.İstersenizyukarıdakiveritipiningerçektendebirsözlükolduğunu kanıtlayalım: 32.1. SözlükTanımlamak 537 PythonBelgeleri,Yayım4.1.3 >>> type(sözlük) <class ’dict’> Sözlüklerin Python programlama dilindeki teknik karşılığı dict ifadesidir. type(sözlük) sorgusu<class ’dict’>çıktısıverdiğinegöre,sözlükadlıdeğişkeningerçektendebirsözlük olduğunusöyleyebiliyoruz. Yukarıdaşöylebirsözlükörneğiverdiğimizihatırlıyorsunuz: >>> kelimeler = {"kitap": "book"} Python programlama diline özellikle yeni başlayanlar, sözlüklerin görünüşü nedeniyle bir sözlükteki öğe sayısı konusunda tereddüte kapılabilir, örneğin yukarıdaki sözlüğün 2 öğeden oluştuğu yanılgısına düşebilir. O halde bu noktada size şöyle bir soru sormama izin verin: Acababusözlüktekaçöğevar?Hemenbakalım: >>> len(kelimeler) 1 Demek ki elimizdeki veri tipi bir adet öğeye sahip bir sözlükmüş. Gördüğünüz gibi, "kitap": "book" ifadesi tek başına bir öğe durumundadır. Yani burada “kitap” karakter dizisini ayrı, “book”karakterdizisiniayrıbiröğeolarakalmıyoruz.Buikisitekbirsözlüköğesioluşturuyor. Hatırlarsanız,listelerdeöğeleribirbirindenayırmakiçinvirgülişaretlerindenyararlanıyorduk. Sözlüklerdedebirdenfazlaöğeyibirbirindenayırmakiçinvirgülişaretlerindenyararlanacağız: >>> kelimeler = {"kitap": "book", "bilgisayar": "computer"} Biröncekiörnekteköğeliydi.Busözlükise2öğeyesahiptir: >>> len(kelimeler) 2 İlk derslerimizden bu yana sürekli olarak vurguladığımız gibi, Python programlama dilinde doğru kod yazmak kadar okunaklı kod yazmak da çok önemlidir. Mesela bir sözlüğü şöyle tanımladığımızdakodlarımızınpekokunaklıolmayacağınısöyleyebiliriz: sözlük = {"kitap": "book", "bilgisayar": "computer", "programlama": "programming ", ˓→ "dil": "language", "defter": "notebook"} Teknik olarak baktığımızda bu kodlarda hiçbir problem yok. Ancak sözlükleri böyle sağa doğruuzayacakşekildetanımladığımızdaokunaklılığıazaltmışoluyoruz.Buyüzdenyukarıdaki sözlüğüşöyleyazmayıtercihedebiliriz: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming", "dil" : "language", "defter" : "notebook"} 538 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 Buşekildesözlüktekiöğelerarasındakiilişkidahabelirgin,yazdığınızkodlardadahaokunaklı birhalegelecektir. Python’da bir sözlük oluşturmanın başka yolları da olmakla birlikte, en temel sözlük oluşturmayöntemiyukarıdakiörneklerdegösterdiğimizgibidir.Bizilerleyensayfalardasözlük oluşturmanınfarklıyöntemlerinideelealacağız.Ancakşimdilik‘sözlüktanımlama’konusunu buradanoktalayıpsözlüklerleilgiliönemlibirkonuyadahadeğinelim. 32.2 Sözlük Öğelerine Erişmek Yukarıdaki örneklerden bir sözlüğün en basit şekilde nasıl tanımlanacağını öğrendik. Peki tanımladığımızbirsözlüğünöğelerinenasılerişeceğiz? Hemenbasitbirörnekverelim.Dahaöncetanımladığımızşusözlüğebirbakalımmesela: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming", "dil" : "language", "defter" : "notebook"} Bu sözlükte birtakım Türkçe kelimeler ve bunların İngilizce karşılıkları var. Şimdi mesela bu sözlükteki‘kitap’adlıöğeyeerişelim: print(sözlük["kitap"]) Bukodlarıçalıştırdığımızdaşöylebirçıktıalırız: book Yukarıdaki örnekten anladığımız gibi, sözlük öğelerine erişmek için şöyle bir formül kullanıyoruz: sözlük[sözlük_öğesinin_adı] Aynı şekilde sözlük değişkeni içindeki ‘bilgisayar’ öğesinin karşılığını almak istersek şöyle bir kodyazıyoruz: print(sözlük["bilgisayar"]) Budabize“computer”çıktısınıveriyor. Karakter dizilerini anlatırken verdiğimiz çeviri_tablosu adlı sözlüğe ve orada anlattıklarımıza geri dönelim şimdi. Artık sözlük adlı veri tipiyle iyiden iyiye tanıştığımıza göre, orada anlattıklarımızzihninizdedahanetbirhalegelmişolmalı. Oradakitablomuzşöyleydi: çeviri_tablosu = {"Ö": "O", "ç": "c", "Ü": "U", "Ç": "C", (sonrakisayfayadevam) 32.2. SözlükÖğelerineErişmek 539 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) "İ": "I", "ı": "i", "Ğ": "G", "ö": "o", "ş": "s", "ü": "u", "Ş": "S", "ğ": "g"} Meselabusözlükteki“Ö”öğesininkarşılığınıeldeetmekiçinşöylebirkodyazdığımızıgayetiyi hatırlıyorsunuz: print(çeviri_tablosu["Ö"]) Bukodlarıbirdosyayakaydedipçalıştırdığımızdaşöylebirçıktıalıyorduk: O Gördüğünüz gibi sözlükteki “Ö” adlı öğeyi parantez içinde belirttiğimiz zaman, Python bize buöğeninkarşısındakideğeriveriyor.Dolayısıylasözlükiçinde“Ö”öğesininkarşılığı“O”harfi olduğuiçindeçıktımız“O”oldu. Sözlüğünötekiöğeleriniiseşuşekildealabiliyoruz: print(çeviri_tablosu["Ö"]) print(çeviri_tablosu["ç"]) print(çeviri_tablosu["Ü"]) print(çeviri_tablosu["Ç"]) print(çeviri_tablosu["İ"]) print(çeviri_tablosu["ı"]) print(çeviri_tablosu["Ğ"]) print(çeviri_tablosu["ö"]) print(çeviri_tablosu["Ş"]) print(çeviri_tablosu["ğ"]) Ancak kod tekrarından kaçınmak için yukarıdaki kodları şu şekilde sadeleştirme imkanımızın daolduğunubiliyorsunuz: for i in çeviri_tablosu: print(çeviri_tablosu[i]) Gördüğünüz gibi, sözlük içinde iki nokta üst üste işaretinin sol tarafında görünen öğeleri köşeli parantez içinde yazarak, iki nokta üst üste işaretinin sağ tarafındaki değerleri elde edebiliyoruz. EğerbirsözlükiçindebulunmayanbiröğeyeerişmeyeçalışırsakPythonbizeKeyErrortipinde birhatamesajıverecektir.Meselayukarıdakisözlüğütemelalacakolursakşöylebirsorguhata verecektir: >>> print(çeviri_tablosu["Z"]) (sonrakisayfayadevam) 540 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Traceback (most recent call last): File "deneme.py", line 14, in <module> print(çeviri_tablosu["Z"]) KeyError: ’Z’ Sözlükte“Z”kaydıbulunmadığıiçindoğalolarakPython’ınbizebirhatamesajıgöstermekten başkaçaresikalmıyor. Sözlükler ile ilgili epey bilgi edindik. Dilerseniz bu öğrendiklerimizi örnek bir uygulama üzerindesomutlaştırmayaçalışalım.MeselaPython’dakisözlüklerikullanarakbasitbirtelefon defteriuygulamasıyazalım: telefon_defteri = {"ahmet öz" : "0532 532 32 32", "mehmet su": "0543 543 42 42", "seda naz" : "0533 533 33 33", "eda ala" : "0212 212 12 12"} kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ") cevap = "{} adlı kişinin telefon numarası: {}" print(cevap.format(kişi, telefon_defteri[kişi])) Burada öncelikle isimler ve telefon numaralarından oluşan, sözlük veri tipinde bir telefon defterioluşturduk: telefon_defteri = {"ahmet öz" : "0532 532 32 32", "mehmet su": "0543 543 42 42", "seda naz" : "0533 533 33 33", "eda ala" : "0212 212 12 12"} Bu kodlarda bilmediğimiz hiçbir şey yok. Sözlüklere dair öğrendiklerimizi kullanarak oluşturduğumuzoldukçabasitbirsözlüktürbu. Daha sonra kullanıcıdan, telefon numarasını öğrenmek için bir kişi adı girmesini istiyoruz. Bunudaşukodlaryardımıylayapıyoruz: kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ") Ardındandatelefondefterindesorgulamayapacakolankullanıcıyagöstereceğimizcevapiçin birşablonoluşturuyoruz: cevap = "{} adlı kişinin telefon numarası: {}" Meselakullanıcı“ahmetöz”isminisorgulamışsaonaşöylebircevapvereceğiz: "ahmet öz adlı kişinin telefon numarası 0532 532 32 32" Eğerarananisimtelefondefterindevarsa,biröncekiadımdatanımladığımızcevapşablonuna göre kullanıcıyı bilgilendiriyoruz. Ama eğer isim defterde yoksa, programımız hata veriyor. Bunuönlemekiçinşöylebirkodyazabilirsiniz: 32.2. SözlükÖğelerineErişmek 541 PythonBelgeleri,Yayım4.1.3 telefon_defteri = {"ahmet öz" : "0532 532 32 32", "mehmet su": "0543 543 42 42", "seda naz" : "0533 533 33 33", "eda ala" : "0212 212 12 12"} kişi = input("Telefon numarasını öğrenmek için bir kişi adı girin: ") if kişi in telefon_defteri: cevap = "{} adlı kişinin telefon numarası: {}" print(cevap.format(kişi, telefon_defteri[kişi])) else: print("Aradığınız kişi telefon rehberinde yok!") Gördüğünüz gibi, if kişi in telefon_defteri satırı yardımıyla öncelikle aranan ismin sözlükte olup olmadığını denetledik. Eğer aranan isim sözlükte yer alıyorsa bu telefon numarasını kullanıcılarımıza gösteriyoruz. Aksi durumda aranan kişinin telefon rehberinde olmadığıkonusundakullanıcılarımızıbilgilendiriyoruz. Gördüğünüz gibi, sözlükler gerçekten de bize Python programlama maceramızda yepyeni olanakların kapısını açabilecek kadar güçlü bir veri tipi. Bu veri tipini programlarınızda bolca kullanacaksınız. Yukarıda verdiğimiz telefon defteri uygulamasına şöyle bir baktığınızda bu uygulamanın aslında geliştirilmeye bir hayli açık olduğu dikkatinizi çekmiştir. Mesela biz bu uygulamada sadece kendi tanımladığımız bir telefon defteri üzerinden sorgulama yapmaya izin verdik. Örneğin kullanıcı bu telefon defterine kendi isim-telefon çiftlerini giremiyor. Bu veri tipini etkili bir şekilde kullanmamızı sağlayacak araçlardan henüz yoksun olduğumuz için yukarıda tanımladığımız uygulama çok basit kaldı. O halde, sözlük veri tipini daha verimli ve etkili bir biçimde kullanabilmek için hiç vakit kaybetmeden bu veri tipinin derinliklerine doğru yol almayadevamedelim. 32.3 Sözlüklerin Yapısı Yukarıdaki örneklerden, Python’da bir sözlüğün nasıl tanımlanacağını ve bir sözlüğün öğelerinenasılerişileceğiniöğrendik.Gelinistersenizşimdisözlükveritipininyapısınailişkin bazıayrıntılarıinceleyelim. Meselaşuörneğitekrarönümüzealalım: sözlük = {"kitap": "book"} Burada iki nokta üst üste işaretinden önce ve sonra birer tane karakter dizisi görüyoruz. Bu karakter dizileri “kitap” ve “book”. Dediğimiz gibi, sözlükler de tıpkı listeler gibi, farklı veri tiplerinin bir araya gelmesi ile oluşan birleşik/kapsayıcı bir veri tipidir. Dolayısıyla bir sözlük içinde sadece karakter dizilerini değil, başka veri tiplerini de görebilirsiniz. İlerleyen sayfalarda sözlüklere ilişkin daha karmaşık örnekler verdiğimizde sözlüklerin hangi veri tipleriniiçerebileceğinidegöreceğiz. Nededik?Sözlükiçindeikinoktaüstüsteişaretininsolundavesağında“kitap”ve“book”adlı karakter dizileri var. Teknik olarak, iki nokta üst üste işaretinin solundaki karakter dizisine ‘anahtar’ (key), sağındaki karakter dizisine ise ‘değer’ (value) adı verilir. Bu bilgilere bakarak sözlükiçinşöylebirtanımverebiliriz: 542 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 Sözlükler; anahtar ve değer çiftlerinin birbirleriyle eşleştirildiği bir veri tipidir. Dolayısıylasözlüklerbuanahtarvedeğerçiftleriarasındabirebirilişkikurar. Mesela yukarıdaki örnekte “kitap” öğesi anahtar, “book” öğesi ise değerdir. İşte sözlük dediğimizşey,buanahtarvedeğerçiftiarasındabirebirilişkikuranbirveritipidir.Yanisözlük adlıveritipi,biranahtarıbirdeğerleeşleştirmegörevigörür. Sözlüklerinbuözelliğini,sözlüköğelerineerişirkengayetnetbirşekildegörebiliyoruz. Yukarıdaki örneklerde tanımladığımız sözlüklerde sadece karakter dizilerini kullandık. Ama aslındasözlüklerfarklıveritiplerindenoluşabilir.Mesela: sözlük = {"sıfır": 0, "bir" : 1, "iki" : 2, "üç" : 3, "dört" : 4, "beş" : 5} Burada sözlük içinde hem sayıları hem de karakter dizilerini kullandık. Aynı şekilde sözlük içindelisteleredeyerverebiliriz: sözlük = {"Ahmet Özkoparan": ["İstanbul", "Öğretmen", 34], "Mehmet Yağız" : ["Adana", "Mühendis", 40], "Seda Bayrak" : ["İskenderun", "Doktor", 30]} Mesela bu sözlükte “Seda Bayrak” adlı kişinin bilgilerine ulaşmak istersek şöyle bir kod yazabiliriz: print(sözlük["Seda Bayrak"]) Bukodbizeşöylebirçıktıverecektir: [’İskenderun’, ’Doktor’, 30] Gördüğünüz gibi, sözlük içinde “Seda Bayrak” adlı öğenin karşısındaki bilgi listesine ulaşabildik. İsterseksözlükleri,içlerindebaşkasözlükleribarındıracakşekildedetanımlayabiliriz: kişiler = {"Ahmet Özkoparan": {"Memleket": "İstanbul", "Meslek" : "Öğretmen", "Yaş" : 34}, "Mehmet Yağız" : {"Memleket": "Adana", "Meslek" : "Mühendis", "Yaş" : 40}, "Seda Bayrak" : {"Memleket": "İskenderun", "Meslek" : "Doktor", "Yaş" : 30}} Böyleceşöylekodlaryazabiliriz: 32.3. SözlüklerinYapısı 543 PythonBelgeleri,Yayım4.1.3 print(kişiler["Mehmet Yağız"]["Memleket"]) print(kişiler["Seda Bayrak"]["Yaş"]) print(kişiler["Ahmet Özkoparan"]["Meslek"]) Yukarıdakiyapınınbenzerinilistelerkonusundanhatırlıyorolmalısınız.İçiçegeçmişlistelerin öğelerineulaşırkendebunabenzerbirsözdizimindenyararlanıyorduk.Örneğin: liste = [["Ahmet", "Mehmet", "Ayşe"], ["Sedat", "Serkan", "Selin"], ["Zeynep", "Nur", "Eda"]] Buradabirlisteiçindeiçiçegeçmişüçfarklılisteilekarşıkarşıyayız.Meselailklisteninilköğesi olan“Ahmet”adlıöğeyeerişmekistersekşöylebirkodyazmamızgerekiyor: print(liste[0][0]) İşte iç içe geçmiş sözlüklerin öğelerine ulaşmak için de buna benzer bir kod yazmamız gerekiyor. Örneğin kişiler adlı sözlükteki “Mehmet Yağız” adlı kişinin yaşına ulaşmak istersek şöylebirşeyyazacağız: print(kişiler["Mehmet Yağız"]["Yaş"]) Gelin isterseniz kişiler adlı sözlüğü kullanarak basit bir irtibat listesi uygulaması yazalım. Böylecesözlüklereelimizialıştırmışoluruz: kişiler = {"Ahmet Özkoparan": {"Memleket": "İstanbul", "Meslek" : "Öğretmen", "Yaş" : 34}, "Mehmet Yağız" : {"Memleket": "Adana", "Meslek" : "Mühendis", "Yaş" : 40}, "Seda Bayrak" : {"Memleket": "İskenderun", "Meslek" : "Doktor", "Yaş" : 30}} isim = "Hakkında ayrıntılı bilgi edinmek \ istediğiniz kişinin adını girin: " arama = input(isim) ayrıntı = input("Memleket/Meslek/Yaş? ") print(kişiler[arama][ayrıntı]) Tıpkıbiröncekitelefondefteriuygulamamızgibi,buirtibatlistesiuygulamasıdageliştirilmeye açıktır. Ancak henüz bu iki uygulamayı geliştirmemizi sağlayacak bilgilerden yoksunuz. Bu uygulamaları istediğimiz kıvama sokabilmek için sözlüklere dair öğrenmemiz gereken başka şeylerdevar. Sözlüklerinötekiveritiplerindenönemlibirfarkı,sözlükiçindeyeralanöğelerinherhangibir 544 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 sıralamamantığınasahipolmamasıdır.Yanisözlüktekiöğeleraçısından‘sıra’diyebirkavram yoktur. (cid:242) Not Python3.7’dan başlayarak sözlükler içerdikleri öğelerin eklenme sırasını korumaktadır. Python’un 3.7’den yüksek bir versiyonunda oluşturduğunuz sözlükleri ekrana yazdırmayı denerseniz sözlüğü oluştururken elemanların içinde bulunduğu sıranın korunduğunu siz degörebilirsiniz.Ancaksözlüklerinelemanlarınalistelergibibirsıraile(liste[sıra]gibi) erişilemez.Ayrıntılıbilgiiçinburaya29 bakabilirsiniz. Örneğin bir liste, demet veya karakter dizisi içindeki öğelere; bu öğelerin o liste, demet veya karakterdizisiiçindekisıralarınagöreerişebilirsiniz: >>> liste = ["Ahmet", "Mehmet", "Zeynep"] >>> liste[0] ’Ahmet’ >>> liste[-1] ’Zeynep’ Ancaksözlükleraçısındanböylebirşeysözkonusudeğildir: >>> sözlük = {’elma’: ’apple’, ... ’armut’: ’pear’, ... ’çilek’: ’strawberry’} >>> sözlük[0] Traceback (most recent call last): File "<stdin>", line 1, in <module> KeyError: 0 Gördüğünüzgibi,sözlüklerüzerindesıralamayadayalıbirsorgulamayapmayaçalıştığımızda Pythonbizebirhatamesajıgösteriyor. Budurumunetkilerinişuradadagörebilirsiniz: Dikkatlicebakın: >>> sözlük = {’a’: ’0’, ’b’: ’1’, ’c’: ’2’} >>> sözlük {’a’: ’0’, ’c’: ’2’, ’b’: ’1’} (cid:242) Not Yukarıdadadediğimizgibi,Python3.7+versiyonlarındaburadakiörneğinaksineelemanlar 29https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6 32.3. SözlüklerinYapısı 545 PythonBelgeleri,Yayım4.1.3 herzamanonlarısözlüğeeklediğinizsıradaekranayazılacaktır. Bu çıktıyı iyi inceleyin. Göreceğiniz gibi, çıktıda görünen öğeler bizim sözlüğü tanımladığımız sıradaki gibi değil. Biz sözlüğü ‘a’, ‘b’ ve ‘c’ şeklinde sıralayarak tanımladık, ama çıktı ‘a’, ‘c’ ve ‘b’ şeklinde oldu. O yüzden sözlükler üzerinde çalışırken öğelerin sırasına dayalı herhangi bir işlem yapmak hiç mantıklı değildir. Çünkü sözlükteki öğeleri tanımlarken kullandığınız sıralamadüzenininçıktıdadaaynenkorunacağınınherhangibirgarantisibulunmaz. 32.4 Sözlüklere Öğe Eklemek Tıpkı listeler gibi, sözlükler de büyüyüp küçülebilen bir veri tipidir. Yani bir sözlüğü ilk kez tanımladıktansonraistediğimizzamanbusözlüğeyeniöğelerekleyebilirveyavarolanöğeleri çıkarabiliriz.Bizşimdibirsözlüğenasılöğeekleyeceğimiziinceleyeceğiz. Diyelimkielimizdeşöyleboşbirsözlükvar: >>> sözlük = {} Bulisteyeöğeeklemekiçinşöylebirformülkullanacağız: >>> sözlük[anahtar] = değer Buformülübirörneküzerindensomutlaştıralım: >>> sözlük["Ahmet"] = "Adana" Böylece sözlüğe, anahtarı “Ahmet”, değeri ise “Adana” olan bir öğe eklemiş olduk. Sözlüğümüzünsondurumunukontroledelim: >>> print(sözlük) {’Ahmet’: ’Adana’} Gördüğünüzgibi,“Ahmet”öğesisözlüğeeklendi.Artıkbuöğeyenormalyollardanulaşabiliriz: >>> print(sözlük["Ahmet"]) Adana Elimizalışsındiyesözlüğeöğeeklemeyedevamedelim: >>> sözlük["Mehmet"] = "İstanbul" >>> sözlük {’Ahmet’: ’Adana’, ’Mehmet’: ’İstanbul’} >>> sözlük["Seda"] = "Mersin" >>> sözlük {’Ahmet’: ’Adana’, ’Mehmet’: ’İstanbul’, ’Seda’: ’Mersin’} (sonrakisayfayadevam) 546 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> sözlük["Eda"] = "Tarsus" >>> sözlük {’Ahmet’: ’Adana’, ’Eda’: ’Tarsus’, ’Mehmet’: ’İstanbul’, ’Seda’: ’Mersin’} Özellikle son çıktıya dikkatlice bakın. Sözlüğe en son “Eda” öğesini eklemiştik. Ama sözlüğü ekranabastığımızdabuöğeninsözlüğünsonunadeğilortasınabiryereyerleştiğinigörüyoruz. Budurumun,sözlüklerinsırasızbirveritipiolmasındankaynaklandığınıbiliyorsunuz. Gelinpratikolmasıaçısındanbirkaçörnekdahaverelim. Elimizdeşöylebirsözlükolsun: >>> personel = {"Mehmet Öz": "AR-GE Müdürü", ... "Samet Söz": "Genel Direktör", ... "Sedat Gün": "Proje Müdürü"} Şimdibusözlüğe"Turgut Özben": "Mühendis"anahtar-değerçiftiniekleyelim: >>> personel["Turgut Özben"] = "Mühendis" Sözlüğümüzünsonhalinigörelim: >>> print(personel) {’Samet Söz’: ’Genel Direktör’, ’Mehmet Öz’: ’AR-GE Müdürü’, ’Turgut Özben’: ’Mühendis’, ’Sedat Gün’: ’Proje Müdürü’} Gördüğünüz gibi eklemek istediğimiz öğe sözlüğe eklenmiş. Ancak bu öğenin sözlüğün en sonuna değil, sözlük içine rastgele bir şekilde yerleştirildiğine dikkatinizi çekmek isterim. Çünkü,dediğimizgibi,sözlüklersırasızbirveritipidir. Gelinbukonuyudahaiyianlamakiçinbirörnekdahaverelim. Öncenotlaradındaboşbirsözlüktanımlayalım: >>> notlar = {} Busözlüğeöğrencilerinsınavdanaldıklarınotlarıekleyeceğiz: >>> notlar["Ahmet"] = 45 >>> notlar["Mehmet"] = 77 >>> notlar["Seda"] = 98 >>> notlar["Deniz"] = 95 >>> notlar["Ege"] = 95 >>> notlar["Zeynep"] = 100 Sözlüğümüzünsonhalinigörelim: >>> print(notlar) {’Seda’: 98, ’Ege’: 95, ’Mehmet’: 77, ’Zeynep’: 100, ’Deniz’: 95, ’Ahmet’: 45} 32.4. SözlüklereÖğeEklemek 547 PythonBelgeleri,Yayım4.1.3 Bunoktadasözlüklerinönemlibirözelliğindenbahsetmemizuygunolacak.Birsözlüğedeğer olarakbütünveritipleriniverebiliriz.Yani: >>> sözlük = {} >>> sözlük = {’a’: 1} >>> sözlük = {’a’: (1,2,3)} >>> sözlük = {’a’: ’kardiz’} >>> sözlük = {’a’: [1,2,3]} Gördüğünüzgibi,sözlüklerdeğerolarakhertürlüveritipinikabulediyor.Amadurumsözlük anahtarlarıaçısındanböyledeğildir.Yanisözlüklereanahtarolarakherveritipiniatayamayız. Birdeğerin‘anahtar’olabilmesiiçin,oöğenindeğiştirilemeyen(immutable)birveritipiolması gerekir.Python’daşimdiyekadaröğrendiğimizşuveritiplerideğiştirilemeyenveritipleridir: 1. Demetler 2. Sayılar 3. KarakterDizileri Şuveritipleriisedeğiştirilebilenveritipleridir: 1. Listeler 2. Sözlükler Dolayısıylabirsözlüğeanahtarolarakancakşuveritipleriniekleyebiliriz: 1. Demetler 2. Sayılar 3. KarakterDizileri Şukodlarıdikkatliceinceleyin: Önceboşbirsözlükoluşturalım: >>> sözlük = {} Busözlüğeanahtarolarakbirdemetekleyelim: >>> l = (1,2,3) >>> sözlük[l] = ’falanca’ >>> sözlük {(1, 2, 3): ’falanca’} Birsayıekleyelim: >>> l = 45 >>> sözlük[l] = ’falanca’ >>> sözlük {45: ’falanca’, (1, 2, 3): ’falanca’} Birkarakterdizisiekleyelim: 548 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 >>> l = ’kardiz’ >>> sözlük[l] = ’falanca’ >>> sözlük {’kardiz’: ’falanca’, 45: ’falanca’, (1, 2, 3): ’falanca’} Yukarıdakiler,değiştirilemeyenveritipleriolduğuiçinsözlüklereanahtarolarakeklenebildi. Birdeşunlarabakalım: Sözlüğümüzeanahtarolarakbirlisteeklemeyeçalışalım: >>> l = [1,2,3] >>> sözlük[l] = ’falanca’ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: ’list’ Sözlüğümüzebirsözlükeklemeyeçalışalım: >>> l = {"a": 1, "b": 2, "c": 3} >>> sözlük[l] = ’falanca’ Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: ’dict’ Sözlüklerleçalışırkensözlüklerinbuözelliğinekarşıuyanıkolmalıyız. 32.5 Sözlük Öğeleri Üzerinde Değişiklik Yapmak Sözlükler değiştirilebilir veri tipleridir. Dolayısıyla sözlükler üzerinde rahatlıkla istediğimiz değişikliğiyapabiliriz. Sözlükler üzerinde değişiklik yapma işlemi, biraz önce öğrendiğimiz, sözlüklere yeni öğe eklemeişlemiyleaynıdır.Dikkatlicebakın: >>> notlar = {’Seda’: 98, ’Ege’: 95, ’Mehmet’: 77, ... ’Zeynep’: 100, ’Deniz’: 95, ’Ahmet’: 45} Sözlüğümüzbu.Şimdibusözlükteki‘Ahmet’adlıkişinin45olannotunu65olarakdeğiştirelim: >>> notlar["Ahmet"] = 65 >>> print(notlar) {’Seda’: 98, ’Ege’: 95, ’Mehmet’: 77, ’Zeynep’: 100, ’Deniz’: 95, ’Ahmet’: 65} GördüğünüzgibiAhmet’innotu65olarakdeğişmiş... 32.5. SözlükÖğeleriÜzerindeDeğişiklikYapmak 549 PythonBelgeleri,Yayım4.1.3 32.6 Sözlük Üreteçleri (Dictionary Comprehensions) Hatırlarsanız listeleri anlatırken liste üreteçleri adı bir kavramdan söz etmiştik. Liste üreteçlerini kullanarak tek satırda ve hızlı bir şekilde listeler oluşturabiliyorduk. Aynı şey sözlükler için de geçerlidir. Tıpkı liste üreteçlerinde olduğu gibi, sözlük üreteçleri sayesinde teksatırdavehızlıbirşekildesözlüklerüretebiliriz. Örneğin elimizde, Türkçe alfabedeki harfleri içeren harfler adlı şöyle bir karakter dizisi olduğunudüşünün: >>> harfler = ’abcçdefgğhıijklmnoöprsştuüvyz’ Amacımız bu harflerin her birine bir numara vermek. Yani nihai olarak şöyle bir sözlük elde etmekistiyoruz: {’ğ’: 8, ’v’: 26, ’ş’: 22, ’u’: 24, ’t’: 23, ’ö’: 18, ’ı’: 10, ’p’: 19, ’s’: 21, ’r’: 20, ’ü’: 25, ’y’: 27, ’ç’: 3, ’z’: 28, ’e’: 5, ’d’: 4, ’g’: 7, ’f’: 6, ’a’: 0, ’c’: 2, ’b’: 1, ’m’: 15, ’l’: 14, ’o’: 17, ’n’: 16, ’i’: 11, ’h’: 9, ’k’: 13, ’j’: 12} Bununiçinbirkaçfarklıyöntemdenyararlanabiliriz.Örneğin: >>> sözlük = {} >>> for i in harfler: ... sözlük[i] = harfler.index(i) veya: 550 Bölüm32. Sözlükler PythonBelgeleri,Yayım4.1.3 >>> sözlük = {} >>> for i in range(len(harfler)): ... sözlük[harfler[i]] = i İştebuişlemlerisözlüküreteçlerinikullanarakçokdahahızlıvepratikbirşekildehalledebiliriz. Dikkatlicebakın: >>> sözlük = {i: harfler.index(i) for i in harfler} Birörnekdahaverelim.Diyelimkielinizdeşöylebirisimlistesivar: isimler = ["ahmet", "mehmet", "fırat", "zeynep", "selma", "abdullah", "cem"] Amacınız,buisimleriveherbirisminkaçharftenoluştuğunugösterenbirsözlükeldeetmek. Yaninihaiolarakşöylebirşeyolsunistiyorsunuzelinizde: {’zeynep’: 6, ’cem’: 3, ’abdullah’: 8, ’ahmet’: 5, ’mehmet’: 6, ’fırat’: 5, ’selma’: 5} İştebugöreviçindesözlüküreteçlerindenyararlanabilirsiniz: >>> isimler = ["ahmet", "mehmet", "fırat", "zeynep", "selma", "abdullah", "cem"] >>> sözlük = {i: len(i) for i in isimler} >>> sözlük {’zeynep’: 6, ’cem’: 3, ’abdullah’: 8, ’ahmet’: 5, ’mehmet’: 6, ’fırat’: 5, ’selma’: 5} ˓→ Bildiğiniz gibi sözlükler, her biri birbirinden: işareti ile ayrılan birtakım anahtar-değer çiftlerinden oluşuyor. İşte yukarıdaki sözlük üreteci yapısında biz: işaretinin sol tarafına isimler adlı listedeki her bir öğeyi; sağ tarafına da bu öğelerin uzunluklarını bir çırpıda ekliyoruz. 32.6. SözlükÜreteçleri(DictionaryComprehensions) 551 33 BÖLÜM Sözlüklerin Metotları Tıpkıötekiveritiplerindeolduğugibi,sözlüklerindebirtakımmetotlarıbulunur.Bubölümde sözlüklerinşumetotlarınıinceleyeceğiz: 1. keys() 2. values() 3. items() 4. get() 5. clear() 6. copy() 7. fromkeys() 8. pop() 9. popitem() 10. setdefault() 11. update() İlkolarakkeys()metoduylabaşlayalım. 33.1 keys() Sözlükleri tarif ederken, sözlüklerin anahtar-değer çiftlerinden oluşan bir veri tipi olduğunu söylemiştik. Bir sözlüğü normal yollardan ekrana yazdırırsanız size hem anahtarları hem de bunlarakarşılıkgelendeğerleriverecektir.Amaeğerbirsözlüğünsadeceanahtarlarınıalmak istersenizkeys()metodundanyararlanabilirsiniz: 552 PythonBelgeleri,Yayım4.1.3 >>> sözlük = {"a": 0, ... "b": 1, ... "c": 2, ... "d": 3} >>> print(sözlük.keys()) dict_keys([’b’, ’c’, ’a’, ’d’]) Gördüğünüz gibi, sözlük.keys() komutu bize bir dict_keys nesnesi veriyor. Bu nesneyi programınızda kullanabilmek için isterseniz, bunu listeye, demete veya karakter dizisine dönüştürebilirsiniz: >>> liste = list(sözlük.keys()) >>> liste [’b’, ’c’, ’a’, ’d’] >>> demet = tuple(sözlük.keys()) >>> demet (’b’, ’c’, ’a’, ’d’) >>> kardiz = "".join(sözlük.keys()) >>> kardiz ’bcad’ Son örnekte sözlük anahtarlarını karakter dizisine dönüştürmek için str() fonksiyonunu değil, karakter dizilerinin join() adlı metodunu kullandığımıza dikkat edin. Çünkü tuple() ve list() fonksiyonlarının aksine str() fonksiyonu, sözlükteki anahtarların nasıl bir ölçüte göre karakter dizisine çevrileceğine dair bir kural içermez. Zira siz bu sözlük anahtarlarını pek çok farklı şekilde karakter dizisine çevirebilirsiniz. Örneğin öğeleri karakter dizisi içine yerleştirirkenöğelerinarasınavirgülkoymakisteyebilirsiniz: >>> kardiz = ’, ’.join(sözlük.keys()) >>> kardiz ’b, c, a, d’ Eğer sözlük anahtarlarını str() fonksiyonu yardımıyla karakter dizisine dönüştürmeye kalkışırsanızbeklemediğinizbirçıktıalırsınız. 33.1. keys() 553 PythonBelgeleri,Yayım4.1.3 33.2 values() keys() metodu bir sözlüğün anahtarlarını veriyor. Bir sözlüğün değerlerini ise values() metoduverir: >>> sözlük {’b’: 1, ’c’: 2, ’a’: 0, ’d’: 3} >>> print(sözlük.values()) dict_values([1, 2, 0, 3]) Gördüğünüz gibi, bu metottan bir dict_values nesnesi alıyoruz. Tıpkı keys() metodunda olduğu gibi, values() metodunda da bu çıktıyı başka veri tiplerine dönüştürme imkanına sahibiz: >>> liste = list(sözlük.values()) >>> liste [1, 2, 0, 3] >>> demet = tuple(sözlük.values()) >>> demet (1, 2, 0, 3) Yalnız bu verileri karakter dizisine dönüştürmeye çalıştığınızda ufak bir problemle karşılaşacaksınız: >>> kardiz = "".join(sözlük.values()) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: sequence item 0: expected str instance, int found Bunun sebebi, sözlükteki değerlerin int tipinde olmasıdır. Bildiğiniz gibi, sadece aynı tip verileri birbiriyle birleştirebiliriz. Eğer birleştirmek istediğimiz veriler birbirinden farklı tipte ise,bunlarıbirleştirmedenöncebirdönüştürmeişlemiyapmamızgerekir: >>> kardiz = "".join([str(i) for i in sözlük.values()]) >>> kardiz ’1203’ Gördüğünüz gibi, sözlükteki değerlerin her birini, tek bir liste üreteci içinde karakter dizisine dönüştürdük ve ortaya çıkan listeyi karakter dizilerinin join() metodu yardımıyla, öğelerin arasındahiçbirboşlukbırakmadankardizadlıbirkarakterdizisiiçineyerleştirdik.Elbetteeğer isteseydikbuöğelerinherbirininarasınabirvirgüldekoyabilirdik: >>> kardiz = ", ".join([str(i) for i in sözlük.values()]) >>> kardiz (sonrakisayfayadevam) 554 Bölüm33. SözlüklerinMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’1, 2, 0, 3’ 33.3 items() Bumetot,birsözlüğünhemanahtarlarınıhemdedeğerleriniaynıandaalmamızısağlar: >>> sözlük.items() dict_items([(’a’, 0), (’c’, 2), (’b’, 1)]) Gördüğünüz gibi, tek bir liste içinde iki öğeli demetler halinde hem anahtarları hem de değerleri görebiliyoruz. Bu metot sıklıkla for döngüleri ile birlikte kullanılarak bir sözlüğün anahtarvedeğerlerininmanipüleedilebilmesinisağlar: >>> for anahtar, değer in sözlük.items(): ... print("{} = {}".format(anahtar, değer)) ... a = 0 c = 2 b = 1 33.4 get() Bumetotsözlüklerinenkullanışlımetotlarındanbiridir.Bumetotpekçokdurumdaişinizibir haylikolaylaştırır. Diyelimkişöylebirprogramyazdık: #!/usr/bin/env python3.0 ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"} sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:") print(ing_sözlük[sorgu]) Bu programı çalıştırdığımızda eğer kullanıcı “ing_sözlük” adıyla belirttiğimiz sözlük içinde bulunan kelimelerden birini yazarsa, o kelimenin karşılığını alacaktır. Diyelim ki kullanıcımız soruya “dil” diye cevap verdi. Bu durumda ekrana “dil” kelimesinin sözlükteki karşılığı olan “language” yazdırılacaktır. Peki ya kullanıcı sözlükte tanımlı olmayan bir kelime yazarsa ne olacak? Öyle bir durumda programımız hata verecektir. Programımız için doğru yol, hatavermektense,kullanıcıyıkelimeninsözlükteolmadığıkonusundabilgilendirmektir.Bunu klasikbiryaklaşımlaşuşekildeyapabiliriz: ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"} (sonrakisayfayadevam) 33.3. items() 555 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:") if sorgu not in ing_sözlük: print("Bu kelime veritabanımızda yoktur!") else: print(ing_sözlük[sorgu]) Amaaçıkçasıbupekverimlibiryaklaşımsayılmaz.Yukarıdakiyöntemyerinesözlükleringet() metodundanfaydalanabiliriz.Bakalımbununasılyapıyoruz: ing_sözlük = {"dil": "language", "bilgisayar": "computer", "masa": "table"} sorgu = input("Lütfen anlamını öğrenmek istediğiniz kelimeyi yazınız:") print(ing_sözlük.get(sorgu, "Bu kelime veritabanımızda yoktur!")) Gördüğünüz gibi, burada çok basit bir metot yardımıyla bütün dertlerimizi hallettik. Sözlüklerin get() adlı metodu, parantez içinde iki adet argüman alır. Birinci argüman sorgulamak istediğimiz sözlük öğesidir. İkinci argüman ise bu öğenin sözlükte bulunmadığı durumdakullanıcıyahangimesajıngösterileceğinibelirtir.Bunagöre,yukarıdayaptığımızşey, önce“sorgu”değişkeninisözlüktearamak,eğerbuöğesözlüktebulunamıyorsadakullanıcıya, “Bukelimeveritabanımızdayoktur!”cümlesinigöstermektenibarettir... Gelinistersenizbununlailgilibirörnekdahayapalım. Diyelim ki bir havadurumu programı yazmak istiyoruz. Bu programda kullanıcı bir şehir adı girecek. Program da girilen şehre ait havadurumu bilgilerini ekrana yazdıracak. Bu programı klasikyöntemleşuşekildeyazabiliriz: #!/usr/bin/env python3 soru = input("Şehrinizin adını tamamı küçük harf olacak şekilde yazın:") if soru == "istanbul": print("gök gürültülü ve sağanak yağışlı") elif soru == "ankara": print("açık ve güneşli") elif soru == "izmir": print("bulutlu") else: print("Bu şehre ilişkin havadurumu bilgisi bulunmamaktadır.") Yukarıdaki, gayet geçerli bir yöntemdir. Ama biz istersek bu kodları “get” metodu yardımıyla çokdahaverimlivesadebirhalegetirebiliriz: #!/usr/bin/env python3 (sonrakisayfayadevam) 556 Bölüm33. SözlüklerinMetotları PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) soru = input("Şehrinizin adını tamamı küçük harf olacak şekilde yazın:") cevap = {"istanbul": "gök gürültülü ve sağanak yağışlı", "ankara": "açık ve güneşli", "izmir": "bulutlu"} print(cevap.get(soru, "Bu şehre ilişkin havadurumu bilgisi bulunmamaktadır.")) 33.5 clear() Bu kelime İngilizce’de “temizlemek” anlamına gelir. Görevi sözlükteki öğeleri temizlemektir. Yaniiçidolubirsözlüğübumetotyardımıylatamamenboşaltabiliriz: >>> lig = {"şampiyon": "Adana Demirspor", "ikinci": "Mersin İdman Yurdu", ... "üçüncü": "Adana Gençlerbirliği"} İstersenizsözlüğümüzüboşaltmadanöncebusözlüklebirazçalışalım: Sözlüğümüzünöğelerineşöyleulaşıyoruz: >>> lig {’şampiyon’: ’Adana Demirspor’, ’ikinci’: ’Mersin İdman Yurdu’, ’üçüncü’: ’Adana Gençlerbirliği’} Eğerbusözlüğünöğelerinetektekerişmekistersekşöyleyapıyoruz: >>> lig["şampiyon"] ’Adana Demirspor’ >>> lig["üçüncü"] ’Adana Gençlerbirliği’ Şimdigeldibusözlüğünbütünöğelerinisilmeye: >>> lig.clear() Şimdisözlüğümüzündurumunutekrarkontroledelim: >>> lig {} Gördüğünüz gibi artık “lig” adlı sözlüğümüz bomboş. clear() metodunu kullanarak bu sözlüğün bütün öğelerini sildik. Ama tabii ki bu şekilde sözlüğü silmiş olmadık. Boş da olsa bellektehâlâ“lig”adlıbirsözlükduruyor.Eğersiz“lig”iortadankaldırmakisterseniz“del”adlı birparçacıktanyararlanmanızgerekir: 33.5. clear() 557 PythonBelgeleri,Yayım4.1.3 >>> del lig Kontroledelim: >>> lig NameError: name ’lig’ is not defined Gördüğünüzgibiartık“lig”diyebirşeyyok... Busözlüğübellektentamamenkaldırdık. clear()adlımetodunneolduğunuveneişeyaradığınıgördüğümüzegörebaşkabirmetoda geçebiliriz. 33.6 copy() Diyelimkielimizdeşöylebirsözlükvar: >>> hava_durumu = {"İstanbul": "yağmurlu", "Adana": "güneşli", ... "İzmir": "bulutlu"} ˓→ Bizbusözlüğükopyalamakistiyoruz.Hemenşöylebirşeydeneyelim: >>> yedek_hava_durumu = hava_durumu Artıkelimizdeaynısözlüktenikitanevar: >>> hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’İzmir’: ’bulutlu’} >>> yedek_hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’İzmir’: ’bulutlu’} Şimdihava_durumuadlısözlüğebiröğeekleyelim: >>> hava_durumu["Mersin"] = "sisli" >>> hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’Mersin’: ’sisli’, ’İzmir’: ’bulutlu’} ˓→ Şimdibirdeyedek_hava_durumuadlısözlüğündurumunabakalım: >>> yedek_hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’Mersin’: ’sisli’, ’İzmir’: ’bulutlu’} ˓→ 558 Bölüm33. SözlüklerinMetotları PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, hava_durumu adlı sözlüğe yaptığımız ekleme yedek_hava_durumu adlı sözlüğü de etkiledi. Hatırlarsanız buna benzer bir durumla daha önce listeleri anlatırken de karşılaşmıştık.Çünküvarolanbirsözlüğüveyalisteyibaşkabirdeğişkeneatadığımızdaaslında yaptığımız şey bir kopyalama işleminden ziyade bellekteki aynı nesneye gönderme yapan iki farklıisimbelirlemektenibaret.Yanisözlüğümüzübellektekibirnesneolarakdüşünürsek,bu nesneyeatıftabulunan,“hava_durumu”ve“yedek_hava_durumu”adlıikifarklıisimbelirlemiş oluyoruz. Eğer istediğimiz şey bellekteki nesneden iki adet oluşturmak ve bu iki farklı nesneyiikifarklıisimleadlandırmakiseyukarıdakiyöntemikullanmakistemediğinizsonuçlar doğurabilir. Yani amacınız bir sözlüğü yedekleyip orijinal sözlüğü korumaksa ve yukarıdaki yöntemikullandıysanız,hiçfarkındaolmadanorijinalsözlüğüdedeğiştirebilirsiniz.İşteböyle durumlardaimdadımızasözlüklerin“copy”metoduyetişecek.Bumetodukullanarakvarolan birsözlüğügerçekanlamdakopyalayabilir,yaniyedekleyebiliriz... >>> hava_durumu = {"İstanbul": "yağmurlu", "Adana": "güneşli", ... "İzmir": "bulutlu"} ˓→ Şimdibusözlüğüyedekliyoruz.Yanikopyalıyoruz: >>> yedek_hava_durumu = hava_durumu.copy() Bakalım hava_durumu adlı sözlüğe ekleme yapınca yedek_hava_durumu adlı sözlüğün durumuneoluyor? >>> hava_durumu["Mersin"] = "sisli" >>> hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’Mersin’: ’sisli’, ’İzmir’: ’bulutlu’} yedek_hava_durumuadlısözlüğebakalım: >>> yedek_hava_durumu {’İstanbul’: ’yağmurlu’, ’Adana’: ’güneşli’, ’İzmir’: ’bulutlu’} Gördüğünüz gibi bu defa sözlüklerin birinde yapılan değişiklik öbürünü etkilemedi... copy metodusağolsun!... 33.7 fromkeys() fromkeys() metodu öteki metotlardan biraz farklıdır. Bu metot mevcut sözlük üzerinde işlem yapmaz. fromkeys()’in görevi yeni bir sözlük oluşturmaktır. Bu metot yeni bir sözlük oluştururkenlistelerveyademetlerdenyararlanır.Şöyleki: >>> elemanlar = "Ahmet", "Mehmet", "Can" >>> adresler = dict.fromkeys(elemanlar, "Kadıköy") >>> adresler (sonrakisayfayadevam) 33.7. fromkeys() 559 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) {’Ahmet’: ’Kadıköy’, ’Mehmet’: ’Kadıköy’, ’Can’: ’Kadıköy’} Gördüğünüz gibi öncelikle “elemanlar” adlı bir demet tanımladık. Daha sonra da “adresler” adlı bir sözlük tanımlayarak, fromkeys() metodu yardımıyla anahtar olarak “elemanlar” demetindeki öğelerden oluşan, değer olarak ise “Kadıköy”ü içeren bir sözlük meydana getirdik. En başta tanımladığımız “elemanlar” demeti liste de olabilirdi. Hatta tek başına bir karakter dizisidahiyazabilirdikoraya... 33.8 pop() Bumetodulistelerdenhatırlıyoruz.Bumetotlistelerlebirliktekullanıldığında,listeninenson öğesini silip, silinen öğeyi de ekrana basıyordu. Eğer bu metodu bir sıra numarası ile birlikte kullanırsak, listede o sıra numarasına karşılık gelen öğe siliniyor ve silinen bu öğe ekrana basılıyordu. Bu metodun sözlüklerdeki kullanımı da az çok buna benzer. Ama burada farklı olarak,popmetodunuargümansızbirşekildekullanamıyoruz.Yanipopmetodununparantezi içindemutlakabirsözlüköğesibelirtmeliyiz: >>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye"), ... "içecekler": ("su", "kola", "ayran")} >>> sepet.pop("meyveler") Bu komut, sözlükteki “meyveler” anahtarını silecek ve sildiği bu öğenin değerini ekrana basacaktır. Eğer silmeye çalıştığımız anahtar sözlükte yoksa Python bize bir hata mesajı gösterecektir: >>> sepet.pop("tatlılar") KeyError: ’tatlılar’ Bir program yazarken böyle bir durumla karşılaşmak istemeyiz çoğu zaman. Yani bir sözlük içindearamayaparken,arananöğeninsözlüktebulunmadığıbirdurumdakullanıcıyamekanik ve anlamsız bir hata göstermek yerine, daha anlaşılır bir mesaj iletmeyi tercih edebiliriz. Hatırlarsanız sözlüklerin get() metodunu kullanarak benzer bir şey yapabiliyorduk. Şu anda incelemekteolduğumuzpop()metodudabizeböylebirimkanverir.Bakalım: >>> sepet.pop("tatlılar", "Silinecek öğe yok!") Böylelikle sözlükte bulunmayan bir öğeyi silmeye çalıştığımızda Python bize bir hata mesajı göstermekyerine,“Silineceköğeyok!”şeklindedahaanlamlıbirmesajverecektir... 560 Bölüm33. SözlüklerinMetotları PythonBelgeleri,Yayım4.1.3 33.9 popitem() popitem() metodu da bir önceki bölümde öğrendiğimiz pop() metoduna benzer. Bu iki metodungörevlerihemenhemenaynıdır.Ancakpop()metoduparanteziçindebirparametre alırken,popitem()metodununparanteziboş,yaniparametresizolarakkullanılır.Bumetotbir sözlükten son eklenen öğeyi silmek için kullanılır(Python 3.7’den önceki sürümlerde bunun yerinerastgelebiröğekaldırılır)... >>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye")} >>> sepet.popitem() EğersözlükboşsabumetotbizeKeyErrorhatamesajıgösterir. 33.10 setdefault() Bumetotepeyenteresan,amabirokadardayararlıbiraraçtır... Bumetodunneişeyaradığını doğrudanbirörneküzerindegörelim: >>> sepet = {"meyveler": ("elma", "armut"), "sebzeler": ("pırasa", "fasulye")} >>> sepet.setdefault("içecekler", ("su", "kola")) Bukomutyardımıylasözlüğümüziçinde“içecekler”adlıbiranahtaroluşturduk.Buanahtarın değeriise(“su”,“kola”)oldu... Birdeşunabakalım: >>> sepet.setdefault("meyveler", ("erik", "çilek")) (’elma’, ’armut’) Gördüğünüz gibi, sözlükte zaten “meyveler” adlı bir anahtar bulunduğu için, Python aynı adı taşıyan ama değerleri farklı olan yeni bir “meyveler” anahtarı oluşturmadı. Demek ki bu metot yardımıyla bir sözlük içinde arama yapabiliyor, eğer aradığımız anahtar sözlükte yoksa,setdefault()metoduiçindebelirttiğimizözellikleritaşıyanyenibiranahtar-değerçifti oluşturabiliyoruz. 33.11 update() İnceleyeceğimiz son metot update() metodu... Bu metot yardımıyla oluşturduğumuz sözlükleriyeniverilerlegüncelleyeceğiz.Diyelimkielimizdeşöylebirsözlükvar: >>> stok = {"elma": 5, "armut": 10, "peynir": 6, "sosis": 15} Stoğumuzda5adetelma,10adetarmut,6kutupeynir,15adetdesosisvar.Diyelimkidaha sonrakizamanlardabustoğamalgiriş-çıkışıolduvestoğunsonhalişöyle: >>> yeni_stok = {"elma": 3, "armut": 20, "peynir": 8, "sosis": 4, "sucuk": 6} 33.9. popitem() 561 PythonBelgeleri,Yayım4.1.3 Yapmamız gereken şey, stoğumuzu yeni bilgilere göre güncellemek olacaktır. İşte bu işlemi update()metoduileyapabiliriz: >>> stok.update(yeni_stok) >>> print(stok) {’peynir’: 8, ’elma’: 3, ’sucuk’: 6, ’sosis’: 4, ’armut’: 20} Böyleliklemallarınsonmiktarlarınagörestokbilgilerimizigüncellemişolduk... 562 Bölüm33. SözlüklerinMetotları 34 BÖLÜM Kümeler ve Dondurulmuş Kümeler Bu bölümde Python’daki iki veri tipini daha inceleyeceğiz. İnceleyeceğimiz veri tiplerinin adı kümevedondurulmuşküme. Özellikle kümeleri öğrendiğimizde, bu veri tipinin kendine has birtakım özellikleri sayesinde bunların kimi zaman hiç tahmin bile edemeyeceğimiz yerlerde işimize yaradığını göreceğiz. Normalde uzun uzun kod yazmayı gerektiren durumlarda kümeleri kullanmak, bir-iki satırla işlerimizihalletmemizisağlayabilir. Bu bölümde kümeler dışında, bir de dondurulmuş kümelerden söz edeceğiz. Bu iki veri tipi birbiriyleilişkilidir.Oyüzdenbuikiveritipinitekbölümdeelealacağız. İstersenizanlatmayaöncekümelerlebaşlayalım. 34.1 Kümeler Tıpkı listeler, demetler, karakter dizileri, sayılar ve dosyalar gibi kümeler de Python’daki veri tiplerinden biridir. Adından da az çok tahmin edebileceğiniz gibi kümeler, matematikten bildiğimiz “küme” kavramıyla sıkı sıkıya bağlantılıdır. Bu veri tipi, matematikteki kümelerin sahip olduğu bütün özellikleri taşır. Yani matematikteki kümelerden bildiğimiz kesişim, birleşimvefarkgibiözelliklerPython’dakikümeleriçindegeçerlidir. 34.1.1 Küme Oluşturmak Kümelerinbizesunduklarındanfaydalanabilmekiçinelbetteönceliklebirkümeoluşturmamız gerekiyor. Küme oluşturmak çok kolay bir işlemdir. Örneğin boş bir kümeyi şöyle oluşturuyoruz: >>> boş_küme = set() Listeler, demetler ve sözlüklerin aksine kümelerin ayırt edici bir işareti yoktur. Küme oluşturmakiçinset()adlıözelbirfonksiyondanyararlanıyoruz. 563 PythonBelgeleri,Yayım4.1.3 Yukarıdakiboşveritipininbirkümeolduğununasılteyitedeceğinizibiliyorsunuz: >>> type(boş_küme) <class ’set’> Gördüğünüzgibi,Pythonprogramlamadilindekümelersetifadesiylegösteriliyor. Yukarıda boş bir küme oluşturduk. İçinde öğe de barındıran kümeleri ise şu şekilde oluşturuyoruz: >>> küme = set(["elma", "armut", "kebap"]) Böylelikle, içinde öğe barındıran ilk kümemizi başarıyla oluşturduk. Dikkat ederseniz, küme oluştururkenlistelerdenfaydalandık.Gördüğünüzgibiset()fonksiyonuiçindekiöğelerbirliste içindeyeralıyor.Dolayısıylayukarıdakitanımlamayışöyledeyapabiliriz: >>> liste = ["elma", "armut", "kebap"] >>> küme = set(liste) Bu daha temiz bir görüntü oldu. Elbette küme tanımlamak için mutlaka liste kullanmak zorundadeğiliz.İstersekdemetleridekümehalinegetirebiliriz: >>> demet = ("elma", "armut", "kebap") >>> küme = set(demet) Hattavehattakarakterdizilerindendahikümeyapabiliriz: >>> kardiz = "Python Programlama Dili için Türkçe Kaynak" >>> küme = set(kardiz) Kullandığımız karakter dizisinin böyle uzun olmasına da gerek yok. Tek karakterlik dizilerden bilekümeoluşturabiliriz: >>> kardiz = "a" >>> küme = set(kardiz) Amasayılardankümeoluşturamayız: >>> n = 10 >>> küme = set(n) TypeError: ’int’ object is not iterable Pekisözlüklerikullanarakkümeoluşturabilirmiyiz?Elbette,nedenolmasın? >>> bilgi = {"işletim sistemi": "GNU", "sistem çekirdeği": "Linux", ... "dağıtım": "Ubuntu GNU/Linux"} >>> küme = set(bilgi) Kümeoluşturmanınsonbiryöntemindendahasözedelim.Enbaştasöylediğimizgibi,listeler, demetler, sözlükler ve karakter dizilerinin aksine kümelerin [ ], ( ), { }, ‘ ‘ gibi ayırt edici bir 564 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 işaretiyoktur.Amaeğeristerseksözlüklerioluşturmakiçinkullandığımızözelişaretleriküme oluşturmakiçindekullanabiliriz.Dikkatlicebakın: >>> küme = {’Python’, ’C++’, ’Ruby’, ’PHP’} Gördüğünüz gibi, aslında sözlüklerin ayırt edici işareti olan süslü parantezleri kullanarak ve öğeleri birbirinden virgülle ayırarak da küme adlı veri tipini elde edebiliyoruz. Teyit edelim bunu: >>> type(küme) <class ’set’> Ancakbuyapıyıkullanarakboşbirkümeoluşturamazsınız: >>> küme = {} Buşekildeoluşturduğunuzşeybirkümedeğil,sözlükolacaktır: >>> type(küme) <class ’dict’> Boşbirkümeoluşturmakiçinset()fonksiyonunukullanmanızgerektiğinibiliyorsunuz: >>> küme = set(küme) >>> type(küme) <class ’set’> Böylece kümeleri nasıl oluşturacağımızı öğrendik. Eğer oluşturduğunuz kümeyi ekrana yazdırmak isterseniz, ne yapacağınızı biliyorsunuz. Tanımladığınız küme değişkenini kullanmanızyeterliolacaktır: >>> küme {’işletim sistemi’, ’sistem çekirdeği’, ’dağıtım’} Bu arada, bir sözlüğü kümeye çevirdiğinizde, elbette sözlüğün yalnızca anahtarları kümeye eklenecektir.Sözlüğündeğerleriiseböylebirişleminsonucundaortadankaybolur. Eğer bir sözlüğü kümeye çevirirken hem anahtarları hem de değerleri korumak gibi bir niyetinizvarsaşöylebirşeyyazabilirsiniz: Sözlüğümüzşu: >>> bilgi = {"işletim sistemi": "GNU", "sistem çekirdeği": "Linux", ... "dağıtım": "Ubuntu GNU/Linux"} Busözlüktekianahtar-değerçiftlerinibirkümeiçine,çiftöğelidemetlerolarakyerleştirebiliriz: >>> liste = [(anahtar, değer) for anahtar, değer in bilgi.items()] >>> küme = set(liste) 34.1. Kümeler 565 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, liste üreteçlerini kullanarak önce bir liste oluşturuyoruz. Bu liste her bir anahtarı ve değeri tek tek bir demet içine yerleştiriyor. Daha sonra da bu listeyi set() fonksiyonunagöndererekkümemizioluşturuyoruz. 34.1.2 Kümelerin Yapısı Bir önceki başlık altında kümelerin nasıl tanımlanacağını inceledik. Gelin şimdi de biraz kümelerinyapısındanbahsedelim. Örneğinşöylebirkümetanımlayalım: >>> kardiz = "Python Programlama Dili" >>> küme = set(kardiz) >>> print(küme) {’g’, ’D’, ’a’, ’ ’, ’o’, ’n’, ’m’, ’l’, ’i’, ’h’, ’t’, ’r’, ’P’, ’y’} Burada bir şey dikkatinizi çekmiş olmalı. Bir öğeyi küme olarak tanımlayıp ekrana yazdırdığımızda elde ettiğimiz çıktı, o öğe içindeki her bir alt öğeyi tek bir kez içeriyor. Yani mesela “Python Programlama Dili” içinde iki adet “P” karakteri var, ama çıktıda bu iki “P” karakterinin yalnızca biri görünüyor. Buradan anlıyoruz ki, kümeler aynı öğeyi birden fazla tekraretmez.Buçokönemlibirözelliktirvepekçokyerdeişimizeyarar.Aynıdurumkarakter dizisidışındakalanötekiveritipleriiçindegeçerlidir.Yanimeselaeğerbirlisteyikümehaline getiriyorsak, o listedeki öğeler küme içinde yalnızca bir kez geçecektir. Listede aynı öğeden iki-üçtanebulunsabile,kümemizbuöğeleritekeindirecektir. >>> liste = ["elma", "armut", "elma", "kebap", "şeker", "armut", ... "çilek", "ağaç", "şeker", "kebap", "şeker"] >>> for i in set(liste): ... print(i) ... ağaç elma şeker kebap çilek armut Gördüğünüzgibi,listeiçindebirdenfazlabulunanöğeler,Python’dakikümeleryardımıylateke indirilebiliyor. Öğrendiğimiz bu bilgi sayesinde, daha önce gördüğümüz count() metodunu da kullanarak, şöylebirkodyazabiliriz: >>> liste = ["elma", "armut", "elma", "kiraz", ... "çilek", "kiraz", "elma", "kebap"] >>> for i in set(liste): ... print("{} listede {} kez geçiyor!".format(i, liste.count(i))) (sonrakisayfayadevam) 566 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) kebap listede 1 kez geçiyor! elma listede 3 kez geçiyor! kiraz listede 2 kez geçiyor! armut listede 1 kez geçiyor! çilek listede 1 kez geçiyor! Buradaset(liste)ifadesinikullanarak,listeöğelerinieşşizvebenzersizbirhalegetirdik. Kümelerinönemlibirözelliğide,tıpkısözlüklergibi,herhangibirşekilde‘öğesırası’kavramına sahipolmamasıdır. Dikkatlicebakın: >>> arayüz_takımları = {’Tkinter’, ’PyQT’, ’PyGobject’} >>> arayüz_takımları {’PyGobject’, ’PyQT’, ’Tkinter’} Sözlüklerde karşılaştığımız durumun aynısının kümeler için de geçerli olduğuna dikkatinizi çekmek isterim. Gördüğünüz gibi, arayüz_takımları adlı kümenin öğeleri, öğe tanımlama sırasını çıktıda korumuyor. Biz ‘Tkinter’ öğesini kümenin ilk sırasına yerleştirmiştik, ama bu öğeçıktıdaensonagitti... Aynensözlüklerdeolduğugibi,kümelerdedeöğelerintanımlanma sırasına bel bağlayarak herhangi bir işlem yapamazsınız. Bu durumun bir yansıması olarak, kümeöğelerinesıralarınagöredeerişemezsiniz: >>> arayüz_takımları[0] Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’set’ object does not support indexing Tıpkıhatamesajındadasöylendiğigibi,kümeadlıveritipiaçısındanöğesırasıdiyebirkavram yoktur... Esasında tek bir küme pek bir işe yaramaz. Kümeler ancak birden fazla olduğunda bunlarla yararlı işler yapabiliriz. Çünkü kümelerin en önemli özelliği, başka kümelerle karşılaştırılabilme kabiliyetidir. Yani mesela kümelerin kesişimini, birleşimini veya farkını bulabilmek için öncelikle elimizde birden fazla küme olması gerekiyor. İşte biz de şimdi bu türişlemlerinasılyapacağımızıöğreneceğiz.Ohaldehiçvakitkaybetmedenyolumuzadevam edelim. 34.1.3 Küme Üreteçleri (Set Comprehensions) Bildiğinizgibilisteüreteçleri,listeoluşturmanınkısavetemizbiryoludur.Aynışekildesözlük üreteçleridesözlükoluşturmanınkısavetemizbiryoludur. İşte liste üreteçlerini ve sözlük üreteçlerini kullanarak nasıl tek satırda ve hızlı bir şekilde listeler ve sözlükler üretebiliyorsak, aynı şekilde küme üreteçlerini kullanarak tek satırda ve hızlıbirşekildekümelerdeüretebiliriz. Örneğinelimizdeşöylebirlisteolduğunudüşünelim: 34.1. Kümeler 567 PythonBelgeleri,Yayım4.1.3 import random liste = [random.randint(0, 10000) for i in range(1000)] Bu arada, buradaki random adlı modüle şimdilik takılmayın. Birkaç bölüm sonra bu modülü inceleyeceğiz. Biz şimdilik random’un da tıpkı sys ve os gibi bir modül olduğunu ve rastgele sayılar üretmemizi sağladığını bilelim yeter. Yukarıdaki kodlarda da bu modül 0 ile 10000 arasındarastgele1000adetsayıüretmemizisağladı. Şimdiamacımızbulisteiçindeyeralansayılardan,değeri100’denküçükolanlarıbulmak. Bununiçinşukodlarıkullanabiliriz: import random liste = [random.randint(0, 10000) for i in range(1000)] yüzden_küçük_sayılar = [i for i in liste if i < 100] print(yüzden_küçük_sayılar) Ancak ortaya çıkan listede aynı sayılardan birkaç tane olabilir. İşte eğer birbirinin aynı olmayansayılardanoluşmuşbirlisteyihızlıvepratikbirşekildeeldeetmekistiyorsanızküme üreteçlerinikullanabilirsiniz: import random liste = [random.randint(0, 10000) for i in range(1000)] küme = {i for i in liste if i < 100} print(küme) Gördüğünüz gibi, küme üreteçlerinin sözdizimi, liste ve sözlük üreteçlerinin sözdizimine çok benziyor. 34.1.4 Kümelerin Metotları Dahaöncekiveritiplerindeolduğugibi,kümelerindemetotlarıvardır.Artıkbizbirveritipinin metotlarınınasıllisteleyeceğimiziçokiyibiliyoruz.Nasıllisteiçinlist();demetiçintuple(); sözlük için de dict() fonksiyonlarını kullanıyorsak, kümeler için de set() adlı fonksiyondan yararlanacağız: >>> dir(set) [’__and__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__iand__’, ’__init__’, ’__ior__’, ’__isub__’, ’__iter__’, ’__ixor__’, ’__le__’, ’__len__’, ’__lt__’, ’__ne__’, ’__new__’, ’__or__’, ’__rand__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__ror__’, ’__rsub__’, ’__rxor__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__sub__’, ’__subclasshook__’, ’__xor__’, ’add’, ’clear’,’copy’, ’difference’, ’difference_update’, ’discard’, (sonrakisayfayadevam) 568 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’intersection’, ’intersection_update’, ’isdisjoint’, ’issubset’, ’issuperset’, ’pop’, ’remove’, ’symmetric_difference’, ’symmetric_difference_update’, ’union’, ’update’] Hemenişimizeyarayacakmetotlarıalalım: >>> for i in dir(set): ... if "__" not in i: ... print(i) ... add clear copy difference difference_update discard intersection intersection_update isdisjoint issubset issuperset pop remove symmetric_difference symmetric_difference_update union update Gördüğünüz gibi kümelerin epey metodu var. Bu arada if "__" not in i satırında “_” yerine “__” kullandığımıza dikkat edin. Neden? Çünkü eğer sadece “_” kullanırsak symmetric_differencevesymmetric_difference_updatemetotlarıçıktımızdayeralmayacaktır. Unutmadan söyleyelim: Kümeler de, tıpkı listeler ve sözlükler gibi, değiştirilebilir bir veri tipidir. clear() Kümelerle ilgili olarak inceleyeceğimiz ilk metot clear(). Bu metodu daha önce sözlükleri çalışırkendegörmüştük.Sözlüklerdebumetodungörevisözlüğüniçiniboşaltmakidi.Burada daaynıvazifeyigörür: >>> km = set("adana") >>> for i in km: ... print(i) ... a d n >>> km.clear() (sonrakisayfayadevam) 34.1. Kümeler 569 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> km set() Burada önce “km” adlı bir küme oluşturduk. Daha sonra da clear() metodunu kullanarak bu kümeninbütünöğelerinisildik.Artıkelimizdeboşbirkümevar. copy() Listeler ve sözlükleri incelerken copy() adlı bir metot öğrenmiştik. Bu metot aynı zamanda kümelerlebirliktedekullanılabilir.Üstelikişlevideaynıdır: >>> km = set("kahramanmaraş") >>> yedek = km.copy() >>> yedek {’a’, ’r’, ’h’, ’k’, ’m’, ’ş’, ’n’} >>> km {’a’, ’h’, ’k’, ’m’, ’n’, ’r’, ’ş’} Burada bir şey dikkatinizi çekmiş olmalı. “km” adlı kümeyi “yedek” adıyla kopyaladık, ama bu iki kümenin çıktılarına baktığımız zaman öğe sıralamasının birbirinden farklı olduğunu görüyoruz. Biliyorsunuz, tıpkı sözlüklerde olduğu gibi, kümeler de sırasız veri tipleridir. Bu yüzden, elde ettiğimiz çıktıda öğeler rastgele diziliyor. Dolayısıyla öğelere sıralarına göre erişemiyoruz.Aynensözlüklerdeolduğugibi... add() Kümelerden bahsederken, bunların değiştirilebilir bir veri tipi olduğunu söylemiştik. Dolayısıyla kümeler, üzerlerinde değişiklik yapmamıza müsaade eden metotlar da içerir. Örneğin add() bu tür metotlardan biridir. Add kelimesi Türkçe’de “eklemek” anlamına gelir. Adındandaanlaşılacağıgibi,bumetotyardımıylakümelerimizeyeniöğelerilaveedebileceğiz. Hemenbununnasılkullanıldığınabakalım: >>> küme = set(["elma", "armut", "kebap"]) >>> küme.add("çilek") >>> print(küme) {’elma’, ’armut’, ’kebap’, ’çilek’} Gördüğünüz gibi, add() metodunu kullanarak, kümemize çilek adlı yeni bir öğe ekledik. Eğer kümede zaten varolan bir öğe eklemeye çalışırsak kümede herhangi bir değişiklik olmayacaktır. Çünkü, daha önce de söylediğimiz gibi, kümeler her bir öğeyi tek bir sayıda barındırır. Eğer bir kümeye birden fazla öğeyi aynı anda eklemek isterseniz for döngüsünden yararlanabilirsiniz: 570 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 >>> yeni = [1,2,3] >>> for i in yeni: ... küme.add(i) ... >>> küme {1, 2, 3, ’elma’, ’kebap’, ’çilek’, ’armut’} Burada yeni adlı listeyi kümeye for döngüsü ile ekledik. Ama bu işlemi yapmanın başka bir yolu daha vardır. Bu işlem için Python’da ayrı bir metot bulunur. Bu metodun adı update() metodudur.Sırasıgelincebumetodudagöreceğiz. Bu arada, yeri gelmişken kümelerin önemli bir özelliğinden daha söz edelim. Bir kümeye herhangi bir öğe ekleyebilmemiz için, o öğenin değiştirilemeyen (immutable) bir veri tipi olmasıgerekiyor.BildiğinizgibiPython’dakişuveritiplerideğiştirilemeyenveritipleridir: 1. Demetler 2. Sayılar 3. KarakterDizileri Şuveritipleriisedeğiştirilebilenveritipleridir: 1. Listeler 2. Sözlükler 3. Kümeler Dolayısıylabirkümeyeancakşuveritipleriniekleyebiliriz: 1. Demetler 2. Sayılar 3. KarakterDizileri Şukodlarıdikkatliceinceleyin: Önceboşbirkümeoluşturalım: >>> küme = set() Bukümeyebirdemetekleyelim: >>> l = (1,2,3) >>> küme.add(l) >>> küme {(1, 2, 3)} Birsayıekleyelim: >>> l = 45 >>> küme.add(l) >>> küme (sonrakisayfayadevam) 34.1. Kümeler 571 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) {45, (1, 2, 3)} Birkarakterdizisiekleyelim: >>> l = ’Jacques Derrida’ >>> küme.add(l) >>> küme {’Jacques Derrida’, 45, (1, 2, 3)} Yukarıdakiler,değiştirilemeyenveritipleriolduğuiçinkümelereeklenebilir. Birdeşunlarabakalım: Kümemizebirlisteeklemeyeçalışalım: >>> l = [1,2,3] >>> küme.add(l) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: ’list’ Kümemizebirsözlükeklemeyeçalışalım: >>> l = {"a": 1, "b": 2, "c": 3} >>> küme.add(l) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: ’dict’ Kümemizebirkümeeklemeyeçalışalım: >>> l = {1, 2, 3} >>> küme.add(l) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: unhashable type: ’set’ Gördüğünüz gibi, tıpkı sözlüklerde olduğu gibi, bir kümeye herhangi bir veri ekleyebilmemiz içinoverinin‘değiştirilemeyen’birveritipiolmasıgerekiyor. 572 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 difference() Bumetotikikümeninfarkınıalmamızısağlar.Örneğin: >>> k1 = set([1, 2, 3, 5]) >>> k2 = set([3, 4, 2, 10]) >>> k1.difference(k2) {1, 5} Demekkik1’ink2’denfarkıbuymuş.Pekik2’nink1’denfarkınıbulmakistersekneyapacağız? >>> k2.difference(k1) {10, 4} Gördüğünüzgibi,birincikullanımda,k1’debulunupk2’debulunmayanöğelerieldeediyoruz. İkincikullanımdaisebununtamtersi.Yaniikincikullanımdak2’debulunupk1’debulunmayan öğelerialıyoruz. İsterseniz uzun uzun difference() metodunu kullanmak yerine sadece eksi (-) işaretini kullanarakdaaynısonucueldeedebilirsiniz: >>> k1 - k2 ...veya... >>> k2 - k1 Hayır, “madem eksi işaretini kullanabiliyoruz, o halde artı işaretini de kullanabiliriz!” gibi bir fikirdoğrudeğildir. difference_update() Bu metot, difference() metodundan elde edilen sonuca göre bir kümenin güncellenmesini sağlar.Yani?Hemenbirörnekverelim: >>> k1 = set([1, 2, 3]) >>> k2 = set([1, 3, 5]) >>> k1.difference_update(k2) >>> print(k1) {2} >>> print(k2) {1, 3, 5} Gördüğünüz gibi, bu metot k1’in k2’den farkını aldı ve bu farkı kullanarak k1’i yeniden oluşturdu.k1ilek2arasındakitekfark2adlıöğeidi.Dolayısıyladifference_update()metodunu uyguladığımızdak1’inöğelerininsilinipyerlerine2adlıöğeningeldiğinigörüyoruz. 34.1. Kümeler 573 PythonBelgeleri,Yayım4.1.3 discard() Bir önceki bölümde öğrendiğimiz add() metodu yardımıyla, önceden oluşturduğumuz bir kümeye yeni öğeler ekleyebiliyorduk. Bu bölümde öğreneceğimiz discard() metodu ise kümedenöğesilmemizisağlayacak: >>> hayvanlar = set(["kedi", "köpek", "at", "kuş", "inek", "deve"]) >>> hayvanlar.discard("kedi") >>> print(hayvanlar) {’kuş’, ’inek’, ’deve’, ’köpek’, ’at’} Eğer küme içinde bulunmayan bir öğe silmeye çalışırsak hiç bir şey olmaz. Yani hata mesajı almayız: >>> hayvanlar.discard("yılan") Burada etkileşimli kabuk sessizce bir alt satıra geçecektir. Bu metodun en önemli özelliği budur.Yaniolmayanbiröğeyisilmeyeçalıştığımızdahatavermemesi. remove() Bu metot da bir önceki bölümde gördüğümüz discard() metoduyla aynı işlevi yerine getirir. Eğerbirkümedenöğesilmekistersekremove()metodunudakullanabiliriz: >>> hayvanlar.remove("köpek") Pekidiscard()varkenremove()metodunanegerekvar?Yadatersi. Bu iki metot aynı işlevi yerine getirse de aralarında önemli bir fark vardır. Hatırlarsanız discard() metoduyla, kümede olmayan bir öğeyi silmeye çalışırsak herhangi bir hata mesajı almayacağımızı söylemiştik. Eğerremove()metodunu kullanarak, kümede olmayan bir öğeyi silmeyeçalışırsak,discard()metodununaksine,hatamesajıalırız: >>> hayvanlar.remove("fare") Traceback (most recent call last): File "<stdin>", line 1, in <module> KeyError: ’fare’ Bu iki metot arasındaki bu fark önemli bir farktır. Bazen yazdığınız programlarda, duruma göreherikiözelliğedeihtiyacınızolabilir. 574 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 intersection() intersection kelimesi Türkçe’de “kesişim” anlamına gelir. Adından da anladığımız gibi, intersection()metodubizeikikümeninkesişimkümesiniverecektir: >>> k1 = set([1, 2, 3, 4]) >>> k2 = set([1, 3, 5, 7]) >>> k1.intersection(k2) {1, 3} Gördüğünüzgibi,bumetotbizek1vek2’ninkesişimkümesiniveriyor.Dolayısıylabuikiküme arasındakiortakelemanlarıbulmuşoluyoruz. Hatırlarsanız, difference() metodunu anlatırken, difference() kelimesi yerine “-” işaretini de kullanabileceğimiz,söylemiştik.Benzerbirdurumintersection()metoduiçindegeçerlidir.İki kümeninkesişiminibulmakiçin“&”işaretindenyararlanabiliriz: >>> k1 & k2 {1, 3} Python programcıları genellikle uzun uzun intersection yazmak yerine “&” işaretini kullanırlar... İsterseniz bu metot için örnek bir program verelim. Böylece gerçek hayatta bu metodu nasıl kullanabileceğimizigörmüşoluruz: tr = "şçöğüıŞÇÖĞÜİ" parola = input("Sisteme giriş için bir parola belirleyin: ") if set(tr) & set(parola): print("Parolanızda Türkçe harfler kullanmayın!") else: print("Parolanız kabul edildi!") Burada eğer kullanıcı, parola belirlerken içinde Türkçe bir harf geçen bir kelime yazarsa programımız kendisini Türkçe harf kullanmaması konusunda uyaracaktır. Bu kodlarda kümelerinasılkullandığımızadikkatedin.Programdaasılişiyapankısımşusatırdır: if set(tr) & set(parola): print("Parolanızda Türkçe harfler kullanmayın!") Buradaaslındaşöylebirşeydemişoluyoruz: Eğer set(tr) ve set(parola) kümelerinin kesişim kümesi boş değilse, kullanıcıya “ParolanızdaTürkçeharflerkullanmayın!”uyarısınıgöster! set(tr) ve set(parola) kümelerinin kesişim kümesinin boş olmaması, kullanıcının girdiği kelimeiçindekiharflerdenenazbirinintradlıdeğişkeniçindegeçtiğianlamınagelir.Burada basitçe,trdeğişkeniileparoladeğişkeniarasındakiortaköğelerisorguluyoruz.Eğerkullanıcı 34.1. Kümeler 575 PythonBelgeleri,Yayım4.1.3 herhangi bir Türkçe harf içermeyen bir kelime girerse set(tr) ve set(parola) kümelerinin kesişimkümesiboşolacaktır.İstersenizküçükbirdenemeyapalım: >>> tr = "şçöğüıŞÇÖĞÜİ" >>> parola = "çilek" >>> set(tr) & set(parola) {’ç’} Burada kullanıcının “çilek” adlı kelimeyi girdiğini varsayıyoruz. Böyle bir durumda set(tr) ve set(parola) kümelerinin kesişim kümesi “ç” harfini içerecek, dolayısıyla da programımız kullanıcıyauyarımesajıgösterecektir.Eğerkullanıcımız“kalem”gibiTürkçeharfiçermeyenbir kelimegirerse: >>> tr = "şçöğüıŞÇÖĞÜİ" >>> parola = "kalem" >>> set(tr) & set(parola) set() Gördüğünüz gibi, elde ettiğimiz küme boş. Dolayısıyla böyle bir durumda programımız kullanıcıyaherhangibiruyarımesajıgöstermeyecektir. intersection() metodunu pek çok yerde kullanabilirsiniz. Hatta iki dosya arasındaki benzerlikleri bulmak için dahi bu metottan yararlanabilirsiniz. İlerde dosya işlemleri konusunuişlerkenbumetottannasılyararlanabileceğimizideanlatacağız. intersection_update() Hatırlarsanızdifference_update()metodunuişlerkenşöylebirşeydemiştik: Bu metot, difference() metodundan elde edilen sonuca göre bir kümenin güncellenmesini sağlar. İşte intersection_update metodu da buna çok benzer bir işlevi yerine getirir. Bu metodun görevi, intersection() metodundan elde edilen sonuca göre bir kümenin güncellenmesini sağlamaktır: >>> k1 = set([1, 2, 3]) >>> k2 = set([1, 3, 5]) >>> k1.intersection_update(k2) >>> print(k1) {1, 3} >>> print(k2) {1, 3, 5} Gördüğünüz gibi, intersection_update() metodu k1’in bütün öğelerini sildi ve yerlerine k1 ve k2’ninkesişimkümesininelemanlarınıkoydu. 576 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 isdisjoint() Bumetodunçokbasitbirgörevivardır.isdisjoint()metodunukullanarakikikümeninkesişim kümesinin boş olup olmadığı sorgulayabilirsiniz. Hatırlarsanız aynı işi bir önceki bölümde gördüğümüz intersection() metodunu kullanarak da yapabiliyorduk. Ama eğer hayattan tek beklentiniz iki kümenin kesişim kümesinin boş olup olmadığını, yani bu iki kümenin ortak elemaniçeripiçermediğiniöğrenmekse,basitçeisdisjoint()metodundanyararlanabilirsiniz: >>> a = set([1, 2, 3]) >>> b = set([2, 4, 6]) >>> a.isdisjoint(b) False Gördüğünüzgibi,avebkümesininkesişimiboşolmadığıiçin,yanibuikikümeortakenazbir öğe barındırdığıiçin,isdisjoint()metoduFalseçıktısı veriyor.Buradatemel olarak şusoruyu sormuşoluyoruz: avebayrıkkümelermi? Python da bize cevap olarak, “Hayır değil,” anlamına gelen False çıktısını veriyor... Çünkü a vebkümelerininortakbirelemanıvar(2). Birdeşunabakalım: >>> a = set([1, 3, 5]) >>> b = set([2, 4, 6]) >>> a.isdisjoint(b) True Buradaavebkümeleriortakhiçbirelemanasahipolmadığıiçin“Doğru”anlamınagelenTrue çıktısınıeldeediyoruz. issubset() Bu metot yardımıyla, bir kümenin bütün elemanlarının başka bir küme içinde yer alıp yer almadığını sorgulayabiliriz. Yani bir kümenin, başka bir kümenin alt kümesi olup olmadığını bu metot yardımıyla öğrenebiliriz. Eğer bir küme başka bir kümenin alt kümesi ise bu metot bizeTruedeğeriniverecek;eğerdeğilseFalseçıktısınıverecektir: >>> a = set([1, 2, 3]) >>> b = set([0, 1, 2, 3, 4, 5]) >>> a.issubset(b) True Bu örnekte True çıktısını aldık, çünkü a kümesinin bütün öğeleri b kümesi içinde yer alıyor. Yania,b’ninaltkümesidir. 34.1. Kümeler 577 PythonBelgeleri,Yayım4.1.3 issuperset() Bu metot, bir önceki bölümde gördüğümüz issubset() metoduna benzer. Matematik derslerinde gördüğümüz “kümeler” konusunda hatırladığınız “b kümesi a kümesini kapsar” ifadesinibumetotlagösteriyoruz.Öncebiröncekiderstegördüğümüzörneğebakalım: >>> a = set([1, 2, 3]) >>> b = set([0, 1, 2, 3, 4, 5]) >>> a.issubset(b) True Buradan,“akümesibkümesininaltkümesidir,”sonucunaulaşıyoruz.Birdeşunabakalım: >>> a = set([1, 2, 3]) >>> b = set([0, 1, 2, 3, 4, 5]) >>> b.issuperset(a) True Buradaise,“bkümesiakümesinikapsar,”sonucunueldeediyoruz.Yanibkümesiakümesinin bütünelemanlarınıiçindebarındırıyor. union() union()metoduikikümeninbirleşiminialmamızısağlar.Hemenbirörnekverelim: >>> a = set([2, 4, 6, 8]) >>> b = set([1, 3, 5, 7]) >>> a.union(b) {1, 2, 3, 4, 5, 6, 7, 8} Öncekibölümlerdegördüğümüzbazımetotlardaolduğugibi,union()metodudabirkısayola sahiptir.union()metoduyerine“|”işaretinidekullanabiliriz: >>> a | b union()metoduyerine,bumetodunkısayoluolan“|”işaretiPythonprogramcılarıtarafından dahasıkkullanılır. update() Hatırlarsanızadd()metodunuanlatırkenşöylebirörnekvermiştik: >>> küme = set(["elma", "armut", "kebap"]) >>> yeni = [1, 2, 3] >>> for i in yeni: ... küme.add(i) (sonrakisayfayadevam) 578 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ... >>> küme {1, 2, 3, ’elma’, ’armut’, ’kebap’} Buörneğiverdiktensonradaşöylebirşeydemiştik: “Burada yeni adlı listeyi kümeye for döngüsü ile ekledik. Ama bu işlemi yapmanın başka bir yoludahavardır.BuişlemiçinPython’daayrıbirmetotbulunur.” İşte bu metodu öğrenmenin vakti geldi. Metodumuzun adı update(). Bu metot, bir kümeyi güncellememizisağlar.İstersenizyukarıdakiörneği,bumetodukullanaraktekraryazalım: >>> küme = set(["elma", "armut", "kebap"]) >>> yeni = [1, 2, 3] >>> küme.update(yeni) >>> print(küme) {1, 2, 3, ’elma’, ’armut’, ’kebap’} Gördüğünüzgibi,fordöngüsünükullanmayagerekkalmadanaynısonucueldeedebildik. symmetric_difference() Daha önceki bölümlerde difference() metodunu kullanarak iki küme arasındaki farklı öğeleri bulmayıöğrenmiştik.Örneğinelimizdeşöyleikikümevardiyelim: >>> a = set([1, 2, 5]) >>> b = set([1, 4, 5]) Eğerakümesininbkümesindenfarkınıbulmakistersekşöyleyapıyoruz: >>> a.difference(b) {2} Demekkiakümesindebulunupbkümesindebulunmayanöğe2imiş. Birdebkümesindebulunupakümesindebulunmayanöğelerebakalım: >>> b.difference(a) {4} Bu da bize “4” çıktısını verdi. Demek ki bu öğe b kümesinde bulunuyor, ama a kümesinde bulunmuyormuş. Peki ya kümelerin sadece birinde bulunan öğeleri nasıl alacağız? İşte bu noktadayardımımızasymmetric_difference()adlımetotyetişecek: >>> a.symmetric_difference(b) {2, 4} 34.1. Kümeler 579 PythonBelgeleri,Yayım4.1.3 Böyleceikikümeninortakolaraksahipolmadığıöğelerialmışolduk. symmetric_difference_update() Daha önce difference_update ve intersection_update gibi metotları öğrenmiştik. symmetric_difference_update()metodudabunlarabenzerbirişleviyerinegetirir: >>> a = set([1,2, 5]) >>> b = set([1,4, 5]) >>> a.symmetric_difference_update(b) >>> print(a) {2, 4} Gördüğünüz gibi, a kümesinin eski öğeleri gitti, yerlerine symmetric_difference() metoduyla elde edilen çıktı geldi. Yani a kümesi, symmetric_difference() metodunun sonucuna göre güncellenmişoldu... pop() İnceleyeceğimiz son metot pop() metodu olacak. Gerçi bu metot bize hiç yabancı değil. Bu metodu listeler konusundan hatırlıyoruz. Orada öğrendiğimize göre, bu metot listenin bir öğesini silip ekrana basıyordu. Aslında buradaki fonksiyonu da farklı değil. Burada da kümelerinöğelerinisilipekranabasıyor: >>> a = set(["elma", "armut", "kebap"]) >>> a.pop() ’elma’ Pekibumetothangiölçütegörekümedenöğesiliyor?Herhangibirölçütyok.Bumetot,küme öğelerinitamamenrastgelesiliyor. Böylelikle Python’da Listeler, Demetler, Sözlükler ve Kümeler konusunu bitirmiş olduk. Bu konularısıksıktekraretmek,hiçolmazsaaradasıradagözgezdirmekbazışeylerinzihnimizde yeretmesiaçısındanoldukçaönemlidir. 34.2 Dondurulmuş Kümeler (Frozenset) Daha önce de söylediğimiz gibi, kümeler üzerinde değişiklik yapabiliyoruz. Zaten kümelerin add() ve remove() gibi metotlarının olması bu durumu teyit ediyor. Ancak kimi durumlarda, öğeleri üzerinde değişiklik yapılamayan kümelere de ihtiyaç duyabilirsiniz. Hatırlarsanız listeler ve demetler arasında da buna benzer bir ilişki var. Demetler çoğu zaman, üzerinde değişiklik yapılamayan bir liste gibi davranır. İşte Python aynı imkanı bize kümelerde de sağlar. Eğer öğeleri üzerinde değişiklik yapılamayan bir küme oluşturmak isterseniz set() yerine frozenset() fonksiyonunu kullanabilirsiniz. Dilerseniz hemen bununla ilgili bir örnek verelim: >>> dondurulmuş = frozenset(["elma", "armut", "ayva"]) 580 Bölüm34. KümelerveDondurulmuşKümeler PythonBelgeleri,Yayım4.1.3 Dondurulmuş kümeleri bu şekilde oluşturuyoruz. Şimdi bu dondurulmuş kümenin metotlarınabakalım: >>> dir(dondurulmuş) [’__and__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__ne__’, ’__new__’, ’__or__’, ’__rand__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__ror__’, ’__rsub__’, ’__rxor__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__sub__’, ’__subclasshook__’, ’__xor__’, ’copy’, ’difference’, ’intersection’, ’isdisjoint’, ’issubset’, ’issuperset’, ’symmetric_difference’, ’union’] Gördüğünüz gibi, add(), remove(), update() gibi, değişiklik yapmaya yönelik metotlar listede yok. Dondurulmuş kümeler ile normal kümeler arasında işlev olarak hiçbir fark yoktur. Bu ikisi arasındakifark,listeleriledemetlerarasındakifarkgibidir. 34.2. DondurulmuşKümeler(Frozenset) 581 35 BÖLÜM Fonksiyonlar İlk derslerimizden bu yana bir şey özellikle dikkatinizi çekmiş olmalı: İlk andan itibaren hep ‘fonksiyon’ diye bir kavramdan söz ettik; üstelik yazdığımız kodlarda da bu fonksiyon denen şeyibolcakullandık.Evet,belkibukavramışimdiyedekenineboyunaincelemefırsatımızhiç olmadı,amayinedeadınınfonksiyonolduğunusöylediğimizpekçokaraçtanıdıkbunoktaya gelinceyekadar. Herhalde, ‘Fonksiyon denince aklınıza ilk ne geliyor?’ diye bir soru sorsam, vereceğiniz cevap print()fonksiyonuolacaktır.Gerçektendebufonksiyonuilkderslerimizdenbuyanaokadar sıkkullandıkki,fonksiyondeninceaklınızailkbufonksiyonungelmesigayetdoğal. Elbette öğrendiğimiz tek fonksiyon print() değildi. Bunun dışında type() diye bir fonksiyondan da söz etmiştik. print() kadar olmasa da, type() fonksiyonunu da yazdığımız kodlardaepeykullandık.print()vetype()dışında,fonksiyonolarakstr(),int()vebenzeri araçlarladatanıştık.BunlarındışındapekçokbaşkafonksiyondaPython’labirliktehayatımıza girdi. İşte bu bölümde, en baştan bu yana sıklıkla sözünü ettiğimiz, ama hiçbir zaman tam anlamıylaelealmadığımızbukavramıdahaiyianlayabilmekiçin,fonksiyonkonusunuayrıntılı olarak ele alacağız. Bu bölümde amacımız fonksiyonları enine boyuna inceleyerek, okurun bilgi dağarcığında fonksiyonlara ilişkin sağlam bir altyapı oluşturmaktır. Okur, bu bölümü bitirdiktensonrafonksiyonlarailişkinolarakbilmesigerekenherşeyiöğrenmişolacak. 35.1 Fonksiyon Nedir ve Ne İşe Yarar? Biz şimdiye dek karşılaştığımız print(), len(), type() ve open() gibi örnekler sayesinde ‘fonksiyon’ denen şeyi az çok tanıdığımızı söyleyebiliriz. Dolayısıyla fonksiyonun ne demek olduğunu şeklen de olsa biliyoruz ve hatta fonksiyonları kodlarımız içinde etkili bir şekilde kullanabiliyoruz. İlk derslerimizden bu yana öğrendiğimiz fonksiyonlara şöyle bir bakacak olursak, fonksiyonlarıngörünüşüneveyapısınadairherhaldeşutespitleriyapabiliriz: 582 PythonBelgeleri,Yayım4.1.3 1. Herfonksiyonunbiradıbulunurvefonksiyonlarsahipolduklarıbuadlarlaanılır.(print fonksiyonu,openfonksiyonu,typefonksiyonu,inputfonksiyonu,lenfonksiyonuvb.) 2. Şekil olarak, her fonksiyonun isminin yanında birer parantez işareti bulunur. (open(), print(),input(),len()vb.) 3. Bu parantez işaretlerinin içine, fonksiyonlara işlevsellik kazandıran bazı parametreler yazılır. (open(dosya_adı), print("Merhaba Zalim Dünya!"), len("kahramanmaraş") vb.) 4. Fonksiyonlar farklı sayıda parametre alabilir. Örneğin print() fonksiyonu toplam 256 adetparametrealabilirken,input()fonksiyonuyalnızcatekbirparametrealır. 5. Fonksiyonların isimli ve isimsiz parametreleri vardır. print() fonksiyonundaki sep, end ve file parametreleri isimli parametrelere örnekken, mesela print("Merhaba Dünya!") kodunda Merhaba Dünya! parametresi isimsiz bir parametredir. Aynı şekilde input("Adınız: ")gibibirkoddaAdınız:parametresiisimsizbirparametredir. 6. Fonksiyonların, isimli ve isimsiz parametreleri dışında, bir de varsayılan değerli parametreleri vardır. Örneğin print() fonksiyonunun sep, end ve file parametreleri varsayılan değerli parametrelere birer örnektir. Eğer bir parametrenin varsayılan bir değerivarsa,oparametreyeherhangibirdeğervermedendefonksiyonukullanabiliriz. Python bu parametrelere, belirli değerleri öntanımlı olarak kendisi atayacaktır. Tabii eğer istersek, varsayılan değerli parametrelere kendimiz de başka birtakım değerler verebiliriz. Fonksiyon kavramının tam olarak ne olduğunu henüz bilmiyor da olsak, şimdiye kadar öğrendiğimiz fonksiyonlara bakarak fonksiyonlar hakkında yukarıdaki çıkarımları yapabiliyoruz. Demek ki aslında fonksiyonlar hakkında alttan alta pek çok şey öğrenmişiz. O halde, fonksiyonlar hakkında şimdiden bildiklerimize güvenerek, fonksiyon kavramının ne olduğundanziyadeneişeyaradığıkonusunarahatlıklaeğilebiliriz.Zatenfonksiyonlarınneişe yaradığınıöğrendiktensonra,fonksiyonlarınneolduğunudahemencecikanlayacaksınız. Fonksiyonların ne işe yaradığını en genel ve en kaba haliyle tarif etmek istersek şöyle bir tanımlamayapabiliriz: Fonksiyonlarıngörevi,karmaşıkişlemleribirarayatoplayarak,buişlemleri tek adımda yapmamızı sağlamaktır. Fonksiyonlar çoğu zaman, yapmak istediğimiz işlemler için bir şablon vazifesi görür. Fonksiyonları kullanarak, bir veya birkaç adımdan oluşan işlemleri tek bir isim altında toplayabiliriz. Python’daki ‘fonksiyon’ kavramı başka programlama dillerinde ‘rutin’ veya ‘prosedür’olarakadlandırılır.Gerçektendefonksiyonlarrutinolaraktekrar edilengörevleriveyaprosedürleritekbirad/çatıaltındatoplayanaraçlardır. Dilerseniz yukarıdaki soyut ifadeleri basit bir örnek üzerinde somutlaştırmaya çalışalım. Örneğinprint()fonksiyonunuelealalım. Bu fonksiyonun görevini biliyorsunuz: print() fonksiyonunun görevi, kullanıcının girdiği parametreleri ekrana çıktı olarak vermektir. Her ne kadar print() fonksiyonunun görevini, ekrana çıktı vermek olarak tanımlasak da, aslında bu fonksiyon, ekrana çıktı vermenin yanı sıra, başka bir takım ilave işlemler de yapar. Yani bu fonksiyon, aslında aldığı parametreleri sadeceekranaçıktıolarakvermekleyetinmez.Örneğinşukomutuinceleyelim: >>> print("Fırat", "Özgül", "1980", "Adana") Buradaprint()fonksiyonutoplamdörtadetparametrealıyor.Fonksiyonumuz,görevigereği, 35.1. FonksiyonNedirveNeİşeYarar? 583 PythonBelgeleri,Yayım4.1.3 bu parametreleri ekrana çıktı olarak verecek. Bu komutu çalıştırdığımızda şöyle bir çıktı alıyoruz: Fırat Özgül 1980 Adana Dikkat ederseniz, burada salt bir ‘ekrana çıktı verme’ işleminden fazlası var. Zira print() fonksiyonualdığıparametrelerişuşekildedeekranaverebilirdi: FıratÖzgül1980Adana Veyaşuşekilde: F ı r a t Ö z g ü l 1 9 8 0 A d a n a Neticedebunlardabirerçıktıvermeişlemidir.Amadediğimizgibi,print()fonksiyonualdığı parametreleri sadece ekrana çıktı olarak vermekle yetinmiyor. Gelin isterseniz ne demek istediğimizibirazdahaaçıklayalım: print() fonksiyonunun yukarıdaki komutu nasıl algıladığını önceki derslerimizde öğrenmiştik.YukarıdakikomutPythontarafındanşuşekildealgılanıyor: >>> print("Fırat", "Özgül", "1980", "Adana", sep=" ", end="\n", ... file=sys.stdout, flush=False) Yaniprint()fonksiyonu; 1. Kendisineverilen“Fırat”,“Özgül”,“1980”ve“Adana”parametreleriniekranabasıyor, 2. sep=”“parametresininetkisiyle,buparametrelerarasınabirerboşlukekliyor, 3. end=”\n” parametresinin etkisiyle, sonuncu parametreyi de ekrana bastıktan sonra bir altsatırageçiyor, 4. file=sys.stdoutparametresininetkisiyle,çıktıkonumuolarakkomutekranınıkullanıyor. Yaniçıktılarıekranaveriyor. 584 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 5. flush=False parametresinin etkisiyle, çıktılar ekrana gönderilmeden önce tamponda bekletiliyor. Eğerprint()gibibirfonksiyonolmasaydı,yukarıdalistediğimizbütünbuişlemlerikendimiz yapmak zorunda kalacaktık. Yani ekranda göstermek istediğimiz ifadeleri ekrana çıktı olarak vermenin yanısıra, bunların ekranda nasıl görüneceğini de tek tek kendimiz elle ayarlamak zorunda kalacaktık. Ekrana çıktı verme ile ilgili pek çok işlem tek bir print() fonksiyonu altındabirleştirildiğiiçin,herihtiyaçduyduğumuzdaoişlemleritektekbizimyapmamızagerek kalmıyor. Aynışeymeselainput()fonksiyonuiçindegeçerlidir.Bufonksiyonukullanarak,programımızı kullanan kişilerle etkileşim içine girebiliyoruz. Tıpkı print() fonksiyonunda olduğu gibi, input() fonksiyonu da aslında alttan alta epey karmaşık işlemler gerçekleştirir. Ama o karmaşık işlemlerin tek bir input() fonksiyonu içinde bir araya getirilmiş olması sayesinde, sadeceinput()gibibasitbirkomutvererekkullanıcılarımızlailetişimegeçebiliyoruz. Bu açıdan bakıldığında fonksiyonlar değişkenlere benzer. Bildiğiniz gibi, her defasında bir değeri tekrar tekrar yazmak yerine bir değişkene atayarak o değere kolayca erişebiliyoruz. Örneğin: >>> kurum = "Sosyal Sigortalar Kurumu" Burada tanımladığımız kurum adlı değişken sayesinde, ‘Sosyal Sigortalar Kurumu’ ifadesini kullanmamızgerekenheryerdesadecedeğişkenadınıkullanarak,değişkenintuttuğudeğere ulaşabiliyoruz. İşte fonksiyonlar da buna benzer bir işlev görür: Örneğin ekrana bir çıktı vermemizgerekenheryerde,yukarıdaverdiğimizkarmaşıkadımlarıtektekgerçekleştirmeye çalışmakyerine,bukarmaşıkverutinadımlarıbirarayagetirenprint()gibibirfonksiyondan yararlanarakişlerimiziçokdahakolaybirşekildehalledebiliriz. Bu anlattıklarımız fonksiyonların ne işe yaradığı konusunda size bir fikir vermiş olabilir. Dilersenizbuanlattıklarımızıbirörnekaracılığıylabirazdahasomutlaştırmayaçalışalım: Hatırlarsanız‘KullanıcıylaVeriAlışverişi’başlıklıbölümdeşöylebirörnekvermiştik: isim = "Fırat" soyisim = "Özgül" işsis = "Ubuntu" şehir = "İstanbul" print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) Buprogramıçalıştırdığımızdaşöylebirçıktıalıyoruz: isim : Fırat soyisim : Özgül işletim sistemi: Ubuntu şehir : İstanbul Bu program, belli değerleri kullanarak bir kayıt oluşturma işlemi gerçekleştiriyor. Mesela yukarıdakiörnekte,‘FıratÖzgül’adlışahsaaitisim,soyisim,işletimsistemiveşehirbilgilerini alarak,bukişiiçinbirkayıtoluşturuyoruz. 35.1. FonksiyonNedirveNeİşeYarar? 585 PythonBelgeleri,Yayım4.1.3 Peki ‘Fırat Özgül’ adlı kişinin yanısıra, ‘Mehmet Öztaban’ adlı başka bir kişi için de kayıt oluşturmakistersekneyapacağız? Aklınızaşöylebirşeyyazmakgelmişolabilir: isim1 = "Fırat" soyisim1 = "Özgül" işsis1 = "Ubuntu" şehir1 = "İstanbul" print("isim : ", isim1) print("soyisim : ", soyisim1) print("işletim sistemi: ", işsis1) print("şehir : ", şehir1) print("-"*30) isim2 = "Mehmet" soyisim2 = "Öztaban" işsis2 = "Debian" şehir2 = "Ankara" print("isim : ", isim2) print("soyisim : ", soyisim2) print("işletim sistemi: ", işsis2) print("şehir : ", şehir2) print("-"*30) Programa her yeni kayıt eklenişinde, her yeni kişi için benzer satırları tekrar tekrar yazabilirsiniz. Peki ama bu yöntem sizce de çok sıkıcı değil mi? Üstelik bir o kadar da hataya açıkbiryöntem.Muhtemelenilkkaydıeklediktensonra,ikincikaydıeklerkenbirincikayıttaki bilgileri kopyalayıp, bu kopya üzerinden ikinci kaydı oluşturuyorsunuz. Hatta muhtemelen kopyalayıp yapıştırdıktan sonra yeni kaydı düzenlerken bazı hatalar da yapıyor ve düzgün çalışanbirprogrameldeedebilmekiçinohatalarıdüzeltmekledeuğraşıyorsunuz. Bütün bu işleri kolaylaştıracak bir çözüm olsa ve bizi aynı şeyleri tekrar tekrar yazmaktan kurtarsa sizce de çok güzel olmaz mıydı? Mesela tıpkı print() fonksiyonu gibi, kayıt_oluştur() adlı bir fonksiyon olsa, biz sadece gerekli bilgileri bu fonksiyonun parantezleriiçineparametreolarakyazsakvebufonksiyonbizeistediğimizbilgileriiçerenbir kayıtoluştursanehoşolurdu,değilmi?Yaniörneğinbahsettiğimizbuhayalikayıt_oluştur() fonksiyonunuşuşekildekullanabilseydik... kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara") ... vebukomutbizeşuçıktıyıverebilseydi... ------------------------------ isim : Mehmet soyisim : Öztaban işletim sistemi: Debian şehir : Ankara ------------------------------ 586 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 ... nekadargüzelolurdu,değilmi? İşte böyle bir şey Python’da mümkündür. Nasıl Python geliştiricileri print(), input() ve benzeri fonksiyonları tanımlayıp, karmaşık işlemleri tek adımda yapabilmemiz için bize sunmuş ve böylece bizi her defasında tekerleği yeniden icat etme külfetinden kurtarmışsa, biz de kendi fonksiyonlarımızı tanımlayarak, kendimizi aynı işlemleri tekrar tekrar yapma zahmetindenkurtarabiliriz. Gelinşimdibuişinasılyapabileceğimizitartışalım. 35.2 Fonksiyon Tanımlamak ve Çağırmak Bir önceki bölümde, kayıt_oluştur() adlı hayali bir fonksiyondan söz etmiştik. Tasarımıza görebufonksiyonşuşekildekullanılacak: kayıt_oluştur("Ahmet", "Gür", "Pardus", "İzmir") Bukomutuverdiğimizdeiseşöylebirçıktıalmayıplanlıyoruz: ------------------------------ isim : Ahmet soyisim : Gür işletim sistemi: Pardus şehir : İzmir ------------------------------ Dediğimiz gibi, böyle bir şey yapmak Python’la mümkündür. Ancak tabii ki kayıt_oluştur() adlı böyle bir fonksiyonu kullanabilmenin belli ön koşulları var. Nasıl sayı adlı bir değişkeni kullanabilmek için öncelikle bu ada sahip bir değişken tanımlamış olmamız gerekiyorsa, aynı şekilde kayıt_oluştur() adlı bir fonksiyonu kullanabilmek için de öncelikle bu ada sahip bir fonksiyonu tanımlamış olmamız gerekiyor. Zira mesela input() ve print() gibi fonksiyonlarıkullanabiliyorolmamız,Pythongeliştiricilerininbufonksiyonlarıtanımlayıpdilin içinegömmüşolmalarısayesindedir. İşte biz de kayıt_oluştur() adlı fonksiyonu kullanabilmek için bu ada sahip fonksiyonu aşağıdakişekildetanımlamalıyız: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) İlk bakışta bu kodlar size hiçbir şey ifade etmemiş olabilir. Ama hiç endişe etmeyin. Biz birazdan bu satırların ne anlama geldiğini bütün ayrıntılarıyla anlatacağız. Siz şimdilik anlamadığınızkısımlarıgörmezdengelipokumayadevamedin. Yukarıdakikodlaryardımıylafonksiyonumuzutanımlamışolduk.Artıkelimizde,tıpkıprint() veya input() gibi, kayıt_oluştur() adlı ‘ev yapımı’ bir fonksiyon var. Dolayısıyla bu yeni 35.2. FonksiyonTanımlamakveÇağırmak 587 PythonBelgeleri,Yayım4.1.3 fonksiyonumuzu, daha önce öğrendiğimiz fonksiyonları nasıl kullanıyorsak aynı şekilde kullanabiliriz.Yaniaşağıdakigibikomutlaryazabiliriz: kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara") Yalnız fonksiyonumuzu tanımlayıp bitirdikten sonra, bu fonksiyonu kullanırken, kodlarımızın hizalamasına dikkat ediyoruz. Fonksiyonu kullanmak için yazdığımız kodları def ifadesinin hizasınagetiriyoruz.Yani: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara") Yukarıdakiyapıyıkullanarak,istediğinizsayıdakayıtoluşturabilirsiniz.Mesela: kayıt_oluştur("İlkay", "Kaya", "Mint", "Adana") kayıt_oluştur("Seda", "Kara", "SuSe", "Erzurum") Gördüğünüz gibi, yukarıdaki yöntem sayesinde kodlarımızdaki tekrar eden kısımlar ortadan kalktı. Yukarıdaki fonksiyonun bize nasıl bir kolaylık sağladığını daha net görebilmek için, fonksiyon kullanarak sadece şu 11 satırla elde ettiğimiz çıktıyı, fonksiyon kullanmadan elde etmeyideneyebilirsiniz: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") kayıt_oluştur("Mehmet", "Öztaban", "Debian", "Ankara") kayıt_oluştur("İlkay", "Kaya", "Mint", "Adana") kayıt_oluştur("Seda", "Kara", "SuSe", "Erzurum") Buanlattıklarımızsizeçokkarmaşıkgelmişolabilir.Amaendişeetmenizehiçgerekyok.Biraz sonra,yukarıdayazdığımızkodlarınhepsinididikdidikedeceğiz.Amaöncelikleyukarıdakikod parçasını yapısal olarak bir incelemenizi istiyorum. Fonksiyonu tanımladığımız aşağıdaki kod parçasınaşöylebirbaktığınızdanelergörüyorsunuz? 588 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") Bukodlarıincelediğinizdeşunoktalardikkatiniziçekiyorolmalı: 1. Kodlardef adlıbirifadeilebaşlamış. 2. Bununardından‘kayıt_oluştur’ifadesinigörüyoruz. 3. Buifadeyi,içindebirtakımkelimelerbarındıranbirparantezçiftiizliyor. 4. Paranteziniçinde,isim,soyisim,işsisveşehiradlıdeğerlervar. 5. def ilebaşlayanbusatırikinoktaüstüsteişaretiilesonbuluyor. 6. İlksatırınardındangelenkısımilksatıragöregirintilibirşekildeyazılmış. 7. kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") satırı önceki satırlara göregirintisizyazılmış. Eğer bu kodlara dikkatlice bakacak olursanız, aslında bu kodların topu topu iki parçadan oluştuğunugöreceksiniz.İstersenizyukarıdakiyapıyıbirazsadeleştirelim: def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4): (...) kayıt_oluştur(parametre1, parametre2, parametre3, parametre4) Buyapınınilkparçasışudur: def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4): (...) İkinciparçasıiseşu: kayıt_oluştur(parametre1, parametre2, parametre3, parametre4) Teknik olarak söylemek gerekirse, ilk parçaya ‘fonksiyon tanımı’ (function definition), ikinci parçaya ise ‘fonksiyon çağrısı’ (function call) adı verilir. Dolayısıyla bir fonksiyonun yaşam döngüsüikiaşamadanoluşur.Bunagörebirfonksiyonöncetanımlanır; def kayıt_oluştur(parametre1, parametre2, parametre3, parametre4): (...) ...sonradaçağrılır; 35.2. FonksiyonTanımlamakveÇağırmak 589 PythonBelgeleri,Yayım4.1.3 kayıt_oluştur(parametre1, parametre2, parametre3, parametre4) Aslında biz şimdiye kadar gördüğümüz print(), type(), open() vb. fonksiyonlarda bu ‘fonksiyon çağrısı’ kısmıyla zaten tanışmıştık. Zira şu komut tam anlamıyla bir fonksiyon çağrısıdır(yanibirfonksiyonçağırmaişlemidir): print("Fırat", "Özgül", "Adana", 32) Gördüğünüzgibi,yukarıdakikomutunyapıolarakşukomuttanhiçbirfarkıyok: kayıt_oluştur("Fırat", "Özgül", "Ubuntu", "İstanbul") Bu iki fonksiyon arasındaki tek fark, print() fonksiyonunu Python geliştiricilerinin; kayıt_oluştur()fonksiyonunuisesizintanımlamışolmanızdır. Elbette bu iki fonksiyon yapı olarak birbirinin aynı olsa da, işlev olarak birbirinden farklıdır. print() fonksiyonunun görevi kendisine parametre olarak verilen değerleri ekrana çıktı vermek iken, kayıt_oluştur() fonksiyonunun görevi kendisine parametre olarak verilen değerlerikullanarakbirkayıtoluşturmaktır. Bu derse gelinceye kadar öğrendiğimiz print(), type() ve open() gibi fonksiyonlara teknik olarak ‘gömülü fonksiyonlar’ (builtin functions) adı verilir. Bu fonksiyonlara bu adın verilmiş olmasının sebebi, bu fonksiyonların gerçekten de Python programlama dili içine gömülü bir vaziyette olmalarıdır. Dikkat ederseniz kendi yazdığımız fonksiyonları kullanabilmek için öncelikle fonksiyonu tanımlamamız gerekiyor. Gömülü fonksiyonlar ise Python geliştiricileri tarafından halihazırda tanımlanmış olduğu için bunları biz herhangi bir tanımlama işlemi yapmayagerekkalmadandoğrudançağırabiliyoruz. Böylece bir fonksiyonun yapı olarak neye benzediğini üstünkörü de olsa incelemiş olduk. Burayakadaranlatılankısımdabazınoktalarıanlamaktazorlanmışolabilirsiniz.Eğeröyleyse hiçendişelenmeyin.Bugayetdoğal. Gelinistersenizşimdiyukarıdaanlattıklarımızıniçinidoldurmayaçalışalım. 35.3 Fonksiyonların Yapısı İsterseniz biraz da fonksiyonların yapısından söz edelim. Böylelikle ne ile karşı karşıya olduğumuzuanlamakzihninizdebirazdahakolaylaşır. Dedik ki, bir fonksiyonun ilk parçasına ‘fonksiyon tanımı’ (function definition) adı verilir. Bir fonksiyonutanımlamakiçindef adlıbirparçacıktanyararlanıyoruz.Örneğin: def bir_fonksiyon(): (...) Burada def parçacığı, tanımladığımız şeyin bir fonksiyon olduğunu gösteriyor. bir_fonksiyon ifadesiisetanımladığımızbufonksiyonunadıdır.Fonksiyonutanımladıktansonra,çağırırken buadıkullanacağız. def bir_fonksiyon(): ifadesinin sonundaki iki nokta işaretinden de tahmin edebileceğiniz gibi,sonrakisatırayazacağımızkodlargirintiliolacak.Yanimesela: 590 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 def selamla(): print("Elveda Zalim Dünya!") Yukarıdaselamla()adlıbirfonksiyontanımlamışolduk.BufonksiyonungöreviekranaElveda ZalimDünya!çıktısıvermektir. Bunoktadaşöylebirsoruaklageliyor:Acabafonksiyongövdesindekikısımiçinnekadarlıkbir girintioluşturacağız? Girintilemeyeilişkinolaraköncekiderslerdebahsettiğimizbütünkurallarburadadageçerlidir. Fonksiyon gövdesine, def ifadesinden itibaren 4 (dört) boşlukluk bir girinti veriyoruz. def ifadesinden itibaren girintili olarak yazdığımız kısmın tamamı o fonksiyonun gövdesini oluştururvebütünüyleofonksiyonaaittir. Bu kodlarla yaptığımız şey bir fonksiyon tanımlama işlemidir. Eğer bu kodları bir dosyaya kaydedipçalıştırırsakherhangibirçıktıalmayız.Çünkühenüzfonksiyonumuzuçağırmadık.Bu durumu print(), input() ve benzeri gömülü fonksiyonlara benzetebilirsiniz. Tıpkı yukarıda bizim yaptığımız gibi, gömülü fonksiyonlar da Python geliştiricileri tarafından bir yerlerde tanımlanmış vaziyette dururlar, ama biz bu fonksiyonları yazdığımız programlarda çağırana kadarbufonksiyonlarçalışmaz. Dahaöncededediğimizgibi,birfonksiyonunyaşamdöngüsüikiaşamadanoluşur:Fonksiyon tanımıvefonksiyonçağrısı.Yukarıdabudöngününsadecefonksiyontanımıaşamasımevcut. Unutmayın, bir fonksiyon çağrılmadan asla çalışmaz. Bir fonksiyonun çalışabilmesi için o fonksiyonuntanımlandıktansonraçağrılmasıgerekir.Örneğininput()fonksiyonuPython’ın derinliklerindebiryerlerdetanımlanmışvaziyettedurur.Bufonksiyon,bizonuçağıranakadar, bulunduğuyerdesessizcebekler.Aynışekildeselamla()adlıfonksiyondaprogramımıziçinde tanımlanmışvaziyette,bizimonuçağıracağımızanıbekliyor.Busöylediklerimizidestekleyecek açıklayıcı bilgileri biraz sonra vereceğiz. Biz şimdilik fonksiyon tanımı kısmını incelemeye devamedelim. Bu arada yukarıdaki fonksiyon tanımının yapısına çok dikkat edin. İki nokta üst üste işaretindensonrakisatırdagirintiliolarakyazılanbütünkodlar(yanifonksiyonungövdekısmı) fonksiyonunbirparçasıdır.Girintinindışınaçıkıldığıandafonksiyontanımlamaişlemidesona erer. Örneğin: def selamla(): print("Elveda Zalim Dünya!") selamla() İşte burada fonksiyonumuzu çağırmış olduk. Dikkat edin! Dediğim gibi, iki nokta üst üste işaretinden sonraki satırda girintili olarak yazılan bütün kodlar fonksiyona aittir. selamla() satırı ise fonksiyon tanımının dışında yer alır. Bu satırla birlikte girintinin dışına çıkıldığı için artıkfonksiyontanımlamasafhasısonaermişoldu. Bizyukarıdakiörnekte,selamla()adlıfonksiyonutanımlartanımlamazçağırmayıtercihettik. Ama elbette siz bir fonksiyonu tanımlar tanımlamaz çağırmak zorunda değilsiniz. Yazdığınız birprogramiçindefonksiyonlarınızıtanımladıktansonra,ihtiyacınızabağlıolarak,programın herhangibaşkabiryerindefonksiyonlarınızıçağırabilirsiniz. Fonksiyonlarla ilgili söylediklerimizi toparlayacak olursak şöyle bir bilgi listesi ortaya çıkarabiliriz: 35.3. FonksiyonlarınYapısı 591 PythonBelgeleri,Yayım4.1.3 1. Python’dakabacaikitipfonksiyonbulunur.Bunlardanbirigömülüfonksiyonlar(builtin functions), öteki ise özel fonksiyonlardır (custom functions). Burada ‘özel’ ifadesi, ‘kullanıcınınihtiyaçlarınagörekullanıcıtarafındanözelolaraküretilmiş’anlamınagelir. 2. Gömülü fonksiyonlar; Python geliştiricileri tarafından tanımlanıp dilin içine gömülmüş olan print(), open(), type(), str(), int() vb. fonksiyonlardır. Bu fonksiyonlar halihazırda tanımlanıp hizmetimize sunulduğu için bunları biz herhangi bir tanımlama işlemiyapmadandoğrudankullanabiliriz. 3. Özel fonksiyonlar ise, gömülü fonksiyonların aksine, Python geliştiricileri tarafından değil,bizimtarafımızdantanımlanmıştır.Bufonksiyonlardilinbirparçasıolmadığından, bufonksiyonlarıkullanabilmekiçinbunlarıöncelikletanımlamamızgerekir. 4. Python’da bir fonksiyonun yaşam döngüsü iki aşamadan oluşur: Tanımlanma ve çağrılma. 5. Bir fonksiyonun çağrılabilmesi (yani kullanılabilmesi) için mutlaka birisi tarafından tanımlanmışolmasıgerekir. 6. FonksiyonutanımlayankişiPythongeliştiricileriolabileceğigibi,sizdeolabilirsiniz.Ama neticedeortadabirfonksiyonvarsa,biryerlerdeofonksiyonuntanımıdavardır. 7. Fonksiyon tanımlamak için def adlı bir ifadeden yararlanıyoruz. Bu ifadeden sonra, tanımlayacağımız fonksiyonun adını belirleyip iki nokta üst üste işareti koyuyoruz. İki nokta üst üste işaretinden sonra gelen satırlar girintili olarak yazılıyor. Daha önce öğrendiğimizbütüngirintilemekurallarıburadadageçerlidir. 8. Fonksiyonunadınıbelirleyipikinoktaüstüstekoyduktansonra,altsatırdagirintiliolarak yazdığımızbütünkodlarfonksiyonungövdesinioluşturur.Doğalolarak,birfonksiyonun gövdesindekibütünkodlarofonksiyonaaittir.Girintinindışınaçıkıldığıandafonksiyon tanımıdasonaerer. Fonksiyonlarlailgiliöğrendiklerimizitoparladığımızagöre,gelinistersenizfonksiyonlarlailgili birörnekyaparak,buyapıyıdahaiyianlamayaçalışalım: def sistem_bilgisi_göster(): import sys print("\nSistemde kurulu Python’ın;") print("\tana sürüm numarası:", sys.version_info.major) print("\talt sürüm numarası:", sys.version_info.minor) print("\tminik sürüm numarası:", sys.version_info.micro) print("\nKullanılan işletim sisteminin;") print("\tadı:", sys.platform) Burada sistem_bilgisi_göster() adlı bir fonksiyon tanımladık. Bu fonksiyonun görevi, kullanıcınınsistemindekiPythonsürümüveişletimsisteminedairbirtakımbilgilervermektir. Buarada,bukodlarda,dahaöncekiderslerimizdeöğrendiğimizsysmodülündenvebumodül içindekideğişkenlerdenyararlandığımızıgörüyorsunuz.Bukodlardasysmodülününiçindeki şuaraçlarıkullandık: 1. version_info.major:Python’ınanasürümnumarası(Örn.3) 2. version_info.minor:Python’ınaltsürümnumarası(Örn.4) 3. version_info.micro:Python’ınminiksürümnumarası(Örn.0) 592 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 4. platform:Kullanılanişletimsistemininadı(Örn.‘win32’veya‘linux2’) Yukarıdatanımladığımızfonksiyonunasılçağıracağımızıbiliyorsunuz: sistem_bilgisi_göster() Bufonksiyonuntanımınıveçağrısınıeksiksizbirprogramiçindegösterelim: def sistem_bilgisi_göster(): import sys print("\nSistemde kurulu Python’ın;") print("\tana sürüm numarası:", sys.version_info.major) print("\talt sürüm numarası:", sys.version_info.minor) print("\tminik sürüm numarası:", sys.version_info.micro) print("\nKullanılan işletim sisteminin;") print("\tadı:", sys.platform) sistem_bilgisi_göster() Bukodlarıbirdosyayakaydedipçalıştırdığımızdaşunabenzerbirçıktıalacağız: Sistemde kurulu Python’ın; ana sürüm numarası: 3 alt sürüm numarası: 3 minik sürüm numarası: 0 Kullanılan işletim sisteminin; adı: linux Demek ki bu kodların çalıştırıldığı sistem Python’ın 3.3.0 sürümünün kurulu olduğu bir GNU/Linuxişletimsistemiimiş... 35.4 Fonksiyonlar Ne İşe Yarar? Şimdiye kadar söylediklerimizden ve verdiğimiz örneklerden fonksiyonların ne işe yaradığını anlamışolmalısınız.Amabizyinedefonksiyonlarınfaydasıüzerinebirkaçsözdahasöyleyelim. Böylecefonksiyonlarınneişeyaradığıkonusundaaklımızdahiçbirşüphekalmaz... İstersenizbirörneküzerindenilerleyelim. Diyelim ki, bir sayının karesini bulan bir program yazmak istiyoruz. Şimdiye kadarki bilgilerimizikullanarakşöylebirşeyyazabiliriz: sayı = 12 çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(sayı, sayı**2)) Yukarıdakiprogramıçalıştırdığımızdaşöylebirçıktıeldeedeceğiz: 12 sayısının karesi 144 sayısıdır 35.4. FonksiyonlarNeİşeYarar? 593 PythonBelgeleri,Yayım4.1.3 Gayetgüzel.Şimdişöylebirdurumhayaledin:Diyelimkibüyükbirprogramiçinde,farklıfarklı yerlerdeyukarıdakiişlemitekrartekraryapmakistiyorsunuz.Böylebirdurumdaşöylebirşey yazmanızgerekebilir: sayı = 12 çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(sayı, sayı**2)) ####programla ilgili başka kodlar### sayı = 15 print(çıktı.format(sayı, sayı**2)) ###programla ilgili başka kodlar### sayı = 29 print(çıktı.format(sayı, sayı**2)) Buradakisorun,aynışeyleritekrartekraryazmakzorundakalmamızdır.Buküçükörnektepek belliolmuyorolabilir,amaözelliklebüyükprogramlardaaynıkodlarınprogramiçindesürekli olarak tekrarlanması pek çok probleme yol açar. Örneğin kodlarda bir değişiklik yapmak istediğinizde, tekrarlanan kısımları bulup hepsinin üzerinde tek tek değişiklik yapmanız gerekir. Mesela çıktı adlı değişkenin içeriğini değiştirmek isterseniz, yaptığınız değişiklik programınızın pek çok kısmını etkileyebilir. Örneğin, çıktı değişkenini şu şekle getirdiğinizi düşünün: çıktı = "{} sayısının karesi {}, karekökü {} sayısıdır" Böyle bir durumda, program içinde geçen bütün print(çıktı.format(sayı, sayı**2)) satırlarını bulup, üçüncü {} işaretine ait işlemi parantez içine eklemeniz gerekir. Tahmin edebileceğiniz gibi, son derece sıkıcı, yorucu ve üstelik hata yapmaya açık bir işlemdir bu. İştebutürproblemlerekarşıfonksiyonlarçokiyibirçözümdür. Yukarıdabahsettiğimizkarebulmaişlemiiçinşuşekildebasitbirfonksiyontanımlayabiliriz: def kare_bul(): sayı = 12 çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(sayı, sayı**2)) Bufonksiyonutanımladık.Şimdidefonksiyonumuzuçağıralım: kare_bul() Kodlarımıztamolarakşöylegörünüyor: def kare_bul(): sayı = 12 çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(sayı, sayı**2)) kare_bul() 594 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 Burada fonksiyonumuz def kare_bul(): satırıyla başlıyor, print(çıktı.format(sayı, sayı**2)) satırıyla bitiyor. Daha sonra gelen kare_bul() kodu, girintinin dışında yer aldığı içinfonksiyontanımınaaitdeğildir. Bukodlarıbirdosyayakaydedipçalıştırdığımızdaalacağımızçıktışuolacaktır: 12 sayısının karesi 144 sayısıdır kare_bul() adlı fonksiyonu bir kez tanımladıktan sonra bu fonksiyonu programınız içinde gerekenheryerdeçağırabilirsiniz: kare_bul() ####programla ilgili başka kodlar### kare_bul() ###programla ilgili başka kodlar### kare_bul() Gördüğünüz gibi kare_bul() adlı bu fonksiyon bizi pek çok zahmetten kurtarıyor. Ancak bu fonksiyonun bir sorunu var. Bu fonksiyon ekrana yalnızca 12 sayısının karesi 144 sayısıdır çıktısı verebiliyor. Buradaki problem, fonksiyonun sadece 12 sayısı üzerinde işlem yapabilmesi.Şöylebirdüşününce,buçıktınınnekadaranlamsızolduğunu,aslındayukarıdaki fonksiyonuntamamengereksizbirişyaptığınırahatlıklagörebiliyoruz.Fonksiyonumuzunadı kare_bul. Ama dediğimiz gibi, fonksiyonumuz sadece 12 sayısının karesini söyleyebiliyor. Halbukimantıkolarakfonksiyonumuzun,bütünsayılarınkaresinisöyleyebilmesinibeklerdik. (cid:242) Not Buarada,gördüğünüzgibi,yukarıdakifonksiyonparametresizbirfonksiyondur.Dolayısıyla bufonksiyonuçağırırkenparanteziçindeherhangibirdeğerbelirtmiyoruz. Fonksiyonumuzun gerçek anlamda işlevli bir hale gelebilmesi için sadece tek bir sayıyı değil, bütün sayıları inceleyebiliyor olması gerek. İşte fonksiyonumuza bu yeteneği parametreler aracılığıylakazandırabiliriz. Dikkatlicebakın: def kare_bul(sayı): çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(sayı, sayı**2)) Fonksiyona parametre olarak nasıl bir isim verdiğinizin önemi yoktur. Parantez içine parametreolarakistediğinizkelimeyiyazabilirsiniz.Önemliolan,paranteziçindefonksiyonun kaçparametrealacağınıgösterenbirişaretolmasıdır.Meselayukarıdakifonksiyonuşöylede tanımlayabilirdik: def kare_bul(i): çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(i, i**2)) 35.4. FonksiyonlarNeİşeYarar? 595 PythonBelgeleri,Yayım4.1.3 ...veyaşöyle: def kare_bul(osman): çıktı = "{} sayısının karesi {} sayısıdır" print(çıktı.format(osman, osman**2)) Elbette parametre adı olarak akılda kalıcı ve daha mantıklı bir seçim yapmak işlerinizi kolaylaştıracaktır... Şimdideyukarıdakifonksiyonuçağıralım: kare_bul(9) Bufonksiyonuçalıştırdığımızdaşuçıktıyıalırız: 9 sayısının karesi 81 sayısıdır Bu fonksiyona parametre olarak hangi sayıyı verirseniz o sayının karesi hesaplanacaktır. Örneğin: kare_bul(15) kare_bul(25555) Yinebufonksiyonuprogramınıziçindegerekenheryerdeçağırabilirsiniz: kare_bul(17) ####programla ilgili başka kodlar### kare_bul(21) ###programla ilgili başka kodlar### kare_bul(54354) Fonksiyonuoluşturankodlardaherhangibirdeğişiklikyapmakistediğinizdesadecefonksiyon tanımınıngövdesinideğiştirmenizyeterliolacaktır.Örneğin: def kare_bul(sayı): çıktı = "{} sayısının karesi {}, karekökü ise {} sayısıdır" print(çıktı.format(sayı, sayı**2, sayı**0.5)) Bu sayede sadece fonksiyon gövdesinde değişiklik yaparak, programın başka kısımlarını hiç etkilemedenyolumuzadevamedebiliyoruz. Buraya kadar anlattıklarımız, fonksiyonların ne işe yaradığı ve bir program yazarken neden fonksiyonlara ihtiyaç duyacağımız konusunda size bir fikir vermiş olmalı. Eğer hala aklınızda fonksiyonların faydası konusunda bir şüphe kaldıysa, fonksiyonların faydasını anlamanızı sağlayabilmek için size şöyle bir soru sormama izin verin: Acaba ‘’ kelimesinin kaç karakterdenoluştuğununasılbuluruz? ‘Elbettelen()fonksiyonunukullanarak!’dediğiniziduyargibiyim.GerçektendePython’dabir karakterdizisininuzunluğunubulmanıneniyiyolulen()fonksiyonunukullanmaktır: 596 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> len("") 7 Peki ya Python’da len() diye bir fonksiyon olmasaydı ne yapacaktınız? Böyle bir durumda, karakterdizilerininuzunluğunuölçmekiçinsizinbiryöntemicatetmenizgerekecekti.Mesela ‘’kelimesininkaçkarakterdenoluştuğunubulmakiçinşöylebirkodyazacaktınız: c = 0 for s in "": c += 1 print(c) Burada önce c adlı bir değişken tanımlayıp, bu değişkenin değerini 0 yaptık. Bu değişken, uzunluğunusorgulamakistediğimizkelimeninkaçkarakterdenoluştuğubilgisinisaklayacak. Ardından bir for döngüsü tanımlıyoruz. Bu döngüde, ‘’ kelimesindeki her bir karakter için c değişkeninin değerini 1 sayı artırıyoruz. Böylece döngü sonunda c değişkeni ‘’ kelimesiiçindekaçkarakterolduğubilgisinitutmuşoluyor. Sonolarakdacdeğişkenininnihaideğeriniekranayazdırıyoruz. Bu kodları çalıştırdığınızda 7 cevabı alacaksınız. Demek ki ‘’ kelimesinde 7 karakter varmış. Peki ‘’ kelimesi yerine mesela ‘Afyonkarahisar’ kelimesi içinde kaç karakter olduğunu hesaplamak isterseniz ne yapacaksınız? Elbette yukarıdaki kodları tekrar yazıp, ‘’ kelimesini ‘Afyonkarahisar’ kelimesi ile değiştireceksiniz. Böylece bu kelimenin kaç karakterden oluştuğunu bulmuş olacaksınız. Sorgulamak istediğiniz her kelime için aynı şeyleriyapabilirsiniz... Nekadarverimsizbiryöntem,değilmi? Halbuki hiç bu tür şeylerle uğraşmaya gerek yok. Eğer Python bize len() fonksiyonu gibi bir fonksiyonvermemişolsaydı,kendilen()fonksiyonumuzuicatedebilirdik.Dikkatlicebakın: def uzunluk(öğe): c = 0 for s in öğe: c += 1 print(c) Böylece adı uzunluk olan bir fonksiyon tanımlamış olduk. Artık bir öğenin uzunluğunu hesaplamakistediğimizde,bütünokodlarıherdefasındatekrartekraryazmakyerinesadece uzunluk()fonksiyonunukullanabiliriz: uzunluk("") uzunluk("Afyonkarahisar") uzunluk("Tarım ve Köyişleri Bakanlığı") Üstelik bu fonksiyon yalnızca karakter dizilerinin değil öteki veri tiplerinin de uzunluğunu hesaplayabilir: liste = ["ahmet", "mehmet", "veli"] uzunluk(liste) 35.4. FonksiyonlarNeİşeYarar? 597 PythonBelgeleri,Yayım4.1.3 Verdiğimiz bu örnek bize hem gömülü fonksiyonların faydasını, hem de genel olarak fonksiyonların ne işe yaradığını açıkça gösteriyor. Buna göre, len() benzeri gömülü fonksiyonlar tekerleği yeniden icat etme derdinden kurtarıyor bizi. Örneğin Python geliştiricilerininlen()gibibirfonksiyontanımlamışolmalarısayesinde,birkarakterdizisinin uzunluğunu hesaplamak için kendi kendimize yöntem icat etmek zorunda kalmıyoruz. Ama eğerkendiyöntemimiziicatetmemizgerekirse,istediğimizişleviyerinegetirenbirfonksiyon tanımlamamızdamümkün. Böylece temel olarak fonksiyonların ne işe yaradığını, neye benzediğini, nasıl tanımlandığını ve nasıl çağrıldığını incelemiş olduk. Şimdi fonksiyonların biraz daha derinine dalmaya başlayabiliriz. 35.5 Parametreler ve Argümanlar Şimdiye kadar yaptığımız örnekler sayesinde aslında parametrelerin neye benzediğini ve ne işeyaradığınıöğrenmiştik.Bubölümdeisesizi‘argüman’adlıbirkavramlatanıştırıp,argüman ile parametre arasındaki benzerlik ve farklılıkları inceleyeceğiz. Bunun yanısıra, parametre kavramınıdabubölümdedahaderinliklibirşekildeelealacağız. Ohaldehemenyolakoyulalım. Parametrenin ne olduğunu biliyorsunuz. Bunlar fonksiyon tanımlarken parantez içinde belirttiğimiz, fonksiyon gövdesinde yapılan işin değişken öğelerini gösteren parçalardır. Mesela: def kopyala(kaynak_dosya, hedef_dizin): çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!" print(çıktı.format(kaynak_dosya, hedef_dizin)) Burada kopyala() adlı bir fonksiyon tanımladık. Bu fonksiyon toplam iki adet parametre alıyor: kaynak_dosya ve hedef_dizin. Gördüğünüz gibi, bu iki parametre gerçekten de fonksiyon gövdesinde yapılan işin değişken öğelerini gösteriyor. Bu fonksiyonun üreteceği çıktı, fonksiyonu çağıran kişinin bu iki parametreye vereceği değerlere bağlı olarak şekillenecek. Bildiğiniz gibi, parametrelere ne ad verdiğinizin hiçbir önemi yok. Elbette parametrenin görevine uygun bir isim vermeniz fonksiyonunuzun okunaklılığını artıracaktır. Ama tabii ki bufonksiyonupekalaşuparametrelerledetanımlayabilirdik: def kopyala(a, b): çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!" print(çıktı.format(a, b)) Burada önemli olan, parametre görevi görecek iki adet kelime bulmak. Bu kelimelerin ne olduğununönemiyok.Amatabiikikaynak_dosyavehedef_dizinadları,avebadlarınakıyasla, fonksiyondakiparametrelerinyaptığıişiçokdahaiyitarifediyor. Parametre adı belirleme kuralları değişken adı belirleme kurallarıyla aynıdır. Dolayısıyla bir değişkenadıbelirlerkenneyedikkatediyorsak,parametreadıbelirlerkendeaynışeyedikkat etmeliyiz. Gelinşimdiisterseniztanımladığınızbufonksiyonuçağıralım: 598 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 kopyala("deneme.txt", "/home//Desktop") Kodlarımızdosyaiçindetamolarakşöylegörünüyor: def kopyala(kaynak_dosya, hedef_dizin): çıktı = "{} adlı dosya {} adlı dizin içine kopyalandı!" print(çıktı.format(kaynak_dosya, hedef_dizin)) kopyala("deneme.txt", "/home//Desktop") Bukodlarıbirdosyayakaydedipçalıştırdığımızdaşöylebirçıktıalırız: deneme.txt adlı dosya /home//Desktop adlı dizin içine kopyalandı! Gördüğünüz gibi, “deneme.txt” ve “/home//Desktop” değerleri, çıktı adlı karakter dizisindeuygunyerlereyerleştirildiveekranaçıktıolarakverildi.İşteburadagördüğünüzbu “deneme.txt”ve“/home//Desktop”değerlerineargümanadıverilir.Yanibirfonksiyonu tanımlarken belirlediğimiz adlara parametre, aynı fonksiyonu çağırırken belirlediğimiz adlara ise argüman deniyor. Dolayısıyla fonksiyon tanımında belirlediğimiz kaynak_dosya ve hedef_dizin adlı değişkenler birer parametre, fonksiyon çağrısında bu parametrelere karşılık gelen“deneme.txt”ve“/home//Desktop”değerleriisebirerargümanoluyor. Böylece parametre ve argüman arasındaki farkı öğrenmiş olduk. Ancak şunu belirtmekte yarar var: Bu iki kavram genellikle birbirinin yerine kullanılır. Yani bu iki kavram arasındaki, yukarıdaaçıkladığımızfarkapekkimsedikkatetmez.Dolayısıylapekçokyerdehemparametre hemdeargümaniçinaynıifadeninkullanıldığınıgörebilirsiniz.ÖzellikleTürkçedeparametre kelimesi argüman kelimesine kıyasla daha bilinir ve yaygın olduğu için, ayrım yapılmaksızın hem fonksiyon çağrısındaki değerlere, hem de fonksiyon tanımındaki değerlere parametre adıverilir. Gelelimparametrelerinçeşitlerine... Python’da parametreler işlevlerine göre farklı kategorilere ayrılır. Gelin şimdi bu kategorileri tektekinceleyelim. 35.5.1 Sıralı (veya İsimsiz) Parametreler Python’daşöylebirfonksiyontanımlayabileceğimizibiliyoruz: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) Yukarıdatanımladığımızbufonksiyonuşuşekildeçağırabiliriz: 35.5. ParametrelerveArgümanlar 599 PythonBelgeleri,Yayım4.1.3 kayıt_oluştur("Ahmet", "Öz", "Debian", "Ankara") Bu fonksiyonda, yazdığımız parametrelerin sırası büyük önem taşır. Mesela yukarıdaki fonksiyonuşöyleçağırdığımızıdüşünün: kayıt_oluştur("Debian", "Ankara", "Öz", "Ahmet") Eğerfonksiyonparametrelerinibusıraylakullanırsakaldığımızçıktıhatalıolacaktır: ------------------------------ isim : Debian soyisim : Ankara işletim sistemi: Öz şehir : Ahmet ------------------------------ Gördüğünüzgibi,isim,soyisimveötekibilgilerbirbirinekarışmış.İştePython’da,verilişsırası önemtaşıyanbutürparametrelere‘sıralıparametreler’(veyaisimsizparametreler)adıverilir. 35.5.2 İsimli Parametreler Biröncekibölümdeverdiğimizşuörneğiyenidenelealalım: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) Bufonksiyonuçağırırkenparametrelerinsırasınıdoğruvermenin,alacağımızçıktınındüzgün olması bakımından büyük önem taşıdığını biliyoruz. Ancak özellikle parametre sayısının çok olduğu fonksiyonlarda parametre sırasını akılda tutmak zor olabilir. Böyle durumlarda parametreleriisimleriilebirliktekullanmayıtercihedebiliriz: kayıt_oluştur(soyisim="Öz", isim="Ahmet", işsis="Debian", şehir= "Ankara") Böylece fonksiyon parametrelerini istediğimiz sıra ile kullanabiliriz. Ancak burada dikkat etmemiz gereken bazı noktalar var. Python’da isimli bir parametrenin ardından sıralı bir parametregelemez.Yanişukullanımyanlıştır: kayıt_oluştur(soyisim="Öz", isim="Ahmet", "Debian", "Ankara") Bukodlarbizeşuhatayıverir: File "<stdin>", line 1 SyntaxError: non-keyword arg after keyword arg 600 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 Bu yüzden, eğer isimli parametreler kullanacaksak, isimli parametrelerden sonra sıralı parametrekullanmamayadikkatediyoruz. 35.5.3 Varsayılan Değerli Parametreler Şimdiyekadarkarşılaştığımızfonksiyonlardabirşeydikkatiniziçekmişolmalı.Meselaprint() fonksiyonunuelealalım.Bildiğinizgibi,bufonksiyonuenbasitşekildeşöylekullanıyoruz: print("Fırat", "Özgül") Evet, print() fonksiyonunu bu şekilde kullanabiliyoruz, ancak bildiğiniz gibi, aslında bu fonksiyonunbazıözelparametreleridevar.Dahaöncekiderslerimizdenhatırlayacağınızgibi, bizyukarıdakikomutuverdiğimizdeaslındaPythonbunuşuşekildealgılıyor: print("Fırat", "Özgül", sep=" ", end="\n", file=sys.stdout, flush=False) Yani biz görmesek de aslında her print() çağrısı sep, end, file ve flush parametrelerini de içeriyor. Biz bu özel parametreleri kullanmasak da, yazdığımız kod düzgün bir şekilde çalışır. Bunun nedeni, sep, end, file ve flush parametrelerinin öntanımlı olarak birtakım değerlere sahip olmasıdır. Yani biz bu parametrelere kendimiz bir değer atamazsak Python bu parametrelere kendi belirlediği bazı öntanımlı değerleri atayacaktır. Dolayısıyla, eğer biz başka bir değer yazmazsak, sep parametresi “ “ değerine, end parametresi “n” değerine, file parametresisys.stdoutdeğerine,flushparametresiiseFalsedeğerinesahipolacaktır.İştebu tür parametrelere Python’da ‘varsayılan değerli parametreler’ adı verilir. Peki biz kendimiz varsayılandeğerliparametreleriçerenfonksiyonlarınasıltanımlayabiliriz? Şuörneğedikkatlicebakın: def kur(kurulum_dizini="/usr/bin/"): print("Program {} dizinine kuruldu!".format(kurulum_dizini)) Burada kur() adlı bir fonksiyon tanımladık. Bu fonksiyonun görevi, yazdığımız bir programı, kullanıcının bilgisayarındaki bir dizine kurmak ve programın hangi dizine kurulduğu konusundakullanıcıyıbilgilendirmek.Bufonksiyonuşuşekildeçağırabiliriz: kur() Eğerkur()fonksiyonunuböyleçağırırsakbizeşuçıktıyıverecektir: Program /usr/bin/ dizinine kuruldu! Gördüğünüzgibi,kur()fonksiyonununkurulum_diziniadlıbirparametresivar.Bizfonksiyonu tanımlarken,buparametreyebirvarsayılandeğeratadık(/usr/bin/).Böylecekur()fonksiyonu parametresiz olarak çağrıldığında bu varsayılan değer devreye girdi. Eğer biz bu değeri değiştirmek istersek, mesela programımızın “C:\Users\firat” dizinine kurulmasını istersek, kur()fonksiyonunuşöyleçağırmalıyız: kur("C:\\Users\\firat") kur()fonksiyonunuyukarıdakigibiçağırdığımızdaPythonbizeşöylebirçıktıverir: Program C:\Users\firat dizinine kuruldu! 35.5. ParametrelerveArgümanlar 601 PythonBelgeleri,Yayım4.1.3 Bu örnek size, varsayılan değerli parametreler belirlemenin ne kadar faydalı olabileceğini göstermiş olmalı. Mesela bir program yazdığınızı düşünün. Programınızı indiren kullanıcılar, yukarıdaki gibi bir varsayılan değerli parametre belirlemiş olmanız sayesinde programınızı nereye kuracaklarını belirlemek zorunda kalmadan bir sonraki kurulum adımına geçebiliyorlar... Elbette eğer isterseniz kullanıcılarınızı bir kurulum dizini belirlemeye zorlamak da isteyebilirsiniz.Bununiçinyinevarsayılandeğerliparametrelerdenyararlanabilirsiniz: def kur(kurulum_dizini=’’): if not kurulum_dizini: print("Lütfen programı hangi dizine kurmak istediğinizi belirtin!") else: print("Program {} dizinine kuruldu!".format(kurulum_dizini)) Bu defa kurulum_dizini parametresinin varsayılan değerini boş bir karakter dizisi olarak belirledik. Eğer bu parametrenin değeri boş bir karakter dizisi olursa, kullanıcı herhangi bir kurulum dizini belirtmemiş demektir. Eğer kullanıcı herhangi bir kurulum dizini belirtmezse kurulum_diziniparametresininbooldeğeriFalseolacaktır.Buözelliğidikkatealarakfonksiyon gövdesindeşukodlarıkullanabiliyoruz: if not kurulum_dizini: print("Lütfen programı hangi dizine kurmak istediğinizi belirtin!") Böylece, kurulum_dizini parametresinin bool değeri False olursa kullanıcılarımıza şöyle bir uyarıgösteriyoruz: "Lütfen programı hangi dizine kurmak istediğinizi belirtin!" Dolayısıyla kuruluma başlayabilmek için kur() fonksiyonunun şöyle çalıştırılmasını zorunlu tutuyoruz: kur("C:\\Users\\") Buna benzer durumlarla pek çok kez karşılaşmış olmalısınız. Özellikle programların kurulmasını sağlayan ‘setup’ betiklerinde her aşama için bir varsayılan değer belirlenip, kullanıcının sadece ‘Next’ tuşlarına basarak sağlıklı bir kurulum yapması sağlanabiliyor. Eğer kullanıcıvarsayılandeğerlerindışındabirtakımdeğerlerbelirlemekisterse,yukarıdaörneğini verdiğimizyapıkullanıcıyaböylebirözgürlükdesağlıyor. 35.5.4 Rastgele Sayıda İsimsiz Parametre Belirleme Şimdiye kadar öğrendiğimiz pek çok fonksiyonun toplam kaç parametre alabileceği bellidir. Örneğin input() fonksiyonu yalnızca tek bir parametre alabilir. Eğer bu fonksiyona birden fazlaparametreverirsekPythonbizebirhatamesajıgösterecektir.Aynışekildemeselapow() fonksiyonunun da kaç parametre alabileceği bellidir. Ama örneğin print() fonksiyonuna verebileceğimizparametresayısı(teknikolarak256ilesınırlıolsada)pratikolarakneredeyse sınırsızdır. Pekiacababizkendimiz,sınırsızparametrealabilenfonksiyonlarüretebilirmiyiz? Busorununcevabı‘evet’olacaktır.Şimdişuörneğedikkatlicebakın: 602 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 def fonksiyon(*parametreler): print(parametreler) fonksiyon(1, 2, 3, 4, 5) Bukodlarıçalıştırdığımızdaşuçıktıyıalacağız: (1, 2, 3, 4, 5) Gördüğünüzgibi,fonksiyontanımıiçindekullandığımız*işaretisayesindefonksiyonumuzun pratik olarak sınırsız sayıda parametre kabul etmesini sağlayabiliyoruz. Bu arada, bu tür fonksiyonların alabileceği parametre sayısı, dediğimiz gibi, pratikte sınırsızdır, ama teknik olarakbusayı256adedigeçemez. Yukarıdakikodlarınverdiğiçıktınınbirdemetolduğunadikkatiniziçekmekisterim.Bubilgiye sahip olduktan sonra, bu tür fonksiyonları demet işleme kurallarına göre istediğiniz şekilde manipüleedebilirsiniz. Pekiböylebirfonksiyontanımlamakneişimizeyarar? Meselabuyapıyıkullanarakşöylebirfonksiyonyazabilirsiniz: def çarp(*sayılar): sonuç = 1 for i in sayılar: sonuç *= i print(sonuç) Bufonksiyonkendisineverilenbütünparametreleribirbiriyleçarpar.Örneğin: çarp(1, 2, 3, 4) Bukodunçıktısı24olacaktır.Gördüğünüzgibi,fonksiyonumuzaistediğimizsayıdaparametre vererekbusayılarınbirbiriyleçarpılmasınısağlayabiliyoruz. Aslında burada kullandığımız * işareti size hiç yabancı değil. Hatırlarsanız print() fonksiyonundanbahsederkenşunabenzerbirkullanımörneğivermiştik: >>> print(*’TBMM’, sep=’.’) T.B.M.M Burada * işareti, eklendiği parametreyi öğelerine ayırıyor. sep parametresi ise * işaretinin birbirindenayırdığıöğelerinarasınabirer‘.’karakteriekliyor. Buişaretinetkilerinişuörneklerdedahanetgörebilirsiniz: >>> liste = ["Ahmet", "Mehmet", "Veli"] >>> print(*liste) Ahmet Mehmet Veli >>> sözlük = {"a": 1, "b": 2} >>> print(*sözlük) (sonrakisayfayadevam) 35.5. ParametrelerveArgümanlar 603 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) a b Gördüğünüzgibi,*işaretiherhangibiröğeyialıp,bunuparçalarınaayırıyor.İştebu*işaretini fonksiyontanımlarkenkullandığımızdaisebuişlemintamtersigerçekleşiyor.Yanifonksiyon tanımındaparametreninsoluna*getirdiğimizde,bufonksiyonçağrılırkenverilenargümanlar tekbirdeğişkeniçindebirdemetolaraktoplanıyor.Zatenbukonununbaşındaverdiğimizşu örnektedebudurumaçıkçagörünüyor: def fonksiyon(*parametreler): print(parametreler) fonksiyon(1, 2, 3, 4, 5) Bufonksiyonuçağırdığımızdaşuçıktıveriliyor: (1, 2, 3, 4, 5) Aynen söylediğimiz gibi, fonksiyon() adlı fonksiyona argüman olarak verdiğimiz her bir öğenin(1,2,3,4,5)tekbirdemetiçindetoplandığınıgörüyorsunuz. Yıldızlı parametreler, tanımladığınız fonksiyonun parametre sayısını herhangi bir şekilde sınırlamakistemediğinizdurumlardaçokişinizeyarar. Elbette * işaretiyle birlikte kullanacağınız parametrenin adı olarak, Python’ın değişken adlandırma kurallarına uygun bütün kelimeleri belirleyebilirsiniz. Mesela biz yukarıda ‘parametreler’ adını tercih ettik. Ama Python dünyasında * işaretiyle birlikte kullanılacak parametrenin adı geleneksel olarak, ‘argümanlar’ anlamında ‘args’tır. Yani Python programcılarıgenellikleyukarıdakigibibirfonksiyonuşöyletanımlar: def fonksiyon(*args): ... * işareti ile birlikte kullanılacak parametrenin adını ‘args’ yapmak bir zorunluluk olmamakla birlikte, başka Python programcılarının kodlarınızı daha kolay anlayabilmesi açısından bu geleneği devamettirmenizi tavsiyeederim. Yazdığımız kodlardaPython programlama dilinin geleneklerinebağlıkalmakçoğunluklaiyibiralışkanlıktır. 35.5.5 Rastgele Sayıda İsimli Parametre Belirleme Bir önceki başlık altında, fonksiyon tanımlarken rastgele sayıda isimsiz parametrelerin nasıl belirleneceğini tartıştık. Aynı bu şekilde, rastgele sayıda isimli parametre belirlemek de mümkündür. Örneğin: def fonksiyon(**parametreler): print(parametreler) fonksiyon(isim="Ahmet", soyisim="Öz", meslek="Mühendis", şehir="Ankara") Bukodlarıçalıştırdığımızdaşöylebirçıktıalıyoruz: 604 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 {’isim’: ’Ahmet’, ’soyisim’: ’Öz’, ’meslek’: ’Mühendis’, ’şehir’: ’Ankara’} Gördüğünüz gibi, fonksiyonu tanımlarken parametremizin sol tarafına yerleştirdiğimiz ** işareti, bu fonksiyonu çağırırken yazdığımız isimli parametrelerin bize bir sözlük olarak verilmesini sağlıyor. Bu yapının bize bir sözlük verdiğini bildikten sonra, bunu sözlük veri tipininkurallarıçerçevesindeistediğimizşekildeeviripçevirebiliriz. Pekibuaraçneişimizeyarar? Hatırlarsanızbubölümünenbaşındakayıt_oluştur()adlışöylebirfonksiyontanımlamıştık: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) Bu fonksiyon bize toplam dört adet parametre kullanarak, isim, soyisim, işletim sistemi ve şehir bilgilerinden meydana gelen bir kayıt oluşturma imkanı sağlıyor. Bu fonksiyonda kullanıcınıngirebileceğibilgilersınırlı.Amabirdeşöylebirfonksiyonyazdığımızıdüşünün: def kayıt_oluştur(**bilgiler): print("-"*30) for anahtar, değer in bilgiler.items(): print("{:<10}: {}".format(anahtar, değer)) print("-"*30) kayıt_oluştur(ad="Fırat", soyad="Özgül", şehir="İstanbul", tel="05333213232") Bufonksiyonuçalıştırdığımızdaşuçıktıyıalacağız: tel : 05333213232 ad : Fırat şehir : İstanbul soyad : Özgül Gördüğünüz gibi, ** işaretlerini kullanmamız sayesinde hem adlarını hem de değerlerini kendimiz belirlediğimiz bir kişi veritabanı oluşturma imkanı elde ediyoruz. Üstelik bu veritabanının,kişiyeaitkaçfarklıbilgiiçereceğinidetamamenkendimizbelirleyebiliyoruz. Tıpkı*işaretlerininbetimlediğiparametreningelenekselolarak‘args’şeklindeadlandırılması gibi,**işaretlerininbetimlediğiparametredegelenekselolarak‘kwargs’şeklindeadlandırılır. DolayısıylayukarıdakigibibirfonksiyonuPythonprogramcılarışöyletanımlar: def kayıt_oluştur(**kwargs): ... 35.5. ParametrelerveArgümanlar 605 PythonBelgeleri,Yayım4.1.3 **işaretliparametrelerpekçokfarklıdurumdaişinizeyarayabilirveyaişinizikolaylaştırabilir. Mesela*ve**işaretlerinikullanarakşöylebirprogramyazabilirsiniz: def karşılık_bul(*args, **kwargs): for sözcük in args: if sözcük in kwargs: print("{} = {}".format(sözcük, kwargs[sözcük])) else: print("{} kelimesi sözlükte yok!".format(sözcük)) sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} karşılık_bul("kitap", "bilgisayar", "programlama", "fonksiyon", **sözlük) Burada tanımladığımız karşılık_bul() adlı fonksiyon, kendisine verilen parametreleri (*args), bir sözlük içinde arayarak (**sözlük) karşılıklarını bize çıktı olarak veriyor. Eğer verilen parametre sözlükte yoksa, ilgili kelimenin sözlükte bulunmadığı konusunda da bizi bilgilendiriyor. karşılık_bul()adlıfonksiyonunasıltanımladığımızaçokdikkatedin.Parametrelistesiiçinde belirttiğimiz *args ifadesi sayesinde, fonksiyonu kullanacak kişiye, istediği sayıda isimsiz parametregirmeimkanıtanıyoruz.**kwargsparametresiisekullanıcıyaistediğisayıdaisimli parametregirmeolanağıveriyor. Esasındayukarıdakikod*argsve**kwargsyapılarıaçısındanucuzbirörnektir.Buyapılariçin dahaniteliklibirörnekverelim... Bildiğiniz gibi print() fonksiyonu sınırsız sayıda isimsiz parametre ve buna ek olarak birkaç tane de isimli parametre alıyor. Bu fonksiyonun alabildiği isimli parametrelerin sep, end, file ve flush adlı parametreler olduğunu biliyorsunuz. Yine bildiğiniz gibi, sep parametresi print() fonksiyonuna verilen isimsiz parametrelerin her birinin arasına hangi karakterin geleceğini; end parametresi ise bu parametrelerin en sonuna hangi karakterin geleceğini belirliyor. Bizim amacımız bu fonksiyona bir de start adında isimli bir parametre ekleyerek print() fonksiyonunun işlevini genişleten başka bir fonksiyon yazmak. Bu yeni parametre, karakterdizilerininenbaşınahangikarakteringeleceğinibelirleyecek. Şimdibuamacımızıgerçekleştirecekkodlarımızıyazalım: def bas(*args, start=’’, **kwargs): for öğe in args: print(start+öğe, **kwargs) bas(’öğe1’, ’öğe2’, ’öğe3’, start="#.") print() fonksiyonunun işlevini genişleten yeni fonksiyonumuzun adı bas(). Bu fonksiyon her bakımdan print() fonksiyonu ile aynı işlevi görecek. Ancak bas() fonksiyonu, print() fonksiyonuna ek olarak, sahip olduğu start adlı bir isimli parametre sayesinde, kendisine verilenparametrelerinenbaşınaistediğimizherhangibirkarakterieklemeolanağıdaverecek bize. bas() fonksiyonunun ilk parametresi olan *args sayesinde kullanıcıya istediği kadar 606 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 parametrevermeimkanıtanıyoruz.Dahasonradailavestartparametresinitanımlıyoruz.Bu parametrenin öntanımlı değeri boş bir karakter dizisi. Yani eğer kullanıcı bu parametrenin değerine herhangi bir şey yazmazsa, *args kapsamında verilen parametreler üzerinde hiçbir değişiklik yapmıyoruz. Bunun ardından gelen **kwargs parametresi ise print() fonksiyonunun halihazırda sahip olduğu sep, end, file ve flush parametrelerinin bas() fonksiyonunda da aynı şekilde kullanılmasını sağlıyor. **kwargs şeklinde bir tanımlama sayesinde,print()fonksiyonununisimliparametrelerinitektekbelirtiptanımlamakzorunda kalmıyoruz: def bas(*args, start=’’, **kwargs): for öğe in args: print(start+öğe, **kwargs) f = open("te.txt", "w") bas(’öğe1’, ’öğe2’, ’öğe3’, start="#.", end="", file=f) Eğer elimizde **kwargs gibi bir imkan olmasaydı yukarıdaki fonksiyonu şu şekilde tanımlamamızgerekirdi: import sys def bas(*args, start=’’, sep=’ ’, end=’\n’, file=sys.stdout, flush=False): for öğe in args: print(start+öğe, sep=sep, end=end, file=file, flush=flush) Gördüğünüzgibi,print()fonksiyonununbütünisimliparametrelerinivebunlarınöntanımlı değerlerini tanımlamak zorunda kaldık. Eğer günün birinde Python geliştiricileri print() fonksiyonuna bir başka isimli parametre daha eklerse, yukarıdaki fonksiyonu ilgili yeniliğe göre elden geçirmemiz gerekir. Ama **kwargs yapısını kullandığımızda, print() fonksiyonuna Python geliştiricilerince eklenecek bütün parametreler bizim fonksiyonumuza daotomatikolarakyansıyacaktır... 35.6 return Deyimi Bu bölümde return adlı bir deyimden söz edeceğiz. Özellikle Python programlama dilini öğrenmeyeyenibaşlayanlarbudeyiminneişeyaradığınıanlamaktazorlanabiliyor.Bizburada bu deyimi anlaşılır hale getirebilmek için elimizden geleni yapacağız. Öncelikle çok basit bir örnekverelim: def ismin_ne(): isim = input("ismin ne? ") print(isim) Buçokbasitbirfonksiyon.Bufonksiyonunasılçağıracağımızıbiliyoruz: ismin_ne() Fonksiyonu bu şekilde çağırdıktan sonra, fonksiyon tanımında yer alan input() fonksiyonu sayesindekullanıcıyaismisorulacakveverdiğicevapekranabasılacaktır. 35.6. returnDeyimi 607 PythonBelgeleri,Yayım4.1.3 Yukarıdaki fonksiyonun tek işlevi kullanıcıdan aldığı isim bilgisini ekrana basmaktır. Aldığınız bu veriyi başka yerlerde kullanamazsınız. Bu fonksiyonu çağırdığınız anda kullanıcıya ismi sorulacak ve alınan cevap ekrana basılacaktır. Ancak siz, tanımladığınız fonksiyonların tek görevininbirveriyiekranabasmakolmasınıistemeyebilirsiniz. Örneğin yukarıdaki fonksiyon yardımıyla kullanıcıdan ismini aldıktan sonra, bu isim bilgisini başka bir karakter dizisi içinde kullanmak isteyebilirsiniz. Diyelim ki amacınız ismin_ne() fonksiyonuylaaldığınızismişukarakterdizisiiçineaşağıdakişekildeyerleştirmek: Merhaba Fırat. Nasılsın? Bildiğimizyöntemikullanarakbuamacımızıgerçekleştirmeyeçalışalım: print("Merhaba {}. Nasılsın?".format(ismin_ne())) Buradanşöylebirçıktıalıyoruz: ismin ne? Fırat Fırat Merhaba None. Nasılsın? Gördüğünüz gibi, istediğimiz şeyi elde edemiyoruz. Çünkü dediğimiz gibi, yukarıdaki fonksiyonun tek görevi kullanıcıdan aldığı çıktıyı ekrana basmaktır. Bu fonksiyondan gelen çıktıyı başka yerde kullanamayız. Eğer kullanmaya çalışırsak yukarıdaki gibi hiç beklemediğimizbirsonuçalırız. Buarada,çıktıdaNonediyebirşeygördüğünüzedikkatedin.Yukarıdakifonksiyonuşuşekilde çağırarakbunudahanetgörebilirsiniz: print(ismin_ne()) Buradanşuçıktıyıalıyoruz: ismin ne? Fırat Fırat None Bu çıktının ne anlama geldiğini birazdan açıklayacağız. Ama öncelikle başka bir konudan söz edelim. Biraz önce söylediğimiz gibi, yukarıda tanımladığımız ismin_ne() adlı fonksiyonun tek görevi kullanıcıdan aldığı isim bilgisini ekrana basmaktır. Şimdi bu fonksiyonu bir de şöyle tanımlayalım: def ismin_ne(): isim = input("ismin ne? ") return isim Şimdidebufonksiyonuçağıralım: ismin_ne() Gördüğünüz gibi, fonksiyonu çağırdığımızda yalnızca fonksiyon gövdesindeki input() fonksiyonu çalıştı, ama bu fonksiyondan gelen veri ekrana çıktı olarak verilmedi. Çünkü biz 608 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 burada herhangi bir ekrana basma (‘print’) işlemi yapmadık. Yaptığımız tek şey isim adlı değişkeni‘döndürmek’. Pekibuneanlamageliyor? return kelimesi İngilizcede ‘iade etmek, geri vermek, döndürmek’ gibi anlamlar taşır. İşte yukarıdaki örnekte de return deyiminin yaptığı iş budur. Yani bu deyim bize fonksiyondan birdeğer‘döndürür’. Eğer tanımladığımız bir fonksiyonda return deyimini kullanarak herhangi bir değer döndürmezsek, Python fonksiyondan hususi bir değerin döndürülmediğini göstermek için ‘None’ adlı bir değer döndürür... İşte yukarıda tanımladığımız ilk ismin_ne() fonksiyonunu print(ismin_ne()) şeklinde çağırdığımızda ekranda None değerinin görünmesinin nedeni budur. Peki bir fonksiyon içinde herhangi bir veriyi ekrana basmayıp return deyimi yardımıyla döndürmemizinbizenefaydasıvar? Aslında bunun cevabı çok açık. Bir fonksiyon içinde bir değeri döndürmek yerine ekrana bastığınızda o fonksiyonun işlevini alabildiğine kısıtlamış oluyorsunuz. Fonksiyonunuzun tek işlevibirdeğeriekranabasmakoluyor.Şuörnektedegösterdiğimizgibi,budeğeridahasonra başkaortamlardakullanamıyoruz: def ismin_ne(): isim = input("ismin ne? ") print(isim) print("Merhaba {}. Nasılsın?".format(ismin_ne())) Ama eğer, mesela yukarıdaki fonksiyonda isim değişkenini basmak yerine döndürürsek işler değişir: def ismin_ne(): isim = input("ismin ne? ") return isim print("Merhaba {}. Nasılsın?".format(ismin_ne())) Bukodlarıçalıştırdığımızdaşuçıktıyıalıyoruz: .. code-block:: pycon isminne?FıratMerhabaFırat.Nasılsın? Gördüğünüz gibi, istediğimiz çıktıyı rahatlıkla elde ettik. ismin_ne() adlı fonksiyondan isim değerini döndürmüş olmamız sayesinde bu değerle istediğimiz işlemi gerçekleştirebiliyoruz. Yani bu değeri sadece ekrana basmakla sınırlamıyoruz kendimizi. Hatta fonksiyondan döndürdüğümüzdeğeribaşkabirdeğişkeneatamaimkanınadahisahibizbuşekilde: ad = ismin_ne() print(ad) Eğer fonksiyondan değer döndürmek yerine bu değeri ekrana basmayı tercih etseydik yukarıdakiişlemiyapamazdık. returndeyimiyleilgilisonbirşeydahasöyleyelim... 35.6. returnDeyimi 609 PythonBelgeleri,Yayım4.1.3 Bu deyim, içinde bulunduğu fonksiyonun çalışma sürecini kesintiye uğratır. Yani return deyiminikullandığınızsatırdansonragelenhiçbirkodçalışmaz.Basitbirörnekverelim: def fonk(): print(3) return print(5) fonk() Bu kodları çalıştırdığınızda yalnızca print(3) satırının çalıştığını, print(5) satırına ise hiç ulaşılmadığını göreceksiniz. İşte bu durumun sebebi, Python’ın kodları return satırından itibarenokumayıbırakmasıdır.Buözelliktençeşitlişekillerdeyararlanabilirsiniz.Örneğin: def fonk(n): if n < 0: return ’eksi değerli sayı olmaz!’ else: return n f = fonk(-5) print(f) Burada eğer fonksiyona parametre olarak eksi değerli bir sayı verilirse Python bize bir uyarı verecekvefonksiyonunçalışmasınıdurduracaktır. 35.7 Örnek bir Uygulama Gelin isterseniz buraya kadar öğrendiklerimizi kullanarak örnek bir uygulama yazalım. Bir yandandayenişeyleröğrenerekbilgimizebilgikatalım. Amacımızbellimiktardavebelliaralıktarastgelesayılarüretenbirprogramyazmak.Örneğin programımızşuşekildealtıadetrastgelesayıüretebilecek: 103, 298, 152, 24, 91, 285 Ancak programımız bu sayıları üretirken her sayıdan yalnızca bir adet üretecek. Yani aynı seridebirsayıdanbirdenfazlabulunamayacak. Dilersenizönceliklekodlarımızıgörelim: import random def sayı_üret(başlangıç=0, bitiş=500, adet=6): sayılar = set() while len(sayılar) < adet: sayılar.add(random.randrange(başlangıç, bitiş)) return sayılar 610 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 Esasında bu kodların (neredeyse) tamamını anlayabilecek kadar Python bilgisine sahipsiniz. Burada anlamamış olabileceğiniz tek şey random modülüdür. O yüzden gelin isterseniz bu modüldenbirazsözedelim. Biz henüz modül kavramını bilmiyoruz. Ama buraya gelene kadar birkaç konu altında modüllerle ilgili bazı örnekler de yapmadık değil. Örneğin şimdiye kadar yazdığımız programlardan öğrendiğimiz kadarıyla Python’da os ve sys adlı iki modülün bulunduğunu, bu modüllerin içinde, program yazarken işimize yarayacak pek çok değişken ve fonksiyon bulunduğunuve bufonksiyonlarıprogramlarımızdakullanabilmekiçin ilkinbumodülleri içe aktarmamız gerektiğini biliyoruz. İşte tıpkı os ve sys gibi, random da Python programlama dilibünyesindebulunanmodüllerdenbiridir.Bumodülüniçinde,rastgelesayılarüretmemizi sağlayacak bazı fonksiyonlar bulunur. İşte randrange() de bu fonksiyonlardan biridir. Dilersenizbufonksiyonunnasılkullanıldığınıanlamakiçinetkileşimlikabuktabirkaçdeneme çalışmasıyapalım. randommodülününiçindekiaraçlarıkullanabilmekiçinönceliklebumodülüiçeaktarmalıyız: >>> import random Acababumodülüniçindenelervarmış? >>> dir(random) [’BPF’, ’LOG4’, ’NV_MAGICCONST’, ’RECIP_BPF’, ’Random’, ’SG_MAGICCONST’, ’SystemRandom’, ’TWOPI’, ’_BuiltinMethodType’, ’_MethodType’, ’_Sequence’, ’_Set’, ’__all__’, ’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__initializing__’, ’__loader__’, ’__name__’, ’__package__’, ’_acos’, ’_ceil’, ’_cos’, ’_e’, ’_exp’, ’_inst’, ’_log’, ’_pi’, ’_random’, ’_sha512’, ’_sin’, ’_sqrt’, ’_test’, ’_test_generator’, ’_urandom’, ’_warn’, ’betavariate’, ’choice’, ’expovariate’, ’gammavariate’, ’gauss’, ’getrandbits’, ’getstate’, ’lognormvariate’, ’normalvariate’, ’paretovariate’, ’randint’, ’random’, ’randrange’, ’sample’, ’seed’, ’setstate’, ’shuffle’, ’triangular’, ’uniform’, ’vonmisesvariate’, ’weibullvariate’] Gördüğünüz gibi bu modülün içinde epey araç var. Gelin isterseniz bu araçlardan en sık kullanılanlarınıtanıyalım. Örneğin random modülü içinde bulunan sample() adlı fonksiyon herhangi bir dizi içinden istediğimizsayıdarastgelenumunealmamızısağlar: >>> liste = ["ahmet", "mehmet", "sevgi", "sevim", "selin", "zeynep", "selim"] >>> random.sample(liste, 2) [’sevim’, ’ahmet’] Gördüğünüz gibi, yedi kişilik bir isim listesinden 2 adet rastgele numune aldık. Aynı işlemi tekrarlayalım: >>> random.sample(liste, 2) [’sevgi’, ’zeynep’] (sonrakisayfayadevam) 35.7. ÖrnekbirUygulama 611 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> random.sample(liste, 5) [’selin’, ’zeynep’, ’ahmet’, ’selim’, ’mehmet’] Numunealmaişlemitamamenrastgeledir.Ayrıcagördüğünüzgibi,listedenistediğimizsayıda numunealabiliyoruz. randommodülüiçindebulunanshuffle()adlıbaşkabirfonksiyon,birdiziiçindekiöğelerin sırasınırastgelebirşekildekarıştırmamızısağlar: >>> liste = ["ahmet", "mehmet", "sevgi", "sevim", ... "selin", "zeynep", "selim"] >>> random.shuffle(liste) shuffle() fonksiyonu liste öğelerini yine aynı liste içinde değiştirdi. Değişikliği görmek için listeyiekranabasabilirsiniz: >>> liste [’selim’, ’selin’, ’ahmet’, ’mehmet’, ’sevim’, ’sevgi’, ’zeynep’] random modülü içinde bulunan bir başka fonksiyon ise randrange() fonksiyonudur. Bu fonksiyon,bellibiraralıktarastgelesayılarüretmemizisağlar: >>> random.randrange(0, 500) 156 Burada0ile500arasındarastgelebirsayıürettik. Gördüğünüzgibirandomsonderecefaydalıolabilecekbirmodüldür.Dilersenizşimdirandom modülünübirkenarabırakıpkodlarımızageridönelim: import random def sayı_üret(başlangıç=0, bitiş=500, adet=6): sayılar = set() while len(sayılar) < adet: sayılar.add(random.randrange(başlangıç, bitiş)) return sayılar Burada ilk satırın ne iş yaptığını öğrendik. Bu satır yardımıyla random modülünü içe aktarıyoruz. Sonrakisatırdafonksiyonumuzutanımlamayabaşlıyoruz: def sayı_üret(başlangıç=0, bitiş=500, adet=6): ... 612 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 Fonksiyonumuzun adı sayı_üret. Bu fonksiyon toplam üç farklı parametre alıyor. Bunlar başlangıç, bitiş ve adet. Dikkat ederseniz bu parametrelerin her birinin bir varsayılan değeri var. Dolayısıyla sayı_üret() fonksiyonu parametresiz olarak çağrıldığında bu üç parametre öntanımlıdeğerlerinesahipolacaktır. Gelelimfonksiyongövdesine... İlkolaraksayılaradlıbirkümetanımlıyoruz. Bildiğiniz gibi, kümeler içinde öğeler her zaman tektir. Yani bir küme içinde aynı öğeden yalnızca bir adet bulunabilir. Kümelerin bu özelliği bizim yazdığımız program için oldukça uygun.Çünkübizdeürettiğimizrastgelesayılarınbenzersizolmasınıistiyoruz.Bubenzersizliği sağlayabilecekenuygunveritipikümelerdir. Birsonrakisatırdabirwhiledöngüsügörüyoruz: while len(sayılar) < adet: sayılar.add(random.randrange(başlangıç, bitiş)) Bu döngüye göre, sayılar değişkeninin uzunluğu adet parametresinin değerinden az olduğu müddetçe, sayılar adlı değişkene başlangıç ve bitiş parametrelerinin gösterdiği değerler arasından rastgele sayılar eklemeye devam edeceğiz. Örneğin kullanıcı fonksiyonumuzu parametresizolarakçağırdıysa,yukarıdakidöngüşuşekildeişleyecektir: while len(sayılar) < 6: sayılar.add(random.randrange(0, 500)) Buna göre, sayılar değişkeninin uzunluğu 6’dan az olduğu müddetçe bu değişkene 0 ile 500 arasında rastgele sayılar eklemeye devam edeceğiz. Böylelikle sayılar değişkeni içinde birbirindenfarklıtoplam6sayıolmuşolacak. Fonksiyonunsonsatırındaiseşukodugörüyoruz: return sayılar Bu kod yardımıyla, belirtilen miktardaki sayıları tutan sayılar adlı değişkeni fonksiyondan döndürüyoruz. Yani fonksiyonumuz dış dünyaya sayılar adlı bir değişken veriyor... Bu değişkenibuşekildedöndürdüktensonraistediğimizgibikullanabiliriz.Mesela: for i in range(100): print(sayı_üret()) Buradanşunabenzerbirçıktıalacaksınız: {34, 144, 211, 468, 58, 286} {41, 170, 395, 113, 178, 29} {161, 195, 452, 271, 212, 324} {1, 328, 461, 398, 464, 220} {356, 489, 12, 114, 329, 472} {320, 34, 238, 176, 243, 149} {364, 304, 434, 403, 217, 63} {452, 392, 175, 464, 81, 467} {36, 230, 21, 440, 287, 415} {292, 391, 145, 182, 440, 223} (sonrakisayfayadevam) 35.7. ÖrnekbirUygulama 613 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) {386, 38, 309, 377, 59, 277} {0, 2, 42, 400, 404, 60} {48, 482, 393, 80, 116, 407} {483, 136, 431, 35, 344, 381} ... Gördüğünüz gibi, sayı_üret() fonksiyonunu kullanarak, her biri 6 öğeden oluşan 100 adet sayı listesi elde ettik. Biz yukarıda bu fonksiyonu parametresiz olarak çalıştırdığımız için, Python başlangıç, bitiş ve adet parametrelerinin öntanımlı değerlerini kullandı (sırasıyla 0, 500ve6). İstersekbizfonksiyonumuzufarklıparametrelerleçağırabiliriz: print(sayı_üret(0, 100, 10)) Bukodlarbize0ile100arasından10adetrastgelesayıseçer: {3, 4, 9, 11, 13, 47, 50, 53, 54, 61} Eğer çıktının küme parantezleri arasında görünmesini istemiyorsanız elbette çıktıyı keyfinize görebiçimlendirebilirsiniz: print(*sayı_üret(100, 1500, 20), sep=’-’) Buşekilde,100ile1500arasısayılardanrastgele20adetseçipherbirsayınınarasınabirtane -işaretiyerleştirdik: 352-1251-1366-1381-1350-330-203-842-269-285-816 -658-643-308-1174-152-594-522-1214-959 35.8 Fonksiyonların Kapsamı ve global Deyimi Elimizdeşöylebirkodolduğunudüşünelim: x = 0 def fonk(): x = 1 return x Bu kodlarda, fonksiyonun dışında x adlı bir değişken var. Fonksiyonun içinde de yine x adını taşıyanbaşkabirdeğişkenvar.Fonksiyonumuzungörevibuxdeğişkeninidöndürmek. Bu noktada size şöyle bir soru sormama izin verin: Acaba fonksiyon içinde tanımladığımız x değişkeni, fonksiyon dışındaki x değişkeninin değerini değiştiriyor mu? Bu sorunun cevabını şukodlarlaverelim: x = 0 def fonk(): (sonrakisayfayadevam) 614 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) x = 1 return x print(’fonksiyon içindeki x: ’, fonk()) print(’fonksiyon dışındaki x: ’, x) Bukodlarıçalıştırdığımızdaşuçıktıyıalacağız: fonksiyon içindeki x: 1 fonksiyon dışındaki x: 0 Gördüğünüz gibi fonksiyon içindeki ve fonksiyon dışındaki aynı adlı değişkenler birbirine karışmıyor.Bununsebebi,Python’daki‘isimalanı’(namespace)adlıbirkavramdır. Pekiisimalanınedemek? Python’da değişkenlerin, fonksiyonların ve daha sonra göreceğiniz gibi sınıfların bir kapsamı vardır. Bu kapsama Python’da ‘isim alanı’ adı verilir. Dolayısıyla Python’da her nesnenin, geçerliveetkinolduğubirisimalanıbulunur.Örneğinyukarıdakikodlardafonksiyondışındaki xdeğişkenianaisimalanındayeralan‘global’birdeğişkendir.Fonksiyoniçindekixdeğişkeni isefonk()değişkenininisimalanıiçindeyeralan‘lokal’birdeğişkendir.Buikideğişken,adları aynıdaolsa,birbirlerindenfarklıikinesnedir. Birdeşuörneklerebakalım: x = [] print(’x\’in ilk hali:’, x) def değiştir(): print(’x\’i değiştiriyoruz...’) x.append(1) return x değiştir() print(’x\’in son hali: ’, x) Buradaisedahafarklıbirdurumsözkonusu.Fonksiyoniçindeappend()metodunukullanarak yaptığımızeklemeişlemifonksiyondışındakilisteyideetkiledi.Pekiamabunasıloluyor? Python herhangi bir nesneye göndermede bulunduğumuzda, yani o nesnenin değerini talep ettiğimizde aradığımız nesneyi ilk önce mevcut isim alanı içinde arar. Eğer aranan nesneyi mevcutisimalanıiçindebulamazsayukarıyadoğrubütünisimalanlarınıtektekkontroleder. Birkaçörnekverelim: def fonk(): print(x) fonk() Tahminedebileceğinizgibi,bukodlarşuhatayıverecektir: 35.8. FonksiyonlarınKapsamıveglobalDeyimi 615 PythonBelgeleri,Yayım4.1.3 Traceback (most recent call last): File "deneme.py", line 4, in <module> fonk() File "deneme.py", line 2, in fonk print(x) NameError: global name ’x’ is not defined Bu hatanın sebebi, x adlı bir değişkenin tanımlanmamış olmasıdır. Bu hatayı gidermek için şöylebirkodyazabiliriz: x = 0 def fonk(): print(x) fonk() Bukodglobalalandakixdeğişkeninindeğeriniverecektir. Yukarıdaki örnekte, biz print() ile x’in değerini sorguladığımızda Python öncelikle fonk() adlıfonksiyonunisimalanınabaktı.Oradax’ibulamayıncabukezglobalalanayönelip,orada bulduğux’indeğeriniyazdırdı. Budurumudahanetanlayabilmekiçinşukodlarıinceleyelim: x = 0 def fonk(): x = 10 print(x) fonk() print(x) Bu kodları çalıştırdığımızda 10 çıktısını alırız. Çünkü Python, dediğimiz gibi, öncelikle mevcut isim alanını kontrol ediyor. x değişkenini mevcut isim alanında bulduğu için de global alana bakmasınagerekkalmıyor. Yalnızburadadikkatetmemizgerekenbazışeylervar. Dediğimiz gibi, global isim alanındaki nesnelerin değerini lokal isim alanlarından sorgulayabiliyoruz. Ancak istediğimiz şey global isim alanındaki nesnelerin değerini değiştirmeksebazıkavramlararasındakifarklarıiyianlamamızgerekiyor. Python’da bir nesnenin değerini değiştirmekle, o nesneyi yeniden tanımlamak farklı kavramlardır. Eğer bir nesne değiştirilebilir bir nesne ise, o nesnenin değerini, lokal isim alanlarından değiştirebilirsiniz: x = set() def fonk(): x.add(10) (sonrakisayfayadevam) 616 Bölüm35. Fonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) return x print(fonk()) Ama eğer bir nesne değiştirilemez bir nesne ise, o nesnenin değerini zaten normalde de değiştiremezsiniz.Değiştirmişgibiyapmakiçiniseonesneyiyenidentanımlamanızgerektiğini biliyorsunuz: >>> isim = ’Fırat’ >>> isim += ’ Özgül’ >>> print(isim) Fırat Özgül Burada yaptığımız şey, karakter dizisinin değerini değiştirmekten ziyade bu karakter dizisini yenidentanımlamaktır.Çünkübildiğinizgibikarakterdizilerideğiştirilemeyenveritipleridir. İşte karakter dizileri gibi değiştirilemeyen nesneleri, lokal isim alanlarında değiştiremeyeceğinizgibi,yenidentanımlayamazsınızda... isim = ’Fırat’ def fonk(): isim += ’ Özgül’ return isim print(fonk()) BukodlarıçalıştırdığınızdaPythonsizebirhatamesajıgösterecektir. Aynıdurumdeğiştirilebilirnesneleriçindegeçerlidir: isim_listesi = [] def fonk(): isim_listesi += [’Fırat Özgül’, ’Orçun Kunek’] return isim_listesi print(fonk()) Değiştirilebilen bir veri tipi olan listeleri, fonksiyon içinde yeniden tanımlayamazsınız. Ancak tabiiistersenizlistelerideğişikliğeuğratabilirsiniz: isim_listesi = [] def fonk(): isim_listesi.extend([’Fırat Özgül’, ’Orçun Kunek’]) return isim_listesi print(fonk()) Bu kodlar düzgün bir şekilde çalışıp, fonksiyon dışındaki isim_listesi adlı listeyi değişikliğe 35.8. FonksiyonlarınKapsamıveglobalDeyimi 617 PythonBelgeleri,Yayım4.1.3 uğratacaktır.Ancakşukodlarhataverecektir: isim_listesi = [] def fonk(): isim_listesi += [’Fırat Özgül’, ’Orçun Kunek’] return isim_listesi print(fonk()) İştePythonprogramlamadilibutürdurumlariçinçözümolacakbiraraçsunarbize.Buaracın adıglobal. Gelinistersenizbuglobaladlıdeyiminnasılkullanılacağınabakalımönce... Şukodlarınhatavereceğinibiliyorsunuz: isim = ’Fırat’ def fonk(): isim += ’ Özgül’ return isim print(fonk()) Amabukodlaraşöylebireklemeyaparsanızişlerdeğişir: isim = ’Fırat’ def fonk(): global isim isim += ’ Özgül’ return isim print(fonk()) Buradafonk()adlıfonksiyonunilksatırındaşöylebirkodgörüyoruz: global isim İşte bu satır, isim adlı değişkenin global alana taşınmasını sağlıyor. Böylece global alanda bulunanisimadlıdeğişkenideğişikliğeuğratabiliyoruz. global deyimi her ne kadar ilk bakışta çok faydalı bir araçmış gibi görünse de aslında programlarımızda genellikle bu deyimi kullanmaktan kaçınmamız iyi bir fikir olacaktır. Çünkü bu deyim aslında global alanı kirletmemize neden oluyor. Global değişkenlerin lokal isim alanlarında değişikliğe uğratılması, eğer dikkatsiz davranırsanız programlarınızın hatalı çalışmasınayolaçabilir. 618 Bölüm35. Fonksiyonlar 36 BÖLÜM Gömülü Fonksiyonlar Bu bölümde, daha önce de birkaç kez bahsettiğimiz ve çokça örneğini gördüğümüz bir kavramdansözedeceğiz.Bukavramınadı‘gömülüfonksiyonlar’. Esasında biz buraya gelene kadar Python’da pek çok gömülü fonksiyon gördük. Dolayısıyla aslında görünüş olarak bunların neye benzediğini biliyoruz. Örneğin daha önceki derslerimizde gördüğümüz print() gömülü bir fonksiyondur. Aynı şekilde open(), type(), len(), pow(), bin() ve şimdiye kadar tanıştığımız öteki bütün fonksiyonlar birer gömülü fonksiyondur. Gömülü fonksiyonlar İngilizcede builtin functions olarak adlandırılır. Bu fonksiyonlar gerçekten de dile gömülü vaziyettedirler. Bildiğiniz gibi, bir fonksiyonu kullanabilmemiz için o fonksiyonu tanımlamamız gerekir. İşte gömülü fonksiyonlar, bizim tanımlamamıza gerek kalmadan,Pythongeliştiricileritarafındanöncedentanımlanıpdilegömülmüşvehizmetimize sunulmuşfaydalıbirtakımaraçlardır. İşte bu bölümde biz de bu gömülü fonksiyonları tek tek ve ayrıntılı olarak inceleyeceğiz. Dediğimiz gibi, bunlardan bir kısmını halihazırda görmüştünüz. Ama biz bütünlük açısından, önceden ele almış olduğumuz bu fonksiyonlara da kısaca değinmeden geçmeyeceğiz. Böylelikle hem yeni fonksiyonlar öğrenmiş olacağız hem de önceden öğrendiğimiz fonksiyonlarlabirlikteyenifonksiyonlarıdaderlitoplubirşekildegörmeimkanımızolacak. Bu bölümde elbette birtakım fonksiyonları salt art arda sıralamakla yetinmeyeceğiz. Python’daki gömülü fonksiyonları incelerken bir yandan da Python programlama dilindeki çokönemlibazıkavramlarıelealacağız. İlkolarakabs()adlıbirfonksiyonlabaşlıyoruzgömülüfonksiyonlarıincelemeye... 619 PythonBelgeleri,Yayım4.1.3 36.1 abs() İngilizcede ‘mutlak’ anlamına gelen absolute adlı bir kelime bulunur. İşte bu fonksiyonun adı da bu kelimeden gelir. Fonksiyonumuzun görevi de isminin anlamına yakındır. abs() fonksiyonunubirsayınınmutlakdeğerinieldeetmekiçinkullanıyoruz. Peki ‘mutlak değer’ ne anlama geliyor. Esasında siz bu kavrama matematik derslerinden aşinasınız.Amabilmeyenlerveyaunutmuşolanlariçintekraredelim.‘Mutlakdeğer’birsayının 0’aolanuzaklığıdır.Örneğin20sayısının0sayısınaolanuzaklığı20’dir.Dolayısıyla20sayısının mutlakdeğeri20’dir.Aynışekilde-20sayısınında0sayısınauzaklığı20’dir.Yani,-20sayısının damutlakdeğeri20’dir. İşteabs()fonksiyonubizebirsayınınmutlakdeğerininneolduğunusöyler: >>> abs(-20) 20 >>> abs(20) 20 >>> abs(20.0) 20.0 Mutlak değer kavramı yalnızca tamsayılar ve kayan noktalı sayılar için değil, aynı zamanda karmaşık sayılar için de geçerlidir. Dolayısıyla abs() fonksiyonunu kullanarak karmaşık sayılarındamutlakdeğerinihesaplayabiliriz: >>> abs(20+3j) 20.223748416156685 Gördüğünüz gibi bu fonksiyon yalnızca tek bir parametre alıyor ve bu parametrenin mutlak değerinidöndürüyor. 36.2 round() round() fonksiyonu bir sayıyı belli ölçütlere göre yukarı veya aşağı doğru yuvarlamamızı sağlar.Basitbirkaçörnekverelim: >>> round(12.4) 12 >>> round(12.7) 13 Gördüğünüzgibibufonksiyon,kayannoktalısayılarıenyakıntamsayıyadoğruyuvarlıyor. 620 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Ancakburadadikkatetmemizgerekenbirnoktavar. Şuörnekleribirinceleyelim: >>> round(1.5) 2 >>> round(12.5) 12 Gördüğünüz gibi, fonksiyonumuz 1.5 sayısını yukarı doğru, 12.5 sayısını ise aşağı doğru yuvarladı. Bunun sebebi, kayan noktalı bir sayının üst ve alt tam sayılara olan uzaklığının birbirine eşit olduğu durumlarda Python’ın çift sayıya doğru yuvarlama yapmayı tercih etmesidir. Mesela yukarıdaki örneklerde 1.5 sayısı hem 1 sayısına, hem de 2 sayısına eşit uzaklıktabulunuyor.İştePythonbudurumda,birçiftsayıolan2sayısınadoğruyuvarlamayı tercihedecektir. round()fonksiyonutoplamikiparametrealır.İlkparametre,yuvarlanacaksayınınkendisidir. Yuvarlamahassasiyetinibelirlemekiçiniseikincibirparametredenyararlanabiliriz. Örneğin22sayısını7’yeböldüğümüzdenormaldeşöylebirçıktıeldeederiz: >>> 22/7 3.142857142857143 round() fonksiyonunu tek parametre ile kullandığımızda bu fonksiyon yukarıdaki sayıyı şu şekildeyuvarlayacaktır: >>> round(22/7) 3 İşte biz round() fonksiyonuna ikinci bir parametre daha vererek, yuvarlama hassasiyetini kontroledebiliriz. Aşağıdakiörnekleridikkatliceinceleyin: >>> round(22/7) 3 >>> round(22/7, 0) 3.0 >>> round(22/7, 1) 3.1 >>> round(22/7, 2) (sonrakisayfayadevam) 36.2. round() 621 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 3.14 >>> round(22/7, 3) 3.143 >>> round(22/7, 4) 3.1429 Gördüğünüzgibi,round()fonksiyonunaverdiğimizikinciparametre,yuvarlamaişlemininne kadarhassasolacağınıbelirliyor. 36.3 all() All kelimesi Türkçede ‘hepsi’ anlamına gelir. Bu fonksiyonun görevi de bu anlamı çağrıştırır. all()fonksiyonunungörevi,birdiziiçindebulunanbütündeğerlerTrueiseTruedeğeri,eğer budeğerlerdenherhangibiriFalseisedeFalsedeğeridöndürmektir. Örneğinelimizdeşöylebirlisteolduğunuvarsayalım: >>> liste = [1, 2, 3, 4] Şimdiall()fonksiyonunubulisteüzerineuygulayalım: >>> all(liste) True Bildiğiniz gibi, 0 hariç bütün sayıların bool değeri True’dur. Yukarıdaki listede False değeri verebilecekherhangibirdeğerbulunmadığından,all()fonksiyonubulisteiçinTruedeğerini veriyor.Birdeşunabakalım: >>> liste = [0, 1, 2, 3, 4] >>> all(liste) False Dediğimizgibi,all()fonksiyonuancakdiziiçindekibütündeğerlerinbooldeğeriTrueiseTrue çıktısıverecektir. Sonbirörnekdahaverelim: >>> liste = [’ahmet’, ’mehmet’, ’’] >>> all(liste) False Listede False değerine sahip bir boş karakter dizisi bulunduğu için all() fonksiyonu False çıktısıveriyor. 622 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Bu fonksiyonu her türlü kodun bool değerlerini test etmek için kullanabilirsiniz. Mesela bu fonksiyonu kullanarak, bir nesnenin listelenen özelliklerin hepsine sahip olup olmadığını denetleyebilirsiniz: >>> a = 3 >>> t1 = a == 3 #sayı 3 mü? ’ >>> t2 = a < 4 #sayı 4 ten küçük mü? >>> t3 = a % 2 == 1 #sayı bir tek sayı mı? >>> all([t1, t2, t3]) #sayı bu özelliklerin hepsine sahip mi? True Eğersayımızbuözelliklerinbirinebilesahipdeğilse,all()fonksiyonuFalseçıktısıverecektir. 36.4 any() Anykelimesiİngilizcede‘herhangibir’anlamınagelir.İşteany()fonksiyonunungörevide,bir diziiçindekibütündeğerlerdenenazbiriTrueiseTrueçıktısıvermektir. Örneğin: >>> liste = [’ahmet’, ’mehmet’, ’’] >>> any(liste) True any() fonksiyonunun True çıktısı verebilmesi için listede yalnızca bir adet True değerli öğe olmasıyeterlidir.BufonksiyonunFalseçıktısıverebilmesiiçindiziiçindekibütünöğelerinbool değerininFalseolmasıgerekir: >>> l = [’’, 0, [], (), set(), dict()] >>> any(l) False İçiboşveritiplerininbooldeğerininFalseolduğunubiliyorsunuz. Tıpkı all() fonksiyonunda olduğu gibi, any() fonksiyonunu da, bir grup nesnenin bool değerlerinidenetlemekamacıylakullanabilirsiniz. 36.5 ascii() Bu fonksiyon, bir nesnenin ekrana basılabilir halini verir bize. Dilerseniz bu fonksiyonun yaptığıişitanımlamakyerinebunubirörneküzerindenanlatmayaçalışalım: >>> a = ’’ >>> print(ascii(a)) ’’ 36.4. any() 623 PythonBelgeleri,Yayım4.1.3 Bufonksiyonun,print()fonksiyonundanfarklıolarak,çıktıyatırnakişaretlerinideeklediğine dikkatedin. ascii()fonksiyonununtamolarakneyaptığınıdahaiyianlamakiçinherhaldeşuörnekdaha faydalıolacaktır. Dikkatlicebakın: >>> print(’\n’) Bukomutuverdiğimizde,nkaçışdizisininetkisiyleyenisatırageçileceğinibiliyorsunuz. Birdeşunabakın: >>> print(ascii(’\n!’)) ’\n’ Gördüğünüz gibi, ascii() fonksiyonu, satır başı kaçış dizisinin görevini yapmasını sağlamak yerinebukaçışdizisininekranabasılabilirhaliniveriyorbize. Ayrıca bu fonksiyon, karakter dizileri içindeki Türkçe karakterlerin de UNICODE temsillerini döndürür.Örneğin: >>> a = ’ışık’ >>> print(ascii(a)) ’\u0131\u015f\u0131k’ Bunudahanetşuşekildegörebiliriz: >>> for i in a: ... print(ascii(i)) ... ’\u0131’ ’\u015f’ ’\u0131’ ’k’ Gördüğünüz gibi, ascii() fonksiyonu ASCII olmayan karakterlerle karşılaştığında bunların karakter temsilleri yerine UNICODE temsillerini (veya onaltılık sayma düzenindeki karşılıklarını)veriyor. Sonolarakşuörneğebakalım: >>> liste = [’elma’, ’armut’, ’erik’] >>> temsil = ascii(liste) >>> print(temsil) [’elma’, ’armut’, ’erik’] Burada listemiz ascii() fonksiyonuna parametre olarak verildikten sonra artık liste olma özelliğiniyitiripbirkarakterdizisihalinegelir.Bunudenetleyelim: 624 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> print(type(temsil)) <class ’str’> >>> temsil[0] ’[’ Gördüğünüz gibi, ascii() fonksiyonu listeyi alıp, bunu ekrana basılabilir bir bütün haline getiriyor. Elbette bunun için de, kendisine verilen parametreyi bir karakter dizisine dönüştürüyor. 36.6 repr() repr() fonksiyonunun yaptığı iş, biraz önce gördüğümüz ascii() fonksiyonunun yaptığı işe çok benzer. Bu iki fonksiyon, ASCII olmayan karakterlere muameleleri açısından birbirinden ayrılır. Hatırlarsanız ascii() fonksiyonu ASCII olmayan karakterlerle karşılaştığında bunların UNICODE(veyaonaltılık)temsillerinigösteriyordu: >>> ascii(’şeker’) "’\\u015feker’" repr() fonksiyonu ise ASCII olmayan karakterlerle karşılaşsa bile, bize çıktı olarak bunların dakarakterkarşılıklarınıgösterir: >>> repr(’şeker’) "’şeker’" Gerikalanözellikleribakımındanrepr()veascii()fonksiyonlarıbirbiriyleaynıdır. 36.7 bool() Bufonksiyonbirnesneninbooldeğeriniverir: >>> bool(0) False >>> bool(1) True >>> bool([]) False 36.6. repr() 625 PythonBelgeleri,Yayım4.1.3 36.8 bin() Bufonksiyon,birsayınınikilidüzendekikarşılığınıverir: >>> bin(12) ’0b1100’ Bufonksiyonunverdiğiçıktınınbirsayıdeğil,karakterdizisiolduğunadikkatetmelisiniz. 36.9 bytes() Bufonksiyonbytestüründenesneleroluşturmakiçinkullanılır.Bufonksiyonu‘bayt’adlıveri tipini incelerken ayrıntılı olarak ele almıştık. Gelin isterseniz burada da bu fonksiyona şöyle birdeğinelim. Dediğimizgibi,bytes()adlıfonksiyon,bytestüründeverileroluşturmayayarar.Bufonksiyon işlev olarak, daha önce öğrendiğimiz list(), str(), int(), set(), dict() gibi fonksiyonlara çok benzer. Tıpkı bu fonksiyonlar gibi, bytes() fonksiyonunun görevi de farklı veri tiplerini ‘bayt’adlıveritipinedönüştürmektir. Bufonksiyon,kendisineverilenparametrelerintürünebağlıolarakbirbirindenfarklısonuçlar ortayaçıkarır.Örneğineğerbufonksiyonaparametreolarakbirtamsayıverecekolursanız,bu fonksiyon size o tam sayı miktarınca bir bayt nesnesi verecektir. Gelin isterseniz bu durumu örneklerüzerindegöstermeyeçalışalım: >>> bytes(10) b’\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’ Yukarıdakikomutbize,herbiröğesinindeğeri0olan10baytlıkbirveridöndürdü: >>> a = bytes(10) >>> a b’\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00’ >>> a[0] 0 >>> a[1] 0 >>> a[2] 0 626 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, bytes(10) komutuyla oluşturduğumuz a değişkeni içinde toplam 10 adet baytvarvebubaytlarınherbirinindeğeri0. Yukarıda, bytes() fonksiyonuna bir tam sayı değerli parametre verdiğimizde nasıl bir sonuç alacağımızı öğrendik. Peki biz bu fonksiyona parametre olarak bir karakter dizisi verirsek ne olur? Hemengörelim: >>> bytes(’’) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: string argument without an encoding Bu fonksiyona karakter dizilerini doğrudan parametre olarak veremeyiz. Eğer verirsek yukarıdakigibibirhataalırız.Pekiacababuhatayıalmamızınnedenineolabilir? Dediğimiz gibi, bytes() fonksiyonu, çeşitli veri tiplerini bayta dönüştürmeye yarar. Ancak bildiğiniz gibi, bayta dönüştürme işlemi her kod çözücü tarafından farklı biçimde yapılır. Örneğin: >>> ’ışık’.encode(’utf-8’) b’\xc4\xb1\xc5\x9f\xc4\xb1k’ >>> ’ışık’.encode(’cp857’) b’\x8d\x9f\x8dk’ >>> ’ışık’.encode(’cp1254’) b’\xfd\xfe\xfdk’ Dolayısıyla, bytes() fonksiyonunun bir karakter dizisini bayta çevirirken nasıl davranması gerektiğini anlayabilmesi için, bayta dönüştürme işlemini hangi kod çözücü ile yapmak istediğimiziaçıkçabelirtmemizgerekir: >>> bytes(’ışık’, ’utf-8’) b’\xc4\xb1\xc5\x9f\xc4\xb1k’ >>> bytes(’ışık’, ’cp1254’) b’\xfd\xfe\xfdk’ >>> bytes(’ışık’, ’cp857’) b’\x8d\x9f\x8dk’ Gördüğünüzgibi,bytes()fonksiyonunaparametreolarakbirkarakterdizisiverebilmekiçin, bu karakter dizisi ile birlikte bir kod çözücü de belirtmemiz gerekiyor. Böylece bytes() fonksiyonukendisineverdiğimizkarakterdizisini,belirttiğimizkodçözücününkurallarınagöre baytadönüştürüyor. 36.9. bytes() 627 PythonBelgeleri,Yayım4.1.3 Bu arada, çıktıda görünen ‘b’ harflerinin, elimizdeki verinin bir bayt olduğunu gösteren bir işaretolduğunubiliyorsunuz. Ayrıca, bytes() fonksiyonuna verdiğimiz ikinci parametrenin isminin encoding olduğunu ve buparametreyiisimlibirparametreolarakdakullanabileceğimizibelirtelim: >>> bytes(’’, encoding=’ascii’) Bu noktada size şöyle bir soru sorayım: Acaba bytes() fonksiyonuna ilk parametre olarak verdiğimizkarakterdizisi,ikinciparametredebelirttiğimizkodçözücütarafındantanınmazsa neolur? Cevabıtahminedebilirsiniz:BöylebirdurumdaelbettePythonbizebirhatamesajıgösterir: >>> bytes(’şeker’, ’ascii’) Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeEncodeError: ’ascii’ codec can’t encode character ’\u015f’ in position 0: ordinal not in range(128) ... veya: >>> bytes(’¿’, ’cp857’) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "C:\Python33\lib\encodings\cp857.py", line 12, in encode return codecs.charmap_encode(input,errors,encoding_map) UnicodeEncodeError: ’charmap’ codec can’t encode character ’\u20ac’ in position 0: character maps to <undefined> ‘ş’ harfi ‘ASCII’ karakter kümesinde; ‘=C’ işareti ise ‘CP857’ adlı karakter kümesinde tanımlanmamış birer karakter olduğu için, ilgili kod çözücüler bu karakterleri çözüp bayta dönüştüremiyor.Yazdığımızkodlarınbutürdurumlardatamamençökmesiniengellemekiçin, önceki derslerimizde de çeşitli vesilelerle öğrenmiş olduğumuz errors adlı bir parametreden yararlanabiliriz: >>> bytes(’ışık’, encoding=’ascii’, errors=’replace’) b’???k’ >>> bytes(’şeker’, encoding=’ascii’, errors=’replace’) b’?eker’ >>> bytes(’¿’, encoding=’cp857’, errors=’replace’) b’?’ >>> bytes(’¿’, encoding=’cp857’, errors=’ignore’) (sonrakisayfayadevam) 628 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) b’’ >>> bytes(’¿’, encoding=’cp857’, errors=’xmlcharrefreplace’) b’&#8364;’ >>> bytes(’şeker’, encoding=’cp857’, errors=’xmlcharrefreplace’) b’\x9feker’ Gördüğünüz gibi, errors parametresine verdiğimiz çeşitli değerler yardımıyla, bytes() fonksiyonunun,encodingparametresindebelirtilenkodçözücüileçözülemeyenkarakterlerle karşılaştığındanasıldavranacağınıbelirleyebiliyoruz. errors parametresine verdiğimiz bütün bu değerleri önceki derslerimizde öğrenmiştik. Dolayısıyla yukarıda gösterdiğimiz kodları rahatlıkla anlayabilecek kadar Python bilgisine sahibiz. Son olarak, bytes() fonksiyonuna parametre olarak 0-256 arası sayılardan oluşan diziler de verebiliriz: >>> bytes([65, 10, 12, 11, 15, 66]) b’A\n\x0c\x0b\x0fB’ Bu yapı içinde Python, 0 ile 128 arası sayılar için standart ASCII tablosunu, 128 ile 256 arası sayılariçiniseLatin-1karakterkümesinitemelalaraksayılarıbirerbaytadönüştürecektir. 36.10 bytearray() Bildiğiniz gibi baytlar değiştirilemeyen bir veri tipidir. Dolayısıyla bir bayt veri tipi üzerinde herhangi bir değişiklik yapamayız. Örneğin bir baytın herhangi bir öğesini başka bir değerle değiştiremeyiz: >>> a = bytes(’’, ’ascii’) >>> a[0] 105 >>> a[0] = 106 Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: ’bytes’ object does not support item assignment Ama eğer hem baytlarla çalışmak, hem de bu baytların üzerinde değişiklik yapabilmek isterseniz baytlar yerine bayt dizileri ile çalışabilirsiniz. İşte bunun için bytearray() adlı bir fonksiyondanyararlanıyoruz. Yaptıklarıişbakımındanbytearray()vebytes()fonksiyonlarıbirbirlerineçokbenzer.Buikisi arasındakitekfark,bytearray()ileoluşturulanveritipinin,bytes()ileoluşturulanveritipinin 36.10. bytearray() 629 PythonBelgeleri,Yayım4.1.3 aksine,değiştirilebilirnitelikteolmasıdır: >>> a = bytearray(’adana’, ’ascii’) >>> a bytearray(b’adana’) >>> a[0] = 65 >>> a bytearray(b’Adana’) 36.11 chr() Bufonksiyon,kendisineparametreolarakverilenbirtamsayınınkarakterkarşılığınıdöndürür. Örneğin: >>> chr(10) ’\n’ Bildiğinizgibi10sayısınınkarakterkarşılığısatırbaşıkarakteridir.Birdeşunabakalım: >>> chr(65) ’A’ 65sayısınınkarakterkarşılığıise‘A’harfidir. Bu fonksiyon sayıları karakterlere dönüştürürken ASCII sistemini değil, UNICODE sistemini temel alır. Dolayısıyla bu fonksiyon ile 128 (veya 255) üstü sayıları da dönüştürebiliriz. Örneğin: >>> chr(305) ’ı’ 36.12 list() Bufonksiyonikifarklıamaçiçinkullanılabilir: 1. Listetipindebirverioluşturmak 2. Farklıveritiplerinilisteadlıveritipinedönüştürmek Birinciamaçiçinbufonksiyonuşuşekildekullanıyoruz: 630 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> l = list() Böylecelistetipindebirverioluşturmuşolduk. Dediğimiz gibi list() fonksiyonunu, farklı tipteki verileri listeye dönüştürmek için de kullanabiliriz.Örneğin: >>> list(’’) [’i’, ’s’, ’t’, ’i’, ’h’, ’z’, ’a’] Burada‘’adlıkarakterdizisinibirlisteyedönüştürdük. Elbette bu fonksiyonu kullanarak başka veri tiplerini de listeye dönüştürebiliriz. Örneğin bir sözlüğü,bufonksiyonyardımıylakolaycalisteyedönüştürebiliriz: >>> s = {’elma’: 44, ’armut’: 10, ’erik’: 100} >>> list(s) [’elma’, ’armut’, ’erik’] Bir sözlük listeye dönüştürülürken, elbette sözlüğün anahtarları dikkate alınacaktır. Eğer siz sözlüğün anahtarlarından değil de değerlerinde bir liste oluşturmak isterseniz şöyle bir kod yazabilirsiniz: >>> list(s.values()) [44, 10, 100] 36.13 set() set() fonksiyonu list() fonksiyonuna çok benzer. Bu fonksiyon da tıpkı list() fonksiyonu gibi, veri tipleri arasında dönüştürme işlemleri gerçekleştirmek için kullanılabilir. set() fonksiyonunungörevifarklıveritiplerinikümeyedönüştürmektir: >>> k = set() Buradaboşbirkümeoluşturduk.Şimdidemeselabirkarakterdizisinikümeyedönüştürelim: >>> i = ’’ >>> set(i) {’t’, ’s’, ’z’, ’a’, ’i’, ’h’} 36.13. set() 631 PythonBelgeleri,Yayım4.1.3 36.14 tuple() tuple() fonksiyonu da, tıpkı list(), set() ve benzerleri gibi bir dönüştürücü fonksiyondur. Bufonksiyonfarklıveritiplerinidemetedönüştürür: >>> tuple(’a’) (’a’,) 36.15 frozenset() Bufonksiyonukullanarakfarklıveritiplerinidondurulmuşkümeyedönüştürebilirsiniz: >>> s = set(’’) >>> df = frozenset(s) >>> df frozenset({’t’, ’s’, ’a’, ’z’, ’i’, ’h’}) 36.16 complex() Sayılardan söz ederken, eğer matematikle çok fazla içli dışlı değilseniz pek karşılaşmayacağınız, ‘karmaşık sayı’ adlı bir sayı türünden de bahsetmiştik. Karmaşık sayılar,birgerçek,birdesanalkısımdanoluşansayılardır. KarmaşıksayılarPython’da‘complex’ifadesiylegösteriliyor.Meselaşubirkarmaşıksayıdır: >>> 12+0j İşte eğer herhangi bir sayıyı karmaşık sayıya dönüştürmeniz gerekirse complex() adlı bir fonksiyondanyararlanabilirsiniz.Örneğin: >>> complex(15) (15+0j) Böyle bir kod yazdığımızda, verdiğimiz parametre karmaşık sayının gerçek kısmını oluşturacak, sanal kısım ise 0 olarak kabul edilecektir. Elbette isterseniz sanal kısmı kendiniz debelirleyebilirsiniz: >>> complex(15, 2) (15+2j) 632 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.17 float() Bu fonksiyonu, sayıları veya karakter dizilerini kayan noktalı sayıya dönüştürmek için kullanıyoruz: >>> float(’134’) 134.0 >>> float(12) 12.0 36.18 int() Bu fonksiyon birkaç farklı amaç için kullanılabilir. int() fonksiyonunun en temel görevi, bir karakterdizisiveyakayannoktalısayıyı(eğermümkünse)tamsayıyadönüştürmektir: >>> int(’10’) 10 >>> int(12.4) 12 Bunun dışında bu fonksiyonu, herhangi bir sayma sisteminde temsil edilen bir sayıyı onlu saymasisteminedönüştürmekiçindekullanabiliriz.Örneğin: >>> int(’12’, 8) 10 ‘ Burada, sekizli sayma sistemine ait sayı değerli bir karakter dizisi olan ‘12’ yi onlu sayma ‘ sisteminedönüştürdükveböylece 10sayısınıeldeettik. int() fonksiyonunu sayma sistemleri arasında dönüştürme işlemlerinde kullanabilmek için ilkparametreninbirkarakterdizisiolmasıgerektiğinedikkatediyoruz. Buarada,int(’12’, 8)komutununun12sayısınısekizlisaymasisteminedönüştürmediğine dikkatedin.Bukomutunyaptığıişsekizlisaymasistemindeki12sayısınıonlusaymasistemine dönüştürmektir. int()fonksiyonununbukullanımıylailgilibirörnekdahaverelim: >>> int(’4cf’, 16) 1231 Burada da, onaltılı sayma sistemine ait bir sayı olan 4cf’yi onlu sayma sistemine çevirdik ve 1231 sayısını elde ettik. 4cf sayısını int() fonksiyonuna parametre olarak verirken 36.17. float() 633 PythonBelgeleri,Yayım4.1.3 bunu karakter dizisi şeklinde yazmayı unutmuyoruz. Aksi halde Python bize bir hata mesajı gösterecektir. 36.19 str() Bu fonksiyonun, farklı veri tiplerini karakter dizisine dönüştürmek için kullanıldığını biliyorsunuz.Örneğin: >>> str(12) ’12’ Burada 12 sayısını bir karakter dizisine dönüştürdük. Şimdi de bir baytı karakter dizisine dönüştürelim: >>> bayt = b’’ Baytnesnemizitanımladık.Şimdibunubirkarakterdizisinedönüştürelim: >>> kardiz = str(bayt, encoding=’utf-8’) >>> print(kardiz) Gördüğünüz gibi, bir baytı karakter dizisine dönüştürmek için str() fonksiyonuna encoding adlı bir parametre veriyoruz. Fonksiyonumuz, bu parametrede hangi kodlama biçimi belirtildiyse, baytları bu kodlama biçiminin kurallarına göre bir karakter dizisine dönüştürüyor. Tahminedebileceğinizgibi,belirttiğinizkodlamabiçimininherhangibirbaytıkarakterdizisine dönüştüremediği durumlara karşı bir errors parametresi de verebiliriz str() fonksiyonuna. Örneğinelimizdebayttipindeşöylebirveriolduğunuvarsayalım: >>> bayt = bytes(’kadın’, encoding=’utf-8’) >>> print(bayt) b’kad\xc4\xb1n’ Şimdibubaytveritipinibirkarakterdizisinedönüştürmeyeçalışalım: >>> kardiz = str(bayt, encoding=’ascii’) Traceback (most recent call last): File "<stdin>", line 1, in <module> UnicodeDecodeError: ’ascii’ codec can’t decode byte 0xc4 in position 3: ordinal not in range(128) ASCII adlı kod çözücü, b’kadın’ içindeki baytlardan birini tanıyamadığı için bize bir hata mesajı gösterdi. Bildiğiniz gibi ASCII 128’den büyük baytları dönüştüremez. İşte bu tür durumlarakarşıerrorsparametresindenyararlanabilirsiniz: 634 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> kardiz = str(bayt, encoding=’ascii’, errors=’ignore’) >>> print(kardiz) kadn errorsparametresineverdiğimiz‘ignore’değerisayesindePythonbizehatamesajıgöstermek yerine, ASCII ile çözülemeyen baytı görmezden geldi. errors parametresinin hangi değerleri alabileceğiniöncekiderslerimizdenhatırlıyorolmalısınız. 36.20 dict() Bu fonksiyon, farklı veri tiplerinden sözlükler üretmemizi sağlar. Örneğin bu fonksiyonu kullanarakboşbirsözlükoluşturabiliriz: >>> s = dict() Bufonksiyon,değişkenlerdensözlükleroluşturmamızıdasağlar: >>> s = dict(a=1, b=2, c=3) {’a’: 1, ’b’: 2, ’c’: 3} dict()fonksiyonunaparametreolarakiçiçegeçmişlistelerveyademetlervererekdesözlük üretebiliriz: >>> öğeler = ([’a’, 1], [’b’, 2], [’c’, 3]) >>> dict(öğeler) {’a’: 1, ’b’: 2, ’c’: 3} 36.21 callable() Bu fonksiyon, bir nesnenin ‘çağrılabilir’ olup olmadığını denetler. Peki hangi nesneler çağrılabilir özelliktedir. Mesela fonksiyonlar çağrılabilir nesnelerdir. Değişkenler ise çağrılabilirnesnelerdeğildir. Birkaçörnekverelimbununlailgili: >>> callable(open) True Python’ın open() adlı bir fonksiyonu olduğu için, doğal olarak callable() fonksiyonu True çıktısıveriyor. Birdeşunabakalım: 36.20. dict() 635 PythonBelgeleri,Yayım4.1.3 >>> import sys >>> callable(sys.version) False Burada da sys modülü içindeki version adlı nesnenin çağrılabilir özellikte olup olmadığını sorguladık. Daha önceki derslerimizde de gördüğünüz gibi, sys modülü içindeki version adlı araç bir fonksiyon değil, değişkendir. Dolayısıyla bu değişken callable(sys.version) sorgusunaFalseyanıtıverir. 36.22 ord() Bufonksiyon,birkarakterinkarşılıkgeldiğiondalıksayıyıverir.Örneğin: >>> ord(’a’) 97 >>> ord(’ı’) 305 36.23 oct() Bufonksiyon,birsayıyısekizlidüzendekikarşılığınaçevirmemizisağlar: >>> oct(10) ’0o12’ 36.24 hex() Bufonksiyon,birsayıyıonaltılıdüzendekikarşılığınaçevirmemizisağlar: >>> hex(305) ’Ox131’ Yalnız hem oct() hem de hex() fonksiyonlarında dikkat etmemiz gereken şey, bu fonksiyonlarınparametreolarakbirsayıalıp,çıktıolarakbirkarakterdizisiveriyorolmasıdır. 636 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.25 eval(), exec(), globals(), locals() Bu bölümde dört farklı fonksiyonu bir arada inceleyeceğiz. Bu fonksiyonları birlikte ele almamızınnedenibunlarınbirbiriyleyakındanbağlantılıolması. Buradaişleyeceğimizbudörtfonksiyonşunlardanoluşuyor: 1. eval() 2. exec() 3. globals() 4. locals() Ancak bu fonksiyonlardan söz etmeye başlamadan önce Python’daki iki önemli kavramı açıklığakavuşturmamızgerekiyor:Bukavramlarşunlar: 1. ifade 2. deyim Öncelikle‘ifade’kavramındanbaşlayalım. İngilizcede expression denen ‘ifadeler’, bir değer üretmek için kullanılan kod parçalarıdır. Karakter dizileri, sayılar, işleçler, öteki veri tipleri, liste üreteçleri, sözlük üreteçleri, küme üreteçleri,fonksiyonlarhepbirerifadedir.Örneğin: >>> 5 >>> 23 + 4 >>> [i for i in range(10)] >>> len([1, 2, 3]) İngilizcede statement olarak adlandırılan ‘deyimler’ ise ifadeleri de kapsayan daha geniş bir kavramdır. Buna göre bütün ifadeler aynı zamanda birer deyimdir. Daha doğrusu, ifadelerin birarayagelmesiiledeyimleroluşturulabilir. Deyimlerebirkaçörnekverelim: >>> a = 5 >>> if a: ... print(a) >>> for i in range(10): ... print(i) Python programlama dilinde deyimlerle ifadeleri ayırt etmenin kolay bir yolu da eval() fonksiyonundanyararlanmaktır.Eğerdeyimmiyoksaifademiolduğundaneminolamadığınız bir şeyi eval() fonksiyonuna parametre olarak verdiğinizde hata almıyorsanız o parametre bir ifadedir. Eğer hata alıyorsanız o parametre bir deyimdir. Çünkü eval() fonksiyonuna parametreolarakyalnızcaifadelerverilebilir. Birkaçörnekverelim: 36.25. eval(),exec(),globals(),locals() 637 PythonBelgeleri,Yayım4.1.3 >>> eval(’a = 5’) Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<string>", line 1 a = 5 ^ SyntaxError: invalid syntax Gördüğünüz gibi, eval() fonksiyonu bize bir hata mesajı verdi. Çünkü a = 5 kodu bir deyimdir. Unutmayın, Python’da bütün değer atama işlemleri birer deyimdir. Dolayısıyla eval()fonksiyonubudeyimiparametreolarakalamaz. Birdeşunabakalım: >>> eval(’5 + 25’) 30 Budefahataalmadık.Çünküeval()fonksiyonuna,olmasıgerektiğigibi,parametreolarakbir ifadeverdik.Bildiğinizgibi,5 + 25kodubirifadedir. Dediğimizgibi,eval()fonksiyonudeyimleriparametreolarakalamaz.Amaexec()fonksiyonu alabilir: >>> exec(’a = 5’) Buşekilde,değeri5olanaadlıbirdeğişkenoluşturmuşolduk.İstersenizkontroledelim: >>> print(a) 5 Gördüğünüz gibi, exec() fonksiyonu, mevcut isim alanı içinde a adlı bir değişken oluşturdu. Yalnızelbettemevcutisimalanıiçindeyenideğişkenlerveyenideğerleroluştururkendikkatli olmamızgerektiğinibiliyorsunuz.Zirameselayukarıdakikomutuvermedenöncemevcutisim alanındazatenaadlıbirdeğişkenvarsa,odeğişkenindeğerideğişecektir: >>> a = 20 Elimizde, değeri 20 olan a adlı bir değişken var. Şimdi exec() fonksiyonu yardımıyla a değişkeninindeiçindeyeraldığımevcutisimalanınamüdahaleediyoruz: >>> exec(’a = 10’) Böyleceadeğişkeninineskideğerinisilmişolduk.Kontroledelim: >>> print(a) 10 Butürdurumlarda,exec()ileoluşturduğunuzdeğişkenleriglobalisimalanınadeğilde,farklı birisimalanınagöndermeyitercihedebilirsiniz.Pekiamabununasılyapacağız? 638 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Pythonprogramlamadilindeisimalanlarısözlüktipindebirveridir.Örneğinglobalisimalanı basitbirsözlüktenibarettir. Global isim alanını gösteren sözlükte hangi anahtar ve değerlerin olduğunu görmek için globals()adlıbirfonksiyonukullanabilirsiniz: >>> globals() Bufonksiyonuçalıştırdığımızdaşunabenzerbirçıktıalırız: {’__doc__’: None, ’__loader__’: <class ’_frozen_importlib.BuiltinImporter’>, ’__name__’: ’__main__’, ’__package__’: None, ’__builtins__’: <module ’builtins’> } ˓→ Gördüğünüz gibi, elimizdeki şey gerçekten de bir sözlük. Dolayısıyla bir sözlük ile ne yapabilirsekbusözlükledeaynışeyiyapabiliriz... ‘globals’adlıbusözlüğüniçeriği,oandaglobalisimalanındabulunannesneleregörefarklılık gösterecektir.Örneğin: >>> x = 10 şeklinde10değerinesahipbirxnesnesitanımladıktansonraglobals()fonksiyonunutekrar çalıştırırsanızglobalisimalanınabunesnenindeeklenmişolduğunugörürsünüz. Dediğimiz gibi, globals() fonksiyonundan dönen nesne bir sözlüktür. Bu sözlüğe, herhangi birsözlüğeverieklergibideğerdeekleyebilirsiniz: >>> globals()[’z’] = 23 Buşekildeglobalisimalanınazadlıbirdeğişkeneklemişoldunuz: >>> z 23 Yalnız, Python programlama dili bize bu şekilde global isim alanına nesne ekleme imkanı verse de, biz mecbur değilsek bu yöntemi kullanmaktan kaçınmalıyız. Çünkü bu şekilde sıradışıbiryöntemledeğişkentanımladığımıziçinaslındaglobalisimalanını,nerdengeldiğini kestirmeningüçolduğudeğerlerle‘kirletmiş’oluyoruz. Bildiğiniz gibi, Python’da global isim alanı dışında bir de lokal isim alanı bulunur. Lokal isim alanlarının, fonksiyonlara (ve ileride göreceğimiz gibi sınıflara) ait bir isim alanı olduğunu biliyorsunuz. İşte bu isim alanlarına ulaşmak için de locals() adlı bir fonksiyondan yararlanacağız: def fonksiyon(param1, param2): x = 10 print(locals()) fonksiyon(10, 20) Bufonksiyonuçalıştırdığınızdaşuçıktıyıalacaksınız: 36.25. eval(),exec(),globals(),locals() 639 PythonBelgeleri,Yayım4.1.3 {’param2’: 20, ’param1’: 10, ’x’: 10} Gördüğünüzgibi,locals()fonksiyonugerçektendebizefonksiyon()adlıfonksiyoniçindeki lokaldeğerleriveriyor. globals() ve locals() fonksiyonlarının ne işe yaradığını incelediğimize göre exec() fonksiyonunuanlatırkenkaldığımızyeredönebiliriz. Nediyorduk? Elimizde,değeri20olanaadlıbirdeğişkenvardı: >>> a = 20 exec() fonksiyonu yardımıyla a değişkeninin de içinde yer aldığı mevcut isim alanına müdahaleedelim: >>> exec(’a = 3’) Buşekildeadeğişkenininvarolandeğerinisilmişolduk: >>> print(a) 3 Dediğimiz gibi, bu tür durumlarda, exec() ile oluşturduğunuz değişkenleri global isim alanı yerine farklı bir isim alanına göndermeyi tercih etmemiz daha uygun olacaktır. Python’da isim alanlarının basit bir sözlük olduğunu öğrendiğimize göre, exec() ile oluşturduğumuz değişkenleriglobalisimalanıyerinenasılfarklıbirisimalanınagöndereceğimizigörebiliriz. Önceyenibirisimalanıoluşturalım: >>> ia = {} Şimdiexec()ileoluşturacağımızdeğerleribuisimalanınagönderebiliriz: >>> exec(’a = 3’, ia) Böyleceglobalisimalanındakiadeğişkeninindeğerinedokunmamışolduk: >>> a 20 Yenioluşturduğumuzdeğeriseiaadlıyeniisimalanınagitti: >>> ia[’a’] 3 640 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.26 copyright() BufonksiyonyardımıylaPython’ıntelifhaklarınailişkinbilgilereerişebilirsiniz: >>> copyright() Copyright (c) 2001-2012 Python Software Foundation. All Rights Reserved. Copyright (c) 2000 BeOpen.com. All Rights Reserved. Copyright (c) 1995-2001 Corporation for National Research Initiatives. All Rights Reserved. Copyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam. All Rights Reserved. 36.27 credits() Bufonksiyon,Pythonprogramlamadilinekatkıdabulunanlarateşekküriçerenküçükbirmetni ekranaçıktıolarakverir: >>> credits() Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands for supporting Python development. See www.python.org for more information. 36.28 license() BufonksiyonyardımıylaPython’ınlisansınailişkinepeyayrıntılımetinlereulaşabilirsiniz. 36.29 dir() Eğer dir() fonksiyonunu parametresiz olarak kullanırsak, mevcut isim alanındaki öğeleri bir listehalindeeldeederiz: >>> dir() [’__builtins__’, ’__doc__’, ’__loader__’, ’__name__’, ’__package__’] Bu bakımdan dir() fonksiyonu globals() ve locals() fonksiyonlarına benzer. Ancak onlardan farkı, dir() fonksiyonunun çıktı olarak bir liste, globals() ve locals() fonksiyonlarınınisebirersözlükvermesidir. 36.26. copyright() 641 PythonBelgeleri,Yayım4.1.3 Ayrıca dir() fonksiyonunu kullanarak nesnelerin metot ve niteliklerini içeren bir listeye ulaşabileceğimizidebiliyorsunuz.Örneğinbufonksiyonukullanarakfarklıveritiplerininmetot veniteliklerinilisteleyebiliriz: >>> dir(’’) >>> dir([]) >>> dir({}) 36.30 divmod() Bufonksiyonunişlevinibirörneküzerindengöstermeyeçalışalım: >>> divmod(10, 2) (5, 0) Gördüğünüzgibidivmod(10, 2)komutubizeikiöğelibirdemetveriyor.Budemetinilköğesi, divmod() fonksiyonuna verilen ilk parametrenin ikinci parametreye bölünmesi işleminin sonucudur. Demetimizin ikinci öğesi ise, ilk parametrenin ikinci parametreye bölünmesi işlemindenkalansayıdır.Yanidemetinilkparametresibölmeişleminin‘bölüm’kısmını,ikinci öğesiise‘kalan’kısmınıverir. Bufonksiyonunbölmeişleminininsonucunutamsayıcinsindenverdiğinedikkatediyoruz: >>> divmod(10, 3) (3, 1) 10 sayısı 3 sayısına bölündüğünde tamsayı cinsinden sonuç 3’tür. Bu bölme işleminin kalanı ise1’dir. 36.31 enumerate() İngilizcede enumerate kelimesi ‘numaralandırmak’ anlamına gelir. enumerate() fonksiyonunun görevi de kelimenin bu anlamıyla aynıdır. Yani bu fonksiyonu kullanarak nesnelerinumaralandırabiliriz. Bufonksiyonbizebir‘enumerate’nesnesiverir: >>> enumerate(’’) <class ’enumerate’> Bunesneniniçeriğinenasılerişebileceğimizibiliyorsunuz: Nesneyibirlisteyeçevirebiliriz: >>> list(enumerate(’’)) [(0, ’i’), (1, ’s’), (2, ’t’), (3, ’i’), (4, ’h’), (5, ’z’), (6, ’a’)] 642 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 veya: >>> [i for i in enumerate(’’)] [(0, ’i’), (1, ’s’), (2, ’t’), (3, ’i’), (4, ’h’), (5, ’z’), (6, ’a’)] print()fonksiyonunayıldızlıparametreolarakverebiliriz: >>> print(*enumerate(’’)) (0, ’i’) (1, ’s’) (2, ’t’) (3, ’i’) (4, ’h’) (5, ’z’) (6, ’a’) veyanesneüzerindebirdöngükurabiliriz: >>> for i in enumerate(’’): ... print(i) ... (0, ’i’) (1, ’s’) (2, ’t’) (3, ’i’) (4, ’h’) (5, ’z’) (6, ’a’) Gördüğünüz gibi, ‘enumerate’ nesnesi bize her koşulda iki öğeli demetler veriyor. Bu demetlerinherbiröğesinenasılulaşabileceğimizidebiliyorolmalısınız: >>> for sıra, öğe in enumerate(’’): ... print("{}. {:>2}".format(sıra, öğe)) ... 0. i 1. s 2. t 3. i 4. h 5. z 6. a Örneklerden de gördüğünüz gibi, enumerate() fonksiyonu bize bir dizi içindeki öğelerin sırasını ve öğenin kendisini içeren bir demet veriyor. Dikkat ettiyseniz, her zaman olduğu gibi,Pythonburadadasaymaya0’danbaşlıyor.Yanienumerate()fonksiyonununürettiğiöğe sıralamasında ilk öğenin sırası 0 oluyor. Elbette eğer isterseniz enumerate() fonksiyonunun saymayakaçtanbaşlayacağınıkendinizdebelirleyebilirsiniz: >>> for sıra, öğe in enumerate(’’, 1): ... print("{}. {:>2}".format(sıra, öğe)) ... 1. i 2. s 3. t 4. i (sonrakisayfayadevam) 36.31. enumerate() 643 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 5. h 6. z 7. a enumerate() fonksiyonuna verdiğimiz ikinci parametre saymaya kaçtan başlanacağını gösteriyor. Eğer bu fonksiyonu ikinci parametre olmadan kullanırsak Python bizim saymaya 0’danbaşlamakistediğimizivarsayacaktır. 36.32 exit() Bufonksiyon,oandaçalışanprogramdançıkmanızısağlar.Eğerbukomutuetkileşimlikabukta verirsenizoandaaçıkolanoturumkapanacaktır. 36.33 help() help() fonksiyonu gömülü fonksiyonlar içinde en faydalı fonksiyonların başında gelir. Bu fonksiyonu kullanarak Python programlama diline ait öğelere ilişkin yardım belgelerine ulaşabiliriz.Örneğin: >>> help(dir) Bukomutuverdiğimizdedir()fonksiyonununneişeyaradığınıgösterenİngilizcebirbelgeye ulaşırız. Gördüğünüz gibi, hakkında bilgi edinmek istediğimiz öğeyi help() fonksiyonuna parametreolarakvererekilgiliyardımdosyasınaerişebiliyoruz. Eğerbufonksiyonuparametresizolarakkullanırsak‘etkileşimliyardım’denenekranaulaşırız: >>> help() Welcome to Python 3.3! This is the interactive help utility. If this is your first time using Python, you should definitely check out the tutorial on the Internet at http://docs.python.org/3.3/tutorial/. Enter the name of any module, keyword, or topic to get help on writing Python programs and using Python modules. To quit this help utility and return to the interpreter, just type "quit". To get a list of available modules, keywords, or topics, type "modules", "keywords", or "topics". Each module also comes with a one-line summary of what it does; to list the modules whose summaries contain a given word such as "spam", type "modules spam". help> Buekranda,hakkındabilgiedinmekistediğinizöğeyihelp>ibaresindenhemensonra,boşluk bırakmadanyazaraköğeyeilişkinbilgilereulaşabilirsiniz: 644 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 help> dir Etkileşimliyardımekranındançıkmakiçin‘q’harfinebasabilirsiniz. 36.34 id() Python’da her nesnenin bir kimliğinin olduğunu biliyorsunuz. Kimlik işleçlerini incelediğimiz konudabundanbirmiktarbahsetmişveoradaid()adlıbirfonksiyondansözetmiştik. Oradaşöylebirörnekvermiştik: >>> a = 50 >>> id(a) 505494576 >>> kardiz = "Elveda Zalim Dünya!" >>> id(kardiz) 14461728 Orada söylediğimiz ve yukarıdaki örneklerden de bir kez daha gördüğünüz gibi, Python’daki hernesneninkimliğieşşiz,tekvebenzersizdir. 36.35 input() Bu fonksiyonun ne işe yaradığını gayet iyi biliyorsunuz. input() adlı bu gömülü fonksiyonu kullanarakkullanıcıileverialışverişindebulunabiliyoruz. 36.36 format() Bu gömülü fonksiyonun görevi, daha önce karakter dizilerini işlerken, karakter dizilerinin bir metodu olarak öğrendiğimiz format() metoduna benzer bir şekilde, karakter dizilerini biçimlendirmektir.Ancakformat()fonksiyonu,dahaönceöğrendiğimizformat()metoduna göre daha dar kapsamlıdır. format() metodunu kullanarak oldukça karmaşık karakter dizisi biçimlendirmeişlemlerinigerçekleştirebiliriz,amabirazdaninceleyeceğimizformat()gömülü fonksiyonuyalnızcatekbirdeğeribiçimlendirmekiçinkullanılır. Basitbirörnekverelim: >>> format(12, ’.2f’) ‘12.00’ Yukarıdakiifadeyidahaöncegördüğümüzformat()metoduileşuşekildeyazabiliriz: 36.34. id() 645 PythonBelgeleri,Yayım4.1.3 >>> ’{:.2f}’.format(12) ’12.00’ 36.37 filter() Bu gömülü fonksiyon yardımıyla dizi niteliği taşıyan nesneler içindeki öğeler üzerinde belirli bir ölçüte göre bir süzme işlemi uygulayabiliriz. Dilerseniz filter() fonksiyonunun görevini birörneküzerindenanlamayaçalışalım. Diyelimkielimizdeşöylebirlistevar: >>> l = [400, 176, 64, 175, 355, 13, 207, 298, 397, 386, 31, 120, 120, 236, 241, 123, 249, 364, 292, 153] ˓→ Amacımızbulisteiçindekiteksayılarısüzmek. Dahaönceöğrendiğimizyöntemlerikullanarakbugörevişuşekildeyerinegetirebiliriz: >>> for i in l: ... if i % 2 == 1: ... print(i) ... 175 355 13 207 397 31 241 123 249 153 Hatta eğer istersek liste üreteçlerini kullanarak aynı işlemi daha kısa bir yoldan da halledebiliriz: >>> [i for i in l if i % 2 == 1] [175, 355, 13, 207, 397, 31, 241, 123, 249, 153] İşte Python, yukarıdaki işlemi yapabilmemiz için bize üçüncü bir yol daha sunar. Bu üçüncü yolunadıfilter()fonksiyonudur.Dikkatlicebakın: def tek(sayı): return sayı % 2 == 1 print(*filter(tek, l)) Dilerseniz bu kodları daha iyi anlayabilmek için filter() fonksiyonuna biraz daha yakından bakalım... 646 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 filter() fonksiyonu toplam iki parametre alır. Bu parametrelerden ilki ölçütü belirleyen fonksiyon,ikincisiisebuölçütünuygulanacağıöğedir.Yukarıdakiörneğebaktığımızda,tek() adlıfonksiyonun,ladlıöğeüzerineuygulandığınıgörüyoruz. Yukarıdakiörnekteilkolaraktek()adlıbirfonksiyontanımladık: def tek(sayı): return sayı % 2 == 1 Bufonksiyonungörevi,kendisineparametreolarakverilenbirsayınınteksayıolupolmadığını sorgulamak. Eğer verilen parametre bir tek sayı ise fonksiyonumuz True değerini, tek sayı değilseFalsedeğerinidöndürecektir.İstersenizfonksiyonumuzutestedelim: print(tek(12)) 12sayısıbirteksayıolmadığıiçinfonksiyonumuzbizeFalseçıktısıverir. Birdeşunabakalım: print(tek(117)) 117sayısıisebirteksayıdır.BunedenlefonksiyonumuzbizeTruedeğeriniverecektir. İştebizbufonksiyonu,filter()fonksiyonuyardımıylaşulisteüzerineuygulayacağız: l = [400, 176, 64, 175, 355, 13, 207, 298, 397, 386, 31, 120, 120, 236, 241, 123, 249, 364, 292, 153] Dediğimizgibi,filter()fonksiyonu,diziözelliğitaşıyannesnelerüzerindebellibirölçütegöre filtreleme işlemi yapmamızı sağlar. Biz de biraz önce tanımladığımız tek() adlı fonksiyonu l adlıbulisteyeuygulayaraklisteiçindekiteksayılarıfiltreleyeceğiz. filter()fonksiyonunuçalıştıralım: >>> filter(tek, l) Burada filter() fonksiyonuna ilk parametre olarak tek() fonksiyonunu verdik. İkinci parametremiz ise bu fonksiyonu uygulayacağımız l adlı liste. Amacımız, l adlı liste üzerine tek() fonksiyonunu uygulayarak, bu liste içindeki öğelerden True çıktısı verenleri (yani tek sayıları)ayıklamak. Şimdideyukarıdakikoddanaldığımızçıktıyabakalım: <filter object at 0x00F74F30> Gördüğünüz gibi, bu fonksiyonu bu şekilde kullandığımızda elde ettiğimiz şey bir ‘filtre nesnesi’.Bunesneiçindekiöğelerigörebilmekiçinneyapabileceğimizibiliyorsunuz: >>> list(filter(tek, l)) [175, 355, 13, 207, 397, 31, 241, 123, 249, 153] veya: 36.37. filter() 647 PythonBelgeleri,Yayım4.1.3 >>> print(*filter(tek, l)) 175 355 13 207 397 31 241 123 249 153 yada: >>> [i for i in filter(tek, l)] [175, 355, 13, 207, 397, 31, 241, 123, 249, 153] Gördüğünüzgibi,gerçektendeladlılisteiçindekibütünteksayılarsüzüldü. Gelin isterseniz filter() fonksiyonunu biraz daha iyi anlayabilmek için basit bir çalışma yapalım. ElimizdebirsınıftakiöğrencilerinMatematiksınavındanaldığınotlarıiçerenbirsözlükvar: notlar = {’Ahmet’ : 60, ’Sinan’ : 50, ’Mehmet’ : 45, ’Ceren’ : 87, ’Selen’ : 99, ’Cem’ : 98, ’Can’ : 51, ’Kezban’ : 100, ’Hakan’ : 66, ’Mahmut’ : 80} Okuldakullanılannotsisteminegöreyukarıdakinotlarışuşekildesınıflandırabiliyoruz: def not_durumu(n): if n in range(0, 50): return ’F’ if n in range(50, 70): return ’D’ if n in range(70, 80): return ’C’ if n in range(80, 90): return ’B’ if n in range(90, 101): return ’A’ Bunagöremeselaprint(not_durumu(54))gibibirkodyazdığımızdabunotunkarşılıkgeldiği ‘D’ sayısını alabiliyoruz. Peki biz bu notları belli bir ölçüte göre süzmek, ayıklamak istersek ne yapabiliriz? Örneğin notu 70’ten yukarı olan öğrencileri listelemek istersek nasıl bir kod yazabiliriz? İşteböylebirdurumdafilter()adlıgömülüfonksiyonukullanabiliriz: notlar = {’Ahmet’ : 60, ’Sinan’ : 50, ’Mehmet’ : 45, ’Ceren’ : 87, ’Selen’ : 99, ’Cem’ : 98, ’Can’ : 51, ’Kezban’ : 100, (sonrakisayfayadevam) 648 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’Hakan’ : 66, ’Mahmut’ : 80} def süz(n): return n >= 70 print(*filter(süz, notlar.values())) Gördüğünüz gibi, filter() fonksiyonu, süz() adlı fonksiyon ile belirlediğimiz ölçütü notlar adlısözlüğündeğerleriüzerinetektekuygulamamızısağlıyor. 36.38 hash() Bufonksiyon,belirlitürdekinesnelerebirkarmadeğerivermemizisağlar.Örneğin: >>> hash(’’) -840510580 >>> hash(’python’) 212829695 Ancak bu fonksiyonun ürettiği çıktı aynı nesne için bütün sistemlerde aynı olmayabilir. Yani örneğin yukarıdaki hash(’’) komutu 32 bitlik ve 64 bitlik işletim sistemlerinde birbirinden farklı sonuçlar verebilir. Ayrıca bu fonksiyonun ürettiği karma değerlerinin birbiriyle çakışma ihtimali de yüksektir. Dolayısıyla bu fonksiyonu kullanarak, mesela parola girişleriiçinkarmadeğeriüretmekdoğruolmaz. 36.39 isinstance() Hatırlarsanız daha ilk derslerimizde öğrendiğimiz type() adlı bir fonksiyon vardı. Bu fonksiyonubirnesneninhangiveritipindeolduğunutespitetmekiçinkullanıyorduk: >>> type(’’) <class ’str’> İşte buna benzer şekilde, tip denetimi için kullanabileceğimiz bir fonksiyon daha var. Bu fonksiyonunadıisinstance(). Bufonksiyonuşöylekullanıyoruz: >>> isinstance(’’, str) True 36.38. hash() 649 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi ’’ gerçekten bir karakter dizisi (str) olduğu için komutumuz True çıktısıveriyor. Birdeşunabakalım: >>> isinstance(’’, list) False ’’birliste(list)olmadığıiçinkomutumuzbukezFalseçıktısıverdi. 36.40 len() Bufonksiyonyardımıylanesnelerinuzunluklarınıhesaplayabileceğimizibiliyorsunuz: >>> len(’’) 7 >>> l = [1, 4, 5, 3, 2, 9, 10] >>> len(l) 7 36.41 map() Diyelimkielimizdeşöylebirlistevar: >>> l = [1, 4, 5, 4, 2, 9, 10] Amacımız bu liste içindeki her öğenin karesini hesaplamak. Bunun için şöyle bir yol izleyebiliriz: >>> for i in l: ... i ** 2 ... 1 16 25 16 4 81 100 Böylece,istediğimizgibi,bütünöğelerinkaresinibulmuşolduk.Butürbirişlemiyapmanınbir başkayoludamap()adlıbirgömülüfonksiyondanyararlanmaktır.Dikkatlicebakın: 650 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> def karesi(n): ... return n ** 2 ... Burada bir n sayısının karesini hesaplayan bir fonksiyon tanımladık. Şimdi bu fonksiyonu l listesininbütünöğeleriüzerineuygulayacağız: >>> list(map(karesi, l)) [1, 16, 25, 16, 4, 81, 100] 36.42 max() max()gömülüfonksiyonunungörevi,birdiziiçindekienbüyüköğeyivermektir.Bufonksiyon birkaçfarklıparametrealırveverdiğiçıktı,aldığıparametrelerintürünevesayısınabağlıolarak değişiklikgösterebilir. Bufonksiyonuenbasitşuşekildekullanabilirsiniz: >>> max(1, 2, 3) 3 max()fonksiyonuyukarıdakişekildeçalıştırıldığında,kendisineverilenparametrelerarasında enbüyükolanıbulacaktır.Yukarıdakiparametrelerdenenbüyüğü3olduğuiçindeyukarıdaki komut3çıktısıverecektir. Yukarıdakikodlarınsağladığıetkiyişuşekildedeeldeedebiliriz: >>> liste = [1, 2, 3] >>> max(liste) 3 max() fonksiyonu yukarıda gösterildiği gibi birtakım isimsiz parametrelerle birlikte key adlı isimli bir parametre de alır. Bu parametre yardımıyla max() fonksiyonunun ‘en büyük’ kavramınıhangiölçütegöreseçeceğinibelirleyebiliriz.Örneğin: >>> isimler = [’ahmet’, ’can’, ’mehmet’, ’selin’, ’abdullah’, ’kezban’] >>> max(isimler, key=len) ’abdullah’ max() fonksiyonu öntanımlı olarak, ‘en büyük’ kavramını sayısal büyüklük üzerinden değerlendirir. Yani herhangi bir key parametresi kullanılmadığında, bu fonksiyon otomatik olarak bir dizi içindeki en büyük sayıyı bulur. Ancak eğer biz istersek, yukarıdaki örnekte olduğugibi,‘enbüyük’kavramınınuzunlukcinsindendeğerlendirilmesinidesağlayabiliriz. Yukarıdakiörnekteelimizdeşöylebirlistevar: 36.42. max() 651 PythonBelgeleri,Yayım4.1.3 >>> isimler = [’ahmet’, ’can’, ’mehmet’, ’selin’, ’abdullah’, ’kezban’] Amacımız bu liste içindeki isimler arasından, en fazla harf içerenini bulmak. Bildiğiniz gibi Python’da bir karakter dizisinin uzunluğunu belirlemek için len() adlı bir fonksiyondan yararlanıyoruz. İşte aşağıdaki kod yardımıyla da max() fonksiyonunun ‘en büyük’ ölçütünü len()fonksiyonuüzerindendeğerlendirmesinisağlıyoruz: >>> max(isimler, key=len) Buaradakeyfonksiyonunalen()fonksiyonunuparantezsizolarakverdiğimizedikkatedin. Gelinistersenizmax()fonksiyonunubirazdahaiyianlamakiçinufakbirçalışmayapalım. Diyelimkielimizdeşöylebirsözlükvar: askerler = {’ahmet’ : ’onbaşı’, ’mehmet’ : ’teğmen’, ’ali’ : ’yüzbaşı’, ’cevat’ : ’albay’, ’berkay’ : ’üsteğmen’, ’mahmut’ : ’binbaşı’} Amacımız bu sözlük içindeki en yüksek askeri rütbeyi bulmak. İşte bunun için max() fonksiyonundanyararlanabiliriz. Bildiğinizgibi,max()fonksiyonuölçütolaraksayısalbüyüklüğügözönünealıyor.Elbetteaskeri rütbeleri böyle bir ölçüte göre sıralamak pek mümkün değil. Ama eğer şöyle bir fonksiyon yazarsakişlerdeğişir: def en_yüksek_rütbe(rütbe): rütbeler = {’er’ : 0, ’onbaşı’ : 1, ’çavuş’ : 2, ’asteğmen’ : 3, ’teğmen’ : 4, ’üsteğmen’ : 5, ’yüzbaşı’ : 6, ’binbaşı’ : 7, ’yarbay’ : 8, ’albay’ : 9} return rütbeler[rütbe] Burada, rütbelerin her birine bir sayı verdik. En küçük rütbe en düşük sayıya, en yüksek rütbeiseenbüyüksayıyasahip.Fonksiyonumuzbiradetparametrealıyor.Buparametrenin adı rütbe. Yazdığımız fonksiyon, kendisine parametre olarak verilecek rütbeyi rütbeler adlı sözlüktearayıp,burütbeyekarşılıkgelensayıyıdöndürecek. Bubilgilerikullanarakkodlarımızınsonhalinidüzenleyelim: def en_yüksek_rütbe(rütbe): rütbeler = {’er’ : 0, ’onbaşı’ : 1, (sonrakisayfayadevam) 652 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’çavuş’ : 2, ’asteğmen’ : 3, ’teğmen’ : 4, ’üsteğmen’ : 5, ’yüzbaşı’ : 6, ’binbaşı’ : 7, ’yarbay’ : 8, ’albay’ : 9} return rütbeler[rütbe] askerler = {’ahmet’: ’onbaşı’, ’mehmet’: ’teğmen’, ’ali’: ’yüzbaşı’, ’cevat’: ’albay’, ’berkay’: ’üsteğmen’, ’mahmut’: ’binbaşı’} Artıkmax()fonksiyonunuaskerleradlısözlüküzerindeuygulayabiliriz: print(max(askerler.values(), key=en_yüksek_rütbe)) Böylece askerler adlı sözlüğün değerleri en_yüksek_rütbe() fonksiyonunun sunduğu ölçüt üzerindenelealınacakveenbüyüksayıdeğerinesahipolanrütbeçıktıolarakverilecektir. Yukarıdaki kodlar problemimizi çözüyor. Peki ama ya biz rütbe ile birlikte bu rütbeyi taşıyan askerinadınıdaöğrenmekisterseknasılbirkodyazacağız? Bununiçindeşöylebirkodyazabiliriz: for k, v in askerler.items(): if askerler[k] in max(askerler.values(), key=en_yüksek_rütbe): print(v, k) Eğeristersenizburadainişleciyerine==işlecinidekullanabilirsiniz: for k, v in askerler.items(): if askerler[k] == max(askerler.values(), key=en_yüksek_rütbe): print(v, k) 36.43 min() min()fonksiyonumax()fonksiyonununtamtersiniyapar.Bildiğinizgibimax()fonksiyonubir dizi içindeki en büyük öğeyi buluyordu. İşte min() fonksiyonu da bir dizi içindeki en küçük öğeyibulur.Bufonksiyonunkullanımımax()ileaynıdır. 36.43. min() 653 PythonBelgeleri,Yayım4.1.3 36.44 open() Bu fonksiyon herhangi bir dosyayı açmak veya oluşturmak için kullanılır. Eğer dosyanın açılmasıveyaoluşturulmasıesnasındabirhataortayaçıkarsaIOErrortüründebirhatamesajı verilir. Bufonksiyonunformülüşudur: >>> open(dosya_adi, mode=’r’, buffering=-1, encoding=None, ... errors=None, newline=None, closefd=True, opener=None) Gördüğünüz gibi, bu fonksiyon pek çok farklı parametre alabiliyor. Biz şimdiye kadar bu parametrelerin yalnızca en sık kullanılanlarını işlemiştik. Şimdi ise geri kalan parametrelerin neişeyaradığınıdaelealacağız. Yukarıdaki formülden de görebileceğiniz gibi, open() fonksiyonunun ilk parametresi dosya_adi’dır. Yani açmak veya oluşturmak istediğimiz dosya adını bu parametre ile belirtiyoruz: >>> open(’falanca_dosya.txt’) Elbette eğer açmak istediğiniz dosya, o anda içinde bulunduğunuz dizinde değilse dosya adı olarak,odosyanıntamadresiniyazmanızgerekir.Mesela: >>> open(’/home//Desktop/dosya.txt’) Bu arada, dosya adresini yazarken ters taksim yerine düz taksim işaretlerini kullanmak daha doğru olacaktır. Bu taksim türü hem Windows’ta hem de GNU/Linux’ta çalışır. Ancak eğer terstaksimişaretlerinikullanacaksanız,dosyayoluiçindekisinsikaçışdizilerinekarşıdikkatli olmalısınız: >>> f = open(’test\nisan.txt’) Traceback (most recent call last): File "<stdin>", line 1, in <module> OSError: [Errno 22] Invalid argument: ’test\nisan.txt’ Buradaprobleminnisan.txtadlıdosyanınilkharfiile,bundanöncegelenterstaksimişaretinin birleşerektesadüfenbirkaçışdizisioluşturmasıolduğunubiliyorsunuz.Butürhatalarakarşı ters taksim yerine düz taksim işaretlerini kullanabileceğiniz gibi r adlı kaçış dizisinden de yararlanabilirsiniz: f = open(r’test\nisan.txt’) open() fonksiyonunun ikinci parametresi olan mode’un da ne olduğunu biliyorsunuz. Bu parametreyardımıyla,herhangibirdosyayıhangikipteaçmakistediğimizibelirtebiliyoruz. Bildiğinizgibi,eğermodeparametresineherhangibirdeğervermezsenizPythonilgilidosyayı okumakipindeaçacaktır. Buparametreyeverebileceğinizdeğerlerişöyleözetleyebiliriz: 654 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 tabularytabulary Karakter Anlamı ‘r’ Okumakipidir.Öntanımlıdeğerbudur. ‘w’ Yazmakipidir.Eğerbelirtilenaddadosyazatenvarsaodosyasilinir. ‘x’ Yenibirdosyaoluşturulupyazmakipindeaçılır. ‘a’ Dosyaeklemekipindeaçılır.Bukipile,varolanbirdosyanınsonunaeklemeleryapılabilir. ‘b’ Dosyalarıikilikipteaçmakiçinkullanılır. ‘t’ Dosyalarımetinkipindeaçmakiçinkullanılır.Öntanımlıdeğerdir. ‘+’ Aynıdosyaüzerindehemokumahemdeyazmaişlemleriyapılmasınısağlar. open()fonksiyonununalabileceğibirbaşkaparametredebufferingparametresidir.Bildiğiniz gibi, open() fonksiyonuyla bir dosyayı açıp bu dosyaya veri girdiğimizde bu veriler önce tampona alınacak, dosya kapandıktan sonra ise tamponda bekletilen veriler dosyaya işlenecektir. İşte bu buffering parametresi yardımıyla bu tampona alma işleminin nasıl yürüyeceğinibelirleyebiliriz. Eğerdosyayaişlenecekverilerintamponaalınmadandoğrudandosyayaişlenmesiniisterseniz buffering değerini 0 olarak belirlersiniz. Yalnız bu değer sadece ikili kipte etkindir. Yani bir dosyayıeğermetinkipindeaçıyorsanızbufferingparametresinindeğerini0yapamazsınız. Eğerdosyayaveriişlerkentamponaalınanverilerinsatırsatırdosyayaeklenmesiniisterseniz buffering değerini 1 olarak belirlersiniz. Bunun nasıl çalıştığını anlamak için şu örneği dikkatliceinceleyin: >>> f = open(’ni.txt’, ’w’, buffering=1) >>> f.write(’birinci satır\n’) 14 >>> f.write(’ikinci satır\n’) 13 >>> f.write(’aaa’) 3 >>> f.write(’\n’) 1 Burada her write() komutundan sonra ni.txt adlı dosyayı açıp bakarsanız, şu durumu görürsünüz: • f.write(’birinci satır\n’) komutuyla dosyaya bir satırlık veri ekledik ve bu veri dosyayaanındaişlendi. • f.write(’ikinci satır\n’)komutuyladosyayabirsatırlıkbaşkabirveridahaekledik vebuveridedosyayaanındaişlendi. • f.write(’aaa’)komutuylaeklenenverisatırdeğil.Çünküsatırsonunaişaretedensatır başıkaçışdizisinikullanmadık. • f.write(’\n’) komutuyla satır başı kaçış dizisini eklediğimiz anda bir önceki karakter 36.44. open() 655 PythonBelgeleri,Yayım4.1.3 dizisi(’aaa’)dedosyayaeklenecektir. Ancak buffering parametresi bu 1 değerini yalnızca metin kipinde alabilir. Bu kısıtlamayı da aklımızınbirkenarınanotedelim... 0 ve 1 dışında buffering parametresine 1’den büyük bir değer verdiğinizde ise tampon boyutununnekadarolacağınıkendinizbelirlemişolursunuz. Yalnız çoğu durumda buffering parametresine herhangi bir özel değer atamanız gerekmeyecektir. Bu parametreye herhangi bir değer atamadığınızda, kullandığınız işletim sistemi tampona alma işlemlerininin nasıl yürütüleceğine ve tampon boyutuna kendisi karar verecektir. İşletim sisteminin sizin yerinize verdiği bu karar da çoğunlukla istediğiniz şey olacaktır... Eğer kendi sisteminizde öntanımlı tampon boyutunun ne olduğunu merak ediyorsanızşukomutlarıkullanabilirsiniz: >>> import io >>> io.DEFAULT_BUFFER_SIZE Çoğusistemdebudeğer4096ve8192baytolacaktır. open() fonksiyonunun alabileceği bir başka parametre de encoding parametresidir. Bu parametre, dosyanın hangi karakter kodlaması ile açılacağını belirler. Örneğin bir dosyayı ‘UTF-8’karakterkodlamasıileaçmakiçinşukomutukullanıyoruz: >>> f = open(’dosya’, encoding=’utf-8’) Üzerinde işlem yaptığınız dosyalarda özellikle Türkçe karakter sorunları yaşamak istemiyorsanız, bir dosyayı açarken mutlaka encoding parametresinin değerini de ayarlamanızıtavsiyeederim. Bir dosyayı açarken veya okurken herhangi bir karakter kodlama hatası ile karşılaştığınızda Python’ınnetepkivermesigerektiğiniiseerrorsadlıparametreyardımıylabelirleyebilirsiniz. Eğer bu parametreye strict değerini verirseniz karakter kodlama hataları programınızın ValueError türünde bir hata vererek çalışmayı kesmesine neden olacaktır. Bu parametreye herhangibirdeğervermediğinizdedePythonsankistrictdeğerinivermişsinizgibidavranır. Eğererrorsparametresineignoredeğeriniverirsenizkodlamahatalarıgörmezdengelinecek, buhatayasebepolankaraktersilinecektir.Yalnızbudeğerinverikaybınayolaçmaihtimalini degözönündebulundurmalısınız. Eğer errors parametresine replace değerini verirseniz kodlama hatasına yol açan karater ‘?’ veya‘ufffd’karakterleriiledeğiştirilecektir. open()fonksiyonununkabulettiğibirbaşkaparametredenewlineadlıparametredir.Pekibu parametreneişeyarar? WindowsveGNU/Linuxişletimsistemlerisatırsonlarınıbirbirlerindenfarklışekildegösterir. GNU/Linux’ta yazılmış dosyalarda satır sonları \n karakteri ile gösterilirken, Windows’ta yazılmış dosyalarda satır sonunda \r\n karakterleri bulunur. Eğer Windows ve GNU/Linux sistemleriarasındadosyaalışverişiyapıyorsanızkimidurumlardabufarklılıkçeşitlisorunların ortaya çıkmasına yol açabilir. İşte dosyalarınızın hangi satır sonu karakterine sahip olacağını yukarıdabahsettiğimiznewlineadlıparametreilebelirleyebilirsiniz.Örneğin: >>> f = open(’dosya’, newline=’\n’) 656 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Buşekildedosyanızhangiişletimsistemindeolursaolsunsatırsonlarında\nkarakterinesahip olacaktır. Dosyaların metotlarını incelerseniz o listede fileno() adlı bir metodun olduğunu göreceksiniz. Bu metot, bize bir dosyanın ‘dosya tanımlayıcısını’ (file descriptor) verir. Dosya tanımlayıcıları, dosyaya işaret eden pozitif tam sayılardır. 0, 1 ve 2 sayıları standart girdi, standartçıktıvestandarthatadosyalarınaayrılmışolduğuiçin,sizinaçtığınızveüzerindeişlem yaptığınızdosyalarıntanımlayıcıları2sayısındanbüyükolacaktır. Birörnekverelim: >>> f = open(’ni.txt’) >>> f.fileno() 3 İşteburadagördüğünüzsayı,ni.txtadlıdosyanın‘dosyatanımlayıcısıdır.Herdosyanındosya tanımlayıcısıbenzersizdir: >>> g = open(’zi.txt’) >>> g.fileno() 4 Python’dabirdosyayıopen()fonksiyonuylaaçarkendosyaadınıvermeninyanısıra,dosyanın tanımlayıcısınıdakullanabilirsiniz: >>> z = open(4) veya: >>> z = open(g.fileno()) Bu sayede, eğer isterseniz, elinizdeki dosyalarla daha ileri düzeyli işlemler yapabilirsiniz. Bir örnekverelim. Dediğimiz gibi, bir dosyanın tanımlayıcısı tek ve benzersizdir. Farklı dosyalar aynı tanımlayıcılarasahipolmaz: >>> a = open(’aaa.txt’) >>> a.fileno() 3 >>> b = open(’bbb.txt’) >>> b.fileno() 4 Şimdişuörneklerebakın: >>> c = open(b.fileno(), closefd=False) 36.44. open() 657 PythonBelgeleri,Yayım4.1.3 Bu şekilde b adlı dosyanın tanımlayıcısını kullanarak, aynı dosyayı bir de c adıyla açtık. Ancak burada kullandığımız closefd=False parametresine dikkat edin. Normalde dosyayı kapattığımızda dosyanın tanımlayıcısı serbest kalır ve başka bir dosya açıldığında bu tanımlayıcıyenidosyayaatanır.AmaclosefdparametresineFalsedeğeriverdiğimizdedosya kapansabile,odosyayaaitdosyatanımlayıcısıvarolmayadevamedecektir. 36.45 pow() Dahaöncekiderslerimizdepekçokkezörnekleriniverdiğimizbufonksiyonİngilizcedekipower (kuvvet)kelimesininkısaltmasındanoluşur.Adınınanlamınauygunolarak,bufonksiyonubir sayınınkuvvetlerinihesaplamakiçinkullanıyoruz. Bufonksiyonentemelşekildeşöylekullanılır: >>> pow(2, 3) 8 Bukomutla2sayısının3.kuvvetinihesaplamışoluyoruz. pow() fonksiyonu toplamda üç farklı parametre alır. İlk iki parametrenin ne olduğunu yukarıda örnekledik. Üçüncü parametre ise kuvvet hesaplaması sonucu elde edilen sayının modülüsünühesaplayabilmemizisağlar.Yani: >>> pow(2, 3, 2) 0 Burada yaptığımız şey şu: Öncelikle 2 sayısının 3. kuvvetini hesapladık. Elde ettiğimiz sayı 8. Ardından da bu sayının 2’ye bölünmesi işleminden kalan sayıyı elde ettik. Yani 0. Çünkü bildiğinizgibi8 % 2işlemininsonucu0’dır.Dolayısıylayukarıdakikomutşunaeşdeğerdir: >>> (2 ** 3) % 2 0 Ancak önceki derslerimizde de söylediğimiz gibi, pow() fonksiyonu çoğunlukla yalnızca ilk iki parametresiilebirliktekullanılır: >>> pow(12, 2) 144 658 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.46 print() print()fonksiyonunuartıkgayetiyitanıyoruz.Bufonksiyonu,bildiğinizgibi,kullanıcılarımıza birtakımmesajlargöstermekiçinkullanıyoruz. Kullanımını daha önce ayrıntılı bir şekilde anlatmış olduğumuz bu fonksiyonu şu şekilde formüleedebiliriz: print(deg1, deg2, deg3, ..., sep=’ ’, end=’\n’, file=sys.stdout, flush=False) Burada; degx Çıktı verilecek değerlerin ne olduğunu belirtir. Buraya 256 adete kadardeğeryazabilirsiniz. sep Çıktı verilirken değerlerin arasına hangikarakterin yerleştirileceğini belirtir.Budeğeröntanımlıolarakboşlukkarakteridir. end Çıktı verilecek son değerin ardından hangi karakterin iliştirileceğini belirtir.Budeğeröntanımlıolaraksatırbaşı(\n)karakteridir. file Çıktıların hangi dosyaya yazılacağını belirtir. Öntanımlı olarak bu parametrenin değeri sys.stdout’tur. Yani print() fonksiyonu çıktılarınıöntanımlıolarakstandartçıktıkonumunagönderir. flush Bildiğinizgibi,herhangibirdosyayayazmaişlemisırasındadosyaya yazılacak değerler öncelikle tampona alınır. İşlem tamamlandıktan sonra tampondaki bu değerler topluca dosyaya aktarılır. İşte bu parametre, değerleri tampona almadan doğrudan dosyaya gönderebilmemizi sağlar. Bu parametrenin öntanımlı değeri False’tur. Yani değerler dosyaya yazılmadan önce öntanımlı olarak öncelikle tampona gider. Ama eğer biz bu parametrenin değerini Trueolarakdeğiştirirsek,değerlerdoğrudandosyayayazılır. 36.46. print() 659 PythonBelgeleri,Yayım4.1.3 36.47 quit() Bu fonksiyonu programdan çıkmak için kullanıyoruz. Eğer bu fonksiyonu etkileşimli kabukta verecekolursanızetkileşimlikabukkapanacaktır. 36.48 range() Bufonksiyonubellibiraralıktakisayılarılistelemekiçinkullanıyoruz.Yanimesela0ile10arası sayılarınlistesinialmakistersekşöylebirkomutyazabiliriz: >>> l = range(0, 10) Ancakburadadikkatetmemizgerekenbirözellikvar:Bufonksiyonaslındadoğrudanherhangi birsayılistesioluşturmaz.Yukarıdaldeğişkenineatadığımızkomutuekranayazdırırsakbunu dahanetgörebilirsiniz: >>> print(l) range(0, 10) Birdebuverinintipinebakalım: >>> type(l) <class ’range’> Gördüğünüz gibi, elimizdeki şey aslında bir sayı listesi değil, bir ‘range’ (aralık) nesnesidir. Biz bu nesneyi istersek başka veri tiplerine dönüştürebiliriz. Mesela bunu bir listeye dönüştürelim: >>> list(l) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] veyabirdemete: >>> tuple(l) (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) yadabirkümeyeveyadondurulmuşkümeye: >>> set(l) #küme {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} >>> frozenset(l) #dondurulmuş küme frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) 660 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Bu ‘range’ nesnesini istediğiniz veri tipine dönüştürdükten sonra, dönüştürdüğünüz veri tipininkurallarıçerçevesindeelinizdekiveriyiişleyebilirsiniz. range()fonksiyonundaneldeettiğiniz‘range’nesnesininiçeriğinieldeetmekiçinbunubaşka birveritipinedönüştürmeninyanısıra,bunesneüzerindebirfordöngüsüdekurabilirsiniz: >>> for i in range(10): ... print(i) ... 0 1 2 3 4 5 6 7 8 9 Ya da yıldızlı parametreler yardımıyla bu nesneyi print() fonksiyonuna göndererek, bu nesneyiistediğinizgibieviripçevirebilirsiniz: >>> print(*range(10), sep=’, ’) 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Esasında, yukarıda nasıl kullanılacağına dair bazı örnekler verdiğimiz bu range() fonksiyonunutemelolarakşuşekildeformüleedebiliriz: range(başlangıç_değer, bitiş_değeri, atlama_değeri) Aşağıdakiörneğitekrarelealalım: >>> range(0, 10) Burada 0 başlangıç değeri, 10 ise bitiş değeridir. Buna göre oluşturulacak sayılar 0 ile 10 arasında olacaktır. Yalnız burada üretilecek sayı listesinde 0 sayısının dahil, 10 sayısının ise hariçolduğunuunutmuyoruz.Yanibukomutunbizevereceğiilksayı0;sonsayıise9olacaktır. range() fonksiyonunda başlangıç değerinin öntanımlı değeri 0’dır. Dolayısıyla istersek biz yukarıdakikomutuşöyledeyazabiliriz: >>> range(10) Böylece Python bizim range(0, 10) komutunu kastettiğimizi varsayacaktır. Elbette eğer başlangıçdeğerinin0dışındabirdeğerolmasınıistiyorsanızbunuözelliklebelirtmenizgerekir: >>> range(10, 100) Bukomutbize10ile(10dahil)100arası(100hariç)sayılarıiçerenbir‘range’nesnesiverecektir. Yukarıda verdiğimiz formülden de göreceğiniz gibi, başlangıç_değer ve bitiş_değer dışında range()fonksiyonuüçüncübirparametredahaalabiliyor.Buparametreyeatlama_değeriadı 36.48. range() 661 PythonBelgeleri,Yayım4.1.3 verdik.Buparametreyişöylekullanıyoruz: >>> list(range(0, 10, 2)) [0, 2, 4, 6, 8] Gördüğünüzgibi,range()fonksiyonunaüçüncüparametreolarakverdiğimiz2sayısı,0ile10 arasısayılarınikişerikişeratlanaraküretilmesinisağladı. 36.49 reversed() Diyelimkielimizdeşöylebirlistevar: >>> isimler = [’ahmet’, ’mehmet’, ’veli’, ’ayşe’, ’çiğdem’, ’ışık’] Eğerbulistedekiisimleritersçevirmek,yanişöylebirlisteeldeetmekisterseniz: [’ışık’, ’çiğdem’, ’ayşe’, ’veli’, ’mehmet’, ’ahmet’] ... ne yapmanız gerektiğini biliyorsunuz. Bu amaç için liste dilimleme yöntemlerinden yararlanabilirsiniz: >>> isimler[::-1] [’ışık’, ’çiğdem’, ’ayşe’, ’veli’, ’mehmet’, ’ahmet’] İşteaynıişlevireversed()adlıbirfonksiyonyardımıyladayerinegetirebilirsiniz: >>> reversed(isimler) <list_reverseiterator object at 0x00EB9710> Gördüğünüz gibi, tıpkı range() fonksiyonunda olduğu gibi, reversed() fonksiyonu da bize ürettiği öğelerin kendisi yerine, bir ‘nesne’ veriyor. Ama tabii ki bu bizim için bir sorun değil. Bizbunesneniniçeriğininasıleldeedebileceğimizigayetiyibiliyoruz: >>> list(reversed(isimler)) [’ışık’, ’çiğdem’, ’ayşe’, ’veli’, ’mehmet’, ’ahmet’] range() fonksiyonunu anlatırken sözünü ettiğimiz içerik elde etme yöntemlerini reversed() fonksiyonunadauygulayabilirsiniz. 662 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.50 sorted() Bumetot,dahaöncekiderslerimizdendebildiğinizgibi,birdiziiçindekiöğeleribelirlibirölçüte göresırayadizmemizisağlıyor.Bununlailgiliçokbasitbirörnekverelim: >>> sorted(’ahmet’) [’a’, ’e’, ’h’, ’m’, ’t’] Bukodlaryardımıylaahmetadlıkarakterdizisiiçindekiharflerialfabesırasınadizdik. Elbette bu fonksiyonu sadece karakter dizileri üzerine uygulamıyoruz. sorted() adlı fonksiyon, dizi özelliği taşıyan her türlü nesne üzerine uygulanabilir. Mesela demetlerin ve listelerinbirdiziolduğunubiliyoruz.Dolayısıyla: >>> sorted((’elma’, ’armut’, ’kiraz’, ’badem’)) [’armut’, ’badem’, ’elma’, ’kiraz’] >>> sorted([’elma’, ’armut’, ’kiraz’, ’badem’]) [’armut’, ’badem’, ’elma’, ’kiraz’] sorted() fonksiyonuna hangi türde bir veri tipi verirseniz verin, aldığınız çıktı her zaman bir listeolacaktır.Bunuunutmayın. Gördüğünüzgibi,sorted()fonksiyonunesnelerüzerindebirsıralamaişlemigerçekleştiriyor. Ancakbufonksiyonunbirproblemivar. Dikkatlicebakın: >>> isimler = [’ahmet’, ’çiğdem’, ’ışık’, ’şebnem’, ’zeynep’, ’selin’] >>> sorted(isimler) [’ahmet’, ’selin’, ’zeynep’, ’çiğdem’, ’ışık’, ’şebnem’] Bufonksiyon,Türkçekarakteriçerenöğeleridüzgünsıralayamaz. Bu sorunu kısmen çözebilmek için locale adlı bir modül içindeki strxfrm() adlı bir fonksiyondanyararlanabilirsiniz: >>> import locale Henüz modülleri öğrenmemiş de olsak, bir modülü kullanabilmek için öncelikle o modülü ‘içe aktarmamız’ gerektiğini artık biliyorsunuz. Bu işlemi import adlı bir komut yardımıyla yaptığımızıdabiliyorsunuz. Şimdideyerelimizi(locale)‘Türkçe’olarakayarlayalım: >>> locale.setlocale(locale.LC_ALL, ’tr_TR’) #GNU/Linux >>> locale.setlocale(locale.LC_ALL, ’Turkish_Turkey.1254’) #Windows Bu işlemleri yaptıktan sonra, sorted() fonksiyonunun key adlı bir parametresini kullanarak ve yine locale modülünün strxfrm() adlı fonksiyonundan faydalanarak Türkçe karakterler içerenlistemizisıralamayıdeneyebiliriz: 36.50. sorted() 663 PythonBelgeleri,Yayım4.1.3 >>> sorted(isimler, key=locale.strxfrm) [’ahmet’, ’çiğdem’, ’ışık’, ’selin’, ’şebnem’, ’zeynep’] locale modülü içinde bulunan strxfrm() adlı fonksiyon, karakter dizilerinin, o anda etkin yerel neyse, ona göre muamele görmesini sağlar. Biz yukarıda yerelimizi Türkçe olarak ayarladığımıziçinstrxfrm()fonksiyonu,sorted()ileyapılanalfabesırasınadizmeişleminin Türkçeninkurallarınagöreyapılmasınısağlıyor. Ancak bu yöntemin de sorunlu olduğunu bir süre sonra kendiniz de farkedeceksiniz. Mesela şuörneğiinceleyin: >>> sorted(’afgdhkıi’, key=locale.strxfrm) [’a’, ’d’, ’f’, ’g’, ’h’, ’i’, ’ı’, ’k’] Gördüğünüzgibi,listede‘i’harfi‘ı’harfindenöncegeliyor.Amaaslındabununtersiolmalıydı. İşte böyle bir durumda, kendi sıralama mekanizmamızı kendimiz icat etmeliyiz. Peki ama nasıl? Bilgisayarlarfarklıdillerdekikarakterleriherzamandoğrusıralayamasada,sayılarıherzaman doğrusıralar: >>> sorted([10, 9, 4, 14, 20]) [4, 9, 10, 14, 20] BilgisayarlarınbuözelliğindenvePython’dakisözlükveritipindenyararlanarakkendisıralama mekanizmamızırahatlıklaicatedebiliriz. Öncelikleharflerimiziyazalım: >>> harfler = "abcçdefgğhıijklmnoöprsştuüvyz" BuradaTürkalfabesinioluşturanharflerisırasınagöredizdik.Şimdibuharflerinherbirinebir sayıvereceğiz: >>> çevrim = {’a’: 0, ’b’: 1, ’c’: 2, ’ç’: 3, ’d’: 4, ... ’e’: 5, ’f’: 6, ’g’: 7, ’ğ’: 8, ’h’: 9, ... ’ı’: 10, ’i’: 11, ’j’: 12, ’k’: 13, ... ’l’: 14, ’m’: 15, ’n’: 16, ’o’: 17, ... ’ö’: 18, ’p’: 19, ’r’: 20, ’s’: 21, ... ’ş’: 22, ’t’: 23, ’u’: 24, ’ü’: 25, ... ’v’: 26, ’y’: 27, ’z’: 28} Yalnızböyleherharfekarşılıkgelensayıyıelleyazmakyorucuolacaktır.Buişlemidahakolay bir şekilde yapabilmek için farklı teknikleri kullanabilirsiniz. Mesela daha önce öğrendiğimiz sözlüküreteçlerindenyararlanabilirsiniz: >>> çevrim = {i: harfler.index(i) for i in harfler} Buşekildeharflerdeğişkeniiçindekiherbirharfinbiranahtar;buharflerinharflerdeğişkeni içindekisırasınıgösterenherbirsayınınisebirdeğerolduğubirsözlükoluşturmuşolduk. 664 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Şimdiisimlistemizialalımkarşımıza: isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule"] Normalbirsorted()işlemininyanlışsonuçdöndüreceğinibiliyoruz: >>> sorted(isimler) [’ahmet’, ’can’, ’ismail’, ’çiğdem’, ’ışık’, ’şule’] Aynışekildekeyparametresinelocale.strxfrmdeğerininverilmesideyetersizkalacaktır: >>> sorted(isimler, key=locale.strxfrm) [’ahmet’, ’can’, ’çiğdem’, ’ismail’, ’ışık’, ’şule’] Amabirazönceoluşturduğumuzçevrimanahtarınıkullanırsakdurumbambaşkaolacaktır: >>> sorted(isimler, key=lambda x: çevrim.get(x[0])) [’ahmet’, ’can’, ’çiğdem’, ’ışık’, ’ismail’, ’şule’] Ancakaslındaburadadaoldukçasinsibirproblemvar.Bumetotilekelimelistesinioluşturan kelimeleri yalnızca ilk harflerine göre sıralıyoruz (x[0]). Peki ya aynı liste içinde ilk harfleri aynıolup,sonrakiharflerdefarklılaşankelimelervarsaneolacak?Yanimeselabumetotacaba ‘ismail’ve‘iskender’kelimelerinidoğrubirşekildesıralayabilirmi?Bakalım: harfler = "abcçdefgğhıijklmnoöprsştuüvyz" çevrim = {i: harfler.index(i) for i in harfler} isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule", "iskender"] print(sorted(isimler, key=lambda x: çevrim.get(x[0]))) Buradanşuçıktıyıalıyoruz: [’ahmet’, ’can’, ’çiğdem’, ’ışık’, ’ismail’, ’iskender’, ’şule’] Gördüğünüz gibi ‘ismail’ ve ‘iskender’ kelimeleri doğru bir şekilde sıralanmadı; ‘iskender’ kelimesinin‘ismail’kelimesindenöncegelmesigerekiyordu... Demekkişimdiyekadarkullandığımızbütünsıralamayöntemlerininbireksiğivarmış.Ohalde başkabirmetotbulmayaçalışalım. Dikkatlicebakın: harfler = ’abcçdefgğhıijklmnoöprsştuüvyz’ çevrim = {i: harfler.index(i) for i in harfler} (sonrakisayfayadevam) 36.50. sorted() 665 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def sırala(kelime): return ([çevrim.get(kelime[i]) for i in range(len(kelime))]) isimler = [’ahmet’, ’can’, ’iskender’, ’cigdem’, ’ismet’, ’ismail’, ’ismit’, ’çiğdem’, ’ismıt’, ’ışık’, ’şule’] print(*sorted(isimler, key=sırala), sep=’\n’) Gelinbukodlarıbirazinceleyelim. Buradailkgördüğümüzkodlarşunlar: harfler = ’abcçdefgğhıijklmnoöprsştuüvyz’ çevrim = {i: harfler.index(i) for i in harfler} Esasında siz bu kodların anlamını biliyorsunuz. Önceki derslerimizde de aynı kodları birkaç kezkullanmıştık.Yalnızbizburada,örnekolmasıaçısından,harflerdeğişkeniiçindeğerolarak yalnızcaküçükharflerikullandık.Bukodlarıdahakapsamlıbirprogramiçindekullanacaksanız bu değişkenin uygun yerlerine mesela büyük harfleri ve noktalama işaretleriyle sayıları da eklemekisteyebilirsiniz. Sonrakisatırlardasırala()adlıbirfonksiyontanımladık: def sırala(kelime): return ([çevrim.get(kelime[i]) for i in range(len(kelime))]) Buradalisteüreteçlerindenyararlandığımızadikkatiniziçekmekisterim: [çevrim.get(kelime[i]) for i in range(len(kelime))] Bukodyardımıylakelimeiçindegeçenherbirharfiçevrimadlısözlüktesorgulayarak,sözlükte ilgiliharfekarşılıkgelensayıyıbuluyoruz. Aslındabu kodlarıdahaiyianlayabilmek içinPython’dakisorted()fonksiyonununmantığını birazdahaderinlemesineincelememizgerekiyor.Gelinşimdibuincelemeişiniyapalım: Diyelimkielimizdeşöylebirlistevar: elemanlar = [(’ahmet’, 33, ’karataş’), (’mehmet’, 45, ’arpaçbahşiş’), (’sevda’, 24, ’arsuz’), (’arzu’, 40, ’siverek’), (’abdullah’, 30, ’payas’), (’ilknur’, 40, ’kilis’), (’abdurrezzak’, 40, ’bolvadin’)] Bu liste, her biri ‘isim’, ‘yaş’ ve ‘memleket’ bilgilerini içeren üç öğeli birer demetten oluşuyor. Eğerbizbulisteüzerinesorted()fonksiyonunuuygularsak: print(*sorted(elemanlar), sep=’\n’) Pythonelemanlarıdemetlerinilköğesinegöresıralayacaktır.Yaniismegöre. 666 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Pekiyabizbuelemanlarıyaşagöresıralamakistersekneyapacağız? Buamacıgerçekleştirmekiçinşöylebirkodyazabiliriz: def sırala(liste): return liste[1] elemanlar = [(’ahmet’, 33, ’karataş’), (’mehmet’, 45, ’arpaçbahşiş’), (’sevda’, 24, ’arsuz’), (’arzu’, 40, ’siverek’), (’abdullah’, 30, ’payas’), (’ilknur’, 40, ’kilis’), (’abdurrezzak’, 40, ’bolvadin’)] print(*sorted(elemanlar, key=sırala), sep=’\n’) Bu örnek bize key parametresinin de ne işe yaradığını açık seçik gösteriyor. Eğer Python’ın kendi sıralama yönteminin dışında bir sıralama yöntemi uygulayacaksak, bu sıralama yönteminin ne olduğunu bir fonksiyon yardımıyla tarif edip bunu key parametresine değer olarak veriyoruz. Örneğin biz yukarıdaki Python’ın elemanlar adlı listeyi ilk sütuna (‘isim’ sütunu) göre değil, ikinci sütuna (‘yaş’ sütunu) göre sıralamasını istedik. Bunun için de şöyle birfonksiyonyazdık: def sırala(liste): return liste[1] Bu fonksiyon, kendisine parametre olarak verilen nesnenin ikinci öğesini döndürüyor. İşte biz sorted() fonksiyonunun key parametresine bu fonksiyonu verdiğimizde Python sıralamaişlemindeelemanlarlistesininikinciöğesinidikkatealacaktır.EğerPython’ınsıralama işleminde mesela üçüncü sütunu dikkate almasını isterseniz sırala() fonksiyonunu şöyle yazabilirsiniz: def sırala(liste): return liste[2] Gördüğünüz gibi, elemanlar listesinin ikinci sütununda değeri aynı olan öğeler var. Mesela ‘arzu’,‘ilknur’ve‘abdurrezzak’40yaşında.Pythonbuöğelerisıralarken,bunlarınlistedegeçtiği sırayı dikkate alacaktır. Ama bazen biz sıralamanın böyle olmasını istemeyebiliriz. Mesela bizim istediğimiz şey, değeri aynı olan öğeler için üçüncü sütunun (veya birinci sütunun) dikkatealınmasıolabilir.İştebununiçindesırala()fonksiyonunuşuşekildetanımlayabiliriz: def sırala(liste): return (liste[1], liste[2]) Gördüğünüzgibiburadasırala()fonksiyonubizeikiöğelibirdemetdöndürüyor. Kodlarımıztamolarakşöylegörünecek: def sırala(liste): return (liste[1], liste[2]) elemanlar = [(’ahmet’, 33, ’karataş’), (sonrakisayfayadevam) 36.50. sorted() 667 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) (’mehmet’, 45, ’arpaçbahşiş’), (’sevda’, 24, ’arsuz’), (’arzu’, 40, ’siverek’), (’abdullah’, 30, ’payas’), (’ilknur’, 40, ’kilis’), (’abdurrezzak’, 40, ’bolvadin’)] print(*sorted(elemanlar, key=sırala), sep=’\n’) KodlarımızıböyleyazdığımızdaPythonlisteyiilkolarakikincisütundaki‘yaş’değerlerinegöre sıralar.Değeriaynıolanöğelerlekarşılaştığındaiseüçüncüsütundaki‘memleket’değerlerine bakarvesıralamayıonagöreyapar. Bütünbuaçıklamalardansonrayukarıdakişukodlarıdahaiyianlıyorolmalısınız: harfler = ’abcçdefgğhıijklmnoöprsştuüvyz’ çevrim = {i: harfler.index(i) for i in harfler} def sırala(kelime): return ([çevrim.get(kelime[i]) for i in range(len(kelime))]) isimler = [’ahmet’, ’can’, ’iskender’, ’cigdem’, ’ismet’, ’ismail’, ’ismit’, ’çiğdem’, ’ismıt’, ’ışık’, ’şule’] print(*sorted(isimler, key=sırala), sep=’\n’) Bizyinedeherşeyiniyideniyineanlaşıldığındaneminolmakiçindurumukısacaaçıklayalım. Öncelikleilgilifonksiyonuönümüzealalım: def sırala(kelime): return ([çevrim.get(kelime[i]) for i in range(len(kelime))]) Burada yaptığımız şey biraz önce yaptığımız şeyle tamamen aynı aslında. Tek fark, Python’ın sıralamadakullanmasınıistediğimizöğeleritektekelleyazmakyerine,bunlarıbirlisteüreteci yardımıylaotomatikolarakbelirlemek. Eğeryukarıdakikodlarışöyleyazsaydık: def sırala(kelime): return (çevrim.get(kelime[0])) Bu durumda Python sıralamada kelimelerin yalnızca ilk harflerini dikkate alacaktı. İlk harfi aynıolankelimeleriisebuyüzdendüzgünsıralayamayacaktı.ElbettePython’ınönceilkharfe, sonraikinciharfe,sonradaüçüncüharfebakmasınısağlayabiliriz: def sırala(kelime): return (çevrim.get(kelime[0]), çevrim.get(kelime[1]), çevrim.get(kelime[2])) Ancak bu yöntemin uygulanabilir ve pratik olmadığı ortada. Kendi kendinize bazı denemeler yaparakbunukendinizderahatlıklagörebilirsiniz. 668 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 Python’ın, sıralama yaparken kelimelerin önce ilk harflerini, sonra ikinci, sonra üçüncü, vb. harflerinikarşılaştırmasınısağlamanınenuygunyoluşuolacaktır: def sırala(kelime): return ([çevrim.get(kelime[i]) for i in range(len(kelime))]) Gördüğünüz gibi, burada kelimelerdeki harflerin sırasını tek tek elle yazmak yerine, bunu bir for döngüsü içinde otomatik olarak yaptırıyoruz. Dolayısıyla sırala() fonksiyonuna verilen parametrenin mesela ahmet olduğu bir durumda yukarıdaki fonksiyon şu demeti döndürüyor: def sırala(’ahmet’): return (çevrim.get(’ahmet’[0]), çevrim.get(’ahmet’[1]), çevrim.get(’ahmet’[2]), çevrim.get(’ahmet’[3]), çevrim.get(’ahmet’[4])) Mesela‘can’içiniseşunu: def sırala(’can’): return (çevrim.get(’can’[0]), çevrim.get(’can’[1]), çevrim.get(’can’[2])) Böylece Python, hangi uzunlukta bir isimle karşılaşırsa karşılaşsın, sıralama işlemini düzgün birşekildegerçekleştirebiliyor. BubölümdePython’dasıralamakonusunuepeyayrıntılıbirşekildeelealdık. (cid:242) Not ‘Sıralama’ konusuna ilişkin bir tartışma için https://web.archive.org/web/ 20161017211231/www..com/forum/viewtopic.php?f=25&t=1523 adresindeki konuyuinceleyebilirsiniz. 36.51 slice() Bildiğiniz gibi, birtakım öğelerden oluşan bir nesnenin yalnızca belli kısımlarını ayırıp alma işlemine‘dilimleme’adıveriliyor.Örneğinelimizdeşöylebirlisteolduğunudüşünelim: >>> l = [’ahmet’, ’mehmet’, ’ayşe’, ’senem’, ’salih’] 5öğelibulisteninyalnızcailkikiöğesinialmak,yanidilimlemekiçinşuyapıyıkullanıyoruz: >>> l[0:2] [’ahmet’, ’mehmet’] Dilimlemeişlemininşöylebirformüldenoluştuğunubiliyoruz: 36.51. slice() 669 PythonBelgeleri,Yayım4.1.3 l[başlangıç:bitiş:atlama_değeri] Başlangıçparametresininöntanımlıdeğeri0olduğuiçinyukarıdakikoduşöyledeyazabilirdik: >>> l[:2] [’ahmet’, ’mehmet’] Aynı listenin, ilk öğeden itibaren sonuna kadar olan bütün öğelerini almak için ise şunu yazıyoruz: >>> l[1:] Eğerbulisteyi,öğeleriniikişerikişeratlayarakdilimlemekistersekdeşuyolutakipediyoruz: >>> l[::2] [’ahmet’, ’ayşe’, ’salih’] Bu örnekte başlangıç ve bitiş parametrelerinin öntanımlı değerlerini kullandık. O yüzden o kısımlarıboşbıraktık.Öğeleriikişerikişeratlayabilmekiçiniseatlama_değeriolarak2sayısını kullandık. İşte yukarıdakine benzer dilimleme işlemleri için slice() adlı bir gömülü fonksiyondan da yararlanabiliriz.Dikkatlicebakın: Listemizşu: >>> l = [’ahmet’, ’mehmet’, ’ayşe’, ’senem’, ’salih’] Bir‘dilimleme’(slice)nesnesioluşturuyoruz: >>> dl = slice(0, 3) Bunesneyilisteüzerineuyguluyoruz: >>> l[dl] [’ahmet’, ’mehmet’, ’ayşe’] Gördüğünüz gibi, slice() fonksiyonunu yukarıda iki parametre ile kullandık. Tahmin edebileceğinizgibi,bufonksiyonunuformülüşuşekildedir: slice(başlangıç, bitiş, atlama) 670 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 36.52 sum() Bufonksiyonuntemelgörevi,birdiziiçindekideğerlerintoplamınıbulmaktır.Örneğin: >>> l = [1, 2, 3] >>> sum(l) 6 Bufonksiyongenellikleyukarıdakigibitekparametreylekullanılır.Amaaslındabufonksiyon ikincibirparametredahaalır.Dikkatlicebakın: >>> l = [1, 2, 3] >>> sum(l, 10) 16 Gördüğünüzgibi,Pythonsum()fonksiyonunaverilenikinciparametreyi,birinciparametredeki toplamdeğerinüzerineekliyor. 36.53 type() type() fonksiyonunun görevi bir nesnenin hangi veri tipine ait olduğunu söylemektir. Bu fonksiyonuartıkyakındantanıyorsunuz: >>> type(’elma’) <class ’str’> 36.54 zip() Gelinistersenizbufonksiyonubirörneküzerindenaçıklamayaçalışalım. Diyelimkielimizdeşöyleikifarklılistevar: >>> a1 = [’a’, ’b’, ’c’] >>> a2 = [’d’, ’e’, ’f’] Eğer bu listelerin öğelerini birbirleriyle eşleştirmek istersek zip() fonksiyonundan yararlanabiliriz. Dikkatlicebakın: >>> zip(a1, a2) <zip object at 0x00FD0BE8> Gördüğünüz gibi, yukarıdaki kod bize bir ‘zip’ nesnesi veriyor. Bu nesnenin öğelerine nasıl ulaşabileceğinizibiliyorsunuz: 36.52. sum() 671 PythonBelgeleri,Yayım4.1.3 >>> print(*zip(a1, a2)) (’a’, ’d’) (’b’, ’e’) (’c’, ’f’) >>> list(zip(a1, a2)) [(’a’, ’d’), (’b’, ’e’), (’c’, ’f’)] >>> for a, b in zip(a1, a2): ... print(a, b) ... a d b e c f Yukarıdakiçıktılarıincelediğimizde,ilklisteninilköğesinin,ikincilisteninilköğesiyle;ilklistenin ikinci öğesinin, ikinci listenin ikinci öğesiyle; ilk listenin üçüncü öğesinin ise, ikinci listenin üçüncüöğesiyleeşleştiğinigörüyoruz. Buözelliktenpekçokfarklışekildeyararlanabilirsiniz.Örneğin: >>> isimler = [’ahmet’, ’mehmet’, ’zeynep’, ’ilker’] >>> yaşlar = [25, 40, 35, 20] >>> for i, y in zip(isimler, yaşlar): ... print(’isim: {} / yaş: {}’.format(i, y)) ... isim: ahmet / yaş: 25 isim: mehmet / yaş: 40 isim: zeynep / yaş: 35 isim: ilker / yaş: 20 Burada isimler ve yaşlar adlı listelerin öğelerini zip() fonksiyonu yardımıyla birbirleriyle eşleştirdik. 36.55 vars() Bu fonksiyon, mevcut isim alanı içindeki metot, fonksiyon ve nitelikleri listeler. Eğer bu fonksiyonuparametresizolarakkullanırsak,dahaöncegördüğümüzlocals()fonksiyonuyla aynıçıktıyıeldeederiz: >>> vars() {’__builtins__’: <module ’builtins’ (built-in)>, ’__name__’: ’__main__’, ’__package__’: None, ’__loader__’: <class ’_frozen_importlib.BuiltinImporter’>, ’__doc__’: None} Bufonksiyonu,nesnelerinmetotlarınıvenitelikleriniöğrenmekiçindekullanabilirsiniz: 672 Bölüm36. GömülüFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> vars(str) >>> vars(list) >>> vars(dict) Yukarıdasırasıylakarakterdizilerinin,listelerinvesözlüklerinmetotlarınılisteledik.Buyönüyle vars()fonksiyonudir()fonksiyonunabenzer. Böylece Python’daki gömülü fonksiyonları tek tek incelemiş olduk. Bu bölümde incelemediğimizgömülüfonksiyonlarşunlar: 1. memoryview 2. iter 3. next 4. object 5. property 6. staticmethod 7. super 8. getattr 9. hasattr 10. delattr 11. classmethod 12. issubclass 13. setattr 14. __import__ Bufonksiyonları,ilerleyenderslerlebirliktePythonbilgimizbirazdahaarttığındaelealacağız. 36.55. vars() 673 37 BÖLÜM İleri Düzey Fonksiyonlar Buraya gelinceye kadar fonksiyonlara ilişkin epey söz söyledik. Artık Python programlama dilindefonksiyonlaradairhemenherşeyibildiğimizirahatlıklasöyleyebiliriz.Zirabunoktaya kadar hem fonksiyonların temel (ve orta düzey) özelliklerini öğrendik, hem de ‘gömülü fonksiyon’ kavramını ve gömülü fonksiyonların kendisini bütün ayrıntılarıyla inceledik. Dolayısıylayazdığımızkodlardafonksiyonlarıoldukçaverimlibirşekildekullanabilecekkadar fonksiyonbilgisinesahibizartık. Dediğimiz gibi, fonksiyonlara ilişkin en temel bilgileri edindik. Ancak fonksiyonlara dair henüzbilmediğimizşeylerdevar.AmaartıkPythonprogramlamadilindegeldiğimizaşamayı dikkatealarakileriyedoğrubiradımdahaatabilir,fonksiyonlaradairileridüzeysayılabilecek konulardandasözedebiliriz. İlkolarak‘lambdafonksiyonlarını’elealalım. 37.1 Lambda Fonksiyonları Şimdiye kadar Python programlama dilinde fonksiyon tanımlamak için hep def adlı bir ifadeden yararlanmıştık. Bu bölümde ise Python programlama dilinde fonksiyon tanımlamamızı sağlayacak, tıpkı def gibi bir ifadeden daha söz edeceğiz. Fonksiyon tanımlamamızısağlayanbuyeniifadeyelambdadenir.Buifadeileoluşturulanfonksiyonlara ise‘lambdafonksiyonları’... BildiğinizgibiPython’dabirfonksiyonudef ifadesiyardımıylaşöyletanımlıyoruz: >>> def fonk(param1, param2): ... return param1 + param2 Bu fonksiyon, kendisine verilen parametreleri birbiriyle toplayıp bize bunların toplamını döndürüyor: 674 PythonBelgeleri,Yayım4.1.3 >>> fonk(2, 4) 6 Pekiaynıişlemilambdafonksiyonlarıyardımıylayapmakisterseknasılbiryolizleyeceğiz? Dikkatlicebakın: >>> fonk = lambda param1, param2: param1 + param2 İşte burada tanımladığımız şey bir lambda fonksiyonudur. Bu lambda fonksiyonunu da tıpkı birazöncetanımladığımızdeffonksiyonugibikullanabiliriz: >>> fonk(2, 4) 6 Gördüğünüzgibilambdafonksiyonlarınıtanımlamakvekullanmakhiçdezordeğil. Lambda fonksiyonlarının neye benzediğinden temel olarak bahsettiğimize göre artık biraz dahaderineinebiliriz. Lambda fonksiyonları Python programlama dilinin ileri düzey fonksiyonlarından biridir. Yukarıdaki örnek yardımıyla bu lambda fonksiyonlarının nasıl bir şey olduğunu gördük. Esasında biz buraya gelene kadar bu lambda fonksiyonlarını hiç görmemiş de değiliz. Hatırlarsanızdahaöncekiderslerimizdeşöylebirörnekkodyazmıştık: harfler = "abcçdefgğhıijklmnoöprsştuüvyz" çevrim = {i: harfler.index(i) for i in harfler} isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule", "iskender"] print(sorted(isimler, key=lambda x: çevrim.get(x[0]))) Burada sorted() fonksiyonunun key parametresi içinde kullandığımız ifade bir lambda fonksiyonudur: lambda x: çevrim.get(x[0]) Pekilambdafonksiyonlarınedirveneişeyarar? Lambda fonksiyonlarını, bir fonksiyonun işlevselliğine ihtiyaç duyduğumuz, ama konum olarakbirfonksiyontanımlayamayacağımızveyafonksiyontanımlamanınzoryadameşakkatli olduğu durumlarda kullanabiliriz. Yukarıdaki örnek kod, bu tanıma iyi bir örnektir: sorted() fonksiyonunun key parametresi bizden bir fonksiyon tanımı bekler. Ancak biz elbette oraya def ifadesini kullanarak doğrudan bir fonksiyon tanımlayamayız. Ama def yerine lambda ifadesiyardımıylakeyparametresiiçinbirlambdafonksiyonutanımlayabiliriz. Eğeryukarıdakikodları‘normal’birfonksiyonlayazmakisteseydikşukodlarıkullanabilirdik: harfler = "abcçdefgğhıijklmnoöprsştuüvyz" çevrim = {i: harfler.index(i) for i in harfler} (sonrakisayfayadevam) 37.1. LambdaFonksiyonları 675 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) isimler = ["ahmet", "ışık", "ismail", "çiğdem", "can", "şule", "iskender"] def sırala(eleman): return çevrim.get(eleman[0]) print(sorted(isimler, key=sırala)) Buradalambdafonksiyonukullanmakyerine,sırala()adlıbirfonksiyonkullandık. Eğer yukarıda ‘lambda’ ile yazdığımız örneği sırala() fonksiyonu ile yazdığımız örnekle kıyaslarsanız lambda fonksiyonlarında hangi parçanın neye karşılık geldiğini veya ne anlama sahipolduğunurahatlıklaanlayabilirsiniz. Gelinbirörnekdahaverelim: Diyelimkibirsayınınçiftsayıolupolmadığınıdenetleyenbirfonksiyonyazmakistiyorsunuz. Bununiçinşöylebirfonksiyontanımlayabileceğimizibiliyorsunuz: def çift_mi(sayı): return sayı % 2 == 0 Eğer çift_mi() fonksiyonuna parametre olarak verilen bir sayı çift ise fonksiyonumuz True çıktısıverecektir: print(çift_mi(100)) True AksihaldeFalseçıktısıalırız: print(çift_mi(99)) False İşteyukarıdakietkiyilambdafonksiyonlarıyardımıyladaeldeedebiliriz. Dikkatlicebakın: >>> çift_mi = lambda sayı: sayı % 2 == 0 >>> çift_mi(100) True >>> çift_mi(99) False Başkabirörnekdahaverelim.Diyelimkibirlisteiçindekibütünsayılarınkaresinihesaplamak istiyoruz.Elimizdekilisteşu: >>> l = [2, 5, 10, 23, 3, 6] 676 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 Bulistedekisayılarınherbirininkaresinihesaplamakiçinşöylebirşeyyazabiliriz: >>> for i in l: ... print(i**2) 4 25 100 529 9 36 Veyaşöylebirşey: >>> [i**2 for i in l] [4, 25, 100, 529, 9, 36] Yadamap()fonksiyonuylabirliktelambda’yıkullanarakşukoduyazabiliriz: >>> print(*map(lambda sayı: sayı ** 2, l)) 4 25 100 529 9 36 Son örnekte verdiğimiz lambda’lı kodu normal bir fonksiyon tanımlayarak şöyle de yazabilirdik: >>> def karesi(sayı): ... return sayı ** 2 ... >>> print(*map(karesi, l)) 4 25 100 529 9 36 Sözünözü,meselaşukod: lambda x: x + 10 Türkçedeşuanlamagelir: ’x’ adlı bir parametre alan bir lambda fonksiyonu tanımla. Bu fonksiyon, bu ’x parametresine 10 sayısını eklesin. Bizyukarıdakiörneklerdelambdafonksiyonunutekbirparametreiletanımladık.Amaelbette lambdafonksiyonlarınınbirdenfazlaparametredealabileceğinidebiliyorsunuz. Örneğin: >>> birleştir = lambda ifade, birleştirici: birleştirici.join(ifade.split()) Burada lambda fonksiyonumuz toplam iki farklı parametre alıyor: Bunlardan ilki ifade, ikincisiisebirleştirici.Fonksiyonumuzungövdesindeifadeparametresinesplit()metodunu uyguladıktan sonra, elde ettiğimiz parçaları birleştirici parametresinin değerini kullanarak birbirleriylebirleştiriyoruz.Yani: 37.1. LambdaFonksiyonları 677 PythonBelgeleri,Yayım4.1.3 >>> birleştir(’istanbul büyükşehir belediyesi’, ’-’) ’istanbul-büyükşehir-belediyesi’ Eğer aynı işlevi ‘normal’ bir fonksiyon yardımıyla elde etmek isteseydik şöyle bir şey yazabilirdik: >>> def birleştir(ifade, birleştirici): ... return birleştirici.join(ifade.split()) ... >>> birleştir(’istanbul büyükşehir belediyesi’, ’-’) ’istanbul-büyükşehir-belediyesi’ Yukarıdaki örneklerin dışında, lambda fonksiyonları özellikle grafik arayüz çalışmaları yaparkenişinizeyarayabilir.Örneğin: import tkinter import tkinter.ttk as ttk pen = tkinter.Tk() btn = ttk.Button(text=’merhaba’, command=lambda: print(’merhaba’)) btn.pack(padx=20, pady=20) pen.mainloop() (cid:242) Not Bu kodlardan hiçbir şey anlamamış olabilirsiniz. Endişe etmeyin. Burada amacımız size sadece lambda fonksiyonlarının kullanımını göstermek. Bu kodlarda yalnızca lambda fonksiyonuna odaklanmanız şimdilik yeterli olacaktır. Eğer bu kodları çalıştıramadıysanız https://forum..com/adresindesorununuzudilegetirebilirsiniz. Bu kodları çalıştırıp ‘merhaba’ düğmesine bastığınızda komut satırında ‘merhaba’ çıktısı görünecektir. Tkinter’de fonksiyonların command parametresi bizden parametresiz bir fonksiyon girmemizi bekler. Ancak bazen, elde etmek istediğimiz işlevsellik için oraya parametrelibirfonksiyonyazmakdurumundakalabiliriz.İştebunungibidurumlardalambda fonksiyonlarıfaydalıolabilir.Elbetteyukarıdakikodlarışöyledeyazabilirdik: import tkinter import tkinter.ttk as ttk pen = tkinter.Tk() def merhaba(): print(’merhaba’) btn = ttk.Button(text=’merhaba’, command=merhaba) (sonrakisayfayadevam) 678 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) btn.pack(padx=20, pady=20) pen.mainloop() Buradadalambdayerineisimlibirfonksiyontanımlayıp,commandparametresinedoğrudan bufonksiyonuverdik. Bütün bu örneklerden gördüğünüz gibi, lambda fonksiyonları son derece pratik araçlardır. Normal, isimli fonksiyonlarla elde ettiğimiz işlevselliği, lambda fonksiyonları yardımıyla çok daha kısa bir şekilde elde edebiliriz. Ancak lambda fonksiyonları normal fonksiyonlara göre biraz daha okunaksız yapılardır. O yüzden, eğer lambda fonksiyonlarını kullanmaya mecbur değilseniz, bunların yerine normal fonksiyonları veya yerine göre liste üreteçlerini tercih edebilirsiniz. 37.2 Özyinelemeli (Recursive) Fonksiyonlar Bu bölümde, lambda fonksiyonlarının ardından, yine Python’ın ileri düzey konularından biri olan ‘özyinelemeli fonksiyonlar’dan söz edeceğiz. İngilizcede recursive functions olarak adlandırılan özyinelemeli fonksiyonların, Python programlama dilinin anlaması en zor konularındanbiriolduğusöylenir.Amabusöylentisizihiçendişelendirmesin.Zirabizburada bu çapraşık görünen konuyu size olabildiğince basit ve anlaşılır bir şekilde sunmak için elimizdengelenbütünçabayıgöstereceğiz. Ohaldehemenbaşlayalım... Şimdiye kadar Python’da pek çok fonksiyon gördük. Bu fonksiyonlar kimi zaman Python programcılarınca tanımlanıp dile entegre edilmiş ‘gömülü fonksiyonlar’ (builtin functions) olarak, kimi zamansa o anda içinde bulunduğumuz duruma ve ihtiyaçlarımıza göre bizzat kendimizintanımladığı‘elyapımıfonksiyonlar’(customfunctions)olarakçıktıkarşımıza. Şimdiye kadar öğrendiğimiz bütün bu fonksiyonların ortak bir noktası vardı. Bu ortak nokta, şu ana kadar fonksiyonları kullanarak yaptığımız örneklerden de gördüğünüz gibi, bu fonksiyonlaryardımıylabaşkafonksiyonlarıçağırabiliyorolmamız.Örneğin: def selamla(kim): print(’merhaba’, kim) Burada selamla() adlı bir fonksiyon tanımladık. Gördüğünüz gibi bu fonksiyon print() adlı başkabirfonksiyonuçağırıyor.Buradasıradışıbirşeyyok.Dediğimizgibi,şimdiyekadarzaten hepböylefonksiyonlargörmüştük. Python fonksiyonları, yukarıdaki örnekte de gördüğünüz gibi, nasıl başka fonksiyonları çağırabiliyorsa, aynı şekilde, istenirse, kendi kendilerini de çağırabilirler. İşte bu tür fonksiyonlaraPythonprogramlamadilinde‘kendikendileriniyineleyen’,veyadahateknikbir dilleifadeetmekgerekirse‘özyinelemeli’(recursive)fonksiyonlaradıverilir. Çok basit bir örnek verelim. Diyelim ki, kendisine parametre olarak verilen bir karakter dizisi içindeki karakterleri teker teker azaltarak ekrana basan bir fonksiyon yazmak istiyorsunuz. Yani mesela elinizde ‘’ adlı bir karakter dizisi var. Sizin amacınız bu karakter dizisini şu şekildebasanbirfonksiyonyazmak: 37.2. Özyinelemeli(Recursive)Fonksiyonlar 679 PythonBelgeleri,Yayım4.1.3 stihza tihza ihza hza za a Elbette bu işi yapacak bir fonksiyonu, daha önce öğrendiğiniz döngüler ve başka yapılar yardımıyla rahatlıkla yazabilirsiniz. Ama isterseniz aynı işi özyinelemeli fonksiyonlar yardımıyladayapabilirsiniz. Şimdişukodlaradikkatlicebakın: def azalt(s): if len(s) == 0: return s else: print(s) return azalt(s[1:]) print(azalt(’’)) Bukodlarbizeyukarıdabahsettiğimizçıktıyıverecek: stihza tihza ihza hza za a Fonksiyonumuzu yazıp çalıştırdığımıza ve bu fonksiyonun bize nasıl bir çıktı verdiğini gördüğümüzegörefonksiyonuaçıklamayageçebiliriz. Bu fonksiyon ilk bakışta daha önce öğrendiğimiz fonksiyonlardan çok da farklı görünmüyor aslında. Ama eğer fonksiyonun son kısmına bakacak olursanız, bu fonksiyonu daha önce öğrendiğimizfonksiyonlardanayıranşusatırıgörürsünüz: return azalt(s[1:]) Gördüğünüz gibi, burada azalt() fonksiyonu içinde yine azalt() fonksiyonunu çağırıyoruz. Böylece fonksiyonumuz sürekli olarak kendi kendini yineliyor. Yani aynı fonksiyonu tekrar tekraruyguluyor. Pekiamabununasılyapıyor? Nasılbirdurumlakarşıkarşıyaolduğumuzudahaiyianlamakiçinyukarıdakikodlarışuşekilde yazalım: def azalt(s): if len(s) < 1: (sonrakisayfayadevam) 680 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) return s else: print(list(s)) return azalt(s[1:]) Burada fonksiyonun her yinelenişinde, özyinelemeli fonksiyona parametre olarak giden karakter dizisinin nasıl değiştiğini birazcık daha net olarak görebilmek için karakter dizisi içindekikarakterleribirlistehalinegetiripekranabasıyoruz: print(list(s)) Bukodlarıçalıştırdığımızdaşuçıktıyıalacağız: [’i’, ’s’, ’t’, ’i’, ’h’, ’z’, ’a’] [’s’, ’t’, ’i’, ’h’, ’z’, ’a’] [’t’, ’i’, ’h’, ’z’, ’a’] [’i’, ’h’, ’z’, ’a’] [’h’, ’z’, ’a’] [’z’, ’a’] [’a’] Yukarıdaki çıktının ilk satırında gördüğünüz gibi, fonksiyon ilk çağrıldığında listede ‘’ karakter dizisini oluşturan bütün harfler var. Yani fonksiyonumuz ilk çalışmada parametre olarak karakter dizisinin tamamını alıyor. Ancak fonksiyonun her yinelenişinde listedeki harfler birer birer düşüyor. Böylece özyinelemeli fonksiyonumuz parametre olarak karakter dizisininherdefasındabireksiltilmişbiçiminialıyor. Yukarıdaki sözünü ettiğimiz düşmenin yönü karakter dizisinin başından sonuna doğru. Yani her defasında, elde kalan karakter dizisinin ilk harfi düşüyor. Düşme yönünün böyle olması bizimkodlarıyazışşeklimizdenkaynaklanıyor.Eğerbukodlarışöyleyazsaydık: def azalt(s): if len(s) < 1: return s else: print(list(s)) return azalt(s[:-1]) Harflerindüşmeyönüsondanbaşadoğruolacaktı: [’i’, ’s’, ’t’, ’i’, ’h’, ’z’, ’a’] [’i’, ’s’, ’t’, ’i’, ’h’, ’z’] [’i’, ’s’, ’t’, ’i’, ’h’] [’i’, ’s’, ’t’, ’i’] [’i’, ’s’, ’t’] [’i’, ’s’] [’i’] Burada, bir önceki koddaki azalt(s[1:]) satırını azalt(s[:-1]) şeklinde değiştirdiğimize dikkatedin. Fonksiyonun nasıl işlediğini daha iyi anlamak için, ‘’ karakter dizisinin son harfinin her 37.2. Özyinelemeli(Recursive)Fonksiyonlar 681 PythonBelgeleri,Yayım4.1.3 yinelenişesnasındakikonumununnasıldeğiştiğinideizleyebilirsiniz: n = 0 def azalt(s): global n mesaj = ’{} harfinin {}. çalışmadaki konumu: {}’ if len(s) < 1: return s else: n += 1 print(mesaj.format(’a’, n, s.index(’a’))) return azalt(s[1:]) azalt(’’) Bukodlarşuçıktıyıverir: a harfinin 1. çalışmadaki konumu: 6 a harfinin 2. çalışmadaki konumu: 5 a harfinin 3. çalışmadaki konumu: 4 a harfinin 4. çalışmadaki konumu: 3 a harfinin 5. çalışmadaki konumu: 2 a harfinin 6. çalışmadaki konumu: 1 a harfinin 7. çalışmadaki konumu: 0 Gördüğünüz gibi ‘’ kelimesinin en sonunda bulunan ‘a’ harfi her defasında baş tarafa doğruilerliyor. Aynı şekilde, kodları daha iyi anlayabilmek için, fonksiyona parametre olarak verdiğimiz ‘’kelimesininheryinelemedenekadaruzunluğasahipolduğunudatakipedebilirsiniz: def azalt(s): if len(s) < 1: return s else: print(len(s)) return azalt(s[:-1]) Bufonksiyonu‘’karakterdizisineuyguladığımızdabizeşuçıktıyıveriyor: 7 6 5 4 3 2 1 Gördüğünüzgibi,fonksiyonunkendiniheryineleyişindekarakterdizimizküçülüyor. Budurumbizeözyinelemelifonksiyonlarhakkındaçokönemlibirbilgiveriyoresasında: Özyinelemeli fonksiyonlar; büyük bir problemin çözülebilmesi için, o problemin, problemin 682 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 bütününü temsil eden daha küçük bir parçası üzerinde işlem yapabilmemizi sağlayan fonksiyonlardır. Yukarıdaki örnekte de bu ilkeyi uyguluyoruz. Yani biz ‘’ karakter dizisinin öncelikle yalnızcailkkarakterinidüşürüyoruz: s[1:] Dahasonradabuyöntemiözyinelemelibirşekildeuyguladığımızda,‘’karakterdizisinin herdefasındadahaküçükbirparçasıbuyöntemdenetkileniyor: azalt(s[1:]) Yani fonksiyonumuz ilk olarak ‘’ karakter dizisinin ilk harfi olan ‘i’ harfini düşürüyor. Sonra ‘stihza’ kelimesinin ilk harfi olan ‘s’ harfini düşürüyor. Ardından ‘tihza’ kelimesinin ilk harfiolan‘t’harfinidüşürüyorvekelimetükenenekadarbuişlemidevamettiriyor. Pekiamabununasılyapıyor? Şimdiyukarıdakifonksiyondakişukısmadikkatlicebakın: if len(s) < 1: return s İşte burada özyinelemeli fonksiyonumuzun, karakter dizisi üzerinde ne kadar derine inmesi gerektiğini belirliyoruz. Buna göre, karakter dizisinin uzunluğu 1’in altına düştüğünde eldeki karakter dizisini döndürüyoruz. Yani karakter dizisinin uzunluğu 1’in altına düştüğünde elde kalan karakter dizisi boş bir karakter dizisi olduğu için o boş karakter dizisini döndürüyoruz. Eğeristersekelbettebudurumdabaşkabirşeydedöndürebiliriz: def azalt(s): if len(s) < 1: return ’bitti!’ else: print(s) return azalt(s[1:]) İşte if len(s) < 1: bloğunun bulunduğu bu kodlara ‘dip nokta’ adı veriyoruz. Fonksiyonumuzun yinelene yinelene (veya başka bir ifadeyle ‘dibe ine ine’) geleceği en sonnoktaburasıdır.Eğerbudipnoktayıbelirtmezsekfonksiyonumuz,tıpkıdipsizbirkuyuya düşmüş gibi, sürekli daha derine inmeye çalışacak, sonunda da hata verecektir. Ne demek istediğimizidahaiyianlamakiçinkodlarımızışöyleyazalım: def azalt(s): print(s) return azalt(s[1:]) Gördüğünüz gibi burada herhangi bir dip nokta belirtmedik. Bu kodları çalıştırdığımızda Pythonbizeşöylebirhatamesajıverecek: RuntimeError: maximum recursion depth exceeded Yani: 37.2. Özyinelemeli(Recursive)Fonksiyonlar 683 PythonBelgeleri,Yayım4.1.3 ÇalışmaZamanıHatası: Azami özyineleme derinliği aşıldı Dediğimizgibi,özyinelemelifonksiyonlarheryineleniştesorunun(yaniüzerindeişlemyapılan parametrenin)birazdahaderinineiner.Ancakbuderineinmenindebirsınırıvardır.Busınırın neolduğunuşukodlaryardımıylaöğrenebilirsiniz: >>> import sys >>> sys.getrecursionlimit() İştebizözyinelemelifonksiyonlarımızdadipnoktayımutlakabelirterek,Python’ınfonksiyonu yinelerkennekadarderineinipnerededuracağınıbelirlemişoluyoruz. Şimdi son kez, yukarıdaki örnek fonksiyonu, özyineleme mantığını çok daha iyi anlamanızı sağlayacakbirşekildeyenidenyazacağız.Dikkatlicebakın: def azalt(s): if len(s) < 1: return s else: print(’özyineleme sürecine girerken:’, s) azalt(s[1:]) print(’özyineleme sürecinden çıkarken:’, s) azalt(’’) Burada, fonksiyon kendini yinelemeye başlamadan hemen önce bir print() satırı yerleştirereksdeğişkeninindurumunutakipediyoruz: print(’özyineleme sürecine girerken:’, s) Aynıişlemibirdefonksiyonunkendiniyinelemeyebaşlamasınınhemenardındanyapıyoruz: print(’özyineleme sürecinden çıkarken:’, s) Yukarıdakikodlarbizeşuçıktıyıverecek: özyineleme sürecine girerken: özyineleme sürecine girerken: stihza özyineleme sürecine girerken: tihza özyineleme sürecine girerken: ihza özyineleme sürecine girerken: hza özyineleme sürecine girerken: za özyineleme sürecine girerken: a özyineleme sürecinden çıkarken: a özyineleme sürecinden çıkarken: za özyineleme sürecinden çıkarken: hza özyineleme sürecinden çıkarken: ihza özyineleme sürecinden çıkarken: tihza özyineleme sürecinden çıkarken: stihza özyineleme sürecinden çıkarken: Gördüğünüz gibi fonksiyon özyineleme sürecine girerken düşürdüğü her bir karakteri, 684 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 özyinelemesürecindençıkarkenyenidendöndürüyor.Bu,özyinelemelifonksiyonlarınönemli birözelliğidir.Meselabuözelliktenyararlanarakşöylebirkodyazabilirsiniz: def ters_çevir(s): if len(s) < 1: return s else: ters_çevir(s[1:]) print(s[0]) ters_çevir(’’) Yazdığımız bu kodda ters_çevir() fonksiyonu, kendisine verilen parametreyi ters çevirecektir.Yaniyukarıdakikodbizeşuçıktıyıverir: a z h i t s i Burada yaptığımız şey çok basit: Yukarıda da söylediğimiz gibi, özyinelemeli fonksiyonlar, özyineleme sürecine girerken yaptığı işi, özyineleme sürecinden çıkarken tersine çevirir. İşte biz de bu özellikten yararlandık. Fonksiyonun kendini yinelediği noktanın çıkışına bir print() fonksiyonu yerleştirip, geri dönen karakterlerin ilk harfini ekrana bastık. Böylece s adlıparametrenintersinieldeetmişolduk. Ancak eğer yukarıdaki kodları bu şekilde yazarsak, fonksiyondan dönen değeri her yerde kullanamayız.Meselayukarıdakifonksiyonuaşağıdakigibikullanamayız: def ters_çevir(s): if len(s) < 1: return s else: ters_çevir(s[1:]) print(s[0]) kelime = input(’kelime girin: ’) print(’Girdiğiniz kelimenin tersi: {}’.format(ters_çevir(kelime))) Fonksiyonumuzundahakullanışlıolabilmesiiçinkodlarımızışöyleyazabiliriz: def ters_çevir(s): if len(s) < 1: return s else: return ters_çevir(s[1:]) + s[0] kelime = input(’kelime girin: ’) print(’Girdiğiniz kelimenin tersi: {}’.format(ters_çevir(kelime))) 37.2. Özyinelemeli(Recursive)Fonksiyonlar 685 PythonBelgeleri,Yayım4.1.3 Buradabizimamacımızıgerçekleştirmemizisağlayansatırşu: return ters_çevir(s[1:]) + s[0] İlk bakışta bu satırın nasıl çalıştığını anlamak zor gelebilir. Ama aslında son derece basit bir mantığı var bu kodların. Şöyle düşünün: ters_çevir() fonksiyonunu özyinelemeli olarak işlettiğimizde,yanişukoduyazdığımızda: return ters_çevir(s[1:]) ...döndürülecek son değer boş bir karakter dizisidir. İşte biz özyinelemeden çıkılırken geri dönen karakterlerin ilk harflerini bu boş karakter dizisine ekliyoruz ve böylece girdiğimiz karakterdizisinintershalinieldeetmişoluyoruz. Yukarıdakiişlevinaynısını,özyinelemelifonksiyonunuzuşöyleyazarakdaeldeedebilirdiniz: def ters_çevir(s): if not s: return s else: return s[-1] + ters_çevir(s[:-1]) print(ters_çevir(’’)) Buradaaynıişiçinfarklıbiryaklaşımbenimsedik.İlkolarak,dipnoktasınışuşekildebelirledik: if not s: return s Bildiğiniz gibi, boş veri tiplerinin bool değeri False’tur. Dolayısıyla özyineleme sırasında s parametresininuzunluğunun1’inaltınadüşmesi,sparametresininiçininboşaldığınıgösterir. Yani o anda s parametresinin bool değeri False olur. Biz de yukarıda bu durumdan faydalandık. Biröncekikodlaragörebirbaşkafarklılıkdaşusatırda: return s[-1] + ters_çevir(s[:-1]) Burada benimsediğimiz yaklaşımın özü şu: Bildiğiniz gibi bir karakter dizisini ters çevirmek istediğimizde öncelikle bu karakter dizisinin en son karakterini alıp en başa yerleştiririz. Yani mesela elimizdeki karakter dizisi ‘’ ise, bu karakter dizisini ters çevirmenin ilk adımı bununensonkarakteriolan‘a’harfinialıpenbaşakoymaktır.Dahasonradagerikalanharfleri tektekterstenbunaekleriz: düz: ters: a + z + h + i + t + s + i İşteyukarıdakifonksiyondadayaptığımızşeytamanlamıylabudur. Öncekarakterdizisininsonharfinienbaşakoyuyoruz: return s[-1] Ardındandabunagerikalanharfleritektekterstenekliyoruz: 686 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 return s[-1] + ters_çevir(s[:-1]) Özyinelemelifonksiyonlarailişkinolarakyukarıdatekbirörneküzerindeepeyaçıklamayaptık. Bu örnek ve açıklamalar, özyinelemeli fonksiyonların nasıl çalıştığı konusunda size epey fikir vermişolmalı.Ancakelbettebufonksiyonlarıtekbirörnekyardımıylatamamenanlayamamış olabilirsiniz.Oyüzdengelinistersenizbirörnekdahaverelim.Meselabukezdebasitbirsayaç yapalım: def sayaç(sayı, sınır): print(sayı) if sayı == sınır: return ’bitti!’ else: return sayaç(sayı+1, sınır) (cid:242) Not Bufonksiyonunyaptığıişielbettebaşkaşekillerdeçokdahakolaybirşekildehalledebilirdik. Bu örneği burada vermemizin amacı yalnızca özyinelemeli fonksiyonların nasıl işlediğini göstermek.Yoksaböylebirişiözyinelemelifonksiyonlarlayapmanızıbeklemiyoruz. Yukarıdaki fonksiyona dikkatlice bakarsanız aslında yaptığı işi çok basit bir şekilde gerçekleştirdiğinigöreceksiniz. Burada öncelikle sayaç() adlı bir fonksiyon tanımladık. Bu fonksiyon toplam iki farklı parametrealıyor:sayıvesınır. Bunagörefonksiyonumuzuşöylekullanıyoruz: print(sayaç(0, 100)) Burada sayı parametresine verdiğimiz 0 değeri sayacımızın saymaya kaçtan başlayacağını gösteriyor. sınır parametresine verdiğimiz 100 değeri ise kaça kadar sayılacağını gösteriyor. Bunagörebiz0’dan100’ekadarolansayılarısayıyoruz... Gelinşimdibirazfonksiyonumuzuinceleyelim. İlkolarakşusatırıgörüyoruzfonksiyongövdesinde: print(sayı) Bu satır, özyinelemeli fonksiyonun her yinelenişinde sayı parametresinin durumunu ekrana basacak. Sonrakiikisatırdaiseşukodlarıgörüyoruz: if sayı == sınır: return ’bitti!’ Bu bizim ‘dip nokta’ adını verdiğimiz şey. Fonksiyonumuz yalnızca bu noktaya kadar yineleyecek, bu noktanın ilerisine geçmeyecektir. Yani sayı parametresinin değeri sınır parametresinin değerine ulaştığında özyineleme işlemi de sona erecek. Eğer böyle bir dip nokta belirtmezsek fonksiyonumuz sonsuza kadar kendini yinelemeye çalışacak, daha 37.2. Özyinelemeli(Recursive)Fonksiyonlar 687 PythonBelgeleri,Yayım4.1.3 önce sözünü ettiğimiz ‘özyineleme limiti’ nedeniyle de belli bir aşamadan sonra hata verip çökecektir. Sonrakisatırlardaiseşukodlarıgörüyoruz: else: return sayaç(sayı+1, sınır) Bu satırlar, bir önceki aşamada belirttiğimiz dip noktaya ulaşılana kadar fonksiyonumuzun hangi işlemleri yapacağını gösteriyor. Buna göre, fonksiyonun her yinelenişinde sayı parametresinindeğerini1sayıartırıyoruz. Fonksiyonumuzu sayaç(0, 100) gibi bir komutla çalıştırdığımızı düşünürsek, fonksiyonun ilk çalışmasında 0 olan sayı değeri sonraki yinelemede 1, sonraki yinelemede 2, sonraki yinelemedeise3olacakve budurumsınırdeğerolan100’evarılana kadardevamedecektir. sayı parametresinin değeri 100 olduğunda ise dip nokta olarak verdiğimiz ölçüt devreye girecekvefonksiyonunkendikendisiniyinelemesiişleminesonverilecektir. Biz yukarıdaki örnekte yukarıya doğru sayan bir fonksiyon yazdık. Eğer yukarıdan aşağıya doğrusayanbirsayaçyapmakistersenizyukarıdakifonksiyonuşuşeklegetirebilirsiniz: def sayaç(sayı, sınır): print(sayı) if sayı == sınır: return ’bitti!’ else: return sayaç(sayı-1, sınır) print(sayaç(100, 0)) Burada,öncekifonksiyonda+olanişleci-işlecineçevirdik: return sayaç(sayı-1, sınır) Fonksiyonumuzu çağırırken de elbette sayı parametresinin değerini 100 olarak, sınır parametresinindeğeriniise0olarakbelirledik. Buarada,dahaöncedebahsettiğimizgibi,özyinelemelifonksiyonlar,özyinelemeyebaşlarken döndürdükleri değeri, özyineleme işleminin sonunda tek tek geri döndürür. Bu özelliği göz önündebulundurarakyukarıdakifonksiyonuşuşekildedeyazabilirdiniz: def sayaç(sayı, sınır): if sayı == sınır: return ’bitti!’ else: sayaç(sayı+1, sınır) print(sayı) print(sayaç(0, 10)) Dikkat ederseniz burada print(sayı) satırını özyineleme işlevinin çıkışına yerleştirdik. Böylece 0’dan 10’a kadar olan sayıları tersten elde ettik. Ancak tabii ki yukarıdaki anlamlı bir kod yazım tarzı değil. Çünkü fonksiyonumuzun yazım tarzıyla yaptığı iş birbiriyle çok ilgisiz. 688 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 Sayıları yukarı doğru saymak üzere tasarlandığı belli olan bu kodlar, yalnızca bir print() fonksiyonununözyinelemeçıkışınayerleştirilmesisayesindeyaptığıişiyapıyor... Yukarıda verdiğimiz örnekler sayesinde artık özyinelemeli fonksiyonlar hakkında en azından fikirsahibiolduğumuzusöyleyebiliriz.Gelinistersenizşimdiözyinelemelifonksiyonlarlailgili (birazdahamantıklı)birörnekvererekbuçetrefillikonuyuzihnimizdenetleştirmeyeçalışalım. Bu defaki örneğimizde iç içe geçmiş listeleri tek katmanlı bir liste haline getireceğiz. Yani elimizdeşöylebirlisteolduğunuvarsayarsak: l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14] Yazacağımızkodlarbulisteyişuhalegetirecek: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] Buamacıgerçekleştirebilmekiçinşöylebirfonksiyonyazalım: def düz_liste_yap(liste): if not isinstance(liste, list): return [liste] elif not liste: return [] else: return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14] print(düz_liste_yap(l)) Bu fonksiyonu yukarıdaki iç içe geçmiş listeye uyguladığınızda istediğiniz sonucu aldığınızı göreceksiniz. İlk bakışta yukarıdaki kodları anlamak biraz zor gelmiş olabilir. Ama endişe etmenize gerek yok.Zirabizbukodlarıolabildiğinceayrıntılıbirşekildeaçıklayacağız. İlkolarakdipnoktamızıtanımlıyoruzherzamankigibi: if not isinstance(liste, list): return [liste] Fonksiyonumuzuntemelçalışmaprensibinegörelisteiçindekibütünöğeleritektekalıpbaşka birlisteiçindetoplayacağız.Eğerlisteelemanlarıüzerindeilerlerkenkarşımızalisteolmayan birelemançıkarsabuelemanı[liste]koduylabirlisteyedönüştüreceğiz. Öncekiörneklerdenfarklıolarak,bukezkodlarımızdaikifarklıdipnoktasıkontrolügörüyoruz. İlkiniyukarıdaaçıkladık.İkincidipnoktamızşu: elif not liste: return [] Buradayaptığımızşeyşu:Eğerözyinelemeesnasındaboşbirlisteilekarşılaşırsak,tekrarboş birlistedöndürüyoruz.Pekiamaneden? Bildiğinizgibiboşbirlistenin0.elemanıolmaz.Yaniboşbirlisteüzerindeşuişlemiyapamayız: 37.2. Özyinelemeli(Recursive)Fonksiyonlar 689 PythonBelgeleri,Yayım4.1.3 >>> a = [] >>> a[0] Traceback (most recent call last): File "<stdin>", line 1, in <module> IndexError: list index out of range Gördüğünüz gibi, boş bir liste üzerinde indeksleme işlemi yapmaya kalkıştığımızda hata alıyoruz. Şimdi durumu daha iyi anlayabilmek için isterseniz yukarıdaki kodları bir de ikinci dipnoktasıkontrolüolmadanyazmayıdeneyelim: def düz_liste_yap(liste): if not isinstance(liste, list): return [liste] else: return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) l = [1, 2, 3, [4, 5, 6], [7, 8, 9, [10, 11], 12], 13, 14] print(düz_liste_yap(l)) Bukodlarıçalıştırdığımızdaşuhatamesajıylakarşılaşıyoruz: Traceback (most recent call last): File "deneme.py", line 9, in <module> print(düz_liste_yap(l)) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) File "deneme.py", line 5, in düz_liste_yap return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) IndexError: list index out of range Gördüğünüz gibi, biraz önce boş bir liste üzerinde indeksleme yapmaya çalıştığımızda aldığımız hatanın aynısı bu. Çünkü kodlarımızın else bloğuna bakarsanız liste üzerinde indekslemeyaptığımızıgörürsünüz: return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) Elbetteboşbirlisteliste[0]veyaliste[1:]gibisorgulamalaraIndexErrortipindebirhata mesajıylacevapverecektir.İşteböylebirdurumdahataalmamakiçinşukodlarıyazıyoruz: 690 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 elif not liste: return [] Böylece özyineleme esnasında boş bir listeyle karşılaştığımızda bu listeyi şu şekle dönüştürüyoruz: [[]] Böylebiryapıüzerindeindekslemeyapılabilir: >>> a = [[]] >>> a[0] [] Dipnoktayaulaşılanakadaryapılacakişlemleriseşunlar: return düz_liste_yap(liste[0]) + düz_liste_yap(liste[1:]) Yanilisteninilköğesine,gerikalanöğeleritekertekerekliyoruz. Gelinbirörnekdahaverelim: def topla(sayilar): if len(sayilar) < 1: return 0 else: ilk, son = sayilar[0], sayilar[1:] return ilk+topla(son) Bu fonksiyonun görevi, kendisine liste olarak verilen sayıları birbiriyle toplamak. Biz bu işi başka yöntemlerle de yapabileceğimizi biliyoruz, ama bizim burada amacımız özyinelemeli fonksiyonlarıanlamak.Oyüzdensayılarıbirbiriyletoplamaişleminibirdebuşekildeyapmaya çalışacağız. Elimizdeşöylebirlisteolduğunuvarsayalım: liste = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Böylebirdurumdafonksiyonumuz55çıktısıverir. Gelelimbufonksiyonuaçıklamaya... Herzamankigibiilkolarakdipnoktamızıtanımlıyoruz: if len(sayilar) < 1: return 0 Bunagöresayilaradlılisteninuzunluğu1’inaltınadüşünce0değerinidöndürüyoruz.Burada 0 değerini döndürmemizin nedeni, listede öğe kalmadığında programımızın hata vermesini önlemek.Eğer0dışındabaşkabirsayıdöndürürsekbusayıtoplamaişlemininsonucunaetki edecektir. Toplama işleminin sonucunu etkilemeyecek tek sayı 0 olduğu için biz de bu sayıyı döndürüyoruz. Tabannoktayavarılıncayakadaryapılacakişlemleriseşunlar: 37.2. Özyinelemeli(Recursive)Fonksiyonlar 691 PythonBelgeleri,Yayım4.1.3 ilk, son = sayilar[0], sayilar[1:] return ilk+topla(son) Buradaamacımız,listeninilksayısıilelisteningerikalanöğelerinitektekbirbiriyletoplamak. Bunun için sayilar adlı listenin ilk öğesini, listenin geri kalanından ayırıyoruz ve ilk öğeyi ilk; gerikalanöğeleriisesonadlıbirdeğişkenegönderiyoruz: ilk, son = sayilar[0], sayilar[1:] Sonra da ilk öğeyi, geri kalan liste öğeleri ile tek tek topluyoruz. Bunun için de topla() fonksiyonunun kendisini son adlı değişken içinde tutulan liste öğelerine özyinelemeli olarak uyguluyoruz: return ilk+topla(son) Böylecelisteiçindekibütünöğelerintoplamdeğerinieldeetmişoluyoruz. Bu arada, yeri gelmişken Python programlama dilinin pratik bir özelliğinden söz edelim. Gördüğünüzgibisayılarınilköğesinigerikalanöğelerdenayırmakiçinşöylebirkodyazdık: ilk, son = sayilar[0], sayilar[1:] Aslındaaynıişiçokdahapratikbirşekildedehalledebilirdik.Dikkatlicebakın: ilk, *son = sayilar Böylece sayilar değişkenin ilk öğesi ilk değişkeninde, geri kalan öğeleri ise son değişkeninde tutulacaktır.İlerleyenderslerde‘Yürüyücüler’(Iterators)konusunuişlerkenbuyapıdandaha ayrıntılıbirşekildesözedeceğiz. 37.3 İç İçe (Nested) Fonksiyonlar Bubölümdeiçiçefonksiyonlarınneolduklarınıvenasılkullanılabilecekleriniinceleceğiz. 37.3.1 İç İçe Fonksiyonlar Nedir? İsminden anlayabileceğimiz gibi içe içe olan birden fazla fonksiyonumuz olunca bunlara nested,yaniiçiçefonksiyonlardiyoruz.Aşağıdakigibiikifonksiyonumuzolduğunudüşünelim: def fonk1(): def fonk2(): ... Burada fonk1 kapsayıcı (enclosing) veya dış fonksiyonumuz, fonk2 ise içerideki (nested) yani iç fonksiyonumuz oluyor. İç içe fonksiyonlarımızın ilginç özellikleri olduğunu söyleyebiliriz. Ayrıcabufonksiyonlarıiyiceanlamak,ilerideüreteçleri(diğerbiradıileyürüyücüleri)dedaha iyianlamamızısağlayacaktır. İçiçefonksiyonlarıanlamanıneniyiyoluörneküzerindengitmektir.Şimdişöylebirfonksiyon tanımlayalım: 692 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 def yazıcı(): def yaz(mesaj): print(mesaj) return yaz Koduçalıştırıpetkileşimlikabuğukullanalım: >>> y = yazıcı() >>> y("Merhaba") Merhaba >>> type(y) <class ’function’> >>> y <function yazıcı.<locals>.yaz at 0x00000210D9235558> Şimdi bu çıktılarımızı inceleyelim. yazıcı fonksiyonumuz çağrıldığında değer olarak yaz fonksiyonunuçeviriyor.Buyazfonksiyonudayazıcıfonksiyonumuzuniçerisindetanımladığı için bizim iç fonksiyonumuz oluyor. yazıcı ise kapsayıcı fonksiyonumuz. y("Merhaba") komutu çağırıldığında ekrana Merhaba yazılıyor. Çünkü y’ye atanan değer olan yaz fonksiyonunun yaptığı iş buydu. Dikkat ederseniz y’nin türünün de function olduğunu görebilirsiniz.Sonçıktımızdaisealışılmışındışındabir<locals>ifadesigörüyoruz.Şimdibiraz bununüzerinekonuşacağız. Normalde bir fonksiyon yazdığımızda ve bu fonksiyon başka bir fonksiyonun içerisinde olmadığında, programı çalıştırıldığımızda ve kod işleme sırası bu fonksiyona geldiğinde fonksiyonumuz tanımlanmış olur. Yani bu fonksiyonun ne olduğu, ne yapacağı artık Python yorumlayıcısı tarafından bilinmektedir. Ayrıca bu fonksiyondan sadece bir tane vardır. Örneğinfonksiyonumuzşuşekildeise: def fonk(): pass Herfonk()yazdığımızdaaynıfonksiyonçağrılır.Dikkatedin,aynıişlemleryapılırdemiyorum. Aynıfonksiyonçağrılır.Yapacağıişlemburadabizimiçinönemlideğil. Şimdideiçiçefonksiyontanımımızaveşu<locals>kelimesinebakalım.İlkönce: def yazıcı(): def yaz(mesaj): print(mesaj) return yaz Şeklindekapsayıcıfonksiyonumuzutanımlamışoluyoruz.Dikkatedersenizsadecekapsa-yıcı fonksiyonun tanımlandığını söyledim. Artık yazıcı fonksiyonunun, Python yorum- layıcısı tarafından ne yapacağı, nasıl çalışacağı biliniyor. Ancak yaz fonksiyonu için aynı şeyleri söyleyemeyiz. Sonuç olarak bir fonksiyon çağırılmadan içerisindeki komutlar çalışmaz. Eğer def yaz... komutu çalışmaz ise de yaz fonksiyonumuz tanımlanmış olmaz. Yani şu anda yaz fonksiyonumuz tanımlanmamıştır. Peki ne zaman tanımlanacaktır? Tabii ki de yazıcı fonksiyonumuzu çağırdığımız zaman. Çünkü dediğimiz gibi, yazıcı fonksiyonu çağrılmadığı sürece def yaz... bölümü çalışmıyor. Python yorumlayıcısı programımız çalışırken yazıcı fonksiyonununneyapacağınıbilir,dolayısıiledeyazfonksiyonunununnasıltanımlanacağını bilir. Ancak yaz fonksiyonu tanımlanmadan önce ne yapacağını bilemez. Buradan önemli 37.3. İçİçe(Nested)Fonksiyonlar 693 PythonBelgeleri,Yayım4.1.3 yerlere varacağımız için bu kısmın anlaşılması gerekiyor. Şimdi şunu söyleyebiliriz ki yazıcı fonksiyonumuzu her çağırdımızda yaz sınıfı en baştan tanımlanır. Bu da yazıcı fonksiyonumuzu her çağırışımızda yeni tanımlanan yaz fonksiyonunun farklı ve tek olduğu anlamına gelir. Yani kapsayıcı olan yazıcı fonksiyonu sadece bir tane iken döndürdüğü yaz fonksiyonu birden fazla ve farklı oluyor. Yani yazıcı fonksiyonumuzu her çağırdığımızda sadeceoçağırışımızaözelbiryazfonksiyonueldeediyoruz.İştebu<locals>kelimesiburadan geliyor.Yani: >>> y <function yazıcı.<locals>.yaz at 0x00000210D9235558> Bu demek oluyor ki bizim y değişkenimiz, daha önceki bir yazıcı fonksiyonunun çağrısına ait, yani onun içinde tanımlanan bir yaz fonksiyonudur. locals da zaten yerel değişkenler anlamına gelir. Yani buradaki yaz fonksiyonu, daha önce çağırdığımız yazıcı fonksiyonunun içinde tanımlanan yerel bir değişkendir. Tanımlanan her yaz fonksiyonunun farklı olduğunu şuşekildedegörebiliriz: >>> y = yazıcı() >>> b = yazıcı() >>> y <function yazıcı.<locals>.yaz at 0x00000210D9235558> >>> b <function yazıcı.<locals>.yaz at 0x00000210D920E678> >>> id(y) 2271385703768 >>> id(b) 2271385544312 Gördüğünüzgibifarklıyazfonksiyonlarınınhafızadasaklandığıyerlerdefarklıoluyor... Bukonudabirazdahailerlemedenöncebilmemizgerekenbaşkaşeylerdevar.Birazdaonlar hakkındakonuşalım. 37.3.2 ‘nonlocal’ Deyimi nonlocal deyimi yerel olmayan anlamına gelir. Kullanım amacı global deyimi ile benzerdir. Ancak bunu kullanmamız küresel yani global değişkenlere ulaşmamızı değil, yerel olmayan değişkenlere ulaşmamızı sağlar. Ayrıca bu deyimi sadece iç içe fonksiyonlarda kullanabiliriz. Tabiibunuböylesöyleyincebirşeyanlaşılmıyor.Örnekvermeklazım: def kapsayıcı_fonk(): non_local_değişken = 1 def iç_fonk(): non_local_değişken = 2 print(non_local_değişken) return iç_fonk Buradaiçiçebirfonksiyonyapısınasahibiz.Şimdibukodumuzuçalıştırıpetkileşimlikabukta denemeleryapalım: 694 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 >>> dönüş_fonksiyonu = kapsayıcı_fonk() >>> dönüş_fonksiyonu() 2 Gördüğünüz gibi 1 yazılmadı. Yani kapsayıcı fonksiyona ait olan non_local_değişken ile iç fonksiyonumuzaaitolannon_local_değişkenfarklılar.Aynıbuörnekte: a = 1 def fonk(): a = 2 print(a) >>> fonk() 2 küreseladeğişkeniilefonkfonksiyonunaaitadeğişkenininfarklıolmasıgibi.Pekibizburada fonksiyon içinde de küresel a’yı kullanmak istersek nasıl yaparız? Bir şey yapmamıza gerek yok,zatenfonksiyonkendiiçindeadeğişkeninibulamayıncaglobalalanabakacaktır: a = 1 def fonk(): print(a) >>> fonk() 1 Fakat eğer küresel olan a değişkenini değiştirmek istiyorsanız bildiğiniz gibi global deyimini kullanmamızlazım: a = 1 def fonk(): global a a += 1 print(a) >>> fonk() 2 >>> a 2 İşteaynıbunungibi: def kapsayıcı_fonk(): non_local_değişken = 1 (sonrakisayfayadevam) 37.3. İçİçe(Nested)Fonksiyonlar 695 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def iç_fonk(): non_local_değişken = 2 print(non_local_değişken) return iç_fonk Örneğimizdedeiç_fonk’uniçindekapsayıcı_fonk’aaitolannon_local_değişkendeğişkenini değiştirmekistersekbunudanonlocaldeyimiileşöyleyapabiliriz: def kapsayıcı_fonk(): non_local_değişken = 1 def iç_fonk(): nonlocal non_local_değişken non_local_değişken += 1 print(non_local_değişken) return iç_fonk >>> dönüş_fonksiyonu = kapsayıcı_fonk() >>> dönüş_fonksiyonu() 2 Tabiibudeğişkenideğiştirmekgibibiramacımızyoksa,sadecekullanmakisteseydikşöylede yapabilirdikvenonlocaldeyiminegerekkalmazdı: def kapsayıcı_fonk(): non_local_değişken = 1 def iç_fonk(): print(non_local_değişken) return iç_fonk >>> dönüş_fonksiyonu = kapsayıcı_fonk() >>> dönüş_fonksiyonu() 1 Gördüğünüz gibi nonlocal ifadesi iç içe fonksiyonlar ile çalışırken iç fonksiyonda, kapsayıcı fonksiyonunun değişkenlerini değiştirmemizi sağlıyor. Artık bu bilgiyi kullanarak şöyle bir fonksiyonoluşturabiliriz: def yazıcı(mesaj): def yaz(): nonlocal mesaj mesaj += " Dünya" print(mesaj) return yaz (sonrakisayfayadevam) 696 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> y = yazıcı("Merhaba") >>> y() Merhaba Dünya nonlocal deyiminin nasıl kullanıldığını bildiğiniz için örneğimizi anladığınızı düşünüyorum. Burda yaptığımız tek farklı şey nonlocal deyimi ile birlikte kullandığımız nesnenin yazıcı fonksiyonununparametresiolması.Bunuyapmamızdabirsakıncayoktur.Sonuçolarakmesaj parametresi, normalde de yazıcı fonksiyonu içerisinde bir değişken gibi kullanılmaktadır. Ancak şunu da unutmayalım ki aynı global ifadesini kullanırken olduğu gibi nonlocal ifadesinde de eğer daha üst bir alandaki değişkenin üzerinde bir değer atama işleci kullanmayacaksak nonlocal ifadesini kullanmamıza gerek yoktur. Yani değişkeni nonlocal ifadesi olmadan da kullanabiliriz, ancak değerini değiştiremeyiz. Eğer yukarıdaki kodda nonlocalifadesinikullanmazsakhataalırız: def yazıcı(mesaj): def yaz(): mesaj += " Dünya" print(mesaj) return yaz >>> y = yazıcı("Merhaba Dünya") >>> y() Traceback (most recent call last): File "<pyshell#1>", line 1, in <module> y() File "C:\Users\Dinçel\Desktop\.py", line 3, in yaz mesaj += " Dünya" UnboundLocalError: local variable ’mesaj’ referenced before assignment Sonuç olarak kapsayıcı fonksiyona ait değişkenleri, iç fonksiyonumuzda değiştirebilmek için nonlocalifadesineihtiyacımızvardır. Şimdi en başta konuştuğumuz <locals> konusuna geri dönüyoruz. İç fonksiyonun, çağırılan kapsayıcı fonksiyonun yerel değişkenlerinden biri olduğunu ve her seferinde yeniden tanımlandığını,buyüzdendeaynıişiyapsalardaaslındafarklıolanfonksiyonlareldeettiğimizi konuşmuştuk.Ancakherseferindeyenidentanımlanantekşeyiçfonksiyondeğildir.Kapsayıcı fonksiyonuniçindekiherdeğişken,dışfonksiyonunherçağırılışındabaştantanımlanır.Bunu şuörneküzerindenanlamayaçalışalım: def sayıcı(): sayı = 0 def say(): nonlocal sayı sayı += 1 return sayı return say Kodumuzu kısaca incelersek say fonksiyonunda sayı değişkenini nonlocal hale getiriyoruz. Aynızamandasayfonksiyonuherçağırıldığındasayıdeğiş-keninidebirartırıpdeğerolarak döndürüyoruz.Şimdikodumuzuçalıştıralım: 37.3. İçİçe(Nested)Fonksiyonlar 697 PythonBelgeleri,Yayım4.1.3 >>> s = sayıcı() >>> type(s) <class ’function’> >>> s <function sayıcı.<locals>.say at 0x000001FD2213ED38> >>> >>> s() 1 >>> s() 2 >>> s() 3 >>> s() 4 Gördüğünüz gibi ilginç bir şekilde sayıcı fonksiyonu çalışmış ve bitmiştir, ancak içerisinde bulunan sayı değişkeni silinmemiştir ve geri döndürülen say fonksiyonu tarafından kullanılmaya devam etmektedir. Yani biz göremesek de sayı değişkeni hala bir yerlede saklanılıyordur. Peki normalde bir fonksiyonun çalışması bitince yerel değişkenleri silinmez mi?Tabiikisilinir.Ancakburadasayfonksiyonuiçindesayıdeğişkenininonlocalhalegetirmiş oluyoruz. Yani aslında biz sayı değişkenini kullanmaya devam ediyoruz. Eee şimdi Python kalkıpdabizimkullanacağımızbirdeğişkenisilseayıpolur.Odabunuyapmıyorzaten.Ancak sayı değişkeni iç fonksiyon olan say fonksiyonunda hiç kullanılmasaydı silinirdi. Aslında bu örnektekikilitolaylardanbiridesayıdeğişkenininsadecebirdefatanımlanmasıvebutanımın aynı say fonksiyonunda olduğu gibi sayıcı fonksiyonumuzun sadece bir çağırılışına özgü olması.Buradanikisonucavarıyoruz: • sayıcısınıfınıbirdenfazladefaçağırsakbilegeridöndürülenhersayfonksiyonuekrana sayılarıhepsıraylayazdıracaktır.Çünkühersayfonksiyonukendisinitanımlayansayıcı çağırılışınaaitolansayıdeğişkeninikullanmaktadır. • Hersayfonksiyonununkullandığısayıdeğişkenisadecebirdefa0olaraktanımlanmakta vedahasonrasayfonksiyonumuzuherçağırışımızdaartmaktadır. Evetdediğimizgibifarklısayfonksiyonlarıfarklısayıdeğişkenlerinikullanıyor: >>> s = sayıcı() >>> s() 1 >>> s() 2 >>> s() 3 >>> s() 4 >>> >>> s2 = sayıcı() >>> s2() 1 >>> s2() 2 >>> s2() (sonrakisayfayadevam) 698 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 3 >>> s2() 4 Eğer bu örnekleri anlamakta zorluk çektiyseniz bunun çalışma mantığı olarak şunun ile aynı olduğunusöyleyebiliriz: sayı = 0 def say(): global sayı sayı += 1 print(sayı) >>> s = say >>> s() 1 >>> s() 2 >>> s() 3 >>> s() 4 global deyimi ile yaptığımız bu örneğin nonlocal ile yaptığımız örnekten belki de en önemli farkı, nonlocal örneğinde sayı değişkenine doğrudan erişememizdir. Ama sayı değişkenini sayfonksiyonutarafındankullanılmaktadır.Ancakbizimsayıdeğişkeninebizzaterişememiz, gördüğümüzgibi,silindiğianlamınagelmiyor... 37.3.3 İç İçe Fonksiyonların Kullanım Alanları Şu ana kadar iç içe fonksiyonların nasıl tanımlandığını ve nasıl çalıştığını öğrendik. Ancak öğrenme aşamasında olduğumuz için buraya kadar hep basit örnekler verdik. Şimdi bazı işe yararörneklervereceğizvenezamaniçeiçefonksiyonkullanıpnezamannormalfonksiyonlar kullanmamızındahadoğruolacağınıkonuşacağız. Öncelikle şunu söyleyelim ki iç içe fonksiyonların en fazla kullanıldığı yer bezeyicilerdir. Bu daha sonra göreceğimiz bir konu ancak orada iç içe fonksiyonları çok fazla kullanacağız, haberinizolsun. İçiçefonksiyonlarbazıişlemleridahaverimliyapmamızısağlayabileceğigibibazıişlemleride (yanlışveyagereksizyerekullanırsak)yavaşlatırlar.Meselaşufonksiyonabakalım: def işlem_yap(sayı, bölen, *eklenenler): sonuç = sayı / bölen for i in eklenenler: sonuç += i return sonuç 37.3. İçİçe(Nested)Fonksiyonlar 699 PythonBelgeleri,Yayım4.1.3 Bu fonksiyonumuz aldığı sayı parametresini bölen parametresi ile böldükten sonra geriye kalan bütün parametreleri sonuca ekleyip geri döndürüyor. *eklenenler’in ne anlama geldiğinizatendahaönceöğrenmiştik.şimdibufonksiyonukullanalım: >>> işlem_yap(10, 2, 5, 7) 17.0 >>> işlem_yap(8, 4, 1, 3) 6.0 Şimdi diyelim ki biz yazdığımız programda farklı sayı ve bölen parametreleri ile hep aynı eklenenlerparametrelerinikullanacağız.Yanişunungibiişlemleryapacağız: >>> işlem_yap(4, 2, 1, 4, 5) 12.0 >>> işlem_yap(60, 12, 1, 4, 5) 15.0 >>> işlem_yap(48, 4, 1, 4, 5) 22.0 >>> işlem_yap(12, 6, 3, 6, 2) 13.0 >>> işlem_yap(12, 4, 3, 6, 2) 14.0 >>> işlem_yap(105, 15, 3, 6, 2) 18.0 Burada görebileceğimiz gibi aynı eklenenler değerleri çoklukla kullanılıyor. Böyle bir durumda toplama işlemini her seferinde gerçekleştirmemiz gereksiz oluyor. Bu işlemin sadecebirdefayapılmasınışuşekildesağlayabiliriz: def işlem_yapıcı(*eklenenler): ekle = 0 for i in eklenenler: ekle += i def işlem(sayı, bölen): return sayı/bölen + ekle return işlem Bukodumuzdaişlem_yapıcıfonksiyonuhepaynıolacağıiçindeğişmeyecekolaneklenenler parametresinisadecebirdefaalıyorvehepsinitopluyor,dahasonraişlemfonksiyonunugeri döndürüyor. işlem fonksiyonunu çağırdığımızda da sayı ve bölen parametrelerini veriyoruz veişleminsonucubizegeridönüyor.İlkyaptığımızişlemleribirdeböylekullanalım: >>> işlemci = işlem_yapıcı(1, 4, 5) >>> işlemci2 = işlem_yapıcı(3, 6, 2) >>> işlemci(4, 2) 12.0 >>> işlemci(60, 12) 15.0 >>> işlemci(48, 4) (sonrakisayfayadevam) 700 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 22.0 >>> işlemci2(12, 6) 13.0 >>> işlemci2(12, 4) 14.0 >>> işlemci2(105, 15) 18.0 Artık gerekli işlemi yapacak fonksiyonu sadece bir defa oluşturuyoruz ve sürekli onu kullanıyoruz. Bu da aynı parametrelerin sürekli fonksiyona parametre olarak yollanmasını engelliyorvegerekliişlemlerinsadecebirdefayapılmasınısağlıyor.Kendiyazdığınızkodlarda herhangibiramaçilebirfonksiyonoluşturduğunuzdavebufonksiyonudakullanırkenbunun gibi bir durum ile karşılaştırdığımızda artık iç içe fonksiyonları kullanarak kodu nasıl daha verimlihalegetireceğinizhakkındaaklınızdabirfikiroluşmuşturdiyedüşünüyorum. Şimdi de bir fonksiyon oluştururken o fonksiyonun içinde kod tekrarları yaptığımız fark ettiğimizi varsayalım. Böyle bir durumda bu kod tekrarlarını da azaltmak için bir fonksiyon dahayazmamıziyiolacaktır.Yani: def dosyadaki_karakter_sayısı(dosya, karakter): sonuç = 0 if type(dosya) == str: with open(dosya, "r") as f: veri = f.read() for i in veri: if i == karakter: sonuç += 1 else: veri = dosya.read() for i in veri: if i == karakter: sonuç += 1 return sonuç Elimizde bir dosyayı okuyacak ve bu dosyadaki belli bir karakterin sayını döndürecek bir fonksiyon var. Ama bu fonksiyon dosya parametresi olarak hem dosyanın ismini hem de açılmış bir dosyanın kendisini alabiliyor. if type(dosya) == str: kısmı dosya değişkeninin türününstrolupolmadığınıkontrolediyor,eğeröyleysedosyayıaçıyoruzveokuyoruz.Öyle değilsedosyayıdirektokuyoruz.Dikkatedersenizdahasonrayapılanişlemleraynı,yani: for i in veri: if i == karakter: sonuç += 1 kısmı iki defa tekrar ediyor. Hatırlarsanız bir karakter dizisinin içinde herhangi bir karakterin kaçdefageçtiğiniöğrenmekiçincountmetodundanfaydalanabiliriz: >>> "merhaba".count("a") 2 37.3. İçİçe(Nested)Fonksiyonlar 701 PythonBelgeleri,Yayım4.1.3 Amaburadaörneğimizanlaşılsındiyebunukendimizyapıyoruz. Şimdiyukarıdakitekraredenyerişuşekildeayrıbirfonksiyonhalinegetirebiliriz: def karakter_sayısı(karakter_dizisi, karakter): sayaç = 0 for i in karakter_dizisi: if i == karakter: sayaç += 1 return sayaç def dosyadaki_karakter_sayısı(dosya, karakter): if type(dosya) == str: with open(dosya, "r") as f: return karakter_sayısı(f.read(), karakter) else: return karakter_sayısı(dosya.read(), karakter) Artık karakter dizisinin içinde bir karakterin kaç defa geçtiğini bulmak için karakter_sayısı sayısı adlı fonksiyon yararlanıyoruz. Ancak bizim bu fonksiyonu tanımlama sebebimiz dosyadaki_karakter_sayısı fonksiyonunda yaptığımız bir işlemi yerine getirmekdi. Eğer karakter_sayısı fonksiyonunu programımızda sadece dosyadaki_karakter_sayısı fonksiyonu içinde kullanacaksak bu fonksiyonu global alanda tanımlamamıza gerek yokü, dosyadaki_karakter_sayısıfonksiyonununiçindedetanımlayabiliriz: def dosyadaki_karakter_sayısı(dosya, karakter): def karakter_sayısı(karakter_dizisi): sayaç = 0 for i in karakter_dizisi: if i == karakter: sayaç += 1 return sayaç if type(dosya) == str: with open(dosya, "r") as f: return karakter_sayısı(f.read()) else: return karakter_sayısı(dosya.read()) Ayrıcabuşekildekarakter_sayısıfonksiyonununkarakterşeklindebirparametreyeihtiyacı kalmadı, zaten dosyadaki_karakter_sayısı fonksiyonunun içindeki karakter değişkenine erişebiliyor.İçiçefonksiyonlarıbunungibidurumlardadakullanabiliriz. 702 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 37.4 Üreteçler (Generators) Biz üreteçlerle az çok tanışıyoruz. Liste üreteçleri olsun, sözlük üreteçleri olsun bu konu hakkındabirşeyleröğrenmiştik.Ancakbizüreteçlerimizihepşunungibitanımlamıştık: >>> listem = [i for i in range(10)] >>> listem [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Dikkatedersenizburadai for i in range(10)kısmı(nasıllambdafonksiyonlarnormalyolla tanımlananfonksiyonlardanfarklıbirsözdizimikullanıyorsa)normalkodlardanbirazfarklıbir sözdizimikullanıyor.Busözdizimiilekarmaşıkalgoritmalaroluşturmakzordur,çoğunluklada mümkün değildir. Zaten bunun bulunma sebebi karmaşık algoritmalarda kullanılması değil, kısaişlerdeyazımkolaylığısağlamasıdır.Yanibuyazımşekli,bazıfonksiyonlarınlambdaolarak tanımlanması gibi, üreteç tanımlamanın sadece kısa bir yoludur. Peki aslında üreteçler nasıl tanımlanır?Şimdigelinbukonuyuinceleyelim. 37.4.1 Üreteçlere Giriş Üreteçler, fonksiyonlara benzer şekilde tanımlanır. Hatta tek farkının yield adındaki bir ifadeolduğunusöyleyebiliriz.Hatırlarsanıziçiçefonksiyonlarkonusundaüreteçlerkonusuna birkaç defa atıfta bulunmuştuk. Bu yüzden aynı işi yapacak iç içe bir fonksiyon ile bir üreteci karşılaştırarakkonuyabaşlamakistiyorum: def fonksiyon_sayıcı(): sayı = 0 def say(): nonlocal sayı sayı += 1 return sayı return say def üreteç_sayıcı(): sayı = 0 while True: sayı += 1 yield sayı Endişe etmeyin. İleride üreteç_sayıcı’nın nasıl çalıştığını inceleyeceğiz. Şimdilik sadece şurayaodaklanalım: >>> type(fonksiyon_sayıcı) <class ’function’> >>> type(üreteç_sayıcı) <class ’function’> >>> fonk = fonksiyon_sayıcı() >>> üreteç = üreteç_sayıcı() >>> type(fonk) (sonrakisayfayadevam) 37.4. Üreteçler(Generators) 703 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) <class ’function’> >>> type(üreteç) <class ’generator’> >>> fonk() 1 >>> fonk() 2 >>> fonk() 3 >>> fonk() 4 >>> next(üreteç) 1 >>> next(üreteç) 2 >>> next(üreteç) 3 >>> next(üreteç) 4 fonk ve üreteç değişkenlerini kullanarak elde ettiğimiz sonuçların aynı olduğunu görebiliyorsunuz.Şimdibundanfaydalanaraktanımlanmaşekillerinianlamayaçalışalım. fonk fonksiyonunun nasıl çalıştığını zaten iç içe fonksiyonlar konusunda gördük. Şimdi next fonksiyonu ve yield deyimi ile alakalı konuşalım. Öncelikle şunu söylemek gerekir ki next fonksiyonu, gömülü bir fonksiyondur. Ne işe yaradığını anlamak için ise yield deyimini anlamamız gerekiyor. Eğer kodumuzu ve aldığımız çıktıları incelerseniz yield deyiminin, return deyimine bazı yönlerden benzediğini fark edebilirsiniz. Tabii önemli farklılıklar da var. Bir kere fark edeceğiniz gibi yield deyimi hangi değeri döndüreceğimizi belirliyor. Peki bu döndürme işleminin return ile değer döndürmekten ne farkı var? Bir fonksiyonun içinde return deyimine ulaşıldığında fonksiyon sonlanır ve fonksiyona ait yerel değişkenler silinir. yield deyiminde böyle bir şey söz konusu değildir. Aynı iç içe fonksiyonlarda iç fonksiyonunun dış fonksiyondaki değişkeni kullanması gibi üreteçlerin de yerel değişkenleri Python tarafından saklanır. Ancak üreteçlerde belli değişkenler değil, yerel değişkenlerin tamamısaklanır.Şimdiyukarıdakiörnekteşuüçkısmatekrarbakarsak: >>> type(fonksiyon_sayıcı) <class ’function’> >>> type(üreteç_sayıcı) <class ’function’> >>> fonk = fonksiyon_sayıcı() >>> üreteç = üreteç_sayıcı() >>> type(fonk) <class ’function’> >>> type(üreteç) <class ’generator’> 704 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 Şunu görüyoruz ki üreteç_sayıcı aslında bir fonksiyon. Ama alelade bir fonksiyon değil, çağrıldığında generator nesnesi döndüren bir fonksiyon. Yani aynı iç içe fonksiyonlarda önce kapsayıcı fonksiyonu çağırıp dönüş değerini kullandığımız gibi üreteçlerde de önce üreteci tanımladığımız fonksiyonu çağırıp dönüş değerini kullanıyoruz. Çünkü aslında üreteç olan nesne, bu döndürülen değerdir. Ve aynı iç içe fonksiyonlarda olduğu gibi bu durum birbirindenbağımsızancakaynıişiyapandeğişkenleroluşturmamızısağlar.Dikkatederseniz iç içe fonksiyonlar ve üreteçler, çalışma prensibi açısından benzerler. Ancak üreteçler yield ifadesinininkullanımıilebizedahakullanışlıbiralgoritmaşeklivermektedir. Şuanakadarüreteçlerinnasıltanımlandığıvenasılkullanıldığıhakkındapekdebilgivermedik. Yaptığımız şey, iç içe fonksiyonlar ile üreteçlerin, çalışma prensiblerinin ne kadar benzer olduğunadikkatçekmekidi.Şimdinextfonksiyonuveyielddeyimihakkındakonuşarakkendi üreteçlerimizinasıltanımlayacağımızabakalım. 37.4.2 Üreteçlerin Tanımlanması ‘yield’Deyimive‘next’Fonksiyonu next fonksiyonunun gömülü bir fonksiyon olduğunu söylemiştik. yield deyimi da üretecimizdendeğerdöndürmemizisağlıyordu.Pekibuişlemlerhangikurallarçerçevesinde gerçekleşiyor? Basitbirüreteçtanımlayarakyieldmetodunuanlatmayaçalışalım: def üreteç(): yield "Merhaba" yield "Dünya" return deyiminin fonksiyonu sonlandırırken yield deyimi üretecin çalışmasına ara verir ve sağındaki değişkeni geriye döndürür. Herhangi bir değer verilmemiş ise None döndürecektir. Şimdikodumuzuçalıştıralım: >>> g = üreteç() >>> next(g) "Merhaba" >>> next(g) "Dünya" >>> next(g) Traceback (most recent call last): File "<pyshell#5>", line 1, in <module> next(g) StopIteration Çıktımızı incelersek next fonksiyonunun, kendisine verilen üretecin kodunu bir yield deyimine rastlayana kadar çalıştırdığını, yield deyimine rastladığında ise deyimin sağındaki değişkeni döndürdüğünü görebiliriz. Unutmayalım ki bu döndürme işlemini yapan next fonksiyonudur. Üretecimizin içinde herhangi bir yönerge kalmadığında ise next fonksiyonumuzStopIterationhatasıyükseltmektedir. (cid:242) Not 37.4. Üreteçler(Generators) 705 PythonBelgeleri,Yayım4.1.3 ‘next’ fonksiyonunun burada yaptığı iş için ‘yineleme (iteration)’ terimi kullanılır. ‘next’ fonksiyonunaparametreolarakverilebilennesnelerisebirer‘yinelenebilirnesne(iterable object)’dir.‘generator’sınıfıyinelenebilirnesnelerebirörnektir. Birörnekdahayapalım: def üreteç(): print("üreteç ilk defa next fonksiyonu ile kullanıldı.") yield "1. yield" print("üreteç ikinci defa next fonksiyonu ile kullanıldı.") yield "2. yield" print("üreteç üçüncü defa next fonksiyonu ile kullanıldı ve bitti.") >>> g = üreteç() >>> ilk_dönüş = next(g) üreteç ilk defa next fonksiyonu ile kullanıldı. >>> ikinci_dönüş = next(g) üreteç ikinci defa next fonksiyonu ile kullanıldı. >>> son_dönüş = next(g) üreteç üçüncü defa next fonksiyonu ile kullanıldı ve bitti. Traceback (most recent call last): File "<pyshell#5>", line 1, in <module> next(g) StopIteration >>> >>> ilk_dönüş ’1. yield’ >>> ikinci_dönüş ’2. yield’ >>> son_dönüş Traceback (most recent call last): File "<pyshell#0>", line 1, in <module> son_dönüş NameError: name ’son_dönüş’ is not defined Örneğimizgayetaçık.nextfonksiyonukendisineverilenüretecinkodunuensolkaldığıyerden çalıştırmayadevamediyor,biryieldifadesinedenkgeldiğindedeüretecinçalışmasıduruyor ve next fonksiyonu yield deyiminin sağındaki değeri geri döndürüyor. Tabii son_dönüş’ün None olmak yerine tanımlanmamış olması da ilginç gelmiş olabilir. Bunu da şu örnekle açıklayabiliriz: >>> def hata(): raise Exception >>> dönüş = hata() Traceback (most recent call last): File "<pyshell#8>", line 1, in <module> dönüş = hata() File "<pyshell#7>", line 2, in hata raise Exception (sonrakisayfayadevam) 706 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Exception >>> dönüş Traceback (most recent call last): File "<pyshell#9>", line 1, in <module> dönüş NameError: name ’dönüş’ is not defined Gördüğümüz gibi son_dönüş değişkenimizin tanımlanmamış olmasının sebebi de next fonksiyonunundeğerdöndürmekyerinehatayükseltmişolmasıdır. Buraya kadar yaptığımız örnekleri iç içe fonksiyonlar ile de kolayca yapabilirdik. Üreteçlerin önemli bir özelliği de tanımlanırken , fonksiyonlar gibi, her türlü ifade ile kullanılabilmesidir. Örnek olarak while döngüsü kullanarak, 1’den başlayarak her yinelediğimizde fibonacci sayı dizisininbirsonrakielemanınıdöndürecekbirüreteçyazalım: def fibonacci(): x = 1 y = 0 z = 0 while True: z = y y = x x = y + z yield x (cid:242) Not Fibonacci dizisi, 0 ve 1 ile başlayan ve her sayının kendisinden önce gelen iki sayının toplanması ile elde edildiği bir sayı dizisidir. İtalyan matematikçi Leonardo Fibonacci’den adını alır. 0, 1, 1 (0+1), 2 (1+1), 3 (1+2), 5 (2+3), 8 (3+5), 13 (5+8), 21 (8+13), 34 (13+21) şeklindedevameder. Şimdibukoduçalıştıralım: >>> f = fibonacci() >>> next(f) 1 >>> next(f) 2 >>> next(f) 3 >>> next(f) 5 >>> next(f) 8 >>> next(f) 13 Gördüğünüz gibi üretecimiz bize (ilk 0 ve 1 sonrasındaki) fibonacci sayılarını vermektedir. Kodumuzuanlamayaçalışırsak: 37.4. Üreteçler(Generators) 707 PythonBelgeleri,Yayım4.1.3 • İlk yinelemede, yani next fonksiyonunu ilk kullanışımızda, x, y ve z değişkenleri tanımlanıyor. Daha sonra while döngüsüne giriliyor. Değişkenlerin değerleri değiştirildikten sonra yield x deyimine geldiğimiz için next fonksiyonu x değerini döndürürereküretecemizinçalışmasınıdurduruyor. • İkinciyinelememizdenormalbirkoddaolacağıgibiwhiledöngümüzünbaşınagidiliyor. Aynı işlemler tekrarlanıyor. Tekrar yield deyimine geliniyor. x değeri döndürürülüyor. Üretecimizinçalışmasıdurduruluyorveaynışeylertekraretmeyedevamediyor. Üreteçlerin çok güzel özelliklerinden biri de for döngüsü ile kullanılabilmeleridir. Örneğin fibonacciüretecimiziçinbunuuygulayalım: >>> for i in fibonacci(): print(i) 1 2 3 5 8 13 21 34 55 89 144 ... (cid:242) Not for i in fibonacci() ifadesinde fibonacci fonksiyonunu çağırdığımıza dikkat edin. Sonuçtaüretecimizinkendisifibonaccifonksiyonudeğil,onundöndüreceğideğer. Ancak bu örnekte üretecimiz hiç durmuyor. Bazen üreteçlerimizin durmasını isteyebiliriz. Bunu yapmamız için tek gereken şey üretecimizin durmasını istediğimiz yerde üretecimizi returnetmemizdir.Sonuçtaüreteçlerdebirtürfonksiyondurvereturndeyimifonksiyonları sonlandırır (bu return deyiminden dönen değer üreteçlerde bize ulaşmaz). Bu durum next fonksiyonunun StopIteration yükseltmesine neden olur. for döngüsü bu hatayı yakalar ve üretecimizinbittiğinianlar: def fibonacci(): x = 1 y = 0 z = 0 while True: z = y y = x x = y + z yield x if x > 100: return (sonrakisayfayadevam) 708 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> for i in fibonacci(): print(i) 1 2 3 5 8 13 21 34 55 89 144 >>> Gördüğünüz gibi üretecimiz 100’den büyük bir tane daha değer yazıp durdu. Tabii burada fazladanbirifkullanmakyerinebuşartıwhile’dansonradayazabilirdik: def fibonacci(): x = 1 y = 0 z = 0 while not x > 100: z = y y = x x = y + z yield x Burada da x değişkeni 100’den büyük olduğunda döngümüz bitiyor ve başka kodumuz kalmadığımız için fonksiyon sonlanıyor. Zaten bir fonksiyonun sonuna ulaşıldığında da biz birdeğerdöndürmediysekdeNonedeğeridöndürülecektir. Son olarak parametre alan basit bir üreteç örneği yaparak bir sonraki konuya geçelim. Unutmayalım ki üreteçler de bir çeşit fonksiyon olduğu için fonksiyon tanımlarken yapabildiğimiz her şeyi üreteç tanımlarken de kullanabiliriz. Buna parametre vermek ve iç içefonksiyonlaroluşturmakdadahildir. Üretecimizbirsayıparametresialacakveosayıdefaekranayazıyazdıracak: def yaz(sayı): for i in range(sayı): print("Merhaba Dünya!") yield y = yaz(4) for i in y: print(i) Kodunçıktısı: 37.4. Üreteçler(Generators) 709 PythonBelgeleri,Yayım4.1.3 Merhaba Dünya! Merhaba Dünya! Merhaba Dünya! Merhaba Dünya! ‘yieldfrom’Deyimi yield from deyimi bir üretecin içinde, başka bir üretecin yield ile döndüreceği değerleri tekraryieldetmekistediğimizdekullanılabilir.Şöylebirörnekverelim: def üreteç1(): yield "üreteç1 başladı" yield "üreteç1 bitti" def üreteç2(): yield "üreteç2 başladı" yield from üreteç1() yield "üreteç2 bitti" >>> for i in üreteç2(): print(i) üreteç2 başladı üreteç1 başladı üreteç1 bitti üreteç2 bitti >>> Aslındayield fromileyazdığımızbuörnekşukodileeşdeğerdir: def üreteç1(): yield "üreteç1 başladı" yield "üreteç1 bitti" def üreteç2(): yield "üreteç2 başladı" for i in üreteç1(): yield i yield "üreteç2 bitti" >>> for i in üreteç2(): print(i) üreteç2 başladı üreteç1 başladı üreteç1 bitti üreteç2 bitti >>> Yani: 710 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 yield from bir_üreteç ifadesibuifadeeşdeğerdir: for i in bir_üreteç: yield i 37.4.3 Liste ve Sözlük Üreteçleri Hakkında Üreteçlerkonusununbaşındasöylediğimizşubilgiyitekrarlayarakkonumuzabaşlayalım: Biz üreteçlerle az çok tanışıyoruz. Liste üreteçleri olsun, sözlük üreteçleri olsun bu konu hakkında bir şeyler öğrenmiştik. Ancak biz üreteçlerimizi hep şunun gibi tanımlamıştık: >>> listem = [i for i in range(10)] >>> listem [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Dikkat ederseniz burada i for i in range(10) kısmı (nasıl lambda fonksiyonlar normalyollatanımlananfonksiyonlardanfarklıbirsözdizimikullanıyorsa)normal kodlardan biraz farklı bir söz dizimi kullanıyor. Bu söz dizimi ile karmaşık algoritmalar oluşturmak zordur, çoğunlukla da mümkün değildir. Zaten bunun bulunma sebebi karmaşık algoritmalarda kullanılması değil, kısa işlerde yazım kolaylığı sağlamasıdır. Yani bu yazım şekli, bazı fonksiyonların lambda olarak tanımlanması gibi, üreteç tanımlamanın sadece kısa bir yoludur. Peki aslında üreteçlernasıltanımlanır?Şimdigelinbukonuyuinceleyelim. Bizöncedenüreteçlerişuşekildekullanmayıbiliyorduk: >>> listem = [i for i in range(10)] >>> listem [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Pekiüreteçbukodunneresinde?Aslındabuyazımoldukçakısaltılmış,yanikolaylaştırılmışbir yazımşeklidir.Birazaçacakolursakşunueldeederiz: >>> üreteç = (i for i in range(10)) >>> type(üreteç) <class ’generator’> >>> listem = list(üreteç) >>> listem [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Şimdiliklistekısmınıbirkenarakoyaraküreteçkısmıileilgilenelim. Gördüğünüzgibiaslındaşuyazımşekli: >>> üreteç = (i for i in range(10)) Bununiçinbirkısaltmadır: 37.4. Üreteçler(Generators) 711 PythonBelgeleri,Yayım4.1.3 def üreteç_fonksiyonu(): for i in range(10): yield i üreteç = üreteç_fonksiyonu() Aynılambdafonksiyonlarınnormalfonksiyonlariçinbirkısaltmaolmasıgibi. Ancakşurayadikkatetmeklazımki: üreteç = (i for i in range(10)) Yazdığımızda, elimizde çağırıldığında bize üreteç döndürecek bir fonksiyonumuz yok. Yani üreteç değişkenimiz generator türünde bir nesne ve tek kullanımlık. Sonuçta üreteçlerin yinelenmesibirdefabittiktensonrabirdahakullanamayız,çünkübirdefabittiktensonrahep StopIterationhatasıyükseltirler.Eğeristersekyenisinioluşturabiliriz.üreteçdeğişkenimizin yinelenmesi bir defa tamamlandıktan sonra daha fazla onu kullanamayacağımızı şu şekilde görebiliriz: >>> üreteç = (i for i in range(5)) >>> for i in üreteç: print(i) 0 1 2 3 4 >>> for i in üreteç: print(i) >>> Gördüğünüz gibi üreteç değişkenimizi bir defa for döngüsü ile kullandığımızda ikinci defa kullanamamaktayız. Çünkü ilk döngüde üretecimiz bitene kadar çalıştı ve en sonunda StopIteration yükseltti. Artık istediğimiz kadar üretecimizi kullanmayı deneyelim, StopIteration yükseltmeye devam edecektir (unutmayalım ki for döngüsü StopIteration hatalarınıyakalarveyakaladığındadaçalışmayıbırakır) >>> üreteç = (i for i in range(3)) >>> next(üreteç) 0 >>> next(üreteç) 1 >>> next(üreteç) 2 >>> next(üreteç) StopIteration >>> next(üreteç) StopIteration Aynışeynormalyoldantanımlananüreteçleriçindegeçerlidir: 712 Bölüm37. İleriDüzeyFonksiyonlar PythonBelgeleri,Yayım4.1.3 def üreteç_fonksiyonu(): for i in range(3): yield i >>> üreteç = üreteç_fonksiyonu() >>> next(üreteç) 0 >>> next(üreteç) 1 >>> next(üreteç) 2 >>> next(üreteç) StopIteration >>> next(üreteç) StopIteration Buradaki fark üretecimizi bize veren fonksiyonumuz durduğu için yeni bir üreteç oluşturabiliyorolmamızdır: >>> üreteç2 = üreteç_fonksiyonu() >>> next(üreteç2) 0 Ancakşuşekildebirtanımlamayaptığımızda: >>> üreteç = (i for i in range(3)) >>> type(üreteç) <class ’generator’> Buradaeldeettiğimizüretecinkendisioluyor,vebuüreteçdetekkullanımlık.Şimdibunların listeüreteçleriilealakasınageridönecekolursak: >>> üreteç = üreteç_fonksiyonu() >>> listem = list(üreteç) >>> listem [0, 1, 2] Gördüğünüzgibiaslındanormalyoldantanımlanmışüreteçler,yaniyieldifadesikullanılarak fonksiyon gibi tanımlanmış üreteçler, de list fonksiyonuna argüman olarak verilebilir. Aynı for döngüsünde kullanılabilmesi gibi. Çünkü -kendi geliştirme arayüzünüzü kullanarak görebilirsiniz- dikkat edersiniz list fonksiyonunun ilk parametresinin adı iterable’dır. Türkçe’yeçevirirsekyinelenebilir.Bizzatenüreteçlerinyinelenebilirnesnelereörnekolduğunu söylemiştik.Buyüzdenbütünüreteçlerilistfonksiyonunukullanarakbirlisteyeçevirebiliriz. Bunaşuşekildetanımlananüreteçlerdedahildir: >>> üreteç = (i for i in range(3)) Buyüzdenşukodgüzelbirşekildeçalışmaktadır: 37.4. Üreteçler(Generators) 713 PythonBelgeleri,Yayım4.1.3 >>> üreteç = (i for i in range(3)) >>> list(üreteç) [0, 1, 2] Veşuyazımdayukarıdayazdığımızındahadakısaltılmışhalindenbaşkabirşeydeğildir: >>> listem = [i for i in range(3)] Anlattıklarımız sözlük üreteçleri için de geçerlidir. Dikkat edersiniz kısa yoldan üreteç tanımlamaları(i for i in range(3))şeklinde,listetanımlamaları[i for i in range(3)] şeklindevesözlüktanımlamalarıda{str(i):i for i in range(3)}şeklindeyapılmaktadır. Bulistetanımlamasını: >>> üreteç = (i for i in range(3)) >>> listem = list(üreteç) Şuşekildeyazabileceğimizgibi: >>> üreteç = (i for i in range(3)) >>> listem = [] >>> for i in üreteç: listem.append(i) Busözlüktanımlamasınıda: >>> üreteç = ((str(i),i) for i in range(3)) >>> sözlük = dict(üreteç) Şuşekildeyazabilirdik: >>> üreteç = ((str(i),i) for i in range(3)) >>> sözlük = {} >>> for key,value in üreteç: sözlük[key] = value Son örneğimizde üretecimiz her yinelenişinde iki elemanlı bir tuple döndürüyor ve bu demetinilkelemanıfordöngüsüiçindekeydeğişkenine,ikincielemanıisevaluedeğişkenine atanıyor.Şunungibidedüşünebilirsiniz: >>> for key,value in ((’0’,0), (’1’,1), (’2’,2)): sözlük[key] = value Evet, artık üreteçler konusunda da kayda değer bilgiler öğrendiğimize göre bir sonraki konumuzageçelim. 714 Bölüm37. İleriDüzeyFonksiyonlar 38 BÖLÜM Modüller Bubölümde,geçendersteayrıntılıolarakincelediğimiz‘Fonksiyonlar’kadarönemlibirkonuyu elealacağız.Buönemlikonununadı‘modüller’. Biz şimdiye kadar modül konusunu hiç ayrıntılı olarak ele almamış olsak da esasında siz modülkavramınabüsbütünyabancısayılmazsınız.Zirabizöncekiderslerimizdezamanzaman modüllerden söz etmiş, hatta yeri geldiğinde bunları kodlarımız içinde kullanmaktan da çekinmemiştik. Bukonuyagelenekadar,çeşitlibölümlerdeşumodüllerdenbahsettiğimizihatırlıyorsunuzdur: • sys • os • keyword • random • unicodedata • locale İşte şimdi, daha önce farklı bölümlerde şöyle bir temas edip geçtiğimiz modüller konusunu bubölümdederinlemesineincelemeyeçalışacağız. 38.1 Modül Nedir? Dediğimiz gibi, bu bölümde Python’daki en önemli konulardan biri olan modüllerden söz edeceğiz. Ancak modülleri kullanabilmek için elbette öncelikle ‘modül’ denen şeyin ne olduğunuiyicebiranlamamızgerekiyor.Peki,nedirbumodüldenenşey? Busoruyu,şimdiyekadargördüğümüzmodüllerebakarakcevaplayacakolursak,modüllerin, bazıişlevlerikolaylıklayerinegetirmemizisağlayanbirtakımfonksiyonlarıvenitelikleriiçinde barındıranaraçlarolduğunusöyleyebiliriz. 715 PythonBelgeleri,Yayım4.1.3 Mesela‘KümelerveDondurulmuşKümeler’adlıbölümderandomadlıbirmodüledeğindiğimizi hatırlıyorolmalısınız.Oradabumodülleilgilişöylebirörnekvermiştik: liste = [random.randint(0, 10000) for i in range(1000)] Buörnekte,randomadlımodülüniçindekirandint()adlıfaydalıbirfonksiyondanyararlanarak 0ile10.000sayılarıarasında1000adetrastgelesayıiçerenbirlisteoluşturmuştuk.Dolayısıyla, yukarıdaki tanımda da belirttiğimiz gibi, bir modül olan random, örnekte bahsettiğimiz işlevi kolaylıkla yerine getirmemizi sağlayan bir fonksiyon barındırıyor. Biz de bu fonksiyonu kullanarakamacımızırahatlıklayerinegetirebiliyoruz. random modülünün dışında, önceki derslerimizde şöyle bir değinip geçtiğimiz, sys, os ve locale gibi modüllerin de çeşitli görevleri kolayca yerine getirmemizi sağlayan birtakım araçlarbarındırdığınıgörmüştük. İşin doğrusu, modül denen şey Python programlama dilinin bel kemiğidir. Eğer modüller olmasaydı, Python programlama dili hem çok kullanışsız bir dil olurdu, hem de modüller sayesindeçokkolaybirşekildeüstesindengelebildiğimizzorluklariçinherdefasındakendimiz yenidenbirçözümicatetmekzorundakalırdık. Belki bu iddialı laf size şu anda pek anlamlı gelmemiş olabilir. Şu ana kadar modüllerle ilgili öğrendikleriniz, henüz zihninizde bu lafın iddiasını teyit etmiyor olabilir. Ama modüllerin neden bu kadar önemli olduğunu birazdan çok daha net bir şekilde anlayacaksınız. Şimdilik okumayadevamedin. HatırlarsanızbiröncekibölümdePython’dakifonksiyonlardanbahsetmiştik.Yinehatırlarsanız obölümdepekçokörnekfonksiyondatanımlamıştık.Meselakayıt_oluştur()adlışöylebir fonksiyontanımladığımızıhatırlıyorolmalısınız: def kayıt_oluştur(isim, soyisim, işsis, şehir): print("-"*30) print("isim : ", isim) print("soyisim : ", soyisim) print("işletim sistemi: ", işsis) print("şehir : ", şehir) print("-"*30) Bu fonksiyonu bir kez tanımladıktan sonra, bu fonksiyonu aynı program içinde istediğimiz kadarkullanabiliyoruz.Yanikayıt_oluşturadlıbirfonksiyontanımlamışolmamızsayesinde, bu fonksiyonun gövdesinde belirttiğimiz işlemleri her defasında tekrar tekrar yapmak zorunda kalmıyoruz; bütün bu işlemleri tek bir ‘kayıt_oluştur’ ismine atamış olduğumuz için, bu fonksiyonun bize sunduğu işleve ihtiyaç duyduğumuz her yerde bu fonksiyonu kullanabiliyoruz.Örneğin: kayıt_oluştur(’Fırat’, ’Özgül’, ’Debian’, ’Arsuz’) Yada: kayıt_oluştur(’Zerrin’, ’Söz’, ’Ubuntu’, ’Bolvadin’) Eğer yukarıdaki işlevselliği bir fonksiyon olarak tanımlamış olmasaydık, kayıt_oluştur(’Fırat’, ’Özgül’, ’Debian’, ’Arsuz’) kodunun verdiği çıktıyı elde 716 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 etmekiçinşukodlarıyazmakzorundakalacaktık: print("-"*30) print("isim : ", "Fırat") print("soyisim : ", "Özgül") print("işletim sistemi: ", "Debian") print("şehir : ", "Arsuz") print("-"*30) Buradaisim,soyisim,işletimsistemiveşehirbilgilerideğiştiğindedeherdefasındaaynışeyleri uzunuzadıyatekrartekraryazmamızgerekecekti: print("-"*30) print("isim : ", "Zerrin") print("soyisim : ", "Söz") print("işletim sistemi: ", "Ubuntu") print("şehir : ", "Bolvadin") print("-"*30) İştemodüllerdebunabenzerbirvazifegörür.YaniPython’ınfonksiyonsisteminasılbizebir işlevselliği aynı dosya içinde tekrar tekrar kullanma imkanı veriyorsa, modül sistemi de bir fonksiyonufarklıdosyalarveprogramlariçindetekrartekrarkullanmaimkanıverir. Dolayısıyla, eğer modül sistemi olmasaydı, biz bir kez yazdığımız (veya başka bir Python programcısı tarafından yazılmış) kayıt_oluştur() fonksiyonunu başka bir programda da kullanmak istediğimizde, bu fonksiyonu alıp her defasında yeni programa elle kopyalamak zorunda kalırdık. Ama modül sistemi sayesinde, bir program içinde bulunan fonksiyonları (ve diğer nitelikleri) başka Python programları içine ‘aktarabiliyoruz’. Böylece bir Python programındaki (veya modülündeki) işlevsellikten, başka bir Python programında da yararlanabiliyoruz. Dolayısıyla modüller sayesinde, bir kez yazdığımız kodları pek çok farklı programiçindekullanmaimkanıeldeediyoruz.Budabizim; • Dahaazkodyazmamızı, • Birkezyazdığımızkodlarıtekrartekrarkullanabilmemizi, • Dahadüzenli,dahaderlitoplubirşekildeçalışabilmemizi sağlıyor. İşte bu bölümde, modüllerin bütün bu işlevleri nasıl yerine getirdiğini, modül denen şeyden nasıl faydalanabileceğimizi ve modüllerin neden bu kadar önemli olduğunu öğreneceğiz. Dilersenizlafıdahafazladolandırmadanmodüllerkonusunahızlıbirgirişyapalım. 38.1. ModülNedir? 717 PythonBelgeleri,Yayım4.1.3 38.2 Hazır Modüller Hatırlarsanız,Python’daikifarklıfonksiyontürüolduğundansözetmiştik: 1. Kenditanımladığımızfonksiyonlar 2. Gömülü(‘built-in’)fonksiyonlar Aynışekildemodüllerdeikifarklıbaşlıkaltındaincelenebilir: 1. Kenditanımladığımızmodüller 2. Hazırmodüller Bizburadaönceliklehazırmodüllerielealacağız.Buşekildemodülkavramınıiyiceanladıktan sonradakendimodüllerimizinasılyazacağımızıöğreneceğiz. Hazırmodüller,PythongeliştiricilerininveyabizimdışımızdakiPythonprogramcılarınınyazıp hizmetimizesunduğumodüllerdir. Hazırmodüllerdekendiiçindeikiyeayrılabilir: 1. StandartKütüphaneModülleri 2. ÜçüncüŞahısModülleri Standart Kütüphane Modülleri, doğrudan Python geliştiricileri tarafından yazılıp dile kaynaştırılmış modüllerdir. Bu yönüyle bu modüller daha önce öğrendiğimiz gömülü fonksiyonlara çok benzer. Tıpkı gömülü fonksiyonlarda olduğu gibi, Standart Kütüphane Modüllerideheranemrimizeamadedir.Bizbunlarıistediğimizheran,herhangibirekyazılım kurmakzorundakalmadan,kendiprogramlarımıziçindekullanabiliriz. ª Ayrıcabakınız Python’ın Standart Kütüphanesi içinde hangi modüllerin olduğunu https://docs.python. org/3/library/adresindeninceleyebilirsiniz. Standart Kütüphane içinde, Python ile programlama yaparken işlerinizi bir hayli kolaylaştıracakpekçokmodülbulacaksınız. Başta da söylediğimiz gibi, biz bu bölüme gelinceye kadar üstünkörü de olsa modüllerden sözetmiştik.Örneğinöncekiderslerimizdeandığımızsys,os,randomvebenzerimodüllerhep birerStandartKütüphanemodülüdür.Dolayısıylabumodüllerinsunduğuişlevselliktenkendi programlarımızdaistediğimizheranyararlanabiliriz. 38.3 Modüllerin İçe Aktarılması Python’da herhangi bir modülü kullanabilmek için öncelikle onu ‘içe aktarmamız’ gerekir. İçe aktarmak, bir modül içindeki fonksiyon ve nitelikleri başka bir program (veya ortam) içinden kullanılabilir hale getirmek demektir. İsterseniz bu soyut tanımlamayı bir örnek ile somutlaştıralım. Mesela, bir Standart Kütüphane modülü olduğunu öğrendiğimiz ve önceki derslerimizde de değindiğimiz os adlı modülü içe aktaralım. Bunun için öncelikle etkileşimli kabuğuçalıştıralımveşukomutuverelim: 718 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 >>> import os Böylece os adlı modülü içe aktarmış, yani bu modül içindeki fonksiyon ve nitelikleri kullanılabilirhalegetirmişolduk. Hatırlarsanız ‘modül’ kavramını tanımlarken, bunların bize birtakım yararlı fonksiyonlar ve niteliklersunanaraçlarolduğunusöylemiştik.İşte,meselabuosmodülününbizehangiyararlı fonksiyonlarıveniteliklerisunduğunuöğrenmekiçindir()fonksiyonunukullanabiliriz: >>> dir(os) Gördüğünüzgibibumodülpekçokfonksiyonvenitelikbarındırıyor. Bumodüleadınıverenoskelimesioperatingsystem(işletimsistemi)ifadesininkısaltmasıdır. Bu modül, kullandığımız işletim sistemine ilişkin işlemler yapabilmemiz için bize çeşitli fonksiyonlarveniteliklersunar.Hemenbirörnekverelim. Diyelim ki bir program yazdınız. Ancak yazdığınız bu programın yalnızca Windows işletim sisteminde çalışmasını istiyorsunuz. Buna göre, eğer programınız Windows işletim sistemi kurulu bir bilgisayarda çalıştırılırsa programınızın normal bir şekilde başlamasını, ama eğer Windows dışı bir işletim sisteminde çalıştırılırsa da kullanıcıya bir uyarı mesajı verilmesini istiyorsunuz. İşte bunun için os modülünden yararlanabilirsiniz. Şimdi dir(os) komutuyla elde ettiğimiz listeyebakalım.Oradanameadlıbirnitelikolduğunugöreceksiniz.Bunitelik,bizekodlarımızın hangiişletimsistemindeçalıştığınıgösterir.Dolayısıyladayukarıdatarifettiğimizişiçingayet uygunbiraraçtır. Öncedenimport oskomutuylaosmodülünüiçeaktarmışolduğumuzuvarsayarsak,modülün buniteliğinişöylekullanıyoruz: >>> os.name ’posix’ os adlı modülün içindeki name niteliğine nasıl eriştiğimize çok dikkat edin. Önce modülümüzün adı olan ‘os’u yazıyoruz. Ardından bir nokta işareti koyup, ihtiyacımız olan niteliğinadınıbelirtiyoruz.Yanişöylebirformültakipediyoruz: modül_adı.fonksiyon_veya_nitelik os.name komutu, kullandığınız işletim sistemine bağlı olarak farklı çıktılar verir. Eğer bu komutu bir GNU/Linux dağıtımında veya bir Mac bilgisayarda verirsek yukarıdaki gibi ‘posix’ çıktısı alırız. Ama eğer aynı komutu Windows’ta verirsek ‘nt’ çıktısı alırız. Dolayısıyla os modülünün name niteliğini kullanarak, yazdığımız bir programın hangi işletim sisteminde çalıştığınıdenetleyebiliriz: >>> if os.name != ’nt’: ... print(’Kusura bakmayın! Bu programı yalnızca’, ... ’Windows\’ta kullanabilirsiniz!’) ... else: ... print(’Hoşgeldin Windows kullanıcısı!’) 38.3. ModüllerinİçeAktarılması 719 PythonBelgeleri,Yayım4.1.3 Etkileşimli kabukta yazdığımız bu programı gelin bir de bir metin dosyasına kaydedelim. Zira biz henüz modülleri öğrenme aşamasında olduğumuz için şimdilik bunları etkileşimli kabuktatestediyorolsakda,gerçekhayattaprogramlarımızıetkileşimlikabuğadeğil,program dosyalarıiçineyazacağız. Yukarıdakikodlarıbirdosyayakaydettiğimizdeprogramımızşöylegörünür: import os if os.name != ’nt’: print(’Kusura bakmayın! Bu programı yalnızca’, ’Windows\’ta kullanabilirsiniz!’) else: print(’Hoşgeldin Windows kullanıcısı!’) Gördüğünüzgibi,programımızıkaydederken,programımızınenbaşınaimport oskomutunu yazarak öncelikle ilgili modülü içe aktarıyoruz. Python’da modüller genellikle programın en başında içe aktarılır. Ama bu bir zorunluluk değildir. Modülleri programın istediğiniz her yerindeiçeaktarabilirsiniz(bununlailgilibiristisnadanbirazsonrasözedeceğiz). Modül içe aktarmaya ilişkin en önemli kural, modüle ait bir nitelik veya fonksiyonun kullanılmasından önce modülün içe aktarılmış olması gerekliliğidir. Yani mesela yukarıdaki programda os modülü içindeki name niteliğini kullanmadan önce os modülünü içe aktarmış olmamız gerekir. Eğer Python, if os.name != ’nt’: satırından önce herhangi bir yerde import osgibibirkomutlaosmodülününiçeaktarıldığınıgöremezsehataverecektir. Bu programı yukarıdaki gibi bir dosyaya kaydettikten sonra bunu herhangi bir Python programıgibiçalıştırabilirsiniz. EğerbuprogramıWindowsdışındakibirişletimsistemindeçalıştırırsanızşuçıktıyıalırsınız: Kusura bakmayın! Bu programı yalnızca Windows’ta kullanabilirsiniz! AmaeğerbuprogramWindowsişletimsistemindeçalıştırılırsaşuçıktıyıverir: Hoşgeldin Windows kullanıcısı! Böylece modül içindeki bir niteliğe erişmiş olduk. Yalnız burada asla unutmamamız gereken şey, öncelikle kullanacağımız modülü import modül_adı komutuyla içe aktarmak olacaktır. Modülü içe aktarmazsak tabii ki o modüldeki fonksiyon veya niteliklere de erişemeyiz. (Sık yapılanbirhataolduğuiçin,bunutekrartekrarvurguluyoruz...) Bu arada bir modülü, her etkileşimli kabuk oturumunda yalnızca bir kez içe aktarmak yeterlidir.Yanisizetkileşimlikabuğuçalıştırdıktansonrabirkezimport oskomutuylamodülü içeaktardıktansonra,oetkileşimlikabukoturumunukapatanakadar,aynımodülütekrariçe aktarmakzorundakalmadanbumodülüniçeriğinikullanabilirsiniz. Aynı şekilde, eğer bu kodları etkileşimli kabuğa değil de bir program dosyasına yazıyorsanız, import os komutunu dosyanın başına bir kez yazdıktan sonra aynı modülü programın ilerleyen kısımlarında tekrar içe aktarmak zorunda kalmadan, o modülünün içeriğinden yararlanabilirsiniz. Gördüğünüz gibi, bir Standart Kütüphane Modülü olan os bize name adlı çok kullanışlı bir nitelik sunuyor. Eğer os modülü olmasaydı, name adlı niteliğin sunduğu işlevi kendimiz icat etmekzorundakalırdık. 720 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Başkabirörnekdahaverelim... Diyelim ki yine bir program yazdınız. Programınızın çalışması için, programınızı kullanan kişinin bilgisayarında birtakım dizinler oluşturmanız gerekiyor. İşte bu iş için de os modülündenyararlanabilirsiniz. Bumodüliçindekimakedirs()fonksiyonunukullanarak,oandaiçindebulunduğunuzdizinde yenibirdizinoluşturabilirsiniz: >>> os.makedirs(’DATA’) Bu komutu verdikten sonra, o anda altında bulunduğunuz dizinde DATA adlı bir dizin oluşacaktır. Eğer o anda hangi dizin altında bulunduğunuzu öğrenmek isterseniz de yine os modülündenfaydalanabilirsiniz: >>> os.getcwd() osmodülününgetcwd()fonksiyonubizeoandahangidizinaltındabulunduğumuzugösterir. Bu komutun çıktısında hangi dizin adını görüyorsanız, biraz önce makedirs() fonksiyonu ile oluşturduğunuzDATAdizinideodizinaltındaoluşmuştur... Gördüğünüzgibi,birçırpıdaosmodülününbirkaçözelliğindenbirdenyararlandık.Dahaönce de söylediğimiz gibi, eğer os modülü olmasaydı yukarıda gerçekleştirdiğimiz bütün işlevleri kendinizicatetmekzorundakalırdınız. Böylece Python’daki modüllerin neye benzediğini ve nasıl kullanıldığını anlamış olduk. Modüllerin faydalı araçlar olduğu konusunda sizleri ikna edebilmiş olduğumuzu varsayarak birsonrakibölümegeçelim. 38.3.1 Farklı İçe Aktarma Yöntemleri Biz şimdiye kadar, modülleri import modül_adı şeklinde içe aktardık. Esasında standart içe aktarma yöntemi de budur. Bir modülü bu şekilde içe aktardığımız zaman, modül adını kullanarak,omodülüniçeriğineerişebiliriz: >>> import sys ’ >>> sys.version #Python ın sürümünü verir veya: >>> import os >>> os.name #İşletim sistemimizin adını verir gibi... Ancak Python’da bir modülü içe aktarmanın tek yöntemi bu değildir. Eğer istersek modülleri dahafarklışekillerdedeiçeaktarabiliriz. Gelinşimdibualternatifmodülaktarmabiçimlerininnelerolduğunugörelim. 38.3. ModüllerinİçeAktarılması 721 PythonBelgeleri,Yayım4.1.3 importmodül_adıasfarklı_isim Bazıkoşullar,birmodülükendiadıyladeğildebaşkabirisimleiçeaktarmanızıgerektirebilir. Ya da siz bir modülü kendi adı dışında bir adla içe aktarmanın daha iyi bir fikir olduğunu düşünebilirsiniz. Pekiamanetürkoşullarbirmodülüfarklıbiradlaiçeaktarmamızıgerektirebilirveyabizhangi sebeplebirmodülüfarklıadlaiçeaktarmayıisteyebiliriz? Busorularıncevabınıverebilmekiçin,gelinistersenizsubprocessadlıbirStandartKütüphane modülündenyararlanalım.Hembuvesileyleyenibirmodüldeöğrenmişoluruz... (cid:242) Not subprocess modülü, harici komutları Python içinden çalıştırabilmemizi sağlayan oldukça faydalı bir araçtır. Bu modülü kullanarak Python programlarımızın içinden başka programlarıçalıştırabiliriz. Bir modülün içindeki fonksiyon ve nitelikleri her kullanmak isteyişimizde, o fonksiyon veya niteliğin başına modül adını da eklememiz gerektiğini artık gayet iyi biliyorsunuz. Örneğin subprocessadlımodülü >>> import subprocess komutuyla içe aktardıktan sonra, bu modül içindeki herhangi bir fonksiyon veya niteliği kullanabilmenin birinci şartı, modül adını ilgili fonksiyon veya niteliğin önüne getirmektir. Mesela biz subprocess modülünün call() adlı fonksiyonunu kullanmak istersek, şöyle bir kodyazmamızgerekir: >>> subprocess.call(’notepad.exe’) Buşekilde‘Notepad’programınıPythoniçindençalıştırmışolduk. Ancak gördüğünüz gibi, ‘subprocess’ biraz uzun bir kelime. Bu modülü her kullanmak isteyişinizde nitelik veya fonksiyon adının önüne bu uzun kelimeyi getirmek bir süre sonra sıkıcı bir hal alabilir. Bu yüzden eğer isterseniz modülü import subprocess şeklinde kendi adıyladeğildedahakısabiradlaiçeaktarmayıtercihedebilirsiniz: >>> import subprocess as sp Buradaşöylebirformüluyguladığımızadikkatedin: >>> import modül_adı as farklı_bir_isim Böyleceartıkbumodülüyalnızcaspönekiylekullanabilirsiniz: >>> sp.call(’notepad.exe’) Örnekolmasıaçısındanbaşkabirmodülüdahaelealalım.Modülümüzünadıwebbrowser. (cid:242) Not 722 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 webbrowser modülü, bilgisayarımızda kurulu internet tarayıcısını kullanarak internet siteleriniaçabilmemizisağlar. Tıpkı‘subprocess’gibi,‘webbrowser’kelimeside,herdefasındatekraretmesisıkıcıolabilecek bir kelime. Dolayısıyla dilerseniz bu modülü import webbrowser yerine farklı bir isimle içe aktarabilirsiniz.Örneğin: >>> import webbrowser as br veya: >>> import webbrowser as web Modülühangiadlaiçeaktaracağınıztamamensizekalmış.Diyelimkibumodülü‘web’adıyla içeaktardık.Artıkbumodülüniçindekiaraçlarıwebönekiylekullanabiliriz: >>> web.open(’www..com’) . Uyarı Bazı GNU/Linux dağıtımlarında websitesi adresini ‘http’ önekiyle birlikte belirtmeniz gerekebilir.Örn.web.open(’http://www..com’). Bukod,bilgisayarımızdakiöntanımlıwebtarayıcısıhangisiyseonuçalıştıracakvebizi,parantez içindegösterilenwebsayfasınagötürecektir. Eğerbizwebbrowsermodülünüdoğrudankendiadıylaiçeaktarsaydık: >>> import webbrowser Budurumdayukarıdakikomutuşuşekildevermekzorundakalacaktık: >>> webbrowser.open(’www..com’) Ama bu modülü daha kısa bir adla içe aktarmış olmamız sayesinde, bu modülü gayet pratik birşekildekullanmaimkanınakavuşuyoruz. frommodül_adıimportisim1,isim2 Şimdiyekadarverdiğimizörneklerdendegördüğünüzgibi,StandartKütüphaneModülleri’nin içindeçoksayıdafonksiyonvenitelikbulunuyor.Meselaosmodülünüelealalım: >>> import os >>> dir(os) Listedeepeyisimvar... Bizimport oskomutunuverdiğimizde,listedekibütünoisimleri‘os’ismialtındaiçeaktarmış oluyoruz.Bununbirsakıncasıyok,ancakyazdığımızprogramlardabufonksiyonveniteliklerin hepsine ihtiyaç duymayız. O yüzden, eğer arzu ederseniz, import os gibi bir komutla 38.3. ModüllerinİçeAktarılması 723 PythonBelgeleri,Yayım4.1.3 bütün o isimleri içe aktarmak yerine, yalnızca kullanacağınız isimleri içe aktarmayı tercih de edebilirsiniz. Mesela os modülünün yalnızca name niteliğini kullanacaksanız, modülü şu şekildeiçeaktarabilirsiniz: >>> from os import name Bu şekilde os modülünden yalnızca name ismi içe aktarılmış olur ve yalnızca bu ismi kullanabiliriz: >>> name ’posix’ Budurumdaos.namekomutuhataverecektir: >>> os.name NameError: name ’os’ is not defined Çünkü biz from os import name komutunu verdiğimizde, os modülünü değil, bu modül içindekibirnitelikolanname’iiçeaktarmışoluyoruz.Dolayısıylaosisminikullanamıyoruz. Buşekilde,aynımodüliçindenbirkaçfarklınitelikvefonksiyonudaiçeaktarabilirsiniz: >>> from os import name, listdir, getcwd Bukomutlaosmodülüiçindenyalnızcanameniteliğini,listdir()fonksiyonunuvegetcwd() fonksiyonunuaktarmışolduk: >>> listdir() Bufonksiyon,oandaiçindebulunduğumuzdizindekidosyalarılisteler. namevegetcwd()isimleriningöreviniisedahaönceöğrenmiştik: >>> name ’nt’ >>> getcwd() ’C:\\Documents and Settings\\fozgul\\’ Gelelimbirbaşkamodülaktarmabiçimine... 724 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 frommodül_adıimportisimasfarklı_isim Birmodülü,kendiadındanfarklıbiradlanasıliçeaktarabileceğinizibiliyorsunuz: import subprocess as sp Buşekildesubprocessmodülünüspadıylaiçeaktarmışoluyoruz. Aynı şekilde, bir modül içinden belli nitelik ve fonksiyonları da nasıl içe aktaracağınızı biliyorsunuz: from os import path, listdir Buşekildeosmodülündenpathniteliğinivelistdir()fonksiyonunuiçeaktarmışoluyoruz. Pekiyabirmodüliçindenbellinitelikvefonksiyonlarıfarklıbiradlaiçeaktarmakistersenizne yapacaksınız? İştePythonsizebununiçindebiryolsunar.Dikkatlicebakın: from os import path as p veya: from os import listdir as ld gibi... Bu örneklerde, os modülü içinden path adlı niteliği p adıyla; listdir() fonksiyonunu ise ld adıyla içe aktardık. Böylece path niteliğini p adıyla; listdir() fonksiyonunu da ld adıyla kullanabiliriz. Yalnız bu yöntem çok sık kullanılmaz. Bunu da not edip, içe aktarma yöntemlerinin sonuncusunageçelim. frommodül_adıimport* Python’daki modülleri from modül_adı import * formülüne göre içe aktarmak da mümkündür (bu yönteme ‘yıldızlı içe aktarma’ diyebilirsiniz). Bu şekilde bir modül içindeki bütünfonksiyonvenitelikleriiçeaktarmışoluruz(ismi_ilebaşlayanlarhariç): >>> from sys import * Böylece sys modülü içindeki bütün fonksiyon ve nitelikleri, başlarına modül adını eklemeye gerekolmadankullanabiliriz: >>> version Ancak bu yöntem pek tavsiye edilmez. Çünkü bu şekilde, modül içindeki bütün isimleri kontrolsüzbirşekildemevcutortama‘boşaltmış’oluyoruz.Meselaeğermodülbuşekildeiçe aktarılmadan önce version diye başka bir değişken tanımlamışsanız, modül içe aktarıldıktan sonra,öncedentanımladığınızbuversiondeğişkeninindeğerikaybolacaktır: 38.3. ModüllerinİçeAktarılması 725 PythonBelgeleri,Yayım4.1.3 >>> version = ’1.0’ >>> print(version) 1.0 Buortamafrom sys import *komutuylasysmodülününbütüniçeriğiniaktaralım: >>> from sys import * Şimdideversiondeğişkeninindeğeriniyazdıralım: >>> print(version) Buradaalacağımızçıktışuolur: ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ Gördüğünüz gibi, sys modülünün içindeki version niteliği bizim önceden tanımladığımız version değişkeniyle çakıştı ve herhangi bir uyarı vermeden, bizim tanımladığımız version değerinisilipkendiversiondeğerinibizimkininyerinegeçirdi... from modül_adı import * komutunun yaptığı şeyi, sıkıştırılmış bir klasörün bütün içeriğini olduğu gibi masaüstüne atmaya benzetebilirsiniz. Böyle bir durumda, eğer masaüstünde sıkıştırılmış klasördekilerle aynı adlı dosyalar varsa, sıkıştırılmış klasör içindeki dosya adları, masaüstündehalihazırdavarolandosyaadlarıylaçakışacaktır. Birsonrakikonuyageçmedenönce,yıldızlıiçeaktarmaileilgiliönemlibirnoktayadeğinelim. Hatırlarsanız, bu konunun başında, modülleri programımızın her yerinden içe aktarabileceğimizi söylemiştik. Mesela bir modülü, program dosyamızın en başında içe aktarabiliriz: from os import * Ama bunun bir istisnası var. Bir modülü yıldızlı olarak içe aktaracaksak, bu işlemi lokal etki alanları içinden gerçekleştiremeyiz. Yani mesela bir fonksiyonun lokal isim alanı içinde şöyle birkodyazabiliriz: def fonksiyon(): import os Veya: def fonksiyon(): import subprocess as sp Amaşöylebirkodyazamayız: def fonksiyon(): from os import * Bukodlarıbirdosyayakaydedipçalıştırdığımızdaşunabenzerbirhataalırız: 726 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 File "falanca.py", line 1 def fonksiyon(): SyntaxError: import * only allowed at module level Bunun anlamı şu: Yıldızlı içe aktarma işlemleri ancak modül seviyesinde, yani global isim alanında gerçekleştirilebilir. Dolayısıyla yukarıdaki içe aktarma işlemini ancak fonksiyonun dışındagerçekleştirebiliriz: from os import * def fonksiyon(): pass Veya: def fonksiyon(): pass from os import * Bu istisnai duruma dikkat ediyoruz. Elbette modül içe aktarma işlemlerini gerçekleştirmenin ensağlıklıyolubütünmodülleriprogramdosyasınınenbaşındaiçeaktarmaktır. 38.4 Kendi Tanımladığımız Modüller Buraya gelene kadar sadece Python’daki hazır modüllerden söz ettik. Hazır modüllerin, ‘Standart Kütüphane Modülleri’ ve ‘Üçüncü Şahıs Modülleri’ olarak ikiye ayrıldığını öğrenmiştiniz.Yukarıda buhazırmodüllerin‘StandartKütüphaneModülleri’adını verdiğimiz altbaşlığınıhalihazırdaelealdık.Dolayısıylaartıkstandartmodüllerinnelerolduğunuvegenel olarakbunlarınnasılkullanıldığınıbiliyoruz. Hazır modül başlığı altında bir de ‘üçüncü şahıs modülleri’nin bulunduğunu da söylemiştik. Birazdan üçüncü şahıs modüllerinden de söz edeceğiz. Ama isterseniz ondan önce hazır modüllere bir ara verelim ve biraz da kendi modüllerimizi nasıl yazabileceğimize bakalım. Kendi modüllerimizi yazmak, modül konusunu biraz daha net bir şekilde anlamamızı sağlayacaktır. 38.4.1 Modüllerin Tanımlanması Hatırlarsanızbubölümünbaşında,‘modülnedir?’sorusunaşucevabıvermiştik: Bazı işlevleri kolaylıkla yerine getirmemizi sağlayan birtakım fonksiyonları ve nitelikleriiçindebarındıranaraçlar... EsasındaPython’dakimodüllerişöyledetanımlayabiliriz: Diyelim ki bir program yazıyorsunuz. Yazdığınız bu programın içinde karakter dizileri, sayılar, değişkenler, listeler, demetler, sözlükler ve fonksiyonlar var. Programınızda.pyuzantılıbirmetindosyasıiçindeyeralıyor.İştebütünbuöğeleri ve veri tiplerini içeren .py uzantılı dosyaya ‘modül’ adı verilir. Yani şimdiye kadar 38.4. KendiTanımladığımızModüller 727 PythonBelgeleri,Yayım4.1.3 yazdığınız ve yazacağınız bütün Python programları aynı zamanda birer modül adayıdır. Gelinistersenizyukarıdakibutanımındoğruluğunutestedelim. Şimdi Python’ın etkileşimli kabuğunu çalıştırın ve kütüphane modüllerinden biri olan os modülünüiçeaktarın: >>> import os dir(os) komutunu kullanarak modülün içeriğini kontrol ettiğinizde, o listede __file__ adlı bir niteliğin olduğunu göreceksiniz. Bu nitelik Python ile yazılmış tüm modüllerde bulunur. Bu niteliğişuşekildekullanıyoruz: >>> os.__file__ ’C:\Python37\lib\os.py’ İşte buradan aldığımız çıktı bize os modülünün kaynak dosyasının nerede olduğunu gösteriyor.Hemençıktıdagörünenkonumagidelimveos.pydosyasınıaçalım. Dosyayıaçtığınızda,gerçektendebumodülünaslındasıradanbirPythonprogramıolduğunu göreceksiniz. Dosyanın içeriğini incelediğinizde, dir(os) komutuyla elde ettiğimiz nitelik ve fonksiyonların dosya içinde nasıl tanımlandığını görebilirsiniz. Mesela yeni dizinler oluşturmak için os.makedirs() şeklinde kullandığımız makedirs fonksiyonunun os.py içinde tanımlanmışaleladebirfonksiyonolduğunugörebilirsiniz. Aynı şekilde, önceki sayfalarda örneklerini verdiğimiz webbrowser modülü de, bilgisayarımızdaki sıradan bir Python programından ibarettir. Bu modülün nerede olduğunu daşukomutlagörebilirsiniz: >>> import webbrowser >>> webbrowser.__file__ Gördüğünüzgibi,webbrowsermodülüde,tıpkıosmodülügibi,bilgisayarımızdaki.pyuzantılı birdosyadanbaşkabirşeydeğil.İstersenizbudosyanındaiçiniaçıpinceleyebilirsiniz. Yalnızşugerçeğideunutmamalıyız:Python’dakibütünmodüllerPythonprogramlamadiliile yazılmamıştır.BazımodüllerCileyazılmıştır.DolayısıylaCileyazılmışbirmodülün.pyuzantılı birPythondosyasıbulunmaz.Meselasysböylebirmodüldür.BumodülCprogramlamadiliile yazıldığıiçin,kayıtlıbir.pydosyasınasahipdeğildir.Dolayısıylabumodülünbir__file__niteliği debulunmaz: >>> import sys >>> sys.__file__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’module’ object has no attribute ’__file__’ Ama tabii ki, Python’daki standart kütüphane modüllerinin çok büyük bölümü Python ile yazılmıştır ve bu modüllerin kaynak dosyalarını os ve webbrowser modüllerini bulduğunuz dizinde görebilirsiniz. Örneğin önceki derslerimizde bahsi geçen locale ve random gibi modüllerinkaynakdosyalarınıdaburadabulabilirsiniz. Gelelimasılkonumuzolan‘modültanımlama’ya... 728 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Hatırlarsanız,Python’dabirfonksiyontanımlamakiçinşusözdiziminikullanıyorduk: def fonksiyon_adı(parametreler): fonksiyon_gövdesi Ancak yukarıdaki örneklerden de rahatlıkla görebileceğiniz gibi, modüller için böyle özel bir sözdizimiyoktur.YazdığınızherPythonprogramıaynızamandapotansiyelbirmodüldür. Ohaldeşimdigelinbirtanedekendimizmodülyazalım. Meselabirprogramdosyasıoluşturalımveadınıdasözlük.pykoyalım.İştebuprogram,aynı zamanda bir Python modülüdür. Bu modülün adı da ‘sözlük’tür. Dediğimiz gibi, Python’da modüllergenellikle.pyuzantısınasahiptir.Ancakbirmodülünadısöylenirkenbu.pyuzantısı dikkatealınmaz.Buyüzdenelinizdeki‘sözlük.py’adlıprogramınmodüladı‘sözlük’olacaktır. Gördüğünüzgibi,modültanımlamaktaherhangibirözelzorlukyok.Yazdığımızherprogram, otomatikolarak,aynızamandabirmodüloluyor. sözlük.pyadlıprogramımızıniçeriğişöyleolsun: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" return sözlük.get(sözcük, hata.format(sözcük)) İşte böylece ilk modülümüzü tanımlamış olduk. Şimdi de, yazdığımız bu modülü nasıl kullanacağımızıöğrenelim. Esasındakütüphanemodülleriylekendiyazdığımızmodüllerarasındakullanımaçısındanpek birfarkyoktur.Bubölümünbaşındagördüğümüzkütüphanemodüllerininasılkullanıyorsak, kendimodüllerimizideöylekullanıyoruz. Kütüphane modüllerini anlatırken gördüğümüz gibi, modül sistemi sayesinde, bir program içinde bulunan fonksiyon (ve nitelikleri) başka Python programları içine aktarabiliyoruz. Böylece bir Python programındaki (veya modülündeki) işlevsellikten, başka bir Python programındadayararlanabiliyoruz. Şimdi, eğer bu sözlük.py dosyasını, mesela masaüstüne kaydettiyseniz, masaüstünün bulunduğu konumda bir komut satırı açın ve Python’ın etkileşimli kabuğunu başlatın. Tıpkı kütüphane modüllerinde olduğu gibi, etkileşimli kabukta şu komutu vererek sözlük adlı modülüiçeaktarın: >>> import sözlük Eğerhiçbirşeyolmadanbiraltsatırageçildiysemodülünüzübaşarıylaiçeaktardınızdemektir. EğerNo module named sözlükgibibirhatamesajıylakarşılaşıyorsanız,muhtemelenPython’ı sözlük.pydosyasınınolduğudizindebaşlatamamışsınızdır. import sözlükkomutununbaşarılıolduğunuvarsayarakyolumuzadevamedelim... 38.4. KendiTanımladığımızModüller 729 PythonBelgeleri,Yayım4.1.3 38.4.2 Modüllerin Yolu Python geliştiricilerinin yazıp dile kaynaştırdığı kütüphane modülleri ile kendi yazdığınız modüller arasında pek bir fark bulunmadığını ifade etmiştik. Her iki modül türü de, içinde PythonkomutlarınıveveritiplerinibarındıranaleladePythonprogramlarındanibarettir. Ancak şimdiye kadar yaptığımız örneklerde bir şey dikkatinizi çekmiş olmalı. Kütüphane modüllerini her yerden içe aktarabiliyoruz. Yani, komut satırını çalıştırdığımız her konumda veya program dosyamızın bulunduğu her dizin altında bu modülleri rahatlıkla kullanabiliyoruz.Python’ınbumodülleribulamamasıgibibirşeysözkonusudeğil. Ama kendi yazdığımız modülleri içe aktarabilmemiz için, bu modüllerin o anda içinde bulunduğumuz dizin altında yer alması gerekiyor. Yani mesela yukarıda örneğini verdiğimiz sözlük modülünü, sözlük.py dosyasını bilgisayarımızdaki hangi konuma kaydetmişsek o konumdaniçeaktarabiliyoruz. Diyelimkisözlük.pydosyasınımasaüstüne kaydetmiştik.İşte bumodülükomut satırındaiçe aktarabilmemiziçin,komutsatırınıdamasaüstününbulunduğukonumdaçalıştırmışolmamız gerekiyor. Aynı şekilde eğer biz bu sözlük modülünü, deneme.py adlı başka bir program içinde kullanacaksak, bu deneme.py dosyasının da sözlük.py adlı dosya ile aynı dizinde yer alması gerekiyor. Aksihalde,import sözlükkomutuhataverecektir. Peki neden kütüphane modüllerini her yerden içe aktarabilirken, kendi yazdığımız modülleri yalnızcabulunduklarıdizinaltındaiçeaktarabiliyoruz? Aslında bunun cevabı çok basit: Biz bir program dosyasında veya komut satırında import modül_adıgibibirkomutverdiğimizdePython‘modül_adı’olarakbelirttiğimizmodülübulmak içinbiraramaişlemigerçekleştirir.ElbettePythonbumodülüsabitdiskintamamındaaramaz. Python, içe aktarmak istediğimiz modülü bulmak için belli birtakım dizinlerin içini kontrol eder. Peki Python modül dosyasını bulmak için hangi dizinlerin içine bakar? Bu sorunun cevabınıbizesysmodülününpathadlıbirniteliğiverecek.Hemenbakalım: >>> import sys >>> sys.path İşte Python bir modül dosyasını ararken, import komutunun verildiği dizin ile birlikte, sys.path çıktısında görünen dizinlerin içine de bakar. Eğer modül dosyasını bu dizinlerin içinde bulursa modülü başarıyla içe aktarır, ama eğer bulamazsa ImportError cinsinden bir hataverir. Peki eğer biz kendi modüllerimizi de her yerden içe aktarabilmek istersek ne yapmamız gerekiyor? Bunun için iki seçeneğimiz var: Birincisi, modülün yolunu sys.path listesine ekleyebiliriz. İkincisi, modülümüzü sys.path içinde görünen dizinlerden birine kopyalayabilir veya taşıyabiliriz. Önceliklebirinciseçeneğielealalım. Gördüğünüzgibi,sys.pathkomutununçıktısıaslındabasitbirlistedenbaşkabirşeydeğildir. Dolayısıyla Python’da liste adlı veri tipi üzerinde ne tür işlemler yapabiliyorsanız, sys.path üzerindedeaynışeyleriyapabilirsiniz. 730 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Mesela, modül dosyasının /home//programlar adlı dizin içinde bulunduğunu varsayarsak,modüldosyasınınyolunusys.pathlistesininensonunaşuşekildeekleyebiliriz: sys.path.append(r’/home//programlar’) Burada listelerin append() metodunu kullandığımıza dikkat edin. Dediğimiz gibi, sys.path aslında basit bir listeden ibarettir. Dolayısıyla bir listeye nasıl öğe ekliyorsak, sys.path’e de aynışekildeöğeekliyoruz. Modül dosyasının bulunduğu /home//programlar yolunu sys.path listesine eklediğimizegöre,artıkmodülümüzüheryerdeniçeaktarabiliriz. Kendi yazdığımız bir modülü her yerden içe aktarabilmenin ikinci yönteminin, ilgili modül dosyasını sys.path çıktısında görünen dizinlerden herhangi birine kopyalamak olduğunu söylemiştik.Dolayısıyla,sys.pathçıktısınabakıp,modüldosyanızıoradagörünendizinlerden herhangi biri içine kopyalayabilirsiniz. Yaygın olarak tercih edilen konum, Python kurulum diziniiçindekisite-packagesadlıdizindir.Budizininyerinişuşekildetespitedebilirsiniz: >>> from distutils import sysconfig >>> sysconfig.get_python_lib() Modüldosyanızı,bukomutlardanaldığınızçıktınıngösterdiğidiziniçinekopyaladıktansonra, modülünüzüheryerdeniçeaktarabilirsiniz. Bu konuyu kapatmadan önce sys.path ile ilgili önemli bir bilgi daha verelim. Python, içe aktarmakistediğimizbirmodülübulabilmekiçindizinleriararkensys.pathlistesindekidizin adlarınısoldansağadoğruokur.Modüldosyasınıbulduğuandadaaramaişleminisonaerdirir vemodülüiçeaktarır.Diyelimkisys.pathçıktımızşöyle: [’A’, ’B’, ’C’] Eğer hem A, hem de B dizininde sözlük.py adlı bir dosya varsa, Python A dizinindeki sözlük modülünüiçeaktarır.Çünküsys.pathçıktısındaAdiziniBdizinindenöncegeliyor.Eğersiziçe aktarmasırasındabirdizineöncelikvermekistersenizodiziniappend()metoduylasys.path listesininsonunaeklemekyerine,insert()metoduylalisteninenbaşınaekleyebilirsiniz: >>> sys.path.insert(0, r’dizin/adı’) BöylecePython,modülünüzüenbaşaeklediğinizdizindeniçeaktaracaktır. Tekrar tekrar söylediğimiz gibi, sys.path sıradan bir listedir. Dolayısıyla listelerin üzerine hangimetotlarıuygulayabiliyorsanızsys.pathüzerinedeometotlarıuygulayabilirsiniz. 38.4.3 Modüllerde Değişiklik Yapmak Python’da bir modül başka bir ortama aktarıldığında, o modülün içinde yer alan nitelik ve fonksiyonlarınoortamiçindenkullanılabilirhalegeldiğinibiliyorsunuz.Yukarıdakiörnektebiz import sözlük komutuyla, sözlük adlı modülün bütün içeriğini etkileşimli kabuk ortamına (veya program dosyasına) aktarmış olduk. Dolayısıyla da artık bu modülün bütün içeriğine erişebiliriz. Peki acaba bu modül içinde bizim erişebileceğimiz hangi nitelik ve fonksiyonlar bulunuyor? Tıpkıkütüphanemodülleriniişlerkenyaptığımızgibi,dir()fonksiyonundanyararlanarak,içe aktardığımızbumodüliçindekikullanılabilirfonksiyonveniteliklerigörebilirsiniz: 38.4. KendiTanımladığımızModüller 731 PythonBelgeleri,Yayım4.1.3 >>> dir(sözlük) Bukomutbizeşöylebirçıktıverir: [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’ara’, ’sözlük’] Gördüğünüz gibi, nasıl os modülünün içinde name, listdir() ve getcwd() gibi nitelik ve fonksiyonlar varsa, kendi yazdığımız sözlük modülü içinde de ara() adlı bir fonksiyon ve sözlükadlıbirnitelikvar. İşte biz bu fonksiyon ve niteliği kullanma imkanına sahibiz. Gelin birkaç deneme çalışması yapalım: >>> sözlük.sözlük Bu komutun, bir kütüphane modülündeki niteliklere erişmekten hiçbir farkı olmadığına dikkatiniziçekmekisterim.Meselasysmodülününversionniteliğinenasılerişiyorsak,sözlük modülününsözlükniteliğinedeaynışekildeerişiyoruz. sözlük.sözlükkomutubizesözlükmodülüiçindekisözlükadlıdeğişkeniniçeriğiniverecektir. Şimdideaynımodüliçindekiara()fonksiyonunaerişelim: >>> sözlük.ara(’kitap’) Budabizeara()fonksiyonunukitapargümanıylabirlikteçağırmaimkanıveriyor. Yukarıda verdiğimiz örnekte sözlük modülünü etkileşimli kabuk üzerinde kullandık. Elbette programyazarkenmodüllerietkileşimlikabuktadeğil,programdosyalarıiçindekullanacağız. Ancak özellikle bir modülün geliştirilme aşamasında o modülü test etmek için etkileşimli kabuküzerindeçalışmakoldukçapratikvefaydalıbiryoldur.Meselayazmaktaolduğunuzbir programın (diğer bir deyişle modülün) nitelik ve fonksiyonlarını test etmek için, o programı etkileşimlikabuktabirmodülolarakiçeaktarıpçeşitlidenemeçalışmalarıyapabilirsiniz. Dilersenizyineyukarıdakiörneküzerindengidelim: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" return sözlük.get(sözcük, hata.format(sözcük)) Bumodülüiçeaktaralım: >>> import sözlük Modülüniçeriğinikontroledelim: >>> dir(sözlük) 732 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Bu komutun çıktısında sözlük niteliğini ve ara() fonksiyonunu görüyoruz. Gelin şimdi programımızabireklemeyapalım: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" return sözlük.get(sözcük, hata.format(sözcük)) def ekle(sözcük, anlam): mesaj = "{} kelimesi sözlüğe eklendi!" sözlük[sözcük] = anlam print(mesaj.format(sözcük)) Burada sözlük modülüne ekle() adlı bir fonksiyon ilave ettik. Bu fonksiyon, sözlüğe yeni kelimelereklememizisağlayacak.Şimditekrarmodülümüzüniçeriğinikontroledelim: >>> dir(sözlük) Ancak gördüğünüz gibi, modüle yeni eklediğimiz ekle() fonksiyonu bu çıktıda görünmüyor. Bunun nedeni, etkileşimli kabukta modül bir kez içe aktarıldıktan sonra, o modülde yapılan değişikliklerinotomatikolaraketkinleşmiyoroluşudur.Yanideğişikliklerinetkileşimlikabukta etkinleşebilmesiiçinomodülüyenidenyüklememizlazım.Bunuikişekildeyapabiliriz: Birincisi,etkileşimlikabuğukapatıpyenidenaçtıktansonraimport sözlükkomutuylasözlük modülünütekrariçeaktarabiliriz. İkincisi,importlibadlıbirkütüphanemodülündenyararlanarakkendimodülümüzüntekrar yüklenmesinisağlayabiliriz.Bumodülüşöylekullanıyoruz: >>> import importlib >>> importlib.reload(sözlük) Bu iki komutu verdikten sonra, sözlük üzerinde tekrar dir() fonksiyonunu uygularsak, yeni eklediğimizekle()fonksiyonununçıktıyayansıdığınıgörürüz: >>> dir(sözlük) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’ara’, ’ekle’, ’sözlük’] Tıpkı önceki derslerimizde gördüğümüz sys, os ve keyword modülleri gibi, importlib de bir kütüphane modülüdür. Bu modülün bizim yukarıda yazdığımız sözlük adlı modülden farkı, Python geliştiricileri tarafından yazılıp dile entegre edilmiş bir ‘hazır modül’ olmasıdır. Yani sözlük modülünü biz kendimiz yazdık, importlib modülünü ise Python geliştiricileri yazdı. İkisiarasındakitekfarkbu. Nediyorduk?Evet,sözlükadlımodüleekle()adlıyenibirfonksiyonilaveettik.Bufonksiyona da, tıpkı sözlük niteliğinde ve ara() fonksiyonunda olduğu gibi, modül adını kullanarak erişebiliriz: 38.4. KendiTanımladığımızModüller 733 PythonBelgeleri,Yayım4.1.3 >>> sözlük.ekle(’araba’, ’car’) araba kelimesi sözlüğe eklendi! Sözlüğümüze, ‘araba’ adlı yeni bir kelimeyi, ‘car’ karşılığı ile birlikte ekledik. Hemen bunu sorgulayalım: >>> sözlük.ara(’araba’) ’car’ Gayetgüzel!Şimdisözlüğümüzebireklemedahayapalım: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" return sözlük.get(sözcük, hata.format(sözcük)) def ekle(sözcük, anlam): mesaj = "{} kelimesi sözlüğe eklendi!" sözlük[sözcük] = anlam print(mesaj.format(sözcük)) def sil(sözcük): try: sözlük.pop(sözcük) except KeyError as err: print(err, "kelimesi bulunamadı!") else: print("{} kelimesi sözlükten silindi!".format(sözcük)) Budefadamodülümüzesil()adlıbaşkabirfonksiyonekledik.Bufonksiyon,sözlüktenöğe silmemizisağlayacak: >>> sözlük.sil(’kitap’) Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’module’ object has no attribute ’sil’ Gördüğünüz gibi, bu kez bir hata mesajı aldık. Peki sizce neden? Elbette değişiklik yaptıktan sonramodülüyenidenyüklemediğimizden... Ohaldeöncemodülümüzüyenidenyükleyelim: >>> importlib.reload(sözlük) Şimdibufonksiyonukullanabiliriz: 734 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 >>> sözlük.sil(’kitap’) kitap kelimesi sözlükten silindi! Bu noktada, importlib modülünün reload() fonksiyonunun çalışma sistemine ilişkin birkaç önemlibilgiverelim. importlib modülünün reload() fonksiyonu, bir modüle yeni eklenen öğeleri yeniden yükleyerek,bunlarınetkileşimlikabuktakullanılabilirhalegelmesinisağlar.Bununnedemek olduğunubiliyoruz.Yukarıdabununörneklerinivermiştik. Eğerbirmodüldekibazınitelikveyafonksiyonlarısilerseniz,importlibmodülününreload() fonksiyonuilebumodülüyenidenyüklediktensonrabilebunitelikvefonksiyonlarönbellekte tutulmayadevameder.Örneğin,yukarıdakisözlükmodülünüönceiçeaktaralım: >>> import sözlük Şimdimodülüniçeriğinikontroledelim: >>> dir(sözlük) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’ara’, ’ekle’, ’sil’, ’sözlük’] Modüldosyasındansil()adlıfonksiyonuçıkaralım.Yanimodülümüzünsonhalişöyleolsun: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" return sözlük.get(sözcük, hata.format(sözcük)) def ekle(sözcük, anlam): mesaj = "{} kelimesi sözlüğe eklendi!" sözlük[sözcük] = anlam print(mesaj.format(sözcük)) Tekrar etkileşimli kabuğa dönüp, importlib modülünün reload() fonksiyonu aracılığıyla modülümüzüyenidenyükleyelim: >>> import importlib >>> importlib.reload(sözlük) Şimdisözlükmodülününiçeriğinitekrarkontroledelim: >>> dir(sözlük) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’ara’, ’ekle’, ’sil’, ’sözlük’] 38.4. KendiTanımladığımızModüller 735 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, biz sil()fonksiyonunu çıkarmış olduğumuz halde,dir(sözlük)çıktısında buöğegörünmeyedevamediyor.Üstelikbufonksiyonhalenkullanılabilirdurumda! >>> sözlük.sil(’programlama’) programlama kelimesi sözlükten silindi! Ancak bu durumu rahatlıkla görmezden gelebilirsiniz. Ama eğer o öğenin orada olması sizi rahatsızediyorsa,şukomutlaoöğeyisilebilirsiniz: >>> del sözlük.sil Dediğimiz gibi, modülden silinen öğeler, reload() ile yeniden yüklendikten sonra dahi kullanılır durumda kalmaya devam eder. Ama eğer modül içinde varolan bir öğe üzerinde değişiklikyaparsanızodeğişiklik,reload()sonrasımodülüngörünümüneyansıyacaktır.Yani mesela,modüldehalihazırdavarolansil()fonksiyonuüzerindebirdeğişiklikyaparsanız,bu değişiklikreload()ileyenidenyüklemesonrasındaetkileşimlikabuğayansıyacaktır. 38.5 Üçüncü Şahıs Modülleri Buraya kadar Python’daki kütüphane modüllerinden ve kendi yazdığımız modüllerden söz ettik. Artık modüllerin ne olduğunu ve ne işe yaradığını gayet iyi biliyoruz. Bu bölümde ise, yinebir‘hazırmodül’türüolanüçüncüşahısmodüllerindenbahsedeceğiz. Üçüncüşahısmodülleri,başkaPythonprogramcılarıtarafındanyazılıphizmetimizesunulmuş programlardır. Bu yönüyle bunlar kütüphane modüllerine çok benzer. Ama bu ikisi arasında önemli bir fark bulunur: Kütüphane modülleri Python programlama dilinin bir parçasıdır. Dolayısıyla kütüphane modüllerini kullanmak için herhangi bir ek yazılım indirmemiz gerekmez. Üçüncü şahıs modülleri ise dilin bir parçası değildir. Bu modülleri kullanabilmek için, öncelikle bunları modül geliştiricisinin koyduğu yerden bilgisayarımıza indirmemiz gerekir. Hatırlarsanız ilk derslerimizde Cx_Freeze adlı bir yazılımdan söz etmiştik. İşte bu yazılım bir üçüncüşahısmodülüdür.Bumodülükullanabilmekiçinöncelikleilgiliyazılımıprogramımıza kurmamızgerekmişti. Python için yazılmış üçüncü şahıs modüllerine çeşitli kaynaklardan ulaşabilirsiniz. Bu tür modülleri bulabileceğiniz en geniş kaynak https://pypi.org/ adresidir. Burada 60.000’in üzerindemodüleulaşabilirsiniz. Pekibumodüllerinasılkuracağız? Eğer birmodül https://pypi.org/adresinde ise, bumodülü sistemkomut satırında şuşekilde kurabilirsiniz: pip3 install modül_adı (cid:242) Not Python’ın 2.7.9 ve 3.4.0 sürümlerinden itibaren, pip adlı yazılım öntanımlı olarak Python kurulumuyla birlikte geliyor. Dolayısıyla Python2’deki pip’i kullanmak isterseniz pip2 komutunu,Python3’tekipip’ikullanmakistersenizdepip3komutunukullanabilirsiniz. 736 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Örneğin amacınız Django adlı üçüncü şahıs modülünü kurmak ise bu modülü şu komut ile kurabilirsiniz: pip3 install django Eğer bir üçüncü şahıs modülünü https://pypi.org/ adresinden değil de başka bir kaynaktan indiriyorsanız,kurulumiçinbirkaçfarklıseçenekolabilir. Eğer indireceğiniz dosya Windows işletim sistemine uyumlu bir .exe dosyasıysa, bunu herhangibirWindowsprogramıgibikurabilirsiniz. Eğerindireceğinizdosya.tar.gzveya.zipgibisıkıştırılmışbirklasörolarakiniyorsaönceliklebu sıkıştırılmışklasörüaçın.Eğerklasöriçeriğindesetup.pyadlıbirdosyagörürsenizbudosyanın bulunduğukonumdabirkomutsatırıaçınveşukomutuverin: python setup.py install Tabii burada python komutunun python3 mü, py -3 mü yoksa başka bir şey mi olacağı tamamen sizin Python kurulumunu nasıl yaptığınıza bağlıdır. Neticede siz oraya, Python’ı hangi komutla başlatıyorsanız onu yazacaksınız. Yani eğer Python’ı python3 komutuyla başlatıyorsanızyukarıdakikomutuşöylevereceksiniz: python3 setup.py install Aynı şekilde, GNU/Linux kullanıcılarının da bu komutu yetkili kullanıcı olarak vermesi gerekecektirmuhtemelen: sudo python3 setup.py install Veyaönce: su - Ardından: python3 setup.py install İndirip kurduğunuz bir üçüncü şahıs modülünü nasıl kullanacağınızı, indirdiğiniz modülün belgelerinebakaraköğrenebilirsiniz. (cid:242) Not Paketler konusunu işlerken üçüncü şahıs modüllerinden daha ayrıntılı bir şekilde söz edeceğiz. 38.5. ÜçüncüŞahısModülleri 737 PythonBelgeleri,Yayım4.1.3 38.6 __all__ Listesi Önceki başlıklar altında da ifade ettiğimiz gibi, farklı içe aktarma yöntemlerini kullanarak, bir modül içindeki öğeleri farklı şekillerde içe aktarabiliyoruz. Gelin isterseniz Python’ın içe aktarmamekanizmasınıanlayabilmekiçinufakbirtestyapalım. Şimdimasaüstünde,içeriğiaşağıdakigibiolan,modül.pyadlıbirdosyaoluşturun: def fonk1(): print(’fonk1’) def fonk2(): print(’fonk2’) def fonk3(): print(’fonk3’) def fonk4(): print(’fonk4’) def fonk5(): print(’fonk5’) def _fonk6(): print(’_fonk6’) def __fonk7(): print(’__fonk7’) def fonk8_(): print(’fonk8_’) Daha sonra, masaüstünün bulunduğu konumda bir komut penceresi açarak Python’ın etkileşimlikabuğunuçalıştırınveoradaşukomutuveripbumodül.pyadlıdosyayıbirmodül olarakiçeaktarın: >>> import modül Şimdideşukomutukullanarakmodüliçeriğinikontroledin: >>> dir(modül) Buradanşuçıktıyıalıyoruz: [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__fonk7’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’_fonk6’, ’fonk1’, ’fonk2’, ’fonk3’, ’fonk4’, ’fonk5’, ’fonk8_’] Gördüğünüz gibi, modül içinde tanımladığımız bütün fonksiyonlar bu listede var. Dolayısıyla bufonksiyonlaraşuşekildeerişebiliyoruz: 738 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 >>> modül.fonk1() fonk1 >>> modül.fonk2() fonk2 >>> modül._fonk6() _fonk6 >>> modül.__fonk7() __fonk7 >>> modül.fonk8_() fonk8_ Bu şekilde, istisnasız bütün fonksiyonlara erişim yetkisi elde ettiğimize dikkatinizi çekmek isterim. Şimdietkileşimlikabuğukapatıptekraraçalımvebukezmodülümüzüşuşekildeiçeaktaralım: >>> from modül import * Buşekilde,ismi_ilebaşlayanlarhariçbütünfonksiyonları,modülönekiolmadanmevcutetki alanınaaktardığımızıbiliyoruz. Kontroledelim: >>> dir() Buradanşuçıktıyıalıyoruz: [’__builtins__’, ’__doc__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’fonk1’, ’fonk2’, ’fonk3’, ’fonk4’, ’fonk5’, ’fonk8_’] Gördüğünüz gibi, gerçekten de ismi _ ile başlayanlar hariç, bütün fonksiyonlar, modül öneki olmadan kullanılmaya hazır bir şekilde mevcut etki alanımız içinde görünüyor. Bunları şu şekildekullanabileceğimizibiliyorsunuz: >>> fonk4() fonk4 >>> fonk8_() fonk8_ 38.6. __all__Listesi 739 PythonBelgeleri,Yayım4.1.3 Elbette,ismi_ilebaşlayanfonksiyonları,doğrudanisimlerinikullanarakiçeaktarmaimkanına sahipsiniz: >>> from modül import __fonk7 >>> from modül import _fonk6 Tabii,bufonksiyonlarıiçeaktarabilmekiçinbunlarınisimlerinibiliyorolmanızlazım... Peki siz, yazdığınız bir programda yalnızca kendi belirlediğiniz isimlerin içe aktarılmasını istersenizneyapacaksınız?İştebununiçin,başlıktasözünüettiğimiz__all__adlıbirlisteden yararlanabilirsiniz. Şimdibirazönceoluşturduğunuzmodül.pydosyasınınenbaşınaşusatırıekleyin: __all__ = [’fonk1’, ’fonk2’, ’fonk3’] Dahasonraetkileşimlikabuktamodülünüzüşuşekildeiçeaktarın: >>> from modül import * Şimdideiçeaktarılanfonksiyonlarınnelerolduğunukontroledin: >>> dir() [’__builtins__’, ’__doc__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’fonk1’, ’fonk2’, ’fonk3’] Gördüğünüz gibi, yalnızca __all__ listesi içinde belirttiğimiz fonksiyonlar içe aktarıldı. Bu listeyi kullanarak, yıldızlı içe aktarmalarda nelerin içe aktarılıp nelerin dışarıda bırakılacağını kontrol edebilirsiniz. Yalnız unutmamanız gereken nokta, bu yöntemin öteki içe aktarma türlerinde hiçbir işe yaramayacağıdır. Yani mesela modül adlı modülümüzü import modül şeklindeiçeaktarırsak__all__listesidikkatealınmayacaktır. Pekiya__all__listesiniboşbırakırsakneolur? __all__ = [] Tabiiki,buşekildeyıldızlıaktarmalarda(modülünkendivarsayılanfonksiyonlarıhariç)hiçbir fonksiyoniçeaktarılmaz... 38.7 Modüllerin Özel Nitelikleri Python’da bütün modüllerin ortak olarak sahip olduğu bazı nitelikler vardır. Bu niteliklerin hangileriolduğunugörmekiçinkesişimkümelerindenyararlanarakşöylebirkodyazabiliriz: import os, sys, random set_os = set(dir(os)) set_sys = set(dir(sys)) set_random = set(dir(random)) print(set_os & set_sys & set_random) 740 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Bukodlar,os,sysverandommodüllerininkesişimkümesini,yaniherüçmodüldeortakolarak bulunannitelikleriverecektir.Bukodlarıçalıştırdığımızdaşuçıktıyıalıyoruz: {’__doc__’, ’__package__’, ’__loader__’, ’__name__’, ’__spec__’} Demek ki hem os hem sys hem de random modülünde ortak olarak bulunan nitelikler bunlarmış... Eğer bu üç modülün bütün modülleri temsil etmiyor olabileceğinden endişe ediyorsanız, bildiğiniz başka modülleri de bu kodlara ekleyerek testinizin kapsamını genişletebilirsiniz. Meselabukodlarabirdesubprocessmodülünüekleyelim: import os, sys, random, subprocess set_os = set(dir(os)) set_sys = set(dir(sys)) set_random = set(dir(random)) set_subprocess = set(dir(subprocess)) print(set_os & set_sys & set_random & set_subprocess) Yalnız burada şöyle bir şey dikkatinizi çekmiş olmalı: Kesişim kümesini bulmak istediğimiz öğelere başka öğeler de eklemek istediğimizde her defasında birkaç farklı işlem yapmak zorundakalıyoruz.Budahemkodlarımızıhatalaraaçıkhalegetiriyor,hemdeaslındakolayca halledebileceğimizbirişigereksizyereuzatmamızayolaçıyor. Gelinbukodlarıbirazdahagenelamaçlıbirhalegetirelim.Zira‘kodlarınyenidenkullanılabilir özellikteolması’(codereusability)programcılıktaarananbirniteliktir: modüller = [’os’, ’sys’, ’random’] def kesişim_bul(modüller): kümeler = [set(dir(__import__(modül))) for modül in modüller] return set.intersection(*kümeler) print(kesişim_bul(modüller)) Eğer bu kodlara yeni bir modül eklemek istersek, yapmamız gereken tek şey en baştaki modüller listesini güncellemek olacaktır. Mesela bu listeye bir de subprocess modülünü ekleyelim: modüller = [’os’, ’sys’, ’random’, ’subprocess’] def kesişim_bul(modüller): kümeler = [set(dir(__import__(modül))) for modül in modüller] return set.intersection(*kümeler) print(kesişim_bul(modüller)) Gördüğünüzgibi,bukodlarişimiziepeykolaylaştırdı.Sadecetekbirnoktadadeğişiklikyaparak istediğimizsonucueldeettik. Bu arada, __import__ fonksiyonu hariç, bu kodlardaki her şeyi daha önceki derslerimizde öğrenmiştik.Amagelinistersenizbizyinedebukodlarınüzerindenşöylebirgeçelim. 38.7. ModüllerinÖzelNitelikleri 741 PythonBelgeleri,Yayım4.1.3 Buradailkyaptığımıziş,kullanmakistediğimizmodüladlarınıtutmasıiçinbirlistetanımlamak: modüller = [’os’, ’sys’, ’random’, ’subprocess’] Bu listede modül adlarının birer karakter dizisi olarak gösterildiğine dikkat edin. Zaten bu modüllerihenüziçeaktarmadığımıziçin,bunlarıdoğrudantırnaksızisimleriylekullanamayız. Dahasonra,asılişiyapacakolankesişim_bul()adlıfonksiyonumuzutanımlıyoruz: def kesişim_bul(modüller): kümeler = [set(dir(__import__(modül))) for modül in modüller] return set.intersection(*kümeler) Bufonksiyon,modülleradlıtekbirparametrealıyor. Fonksiyonumuzungövdesindeilkolarakşöylebirkodyazıyoruz: kümeler = [set(dir(__import__(modül))) for modül in modüller] Burada modüller adlı listedeki her öğe üzerine sırasıyla __import__ fonksiyonunu, dir() fonksiyonunuveset()fonksiyonunuuyguluyoruz.Dahasonraeldeettiğimizsonucubirliste üreteciyardımıylalistehalinegetiripkümelerdeğişkenineatıyoruz. Gelelim__import__fonksiyonununneolduğuna... Bir gömülü fonksiyon olan __import__ fonksiyonu, modül adlarını içeren karakter dizilerini kullanarak,herhangibirmodülüiçeaktarmamızısağlayanbiraraçtır.Bufonksiyonunuşöyle kullanıyoruz: >>> __import__(’os’) >>> __import__(’sys’) Bu fonksiyonun parametre olarak bir karakter dizisi alıyor olmasının bize nasıl bir esneklik sağladığına dikkatinizi çekmek isterim. Bu fonksiyon sayesinde modül aktarma işlemini, kod parçalarıiçineprogramatikolarakyerleştirebilmeimkanıeldeediyoruz.Yani,modülaktarma işleminimeselabirfordöngüsüiçinealamıyorken: >>> modüller = [’os’, ’sys’, ’random’] >>> for modül in modüller: ... import modül ... Traceback (most recent call last): File "<stdin>", line 2, in <module> ImportError: No module named ’modül’ __import__fonksiyonubizeböylebirişlemyapabilmeolanağısunuyor: >>> modüller = [’os’, ’sys’, ’random’] >>> for modül in modüller: ... __import__(modül) <module ’os’ from ’C:\\Python34\\lib\\os.py’> <module ’sys’ (built-in)> <module ’random’ from ’C:\\Python34\\lib\\random.py’> 742 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Yalnız, __import__(’os’) gibi bir komut verdiğimizde, ‘os’ ismi doğrudan kullanılabilir hale gelmiyor.Yani: >>> __import__(’os’) ...komutunuverdiğimizde,meselaosmodülününbirniteliğiolanname’ikullanamıyoruz: >>> os.name Traceback (most recent call last): File "<stdin>", line 1, in <module> NameError: name ’os’ is not defined ‘os’isminikullanabilmemiziçinşöylebirşeyyazmışolmalıydık: >>> os = __import__(’os’) Eğer __import__ fonksiyonu yardımıyla içe aktardığımız os modülünü bu şekilde bir isme atamazsak, __import__(’os’) komutu ile içe aktarılan bütün os fonksiyon ve nitelikleri, bu komut bir kez çalıştıktan sonra unutulacaktır. Eğer __import__ fonksiyonunu bir isme atamadan,içeaktarılanmodülünniteliklerineerişmekisterseniziçeaktarmaişlemiileniteliğe erişmeişleminiaynısatırdagerçekleştirmenizgerekir: >>> __import__(’os’).name ’nt’ __import__ fonksiyonu çok sık kullanacağınız bir araç değildir. Ancak özellikle tek satırda hem bir modülü içe aktarmanız, hem de hemen ardından başka işlemler yapmanız gereken durumlardabufonksiyonişinizeyarayabilir: >>> open(’den.txt’, ’w’).write(’merhaba’); __import__(’subprocess’).call( ’notepad.exe den.txt’) ˓→ Gerekli modülleri içe aktardıktan ve kümemimizi tanımladıktan sonra da fonksiyon tanımını şukodlabitiriyoruz: return set.intersection(*kümeler) Burada kümelerin intersection() metodundan faydalandık. Bu metodu önceki derslerimizdeelealmıştık.Bumetotyardımıylabirdenfazlakümeninkesişiminibulabiliyoruz. Bufonksiyonunormaldeşöylekullanıyorduk: >>> küme1.intersection(küme2) Bu komut, küme1 ile küme2 adlı kümelerin kesişimini bulacaktır. Eğer bizim kodlarımızda olduğu gibi küme ismi belirtmeksizin birden fazla kümenin kesişimini bulmak isterseniz bu metodudoğrudankümeveritipi(set)üzerineuygulayabilirsiniz: >>> set.intersection(küme1, küme2) Eğer intersection() metoduna parametreleri bir liste içinden atamak isterseniz bu listeyi yıldızişleciyardımıylaçözmenizgerekir: 38.7. ModüllerinÖzelNitelikleri 743 PythonBelgeleri,Yayım4.1.3 >>> liste = [küme1, küme2, küme3] >>> set.intersection(*liste) İşte bizim yukarıda return set.intersection(*kümeler) komutuyla yaptığımız şey de tam olarakbudur.Buradaintersection()metodunudoğrudansetveritipiüzerineuyguladıkve bumetodunparametrelerinikümeleradlılistedenyıldızişleciyardımıylaçözdük. Son olarak da, tanımladığımız kesişim_bul() fonksiyonunu modüller adlı parametre ile çağırdık: print(kesişim_bul(modüller)) Bütünbukodlarıçalıştırdıktansonraiseşöylebirçıktıeldeettik: {’__doc__’, ’__name__’, ’__loader__’, ’__spec__’, ’__package__’} İşte bu bölümün konusu, bütün modüllerde ortak olan bu beş özel nitelik. İlk olarak __doc__niteliğiilebaşlayalım. 38.7.1 __doc__ Niteliği İsterseniz__doc__niteliğinitarifetmeyeçalışmakyerine,bunubirörneküzerindenanlatalım. ŞimdiPythonkurulumdiziniiçindeos.pydosyasınınbulunduğukonumagidelimvebudosyayı açalım.Dosyayıaçtığınızda,sayfanınenbaşındaşukarakterdizisinigöreceksiniz: ’ r"""OS routines for NT or Posix depending on what system we re on. This exports: - all functions from posix, nt or ce, e.g. unlink, stat, etc. - os.path is either posixpath or ntpath ’ ’ ’ ’ ’ ’ - os.name is either posix , nt or ce . ’ ’ ’ ’ - os.curdir is a string representing the current directory ( . or : ) ’ ’ ’ ’ - os.pardir is a string representing the parent directory ( .. or :: ) ’ ’ ’ ’ ’ ’ - os.sep is the (or a most common) pathname separator ( / or : or \\ ) ’ ’ - os.extsep is the extension separator (always . ) ’ ’ - os.altsep is the alternate pathname separator (None or / ) - os.pathsep is the component separator used in $PATH etc ’ ’ ’ ’ ’ ’ - os.linesep is the line separator in text files ( \r or \n or \r\n ) - os.defpath is the default search path for executables ’ ’ - os.devnull is the file path of the null device ( /dev/null , etc.) ’ ’ Programs that import and use os stand a better chance of being portable between different platforms. Of course, they must then only use functions that are defined by all platforms (e.g., unlink and opendir), and leave all pathname manipulation to os.path (e.g., split and join). """ ŞimdiPython’ınetkileşimlikabuğunuaçınveşukomutlarıverin: 744 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 >>> import os >>> print(os.__doc__) Bu komutları verdiğinizde, yukarıdaki karakter dizisinin çıktı olarak verildiğini göreceksiniz. Teknik dilde, üç tırnak içinde gösterilen karakter dizilerine belge dizisi (docstring) veya belgelendirme dizisi (documentation string) adı verilir. Modüllerin __doc__ niteliğini kullanarak,birmodüldosyasınınenbaşındabulunanbelgelendirmedizilerineerişebiliriz. Birörnekdahaverelim.Meselarandommodülünebakalım: >>> import random >>> print(random.__doc__) os.py dosyası ile aynı konumda bulunan random.py dosyasını açtığınızda, yukarıdaki komutlardan aldığınız çıktının random.py dosyasının en başındaki uzun karakter dizisi olduğunugöreceksiniz. Çeşitli yazılımlar, bu belge dizilerini kullanarak, ilgili modüle ilişkin kısa kılavuzlar oluşturur. MeselaPython’ınhelp()fonksiyonububelgedizilerindenyararlanır: >>> help(os) Siz de kendi yazdığınız modüllerde bu belge dizilerinden yararlanabilirsiniz. Ancak aklınızda bulundurmanız gereken önemli nokta, bu belge dizilerini üç tırnak içinde belirtmeniz gerektiğidir. Alt alta çift veya tek tırnak ile tanımladığınız karakter dizilerine __doc__ niteliği aracılığıylaerişmeyeçalıştığınızdasadeceilksatırdakikarakterdizisineulaşırsınız.Yani: "satır1" "satır2" "satır3" ...şeklinde tanımladığınız karakter dizileri __doc__ niteliği ile çağrıldığında yalnızca “satır1” görüntülenecektir. Eğer bu üç satırın da kapsama alanına girmesini istiyorsak yukarıdaki karakterdizilerinişöyletanımlamalıyız: ’’’ satır1 satır2 satır3 ’’’ 38.7.2 __name__ Niteliği Şöylebirprogramyazdığımızıvarsayalım: sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" (sonrakisayfayadevam) 38.7. ModüllerinÖzelNitelikleri 745 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(sözlük.get(sözcük, hata.format(sözcük))) def ekle(sözcük, anlam): mesaj = "{} kelimesi sözlüğe eklendi!" sözlük[sözcük] = anlam print(mesaj.format(sözcük)) def sil(sözcük): try: sözlük.pop(sözcük) except KeyError as err: print(err, "kelimesi bulunamadı!") else: print("{} kelimesi sözlükten silindi!".format(sözcük)) print(’1. Sözlükte kelime ara’) print(’2. Sözlüğe kelime ekle’) print(’3. Sözlükten kelime sil’) no = input(’Yapmak istediğiniz işlemin numarasını girin: ’) if no == ’1’: sözcük = input(’Aradığınız sözcük: ’) ara(sözcük) elif no == ’2’: sözcük = input(’Ekleyeceğiniz sözcük: ’) anlam = input(’Eklediğiniz sözcüğün anlamı: ’) ekle(sözcük, anlam) elif no == ’3’: sözcük = input(’Sileceğiniz sözcük: ’) sil(sözcük) else: print(’Yanlış işlem’) sözlük.pyadınıverdiğimizbuprogramınormalbirşekildekomutsatırında python sözlük.py gibibirkomutlaçalıştırdığımızdabizebirtakımsorularsorulacakveverdiğimizcevaplaragöre sözlüküzerindebazıişlemleryapılacaktır. Hatırlarsanız, modüller konusunu anlatmaya başlarken, yazdığımız bütün programların aslındabirermodülolduğunu,dolayısıylabunlarınbaşkaprogramlarıniçineaktarılarak,sahip olduklarıişlevlerdenbaşkaprogramlardadayararlananılabileceğinisöylemiştik. Yukarıdaki kodları, komut satırı üzerinde bağımsız bir program gibi çalıştırabiliyoruz. Peki acababizbuprogramıdoğrudançalıştırmakdeğildebaşkabirprogramıniçineaktarıpsahip olduğuişlevlerdenyararlanmakistersekneyapacağız? İştebununiçin__name__adlıbirniteliktenyararlanacağız. 746 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Python’dakiherhangibirmodülüiçeaktardıktansonrabumodülüzerinedir()fonksiyonunu uygularsanız,istisnasızhermodülün__name__adlıbirniteliğiolduğunugörürsünüz. __name__niteliğiikifarklıdeğeralabilir:İçindebulunduğumodülünadıveya"__main__"adlı özelbirdeğer. Eğer bir Python programı başka bir program içinden modül olarak içe aktarılıyorsa, __name__niteliğinindeğeriomodülünadıolacaktır. Eğer bir Python programı doğrudan bağımsız bir program olarak çalıştırılıyorsa, __name__niteliğinindeğeribudefa"__main__"olacaktır. Gelin isterseniz bu durumu bir örnek üzerinde somutlaştıralım. Mesela masaüstünde deneme.pyadlıbirdosyaoluşturupiçinesadeceşunuyazalım: print(__name__) Şimdiöncebudosyayıbağımsızbirprogramolarakçalıştıralım: python deneme.py Programımızıbuşekildeçalıştırdığımızdaalacağımızçıktışuolacaktır: __main__ Demekki__name__niteliğinindeğeri"__main__"imiş... Şimdi de deneme.py dosyasının bulunduğu konumda Python’ın etkileşimli kabuğunu çalıştıralımveşukomutyardımıylabudosyayıbirmodülolarakiçeaktaralım: >>> import deneme Budefaşuçıktıyıaldık: deneme Gördüğünüzgibi,__name__niteliğinindeğeribukezdemodüldosyasınınadıoldu. İşte bu özellikten yararlanarak, yazdığınız programların bağımsız çalıştırılırken ayrı, modül olarakiçeaktarılırkenayrıdavranmasınısağlayabilirsiniz. Gelinbubilgiyiyukarıdakisözlük.pydosyasınauygulayalım. Buprogramıkomutsatırıüzerindebağımsızbirprogramolarakçalıştırdığınızdaneolacağını biliyorsunuz.Pekiyaaynıprogramıbirmodülolarakiçeaktarırsakneolur? Deneyelim: >>> import sözlük Yapmak istediğiniz işlemin numarasını girin: Gördüğünüz gibi, programımız doğrudan çalışmaya başladı. Ama biz bunu istemiyoruz. Biz istiyoruz ki, sözlük.py bir modül olarak aktarıldığında çalışmaya başlamasın. Ama biz onun içindekiniteliklerikullanabilelim. Bununiçinsözlük.pydosyasındaşudeğişikliğiyapacağız: 38.7. ModüllerinÖzelNitelikleri 747 PythonBelgeleri,Yayım4.1.3 sözlük = {"kitap" : "book", "bilgisayar" : "computer", "programlama": "programming"} def ara(sözcük): hata = "{} kelimesi sözlükte yok!" print(sözlük.get(sözcük, hata.format(sözcük))) def ekle(sözcük, anlam): mesaj = "{} kelimesi sözlüğe eklendi!" sözlük[sözcük] = anlam print(mesaj.format(sözcük)) def sil(sözcük): try: sözlük.pop(sözcük) except KeyError as err: print(err, "kelimesi bulunamadı!") else: print("{} kelimesi sözlükten silindi!".format(sözcük)) #BURAYA DİKKAT!!! if __name__ == ’__main__’: no = input(’Yapmak istediğiniz işlemin numarasını girin: ’) print(’1. Sözlükte kelime ara’) print(’2. Sözlüğe kelime ekle’) print(’3. Sözlükten kelime sil’) if no == ’1’: sözcük = input(’Aradığınız sözcük: ’) ara(sözcük) elif no == ’2’: sözcük = input(’Ekleyeceğiniz sözcük: ’) anlam = input(’Eklediğiniz sözcüğün anlamı: ’) ekle(sözcük, anlam) elif no == ’3’: sözcük = input(’Sileceğiniz sözcük: ’) sil(sözcük) else: print(’Yanlış işlem’) Gördüğünüzgibi,çokbasitbirifdeyimiyardımıyladosyamızınbağımsızbirprogramolarakmı çalıştırıldığınıyoksabirmodülolarakiçemiaktarıldığınıkontrolettik.Eğer__name__niteliğinin değeri‘__main__’ise,yaniprogramımızbağımsızolarakçalıştırılıyorsaifbloğuiçindekikodları işletiyoruz. Eğer bu niteliğin değeri başka bir şey ise (yani modülün adı ise), bu durumda programımız bir modül olarak içe aktarılıyor demektir. Bu durumda if bloğu içindeki kodları çalıştırmıyoruz... 748 Bölüm38. Modüller PythonBelgeleri,Yayım4.1.3 Herşeyinyolundaolupolmadığınıkontroletmekiçinsözlükmodülünüiçeaktaralım: >>> import sözlük Bukez,tamdaistediğimizşekilde,programımızdoğrudançalışmayabaşlamadanbizeiçindeki fonksiyonlarıkullanmaimkanısundu: >>> dir(sözlük) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’ara’, ’ekle’, ’sil’, ’sözlük’] 38.7.3 __loader__ Niteliği Python’da içe aktarılan bütün modüllerin __loader__ adlı bir niteliği bulunur. Bu nitelik, ilgili modülüiçeaktaranmekanizmahakkındabizeçeşitlibilgilerverenbirtakımaraçlarsunar: >>> import os >>> yükleyici = os.__loader__ >>> dir(yükleyici) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’, ’_cache_bytecode’, ’exec_module’, ’get_code’, ’get_data’, ’get_filename’, ’get_source’, ’is_package’, ’load_module’, ’name’, ’path’, ’path_mtime’, ’path_stats’, ’set_data’, ’source_to_code’] Mesela, içe aktardığınız bir modülün kaynak kodlarını görüntülemek için bu modülden yararlanabilirsiniz: >>> import webbrowser >>> yükleyici = webbrowser.__loader__ >>> kaynak = yükleyici.get_data(webbrowser.__file__) >>> kaynak Burada, daha önce öğrendiğimiz __file__ niteliğini kullandığımıza dikkat edin. __loader__ niteliğinin get_data() adlı metodu, parametre olarak, sorgulayacağımız modülün dizinadresiniister.Birmodülündizinadresini__file__niteliğiyardımıylaeldeedebileceğimizi biliyoruz.Dolayısıyladaget_data()metodunaparametreolarakwebbrowser.__file__kodunu veriyoruz. Elde ettiğimiz şey ise, sorguladığımız modülün kaynak kodlarını içeren bir bayt (bytes)veritipioluyor. __loader__, günlük olarak kullanacağımız bir araç değil. Eğer yazdığınız kodlarda bu niteliğin sunduğu olanaklara ihtiyaç duyarsanız, doğrudan bu nitelik yerine pkgutil adlı bir modülü kullanabilirsiniz. 38.7. ModüllerinÖzelNitelikleri 749 PythonBelgeleri,Yayım4.1.3 38.7.4 __spec__ Niteliği __spec__ niteliği de bize modüller hakkında çeşitli bilgiler sunan birtakım araçları içinde barındırır.Meselabirmodülünadvekonumbilgilerineulaşmakiçinbuniteliğikullanabiliriz: >>> import subprocess >>> adı = subprocess.__spec__.name >>> konumu = subprocess.__spec__.origin >>> adı ’subprocess’ >>> konumu ’C:\\Pythonxy\\lib\\subprocess.py’ Tıpkı __loader__ gibi, bu nitelik de günlük olarak kullanacağımız bir araç değil. Bu niteliğin içindekiaraçlarınsunduğubilgileribaşkayollardandaeldeedebileceğimizibiliyorsunuz. 38.7.5 __package__ Niteliği Henüz bu niteliğin ne olduğunu anlayacak bilgiye sahip olmadığımız için, bu niteliğin incelemesini‘Paketler’konusunuişlediğimizbölümebırakıyoruz. Böylece modüller konusunu tamamlamış olduk. Bu bölümde modüllere ilişkin epey bilgi verdik. Eğer modüller konusunda aklınıza yatmayan yerler varsa, hiç ümitsizliğe kapılmadan okumayadevamedin.Birazdan‘sınıflar’konusunuişlerken,modüllerdenvemodüllerinçeşitli özelliklerindendesözedeceğiz.Ozaman,buradaanlamamışolabileceğinizkonularıçokdaha netbirşekildeanlayacaksınız. 750 Bölüm38. Modüller 39 BÖLÜM Nesne Tabanlı Programlama (OOP) Bu bölümde, programlama faaliyetlerimizin önemli bir kısmını oluşturacak olan nesne tabanlı programlama yaklaşımına bir giriş yaparak, bu yaklaşımın temel kavramlarından biri olan sınıflara değineceğiz. Bu bölümde amacımız, sınıflar üzerinden hem nesne tabanlı programlamayıtanımak,hembuyaklaşımailişkintemelbilgileriedinmek,hemdeetrafımızda gördüğümüz nesne tabanlı yapıların büyük çoğunluğunu anlayabilecek seviyeye gelmek olacaktır. Bu bölümü tamamladıktan sonra, nesne tabanlı programlamayı orta düzeyde bildiğimiziiddiaedebileceğiz. 39.1 Giriş ŞimdiyekadarPythonprogramlamadiliileilgiliolarakgördüğümüzkonulardanöğrendiğimiz çok önemli bir bilgi var: Aslına bakarsak, bu programlama dilinin bütün felsefesi, ‘bir kez yazılankodlarınenverimlişekildetekrartekrarkullanılabilmesi,’fikrinedayanıyor. Şimdi bir geriye dönüp baktığımızda, esasında bu fikrin izlerini ta ilk derslerimize kadar sürebiliyoruz.Meseladeğişkenlerielealalım.Değişkenlerikullanmamızdakitemelgerekçe,bir kezyazdığımızbirkodubaşkayerlerderahatçakullanabilmek.Örneğin,isim = ’Uzun İhsan Efendi’gibibirtanımlamayaptıktansonra,buisimdeğişkeniaracılığıyla‘UzunİhsanEfendi’ adlıkarakterdizisiniherdefasındatekrartekraryazmakzorundakalmadan,kodlarımızınher yanındakullanabiliyoruz. Aynı fikrin fonksiyonlar ve geçen bölümde incelediğimiz modüller için de geçerli olduğunu bariz bir şekilde görebilirsiniz. Gömülü fonksiyonlar, kendi tanımladığımız fonksiyonlar, hazır modüller, üçüncü şahıs modülleri hep belli bir karmaşık süreci basitleştirme, bir kez tanımlananbirprosedürüntekrartekrarkullanılabilmesinisağlamaamacıgüdüyor. İştebufikirnesnetabanlıprogramlamavedolayısıyla‘sınıf’(class)adıverilenözelbirveritipi içindegeçerlidir.Bubölümde,bununnedenvenasılböyleolduğunubütünayrıntılarıylaele almayaçalışacağız. Bu arada, İngilizcede Object Oriented Programming olarak ifade edilen programlama yaklaşımı, Türkçede ‘Nesne Tabanlı Programlama’, ‘Nesne Yönelimli Programlama’ ya da 751 PythonBelgeleri,Yayım4.1.3 ‘NesneyeYönelikProgramlama’olarakkarşılıkbulur.Bizbukarşılıklardan,adı‘NesneTabanlı Programlama’olanıtercihedeceğiz. Unutmadan, nesne tabanlı programlamaya girmeden önce değinmemiz gereken bir şey daha var. Eğer öğrendiğiniz ilk programlama dili Python ise, nesne tabanlı programlamayı öğrenmenin(aslındaöyleolmadığıhalde)zorolduğunudüşünebilir,bukonuyubirazkarmaşık bulabilirsiniz. Bu durumda da kaçınılmaz olarak kendi kendinize şu soruyu sorarsınız: Acaba bennesnetabanlıprogramlamayıöğrenmekzorundamıyım? Busorununkısacevabı,eğeriyibirprogramcıolmakistiyorsanıznesnetabanlıprogramlamayı öğrenmekzorundasınız,olacaktır. Uzuncevapiseşu: Nesne tabanlı programlama, pek çok yazılım geliştirme yönteminden yalnızca biridir. Siz bu yöntemi, yazdığınız programlarda kullanmak zorunda değilsiniz. Nesne tabanlı programlamadan hiç yararlanmadan da faydalı ve iyi programlar yazabilirsiniz elbette. Python sizi bu yöntemi kullanmaya asla zorlamaz. Ancak nesne tabanlı programlama yaklaşımı program geliştirme alanında oldukça yaygın kullanılan bir yöntemdir. Dolayısıyla, etrafta nesne tabanlı programlama yaklaşımından yararlanılarak yazılmış pek çok kodla karşılaşacaksınız. Hiç değilse karşılaştığınız bu kodları anlayabilmek için nesne tabanlı programlamayı biliyor ve tanıyor olmanız lazım. Aksi halde, bu yöntem kullanılarak geliştirilmişprogramlarıanlayamazsınız. Mesela, grafik bir arayüze sahip (yani düğmeli, menülü) programların ezici çoğunluğu nesne tabanlıprogramlamayöntemiylegeliştiriliyor.Grafikarayüzgeliştirmenizisağlayacakaraçları tanımanızı, öğrenmenizi sağlayan kitaplar ve makaleler de bu konuları hep nesne tabanlı programlamayaklaşımıüzerindenanlatıyor. . Uyarı Yalnızbusöylediğimizden,nesnetabanlıprogramlamasadecegrafikarayüzlüprogramlar geliştirmeye yarar gibi bir anlam çıkarmamalısınız. Nesne tabanlı programlama, komut arayüzlüprogramlargeliştirmekiçindekullanışlıbirprogramlamayöntemidir. Sözünözü,nesnetabanlıprogramlamadankaçamazsınız!İyibirprogramcıolmakistiyorsanız, kendiniz hiç kullanmasanız bile, nesne tabanlı programlamayı öğrenmek zorundasınız. Hem şimdi nesne tabanlı programlamaya dudak bükseniz bile, bunu kullandıkça ve size sağladığı faydalarıgördükçeonusizdeseveceksiniz... 39.2 Sınıflar Nesne tabanlı programlamanın temelinde, yukarıdaki giriş bölümünde de adını andığımız ‘sınıf’ (class) adlı bir kavram bulunur. Bu bölümde, bu temel kavramı hakkıyla ele almaya çalışacağız. Pekitamolaraknedirbusınıfdenenşey? Çok kaba ve oldukça soyut bir şekilde tanımlayacak olursak, sınıflar, nesne üretmemizi sağlayanveritipleridir.İştenesnetabanlıprogramlama,adındandaanlaşılacağıgibi,nesneler (vedolayısıylasınıflar)temelalınarakgerçekleştirilenbirprogramlamafaaliyetidir. 752 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 ‘Hiçbir şey anlamadım!’ dediğinizi duyar gibiyim. Çünkü yukarıdaki tanım, ‘nesne’ ne demek, ‘sınıf’ ne anlama geliyor gibi sorulara cevap vermiyor. Yani programcılık açısından ‘nesne’ ve ‘sınıf’ kelimelerini burada ne anlamda kullandığımızı, yukarıdaki tanıma bakarak kestiremiyoruz.Eğersizdebufikirdeysenizokumayadevamedin... 39.3 Sınıflar Ne İşe Yarar? Buraya gelene kadar Python’da pek çok veri tipi olduğunu öğrendik. Mesela önceki derslerimizdeincelediğimizlisteler,demetler,karakterdizileri,sözlüklervehattafonksiyonlar hepbirerveritipidir.Butiplerin,verileriçeşitlişekillerdeeviripçevirmemizisağlayanbirtakım araçlar olduğunu biliyoruz. İşte sınıflar da, tıpkı yukarıda saydığımız öteki veri tipleri gibi, verilerimanipüleetmemizisağlayanbirveritipidir. Pekibubölümdeelealacağımız‘sınıf’(class)veritipineişeyarar? Dilersenizbunubasitbirörneküzerindeanlatmayaçalışalım. Diyelimki,kullanıcınıngirdiğibirkelimedekisesliharflerisayanbirkodyazmakistiyorsunuz. Buamacıgerçekleştirebilmekiçinyazabileceğinizenbasitkodherhaldeşuolacaktır: sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) for harf in kelime: if harf in sesli_harfler: sayaç += 1 mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, sayaç)) Düzgün bir şekilde çalışan, gayet basit kodlardır bunlar. Ayrıca amacımızı da kusursuz bir şekilde yerine getirir. Üstelik kodlardaki bütün öğeler tek bir isim/etki alanı (namespace, scope) içinde bulunduğu için, bunlara erişimde hiçbir zorluk çekmeyiz. Yani mesela sesli_harfler,sayaç,kelime,harf,mesajdeğişkenlerinekodlariçindeheryerdenerişebiliriz. (cid:242) Not Eğer isim/etki alanı ile ilgili söylediğimiz şeyi anlamadıysanız endişe etmeyin. Birazdan vereceğimizörnekledurumudahanetkavrayacaksınız. Ancak bu kodların önemli bir dezavantajı, kodlarda benimsediğimiz yaklaşımın genişlemeye pekmüsaitolmamasıdır.Dahadoğrusu,yukarıdakikodlarayenikodlarekledikçeprogramımız karmaşıkhalegelecek,kodlarıanlamakzorlaşacaktır. Kod yapısını biraz olsun rahatlatmak için bazı önlemler alabiliriz. Mesela kullanıcı tarafından girilenkelimedekibirharfinsesliolupolmadığınıdenetleyenkodlarıbirfonksiyoniçinealarak, okısmıdahabelirginhalegetirebiliriz: 39.3. SınıflarNeİşeYarar? 753 PythonBelgeleri,Yayım4.1.3 sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler for harf in kelime: if seslidir(harf): sayaç += 1 mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, sayaç)) Burada, kontrol ettiğimiz harfin sesli_harfler adlı değişken içinde bulunup bulunmamasına göre True veya False çıktısı veren, seslidir() adlı bir fonksiyon tanımladık. Eğer kontrol ettiğimiz harf sesli_harfler değişkeni içinde geçiyorsa, yani bu bir sesli harf ise, seslidir() fonksiyonu True çıktısı verecektir. Aksi durumda ise bu fonksiyondan False çıktısı alacağız. Böylece sesli harf kontrolü yapmak istediğimiz her yerde yalnızca seslidir() fonksiyonunu kullanabileceğiz.Budabize,birkezyazdığımızkodlarıtekrartekrarkullanmaimkanıverecek. Eğeryukarıdakikodlarıdahadagenelamaçlıbirhalegetirmekistersek,sayacıartırankodları dabirfonksiyoniçinealmayıdüşünebiliriz: sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler def artır(): global sayaç for harf in kelime: if seslidir(harf): sayaç += 1 return sayaç mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, artır())) Hatırlarsanız, ilk başta yazdığımız kodların en büyük avantajının, kodlarda geçen bütün öğelerintekbirisim/etkialanındabulunmasıolduğunusöylemiştik.Busayedebütünöğelere heryerdenerişebiliyorduk.Yukarıdakikodlardaisebirdenfazlaisim/etkialanıvar: 1. sesli_harfler,sayaç,kelimevemesajdeğişkenlerininbulunduğuglobalisim/etkialanı. 2. seslidir()fonksiyonununlokalisim/etkialanı. 3. artır()fonksiyonununlokalisim/etkialanı. 754 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 Bildiğiniz gibi, global isim alanında bulunan değişkenlere her yerden ulaşabiliyoruz. Ancak bunları her yerden değiştiremiyoruz. Yani mesela global isim alanında bulunan sayaç değişkeninindeğerini,seslidir()fonksiyonuiçindengörüntüleyebiliriz. Bunuteyitedelim: sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) def seslidir(harf): print(’sayaç değişkeninin değeri şu anda: ’, sayaç) return harf in sesli_harfler def artır(): global sayaç for harf in kelime: if seslidir(harf): sayaç += 1 return sayaç mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, artır())) Gördüğünüz gibi, global isim alanındaki sayaç değişkeninin değerini seslidir() fonksiyonu içindekullanabildik.Amaeğerbudeğişkenüzerindedeğişiklikyapacaksakilaveadımlaratmak zorundayız.Dolayısıyla,meselaartır()fonksiyonununetkialanından,globaletkialanındaki sayaç değişkeni üzerinde değişiklik yapabilmek için global deyimini kullanmamız gerekiyor. Buşekilde,globalisimalanındabulunansayaçadlıdeğişkenindeğeriniartırabiliyoruz. Dikkat ederseniz, artır() fonksiyonunda iki tane global değişken var: sayaç ve kelime. Ama biz bunlardan yalnızca sayaç değişkenini global olarak belirledik. Öbür global değişkenimiz kelimeiçinisebuişlemiyapmadık.Çünkükelimeadlıdeğişkenideğiştirmekgibibirniyetimiz yok. Biz bu değişkeni sadece kullanmakla yetiniyoruz. O yüzden bu değişkeni global olarak belirlemekzorundadeğiliz. Ancak bildiğiniz gibi, global deyimini kullanmak pek tavsiye edilen bir şey değil. Eğer siz de budeyimikullanmakistemezseniz,yukarıdakikodlarışuşekildeyazmayıyeğleyebilirsiniz: sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler def artır(sayaç): for harf in kelime: if seslidir(harf): sayaç += 1 (sonrakisayfayadevam) 39.3. SınıflarNeİşeYarar? 755 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) return sayaç mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, artır(sayaç))) Gördüğünüz gibi, bu kodlarda global deyimini kullanmak yerine, artır() fonksiyonuna verdiğimizsayaçparametresiüzerindenglobalisimalanıylailetişimkurarak,sayaçdeğişkenini manipüleedebildik.Sadecedeğerinikullandığımızglobaldeğişkenkelimeiçiniseözelbirşey yapmamızagerekkalmadı. Buarada,tabiiki,artır()fonksiyonundaparametreolarakkullandığımızkelimesayaçolmak zorundadeğil.Kodlarımızımeselaşöyledeyazabilirdik: sesli_harfler = ’aeıioöuü’ sayaç = 0 kelime = input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler def artır(n): for harf in kelime: if seslidir(harf): n += 1 return n mesaj = ’{} kelimesinde {} sesli harf var.’ print(mesaj.format(kelime, artır(sayaç))) Önemliolan,artır()fonksiyonunun,bizimglobalisimalanıylailetişimkurmamızısağlayacak birparametrealması.Buparametreninadınınneolduğununbirönemiyok. Yukarıdaki kodlarda birkaç değişiklik daha yaparak, bu kodları iyice genişletilebilir hale getirebiliriz: sesli_harfler = ’aeıioöuü’ sayaç = 0 def kelime_sor(): return input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler def artır(sayaç, kelime): for harf in kelime: if seslidir(harf): sayaç += 1 return sayaç (sonrakisayfayadevam) 756 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def ekrana_bas(kelime): mesaj = "{} kelimesinde {} sesli harf var." print(mesaj.format(kelime, artır(sayaç, kelime))) def çalıştır(): kelime = kelime_sor() ekrana_bas(kelime) çalıştır() Bu kodlarda, fonksiyonlara verdiğimiz parametreler yardımıyla, farklı fonksiyonların lokal etki alanlarında yer alan öğeler arasında nasıl iletişim kurduğumuza dikkat edin. Bir önceki kodlarda global etki alanında bulunan kelime değişkenini bu kez çalıştır() fonksiyonunun lokal etki alanı içine yerleştirdiğimiz için, artır() fonksiyonu içindeki kelime değişkeni boşa düştü. O yüzden, bu değişkeni artır() fonksiyonuna bir parametre olarak verdik ve ekrana_bas() fonksiyonu içinde bu fonksiyonu çağırırken, hem sayaç hem de kelime argümanlarınıkullandık. Ayrıca, kullanıcıya kelime sorup, aldığı kelimeyi ekrana basan kod parçalarını, yani programımızı başlatan kodları çalıştır() başlığı altında toplayarak bu kısmı tam anlamıyla ‘modüler’,yaniesnekvetakılıpçıkarılabilirbirhalegetirdik. Gördüğünüz gibi, yazdığımız kodların olabildiğince anlaşılır ve yönetilebilir olmasını sağlayabilmek için, bu kodları küçük birtakım birimlere böldük. Bu şekilde hem hangi işlevin nerede olduğunu bulmak kolaylaştı, hem kodların görünüşü daha anlaşılır oldu, hem de bu kodlarailerideyeniözelliklereklemekbasitleşti.Unutmayın,birprogramcınıngöreviyalnızca çalışankodlaryazmakdeğildir.Programcıaynızamandakodlarınınokunaklılığınıartırmakve bakımınıkolaylaştırmakladayükümlüdür. Bu bakımdan, programcı ile kod arasındaki ilişkiyi, yazar ile kitap arasındaki ilişkiye benzetebilirsiniz. Tıpkı bir programcı gibi, yazarın da görevi aklına gelenleri bir kağıda gelişigüzel boca etmek değildir. Yazar, yazdığı kitabın daha anlaşılır olmasını sağlamak için kitabına bir başlık atmalı, yazdığı yazıları alt başlıklara ve paragraflara bölmeli, ayrıca noktalama işaretlerini yerli yerinde kullanarak yazılarını olabildiğince okunaklı hale getirmelidir. Bir ana başlığı ve alt başlıkları olmayan, sadece tek bir büyük paragraftan oluşan, içinde hiçbir noktalama işaretinin kullanılmadığı bir makaleyi okumanın veya bu makaleye sonradan yeni bir şeyler eklemenin ne kadar zor olduğunu düşünün. İşte aynı şey bir programcının yazdığı kodlar için de geçerlidir. Eğer yazdığınız kodları anlaşılır birimlere bölmeden ekrana yığarsanız bu kodları ne başkaları okuyup anlayabilir, ne de siz ileride bu kodlarayeniişlevlerekleyebilirsiniz. Python programlama dili, kodlarınızı olabildiğince anlaşılır, okunaklı ve yönetilebilir hale getirmeniz için size pek çok araç sunar. Önceki derslerde gördüğümüz değişkenler, fonksiyonlar ve modüller bu araçlardan yalnızca birkaçıdır. İşte bu bölümde inceleyeceğimiz sınıflardakodlarımızıehlileştirmekiçinkullanacağımızsonderecefaydalıaraçlardır. Birazdan, ‘sınıf’ denen bu faydalı araçları enine boyuna inceleyeceğiz. Ama gelin isterseniz, anlatmayadevametmedenönce,verdiğimizsonkodlarıbirazdahakurcalayalım. Hatırlarsanız, geçen bölümde, yazdığımız Python kodlarının aynı zamanda hem bağımsız bir programolarakhemdebirmodülolarakkullanılabileceğinisöylemiştik. Mesela, yukarıdaki kodları sayac.py adlı bir dosyaya kaydettiğimizi varsayarsak, bu programı 39.3. SınıflarNeİşeYarar? 757 PythonBelgeleri,Yayım4.1.3 komut satırı üzerinden python sayac.py gibi bir kodla çalıştırabiliyoruz. Biz bu programı bu şekilde komut satırı üzerinden veya üzerine çift tıklayarak çalıştırdığımızda, bu kodları bağımsız bir program olarak çalıştırmış oluyoruz. Gelin bir de bu kodları bir modül olarak nasıliçeaktaracağımızıinceleyelim. Şimdi, sayac.py programının bulunduğu dizin altında Python komut satırını başlatalım ve oradaşukomutuverereksayacmodülünüiçeaktaralım: >>> import sayac Bu komutu verdiğimiz anda, sayac.py programı çalışmaya başlayacaktır. Ancak bizim istediğimiz şey bu değil. Biz sayac.py programının çalışmaya başlamasını istemiyoruz. Bizim istediğimiz şey, bu sayac.py dosyasını bağımsız bir program olarak değil, bir modül olarak kullanmak ve böylece bu modül içindeki nitelik ve fonksiyonlara erişmek. Tam bu noktada şöylebirsoruaklımızageliyor:Acababirinsannedenbirprogramımodülolarakiçeaktarmak istiyorolabilir? Bir Python dosyasına modül olarak erişmek istemenizin birkaç sebebi olabilir. Mesela bir program yazıyorsunuzdur ve amacınız yazdığınız kodların düzgün çalışıp çalışmadığını test etmektir. Bunun için, programınızı etkileşimli kabuk ortamına bir modül olarak aktarıp, bu modülün test etmek istediğiniz kısımlarını tek tek çalıştırabilirsiniz. Aynı şekilde, kendi yazdığınız veya başkası tarafından yazılmış bir program içindeki işlevsellikten başka bir program içinde de yararlanmak istiyor olabilirsiniz. İşte bunun için de, ilgili programı, başka birprogramiçindençağırarak,yanioprogramıötekiprogramiçinebirmodülolarakaktararak, ilgilimodüliçindekiişlevlerikullanabilirsiniz. Diyelim ki biz, yukarıda yazdığımız sayac.py adlı dosya içindeki kodların düzgün çalışıp çalışmadığınıkontroletmekistiyoruz.Bununiçinsayac.pydosyasındakikodlardaşudeğişikliği yapalım: sesli_harfler = ’aeıioöuü’ sayaç = 0 def kelime_sor(): return input(’Bir kelime girin: ’) def seslidir(harf): return harf in sesli_harfler def artır(sayaç, kelime): for harf in kelime: if seslidir(harf): sayaç += 1 return sayaç def ekrana_bas(kelime): mesaj = "{} kelimesinde {} sesli harf var." print(mesaj.format(kelime, artır(sayaç, kelime))) def çalıştır(): kelime = kelime_sor() ekrana_bas(kelime) (sonrakisayfayadevam) 758 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if __name__ == ’__main__’: çalıştır() Gördüğünüz gibi, burada çalıştır() fonksiyonunu if __name__ == ’__main__’ bloğuna aldık. Buna göre, eğer __name__ niteliğinin değeri ‘__main__’ ise çalıştır() fonksiyonu işlemeyebaşlayacak.Aksihaldeherhangibirşeyolmayacak. Şimdisayac.pyprogramınıkomutsatırıüzerindenpython sayac.pygibibirkomutlaçalıştırın. Programınız normal bir şekilde çalışacaktır. Çünkü, bildiğiniz gibi, bir Python programı bağımsız bir program olarak çalıştırıldığında __name__ niteliğinin değeri ‘__main__’ olur. Dolayısıyladaçalıştır()fonksiyonuişlemeyebaşlar. Şimdideetkileşimlikabuğutekraraçınveşukomutuvererekmodülüiçeaktarın: >>> import sayac Bu defa programımız çalışmaya başlamadı. Çünkü bu kez, programımızı bir modül olarak içeaktardığımıziçin,__name__niteliğinindeğeri‘__main__’değil,ilgilimodülünadıoldu(yani bizimörneğimizdesayac). Böylece __name__ niteliğinin farklı durumlarda farklı bir değere sahip olmasından yararlanarak,programınızınfarklıdurumlardafarklıtepkilervermesinisağlamışolduk. sayac modülünü içe aktardıktan sonra, bu modülün içinde neler olduğunu nasıl kontrol edebileceğinizibiliyorsunuz: >>> dir(sayac) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’, ’artır’, ’ekrana_bas’, ’kelime_sor’, ’sayaç’, ’sesli_harfler’, ’seslidir’, ’çalıştır’] Bu listede, sayac modülüne ait bütün nitelik ve fonksiyonları görebiliyoruz. Bunları, başka modüllerdeolduğugibikullanmaimkanınasahibiz. Meselabulistedegörünenseslidir()fonksiyonunukullanalım: >>> sayac.seslidir(’ö’) True >>> sayac.seslidir(’ç’) False Gördüğünüzgibi,sayac.pyiçindetanımladığımızseslidir()fonksiyonunu,rastgeleharflerin birersesliharfolupolmadığınıdenetlemekiçindekullanabiliyoruz.Buşekildeaynızamanda seslidir() fonksiyonunun düzgün bir şekilde çalışıp çalışmadığını, sesli olan ve olmayan harfleribaşarılıbirşekildebirbirindenayırtedipedemediğinidetestetmişoluyoruz. Devamedelim: 39.3. SınıflarNeİşeYarar? 759 PythonBelgeleri,Yayım4.1.3 >>> sayac.sesli_harfler ’aeıioöuü’ Modüllerinnekadarfaydalıaraçlarolabileceğinibuörnekgayetnetbirşekildegösteriyor.Eğer ileride sesli harfleri kullanmamızı gerektiren başka bir program yazacak olursak, bu harfleri yenidentanımlamakyerine,sayac.pydosyasındaniçeaktarabiliriz. Bütünbuörneklersayesinde,sınıflarıdahaiyianlamamızısağlayacakaltyapıyıoluşturmuş,bir yandandaeskibilgilerimizipekiştirmişolduk.Dilerseniz,sınıflarıanlatmayageçmedenönce, yukarıdaverdiğimizkodlarısınıflıbiryapıiçindenasılifadeedebileceğimizidegörelim. Elbette aşağıdaki kodları anlamanızı şu aşamada sizden beklemiyoruz. Bu bölümün sonuna vardığımızda, zihninizde her şey berraklaşmış olacak. Siz şimdilik sadece aşağıdaki kodlara bakınvehemokunaklılıkhemdeyönetilebilirlikbakımındanbukodlarınbizenegibifaydalar sağlıyorolabileceğinedairfikiryürütmeyeçalışın.Anlamadığınızkısımlarolursabunlarıgeçin gitsin.Anladığınızkısımlariseyanınızakârkalsın. class HarfSayacı: def __init__(self): self.sesli_harfler = ’aeıioöuü’ self.sayaç = 0 def kelime_sor(self): return input(’Bir kelime girin: ’) def seslidir(self, harf): return harf in self.sesli_harfler def artır(self): for harf in self.kelime: if self.seslidir(harf): self.sayaç += 1 return self.sayaç def ekrana_bas(self): mesaj = "{} kelimesinde {} sesli harf var." sesli_harf_sayısı = self.artır() print(mesaj.format(self.kelime, sesli_harf_sayısı)) def çalıştır(self): self.kelime = self.kelime_sor() self.ekrana_bas() if __name__ == ’__main__’: sayaç = HarfSayacı() sayaç.çalıştır() Hakkında herhangi bir fikre sahip olmadığınız bir kod parçasını anlamanın en iyi yolu, anlamadığınız kısmı kodlardan çıkarıp, kodları bir de o şekilde çalıştırmaktır. Mesela yukarıdaki __init__, self ve class gibi öğelerin ismini değiştirin, bunları kodlardan çıkarın veya başka bir yere koyun. Elde ettiğiniz sonuçları gözlemleyerek bu kodlar hakkında en azından 760 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 birfikirsahibiolabilirsiniz. Gelin isterseniz, henüz yukarıdaki kodları anlayabilecek kadar sınıf bilgisine sahip olmasak da, bu kodları şöyle bir üstünkörü gözden geçirerek, bu kodların programcılık deneyimimiz açısındanbizenegibibirkatkısunuyorolabileceğinianlamayaçalışalım. Yukarıdaki kodlarda dikkatimizi çeken ilk şey, bu kodların son derece derli toplu görünüyor olmasıdır.Öyleki,HarfSayacıadlısınıfiçindekifonksiyonlarsankiipedizilirgibidizilmiş. HarfSayacı adlı sınıf ile bu sınıf yapısı içinde yer alan fonksiyonlar arasındaki ilişki gayet net bir şekilde görünüyor. Eğer ileride bu sayaca yeni bir işlev eklemek istersek, neyi nereye yerleştirmemizgerektiğiçokaçık.Meselailerdebukodlarasesliharflerlebirliktebirdesessiz harfdenetimişlevieklemekistersek,gereklideğişikliklerikolaycayapabiliriz: class HarfSayacı: def __init__(self): self.sesli_harfler = ’aeıioöuü’ self.sessiz_harfler = ’bcçdfgğhjklmnprsştvyz’ self.sayaç_sesli = 0 self.sayaç_sessiz = 0 def kelime_sor(self): return input(’Bir kelime girin: ’) def seslidir(self, harf): return harf in self.sesli_harfler def sessizdir(self, harf): return harf in self.sessiz_harfler def artır(self): for harf in self.kelime: if self.seslidir(harf): self.sayaç_sesli += 1 if self.sessizdir(harf): self.sayaç_sessiz += 1 return (self.sayaç_sesli, self.sayaç_sessiz) def ekrana_bas(self): sesli, sessiz = self.artır() mesaj = "{} kelimesinde {} sesli {} sessiz harf var." print(mesaj.format(self.kelime, sesli, sessiz)) def çalıştır(self): self.kelime = self.kelime_sor() self.ekrana_bas() if __name__ == ’__main__’: sayaç = HarfSayacı() sayaç.çalıştır() Ayrıca sınıflı kodlarda, farklı etki alanları ile iletişim kurmak, sınıfsız kodlara kıyasla daha zahmetsizdir. Sınıflı ve sınıfsız kodlarda fonksiyonlara verdiğimiz parametreleri birbirleri ile 39.3. SınıflarNeİşeYarar? 761 PythonBelgeleri,Yayım4.1.3 kıyaslayarakbudurumukendinizdegörebilirsiniz. Sınıflı yapıların daha pek çok avantajlı yönü vardır. İşte biz bu bölümde bunları size tek tek göstermeyeçalışacağız. 39.4 Sınıf Tanımlamak Nesne tabanlı programlama yaklaşımı, özellikle birtakım ortak niteliklere ve davranış şekillerine sahip gruplar tanımlamak gerektiğinde son derece kullanışlıdır. Mesela şöyle bir örnek düşünün: Diyelim ki çalıştığınız işyerinde, işe alınan kişilerin kayıtlarını tutan bir veritabanınız var. Bir kişi işe alındığında, o kişiye dair belli birtakım bilgileri bu veritabanına işliyorsunuz. Mesela işe alınan kişinin adı, soyadı, unvanı, maaşı ve buna benzer başka bilgiler... Çalışmaya başlayacak kişileri temsil eden bir ‘Çalışan’ grubunu, bu grubun nitelikleri ile faaliyetlerinitutacakyapıyıvebugrubunbütünöğelerinintaşıyacağıözelliklerinesnetabanlı programlamayaklaşımıilekolaycakodlayabilirsiniz. Aynı şekilde, mesela yazdığınız bir oyun programı için, bir ‘Asker’ grubunu nesne tabanlı programlamamantığıiçindetanımlayarak,bugrubunherbirüyesininsahipolacağınitelikleri, kabiliyetleri ve davranış şekillerini kodlayabilir; mesela askerlerin sağa sola nasıl hareket edeceklerini, hangi durumlarda puan/enerji/güç kazanacaklarını veya kaybedeceklerini, bir askerilkkezoluşturulduğundahangiözellikleritaşıyacağınıveaklınızagelebilecekbaşkaher türlüözelliğitektekbelirleyebilirsiniz. Amacınız ne olursa olsun, atmanız gereken ilk adım, ilgili sınıfı tanımlamak olmalıdır. Zira fonksiyonlarda olduğu gibi, bir sınıfı kullanabilmek için de öncelikle o sınıfı tanımlamamız gerekiyor.Mesela,yukarıdabahsettiğimizişeuygunolarak,Çalışanadlıbirsınıftanımlayalım: class Çalışan: pass Yukarıdaki, boş bir sınıf tanımıdır. Hatırlarsanız fonksiyonları tanımlamak için def adlı bir ifadeden yararlanıyorduk. İşte sınıfları tanımlamak için de class adlı bir ifadeden yararlanıyoruz.BuifadeninardındangelenÇalışankelimesiisebusınıfınadıdır. Eğerarzuederseniz,yukarıdakisınıfışuşekildedetanımlayabilirsiniz: class Çalışan(): pass Yani sınıf adından sonra parantez kullanmayabileceğiniz gibi, kullanabilirsiniz de. Her ikisi de aynı kapıya çıkar. Ayrıca sınıf adlarında, yukarıda olduğu gibi büyük harf kullanmak ve birden fazla kelimeden oluşan sınıf adlarının ilk harflerini büyük yazıp bunları birleştirmek adettendir.Yani: class ÇalışanSınıfı(): pass Veyaparantezsizolarak: class ÇalışanSınıfı: pass 762 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi sınıf tanımlamak fonksiyon tanımlamaya çok benziyor. Fonksiyonları tanımlarken nasıl def deyimini kullanıyorsak, sınıfları tanımlamak için de class deyimini kullanıyoruz. Örnekolmasıaçısından,yukarıdabahsettiğimiz‘Asker’grubuiçindebirsınıftanımlayalım: class Asker: pass ... veya: class Asker(): pass Python’da sınıfları nasıl tanımlayacağımızı öğrendiğimize göre, bu sınıfları nasıl kullanacağımızıincelemeyegeçebiliriz. 39.5 Sınıf Nitelikleri Yukarıda, boş bir sınıfı nasıl tanımlayacağımızı öğrendik. Elbette tanımladığımız sınıflar hep boş kalmayacak. Bu sınıflara birtakım nitelikler ekleyerek bu sınıfları kullanışlı hale getirebiliriz.Mesela: class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ Buradaunvanıvekabiliyetleriadlıikideğişkentanımladık.Teknikdildebudeğişkenlere‘sınıf niteliği’(classattribute)adıverilir. Biraz önce, sınıf tanımlamayı öğrenirken sınıf tanımlamanın fonksiyon tanımlamaya çok benzediğini söylemiştik. Gerçekten de öyledir. Ancak fonksiyonlarla sınıflar arasında (başka farkların dışında) çok önemli bir fark bulunur. Bildiğiniz gibi, bir fonksiyonu tanımladıktan sonra, o fonksiyonun işlemeye başlaması için, o fonksiyonun mutlaka çağrılması gerekir. Çağrılmayan fonksiyonlar çalışmaz. Mesela yukarıdaki sınıfa benzeyen şöyle bir fonksiyon tanımladığımızıdüşünün: def çalışan(): kabiliyetleri = [] unvanı = ’işçi’ print(kabiliyetleri) print(unvanı) Bu fonksiyonun çalışması için, kodlarımızın herhangi bir yerinde bu fonksiyonu çağırmamız lazım: çalışan() Ancaksınıflarfarklıdır.Bunugörmekiçinyukarıdakifonksiyonubirsınıfhalinegetirelim: 39.5. SınıfNitelikleri 763 PythonBelgeleri,Yayım4.1.3 class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ print(kabiliyetleri) print(unvanı) Bu kodları mesela deneme.py adlı bir dosyaya kaydedip çalıştırdığınızda, unvanı ve kabiliyetlerideğişkenlerinindeğerininekranabasıldığınıgöreceksiniz. Aynı şey, yukarıdaki kodların bir modül olarak içe aktarıldığı durumlarda da geçerlidir. Yani yukarıdaki kodların deneme.py adlı bir dosyada bulunduğunu varsayarsak, bu modülü şu komutla içe aktardığımızda, sınıfı kodlarımızın herhangi bir yerinde çağırmamış olmamıza rağmensınıfiçeriğiçalışmayabaşlayacaktır: >>> import deneme [] işçi Eğersınıfniteliklerininnezamançalışacağınıkendinizkontroletmekisterseniz,bunitelikleri sınıfdışındakullanabilirsiniz: class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ print(Çalışan.kabiliyetleri) print(Çalışan.unvanı) Burada Çalışan() adlı sınıfın niteliklerine nasıl eriştiğimize dikkat edin. Gördüğünüz gibi, sınıf niteliklerine erişmek için doğrudan sınıfın adını parantezsiz bir şekilde kullanıyoruz. Eğer sınıf adlarını parantezli bir şekilde yazarsak başka bir şey yapmış oluruz. Bundan biraz sonra bahsedeceğiz. Biz şimdilik, sınıf niteliklerine erişmek için sınıf adlarını parantezsiz kullanmamızgerektiğinibilelimyeter. Hatırlarsanız, bu bölüme başlarken, nesne tabanlı programlama yaklaşımının, özellikle birtakım ortak niteliklere ve davranış şekillerine sahip gruplar tanımlamak gerektiğinde son derece kullanışlı olduğunu söylemiştik. Gelin isterseniz yukarıdaki Çalışan() sınıfına birkaç nitelikdahaekleyerekbuiddiamızıdestekleyelim: class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ maaşı = 1500 memleketi = ’’ doğum_tarihi = ’’ Buradabellikabiliyetleri,unvanı,maaşı,memleketivedoğum_tarihiolanbirÇalışan()sınıfı tanımladık. Yani ‘Çalışan’ adlı bir grubun ortak niteliklerini belirledik. Elbette her çalışanın memleketi ve doğum tarihi farklı olacağı için sınıf içinde bu değişkenlere belli bir değer atamadık. Bunların birer karakter dizisi olacağını belirten bir işaret olması için yalnızca memleketivedoğum_tarihiadlıbirerboşkarakterdizisitanımladık. 764 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 Yukarıda tanımladığımız sınıf niteliklerine, doğrudan sınıf adını kullanarak erişebileceğimizi biliyorsunuz: print(Çalışan.maaşı) print(Çalışan.memleketi) print(Çalışan.doğum_tarihi) Eğeristersenizbusınıfayenisınıfniteliklerideekleyebilirsiniz: Çalışan.isim = ’Ahmet’ Çalışan.yaş = 40 Gayetgüzel... Ancakburadaşöylebirsorunvar:Bizyukarıdakigibidoğrudansınıfadınıkullanaraköğelere eriştiğimizdekodlarımıztekkullanımlıkolmuşoluyor.YanibuşekildeancaktekbirÇalışan() nesnesi(‘nesne’kavramınailerdedeğineceğiz),dolayısıyladatekbirçalışanoluşturmaimkanı eldeedebiliyoruz.Amabiz,mantıken,sınıfiçindebelirtilenözellikleritaşıyan,Ahmet,Mehmet, Veli,Selim,Selinvebunabenzer,istediğimizsayıdaçalışanoluşturabilmeliyiz.Pekiamanasıl? 39.6 Sınıfların Örneklenmesi Birazönceşöylebirsınıftanımlamıştık: class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ maaşı = 1500 memleketi = ’’ doğum_tarihi = ’’ Daha önce de söylediğimiz gibi, sınıflar belli birtakım ortak özelliklere sahip gruplar tanımlamak için biçilmiş kaftandır. Burada da, her bir çalışan için ortak birtakım nitelikler tanımlayan Çalışan() adlı bir sınıf oluşturduk. Ancak elbette bu sınıfın bir işe yarayabilmesi için, biraz önce de değindiğimiz gibi, bu sınıfı temel alarak, bu sınıfta belirtilen nitelikleri taşıyanbirdenfazlasınıfüyesimeydanagetirebilmemizlazım. Şimdidikkatlicebakın: class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ maaşı = 1500 memleketi = ’’ doğum_tarihi = ’’ ahmet = Çalışan() Buradasınıfımızıahmetadlıbirdeğişkeneatadık. İştebuişlemeteknikdilde‘örnekleme’veya‘örneklendirme’(instantiation)adıverilir.Buişlemi fonksiyon çağırma ile kıyaslayabiliriz: Python programlama dilinde bir fonksiyonu kullanışlı 39.6. SınıflarınÖrneklenmesi 765 PythonBelgeleri,Yayım4.1.3 hale getirme işlemine ‘çağırma’, bir sınıfı kullanışlı hale getirme işlemine ise ‘örnekleme’ adı veriyoruz. Örneklemekavramınıdahaiyianlayabilmekiçinbaşkabirsınıfdahaoluşturalım: class Asker(): rütbesi = ’Er’ standart_teçhizat = [’G3’, ’kasatura’, ’süngü’, ’el bombası’] gücü = 60 birliği = ’’ Burada da belli birtakım niteliklere sahip Asker() adlı bir sınıf tanımladık. Bu sınıfın niteliklerinedoğrudansınıfadınıkullanarakerişebileceğimizibiliyorsunuz: Asker.rütbesi Asker.standart_teçhizat Asker.gücü Asker.birliği Ama bu sınıfın bir işe yarayabilmesi için, bu sınıfa bir ‘referans’ oluşturmamız lazım, ki daha sonra bu sınıfa bu referans üzerinden atıfta bulunabilelim. Yani bu sınıfı çağırırken buna bir isimvermeliyiz,kibuisimüzerindensınıfaveniteliklerineerişebilelim. Mesela bu sınıfa daha sonra atıfta bulunabilmek amacıyla, bu sınıf için mehmet adlı bir referansnoktasıoluşturalım: mehmet = Asker() İşte,teknikolarakifadeetmemizgerekirse,sınıflarıbirismeatamaişlemineörnekleme(veya örneklendirme)adıveriyoruz. Buradaahmetvemehmet,aitolduklarısınıflarınbirer‘sureti’veyabaşkabirdeyişle‘örneği’dir (instance). mehmet’in, Asker() adlı sınıfın bir örneği, ahmet’inse Çalışan() adlı sınıfın bir örneği olması demek, mehmet’in ve ahmet’in, ilgili sınıfların bütün özelliklerini taşıyan birer üyesiolmasıdemektir. . Uyarı Bu bağlamda ‘örnek’ kelimesini ‘misal’ anlamında kullanmadığımıza özellikle dikkatinizi çekmek isterim. Türkçede ‘örnek’ kelimesi ile karşıladığımız ‘instance’ kavramı, nesne tabanlıprogramlamanınönemliteknikkavramlarındanbiridir. Biz bir sınıfı çağırdığımızda (yani Asker() veya Çalışan() komutunu verdiğimizde), o sınıfı örneklemişoluyoruz.Örneklediğimizsınıfıbirdeğişkeneatadığımızdaiseosınıfınbirörneğini çıkarmış,yaniosınıfınbütünözelliklerinitaşıyanbirüyemeydanagetirmişoluyoruz. Bu arada, elbette bu teknik terimleri ezberlemek zorunda değilsiniz. Ancak nesne tabanlı programlamaya ilişkin metinlerde bu terimlerle sık sık karşılaşacaksınız. Eğer bu terimlerin anlamını bilirseniz, okuduğunuz şey zihninizde daha kolay yer edecek, aksi halde, sürekli ne demek olduğunu bilmediğiniz terimlerle karşılaşmak öğrenme motivasyonunuza zarar verecektir. Esasında nesne tabanlı programlamayı öğrencilerin gözünde zor kılan şey, bu programlama yaklaşımının özünden ziyade, içerdiği terimlerdir. Gerçekten de nesne tabanlı programlama, 766 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 pek çok çetrefilli teknik kavramı bünyesinde barındıran bir sistemdir. Bu nedenle öğrenciler bukonuyailişkinbirşeylerokurken,muğlakkavramlarınarasındakaybolupkonununesasını gözdenkaçırabiliyor.Eğernesnetabanlıprogramlamayailişkinkavramlarıhakkıylaanlarsanız, buyaklaşımadairönemlibirengeliaşmışsınızdemektir. Öteyandan,nesnetabanlıprogramlamayailişkinkavramlarıanlamaksadeceTürkçeokuyup yazanlariçindeğil,aynızamandaİngilizcebilipilgilimakaleleriözgündilindenokuyanlariçin de zor olabilir. O yüzden biz bu bölümde, kavramların Türkçeleri ile birlikte İngilizcelerini de vererek,İngilizcebilenlerinözgünmetinleriokurkenkonuyudahaiyianlamalarınısağlamaya çalışacağız.Dolayısıyla,birkavramdanbahsederkenonunaslınınneolduğunudabelirtmemiz, İngilizcebilipdekonuyudahaileribirdüzeydearaştırmakisteyenlerekolaylıksağlayacaktır. Nediyorduk?Eğerelimizdeşöylebirkodvarsa: class Sipariş(): firma = ’’ miktar = 0 sipariş_tarihi = ’’ teslim_tarihi = ’’ stok_adedi = 0 jilet = Sipariş() Buradaclass,sınıfıtanımlamamızayarayanbiröğedir.Tıpkıfonksiyonlardakidefgibi,sınıfları tanımlamakiçindeclassadlıbirparçacığıkullanıyoruz. Sipariş ise, sınıfımızın adı oluyor. Biz sınıfımızın adını parantezli veya parantezsiz olarak kullanmaimkanınasahibiz. Sınıfıngövdesindetanımladığımızşudeğişkenlerbirersınıfniteliğidir(classattribute): firma = ’’ miktar = 0 sipariş_tarihi = ’’ teslim_tarihi = ’’ stok_adedi = 0 jilet = Sipariş() komutunu verdiğimizde ise, biraz önce tanımladığımız sınıfı örnekleyip (instantiation),bunujiletadlıbirörneğe(instance)atamışoluyoruz.Yanijilet,Sipariş()adlı sınıfınbirörneğiolmuşoluyor.Birsınıftanistediğimizsayıdaörnekçıkarabiliriz: kalem = Sipariş() pergel = Sipariş() çikolata = Sipariş() Bu şekilde Sipariş() sınıfını üç kez örneklemiş, yani bu sınıfın bütün özelliklerini taşıyan üç farklıüyemeydanagetirmişoluyoruz. Busınıförneklerinikullanarak,ilgilisınıfınniteliklerine(attribute)erişebiliriz: kalem = Sipariş() kalem.firma (sonrakisayfayadevam) 39.6. SınıflarınÖrneklenmesi 767 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) kalem.miktar kalem.sipariş_tarihi kalem.teslim_tarihi kalem.stok_adedi Bildiğiniz gibi, eriştiğimiz bu nitelikler birer sınıf niteliği olduğu için, sınıfı hiç örneklemeden, bunitelikleredoğrudansınıfadıüzerindendeerişebilirdik: Sipariş.firma Sipariş.miktar Sipariş.sipariş_tarihi Sipariş.teslim_tarihi Sipariş.stok_adedi Özellikle, örneklenmesine gerek olmayan, yalnızca bir kez çalışacak sınıflarda, sınıf niteliklerine örnekler üzerinden değil de doğrudan sınıf adı üzerinden erişmek daha pratik olabilir. Ancak yukarıda olduğu gibi, tek bir sınıftan, ortak niteliklere sahip birden fazla üye oluşturmamız gereken durumlarda sınıfı bir örneğe atayıp, sınıf niteliklerine bu örnek üzerinden erişmek çok daha akıllıca olacaktır. Ancak her koşulda sınıfların niteliklerine doğrudansınıfadlarıüzerindenerişmekyerineörneklerüzerindenerişmeyitercihetmenizin dehiçbirsakıncasıolmadığınıbilin. Gelinşimdiyukarıdaöğrendiklerimizikullanarakufaktefekuygulamaçalışmalarıyapalım. Sınıfımızşuolsun: class Sipariş(): firma = ’’ miktar = 0 sipariş_tarihi = ’’ teslim_tarihi = ’’ stok_adedi = 0 Bildiğinizgibi,ufaktefekkodçalışmalarıyapmakiçinPython’ınetkileşimlikabuğusonderece uygun bir ortamdır. O halde yukarıdaki sınıfı sipariş.py adlı bir dosyaya kaydedelim, bu dosyanınbulunduğukonumdabiretkileşimlikabukortamıaçalımvesipariş.pydosyasınıbir modülolarakiçeaktaralım: >>> import sipariş Böylecesiparişmodülüiçindekinitelikvemetotlaraerişimsağladık.Bunuteyitedelim: >>> dir(sipariş) [’Sipariş’, ’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, ’__loader__’, ’__name__’, ’__package__’, ’__spec__’] Sipariş() adlı sınıfı listenin en başında görebilirsiniz. O halde gelin bu sınıfı örnekleyerek kullanılabilirhalegetirelim: >>> gofret = sipariş.Sipariş() 768 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 ElbetteSipariş()adlısınıfsiparişadlımodüliçindebulunduğundan,busınıfasiparişönekiyle erişiyoruz.Tabiibizisteseydikmodülüşuşekildedeiçeaktarabilirdik: >>> from sipariş import Sipariş BöyleceSipariş()sınıfınaöneksizolarakerişebilirdik: >>> gofret = Sipariş() Ancak mevcut isim alanını kirletmemek ve bu alanı nereden geldiği belli olmayan birtakım nitelik ve metotlarla doldurmamak için biz import modül_adı biçimini tercih ediyoruz. Aksi halde, bu kodları okuyanlar, Sipariş() adlı sınıfın sipariş adlı bir modüle ait olduğunu anlamayacak,busınıfıilkolarakmevcutdosyaiçindebulmayaçalışacaklardır.Amabizmodül adınısınıfadınaeklediğimizdemodülünneredengeldiğigayetaçıkbirşekildeanlaşılabiliyor. Böylecehemkodlarıokuyanbaşkalarınınişinihemdebirkaçaysonrakendikodlarımızatekrar bakmakistediğimizdekendiişimizikolaylaştırmışoluyoruz. Neyse... Lafıdahafazladolandırmadankaldığımızyerdendevamedelim... Sınıfımızışuşekildeiçeaktarmışveörneklemiştik: >>> import sipariş >>> gofret = sipariş.Sipariş() Gelinşimdibirdegofretörneğinin(instance)içeriğinikontroledelim: >>> dir(gofret) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’, ’firma’, ’miktar’, ’sipariş_tarihi’, ’stok_adedi’, ’teslim_tarihi’] Gördüğünüzgibi,sınıfiçindetanımladığımızbütünsınıfnitelikleri(firma,miktar,sipariş_tarihi, stok_adediveteslim_tarihi)bulisteiçindevar. Bu sınıf niteliklerinden, adı firma olanı kullanarak siparişin hangi firmadan yapılacağını belirleyebiliriz: >>> gofret.firma = ’Öz ve Şerikleri Gıda, Ticaret Anonim Şirketi’ Böylece, sınıf içindeki bir niteliğe yeni bir değer atamış olduk. İsterseniz sipariş miktarını da belirleyelim: >>> gofret.miktar = 1000 Öteki sınıf niteliklerini de ihtiyacınıza göre ayarlayabilir, hatta bu sınıfa yeni nitelikler de ekleyebilirsiniz. Gelinistersenizpratikolmasıbakımındanbirörnekdahaverelim. Elimizdeşöylebirsınıfolsun: 39.6. SınıflarınÖrneklenmesi 769 PythonBelgeleri,Yayım4.1.3 class Çalışan(): kabiliyetleri = [] unvanı = ’işçi’ maaşı = 1500 memleketi = ’’ doğum_tarihi = ’’ Burada kabiliyetleri, unvanı, maaşı, memleketi ve doğum_tarihi adlı beş adet değişken tanımladık. Teknik dilde bu değişkenlere ‘sınıf niteliği’ (class attribute) adı verildiğini biliyorsunuz. Çalışan()sınıfıiçindekiniteliklereerişmekiçinbirkaçtaneörnekçıkaralım: ahmet = Çalışan() mehmet = Çalışan() ayşe = Çalışan() Bu şekilde Çalışan() sınıfının üç farklı örneğini oluşturmuş olduk. Bu sınıfın niteliklerine, oluşturduğumuzbuörneklerüzerindenerişebiliriz: print(ahmet.kabiliyetleri) print(ahmet.unvanı) print(mehmet.maaşı) print(mehmet.memleketi) print(ayşe.kabiliyetleri) print(ayşe.doğum_tarihi) Çıkardığımızörnekleraracılığıylasınıfnitelikleriüzerindedeğişiklikdeyapabiliyoruz: ahmet.kabiliyetleri.append(’prezantabl’) Şimdiburadabirduralım.Çünküburadaçoksinsibirsorunlakarşıkarşıyayız.Dikkatlicebakın. Çalışan()sınıfıiçinbirahmetörneğioluşturalım: ahmet = Çalışan() Buna‘prezantabl’kabiliyetiniekleyelim: ahmet.kabiliyetleri.append(’prezantabl’) Bukabiliyetineklendiğiniteyitedelim: print(ahmet.kabiliyetleri) ŞimdiÇalışan()sınıfınınbirbaşkaörneğinioluşturalım: selim = Çalışan() Buörneğinkabiliyetlerinikontroledelim: 770 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 print(selim.kabiliyetleri) Gördüğünüz gibi, yalnızca ahmet örneğine eklemek istediğimiz ‘prezantabl’ kabiliyeti selim örneğinedeeklenmiş.Ancaknormalşartlardaarzuedilenbirşeydeğildirbu.Zirabudurum aslındaprogramımızdakibirtasarımhatasınaişareteder.Pekiamabudurumunsebebinedir? Hatırlarsanız, sınıf niteliklerinden bahsederken, bu niteliklerin önemli bir özelliğinin, sınıf çağrılmadançalışmayabaşlamalarıolduğunusöylemiştik.Sınıfniteliklerininbirbaşkaönemli özelliği de, bu niteliklere atanan değerlerin ve eğer yapılabiliyorsa bu değerler üzerinde sonradan yapılan değişikliklerin o sınıfın bütün örneklerini etkiliyor olmasıdır. Eğer ilgili sınıf niteliği; karakter dizisi, demet ve sayı gibi değiştirilemeyen (immutable) bir veri tipi ise bu sınıf niteliği üzerinde zaten değişiklik yapamazsınız. Yaptığınız şey ancak ilgili sınıf niteliğini yenidentanımlamakolacaktır.Ancakeğersınıfniteliği,liste,sözlükvekümegibideğiştirilebilir (mutable) bir veri tipi ise bu nitelik üzerinde yapacağınız değişiklikler bütün sınıf örneklerine yansıyacaktır. Yazdığınız program açısından bu özellik arzu ettiğiniz bir şey olabilir veya olmayabilir. Önemli olan, sınıf niteliklerinin bu özelliğinin farkında olmanız ve kodlarınızı bu bilgi çerçevesinde yazmanızdır. Mesela yukarıdaki örnekte kabiliyetleri listesine eklenen öğelerinbütünörneklereyansımasıistediğimizbirşeydeğil.Amaeğersınıfımızşöyleolsaydı: class Çalışan(): personel_listesi = [] Burada personel_listesi adlı bir sınıf niteliği tanımladık. Eğer bu listenin, personele eklenen bütünelemanlarıbarındırmasınıplanlıyorsakbulisteninherörneklemedebüyümesielbette istediğimizbirşeyolacaktır. Peki o halde biz değerinin her örnekte ortak değil de her örneğe özgü olmasını istediğimiz niteliklerinasıltanımlayacağız?Elbettesınıfnitelikleriyerineörneknitelikleridenenbaşkabir kavramdanyararlanarak... 39.7 Örnek Nitelikleri Şimdiye kadar öğrendiklerimiz, sınıflarla faydalı işler yapmamız için pek yeterli değildi. Sınıflarkonusundaufkumuzungenişleyebilmesiiçin,sınıfniteliklerinin(classattributes)yanı sıra, nesne tabanlı programlamanın önemli bir parçası olan örnek niteliklerinden (instance attributes)desözetmemizgerekiyor.Hemörneknitelikleriniöğrendiktensonra,bunlarınsınıf nitelikleriilearasındakifarklarıgörüncesınıfniteliklerinideçokdahaiyianlamışolacaksınız. 39.8 __init__ Fonksiyonu ve self Buraya gelene kadar, sınıflar ile ilgili verdiğimiz kod parçaları yalnızca sınıf niteliklerini içeriyordu. Mesela yukarıda tanımladığımız Çalışan() sınıfı içindeki unvanı ve kabiliyetleri adlıdeğişkenlerinbirersınıfniteliğiolduğunubiliyoruz. Sınıfnitelikleridışında,Python’dabirdeörneknitelikleribulunur. Bildiğiniz gibi, Python’da sınıf niteliklerini tanımlamak için yapmamız gereken tek şey, sınıf tanımınınhemenaltınabunlarıaleladebirerdeğişkengibiyazmaktanibarettir: 39.7. ÖrnekNitelikleri 771 PythonBelgeleri,Yayım4.1.3 class Sınıf(): sınıf_niteliği1 = 0 sınıf_niteliği2 = 1 Örnek niteliklerini tanımlamak için ise iki yardımcı araca ihtiyacımız var: __init__() fonksiyonuveself. Buikiaracışuşekildekullanıyoruz: class Çalışan(): def __init__(self): self.kabiliyetleri = [] Buarada,__init__()fonksiyonununnasılyazıldığınadikkatediyoruz.initkelimesininsağında ve solunda ikişer adet alt çizgi (_) bulunduğunu gözden kaçırmıyoruz. Ayrıca, __init__() fonksiyonunudef ifadesinebitişikyazmamayadabilhassaözengösteriyoruz. ‘init’ kelimesinin solunda ve sağında bulunan alt çizgiler sizi sakın ürkütmesin. Aslında __init__(), alelade bir fonksiyondan başka bir şey değildir. Bu fonksiyonun öteki fonksiyonlardan tek farkı, sınıflar açısından biraz özel bir anlam taşıyor olmasıdır. Bu özel fonksiyonun görevi, sınıfımızı örneklediğimiz sırada, yani mesela ahmet = Çalışan() gibi bir komutverdiğimizandaoluşturulacakniteliklerivegerçekleştirilecekişlemleritanımlamaktır. Bu fonksiyonun ilk parametresi her zaman self olmak zorundadır. Bu açıklama ilk anda kulağınıza biraz anlaşılmaz gelmiş olabilir. Ama hiç endişe etmeyin. Bu bölümün sonuna vardığınızdabuikiöğeyi,adınızıbilirgibibiliyorolacaksınız. Hatırlarsanız, sınıf niteliklerini anlatırken bunların önemli bir özelliğinin, sınıfın çağrılmasına gerekolmadançalışmayabaşlamasıolduğunusöylemiştik: class Çalışan(): selam = ’merhaba’ print(selam) Bu kodları çalıştırdığımız anda ekrana ‘merhaba’ çıktısı verilecektir. Örnek nitelikleri ise farklıdır: class Çalışan(): def __init__(self): self.kabiliyetleri = [] print(self.kabiliyetleri) Bu kodları çalıştırdığınızda herhangi bir çıktı almazsınız. Bu kodların çıktı verebilmesi için sınıfımızımutlakaörneklememizlazım: class Çalışan(): def __init__(self): self.kabiliyetleri = [] print(self.kabiliyetleri) Çalışan() Çünkü self.kabiliyetleri bir sınıf niteliği değil, bir örnek niteliğidir. Örnek niteliklerine erişebilmekiçindeilgilisınıfımutlakaörneklememizgerekir.Ayrıcasınıfniteliklerininaksine, 772 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 örnekniteliklerinesınıfadlarıüzerindenerişemeyiz.Yaniself.kabiliyetleriadlıörnekniteliğine erişmeyeyönelikşöylebirgirişimbizihüsranauğratacaktır: Çalışan.kabiliyetleri Buörnekniteliğineerişmekiçinörneklendirmemekanizmasındanyararlanmamızlazım: Çalışan().kabiliyetleri #parantezlere dikkat! Gelin isterseniz, örneklendirme işlemini daha kullanışlı bir hale getirmek için, örneklendirdiğimizsınıfıbirörneğeatayalım,yanibusınıfınbirörneğiniçıkaralım: ahmet = Çalışan() ahmet = Çalışan() kodu yardımıyla, Çalışan sınıfının bir örneğini çıkardık ve buna ahmet adınıverdik.İştetambuanda__init__()fonksiyonuçalışmayabaşladıveahmetörneğiiçin, kabiliyetleriadlıboşbirörnekniteliğioluşturdu. Pekiyukarıdakodlarımızıyazarken__init__()fonksiyonunaparametreolarakverdiğimizve kabiliyetlerilistesininbaşındakullandığımızself kelimesineoluyor? Öncelikle bilmemiz gereken şey, self kelimesinin, Python programlama dilinin söz diziminin gerektirdiğibiröğeolduğudur.Bukelime,Çalışan()adlısınıfınörneklerinitemsileder.Peki ‘selfkelimesininbirsınıfınörneklerinitemsilediyorolması’neanlamageliyor? Bildiğinizgibi,birsınıfınörneğinişuşekildeçıkarıyoruz: ahmet = Çalışan() Bu ahmet örneğini kullanarak, Çalışan() sınıfının içindeki kabiliyetleri adlı örnek niteliğine sınıfdışındanerişebiliriz: print(ahmet.kabiliyetleri) İşte self kelimesi, yukarıdaki kodda yer alan ahmet kelimesini temsil ediyor. Yani ahmet.kabiliyetleri şeklinde bir kod yazabilmemizi sağlayan şey, __init__() fonksiyonu içindebelirttiğimizself kelimesidir.Eğerbukelimeyikullanmadanşöylebirkodyazarsak: class Çalışan(): def __init__(): kabiliyetleri = [] ...artıkaşağıdakikodlaryardımıylakabiliyetleriniteliğineerişemeyiz: ahmet = Çalışan() print(ahmet.kabiliyetleri) Şimdiaynıkodlarıbirdeşöyleyazalım: class Çalışan(): def __init__(self): kabiliyetleri = [] (sonrakisayfayadevam) 39.8. __init__Fonksiyonuveself 773 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ahmet = Çalışan() print(ahmet.kabiliyetleri) Burada __init__() fonksiyonunda ilk parametre olarak self’i belirttik. Ama kabiliyetleri niteliğinin başına self eklemedik. Dolayısıyla yazdığımız kodlar yine hata verdi. Çünkü, ahmet.kabiliyetleri şeklinde ifade ettiğimiz kodlardaki ahmet kelimesini karşılayacak herhangibiröğesınıfiçindebulunmuyor... Bu arada, örnek isimlerini (mesela ahmet) yalnızca örnek niteliklerine erişmek için kullanmıyoruz. Bunları aynı zamanda sınıf niteliklerine erişmek için de kullanabiliyoruz. Dolayısıyla eğer yukarıdaki sınıf tanımı içinde, self.kabiliyetleri adlı örnek niteliği’nin yanısıra personeladlıbirsınıfniteliğidebulunsaydı: class Çalışan(): personel = [’personel’] def __init__(self): self.kabiliyetleri = [] Şukodlarıyazdığımızda: ahmet = Çalışan() print(ahmet.personel) ...o sınıf niteliğine erişebilirdik. Ancak eğer __init__() fonksiyonu altındaki kabiliyetleri niteliğineerişmekistiyorsak,buniteliğinbaşınaself kelimesinigetirerek,buniteliğibirörnek niteliği haline getirmeli ve böylece, ahmet.kabiliyetleri kodundaki ahmet kelimesini temsil edecekbiröğeyisınıfiçindeoluşturmalıyız. Busüreçtamolarakşöyleişler: Biz ahmet.kabiliyetleri şeklinde bir komut verdiğimizde, Python ilk olarak ilgili sınıfın __init__() fonksiyonu içinde kabiliyetleri adlı bir örnek niteliği arar. Elbette Python’ın bu örnek niteliğini bulabilmesi için, __init__() fonksiyonu içinde, bu fonksiyonun ilk parametresi ile aynı öneki taşıyan bir niteliğin yer alması gerekir. Yani eğer __init__() fonksiyonunun ilk parametresi self ise, Python bu fonksiyon içinde self.kabiliyetleri adlı bir örnekniteliğibulmayaçalışır.Eğerbulamazsa,Pythonbukezkabiliyetleriadlıbirsınıfniteliği arar.Eğeronudabulamazsatabiikihataverir... Gelinistersenizbumekanizmayıteyitedelim: class Çalışan(): kabiliyetleri = [’sınıf niteliği’] def __init__(self): self.kabiliyetleri = [’örnek niteliği’] Gördüğünüzgibi,buradaaynıadıtaşıyanbirsınıfniteliğiilebirörnekniteliğimizvar.Python’da hem sınıf niteliklerine, hem de örnek niteliklerine örnek isimleri üzerinden erişebileceğimizi söylemiştik. Yani eğer örneğimizin ismi ahmet ise, hem kabiliyetleri adlı sınıf niteliğine hem deself.kabiliyetleriadlıörnekniteliğineaynışekildeerişiyoruz: 774 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 ahmet = Çalışan() print(ahmet.kabiliyetleri) Pekiamaacabayukarıdakikodlarbizeörnekniteliğinimiverir,yoksasınıfniteliğinimi? Böyle bir durumda, yukarıda bahsettiğimiz mekanizma nedeniyle, self.kabiliyetleri şeklinde ifade ettiğimiz örnek niteliği, kabiliyetleri adlı sınıf niteliğini gölgeler. Bu yüzden de print(ahmet.kabiliyetleri) komutu, örnek niteliğini, yani self.kabiliyetleri listesini verir. Yukarıdaki kodları çalıştırarak siz de bu durumu teyit edebilirsiniz. Zira bu kodlar bize, self.kabiliyetlerilistesinindeğeriolan‘örnekniteliği’çıktısınıverecektir... Pekiyasizsınıfniteliğiolankabiliyetlerilistesineerişmekistersenizneolacak? İştebununiçin,sınıförneğinideğilde,sınıfadınıkullanacaksınız: class Çalışan(): kabiliyetleri = [’sınıf niteliği’] def __init__(self): self.kabiliyetleri = [’örnek niteliği’] #sınıf niteliğine erişmek için #sınıf adını kullanıyoruz print(Çalışan.kabiliyetleri) #örnek niteliğine erişmek için #örnek adını kullanıyoruz ahmet = Çalışan() print(ahmet.kabiliyetleri) Ancak elbette, aynı adı taşıyan bir sınıf niteliği ile bir örnek niteliğini aynı sınıf içinde tanımlamak daha baştan iyi bir fikir değildir, ama yazdığınız bir sınıf yanlışlıkla aynı ada sahip sınıf ve örnek nitelikleri tanımlamanız nedeniyle beklenmedik bir çıktı veriyorsa, siz Python’ınbuözelliğindenhaberdarolduğunuziçin,hatanınneredenkaynaklandığınıkolayca kestirebilirsiniz. Sözün kısası, Python’ın söz dizimi kuralları açısından, eğer bir örnek niteliği tanımlıyorsak, bu niteliğin başına bir self getirmemiz gerekir. Ayrıca bu self kelimesini de, örnek niteliğinin bulunduğu fonksiyonun parametre listesinde ilk sıraya yerleştirmiş olmalıyız. Unutmayın, örnek nitelikleri sadece fonksiyonlar içinde tanımlanabilir. Fonksiyon dışında örnek niteliği tanımlayamazsınız.Yanişöylebirşeyyazamazsınız: class Çalışan(): self.n = 0 def __init__(self): self.kabiliyetleri = [] Çünküselfkelimesiancakveancak,içindegeçtiğifonksiyonunparametrelistesindeilksırada kullanıldığındaanlamkazanır. Bu noktada size çok önemli bir bilgi verelim: Python sınıflarında örnek niteliklerini temsil etmesi için kullanacağınız kelimenin self olması şart değildir. Bunun yerine istediğiniz başka birkelimeyikullanabilirsiniz.Mesela: 39.8. __init__Fonksiyonuveself 775 PythonBelgeleri,Yayım4.1.3 class Çalışan(): def __init__(falanca): falanca.kabiliyetleri = [] Dediğimiz gibi, self kelimesi, bir sınıfın örneklerini temsil ediyor. Siz sınıf örneklerini hangi kelimenin temsil edeceğini kendiniz de belirleyebilirsiniz. Mesela yukarıdaki örnekte, __init__() fonksiyonunun ilk parametresini falanca olarak belirleyerek, örnek niteliklerinin falancakelimesiiletemsiledilmesinisağlamışolduk.Python’dabukonuyailişkinkuralşudur: Sınıf içindeki bir fonksiyonun ilk parametresi ne ise, o fonksiyon içindeki örnek niteliklerini temsiledenkelimedeodur.Örneğin,eğerşöylebirsınıftanımlamışsak: class XY(): def __init__(a, b, c): a.örnek_niteliği = [] Burada__init__()fonksiyonununilkparametresiaolduğuiçin,örnekniteliğinitemsileden kelimedeaolur.Dolayısıylaörnek_niteliğiadlıörnekniteliğimizinbaşınadaönekolarakbua kelimesinigetiriyoruz. __init__() fonksiyonunun ilk parametresi a olarak belirlendikten sonra, bu fonksiyon içindekibütünörneknitelikleri,önekolarakakelimesinialacaktır: class XY(): def __init__(a, b, c): a.örnek_niteliği1 = [] a.örnek_niteliği2 = 23 a.örnek_niteliği3 = ’’ ANCAK! Her ne sebeple olursa olsun, örnek niteliklerini temsil etmek için self dışında bir kelime kullanmayın. Python bu kelimeyi bize dayatmasa da, self kullanımı Python topluluğu içinde çok güçlü ve sıkı sıkıya yerleşmiş bir gelenektir. Bu geleneği kimse bozmaz. Siz de bozmayın. Sözünözü,tekbaşınaselfkelimesininhiçbiranlamınınolmadığınıaslaaklınızdançıkarmayın. Bu kelimenin Python açısından bir anlam kazanabilmesi için, ilgili fonksiyonun parametre listesindeilksıradabelirtiliyorolmasılazım.Zatenbuyüzden,dediğimizgibi,self kelimesinin Python açısından bir özelliği yoktur. Yani şöyle bir kod yazmamızın, Python söz dizimi açısındanhiçbirsakıncasıbulunmaz: class Çalışan(): def __init__(osman): osman.kabiliyetleri = [] ÇünküPython,örnekniteliklerinitemsiledenkelimeninneolduğuylaaslailgilenmez.Python için önemli olan tek şey, temsil işi için herhangi bir kelimenin belirlenmiş olmasıdır. Tabii, biz,dahaöncedeısrarlasöylediğimizgibi,örneknitelikleriniself dışındabirkelimeiletemsil etmeyeteşebbüsetmeyeceğizvekodlarımızışuşekildeyazmaktanşaşmayacağız: class Çalışan(): def __init__(self): self.kabiliyetleri = [] 776 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 İşte yukarıdaki kodda gördüğümüz self parametresi ve self öneki, birbirlerine bağımlı kavramlardır.Fonksiyonunilkparametresineise,örnekniteliklerininönekideoolacaktır. Bu arada, örnek niteliklerini anlatmaya başlamadan önce sınıf niteliklerine ilişkin sinsi bir durumdansözetmiştikhatırlarsanız.Bunagöre,eğerelimizdeşöylebirkodvarsa: class Çalışan(): kabiliyetleri = [] Biz bu sınıf içindeki kabiliyetleri listesine ekleme yaptığımızda, bu durum o sınıfın bütün örneklerinietkiliyordu. Yukarıdakikodlarıdeneme.pyadlıbirdosyayakaydettiğimizivarsayarsak: >>> import deneme >>> ahmet = deneme.Çalışan() >>> ahmet.kabiliyetleri.append(’konuşkan’) >>> ahmet.kabiliyetleri [’konuşkan’] >>> mehmet = deneme.Çalışan() >>> print(mehmet.kabiliyetleri) [’konuşkan’] İştebudurumuönlemekiçinörnekmetotlarındanyararlanabiliyoruz: class Çalışan(): def __init__(self): self.kabiliyetleri = [] Yukarıdakikodlarıyinedeneme.pyadlıbirdosyayakaydettiğimizivarsayarsak: >>> import deneme >>> ahmet = deneme.Çalışan() >>> ahmet.kabiliyetleri.append(’konuşkan’) >>> ahmet.kabiliyetleri [’konuşkan’] >>> mehmet = deneme.Çalışan() >>> print(mehmet.kabiliyetleri) [] Gördüğünüzgibi,ahmetörneğineeklediğimiz‘konuşkan’öğesi,olmasıgerektiğigibi,mehmet örneğindebulunmuyor.Birazdanbukonuüzerinebirkaçkelamdahaedeceğiz. 39.8. __init__Fonksiyonuveself 777 PythonBelgeleri,Yayım4.1.3 39.9 Örnek Metotları Buraya kadar sınıflar, örnekler, sınıf nitelikleri ve örnek nitelikleri konusunda epey bilgi edindik. Gelin şimdi isterseniz bu öğrendiklerimizi kullanarak az çok anlamlı bir şeyler yazmaya çalışalım. Böylece hem şimdiye kadar öğrendiklerimizi gözden geçirmiş ve pekiştirmiş oluruz, hem de bu bölümde ele alacağımız ‘örnek metotları’ (instance methods) kavramınıanlamamızkolaylaşır: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Sınıfımızı tanımladık. Gelin isterseniz bu kodları açıklamaya başlamadan önce nasıl kullanacağımızıgörelim. Bildiğiniz gibi, Python kodlarını test etmenin en iyi yolu, bunları etkileşimli kabuk üzerinde çalıştırmaktır.Özelliklebirprogramyazarken,tasarladığınızsınıfların,fonksiyonlarınveöteki öğelerindüzgünçalışıpçalışmadığınıtestetmekiçinetkileşimlikabuğusıklıklakullanacaksınız. Ohalde,yukarıdakikodlarıbarındırandosyanınbulunduğudizinaltındabiretkileşimlikabuk oturumu başlatalım ve dosya adının çalışan.py olduğunu varsayarak kodlarımızı bir modül şeklindeiçeaktaralım: >>> import çalışan Dahasonrasınıfımızınikifarklıörneğiniçıkaralım: >>> ç1 = çalışan.Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi (sonrakisayfayadevam) 778 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> ç2 = çalışan.Çalışan(’Mehmet’) Mehmet adlı kişi personele eklendi Bu şekilde çalışan adlı modül içindeki Çalışan() adlı sınıfı sırasıyla ‘Ahmet’ ve ‘Mehmet’ parametreleri ile çağırarak ç1 ve ç2 adlı iki farklı sınıf örneği oluşturmuş olduk. Bu arada, sınıfımızıörneklediğimizanda__init__()fonksiyonunundevreyegirdiğinedikkatediyoruz. personele_ekle() adlı fonksiyonu self.personele_ekle() şeklinde __init__() fonksiyonu içinden çağırdığımız için, sınıfımızı örneklediğimiz anda hem personelin kendisi personel listesineeklendi,hemdebukişininpersoneleeklendiğinedairbirmesajgösterildi. Tanımladığımızsınıfınniteliklerine,çıkardığımızörneklerüzerindenerişebiliriz: >>> ç1.isim ’Ahmet’ >>> ç2.isim ’Mehmet’ Yinebuörneklerüzerinden,buniteliklerideğiştirebilirizde: >>> ç1.isim = ’Mahmut’ >>> ç1.personel[0] = ’Mahmut’ Böyleceilkçalışanınismini‘Mahmut’olarakdeğiştirdik: >>> ç1.isim ’Mahmut’ >>> ç1.personel [’Mahmut’, ’Mehmet’] Tanımladığımız sınıf içindeki fonksiyonları kullanarak, çalışanlarımıza birkaç kabiliyet ekleyelim: >>> ç1.kabiliyet_ekle(’prezantabl’) >>> ç1.kabiliyet_ekle(’konuşkan’) ç1örneğininkabiliyetlerinigörüntüleyelim: >>> ç1.kabiliyetleri_görüntüle() Mahmut adlı kişinin kabiliyetleri: prezantabl konuşkan Şimdideç2örneğinebirkabiliyetekleyelimveeklediğimizkabiliyetigörüntüleyelim: 39.9. ÖrnekMetotları 779 PythonBelgeleri,Yayım4.1.3 >>> ç2.kabiliyet_ekle(’girişken’) >>> ç2.kabiliyetleri_görüntüle() Mehmet adlı kişinin kabiliyetleri: girişken Gördüğünüzgibi,birsınıförneğineeklediğimizkabiliyetötekisınıförneklerinekarışmıyor.Bu, örnekniteliklerininsınıfniteliklerindenönemlibirfarkıdır.Zirasınıfnitelikleribirsınıfınbütün örnekleri tarafından paylaşılır. Ama örnek nitelikleri her bir örneğe özgüdür. Bu özellikten birazsonradahaayrıntılıolaraksözedeceğiz.Bizşimdilikokumayadevamedelim. Sınıförneklerimizinherhangibiriüzerindenpersonellistesinedeulaşabileceğimizibiliyoruz: >>> ç1.personeli_görüntüle() Personel listesi: Mahmut Mehmet Gayetgüzel... Yukarıda anlattıklarımız sınıflar hakkında size epey fikir vermiş olmalı. Konuyu daha da derinlemesineanlayabilmekiçin,artıkbusınıfıincelemeyegeçebiliriz. Sınıfımızıönümüzealalım: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Buradaöncelikleherzamankigibisınıfımızıtanımlıyoruz: 780 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 class Çalışan(): ... Dahasonrabusınıfapersoneladlıbirsınıfniteliğiekliyoruz: class Çalışan(): personel = [] Sınıf niteliklerinin özelliği, o sınıfın bütün örnekleri tarafından paylaşılıyor olmasıdır. Yani herhangi bir örneğin bu nitelik üzerinde yaptığı değişiklik, öteki örneklere de yansıyacaktır. Helebirdebusınıfniteliği,listelergibideğiştirilebilir(mutable)birveritipiise,budurumhiçde istemediğinizsonuçlardoğurabilir.Bununlailgilibir örneğiyukarıdavermiştik.Hatırlarsanız, kabiliyetleri adlı, liste veri tipinde bir sınıf niteliği oluşturduğumuzda, bu listeye eklediğimiz öğeler,hiçistemediğimizhaldeöbürörnekleredesirayetediyordu.Elbette,sınıfniteliklerinin bu özelliği, o anda yapmaya çalıştığınız şey açısından gerekli bir durum da olabilir. Mesela yukarıdaki kodlarda, listelerin ve sınıf niteliklerinin bu özelliği bizim amacımıza hizmet ediyor. Yukarıdaki sınıfı çalıştırdığımızda, eklenen her bir kişiyi bu personel listesine ilave edeceğiz. Dolayısıyla bu nitelik üzerinde yapılan değişikliklerin bütün örneklere yansıması bizimistediğimizbirşey. Neyse... Lafı daha fazla uzatmadan, kodlarımızı açıklamaya kaldığımız yerden devam edelim... Sınıfımızı ve sınıf niteliğimizi tanımladıktan sonra __init__() adlı özel fonksiyonumuzu oluşturuyoruz: def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() Bu fonksiyonun özelliği, sınıfın örneklenmesi ile birlikte otomatik olarak çalıştırılacak olmasıdır. Biz burada, self.isim ve self.kabiliyetleri adlı iki adet örnek niteliği tanımladık. Bu örnekniteliklerinesınıfımızınhertarafındanerişebileceğiz. Yukarıda,tanımladığımızsınıfınasılkullanacağımızıgösterirken,Çalışan()sınıfınışuşekilde örneklediğimizihatırlıyorsunuz: >>> ç1 = çalışan.Çalışan(’Ahmet’) Burada sınıfımızı ‘Ahmet’ adlı bir argümanla örneklediğimize dikkatinizi çekmek isterim. İşte bu argüman, biraz önce __init__() fonksiyonunu tanımlarken belirttiğimiz isim parametresine karşılık geliyor. Dolayısıyla, bir sınıfı çağırırken/örneklerken kullanacağımız argümanları,bu__init__()fonksiyonununparametreleriolaraktanımlıyoruz. Dahasonrabuisimparametresini,__init__()fonksiyonunungövdesiiçindebirörnekniteliği halinegetiriyoruz: self.isim = isim Bunu yapmamızın gerekçesi, isim parametresini sınıfımızın başka bölgelerinde de kullanabilmek. self kelimesini parametremizin başına yerleştirerek, bu parametreyi sınıfın başkayerlerindendeerişilebilirhalegetiriyoruz. 39.9. ÖrnekMetotları 781 PythonBelgeleri,Yayım4.1.3 isim parametresini, self.isim kodu yardımıyla bir örnek niteliğine dönüştürdükten sonra self.kabiliyetleri adlı bir başka örnek niteliği daha tanımlıyoruz. Bu liste, sınıf örneklerine eklediğimizkabiliyetleritutacak. Bununardındanşöylebirkodgörüyoruz: self.personele_ekle() Burada, personele_ekle() adlı bir örnek metoduna (instance method) atıfta bulunuyoruz. Örnekmetotları,birsınıfınörneklerivasıtasıylaçağrılabilenfonksiyonlardır.Bufonksiyonların ilk parametresi her zaman self kelimesidir. Ayrıca bu fonksiyonlara sınıf içinde atıfta bulunurkendeyineself kelimesinikullanıyoruz.Tıpkıyukarıdakiörnekteolduğugibi... Bir örnek metodu olduğunu söylediğimiz personele_ekle() fonksiyonunu şu şekilde tanımladık: def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) Burada, bir sınıf niteliği olan personel değişkenine nasıl eriştiğimize çok dikkat etmenizi istiyorum. Daha önce de söylediğimiz gibi, sınıf niteliklerine sınıf dışındayken örnekler üzerinden erişebiliyoruz. self kelimesi, bir sınıfın örneklerini temsil ettiği için, bir sınıf niteliğinesınıfiçindenerişmemizgerektiğindeself kelimesinikullanabiliriz. Sınıf niteliklerine, örnekler dışında, sınıf adıyla da erişebileceğinizi biliyorsunuz. Dolayısıyla istersenizyukarıdakikodlarışöyledeyazabilirdiniz: def personele_ekle(self): Çalışan.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) Bir öncekinden farklı olarak, bu defa sınıf niteliğine doğrudan sınıf adını (Çalışan) kullanarak eriştik. Ayrıca bu fonksiyonda, bir örnek niteliği olan self.isim değişkenine de erişebiliyor olduğumuza dikkat edin. Unutmayın, self sınıfların çok önemli bir öğesidir. Bu öğeyi kullanarak hem örnek niteliklerine, hem sınıf niteliklerine, hem de örnek metotlarına ulaşabiliyoruz. Tanımladığımız bu personele_ekle() adlı örnek metodunu __init__() fonksiyonu içinden self.personele_ekle() kodu ile (yani yine self kelimesini kullanarak) çağırdığımızıhatırlıyorsunuz. personele_ekle()fonksiyonununardındanarkaarkayaüçfonksiyondahatanımladık: def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) (sonrakisayfayadevam) 782 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Bu fonksiyonlar da, tıpkı personele_ekle() gibi, birer örnek metodudur. Bu örnek metotlarının da ilk parametrelerinin hep self olduğuna dikkat ediyoruz. Örnek metotlarına sınıfdışındanörnekisimleri(ahmet,mehmetgibi)aracılığıyla,sınıfiçindenise,örnekisimlerini temsiledenself kelimesiaracılığıylaeriştiğimizibiliyorsunuz. Şimdibirduralım... Bu noktaya kadar epey konuştuk, epey örnek verdik. Sınıflar hakkında yeterince bilgi sahibi olduğumuza göre, nihayet en başta verdiğimiz harf sayacı kodlarını rahatlıkla anlayabilecek düzeyeeriştik: class HarfSayacı: def __init__(self): self.sesli_harfler = ’aeıioöuü’ self.sessiz_harfler = ’bcçdfgğhjklmnprsştvyz’ self.sayaç_sesli = 0 self.sayaç_sessiz = 0 def kelime_sor(self): return input(’Bir kelime girin: ’) def seslidir(self, harf): return harf in self.sesli_harfler def sessizdir(self, harf): return harf in self.sessiz_harfler def artır(self): for harf in self.kelime: if self.seslidir(harf): self.sayaç_sesli += 1 if self.sessizdir(harf): self.sayaç_sessiz += 1 return (self.sayaç_sesli, self.sayaç_sessiz) def ekrana_bas(self): sesli, sessiz = self.artır() mesaj = "{} kelimesinde {} sesli {} sessiz harf var." print(mesaj.format(self.kelime, sesli, sessiz)) def çalıştır(self): self.kelime = self.kelime_sor() self.ekrana_bas() if __name__ == ’__main__’: sayaç = HarfSayacı() sayaç.çalıştır() 39.9. ÖrnekMetotları 783 PythonBelgeleri,Yayım4.1.3 Gelinistersenizbukodlaradaşöylebirbakalım... Buradasınıfımızışuşekildetanımladık: class HarfSayacı: ... Sınıfadınıparantezlibirşekildeyazabileceğimizidebiliyorsunuz: class HarfSayacı(): ... Dahasonra,__init__()fonksiyonuiçindedörtadetörnekniteliğitanımladık: self.sesli_harfler = ’aeıioöuü’ self.sessiz_harfler = ’bcçdfgğhjklmnprsştvyz’ self.sayaç_sesli = 0 self.sayaç_sessiz = 0 Bunların birer örnek niteliği olduğunu, başlarına getirdiğimiz self kelimesinden anlıyoruz. Çünkübildiğinizgibi,self kelimesi,ilgilisınıfınörneklerinitemsilediyor.Birsınıfiçindeörnek niteliklerineveörnekmetotlarınahepbuself kelimesiaracılığıylaerişiyoruz. Busınıfiçinde,ilkparametreleriself olanşuörnekmetotlarınıgörüyoruz: def kelime_sor(self): ... def seslidir(self, harf): ... def sessizdir(self, harf): ... def artır(self): ... def ekrana_bas(self): ... def çalıştır(self): ... Sınıfla birlikte bütün örnek değişkenlerini ve örnek metotlarını tanımladıktan sonra programımızıçalıştırmaaşamasınageliyoruz: if __name__ == ’__main__’: sayaç = HarfSayacı() sayaç.çalıştır() Bunagöre,eğerprogramımızbağımsızolarakçalıştırılıyorsaöncelikleHarfSayacı()adlısınıfı örneklendiriyoruz: 784 Bölüm39. NesneTabanlıProgramlama(OOP) PythonBelgeleri,Yayım4.1.3 sayaç = HarfSayacı() Daha sonra da sayaç örneği üzerinden HarfSayacı() adlı sınıfın çalıştır() metoduna erişerekprogramımızıbaşlatıyoruz. Böylece, Python’da nesne tabanlı programlama ve sınıflara dair öğrenmemiz gereken bütün temelbilgileriedinmişolduk.Şuanakadaröğrendiklerinizsayesinde,etraftagöreceğinizsınıflı kodların büyük bölümünü anlayabilecek durumdasınız. Bir sonraki bölümde, nesne tabanlı programlamanınayrıntılarınainmeyebaşlayacağız. 39.9. ÖrnekMetotları 785 40 BÖLÜM Nesne Tabanlı Programlama (Devamı) Geçen bölümde Python’da nesne tabanlı programlama konusunun temellerinden söz etmiştik.Bubölümdeisenesnetabanlıprogramlamanınayrıntılarınainmeyebaşlayacağız. 40.1 Sınıf Metotları Nesnetabanlıprogramlamayagirişyaptığımızgeçenbölümdeşunlaradeğindik: 1. Sınıflar(classes) 2. Örnekler(instances) 3. Sınıfnitelikleri(classattributes) 4. Örneknitelikleri(instanceattributes) 5. Örnekmetotları(instancemethods) Bunlar nesne tabanlı programlamanın en temel kavramlarıdır. Bunları iyice öğrendiyseniz, etraftagördüğünüzkodlarınbüyükbölümünüanlayabilecekkıvamagelmişsinizdemektir. Ama elbette nesne tabanlı programlama yalnızca bu temel kavramlardan ibaret değil. Nesnetabanlıprogramlamanınderinlerineindikçe,bunlarındışındabaşkapekçokkavramla daha karşılaşacağız. Mesela sınıf metotları (class methods) bu kavramlardan biridir. İşte bu bölümde, nesne tabanlı programlamanın ileri düzey kavramlarının ilki olan bu sınıf metotlarından(classmethods)sözedeceğiz. Dilerseniz ne ile karşı karşıya olduğumuzu anlayabilmek için basit bir örnek üzerinden ilerleyelim. Hatırlarsanızbiröncekibölümdeşöylebirkodparçasıvermiştik: class Çalışan(): personel = [] (sonrakisayfayadevam) 786 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Bu kodlarda, bir personel listesi oluşturmamızı, personele ekleme yapmamızı, personeli görüntülememizi, personele yeni kabiliyet eklememizi ve eklediğimiz kabiliyetleri görüntüleyebilmemizi sağlayan örnek metotları var. Gelin bu kodlara bir de personel sayısınıgörüntülememizisağlayacakbirbaşkaörnekmetodudahaekleyelim: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personel_sayısını_görüntüle(self): print(len(self.personel)) def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) (sonrakisayfayadevam) 40.1. SınıfMetotları 787 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Burada yeni olarak personel_sayısını_görüntüle() adlı bir örnek metodu tanımladık. Bu metot, bir sınıf niteliği olan personel’e erişerek bunun uzunluğunu ekrana basıyor. Böylece personelinkaçkişidenoluştuğunuöğrenmişoluyoruz. Buyeniörnekmetodunuaşağıdakişekildekullanabiliriz. Önceliklekodlarımızıbarındıranmodülüiçeaktaralım: >>> import çalışan Dahasonrapersonellistesinebirkaççalışanekleyelim: >>> ahmet = çalışan.Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi >>> mehmet = çalışan.Çalışan(’Mehmet’) Mehmet adlı kişi personele eklendi >>> ayşe = çalışan.Çalışan(’Ayşe’) Ayşe adlı kişi personele eklendi Artıkherhangibirörnekdeğişkeniüzerindenpersonelsayısınaerişebiliriz: >>> ayşe.personel_sayısını_görüntüle() 3 Ancak kodların çalışma mantığı açısından burada bir tutarsızlıktan söz edebiliriz. Genel olarak bütün personele dair bilgi veren bir fonksiyona ahmet, mehmet, ayşe gibi bireysel örnek değişkenleri üzerinden erişmek kulağa sizce de biraz tuhaf gelmiyor mu? Neticede bu fonksiyon, aslında sınıfın herhangi bir örneği ile özellikle veya doğrudan ilişkili değil. Yani bu fonksiyon tek tek sınıf örneklerini değil, genel olarak sınıfın bütününü ilgilendiriyor. Bu bakımdan, personel_sayısını_görüntüle() fonksiyonunun örnek değişkenlerinden bağımsızbirbiçimdekullanılabilmesiçokdahamantıklıolacaktır. Ayrıca, bir örnek metodu olan personel_sayısını_görüntüle() fonksiyonunu örneklerden bağımsız olarak kullanamadığımız için, bu metot yardımıyla personel sayısının 0 olduğu bir durumu görüntülememiz de mümkün olmuyor. Çünkü bu fonksiyona erişebilmek için önceliklesınıfıenazbirkezörneklemiş,yanisınıfınenazbiradetörneğiniçıkarmışolmamız gerekiyor.Budurumdakodlarımızınmantığıaçısındansonderececiddibirkısıtlamadır. Yukarıdasıralanangerekçelerdoğrultusundakodlarıhemdahatutarlıbirhalegetirmekhem de personel sayısının 0 olduğu durumu göstermemizi engelleyen kısıtlamayı aşabilmek için şöylebirşeydeneyebilirsiniz: 788 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 def personel_sayısını_görüntüle(): print(len(Çalışan.personel)) class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Burada personel sayısını görüntüleyen fonksiyonu sınıftan ayırdık. Böylece şu şekilde bir kullanımmümkünolabildi: >>> import çalışan >>> çalışan.personel_sayısını_görüntüle() 0 personel_sayısını_görüntüle()adlıfonksiyonusınıftanayırıpmodüldüzeyindeçalışanbir fonksiyon (veya bir başka deyişle global düzeyde çalışan bir fonksiyon) haline getirdiğimiz için,artıkbufonksiyonÇalışan()sınıfınınherhangibirörneğinebağımlıdeğil.Dolayısıylabu fonksiyonu, Çalışan() sınıfı için bir örnek çıkarmak zorunda kalmadan da kullanabiliyoruz. Budabizepersonelsayısının0olduğudurumugösterebilmeimkanıtanıyor. Bufonksiyonubirdebirkaçörnekçıkardıktansonraçalıştıralım... Öncesınıfımızınbirkaçörneğiniçıkaralım: >>> ahmet = çalışan.Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi >>> ayşe = çalışan.Çalışan(’Ayşe’) (sonrakisayfayadevam) 40.1. SınıfMetotları 789 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Ayşe adlı kişi personele eklendi >>> mehmet = çalışan.Çalışan(’Mehmet’) Mehmet adlı kişi personele eklendi Şimdidepersonelinşuandakaçkişidenoluştuğunusorgulayalım: >>> çalışan.personel_sayısını_görüntüle() 3 Gördüğünüz gibi, bu şekilde kodlarımız biraz daha tutarlı bir görünüme kavuştu. Ancak bu şekilde, bariz bir biçimde Çalışan() sınıfı ile ilişkili olan personel_sayısını_görüntüle() fonksiyonunu sınıftan ayırmış ve kod bütünlüğünü bozmuş olduk. Çünkü, her ne kadar personel_sayısını_görüntüle()fonksiyonuÇalışan()sınıfınınherhangibirörneğiileilişkili olmasa da, anlam açısından bu fonksiyonun Çalışan() sınıfına ait olduğu besbelli. Ayrıca, yukarıdaki kodları barındıran modülün tamamını değil de, from çalışan import Çalışan gibi bir komutla yalnızca Çalışan() sınıfını içe aktarırsak, personel_sayısını_görüntüle() fonksiyonudışarıdakalacaktır: >>> from çalışan import Çalışan >>> dir() Gördüğünüzgibi,personel_sayısını_görüntüle()fonksiyonulistedeyok.Dolayısıyla,sınıfla sıkı sıkıya ilişkili olan bu fonksiyonu sınıftan kopardığımız için, seçmeli içe aktarmalarda bu fonksiyongeridekalıyorveböylecebufonksiyonukullanamazhalegeliyoruz. Seçmeli içe aktarmalarda bu fonksiyon aktarım işlemiyle birlikte gelmediği için, ilgili fonksiyonuözelolarakiçeaktarmamızgerekir: >>> from çalışan import personel_sayısını_görüntüle Bu şekilde çalışan modülü içinden personel_sayısını_görüntüle() adlı fonksiyonu özel olarakelleiçeaktarmışolduk.Artıkbufonksiyonuşöylekullanabiliriz: >>> personel_sayısını_görüntüle() Ancak bu da, her zaman tercih etmeyeceğiniz bir kısıtlama olabilir. O halde bu kısıtlamayı aşmakiçingelin,ilgilifonksiyonutekrarsınıfiçinealalım: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() def personel_sayısını_görüntüle(self): (sonrakisayfayadevam) 790 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(len(self.personel)) def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Yukarıdakikodlardailgilifonksiyonabirörnekadıyladeğilde,sınıfadıylaerişmekiçinilketapta şukodudenemekaklınızagelmişolabilir: >>> from çalışan import Çalışan >>> Çalışan.personel_sayısını_görüntüle() Ancakbukodsizeşöylebirhatamesajıverir: Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: personel_sayısını_görüntüle() missing 1 required positional argument: ’self’ Çünkü burada siz Çalışan.personel_sayısını_görüntüle() komutunu vererek aslında sınıfın bir metoduna (class method) erişmeye çalışıyorsunuz. Ancak kodlarımızın içinde bir sınıf metodu yok. Zira, yukarıda sınıf adıyla erişmeye çalıştığımız personel_sayısını_görüntüle() fonksiyonu bir sınıf metodu değil, bir örnek metodudur. Örnek metotlarına da sınıf adlarıyla erişmemizin mümkün olmadığını, bu tür metotlara erişebilmekiçinsınıfıenazbirkezörneklemişolmamızgerektiğinibiliyorsunuz. Burada, __init__() ve personel_sayısını_görüntüle() dışında şu örnek metotları var: personel_sayısını_görüntüle(), personele_ekle(), personeli_görüntüle(), kabiliyet_ekle(), kabiliyetleri_görüntüle(). Bunları birer örnek metodu yapan şeyin, self kelimesiolduğunubiliyoruz... Daha önce de söylediğimiz gibi, her ne kadar Python’da sınıf niteliklerine hem örnekler hem de doğrudan sınıf adları üzerinden erişebilsek de örnek niteliklerine ve örnek metotlarına yalnızcaörneklerüzerindenerişebiliriz.Birmetoda,sınıfadıileerişebilmekiçin,ilgilimetodu birsınıfmetoduolaraktanımlamışolmamızgerekir.Pekiamanasıl? 40.1. SınıfMetotları 791 PythonBelgeleri,Yayım4.1.3 40.2 @classmethod Bezeyicisi ve cls Bildiğiniz gibi, örnek metotlarını oluşturmak için self adlı bir kelimeden yararlanıyorduk. Tanımladığımızörnekmetotlarınınparametrelistesindeilksırayayerleştirdiğimizbukelimeyi kullanarak,sınıfiçindeörnekmetotlarınaerişebiliyoruz.İştesınıfmetotlarıiçindebenzerbir işlemyapacağız. Çokbasitbirörnekverelim: class Sınıf(): sınıf_niteliği = 0 def __init__(self, param1, param2): self.param1 = param1 self.param2 = param2 self.örnek_niteliği = 0 def örnek_metodu(self): self.örnek_niteliği += 1 return self.örnek_niteliği def sınıf_metodu(cls): cls.sınıf_niteliği += 1 return cls.sınıf_niteliği Burada örnek_metodu() ile sınıf_metodu() arasındaki fark, ilkinde self, ikincisinde ise cls kullanmamız.Ancakhatırlarsanız,selfkelimesininPythonaçısındanbirzorunlulukolmadığını söylemiştik. Tıpkı self gibi, aslında cls kelimesi de Python açısından bir zorunluluk değildir. Yaniclsyerinedeistediğimizkelimeyikullanabilirdik.Bumetotlardaönemliolan,parametre listesininilksırasınıişgaledenkelimeninneolduğudur.DolayısıylayukarıdakiörnektePython açısından örnek_metodu() ile sınıf_metodu() arasında hiçbir fark bulunmaz. Python her iki metodu da birer örnek metodu olarak değerlendirir. Bu iki örnek metodu arasındaki fark, ilkinde sınıf örneklerini temsil edecek kelimenin self, ikincisinde ise cls olarak belirlenmiş olmasıdır. Python self veya cls kelimelerine özel bir önem atfetmez. Ama Python topluluğu içinde,örnekmetotlarıiçinself,sınıfmetotlarıiçiniseclskullanmakçokgüçlübirgelenektir. Sözünözü,sınıf_metodu()fonksiyonununilkparametresiniclsyapmışolmamızbumetodun bir sınıf metodu olabilmesi için gereklidir, ama yeterli değildir. Python’da bir sınıf metodu oluşturabilmekiçinbirparçayadahaihtiyacımızvar: class Sınıf(): sınıf_niteliği = 0 def __init__(self, param1, param2): self.param1 = param1 self.param2 = param2 self.örnek_niteliği = 0 def örnek_metodu(self): self.örnek_niteliği += 1 return self.örnek_niteliği (sonrakisayfayadevam) 792 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) @classmethod def sınıf_metodu(cls): cls.sınıf_niteliği += 1 return cls.sınıf_niteliği İşte Python’da bir sınıf metodunu örnek metodundan ayıran asıl öğe, yukarıdaki örnekte gördüğümüz @classmethod ifadesidir. Python’da isminin önünde @ işareti olan bu tür öğelere ‘bezeyici’ (decorator) adı verilir. Gördüğünüz gibi, @classmethod bezeyicisi, yukarıdaki örnekte bir fonksiyonu sınıf metoduna dönüştürme işlevi görüyor. İlerleyen derslerimizde bezeyicilerin başka özelliklerinden de söz edeceğiz. Gelin isterseniz şimdi yukarıdaöğrendiğimizözelliğiÇalışan()adlısınıfauygulayalım: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() @classmethod def personel_sayısını_görüntüle(cls): print(len(cls.personel)) def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Yukarıda personel_sayısını_görüntüle() adlı fonksiyonun yanı sıra, personeli_görüntüle() adlı fonksiyonu da bir sınıf metodu haline getirdik. Çünkü tıpkı personel_sayısını_görüntüle() fonksiyonu gibi, personeli_görüntüle() fonksiyonu da aslındatektekörneklerdenziyadesınıfıngeneliniilgilendiriyor.Dolayısıylabufonksiyonada sınıfadıüzerindenerişebilmekgayetmakulvemantıklıbiriştir. Sınıf metotlarımızı başarıyla tanımladığımıza göre artık yukarıdaki sınıfı şu şekilde kullanabiliriz: 40.2. @classmethodBezeyicisivecls 793 PythonBelgeleri,Yayım4.1.3 >>> from çalışan import Çalışan >>> Çalışan.personel_sayısını_görüntüle() 0 Birsınıfmetoduolaraktanımladığımızpersonel_sayısını_görüntüle()fonksiyonuartıkilgili sınıfın herhangi bir örneğine bağımlı olmadığı için, sınıfı örneklemek zorunda kalmadan, yalnızca sınıf adını kullanarak personel_sayısını_görüntüle() fonksiyonuna erişebiliyoruz. Budabizepersonelsayısının0olduğudurumugörüntüleyebilmeimkanıveriyor... Ayrıca, personel_sayısını_görüntüle() adlı sınıf metodumuz, fiziksel olarak da sınıfın içinde yer aldığı için, seçmeli içe aktarmalarda sınıfın öteki öğeleriyle birlikte bu metot da aktarılacaktır: >>> from çalışan import Çalışan >>> dir(Çalışan) Listedesınıfmetodumuzundaolduğunugörüyorsunuz. Personeleüyeeklediktensonrabumetodunasılkullanacağımızıbiliyorsunuz: >>> ahmet = Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi >>> mehmet = Çalışan(’Mehmet’) Mehmet adlı kişi personele eklendi >>> ayşe = Çalışan(’Ayşe’) Ayşe adlı kişi personele eklendi >>> Çalışan.personel_sayısını_görüntüle() 3 Gördüğünüzgibi,sınıfmetodumuzadoğrudansınıfadınıkullanarakerişebiliyoruz.Elbettebu durum,sınıfmetodunaörnekadlarıüzerindendeerişmemizeengeldeğil.Eğerarzuedersek personel_sayısını_görüntüle()adlısınıfmetodunuşuşekildedeçağırabiliriz: >>> ayşe.personel_sayısını_görüntüle() 3 >>> ahmet.personel_sayısını_görüntüle() 3 >>> mehmet.personel_sayısını_görüntüle() 3 794 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Ancakörnekmetotlarınaveörnekniteliklerineatıftabulunmakiçinörnekadlarınıkullanmak, sınıf metotları ve sınıf niteliklerine atıfta bulunmak için ise sınıf adlarını tercih etmek daha akıllıcaolabilir. personel_sayısını_görüntüle() fonksiyonu için söylediğimiz bu sözler, personeli_görüntüle()fonksiyonuiçindeaynengeçerlidir. Sözünözü,sınıfınherhangibirörneğinebağlıolmayanbirişlemyapan,amaanlamsalolarak da sınıfla ilişkili olduğu için sınıf dışında bırakmak istemediğiniz fonksiyonları birer sınıf metoduolaraktanımlayabilirsiniz. 40.3 Alternatif İnşacılar Sınıf metotlarının, işimize yarayabilecek bir başka özelliği ise, bunların bir ‘alternatif inşacı’ (alternative constructor) olarak kullanılabilecek olmasıdır. “Alternatif neyci?” diye sorduğunuzurahatlıkladuyabiliyorum... Gelin isterseniz ‘alternatif inşacı’ kavramını bir dizi örnek üzerinde kabataslak da olsa açıklamayaçalışalım. Şimdielinizdeşöylebirkitaplistesiolduğunudüşünün: liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi Vadetmedim’, ’Metis’), (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] Bu liste, her bir kitap için, sırasıyla o kitabın ISBN numarasını, yazarını, ismini ve yayınevini gösteren birer demetten oluşuyor. Amacımız, bu listeden çeşitli ölçütlere göre sorgulama yapabilen bir program yazmak. Yazdığımız program; isbn, isim, eser ve yayınevi ölçütlerine görebulistedenverialabilmemizisağlayacak. İlkdenememiziyapalım: liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi Vadetmedim’, ’Metis’), (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] def sorgula(ölçüt=None, değer=None): for li in liste: if not ölçüt and not değer: print(*li, sep=’, ’) elif ölçüt == ’isbn’: if değer == li[0]: print(*li, sep=’, ’) elif ölçüt == ’yazar’: if değer == li[1]: print(*li, sep=’, ’) elif ölçüt == ’eser’: if değer == li[2]: (sonrakisayfayadevam) 40.3. Alternatifİnşacılar 795 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(*li, sep=’, ’) elif ölçüt == ’yayınevi’: if değer == li[3]: print(*li, sep=’, ’) Buradaönceliklekitaplistemizitanımladık.Dahasonradasorgulamaişleminigerçekleştirecek sorgula()adlıbirfonksiyonyazdık. Bu fonksiyon toplam iki parametre alıyor: ölçüt ve değer. Bu parametrelerin öntanımlı değerlerini None olarak belirledik. Böylece bu fonksiyonu herhangi bir argüman vermeden deçalıştırabileceğiz. Fonksiyon gövdesinde ilk yaptığımız iş, fonksiyon argümansız çalıştırıldığında, yani ölçüt ve değeriçinherhangibirdeğerbelirlenmediğindeneolacağınıayarlamak: for li in liste: if not ölçüt and not değer: print(*li, sep=’, ’) Eğer ölçüt ve değer parametreleri için herhangi bir değer belirtilmemişse, yani bunlar None olarak bırakılmışsa, kitap listesinin tamamını, her bir öğe arasına birer virgül yerleştirerek ekranabasıyoruz. Eğer sorgula() fonksiyonu çağrılırken ölçüt parametresine ‘isbn’ argümanı, değer parametresineisebirISBNdeğeriverilmişseşuişlemiyapıyoruz: elif ölçüt == ’isbn’: if değer == li[0]: print(*li, sep=’, ’) Burada yaptığımız şey şu: Eğer ölçüt ‘isbn’ ise, fonksiyona verilen değer argümanını, kitap listesi içindeki her bir demetin ilk sırasında arıyoruz. Çünkü ISBN bilgileri demetlerin ilk sırasındayeralıyor.Eğerbukoşulsağlanırsalisteninilgilikısmınıekranabasıyoruz: if değer == li[0]: print(*li, sep=’, ’) Bumantığıkullanarakötekiölçütleriçindebirersorgukoduyazıyoruz: elif ölçüt == ’yazar’: if değer == li[1]: print(*li, sep=’, ’) elif ölçüt == ’eser’: if değer == li[2]: print(*li, sep=’, ’) elif ölçüt == ’yayınevi’: if değer == li[3]: print(*li, sep=’, ’) 796 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Her bir değer’i, listenin ilgili sırasında aradığımıza dikkat edin. Yazar bilgisi demetlerin ikinci sırasında yer aldığı için li[1]’i, aynı gerekçeyle eser için li[2]’yi, yayınevi için ise li[3]’ü sorguluyoruz. Gelelimbufonksiyonunasılkullanacağımıza... Her zaman söylediğimiz gibi, Python’ın etkileşimli kabuğu mükemmel bir test ortamıdır. O halde şimdi bu kodları klist.py adlı bir dosyaya kaydedelim ve dosyanın bulunduğu dizinde biretkileşimlikabukoturumubaşlatarakmodülümüzüiçeaktaralım: >>> import klist Önceklistmodülüiçindekisorgula()fonksiyonunuargümansızolarakçağıralım: >>> klist.sorgula() 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem Tamdabeklediğimizgibi,fonksiyonargümansızçağrıldığındabütünkitaplistesini,herbiröğe arasındabirvirgülolacakşekildeekranabasıyor. ŞimdidemeselaISBNnumarasınagörebirkaçsorguişlemigerçekleştirelim: >>> klist.sorgula(’isbn’, ’9789754060409’) 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt , Cem >>> klist.sorgula(’isbn’, ’975872519X’) 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki >>> klist.sorgula(’isbn’, ’9789753424080’) 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis Burada, sorgula() fonksiyonunun ilk parametresine argüman olarak ‘isbn’ değerini verdik. BöyleceprogramımızISBNnumarasınagöresorguyapmakistediğimizianladı.Dahasonrada ikinciargümanolarakistediğimizbirISBNnumarasınıyazdıkvesorguişleminitamamladık. Birdeyayınevinegöresorgulamayapalım: >>> klist.sorgula(’yayınevi’, ’Metis’) 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis >>> klist.sorgula(’yayınevi’, ’İthaki’) 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki >>> klist.sorgula(’yayınevi’, ’Cem’) 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem 40.3. Alternatifİnşacılar 797 PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,fonksiyonumuzgayetgüzelçalışıyor... Yukarıdaverdiğimizkodlar,bahsettiğimizamaçiçinyazılabilecektekalternatifdeğildirelbette. Mesela yukarıdaki if-else yapısını bir sözlük içine yerleştirerek çok daha sade bir program eldeedebiliriz. Dikkatliceinceleyin: liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi Vadetmedim’, ’Metis’), (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] def sorgula(ölçüt=None, değer=None): d = {’isbn’ : [li for li in liste if değer == li[0]], ’yazar’ : [li for li in liste if değer == li[1]], ’eser’ : [li for li in liste if değer == li[2]], ’yayınevi’ : [li for li in liste if değer == li[3]]} for öğe in d.get(ölçüt, liste): print(*öğe, sep = ’, ’) Burada bütün if-else cümleciklerini birer liste üretecine dönüştürüp, d adlı sözlüğün anahtarları olarak belirledik. Artık sorgulama işlemlerini bir if-else yapısı içinde değil de, birsözlükiçindengerçekleştireceğiz. Hangi parametrenin hangi listeyi çağıracağını belirleyen sözlüğümüzü yazdıktan sonra, sözlüklerin get() metodunu kullanarak, ölçüt argümanının değerine göre sözlükten veri çekiyoruz.Eğersözlüktebulunmayanbirölçütdeğeriverilirsetümlisteyiekranabasıyoruz. Buarada,eğerdsözlüğüiçindekilisteüreteçlerininbirbirinitekrarederbiryapıdaolmasısizi rahatsızediyorsa,bukısmıbiryardımcıfonksiyonaracılığıylasadeleştirebilirsiniz: liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi Vadetmedim’, ’Metis’), (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] def bul(değer, sıra): return [li for li in liste if değer == li[sıra]] def sorgula(ölçüt=None, değer=None): d = {’isbn’ : bul(değer, 0), ’yazar’ : bul(değer, 1), ’eser’ : bul(değer, 2), ’yayınevi’ : bul(değer, 3)} for öğe in d.get(ölçüt, liste): print(*öğe, sep = ’, ’) Burada bütün liste üreteçlerini tek bir bul() fonksiyonu içinde oluşturarak, sorgula() fonksiyonuiçindekidsözlüğünegönderdik. Bukodlarıdaaynıilkprogramörneğindeolduğugibikullanıyoruz: 798 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 >>> import klist >>> klist.sorgula() 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem >>> klist.sorgula(’yazar’, ’Nietzsche’) 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem >>> klist.sorgula(’eser’, ’Sana Gül Bahçesi Vadetmedim’) 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis Yukarıdaki kodları yazmanın daha başka alternatifleri de var. Mesela, eğer arzu ederseniz, yukarıdakikodlarıbirsınıfyapısıiçindedeifadeedebilirsiniz: class Sorgu(): def __init__(self): self.liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi␣ Vadetmedim’, ’Metis’), ˓→ (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), ˓→ (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] ˓→ def bul(self, değer, sıra): return [li for li in self.liste if değer == li[sıra]] def sorgula(self, ölçüt=None, değer=None): d = {’isbn’ : self.bul(değer, 0), ’yazar’ : self.bul(değer, 1), ’eser’ : self.bul(değer, 2), ’yayınevi’ : self.bul(değer, 3)} for öğe in d.get(ölçüt, self.liste): print(*öğe, sep = ’, ’) Burada kitap listesini bir örnek niteliği olarak tanımlamak suretiyle sınıfın her yerinden kullanılabilirhalegetirdik. Ardından da bul() ve sorgula() adlı fonksiyonları, birer örnek metodu biçiminde sınıf içine yerleştirdik. Busınıfıdaşuşekildekullanabiliriz: >>> import klist >>> sorgu = klist.Sorgu() >>> sorgu.sorgula() (sonrakisayfayadevam) 40.3. Alternatifİnşacılar 799 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem >>> sorgu.sorgula(’yazar’, ’Evren’) 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki Elbette,buörnekte,ilkyazdığımızkodlarıbirsınıfyapısıiçindetarifetmeninbizepekbirkatkısı yok. Burada yaptığımız şey esasında bütün kodları ‘Sorgu’ adlı bir etki alanı içine taşımaktan fazlasıdeğil.Amaböylebirimkanınızındaolduğunubilmenizherhalükardasiziniçinfaydalı olacaktır. Gelelimyukarıdakikodlarıyazmanınsonalternatifine: class Sorgu(): def __init__(self, değer=None, sıra=None): self.liste = [(’9789753424080’, ’Greenberg’, ’Sana Gül Bahçesi␣ Vadetmedim’, ’Metis’), ˓→ (’975872519X’, ’Evren’, ’Postmodern Bir Kız Sevdim’, ’İthaki’), ˓→ (’9789754060409’, ’Nietzsche’, ’Böyle Buyurdu Zerdüşt’, ’Cem’)] ˓→ if not değer and not sıra: l = self.liste else: l = [li for li in self.liste if değer == li[sıra]] for i in l: print(*i, sep=’, ’) @classmethod def isbnden(cls, isbn): cls(isbn, 0) @classmethod def yazardan(cls, yazar): cls(yazar, 1) @classmethod def eserden(cls, eser): cls(eser, 2) @classmethod def yayınevinden(cls, yayınevi): cls(yayınevi, 3) Buradada,herbirölçütüayrıbirersınıfmetoduolaraktanımladık.Böylecebuölçütleriyapısal olarakbirbirindenayırmışolduk.Yukarıdakisınıfışuşekildekullanabiliriz: 800 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Öncemodülümüzüiçeaktaralım: >>> from klist import Sorgu ISBNnumarasınagörebirsorgugerçekleştirelim: >>> Sorgu.isbnden("9789753424080") 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis Gördüğünüz gibi, sınıf metodu yaklaşımı, gayet temiz bir sorgu kodu üretmemize imkan tanıyor. Birdeyazaraveeseregöresorgulayalım: >>> Sorgu.yazardan("Greenberg") 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis >>> Sorgu.eserden("Postmodern Bir Kız Sevdim") 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki Bunlardagayetgüzelgörünüyor. Şimdibirdebütünlisteyialalım: >>> hepsi = Sorgu() 9789753424080, Greenberg, Sana Gül Bahçesi Vadetmedim, Metis 975872519X, Evren, Postmodern Bir Kız Sevdim, İthaki 9789754060409, Nietzsche, Böyle Buyurdu Zerdüşt, Cem Gördüğünüzgibi,sınıfıparametresizolarakörneklediğimizdebütünlisteyieldeediyoruz. İşte‘alternatifinşa’denenişlemtamolarakbudur.Yukarıdakiörnekteisbnden(),yazardan(), eserden()veyayınevinden()adlısınıfmetotları,Sorgu()adlısınıfıalternatifşekillerdeinşa etmemizisağlıyor30. Normalşartlarda,birsınıfı,__init__()fonksiyonunaverdiğimizparametreleraracılığıylainşa ediyoruz(birkaçsayfasonra‘inşa’kavramındandahaayrıntılıolarakbahsedeceğiz). Mesela: class Giriş(): def __init__(self, mesaj=’Müşteri numaranız: ’): cevap = input(mesaj) print(’Hoşgeldiniz!’) Burada tanımladığımız Giriş() sınıfı, bir müşteri numarası aracılığıyla sisteme giriş imkanı sağlıyor: 30Aslındaburadainşaedilenşeysınıftanziyadenesnedir.Budurumuve‘nesne’kavramınıbirsonrakibölümde ayrıntılıolarakelealacağız. 40.3. Alternatifİnşacılar 801 PythonBelgeleri,Yayım4.1.3 >>> from sistem import Giriş #kodlarımız sistem.py dosyası içinde >>> Giriş() EğerbizaynızamandabirparolaveTCKimlikNumarasıiledegirişimkanısağlamakistersek, başkayöntemlerinyanısıra,sınıfmetotlarındandayararlanabiliriz: class Giriş(): def __init__(self, mesaj=’Müşteri numaranız: ’): cevap = input(mesaj) print(’Hoşgeldiniz!’) @classmethod def paroladan(cls): mesaj = ’Lütfen parolanızı giriniz: ’ cls(mesaj) @classmethod def tcknden(cls): mesaj = ’Lütfen TC kimlik numaranızı giriniz: ’ cls(mesaj) Buşekildeyukarıdakisınıfıaşağıdakigibideinşaetmeimkanınakavuşuyoruz: >>> Giriş.paroladan() veya: >>> Giriş.tcknden() Sınıf metotları içinde kullandığımız cls(mesaj) satırları, Giriş() adlı sınıfı farklı bir parametre ile çağırmamızı sağlıyor. Gördüğünüz gibi, bu sınıfın mesaj parametresinin öntanımlı değeri ‘Müşteri numaranız: ‘. Sınıfımızı farklı bir şekilde çağırabilmek için, cls(mesaj) kodları yardımıyla sınıfın mesaj parametresini ‘Lütfen parolanızı giriniz: ‘ ve ‘Lütfen TC kimlik numaranızıgiriniz:‘değerleriileyenidençalıştırıyoruz. Daha önce de birkaç kez vurguladığımız gibi, cls kelimesi Python açısından bir zorunluluk değildir.Yaniyukarıdakisınıfımeselaşöyledeyazabilirdik: class Giriş(): def __init__(self, mesaj=’Müşteri numaranız: ’): cevap = input(mesaj) print(’Hoşgeldiniz!’) @classmethod def paroladan(snf): mesaj = ’Lütfen parolanızı giriniz: ’ snf(mesaj) @classmethod def tcknden(snf): mesaj = ’Lütfen TC kimlik numaranızı giriniz: ’ snf(mesaj) 802 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Ancak, tıpkı self kelimesinde olduğu gibi, cls de Python topluluğu içinde son derece yerleşik birgelenektir.Bugeleneğibozmakisteyeceğinizizannetmiyorum. İlkbakıştasınıfmetotlarısizepekgereklideğilmişgibigelebilir.Amaeğerbumetotlarıngerçek dünyadakikullanımınailişkinbirörnekverirsekbelkifikrinizdeğişir. Sınıfmetotlarınınkullanımınailişkingüzelbirörneğidatetimemodülündegörebilirsiniz. ª Ayrıcabakınız Aşağıdaki örneği daha iyi anlayabilmek için datetime Modülü ve time Modülü belgelerine bakınız. Birstandartkütüphanemodülüolandatetime’ınkaynakdosyasınıaçarsanız(kaynakdosyanın nerede olduğunu nasıl öğrenebilirim diye soran arkadaşlara teessüflerimi iletiyorum...), oradadatesınıfınınşöyleyazıldığınıgöreceksiniz: class date: __slots__ = ’_year’, ’_month’, ’_day’ def __new__(cls, year, month=None, day=None): if (isinstance(year, bytes) and len(year) == 4 and 1 <= year[2] <= 12 and month is None): # Month is sane # Pickle support self = object.__new__(cls) self.__setstate(year) return self _check_date_fields(year, month, day) self = object.__new__(cls) self._year = year self._month = month self._day = day return self @classmethod def fromtimestamp(cls, t): y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t) return cls(y, m, d) @classmethod def today(cls): t = _time.time() return cls.fromtimestamp(t) @classmethod def fromordinal(cls, n): y, m, d = _ord2ymd(n) return cls(y, m, d) Gördüğünüzgibi,buradaüçtanesınıfmetoduvar: 40.3. Alternatifİnşacılar 803 PythonBelgeleri,Yayım4.1.3 @classmethod def fromtimestamp(cls, t): ... @classmethod def today(cls): ... @classmethod def fromordinal(cls, n): ... Normalşartlardadatetimemodülüiçindekidatesınıfınışuşekildekullanıyoruz: >>> import datetime >>> bugün = datetime.date(2015, 6, 16) Bu şekilde, date sınıfına sırasıyla yıl, ay ve gün bilgisi girerek bugün adlı bir tarih nesnesi oluşturmuşoluyoruz.Buşekildeherhangibirtarihielleoluşturabilirsiniz. Eğer amacınız bugünün tarihini oluşturmaksa, yıl, ay ve gün bilgilerini yukarıdaki gibi date sınıfınaellegirebileceğinizgibi,today()adlısınıfmetodunudakullanabilirsiniz: >>> bugün = datetime.date.today() İşte böylece, date sınıfının size sunduğu bir alternatif inşacı (today()) vasıtasıyla bugünün tarihiniotomatikolarakeldeetmişoldunuz. Aynı şekilde, eğer elinizde bir zaman damgası varsa ve siz bu zaman damgasından bir tarih elde etmek istiyorsanız yine date sınıfının sunduğu bir başka alternatif inşacıdan yararlanabilirsiniz: >>> import time >>> zaman_damgası = time.time() >>> bugün = datetime.date.fromtimestamp(zaman_damgası) EğerelinizdetamsayıbiçimlibirGregoryentarihverisivarsabuveriyikullanarakdabirtarih nesnesieldeedebilirsiniz: >>> gregoryen = 735765 >>> bugün = datetime.date.fromordinal(gregoryen) datetime.date(2015, 6, 16) Uzun lafın kısası, alternatif inşacılar, bir sınıftan nesne oluşturmak için bize alternatif yollar sunansonderecefaydalıaraçlardır.Buarada,eğerbubölümdedeğindiğimizbazıkavramları anlamakta zorlandıysanız hiç canınızı sıkmayın. Bir sonraki bölümü işledikten sonra, burada anlatılanlarkafanızaçokdahasağlambirşekildeyerleşmişolacak. 804 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 40.4 Statik Metotlar Python’da örnek metotları ve sınıf metotları dışında bir de statik metotlar bulunur. Bildiğiniz gibi, örnek nitelikleri üzerinde işlem yapacağımız zaman örnek metotlarını kullanıyoruz. Aynı şekilde sınıf nitelikleri üzerinde işlem yapacağımız zaman ise sınıf metotlarından faydalanıyoruz.Örnekmetotlarıiçindeherhangibirörnekniteliğineerişmekistediğimizdeself kelimesinikullanıyoruz.Sınıfmetotlarıiçindebirsınıfniteliğineerişmekiçiniseclskelimesini kullanıyoruz.İşteeğerbirsınıfiçindekiherhangibirfonksiyondaörnekveyasınıfniteliklerinin hiçbirineerişmenizgerekmiyorsa,statikmetotlarıkullanabilirsiniz. 40.5 @staticmethod Bezeyicisi Buraya gelene kadar öğrendiğimiz örnek ve sınıf metotlarını nasıl kullanacağımızı biliyorsunuz: class Sınıf(): sınıf_niteliği = 0 def __init__(self, veri): self.veri = veri def örnek_metodu(self): return self.veri @classmethod def sınıf_metodu(cls): return cls.sınıf_niteliği Burada örnek_metodu(), self yardımıyla örnek niteliklerine erişiyor. sınıf_metodu() ise cls yardımıyla sınıf niteliklerine erişiyor. Sınıf metodu tanımlamak için ayrıca @classmethod bezeyicisini de kullanıyoruz. İşte eğer sınıf içinde tanımlayacağınız fonksiyon herhangi bir örnekyadasınıfniteliğiüzerindeherhangibirişlemyapmayacaksaşöylebirşeyyazabilirsiniz: class Sınıf(): sınıf_niteliği = 0 def __init__(self, veri): self.veri = veri def örnek_metodu(self): return self.veri @classmethod def sınıf_metodu(cls): return cls.sınıf_niteliği @staticmethod def statik_metot(): print(’merhaba statik metot!’) 40.4. StatikMetotlar 805 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, statik metotları tanımlamak için @staticmethod bezeyicisini kullanıyoruz. Statik metotlar, ilk parametre olarak self veya cls benzeri kelimeler almaz. Çünkü bu tür sınıflarınörnekveyasınıfnitelikleriileherhangibirişiyoktur. Pekistatikmetotlarneişeyarar? Bumetotlarsınıfmetotlarınaçokbenzer.Tıpkısınıfmetotlarındaolduğugibi,anlamsalolarak sınıfla ilgili olan, ancak sınıf metotlarının aksine bu sınıfın herhangi bir niteliğine erişmesine gerek olmayan fonksiyonları, sınıf dışına atmak yerine, birer statik metot olarak sınıf içine yerleştirebiliriz. Basitbirörnekverelim: class Mat(): ’’’ Matematik işlemleri yapmamızı sağlayan ’’’ bir sınıf. @staticmethod def pi(): return 22/7 @staticmethod def karekök(sayı): return sayı ** 0.5 Burada Mat() adlı bir sınıf tanımladık. Bu sınıf içinde iki adet statik metodumuz var: pi() ve karekök().Gördüğünüzgibi,buikifonksiyon,örnekvesınıfmetotlarınınaksineilkparametre olarakself veyaclsalmıyor.Çünkübuikisınıfındasınıfveyaörneknitelikleriyleherhangibir işiyok. Statikmetotlarıhemörneklerhemdesınıfadlarıüzerindenkullanabiliriz. Yukarıdakikodlarınmat.pyadlıbirdosyadayeraldığınıvarsayarsak: >>> from mat import Mat >>> m = Mat() >>> m.pi() #örnek üzerinden 3.142857142857143 >>> m.karekök(144) #örnek üzerinden 12.0 >>> Mat.pi() #sınıf üzerinden 3.142857142857143 >>> Mat.karekök(144) #sınıf üzerinden 12.0 Statik metotların özellikle sınıf adları üzerinden kullanılabilmesi, bu tür metotları epey kullanışlı hale getirir. Böylece sınıfı örneklemek zorunda kalmadan, sınıf içindeki statik metotlaraulaşabiliriz. 806 Bölüm40. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Elbetteeğeristeseydikbizbufonksiyonlarışöyledetanımlayabilirdik: class Mat(): ’’’ Matematik işlemleri yapmamızı sağlayan ’’’ bir sınıf. def pi(self): return 22/7 def karekök(self, sayı): return sayı ** 0.5 Burada bu iki fonksiyonu birer örnek metodu olarak tanımladık. Bu fonksiyonları bu şekilde tanımladığımızda,bunlaraörneklerüzerindenerişebiliriz: >>> from mat import Mat >>> m = Mat() >>> m.pi() 3.142857142857143 >>> m.karekök(144) 12.0 Ancakbildiğinizgibi,örnekmetotlarınasınıfadlarıüzerindenerişemeyiz: >>> Mat.pi() Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: pi() missing 1 required positional argument: ’self’ Aynışekildebunlarısınıfmetoduolarakdatanımlayabilirdik: class Mat(): ’’’ Matematik işlemleri yapmamızı sağlayan ’’’ bir sınıf. @classmethod def pi(cls): return 22/7 @classmethod def karekök(cls, sayı): return sayı ** 0.5 Bumetotlarıböyletanımladığımızda,bumetotlarahemörneklerüzerindenhemdesınıfadı üzerindenerişebiliriz: >>> from mat import Mat >>> m = Mat() (sonrakisayfayadevam) 40.5. @staticmethodBezeyicisi 807 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> m.pi() #örnek üzerinden 3.142857142857143 >>> m.karekök(144) #örnek üzerinden 12.0 >>> Mat.pi() #sınıf üzerinden 3.142857142857143 >>> Mat.karekök(144) #sınıf üzerinden 12.0 Gördüğünüz gibi, kullanım açısından sınıf metotları ile statik metotlar aynı. Ancak Mat() sınıfı içindeki fonksiyonları birer sınıf metodu olarak tanımladığımızda gereksiz yere cls parametresi kullanmış oluyoruz. Fonksiyon içinde herhangi bir yerde kullanılmadığı için, yukarıdakiörnekteclsparametresininhiçbiramacahizmetetmediğinedikkatedin. Statikmetotlarınçoksıkkullanılanaraçlarolmadığınıdabelirterekyolumuzadevamedelim. Dipnotları: 808 Bölüm40. NesneTabanlıProgramlama(Devamı) 41 BÖLÜM Nesne Tabanlı Programlama (Devamı) Bu bölümde de, temellerini geçen derslerimizde attığımız nesne tabanlı programlama konusunu incelemeye devam edeceğiz. Bu bölümde uygulamaya yönelik bazı örnekler yapmanınyanısıra,nesnetabanlıprogramlamayailişkinbazıteorikbilgilerdevereceğiz. 41.1 Nesneler Geçenbölümlerdenbirindesınıflarıtanımlarken,bunların,nesneüretmemizisağlayanbirveri tipiolduğunadairmuğlakbirlafetmiştik.İştebubaşlıkaltında,otanımiçindegeçenvenesne tabanlıprogramlamanıntemelinioluşturan‘nesne’kavramıüzerineeğileceğiz. 41.2 Nesne Nedir? Programlamayailişkinkavramlariçinde,özellikleprogramlamayayenibaşlayanlarınkafasını en fazla karıştıran kavram nedir diye sorsak, herhalde alacağımız cevap ‘nesne’ olur. Hakikaten, sağda solda sürekli duyduğumuz bu ‘nesne’ denen şey, öteden beri yazılım geliştiriciadaylarınınzihninikarıştırırdurur. Aslında‘nesne’(object)dedikleri,ilkbakıştauyandırdığıizleniminaksine,anlamasızor,gizemli bir kavram değildir. Dolayısıyla, nesne kavramına ilişkin olarak öğrenmemiz gereken ilk şey, bunun abartılacak veya korkulacak bir şey olmadığıdır. Peki ama tam olarak nedir bu nesne dedikleri? Kabaca, Python’da belli birtakım metotlara ve/veya niteliklere sahip olan öğelere nesne adı verilir. Yani ‘nesne’ kelimesi, içinde birtakım metot ve/veya nitelikler barındıran öğeleri tanımlamakiçinkullanılanbirtabirden,basitbirisimlendirmedenibarettir. Pekibirnesneoluşturmakiçinacabaneyapmamızgerekiyor? Hatırlarsanız, geçen bölümde, sınıfların nesne üretmemizi sağlayan veri tipleri olduğunu söylemiştik.Ohaldegelinminikbirnesneüretelim: 809 PythonBelgeleri,Yayım4.1.3 class Sınıf(): pass sınıf = Sınıf() İşte bu kodlardaki sınıf = Sınıf() komutu ile bir nesne üretmiş olduk. Nesnemizin adı da ‘sınıf’.Teknikolarakifadeedersek,sınıförneği,Sınıf()adlısınıfınbütünnitelikvemetotlarını bünyesinde barındıran bir nesnedir. Mesela yukarıdaki kodların sınıf.py adlı bir dosyada bulunduğunuvarsayarakşöylebirdenemeyapalım: >>> import sınıf >>> snf = sınıf.Sınıf() Buşekilde,kodlarıiçerenmodülüiçeaktarmışvemodüliçindekiSınıf()adlısınıfısnf adıile örneklemişolduk.Yaniyukarıdakikodlaryardımıylasnfadlıbirnesneoluşturduk.Bakalımbu nesnehanginitelikve/veyametotlarasahipmiş: >>> dir(snf) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’] Gördüğünüz gibi, biz boş bir sınıf tanımlamış olsak da, snf nesnesi öntanımlı olarak yine de bazı nitelik ve metotlara sahip. İşte Python’da, yukarıdaki gibi birtakım nitelik ve metotlara sahipolanbutüröğelere‘nesne’adıveriyoruz. Bir de isterseniz yukarıdaki gibi boş bir sınıf tanımlamak yerine, sınıfımız içinde kendimiz birtakımnitelikvemetotlartanımlamayıdadeneyelim: class Sınıf(): sınıf_niteliği = ’sınıf niteliği’ def __init__(self): self.örnek_niteliği = ’örnek niteliği’ def örnek_metodu(self): print(’örnek metodu’) @classmethod def sınıf_metodu(cls): print(’sınıf metodu’) @staticmethod def statik_metot(): print(’statik metot’) Şimdinesneiçeriğinitekrarkontroledelim: 810 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 >>> import sınıf >>> snf = sınıf.Sınıf() >>> dir(snf) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’, ’statik_metot’, ’sınıf_metodu’, ’sınıf_niteliği’, ’örnek_metodu’, ’örnek_niteliği’] Gördüğünüzgibi,kenditanımladığımıznitelikvemetotlardasnf adlınesneiçineeklenmiş... İşte snf adlı sınıf örneğinin, yukarıda gösterilen birtakım durum ve davranışlara sahip olmasındanyolaçıkarak,snf örneğininbirnesneolduğunusöylüyoruz. Yukarıdaki açıklamaların, ‘nesne’ kavramı hakkında en azından bir fikir sahibi olmanızı sağladığını zannediyorum. Gördüğünüz gibi, nesne denen şey aslında basit bir isimlendirmeden ibarettir: Python’da belli bir durumu/niteliği/metodu/davranışı olan elemanlara/öğelere nesne (object) adı veriyoruz. Peki o zaman, nesne denen şey basit bir adlandırmadanibaretsenesnetabanlıprogramlamanınetrafındakoparılanbuncayaygaranın sebebinedir? Nesne tabanlı programlamayı bu kadar özel ve önemli kılan şeyin ne olduğunu anlamak için gelinnesnelerebirazdahayakındanbakalım. 41.3 Basit Bir Oyun Gelin isterseniz nesne denen kavramı daha iyi anlayabilmek, bir nesneyi nesne yapan metot ve nitelikler arasındaki ilişkiyi daha net bir şekilde kavrayabilmek için, komut satırı üzerinde çalışan çok basit bir oyun tasarlayalım. Bu şekilde hem eski bilgilerimizi tekrar etmiş oluruz, hem teorik bilgilerimizi uygulama sahasına dökmüş oluruz, hem de yeni şeyler öğrenmiş oluruz. Oyunumuzunkodlarışöyle: import time import random import sys class Oyuncu(): def __init__(self, isim, can=5, enerji=100): self.isim = isim self.darbe = 0 self.can = can self.enerji = enerji def mevcut_durumu_görüntüle(self): print(’darbe: ’, self.darbe) print(’can: ’, self.can) (sonrakisayfayadevam) 41.3. BasitBirOyun 811 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(’enerji: ’, self.enerji) def saldır(self, rakip): print(’Bir saldırı gerçekleştirdiniz.’) print(’Saldırı sürüyor. Bekleyiniz.’) for i in range(10): time.sleep(.3) print(’.’, end=’’, flush=True) sonuç = self.saldırı_sonucunu_hesapla() if sonuç == 0: print(’\nSONUÇ: kazanan taraf yok’) if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) self.darbele(rakip) if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) rakip.darbele(self) def saldırı_sonucunu_hesapla(self): return random.randint(0, 2) def kaç(self): print(’Kaçılıyor...’) for i in range(10): time.sleep(.3) print(’\n’, flush=True) print(’Rakibiniz sizi yakaladı’) def darbele(self, darbelenen): darbelenen.darbe += 1 darbelenen.enerji -= 1 if (darbelenen.darbe % 5) == 0: darbelenen.can -= 1 if darbelenen.can < 1: darbelenen.enerji = 0 print(’Oyunu {} kazandı!’.format(self.isim)) self.oyundan_çık() def oyundan_çık(self): print(’Çıkılıyor...’) sys.exit() ################################## (sonrakisayfayadevam) 812 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) # Oyuncular siz = Oyuncu(’Ahmet’) rakip = Oyuncu(’Mehmet’) # Oyun başlangıcı while True: print(’Şu anda rakibinizle karşı karşıyasınız.’, ’Yapmak istediğiniz hamle: ’, ’Saldır: s’, ’Kaç: k’, ’Çık: q’, sep=’\n’) hamle = input(’\n> ’) if hamle == ’s’: siz.saldır(rakip) print(’Rakibinizin durumu’) rakip.mevcut_durumu_görüntüle() print(’Sizin durumunuz’) siz.mevcut_durumu_görüntüle() if hamle == ’k’: siz.kaç() if hamle == ’q’: siz.oyundan_çık() Komut satırı üzerinde çalışan basit bir oyundur bu. Dilerseniz bu kodları incelemeye başlamadanönce,birdosyayakaydedipçalıştırın.Karşınızaşöylebirekrangelecek: Şu anda rakibinizle karşı karşıyasınız. Yapmak istediğiniz hamle: Saldır: s Kaç: k Çık: q > Programımız bize burada üç farklı seçenek sunuyor. Eğer rakibimize saldırmak istiyorsak klavyedeki‘s’tuşuna;rakibimizdenkaçmakistiyorsakklavyedeki‘k’tuşuna;yokeğeroyundan çıkmak istiyorsak da klavyedeki ‘q’ tuşuna basacağız. Tercihinizi belirleyip neler olduğunu inceleyinveoyunuiyicetanımayaçalışın. Oyunuiyiceanlayıptanıdıktansonraoyunkodlarınıincelemeyegeçebiliriz. YukarıdailkolarakOyuncuadlıbirsınıftanımladık: class Oyuncu(): def __init__(self, isim, can=5, enerji=100): (sonrakisayfayadevam) 41.3. BasitBirOyun 813 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.isim = isim self.darbe = 0 self.can = can self.enerji = enerji classkelimesininsınıftanımlamamızısağlayanbiraraç,Oyuncukelimesininisetanımladığımız sınıfın adı olduğunu biliyoruz. Bu satırın hemen ardından gelen __init__() fonksiyonu, sınıfımız örneklendiğinde neler olacağını tanımladığımız yerdir. Bu sınıfın, örnekleme sırasında hangi parametreleri alacağını da __init__() fonksiyonu içinde belirliyoruz. Parametre listesinde gördüğümüz ilk öğe, yani self, sınıfın o anki örneğini temsil ediyor. Python’ınsözdizimikurallarıgereğincebukelimeyiorayayazmamızgerektiğinibiliyoruz. Yukarıdakifonksiyon,self dışındatoplamüçparametrealıyor:isim,canveenerji.Bunlardan ilki, yani isim parametresinin öntanımlı bir değeri yok. Dolayısıyla sınıfı çağırırken (yani örneklerken) bu parametrenin değerini belirtmemiz gerekecek. Öteki iki parametre olan can ve enerji ise birtakım öntanımlı değerlere sahip. Dolayısıyla sınıfı örneklendirirken bu parametrelere farklı bir değer atamadığımız sürece, bu parametreler, listede belirtilen değerleritaşıyacak. Parametre olarak belirlediğimiz değerleri sınıf içinde kullanabilmek için, bunları __init__() fonksiyonunungövdesindebirerörnekniteliğinedönüştürüyoruz: self.isim = isim self.darbe = 0 self.can = can self.enerji = enerji Burada ilave olarak bir de değeri 0 olan self.darbe adlı bir değişken tanımladık. Bu da sınıfımızınörnekniteliklerindenbiriolup,ilgilioyuncu(yanisınıfınoankiörneği)darbealdıkça bunundeğeriyükselecektir. Gelin isterseniz bu aşamada sınıfımızı örnekleyerek neler olup bittiğini daha net anlamaya çalışalım: class Oyuncu(): def __init__(self, isim, can=5, enerji=100): self.isim = isim self.darbe = 0 self.can = can self.enerji = enerji #Sınıfımızı örnekliyoruz oyuncu = Oyuncu(’Ahmet’) Burada oyuncu = Oyuncu(’Ahmet’) komutunu verdiğimiz anda __init__() fonksiyonu çalışmayabaşlıyorveoyuncuadlınesneiçinsırasıylaşudeğişkenlerioluşturuyor: isim = ’Ahmet’ darbe = 0 can = 5 enerji = 100 814 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Buörnekniteliklerinenasılulaşabileceğinizibiliyorsunuz: print(’İsim: ’, oyuncu.isim) print(’Darbe: ’, oyuncu.darbe) print(’Can: ’, oyuncu.can) print(’Enerji: ’, oyuncu.enerji) Başta da söylediğimiz gibi, Oyuncu() sınıfını örnekleyerek meydana getireceğiniz bütün sınıf örnekleri, yani nesneler, __init__() fonksiyonu içinde tanımladığınız örnek niteliklerini taşıyacaktır: class Oyuncu(): def __init__(self, isim, can=5, enerji=100): self.isim = isim self.darbe = 0 self.can = can self.enerji = enerji oyuncu1 = Oyuncu(’Ahmet’) oyuncu2 = Oyuncu(’Mehmet’) oyuncu3 = Oyuncu(’Veli’) oyuncu4 = Oyuncu(’Ayşe’) Burada oyuncu1, oyuncu2, oyuncu3 ve oyuncu4 olmak üzere dört farklı nesne oluşturduk. Bu nesnelerin hangi niteliklere sahip olacağını ise Oyuncu() sınıfının tanımı içinde belirttik. Yanisınıfımıztıpkıbirfabrikagibiçalışarak,bizimiçin,aynınitelikleritaşıyandörtfarklınesne üretti. İşte nesne tabanlı programlamanın özünü oluşturan ‘nesne’ budur. Bir nesnenin hangi niteliklere sahip olacağını belirleyen veri tipine sınıf (class) derken, o sınıfın ortaya çıkardığı ürüne ise nesne (object) adını veriyoruz. Bunu şuna benzetebilirsiniz: Eğer ‘İnsan’ bir sınıfsa, ‘Mahmut’busınıfınbirörneğidir.DolayısıylaMahmut,İnsansınıfındanüretilmişbirnesnedir. Aynı şekilde eğer ‘Köpek’ bir sınıfsa, ‘Karabaş’ da bu sınıfın bir örneğidir. Yani Karabaş, Köpek sınıfından üretilmiş bir nesnedir. Mahmut’un hangi özelliklere sahip olacağını İnsan sınıfının nasıl tanımlandığı, Karabaş’ın hangi özelliklere sahip olacağını ise Köpek sınıfının nasıltanımlandığıbelirler.İşteaynıbunungibi,Oyuncu()sınıfındanüretilennesnelerinhangi özellikleresahipolacağınıdaOyuncu()sınıfınınnasıltanımlandığıbelirler. Kodlarımızıincelemeyedevamedelim... def mevcut_durumu_görüntüle(self): print(’darbe: ’, self.darbe) print(’can: ’, self.can) print(’enerji: ’, self.enerji) Buradamevcut_durumu_görüntüle()adlıbirörnekmetodutanımladık.Örnekmetotlarınınilk parametresininherzamanself olmasıgerektiğinibiliyoruz. Tanımladığımız örnek metodunun görevi, Oyuncu() sınıfından oluşturduğumuz nesnelerin (yani örneklerin) o anki darbe, can ve enerji durumlarını görüntülemek. Birer örnek niteliği olandarbe,canveenerjideğişkenlerineself aracılığıylaeriştiğimizeözellikledikkatediyoruz. Gelelimsınıfımızınönemliörnekmetotlarındanbiriolansaldır()fonksiyonunuincelemeye: 41.3. BasitBirOyun 815 PythonBelgeleri,Yayım4.1.3 def saldır(self, rakip): print(’Bir saldırı gerçekleştirdiniz.’) print(’Saldırı sürüyor. Bekleyiniz.’) for i in range(10): time.sleep(.3) print(’.’, end=’’, flush=True) sonuç = self.saldırı_sonucunu_hesapla() if sonuç == 0: print(’\nSONUÇ: kazanan taraf yok’) if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) self.darbele(rakip) if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) rakip.darbele(self) Bu fonksiyon, self dışında tek bir parametre alıyor. Fonksiyonu çalıştırırken kullanacağımız rakip parametresi, saldırının kime karşı (yani sınıf örneklerinden hangisine karşı) düzenleneceğinibelirleyecek. Fonksiyongövdesindeilkolarakşöylebirkısımgörüyoruz: print(’Bir saldırı gerçekleştirdiniz.’) print(’Saldırı sürüyor. Bekleyiniz.’) for i in range(10): time.sleep(.3) print(’.’, end=’’, flush=True) Burada saldırınıngerçekleştiğine dairkullanıcıyı bilgilendirdiktensonra şöylebir kodparçası yazdık: for i in range(10): time.sleep(.3) print(’.’, end=’’, flush=True) Bu kodlarda time adlı bir standart kütüphane modülünün sleep() adlı bir metodundan yararlandığımızı görüyorsunuz. Elbette bu modülü kullanabilmek için öncelikle bu modülü içeaktarmışolmamızgerekiyor.Buişlemidosyanınenbaşındaimport timesatırıyardımıyla gerçekleştirdiğimizigörebilirsiniz. Yukarıdaki satırlar, 300’er milisaniye aralıklarla, yan yana nokta işaretleri yerleştirecektir. Dilersenizetkileşimlikabuktabukodlarışuşekildetestedebilirsiniz: >>> import time >>> for i in range(10): (sonrakisayfayadevam) 816 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ... time.sleep(.3) ... print(’.’, end=’’, flush=True) print()fonksiyonuiçindekullandığımızendveflushparametrelerininneolduğunuveneişe yaradığını ilk derslerimizden hatırlıyor olmalısınız. Eğer hatırlamıyorsanız, bu parametreleri tektekkodlardançıkarıp,bukodlarıbirdeöyleçalıştırın.Sonucunneolduğunutakipederek, endveflushparametreleriningörevinidahaiyianlayabilirsiniz. Bukodlarınardındanşöylebirsatıryazdık: sonuç = self.saldırı_sonucunu_hesapla() Burada,saldırı_sonucunu_hesapla()adlıbirörnekmetodunuçağırdığımızıgörüyorsunuz: def saldırı_sonucunu_hesapla(self): return random.randint(0, 2) Biraz önce time adlı bir standart kütüphane modülünü kullanmıştık. Şimdi ise random adlı başka bir standart kütüphane modülünü kullanıyoruz. Elbette bu modülü de kullanabilmek için öncelikle bu modülü import random komutuyla içe aktarmış olmamız gerekiyor. Bu zorunluluğuda,tıpkıtimemodülündeolduğugibi,dosyanınenbaşındayerinegetirmiştik. Yukarıda random modülünü, 0 ile 2 arası rastgele sayılar üretmek için kullandık. random.randint(0, 2) komutu her çalıştığında 0, 1 ve 2 sayılarından birini rastgele üretecektir. Buradan elde ettiğimiz sonucu sonuç adlı bir değişkene atayarak saldır() fonksiyonuiçindeşuşekildekullanıyoruz: sonuç = self.saldırı_sonucunu_hesapla() if sonuç == 0: print(’\nSONUÇ: kazanan taraf yok’) if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) self.darbele(rakip) if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) rakip.darbele(self) Eğer randint() metodu 0 sayısını üretirse, rakibimize karşı gerçekleştirdiğimiz saldırının sonuçsuzkaldığınahükmediyoruz: if sonuç == 0: print(’\nSONUÇ: kazanan taraf yok’) Eğer randint() metodu 1 sayısını üretirse, rakibimizi başarıyla darbelediğimize, 2 sayısını üretirsederakibimiztarafındandarbelendiğimizehükmediyoruz: if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) (sonrakisayfayadevam) 41.3. BasitBirOyun 817 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.darbele(rakip) if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) rakip.darbele(self) Saldırısonucundarakibimizidarbelediğimizdeverakibimizdendarbeyediğimizdedarbele() adlıbirbaşkaörnekmetodunuçağırdığımızıdagözdenkaçırmayın. Buarada,örnekmetotlarınadaselfönekiileeriştiğimizedikkatiniziçekmekisterim.Ayrıcaher nekadarörnekmetotlarınıtanımlarkenparantezlistesiiçindeself kelimesinibelirtsekde,bu metotlarıçağırırkenbunlarıargümanolarakkullanmadığımızadaözellikledikkatetmelisiniz. Yanibizbumetotlarışöyletanımlıyoruz: def saldırı_sonucunu_hesapla(self): return random.randint(0, 2) Buradaparametrelistesindeself’igörüyoruz.Amabufonksiyonlarıçağırırkenparanteziçinde buself’ikullanmıyoruz: self.saldırı_sonucunu_hesapla() self’i parantez içinde bir argüman olarak kullanmak yerine, bu kelimeyi fonksiyon adının başınabirönekolaraktakıyoruz. Nediyorduk?Evet,saldır()fonksiyonuiçindedarbele()adlıbirfonksiyonaatıftabulunduk. Yani saldırı sonucunda rakibimizi darbelediğimizde ve rakibimizden darbe yediğimizde darbele()adlıbirbaşkaörnekmetodunuçağırdık: def darbele(self, darbelenen): darbelenen.darbe += 1 darbelenen.enerji -= 1 if (darbelenen.darbe % 5) == 0: darbelenen.can -= 1 if darbelenen.can < 1: darbelenen.enerji = 0 print(’Oyunu {} kazandı!’.format(self.isim)) self.oyundan_çık() Bu fonksiyon içinde, herhangi bir darbe alma durumunda oyuncunun darbe, can ve enerji miktarlarındameydanagelecekdeğişiklikleritanımlıyoruz. Bunagöreherhangibirdarbealmadurumundaaşağıdakiişlemlergerçekleştirilecek: Darbelenenoyuncunundarbedeğeri1birimartacak: darbelenen.darbe += 1 enerjideğeri1birimazalacak: darbelenen.enerji -= 1 Darbelenenoyuncuher5darbede1cankaybedecek: 818 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 if (darbelenen.darbe % 5) == 0: darbelenen.can -= 1 Burada her 5 darbede 1 can kaybetme kriterini nasıl belirlediğimize dikkat edin. Bildiğiniz gibi,oyuncudarbeyedikçedarbedeğişkeninindeğeriartıyor.Budeğer5sayısınaulaştığında, 5 % 5 işleminin sonucu 0 olacaktır. Yani bu sayı 5’e bölündüğünde bölme işleminden kalan değer 0 olacaktır. 5’in tüm katları için (5, 10, 15, 20 gibi...) bu durum geçerlidir. Eğer darbe değişkenin ulaştığı değer 5’in katı değilse, bu sayı 5’e tam bölünmediği için, bölmeden kalan değer 0 dışında bir sayı olur. Dolayısıyla darbe değerinin ulaştığı sayının 5’e bölünmesinden kalan değerin 0 olup olmadığını kontrol ederek oyuncunun 5 darbede 1 can kaybetmesini sağlayabiliyoruz. Oyuncunun can değeri 1’in altına düştüğünde ise enerji değeri 0’a inecek ve oyunu kimin kazandığıilanedildiktensonraoyunkapatılacak: if darbelenen.can < 1: darbelenen.enerji = 0 print(’Oyunu {} kazandı!’.format(self.isim)) self.oyundan_çık() Buradaoyundan_çık()adlıbirörnekmetodunadahaatıftabulunduk: def oyundan_çık(self): print(’Çıkılıyor...’) sys.exit() Gayetbasitbirfonksiyon.Herhangibirşekildeoyundançıkmakgerektiğindesysmodülünün exit()fonksiyonunukullanarakoyunuterkediyoruz. İlerlemedenönce,darbele()fonksiyonunukullandığımızkısmatekrarbakalım: sonuç = self.saldırı_sonucunu_hesapla() if sonuç == 0: print(’\nSONUÇ: kazanan taraf yok’) if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) self.darbele(rakip) if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) rakip.darbele(self) Bildiğinizgibi,darbele()fonksiyonu,selfdışında1adetparametredahaalıyor.Buparametre, darbeyi hangi oyuncunun alacağını gösteriyor. İşte bunu tespit etmek için darbelenen adlı bir parametre belirledik. Gördüğünüz gibi, darbele() fonksiyonu saldır() adlı başka bir fonksiyonun içinden çağrılıyor. saldır() fonksiyonu da rakip adlı bir parametre alıyor. İşte darbe alan oyuncunun can ve enerji değerlerini yenilemek istediğimizde bu parametreyi, darbele()fonksiyonunagönderiyoruz: self.darbele(rakip) 41.3. BasitBirOyun 819 PythonBelgeleri,Yayım4.1.3 Burada darbelenen oyuncu karşı taraf. Yani rakibimiz bizden (self’den) darbe yemiş. Eğer darbelenenkişikendimizsek,rakipoyuncusununbizidarbelemesiniistiyoruz: rakip.darbele(self) Pek çok kez söylediğimiz gibi, self kelimesi mevcut sınıf örneğini temsil eder. Dolayısıyla kendimizeatıftabulunmakistediğimizdurumlarda,yukarıdaolduğugibiself’ikullanabiliriz. Eğerarzuederseniz,darbele()fonksiyonunuşöyledeyazabilirsiniz: def darbele(self): self.darbe += 1 self.enerji -= 1 if (self.darbe % 5) == 0: self.can -= 1 if self.can < 1: self.enerji = 0 print(’Oyunu {} kazandı!’.format(self.isim)) self.oyundan_çık() Buradadarbelenenparametresiniiptalettik.Kimindurumununyenileceğiniself’inkimolduğu belirleyecek: if sonuç == 1: print(’\nSONUÇ: rakibinizi darbelediniz’) rakip.darbele() if sonuç == 2: print(’\nSONUÇ: rakibinizden darbe aldınız’) self.darbele() Gördüğünüz gibi, eğer rakibi darbeleyip onun can ve enerji durumunu yenilemek istiyorsak, ilgili fonksiyonu rakip.darbele() şeklinde çağırıyoruz. Kendimizin durumunu yenilemek istediğimizde ise self.darbele() komutunu kullanıyoruz. Tabii darbele fonksiyonunu bu şekildetanımlayacaksakisminidarbe_alolarakbelirlemekdahaanlamlıolur. Sınıfımızıtanımladığımızagöreartıkbusınıfınasılkullanacağımızıincelemeyegeçebiliriz: siz = Oyuncu(’Ahmet’) rakip = Oyuncu(’Mehmet’) BuradaöncelikleOyuncu()sınıfıiçinikifarklınesne/örnekoluşturuyoruz: siz = Oyuncu(’Ahmet’) rakip = Oyuncu(’Mehmet’) Bu iki nesne, Oyuncu() sınıfının bütün niteliklerini taşıyor. Nesneleri oluştururken, zorunlu argümanolanisimdeğerinimutlakabelirtmemizgerektiğiniunutmuyoruz. Daha sonra bir while döngüsü içinde, oyunumuzun kullanıcı tarafından görüntülenecek kısmınıkodluyoruz: 820 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 while True: print(’Şu anda rakibinizle karşı karşıyasınız.’, ’Yapmak istediğiniz hamle: ’, ’Saldır: s’, ’Kaç: k’, ’Çık: q’, sep=’\n’) hamle = input(’\n> ’) if hamle == ’s’: siz.saldır(rakip) print(’Rakibinizin durumu’) rakip.mevcut_durumu_görüntüle() print(’Sizin durumunuz’) siz.mevcut_durumu_görüntüle() if hamle == ’k’: siz.kaç() if hamle == ’q’: siz.oyundan_çık() Oyununnasıloynanacağıkonusundakullanıcılarımızıbilgilendiriyoruz: print(’Şu anda rakibinizle karşı karşıyasınız.’, ’Yapmak istediğiniz hamle: ’, ’Saldır: s’, ’Kaç: k’, ’Çık: q’, sep=’\n’) Kullanıcılarımızınklavyedehangituşabastığınışuşekildealıyoruz: hamle = input(’\n> ’) Eğerkullanıcı‘s’tuşunabasarsarakibimizesaldırıyoruz: if hamle == ’s’: siz.saldır(rakip) Saldırınınardındanhemkendidurumumuzuhemderakibimizindurumunugörüntülüyoruz: print(’Rakibinizin durumu’) rakip.mevcut_durumu_görüntüle() print(’Sizin durumunuz’) siz.mevcut_durumu_görüntüle() Eğerkullanıcı‘k’tuşunabasarsa: if hamle == ’k’: siz.kaç() 41.3. BasitBirOyun 821 PythonBelgeleri,Yayım4.1.3 sınıfiçindetanımladığımızkaç()metodunuçalıştırıyoruz: def kaç(self): print(’Kaçılıyor...’) for i in range(10): time.sleep(.3) print(’\n’, flush=True) print(’Rakibiniz sizi yakaladı’) Burada300’ermilisaniyelikaralıklarla‘\n’kaçışdizisinikullanarakbiraltsatırageçiyoruz. Kullanıcının‘q’tuşunabasmasıhalindeiseoyundanderhalçıkıyoruz: if hamle == ’q’: siz.oyundan_çık() Buörnekkodlarbizesınıflarvenesnelerhakkındaepeybilgiverdi.Ayrıcabukodlarsayesinde öncekibilgilerimizidepekiştirmişolduk. 41.4 Her Şey Bir Nesnedir Belkisağdasoldaşusözüduymuşsunuzdur:Python’daherşeybirnesnedir.Gerçektende(if, def,and,orgibideyimveişleçlerhariç)Python’daherşeybirnesnedir.Pekiherşeyinnesne olmasıtamolarakneanlamageliyor? Hatırlarsanıznesneninneolduğunutanımlarken,bellibirdurumdabulunanvebellibirtakım davranışlarıolanöğelerenesneadıverildiğinisöylemiştik.İştePython’dakiherşey,butanım doğrultusundabirnesnedir. Mesela,aşağıdakikomutuverdiğimizandabirnesneoluşturmuşoluyoruz: >>> ’’ ‘’karakterdizisi,stradlısınıfın... >>> type(’’) <class ’str’> ...bütünözelliklerinitaşıyanbirnesnedir: >>> dir(’’) [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__getnewargs__’, ’__gt__’, ’__hash__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mod__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rmod__’, ’__rmul__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’capitalize’, ’casefold’, (sonrakisayfayadevam) 822 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’center’, ’count’, ’encode’, ’endswith’, ’expandtabs’, ’find’, ’format’, ’format_map’, ’index’, ’isalnum’, ’isalpha’, ’isdecimal’, ’isdigit’, ’isidentifier’, ’islower’, ’isnumeric’, ’isprintable’, ’isspace’, ’istitle’, ’isupper’, ’join’, ’ljust’, ’lower’, ’lstrip’, ’maketrans’, ’partition’, ’replace’, ’rfind’, ’rindex’, ’rjust’, ’rpartition’, ’rsplit’, ’rstrip’, ’split’, ’splitlines’, ’startswith’, ’strip’, ’swapcase’, ’title’, ’translate’, ’upper’, ’zfill’] Aynışekilde,[’elma’, ’armut’]listeside,listadlısınıfın... >>> type([’elma’, ’armut’]) <class ’list’> ...bütünözelliklerinitaşıyanbirnesnedir: >>> dir([’elma’, ’armut’]) [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__delitem__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__gt__’, ’__hash__’, ’__iadd__’, ’__imul__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__reversed__’, ’__rmul__’, ’__setattr__’, ’__setitem__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’append’, ’clear’, ’copy’, ’count’, ’extend’, ’index’, ’insert’, ’pop’, ’remove’, ’reverse’, ’sort’] Hatta mesela 1 gibi alelade bir sayı bile, dış dünyayla iletişim kurmasını ve dış dünyanın kendisiyleiletişimkurabilmesinisağlayanpekçoknitelikvemetodasahipbirnesnedir: >>> dir(1) [’__abs__’, ’__add__’, ’__and__’, ’__bool__’, ’__ceil__’, ’__class__’, ’__delattr__’, ’__dir__’, ’__divmod__’, ’__doc__’, ’__eq__’, ’__float__’, ’__floor__’, ’__floordiv__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getnewargs__’, ’__gt__’, ’__hash__’, ’__index__’, ’__init__’, ’__int__’, ’__invert__’, ’__le__’, ’__lshift__’, ’__lt__’, ’__mod__’, ’__mul__’, ’__ne__’, ’__neg__’, ’__new__’, ’__or__’, ’__pos__’, ’__pow__’, ’__radd__’, ’__rand__’, ’__rdivmod__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rfloordiv__’, ’__rlshift__’, ’__rmod__’, ’__rmul__’, ’__ror__’, ’__round__’, ’__rpow__’, ’__rrshift__’, ’__rshift__’, ’__rsub__’, ’__rtruediv__’, ’__rxor__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__sub__’, ’__subclasshook__’, ’__truediv__’, ’__trunc__’, ’__xor__’, (sonrakisayfayadevam) 41.4. HerŞeyBirNesnedir 823 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’bit_length’, ’conjugate’, ’denominator’, ’from_bytes’, ’imag’, ’numerator’, ’real’, ’to_bytes’] İşte konuya bu noktadan baktığımızda, Python’da her şey bir nesnedir. Yani Python’daki her şeyle,sahipolduklarımetotlarvenitelikleraracılığıylaetkileşebilirsiniz. Python’ınbuözelliğinibilmek,muhatapolduğunuzprogramlamadiliniveonunkabiliyetlerini tanımakaçısındanönemlidir.Python’daherşeyinbirnesneolduğunuanladığınızanda,{’a’: 0, ’b’: 1}gibibirkodlayalnızcabasitbirsözlüktanımlamadığınızı,bununarkaplanında,bu sözlükleetkileşimkurmanızısağlayacakkocabirmekanizmabulunduğunubilirsiniz. 41.5 Birinci Sınıf Öğeler Tıpkı ‘her şey bir nesnedir’ sözü gibi, yine sağda solda sıklıkla duyabileceğiniz bir söz de Python’da nesnelerin ‘birinci sınıf öğeler’ olduğudur. Peki burada ‘birinci sınıf’ (first class) ifadesiylekastedilenşeytamolaraknedir? Programlamadillerindeherhangibiröğeninbirincisınıfbiröğeolması,oöğenin,diliçindeki herhangi bir değer ile aynı kabiliyetlere sahip olması anlamına gelir. ‘Bunun birinci sınıf olmaklanealakasıvar?’diyesorduğunuzuduyargibiyim... Şöyle bir cümle kurduğunuzu düşünün: ‘Gelişmiş bir toplumda kadınlar birinci sınıf vatandaşlardır.’ Bu cümleden, bir toplumun gelişmiş sayılabilmesi için kadınların erkeklerle eşithaklarasahipolmasıgerektiğinianlıyoruz.Yanikadınlarınbirincisınıfvatandaşlarolması, erkeklerle eşit haklara sahip olması anlamına geliyor. İşte tıpkı bunun gibi, Python’daki sınıf yapılarının‘birincisınıf’öğelerolması,buyapıların,diliçindekiötekideğerlerleaynıözelliklere vekabiliyetleresahipolmasıdemektir.YaniPython’dakisınıflarşuözellikleresahiptir: 1. Başkabirfonksiyonaveyasınıfaparametreolarakverilebilirler 2. Birfonksiyondandöndürülebilirler 3. Birdeğişkeneatanabilirler Yani,biröğenin‘birincisınıf’olmasıdemek,diliçindekibaşkaöğelerleyapabildiğinizherşeyi oöğeyledeyapabilmenizdemektir. Durumu biraz daha netleştirebilmek için, konu hakkında Guido Van Rossum’un ne dediğine birbakalım: Python’a ilişkin hedeflerimden bir tanesi de, bu dili, bütün nesneler “birinci sınıf” olacak şekilde tasarlamaktı. Bununla kastettiğim, dil içinde kendisine bir isim verilebilen bütün nesnelerin (örn. tam sayılar, karakter dizileri, fonksiyonlar, sınıflar, modüller, metotlar, vb.) eşit statüye sahip olmasıdır. Yani, bütün nesnelerin değişkenlere atanabilmesi, listelerin içine yerleştirilebilmesi, sözlükler içindedepolanabilmesi,argümanolarakatanabilmesivesaire... kaynak: http://python-history.blogspot.com.tr/2009/02/first-class-everything. html Gelinbütünbutanımlarısomutlaştıranbirkaçörnekverelim. MeselaDeneme()adlıbasitbirsınıftanımlayalım: 824 Bölüm41. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 class Deneme(): def __init__(self): self.değer = 0 def metot(self): self.metot_değeri = 1 Yukarıdakitanımlaragöre,busınıfınbirincisınıfbirnesneolabilmesiiçinbaşkabirfonksiyona veyasınıfaparametreolarakatanabilmesigerekiyor.Bakalımacabagerçektenöylemi? print(Deneme()) Gördüğünüzgibi,gerçektendesınıfımızıprint()fonksiyonunaparametreolarakatayabildik. Yine yukarıdaki tanıma göre birinci sınıf nesnelerin bir fonksiyondan döndürülebilmesi gerekiyor: def fonksiyon(): return Deneme() print(fonksiyon()) Butestidebaşarıylageçtik. Sonolarak,birnesneninbirincisınıfolabilmesiiçinbirdeğişkeneatanabilmesigerekiyor: değişken = Deneme() Gördüğünüzgibi,Pythoniçinbudaoldukçabasitbirgörev. İlkbakıştabuözelliktenpeketkilenmemişolabilirsiniz... Şöylebirdüşününce,aslındaçokda önemlibirözellikdeğilmişgibigelebilirbusize.Ancakbaşkaprogramlamadillerinin; • Öğelerinkullanımınailişkinçeşitlikısıtlamalarkoyduğunu, • Yaniöğelerarasındaayrımyaptığını, • Değişkenlerlefonksiyonlarınvefonksiyonlarlasınıflarınaynıhaklarasahipolmadığını, • Meselabirdeğişkeniveyaherhangibirdeğerikullanabildiğinizheryerdefonksiyonveya sınıfkullanamadığınızı, • Yanifonksiyonlarınve/veyasınıflarınbirincisınıföğelerolmadığını gördüğünüzdePython’dakibuesneklikdahabiranlamkazanacaktır. 41.5. BirinciSınıfÖğeler 825 42 BÖLÜM Nesne Tabanlı Programlama (Devamı) Geçen bölümlerde, nesne tabanlı programlamaya ilişkin hem temel, hem orta, hem de ileri düzey sayılabilecek pek çok konuya değindik. Şimdiye kadar öğrendiklerimiz, nesne tabanlı programlama yaklaşımı çerçevesinde yazılım üretirken yönümüzü bulabilmemiz açısından büyük ölçüde yeterlidir. Ancak daha önce de söylediğimiz gibi, nesne tabanlı programlama çokgenişkapsamlıbirkonudurveiçindeşimdiyekadaradınıbileanmadığımızdahapekçok kavram barındırır. İşte bu bölümde, geçen derslerimizde incelemeye fırsat bulamadığımız, ancak nesne tabanlı programlamayı daha derinlemesine tanımak bakımından bilmemizin iyi olacağıbirtakımileridüzeykavramlardansözedeceğiz. Bubölümdeinceleyeceğimizilkkonu‘sınıfüyeleri’. 42.1 Sınıf Üyeleri Python’da bir sınıf içinde bulunan nitelikler, değişkenler, metotlar, fonksiyonlar ve buna benzer başka veri tipleri, o sınıfın üyelerini meydana getirir. Bir sınıfın üyelerini genel olarak üçeayırarakinceleyebiliriz: • Aleniüyeler(publicmembers) • Gizliüyeler(privatemembers) • Yarı-gizliüyeler(semi-privatemembers). Bu bölümde bu üç üye türünü ve bunların birbirinden farkını ele alacağız. Öncelikle aleni üyelerdenbaşlayalım. 826 PythonBelgeleri,Yayım4.1.3 42.1.1 Aleni Üyeler Eğer bir sınıf üyesi dışarıya açıksa, yani bu üyeye sınıf dışından normal yöntemlerle erişilebiliyorsa bu tür üyelere ‘aleni üyeler’ adı verilir. Programlama maceranız boyunca karşınıza çıkacak veri üyelerinin tamamına yakını alenidir. Biz de bu kitapta şimdiye kadar yalnızcaaleniüyelerigördük. Eğer bildiğiniz tek programlama dili Python ise, şu anda tam olarak neden bahsediyor olduğumuza anlam verememiş olabilirsiniz. Dilerseniz durumu zihninizde biraz olsun netleştirebilmekiçinbasitbirörnekverelim. Diyelimkielimizdeşöylebirsınıfvar: class Sınıf(): sınıf_niteliği = ’sınıf niteliği’ def örnek_metodu(self): print(’örnek metodu’) @classmethod def sınıf_metodu(cls): print(’sınıf metodu’) @staticmethod def statik_metot(): print(’statik metot’) Bukodlarınsinif.pyadlıbirdosyaiçindeyeraldığınıvarsayarsakşöylebirşeyleryazabiliriz: >>> import sinif >>> s = sinif.Sınıf() >>> dir(s) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’, ’statik_metot’, ’sınıf_metodu’, ’sınıf_niteliği’, ’örnek_metodu’] Burada öncelikle kodlarımızı barındıran modülü içe aktardık. Daha sonra, içe aktardığımız modülün içindeki Sınıf() adlı sınıfımızı s örneğine atadık ve ardından dir() komutunu kullanarak,içeaktardığımızbusınıfıniçeriğinisorguladık. Gördüğünüz gibi, içe aktardığımız sınıfın bütün öğeleri listede var. Yani biz bu sınıf içindeki bütünöğelerenormalyollardanerişmeimkanınasahibiz: >>> s.statik_metot() ’statik metot’ >>> s.örnek_metodu() (sonrakisayfayadevam) 42.1. SınıfÜyeleri 827 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’örnek metodu’ >>> s.sınıf_metodu() ’sınıf metodu’ >>> s.sınıf_niteliği ’sınıf niteliği’ İştedir()komutununçıktısındagörünenvenormalyollardanerişebildiğimizbütünbuöğeler bireraleniüyedir. Yukarıda da ifade ettiğimiz gibi, program yazarken çoğu zaman yalnızca aleni üyelerle muhatap olacaksınız. Ancak bazı durumlarda, yazdığınız bir sınıftaki bütün sınıf üyelerinin dışarıya açık olmasını istemeyebilirsiniz. Eğer kodlarınızda, sınıfın yalnızca iç işleyişini ilgilendiren, bu yüzden de dışarıdan erişilmesine gerek olmadığını veya erişilirse problem çıkacağınıdüşündüğünüzbirtakımöğelervarsabunlarıdışarıyakapatarakbir‘gizliüye’haline getirmekisteyebilirsiniz.Pekiamanasıl? 42.1.2 Gizli Üyeler Python’daşimdiyekadargördüğümüzveyukarıdaandığımızaleniüyelerindışında,birdegizli üyeler bulunur. Aleni üyelerin aksine gizli üyeler dışarıya açık değildir. Gizli üyelere, normal yöntemlerikullanaraksınıfdışındanerişemeyiz. Konuyu açıklığa kavuşturmak için, aleni üyeleri anlatırken verdiğimiz sınıf örneğinde şu değişikliğiyapalım: class Sınıf(): __gizli = ’gizli’ def örnek_metodu(self): print(self.__gizli) print(’örnek metodu’) @classmethod def sınıf_metodu(cls): print(’sınıf metodu’) @staticmethod def statik_metot(): print(’statik metot’) Burada__gizliadlıbirgizlisınıfniteliğitanımladık.Budeğişkeninyalnızcabaştarafındaikiadet alt çizgi olduğuna, ancak uç tarafında alt çizgi bulunmadığına dikkat edin. İşte Python’da baş tarafında yukarıdaki gibi iki adet alt çizgi olan, ancak uç tarafında alt çizgi bulunmayan (veya yalnızca tek bir alt çizgi bulunan) bütün öğeler birer gizli üyedir. Dışarıya kapalı olan bu gizli üyelere,normalyöntemlerikullanaraksınıfdışındanerişemezsiniz. İstersenizdeneyelim: 828 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 >>> import sinif >>> s = sinif.Sınıf() >>> s.__gizli Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’Sınıf’ object has no attribute ’__gizli’ Gördüğünüzgibi,örnekadıüzerinden__gizliniteliğineerişemiyoruz.Birdesınıfadıüzerinden erişmeyideneyelim: >>> sinif.Sınıf.__gizli Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: type object ’Sınıf’ has no attribute ’__gizli’ Bu şekilde de erişemedik. Çünkü dediğimiz gibi, başında çift alt çizgi olan, ancak ucunda herhangi bir çizgi bulunmayan (veya tek bir alt çizgi bulunan) bu gizli öğelere normal yollardanerişemeyiz. Dilersenizgizliüyeoluşturmakurallarınışöylebirnetleştirelim: Bir üyenin gizli olabilmesi için başında en az iki adet, ucunda da en fazla bir adet alt çizgi bulunmalıdır.Yanişunlarbirergizliüyedir: >>> __gizli = ’gizli’ >>> __gizli_ = ’gizli’ >>> __gizli_üye = ’gizli’ >>> __gizli_üye_ = ’gizli’ Burada önemli bir noktaya dikkatinizi çekmek istiyorum: Gizli üyeler yalnızca sınıf dışına kapalıdır. Bu üyelere sınıf içinden rahatlıkla erişebiliriz. Mesela yukarıdaki örnekte bu durumu görüyorsunuz. __gizli adlı değişkene örnek_metodu() içinden normal bir şekilde erişebiliyoruz: def örnek_metodu(self): print(self.__gizli) print(’örnek metodu’) Bu durumda sınıf dışından bu örnek_metodu()’na eriştiğimizde gizli üye olan __gizli’ye de erişmişoluyoruz: >>> import sinif >>> s = sinif.Sınıf() >>> s.örnek_metodu() ’gizli’ ’örnek metodu’ Buradaörnek_metodu(),__gizliadlıgizliüyeyeerişmemiziçinbizearacılıketmişoluyor. Pekiamabirinsannedenbuşekildebirtakımgizliüyelertanımlamakistiyorolabilir? 42.1. SınıfÜyeleri 829 PythonBelgeleri,Yayım4.1.3 Hatırlarsanızgeçenbölümdeşöylebirörnekvermiştik: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() @classmethod def personel_sayısını_görüntüle(cls): print(len(cls.personel)) def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Burada personel adlı bir sınıf niteliğimiz var. Bu niteliğe sınıf içinde hem personele_ekle() adlıörnekmetodundanhemdepersonel_sayısını_görüntüle()vepersoneli_görüntüle() adlısınıfmetotlarındanerişmeksuretiylebuniteliküzerindeçeşitliişlemleryapıyoruz. Esasında şöyle bir düşününce, personel adlı niteliğin yalnızca sınıfın iç işleyişi açısından önemtaşıdığınırahatlıklasöyleyebiliriz.Buniteliğesınıfdışındandoğrudanerişilerekpersonel üzerinde işlem yapılmaya çalışılması çok mantıksız. Yani sınıfımızı kullanacak kişilerin şu tür birkodyazmasıbirazabeskaçacaktır: >>> from calisan import Çalışan >>> Çalışan.personel.append(’Ahmet’) Zira biz, kodlarımızın yapısı gereği, personel üzerindeki işlemlerin yalnızca çeşitli fonksiyonlar/metotlararacılığıylayapılmasınıistiyoruz. Personele eleman ekleyecek kişilerin doğrudan personel listesine erişmesi, kodlarımızın kullanımkurallarınınbirbakımaihlaledilmesianlamınageliyor.Çünkübizpersoneleeleman eklemeişlemleriiçinhalihazırdaayrıbirmetottanımlamışdurumdayız.Eğerpersoneleadam eklenecekse,buişlemdoğrudanpersonellistesiüzerindendeğil,personele_ekle()adlıörnek metodu üzerinden gerçekleştirilmeli. Yukarıdaki kodlarda bu personele_ekle() metodu doğrudansınıfınkendi__init__()metodutarafındankullanılıyor.Dolayısıylayukarıdakisınıfı 830 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 kullanmanındoğruyolu,ilgilisınıfıörneklemektir: >>> from calisan import Çalışan >>> ahmet = Çalışan(’Ahmet’) Aynı şekilde personel listesini görüntülemek için de doğrudan personel listesine erişmeye çalışmayacağız.Yanişöylebirşeyyazmayacağız: >>> Çalışan.personel Bunun yerine, bu iş için özel olarak tasarladığımız personeli_görüntüle() fonksiyonunu kullanacağız: >>> Çalışan.personeli_görüntüle() İşteyukarıdakikodlardayeralanpersonellistesininusulsüzbirşekildekullanılmasınıönlemek amacıylabulisteyibirgizliüyehalinegetirebilirsiniz: class Çalışan(): __personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] self.personele_ekle() @classmethod def personel_sayısını_görüntüle(cls): print(len(cls.__personel)) def personele_ekle(self): self.__personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) def personeli_görüntüle(self): print(’Personel listesi:’) for kişi in self.__personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Burada personel listesinin baş tarafına iki alt çizgi ekleyerek bunu sınıf dışından, normal yollarlaerişilmezhalegetirdik: >>> Çalışan.__personel (sonrakisayfayadevam) 42.1. SınıfÜyeleri 831 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: type object ’Çalışan’ has no attribute ’__personel’ Gördüğünüzgibi,aslındasınıfımıziçinde__personeladlıbirnitelikolmasınarağmen,Python bu niteliğe sınıf dışından erişilmesine izin vermiyor. Eğer amacımız personel üzerinde çeşitli işlemleryapmaksa,buişiçinsınıfınbizesunduğumetotlarıkullanmamızgerekiyor: >>> Çalışan.personel_sayısını_görüntüle() Butipdurumlardagizliüyelerepeyişinizeyarayabilir... Birörnekdahaverelim. Yukarıdaki kodlarda, tıpkı personel listesi gibi, aslında personele_ekle() fonksiyonu da dışarıdan erişilmesine gerek olmayan, hatta dışarıdan erişilirse kafa karıştırıcı olabilecek bir sınıfüyesidir. personele_ekle() adlı örnek metodu, sınıfımız içinde __init__() fonksiyonu tarafından kullanılıyor.Dolayısıylasınıfımızörneklendiğindepersonele_ekle()metodudevreyegirerek yenielemanıpersonellistesineekliyor: >>> ayşe = Çalışan(’Ayşe’) ’Ayşe adlı kişi personele eklendi’ Öte yandan, bu fonksiyon aleni bir üye olduğu için, buna dışarıdan erişmemizin önünde herhangibirengelyok: >>> ayşe.personele_ekle() ’Ayşe adlı kişi personele eklendi’ Bu fonksiyon sınıf dışından çağrıldığında, kendisini çağıran örnek adını personel listesine tekrarekleyecektir: >>> Çalışan.personeli_görüntüle() Ayşe Ayşe YaniyukarıdakikomutAyşeadlıkişiyipersonellistesinetekrarekler.Dolayısıylabufonksiyona sınıf dışından erişilmesi son derece mantıksız, son derece yanlış ve hatta son derece kafa karıştırıcıdır. O yüzden, herhangi bir sıkıntı yaşanmasını engellemek amacıyla bu fonksiyonu dabirgizliüyeolaraktanımlayabiliriz: class Çalışan(): __personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] (sonrakisayfayadevam) 832 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.__personele_ekle() @classmethod def personel_sayısını_görüntüle(cls): print(len(cls.__personel)) def __personele_ekle(self): self.__personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.__personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Bu şekilde personele_ekle() fonksiyonunu da dışarıya kapatmış olduk. Artık bu fonksiyon da,olmasıgerektiğigibi,yalnızcasınıfiçindekullanılabilecek. Yukarıdaki örnekler, bazı durumlarda veri gizlemenin epey işimize yarayabileceğini bariz bir biçimde gösteriyor. Ama elbette, yukarıdaki işlemlerin hiçbiri zorunlu değildir. Yani siz, yazdığınız kodlarda hiçbir sınıf üyesini gizlemek mecburiyetinde değilsiniz. Yukarıda gösterdiğimiz kullanımlar tamamen tercih meselesidir. Zaten birkaç nadir durum dışında, Python’da verilerinizi gizlemek zorunda da kalmazsınız. Ama tabii kendiniz Python’ın bu özelliğinden yararlanmasanız da, sırf bu özellikten yararlanan başka programcıların yazdığı kodlarıanlayabilmekiçinbileolsabuözelliktenhaberdarolmalısınız. 42.1.3 İsim Bulandırma Gelinistersenizgizliüyelereilişkinilginçbirözelliktensözedelim. Python’da ‘gizli’ olarak adlandırdığımız öğeler aslında o kadar da gizli değildir... Çünkü Python’da gerçek anlamda gizli ve dışarıya tamamen kapalı üyeler bulunmaz. Peki bu ne anlamageliyor? Bu şu anlama geliyor: Her ne kadar yukarıdaki örneklerde üyeleri dışarıya kapatmak için kullandığımız alt çizgi işaretleri ilgili değişkeni gizlese de, bunu tamamen erişilmez hale getirmez.Dediğimizgibi,Python’dagerçekanlamdadışakapalısınıfüyeleribulunmadığıiçin bizbuüyelerebirşekildeerişmeimkanınasahibiz.Pekiamanasıl? Python,kodlariçindegizlibirüyeilekarşılaştığındaözelbir‘isimbulandırma’(namemangling) işlemigerçekleştirirveilgiligizliüyeningörünüşünüdeğiştirir.EğerPython’ınarkaplandaneler çevirdiğinibilirseniz,gizliüyeyedeerişebilirsiniz. 42.1. SınıfÜyeleri 833 PythonBelgeleri,Yayım4.1.3 Örneksınıfımızşöyleydi: class Sınıf(): __gizli = ’gizli’ def örnek_metodu(self): print(self.__gizli) print(’örnek metodu’) @classmethod def sınıf_metodu(cls): print(’sınıf metodu’) @staticmethod def statik_metot(): print(’statik metot’) Şimdi,busınıfiçindekigizliüyeyeerişeceğiz. Dikkatlicebakın: >>> import sinif >>> s = sinif.Sınıf() >>> s._Sınıf__gizli ’gizli’ Nekadardatuhaf,değilmi? İştePython,sizbirsınıfüyesini__gizlişeklindetanımladığınızda,buöğeüzerindeşuişlemleri gerçekleştirir: Öncelikledeğişkeninbaştarafınabiraltçizgiekler: _ Dahasonra,bualtçizgininsağtarafınabugizliüyeyibarındıransınıfınadınıiliştirir: _Sınıf Sonolarakdagizliüyeyisınıfadınınsağtarafınayapıştırır: _Sınıf__gizli Dolayısıyla_Sınıf__gizlikodunukullanarak,__gizliadlıüyeyesınıfdışındanerişebilirsiniz. Pratikolmasıbakımındanbirörnekdahaverelim.Meselaşuörneğielealalım: class Çalışan(): __personel = [] def __init__(self, isim): self.isim = isim self.kabiliyetleri = [] (sonrakisayfayadevam) 834 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.__personele_ekle() @classmethod def personel_sayısını_görüntüle(cls): print(len(cls.__personel)) def __personele_ekle(self): self.__personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.__personel: print(kişi) def kabiliyet_ekle(self, kabiliyet): self.kabiliyetleri.append(kabiliyet) def kabiliyetleri_görüntüle(self): print(’{} adlı kişinin kabiliyetleri:’.format(self.isim)) for kabiliyet in self.kabiliyetleri: print(kabiliyet) Burada__personele_ekle()adlıfonksiyonbirgizliüyedir.Dolayısıylabunadışarıdannormal yöntemlerleerişemeyiz. Bunutestetmekiçinöncegerekliverilerioluşturalım: >>> from calisan import Çalışan >>> ahmet = Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi. Şimdiahmetörneğiüzerindenbugizliüyeyeerişmeyeçalışalım: >>> ahmet.__personele_ekle() Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’Çalışan’ object has no attribute ’__personele_ekle’ Gördüğünüz gibi, Python bu üyeye normal yollardan erişmemize izin vermiyor. Ama biz biliyoruz ki, Python bu üyeyi gizlerken özel bir isim bulandırma işlemi gerçekleştiriyor. Bu bulandırmaişlemininnasılgerçekleştirildiğinibildiğimizegöregizliüyeyeerişebiliriz. Öncelikleörneğimizinadınıyazalım.Ziragizliüyeyebuadüzerindenerişeceğiz: >>> ahmet. Şimdibulandırmaişleminiuygulamayageçebiliriz. 42.1. SınıfÜyeleri 835 PythonBelgeleri,Yayım4.1.3 Önceliklebiraltçizgiekleyelim: >>> ahmet._ Dahasonrasınıfadınıiliştirelim: >>> ahmet._Çalışan Sonolarakdagizliüyeninkendisiniyazalım: >>> ahmet._Çalışan__personele_ekle() Ahmet adlı kişi personele eklendi. Gayetbaşarılı... Yalnızburayaşöylebirnotdüşelim:HernekadarPythonbizegizliüyelereerişmeimkanısunsa da, başkasının yazdığı kodları kullanırken, o kodlardaki gizli üyelere erişmeye çalışmamak çoğuzamaniyibirfikirdir.Nihayetindeeğerbirprogramcı,birsınıfüyesinigizlemişsebunun bir nedeni vardır. Eğer erişmenizin istenmediği bir üyeye erişirseniz ve bunun sonucunda birtakımsorunlarlakarşılaşırsanızbudurumoprogramıyazanprogramcınındeğil,tamamen sizin kabahatinizdir. Python programcılarının da sık sık söylediği gibi: ‘Neticede hepimiz, doğruyuyanlışıbilen,yetişkininsanlarız.’ 42.1.4 Yarı-gizli Üyeler BurayakadarPython’adairanlattığımızşeylerden,yerleşmişadetlerinvegeleneklerinPython açısından ne kadar önemli olduğunu anlamış olmalısınız. Daha önce verdiğimiz örnekler, bu dildeki pek çok meselenin uzlaşma esası üzerinden çözüme kavuşturulduğunu bize açık ve seçik olarak gösterdi. Mesela geçen bölümlerde ele aldığımız self ve cls kelimeleri tamamen uzlaşmaya dayalı kavramlardır. Python topluluğu içinde, self kelimesinin örnek metotları için, cls kelimesinin ise sınıf metotları için kullanılması tamamen bir alışkanlık, adet, gelenek ve uzlaşı meselesidir. Python’ın kendisi bize bu kelimeleri dayatmaz. Ancak topluluk içinde süregelen kuvvetli gelenekler bizi başka kelimeleri değil de yukarıdaki kelimeleri kullanmaya teşvik eder. Aynı şekilde kod yazarken girinti sayısının dört boşluk olarak belirlenmiş olması da bir gelenekten ibarettir. Yazdığınız kodlarda, aynı program içinde hep aynı sayıda olmak şartıyla,istediğinizsayıdaboşluktanoluşangirintilerkullanabilirsiniz.AmaPython’ıntopluluk içigelenekleribizidörtboşluklukbirgirintilemesistemikullanmayayöneltir. İşte tıpkı yukarıdakiler gibi, Python’daki sınıf üyelerinin dışa açık veya dışa kapalı olup olmamasıdahepbellibirtakımgeleneklerüzerindenbelirlenenbirdurumdur. Bunun bir örneğini, yukarıda gizli üyeleri anlatırken vermiştik. Bir sınıf içindeki herhangi bir niteliğin başında çift alt çizgi gördüğümüzde, o sınıfı yazan kişinin, bu niteliğe sınıf dışından erişilmesiniistemediğinianlıyoruz.Pythonhernekadarniteliklerigizlememiziçinbizeözelbir mekanizma sunmuş olsa da bu niteliğe erişmemizi tamamen engellemiyor, ancak ilgili sınıfı yazankişininniyetinesaygıgöstereceğimizivarsayıyor. Python’da sınıf üyelerinin gizliliği, yukarıda da gördüğümüz gibi, hem özel bir mekanizma ile hemdetoplulukiçigeleneklertarafındankorunur. Python’da bir de yalnızca topluluk içi gelenekler tarafından korunan ‘yarı-gizli’ üyeler (semi-private members) vardır. İşte bu bölümde, bir gizli üye türü olan yarı-gizli üyelerden sözedeceğiz. 836 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Yarı-gizli üyeler, herhangi bir özel mekanizma aracılığıyla değil de yalnızca topluluk içi gelenekler tarafından korunan niteliklerdir. Herhangi bir üyeyi yarı-gizli olarak işaretlemek içinyapmamızgerekentekşeybaşınabiradetaltçizgiyerleştirmektir.Örneğin: class Falanca(): _yarıgizli = ’yarıgizli’ Buradaki _yarıgizli adlı niteliğe sınıf içinden veya dışından erişmemizi engelleyen veya zorlaştıran hiçbir mekanizma bulunmaz. Ama biz bir sınıf içinde tek alt çizgi ile başlayan bir öğe gördüğümüzde, bunun sınıfın iç işleyişine ilişkin bir ayrıntı olduğunu, sınıf dışından bu öğeyideğiştirmeyekalkışmamamızgerektiğinianlarız. 42.2 @property Bezeyicisi Yukarıda aleni, gizli ve yarı-gizli sınıf üyelerinden söz ettik. İsterseniz özellikle yarı-gizli öğelerinkullanıldığıbirkodörneğivererekyukarıdaanlattıklarımızısomutbirörneküzerinden netleştirmeyeçalışalım. Diyelimkişöylebirkodyazdık: class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.personel: print(kişi) Burada personel veritabanına kişi eklememizi ve veritabanındaki kişileri görüntülememizi sağlayanbirtakımmetotlarvar. Bumetotlarışöylekullanıyoruz: >>> from calisan import Çalışan >>> ç1 = Çalışan(’Ahmet’) Ahmet adlı kişi personele eklendi >>> ç2 = Çalışan(’Mehmet’) Mehmet adlı kişi personele eklendi (sonrakisayfayadevam) 42.2. @propertyBezeyicisi 837 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> Çalışan.personeli_görüntüle() Personel listesi: Ahmet Mehmet Pekieğerkodlarımızıkullananlarpersonellistesindekibirkişininisminisonradandeğiştirmek isterseneyapacak? Kodlarımız içinde, isim değişikliği yapılmasını sağlayan özel bir metot yok. Dolayısıyla kodlarımızı kullananlar, doğrudan isim adlı örnek değişkenine erişerek isim değişikliğini şu şekildeyapabilir: >>> ç1.isim = ’Selim’ Buşekilde‘Ahmet’adlıkişininisminideğiştirdik.Bunuteyitedelim: >>> print(ç1.isim) Selim Ancak burada şöyle bir sorun var. Bu isim değişikliği personel listesine yansımadı. Kontrol edelim: >>> Çalışan.personeli_görüntüle() Personel listesi: Ahmet Mehmet Gördüğünüzgibi,‘Ahmet’ismihâlâoradaduruyor.Busorunugidermekiçin,personellistesine demüdahaleedilmesigerekir: >>> kişi = Çalışan.personel.index(’Ahmet’) >>> Çalışan.personel[kişi] = ’Selim’ Burada öncelikle listelerin index() metodunu kullanarak, değiştirmek istediğimiz kişinin personel listesindeki sırasını bulduk. Daha sonra da bu bilgiyi kullanarak listede gerekli değişikliğiyaptık. Personellistesinitekrarkontrolettiğimizdeherşeyinyolundaolduğunugörebiliriz: >>> Çalışan.personeli_görüntüle() Personel listesi: Selim Mehmet Ancak bunun hiç kullanışlı bir yöntem olmadığı çok açık. Basit bir isim değişikliği için, kullanıcılarımız bir sürü kod yazmak zorunda kalıyor. Kullanıcılarımızın hayatını kolaylaştırmakiçinonlarapratikbirmetotsunabiliriz: 838 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 class Çalışan(): personel = [] def __init__(self, isim): self.isim = isim self.personele_ekle() def personele_ekle(self): self.personel.append(self.isim) print(’{} adlı kişi personele eklendi’.format(self.isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.personel: print(kişi) def isim_değiştir(self, yeni_isim): kişi = self.personel.index(self.isim) self.personel[kişi] = yeni_isim print(’yeni isim:’, yeni_isim) Burada isim_değiştir() adlı yeni bir fonksiyon tanımladık. Artık kodlarımızdan istifade edenleryalnızcabuyenifonksiyonukullanarak,personeleöncedeneklediklerikişilerinismini kolaycadeğiştirebilir: >>> from calisan import Çalışan >>> ç1 = Çalışan(’Ahmet’) >>> ç2 = Çalışan(’Mehmet’) >>> ç3 = Çalışan(’Selim’) >>> Çalışan.personeli_görüntüle() Personel listesi: Ahmet Mehmet Selim >>> ç1.isim_değiştir(’Emre’) yeni isim: Emre >>> Çalışan.personeli_görüntüle() Personel listesi: Emre Mehmet Selim Gördüğünüz gibi, kodlarımız gayet güzel çalışıyor. Bu noktadan sonra, eğer arzu ederseniz, kullanıcılarınızınpersonelveself.isimadlıdeğişkenleredoğrudanerişmesiniengellemekiçin 42.2. @propertyBezeyicisi 839 PythonBelgeleri,Yayım4.1.3 bunlarıtekaltçizgiveyaçiftaltçizgikullanarakgizleyebilirsiniz. Çiftaltçizgiile: class Çalışan(): __personel = [] def __init__(self, isim): self.__isim = isim self.personele_ekle() def personele_ekle(self): self.__personel.append(self.__isim) print(’{} adlı kişi personele eklendi’.format(self.__isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls.__personel: print(kişi) def isim_değiştir(self, yeni_isim): kişi = self.__personel.index(self.__isim) self.__personel[kişi] = yeni_isim print(’yeni isim: ’, yeni_isim) Tekaltçizgiile: class Çalışan(): _personel = [] def __init__(self, isim): self._isim = isim self.personele_ekle() def personele_ekle(self): self._personel.append(self._isim) print(’{} adlı kişi personele eklendi’.format(self._isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls._personel: print(kişi) def isim_değiştir(self, yeni_isim): kişi = self._personel.index(self._isim) self._personel[kişi] = yeni_isim print(’yeni isim: ’, yeni_isim) personel ve self.isim adlı nitelikleri çift alt çizgi ile gizlediğimizde Python’ın isim bulandırma mekanizmasını işleteceğini, tek alt çizgi ile gizlediğimizde ise bu mekanizmanın 840 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 işletilmeyeceğinibiliyorsunuz. Pekisizeşöylebirsorusorayım: Acaba, personel listesindeki bir ismi, mesela yalnızca şöyle bir komut vererek değiştiremez miyiz? >>> ç1.isim = ’Emre’ Elbette değiştirebiliriz. Ancak bunun için özel bir araçtan yararlanmamız gerekir. Bu iş için @propertyadlıözelbirbezeyiciyikullanacağız. Dikkatlicebakın: class Çalışan(): _personel = [] def __init__(self, isim): self._isim = isim self.personele_ekle() def personele_ekle(self): self._personel.append(self._isim) print(’{} adlı kişi personele eklendi’.format(self._isim)) @classmethod def personeli_görüntüle(cls): print(’Personel listesi:’) for kişi in cls._personel: print(kişi) @property def isim(self): return self._isim @isim.setter def isim(self, yeni_isim): kişi = self._personel.index(self.isim) self._personel[kişi] = yeni_isim print(’yeni isim: ’, yeni_isim) Bu kodları çalıştırdığınızda, tıpkı yukarıda bahsettiğimiz gibi, herhangi bir çalışanın ismini yalnızcaşuşekildedeğiştirebildiğinizigöreceksiniz: >>> ç1.isim = ’Emre’ Üstelikbukod,isimdeğişikliğininpersonellistesinedeyansımasınısağlıyor: >>> Çalışan.personeli_görüntüle() Emre Birazdan bu kodları derinlemesine inceleyeceğiz. Ama isterseniz öncelikle şu @property bezeyicisindenbirazsözedelim.Böylelikleyukarıdakikodlarıanlamamızkolaylaşır. 42.2. @propertyBezeyicisi 841 PythonBelgeleri,Yayım4.1.3 42.2.1 Metottan Niteliğe Şimdiye kadar verdiğimiz örneklerden anlamış olabileceğiniz gibi, bir sınıf içinde salt verileri tutandeğişkenlere‘nitelik’adıveriyoruz.Mesela: class Falanca(): nitelik = ’nitelik’ def __init__(self): self.nitelik = ’nitelik’ Buradanitelikbirsınıfniteliği,self.nitelikisebirörnekniteliğidir. Bunakarşılık,birsınıfiçindefonksiyonbiçimindeyeralanvebirişlemiveyaprosedürüyerine getirenöğelereisemetotadıveriyoruz.Mesela: class Falanca(): def __init__(self): pass def örnek_fonk(self): pass @classmethod def sınıf_fonk(cls): pass @staticmethod def statik_fonk(): pass Burada örnek_fonk() adlı fonksiyon bir örnek metodu, sınıf_fonk() adlı fonksiyon bir sınıf metodu, statik_fonk() adlı fonksiyon ise bir statik metottur. Metotlar ile niteliklerin gerçekleştirebilecekleriişlemlerinkarmaşıklığınınbirbirindenfarklıolmasınınyanısıra,bunlar arasındakullanımaçısındandafarklılıkvardır.MeselaFalanca()sınıfıiçindekinitelikadlısınıf niteliğinişuşekildekullanıyoruz: >>> Falanca.nitelik >>> Falanca.nitelik = ’yeni değer’ Aynısınıfiçindekisınıf_fonk()adlısınıfmetodunaiseşöyleerişiyoruz: >>> Falanca.sınıf_fonk() Niteliklerinaksine,metotlardaatamayoluyladeğerdeğiştirmegibibirşeysözkonusudeğildir. Yanişunabenzerbirşeyyazamayız: >>> Falanca.sınıf_fonk() = ’yeni değer’ Eğer metot bir parametre alıyorsa (yukarıdaki örneklerde metotlar parametre almıyor), bu parametreyikullanarakmetotlailetişimkurabiliriz.Mesela: 842 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 >>> Falanca.sınıf_fonk(yeni_değer) Property kelimesi (attribute kelimesine benzer bir şekilde) İngilizcede ‘özellik, nitelik’ gibi anlamlara gelir. Kelime anlamına uygun olarak, @property bezeyicisinin yaptığı en temel iş, birmetodu,nitelikgibikullanılabilecekhalegetirmektir.Çokbasitbirörnekverelim: class Program(): def __init__(self): pass def versiyon(self): return ’0.1’ Buradaversiyon()adlıbirörnekmetodutanımladık.Buprogramışöylekullanıyoruz: >>> program = Program() >>> program.versiyon() ’0.1’ Şimdiprogramımızdaşudeğişikliğiyapalım: class Program(): def __init__(self): pass @property def versiyon(self): return ’0.1’ Burada versiyon() adlı metodu @property bezeyicisi ile ‘bezedik’. Böylece bu metodu bir ‘nitelik’halinegetirmişolduk.Artıkbunuşöylekullanabiliriz: >>> program = Program() >>> program.versiyon ’0.1’ versiyon()fonksiyonunu,@propertybezeyicisiyardımıylabirniteliğedönüştürdüğümüziçin, artıkbufonksiyonuparantezsizkullandığımızadikkatedin. Gördüğünüz gibi, @property bezeyicisinin ilk görevi bir metodu niteliğe dönüştürmek. Peki acabanedenbirmetoduniteliğedönüştürmekistiyorolabiliriz? Şöylebirprogramyazdığınızıdüşünün: class Program(): def __init__(self): self.data = 0 Yazdığınızbuprogramıkullananlar,sınıfiçindekidataniteliğineşuşekildeerişiyor: 42.2. @propertyBezeyicisi 843 PythonBelgeleri,Yayım4.1.3 >>> p = Program() >>> p.data 0 Hattadurumagörebuniteliğişuşekildedeğişikliğedeuğratıyor: >>> p.data = 1 Günün birinde, ‘data’ kelimesi yerine ‘veri’ kelimesinin daha uygun olduğunu düşünerek, ‘data’ kelimesini ‘veri’ olarak değiştirmek istediğinizi varsayalım. Bunun için kodlarınızda şu değişikliğiyapabilirsiniz: class Program(): def __init__(self): self.veri = 0 Ancak bu şekilde, programınızı eskiden beri kullananların, sizin yazdığınız bu programı temel alarak oluşturdukları programları bozmuş oldunuz... Çünkü eğer bu programdan faydalanan birisi, yazdığı kodda eski self.data değişkenini kullanmışsa, yukarıdaki isim değişikliğiyüzündenprogramıkullanılamazhalegelecektir.İştebunuönlemekiçin@property bezeyicisinikullanabilirsiniz. Dikkatlicebakın: class Program(): def __init__(self): self.veri = 0 @property def data(self): return self.veri Bu şekilde, self.data niteliğine yapılan bütün çağrılar data() adlı metot vasıtasıyla self.veri niteliğine yönlendirilecek. Böylece başkalarının bu programı kullanarak yazdığı eski kodları bozmadan, programımızda istediğimiz değişikliği yapmış olduk. Yani programımızda geriye dönükuyumluluğu(backwardscompatibility)sağlamışolduk. Yukarıdaki kodlarda @property bezeyicisini kullanarak data() metodunu bir niteliğe dönüştürdüğümüziçinartıkşöylebirkullanımmümkün: >>> p = Program() >>> p.data 0 >>> p.veri 0 Buyapıda,self.veriüzerindekideğişikliklerself.dataniteliğinedeyansıyacaktır: 844 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 >>> p.veri = 5 >>> p.data 5 42.2.2 Salt Okunur Nitelikler @propertybezeyicisininbirbaşkakabiliyetidesaltokunurnitelikleroluşturabilmesidir. Meselayukarıdakiprogramıtemelalarakşöylebirşeydeneyelim: >>> p = Program() >>> p.data = 5 Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: can’t set attribute Gördüğünüz gibi, data niteliği üzerinde değişiklik yapamıyoruz. Dolayısıyla, kodlarınızı kullananların değiştirmesini istemediğiniz, ‘salt okunur’ nitelikler oluşturmak için @property bezeyicisindenyararlanabilirsiniz. 42.2.3 Veri Doğrulaması @propertybezeyicisininüçönemliişlevibulunur: • Değerdöndürmek • Değeratamak • Değersilmek Yukarıdaki örneklerde bu bezeyicinin değer döndürme işlevini görmüştük. Şimdi ise bu bezeyicinindeğeratamaişlevinianlamayaçalışalım. Bildiğiniz gibi, @property bezeyicisinin ‘değer döndürme’ işlevini kullanarak, bir niteliğe erişimikısıtlayabiliyoruz.Örneğin,zamanındaşöylebirkodyazdığımızıvarsayalım: class Program(): def __init__(self): self.sayı = 0 Daha sonra herhangi bir sebepten ötürü buradaki self.sayı niteliğine erişimi kısıtlayıp bu niteliği üzerinde değişiklik yapılamaz hale getirmek istersek @property bezeyicisinden yararlanabiliriz: class Program(): def __init__(self): self._sayı = 0 @property (sonrakisayfayadevam) 42.2. @propertyBezeyicisi 845 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def sayı(self): return self._sayı Gördüğünüz gibi, öncelikle self.sayı adlı niteliği, başına bir alt çizgi getirerek normal erişime kapatmakistediğimizibelirttik.Bukodlarıgörenler,sayıniteliğininyarı-gizlibirüyeolduğunu anlayıp ona göre davranacak. Ayrıca biraz sonra tanımlayacağımız sayı() fonksiyonuyla bu değişkenin adının birbirine karışmaması için de bir önlem almış olacağız. Python’da bir değişkeninadınıdeğiştirmedenodeğişkeneerişimikontrolaltınaalmakistediğimizdetekalt çizgikullanmaktercihedilenbiryöntemdir. Dahasonradasayı()fonksiyonumuzutanımlıyoruz: @property def sayı(self): return self._sayı Busayı()fonksiyonunu@propertyilebezediğimiziçin,fonksiyonbirniteliğedönüştüvesayı değişkeninisaltokunurhalegetirdi.Eğeramacınızdeğişkenisaltokunurhalegetirmekdeğilse @propertyilebezediğimizfonksiyoniçinbirsetterparametresitanımlayabilirsiniz.Nasılmı? Dikkatliceinceleyin: class Program(): def __init__(self): self._sayı = 0 @property def sayı(self): return self._sayı @sayı.setter def sayı(self, yeni_değer): self._sayı = yeni_değer return self._sayı @property ile bezeyerek bir nitelik haline getirdiğiniz fonksiyonu yazılabilir hale getirmek ve buyazmaişlemininnasılolacağınıbelirlemekiçinözelbir.setterbezeyicisiilebezenmişyeni birfonksiyontanımlayabilirsiniz. Bizyukarıda,yinesayıadınıtaşıyan,.setterilebezenmişbirfonksiyondahatanımladık: @sayı.setter def sayı(self, yeni_değer): self._sayı = yeni_değer return self._sayı Yukarıdaki kodları çalıştırdığımızda, _sayı değişkenine sayı adı ile normal bir şekilde erişip istediğimizdeğişikliğiyapabiliyoruz: >>> p = Program() >>> p.sayı (sonrakisayfayadevam) 846 Bölüm42. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 0 >>> p.sayı = 5 >>> p.sayı 5 Gördüğünüz gibi, artık sayı değişkeni, kendisi için bir .setter bezeyicisi tanımlamış olmamız sayesindedeğişiklikkabulediyor. .setterbezeyicisini,birniteliğiyazılabilirhalegetirmeninyanısıra,doğrulamaişlemleriiçinde kullanabilirsiniz. Basitbirörnekverelim: class Program(): def __init__(self): self._sayı = 0 @property def sayı(self): return self._sayı @sayı.setter def sayı(self, yeni_değer): if yeni_değer % 2 == 0: self._sayı = yeni_değer else: print(’çift değil!’) return self.sayı Burada, self.sayı niteliğinin değerini çift sayılarla sınırlandırdık. Veri doğrulama/kısıtlama işlemini .setter bezeyicisi içinden gerçekleştirdiğimize dikkatinizi çekmek isterim. Buna göre, eğerself.sayıdeğişkeninegirilendeğerbirçiftsayıisebudeğişikliğikabulediyoruz.Aksihalde ‘çiftdeğil!’uyarısıgösteriyoruz: >>> p = Program() >>> p.sayı = 2 >>> p.sayı = 5 ’çift değil!’ Buarada,.setterdışında.deleteradlıözelbir@propertybezeyicisidahabulunur.Bunudabir değerisilmekiçinkullanıyoruz: class Program(): def __init__(self): self._sayı = 0 @property (sonrakisayfayadevam) 42.2. @propertyBezeyicisi 847 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def sayı(self): return self._sayı @sayı.setter def sayı(self, yeni_değer): if yeni_değer % 2 == 0: self._sayı = yeni_değer else: print(’çift değil!’) return self.sayı @sayı.deleter def sayı(self): del self._sayı Gördüğünüzgibi,@propertybezeyicisinikullanırkenüçayrımetottanımlıyoruz: • İlgiliniteliğenasılulaşacağımızıgösterenbirmetot:Bumetodu@propertyilebeziyoruz. • İlgili niteliği nasıl ayarlayacağımızı gösteren bir metot: Bu metodu @metot_adı.setter şeklindebeziyoruz. • İlgili niteliği nasıl sileceğimizi gösteren bir metot: Bu metodu @metot_adı.deleter şeklindebeziyoruz. Bu bölümde nesne tabanlı programlamanın orta-ileri düzey sayılabilecek yönlerine temas ettik. Artık nesne tabanlı programlamanın temellerinden biraz daha fazlasını bildiğinizi rahatlıklaiddiaedebilirsiniz. 848 Bölüm42. NesneTabanlıProgramlama(Devamı) 43 BÖLÜM Nesne Tabanlı Programlama (Devamı) Nesne tabanlı programlamaya giriş yaparken, bu programlama yaklaşımının oldukça geniş kapsamlı bir konu olduğunu söylemiştik. Bu bölümde de bu geniş kapsamlı konunun ileri düzeyyönlerinielealmayadevamedeceğiz. Ayrıca bu bölümü bitirdikten sonra, nesne tabanlı programlamanın yoğun bir şekilde kullanıldığı ‘grafik arayüz tasarlama’ konusundan da söz edebileceğiz. Böylece, bu zamana kadar gördüğümüz komut satırı uygulamalarından sonra, bu bölümle birlikte ilk kez düğmeli-menülü modern arayüzleri tanımaya da başlayacağız. Üstelik grafik arayüzlü programlarüzerindeçalışmak,nesnetabanlıprogramlamanınözelliklekarmaşıkyönleriniçok dahakolayvenetbirşekildeanlamamızıdasağlayacak. 43.1 Miras Alma Bu bölümde, yine nesne tabanlı programlamaya ait bir kavram olan ‘miras alma’dan söz edeceğiz. Bütün ayrıntılarıyla ele alacağımız miras alma, nesne tabanlı programlamanın en önemli konularından birisidir. Hatta nesne tabanlı programlamayı faydalı bir programlama yaklaşımı haline getiren özelliklerin başında miras alma gelir dersek çok da abartmış olmayız. Ayrıca miras alma konusu, komut satırında çalışan programların yanı sıra grafik arayüzlü programlar da yazabilmemizin önündeki son engel olacak. Bu bölümü tamamladıktan sonra, grafik arayüzlü programlar yazmamızı sağlayacak özel modüllerin belgelerinden yararlanabilmeye ve grafik arayüzlü programların kodlarını okuyup anlamaya başlayabileceğiz. Daha önce de söylediğimiz gibi, Python programlama dilinin temel felsefesi, bir kez yazılan kodları en verimli şekilde tekrar tekrar kullanabilmeye dayanır. Genel olarak baktığımızda dilin hemen hemen bütün öğeleri bu amaca hizmet edecek şekilde tasarlanmıştır. İşte bu başlık altında ele alacağımız ‘miras alma’ kavramı da kodların tekrar tekrar kullanılabilmesi felsefesinekatkısunanbirözelliktir. İstersenizmirasalmakonusunuanlatmayabasitbirörneklebaşlayalım. Diyelim ki bir oyun yazıyorsunuz. Bu oyun içinde askerler, işçiler, yöneticiler, krallar, 849 PythonBelgeleri,Yayım4.1.3 kraliçeler ve bunun gibi oyuncu türleri olacak. Bu oyuncuları ve kabiliyetlerini mesela şöyle tanımlayabilirsiniz: class Asker(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 100 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class İşçi(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 70 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Yönetici(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 20 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) Burada asker, işçi ve yöneticinin her biri için ayrı bir sınıf tanımladık. Her sınıfın bir ismi, rütbesi ve gücü var. Ayrıca her sınıf; hareket etme, puan kazanma ve puan kaybetme gibi kabiliyetleresahip. 850 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Bu kodların oyuncular.py adlı bir dosyada bulunduğunu varsayarsak, mesela bir asker oluşturmakiçinyukarıdakikodlarışöylekullanabiliriz: >>> import oyuncular >>> asker1 = oyuncular.Asker(’Mehmet’, ’er’) Asker() sınıfının isim ve rütbe parametrelerini belirtmek suretiyle bir asker nesnesi oluşturduk. Tıpkı Python’da gördüğümüz başka nesneler gibi, bu nesne de çeşitli nitelik ve metotlardanoluşuyor: >>> dir(asker1) [’__class__’, ’__delattr__’, ’__dict__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__module__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’__weakref__’, ’güç’, ’hareket_et’, ’isim’, ’puan_kaybet’, ’puan_kazan’, ’rütbe’] Bunitelikvemetotlarıaskernesnesiüzerinenasıluygulayacağımızıbiliyorsunuz: >>> asker1.isim ’Mehmet’ >>> asker1.rütbe ’er’ >>> asker1.güç 100 >>> asker1.hareket_et() ’hareket ediliyor...’ >>> asker1.puan_kazan() ’puan kazanıldı’ >>> asker1.puan_kaybet() ’puan kaybedildi’ Aynışekildeötekiİşçi()veYönetici()sınıflarınıdaörnekleyipkullanabiliriz.Bukonudabir problem yok. Ancak yukarıdaki kodları incelediğinizde, aynı kodların sürekli tekrarlandığını göreceksiniz. Gördüğünüz gibi, aynı nitelik ve metotları her sınıf için yeniden tanımlıyoruz. BudurumunPython’ınmantalitesineaykırıolduğunutahminetmekhiçzordeğil.Pekiacaba yukarıdakikodlarınasıldaha‘Pythonvari’halegetirebiliriz? Bunoktadailkolaraktabansınıflardansözetmemizgerekiyor. 43.1. MirasAlma 851 PythonBelgeleri,Yayım4.1.3 43.2 Taban Sınıflar Tabansınıflar(baseclasses)mirasalmakonusununönemlikavramlarındanbiridir.Dilerseniz taban sınıfın ne olduğu anlayabilmek için, yukarıda verdiğimiz örneği temel alarak çok basit biruygulamayapalım. Öncelikleyukarıdaverdiğimizörneğitekrarönümüzealalım: class Asker(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 100 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class İşçi(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 70 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Yönetici(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 20 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): (sonrakisayfayadevam) 852 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print(’puan kaybedildi’) Buörnekte,Asker(),İşçi()veYönetici()adlısınıflarıniçeriğinebaktığımızdapekçokmetot veniteliğinaslındabirbiriyleaynıolduğunugörüyoruz.Gelinistersenizbütünsınıflardaortak olanbunitelikvemetotlarıtekbirsınıfaltındatoplayalım. Asker(),İşçi()veYönetici()sınıflarının,yazdığımızprogramdakioyuncularıtemsilettiğini düşünürsek,ortaknitelikvemetotlarıbarındıransınıfımızıdaOyuncu()olarakadlandırmamız mantıksızolmayacaktır: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) İşteburadaOyuncu()adlısınıf,bir‘tabansınıf’olarakadlandırılır.Tabansınıfdenenşey,birkaç farklısınıftaortakolannitelikvemetotlarıbarındıranbirsınıftürüdür.İngilizcedebaseclass olarakadlandırılantabansınıflar,ayrıcaüstsınıf(superclass)veyaebeveynsınıf(parentclass) olarakdaadlandırılır.Bizbumakaledetabansınıfisminitercihedeceğiz. Yukarıdaki Oyuncu() adlı taban sınıf da, İşçi(), Asker(), Yönetici() gibi sınıfların hepsinde ortak olarak bulunacak nitelik ve metotları barındıracak. Öteki bütün sınıflar, ortak nitelik ve metotlarınıherdefasındatektekyenidentanımlamakyerine,Oyuncu()adlıbutabansınıftan devralacak.Pekiamanasıl?İştebunuanlamakiçinde‘altsınıf’adlıbirkavramadeğinmemiz gerekiyor. 43.3 Alt Sınıflar Bir taban sınıftan türeyen bütün sınıflar, o taban sınıfın alt sınıflarıdır. (subclass). Alt sınıflar, kendilerindentüredikleritabansınıflarınmetotveniteliklerinimirasyoluyladevralır. Anlattığımızbusoyutşeylerianlamanınenkolayyolusomutbirörneküzerindenilerlemektir. Mesela,birazöncetanımladığımızOyuncu()adlıtabansınıftanbiraltsınıftüretelim: class Asker(Oyuncu): pass Kodlarımıztamolarakşöylegörünüyor: 43.3. AltSınıflar 853 PythonBelgeleri,Yayım4.1.3 class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): pass Burada Asker() sınıfını tanımlarken, bu sınıfın parantezleri içine Oyuncu() sınıfının adını yazdığımıza dikkat edin. İşte bu şekilde bir sınıfın parantezleri içinde başka bir sınıfın adını belirtirsek, o sınıf, parantez içinde belirttiğimiz sınıfın bir alt sınıfı olmuş olur. Yani mesela yukarıdaki gibi Asker() sınıfının parantezleri arasına Oyuncu() sınıfının adını yazdığımızda, Asker()adlısınıf; 1. Oyuncu()adlısınıfımirasalmış, 2. Oyuncu()adlısınıfınbütünmetotveniteliklerinidevralmış, 3. Oyuncu()adlısınıftantüremişoluyor. Bu sayede Oyuncu() sınıfında tanımlanan bütün nitelik ve metotlara Asker() sınıfından da erişebiliyoruz: >>> import oyuncular >>> asker1 = oyuncular.Asker(’Ahmet’, ’Er’) >>> asker1.isim ’Ahmet’ >>> asker1.rütbe ’Er’ >>> asker1.güç 0 >>> asker1.puan_kazan() ’puan kazanıldı’ Örnek olması açısından, Oyuncu() sınıfından türeyen (miras alan) birkaç alt sınıf daha tanımlayalım: 854 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): pass class İşçi(Oyuncu): pass class Yönetici(Oyuncu): pass Tanımladığımız bu İşçi() ve Yönetici() sınıfları da tıpkı Asker() sınıfı gibi Oyuncu() adlı sınıftanmirasaldığıiçin,Oyuncu()sınıfınınsahipolduğutümnitelikvemetotlarasahiptirler. Burayakadaranlattıklarımızıözetleyecekolursak,şusınıfbirtabansınıftır: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) Butabansınıf,kendisindentüreyecekaltsınıflarınortaknitelikvemetotlarınıtanımlar. Şusınıflarise,yukarıdakitabansınıftantüreyenbireraltsınıftır: class Asker(Oyuncu): pass (sonrakisayfayadevam) 43.3. AltSınıflar 855 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class İşçi(Oyuncu): pass class Yönetici(Oyuncu): pass Bu alt sınıflar, Oyuncu() adlı taban sınıfın bütün nitelik ve metotlarını miras yoluyla devralır. Yani Oyuncu() adlı taban/ebeveyn/üst sınıfın nitelik ve metotlarına, Asker(), İşçi() ve Yönetici()adlıaltsınıflardanerişebiliriz: >>> asker1 = Asker(’Ahmet’, ’İstihkamcı’) >>> işçi1 = İşçi(’Mehmet’, ’Usta’) >>> yönetici1 = Yönetici(’Selim’, ’Müdür’) >>> asker1.hareket_et() ’hareket ediliyor...’ >>> işçi1.puan_kaybet() ’puan kaybedildi’ >>> yönetici1.puan_kazan() ’puan kazanıldı’ İşte bu mekanizmaya miras alma (inheritance) adı verilir. Miras alma mekanizması, bir kez yazılan kodların farklı yerlerde kullanılabilmesini sağlayan, bu bakımdan da programcıyı kod tekrarına düşmekten kurtaran oldukça faydalı bir araçtır. İlerleyen sayfalarda miras alma mekanizmasınınbaşkafaydalarınıdagöreceğiz. 43.4 Miras Alma Türleri Tahminedebileceğinizgibi,mirasalmayalnızcabirsınıfınparantezleriarasınabaşkabirsınıfı yazarakilgilisınıfınbütünnitelikvemetotlarınıkayıtsızşartsızdevralmaktanibaretdeğildir.Bir sınıf,muhtemelen,mirasaldığınitelikvemetotlarüzerindebirtakımdeğişikliklerdeyapmak isteyecektir. Esasında miras alma mekanizmasının işleyişi bakımından kabaca üç ihtimalden sözedebiliriz: 1. Mirasalınansınıfınbütünnitelikvemetotlarıaltsınıfaolduğugibidevredilir. 2. Mirasalınansınıfınbazınitelikvemetotlarıaltsınıftayenidentanımlanır. 3. Mirasalınansınıfınbazınitelikvemetotlarıaltsınıftadeğişikliğeuğratılır. Buihtimallerdenilkinizatengörmüştük.Birsınıfınparantezleriarasınabaşkabirsınıfınadını yazdıktan sonra eğer alt sınıfta herhangi bir değişiklik yapmazsak, taban sınıftaki nitelik ve metotlarolduğugibialtsınıflaraaktarılacaktır. Mesela: 856 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 class Asker(Oyuncu): pass Burada Asker() sınıfı, miras aldığı Oyuncu() sınıfının sanki bir kopyası gibidir. Dolayısıyla Oyuncu()sınıfınınbütünnitelikvemetotlarınaAsker()sınıfıaltındandaaynenerişebiliriz. Yani yukarıdaki kod, Oyuncu() adlı sınıfın bütün nitelik ve metotlarının Asker() sınıfı tarafındanmirasalınmasınısağlar.Buşekilde,Oyuncu()sınıfıiçindehangimetotveyanitelik nasıltanımlanmışsa,Asker()sınıfınadaoşekildedevredilir. Tabansınıfımızınşuşekildetanımlandığınıbiliyoruz: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) Dolayısıyla bu taban sınıfta hangi nitelik ve metotlar hangi değerlere sahipse aşağıdaki Asker(),İşçi()veYönetici()sınıflarıdaodeğerleresahipolacaktır: class Asker(Oyuncu): pass class İşçi(Oyuncu): pass class Yönetici(Oyuncu): pass Ancak, dediğimiz gibi, miras almada tek seçenek bütün metot ve nitelikleri olduğu gibi alt sınıflara aktarmak değildir. Zaten öyle olsaydı miras alma mekanizmasının pek bir anlamı olmazdı. Biz miras aldığımız sınıflar üzerinde, içinde bulunduğumuz durumun gerektirdiği birtakımdeğişiklikleriyapabilmeliyizkibumekanizmanınilgiçekicibiryanıolsun. Ayrıca eğer bir taban sınıfı alt sınıflara olduğu gibi aktaracaksanız, taban sınıftan gelen metot ve nitelikler üzerinde herhangi bir değişiklik yapmayacaksanız ve alt sınıflara da herhangibirnitelikilaveetmeyecekseniz,altsınıflartanımlamakyerinedoğrudantabansınıfın örneklerindenyararlanmakdahaakıllıcavepratikbirterciholabilir: >>> asker = Oyuncu(’Ahmet’, ’Er’) >>> işçi = Oyuncu(’Mehmet’, ’Usta’) >>> yönetici = Oyuncu(’Selim’, ’Müdür’) 43.4. MirasAlmaTürleri 857 PythonBelgeleri,Yayım4.1.3 Buradaasker,işçiveyöneticiiçinayrıayrıaltsınıflartanımlamakyerine,herbiriiçindoğrudan Oyuncu()sınıfınıfarklıisimverütbedeğerleriyleörnekleyerekistediğimizşeyieldeettik. İlerleyenderslerde miras almaalternatiflerinden dahaayrıntılıbir şekildesözedeceğiz, ama dilerseniz şimdi konuyu daha fazla dağıtmadan miras alınan metot ve niteliklerin alt sınıflar içinde nasıl yeniden tanımlanacağını, nasıl değişikliğe uğratılacağını ve alt sınıflara nasıl yeni nitelikvemetotlarekleneceğiniincelemeyegeçelimveilkörneklerimizivermeyebaşlayalım. Hatırlarsanızbiröncekibaşlıktaşöylebirkodyazmıştık: class Asker(Oyuncu): pass Burada Oyuncu() sınıfını bütünüyle alt sınıfa aktardık. Peki ya biz bir taban sınıfı olduğu gibi miras almak yerine, bazı nitelikleri üzerinde değişiklik yaparak miras almak istersek ne olacak? Mesela taban sınıf içinde self.güç değeri 0. Biz bu değerin Asker(), İşçi() ve Yönetici()örnekleriiçinbirbirindenfarklıolmasınıisteyebiliriz.Veyatabansınıfıolduğugibi miras almakla birlikte, alt sınıflardan herhangi birine ilave nitelik veya nitelikler eklemek de isteyebiliriz. Diyelim ki biz Asker() sınıfı için, öteki sınıflardan farklı olarak, bir de memleket niteliğitanımlamakistiyoruz.Pekibudurumdaneyapacağız? İştebununiçinAsker()sınıfınışuşekildeyazabiliriz: class Asker(Oyuncu): memleket = ’Arpaçbahşiş’ Burada Asker() sınıfına memleket adlı bir sınıf niteliği eklemiş olduk. Dolayısıyla Asker() sınıfı, Oyuncu() adlı taban sınıftan miras alınan bütün nitelik ve metotlarla birlikte bir de memleketniteliğinesahipolmuşoldu: >>> asker = Asker(’Ahmet’, ’binbaşı’) >>> asker.isim ’Ahmet’ >>> asker.memleket ’Arpaçbahşiş’ Elbette,buniteliğiöbüraltsınıflardatanımlamadığımıziçinbunitelikyalnızcaAsker()sınıfına özgüdür. Aynışekilde,birtabansınıftantüreyenbiraltsınıfayenibirsınıfmetodu,örnekmetoduveya statikmetotdaekleyebiliriz: class Asker(Oyuncu): memleket = ’Arpaçbahşiş’ def örnek_metodu(self): pass @classmethod def sınıf_metodu(cls): (sonrakisayfayadevam) 858 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pass @staticmethod def statik_metot(): pass Kural şu: Eğeralt sınıfaeklenen herhangi birnitelik veyametot tabansınıfta zaten varsa,alt sınıfa eklenen nitelik ve metotlar taban sınıftaki metot ve niteliklerin yerine geçecektir. Yani diyelimkitabansınıfımızşu: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) BusınıfınnitelikvemetotlarınımirasyoluyladevralanAsker()sınıfımıziseşu: class Asker(Oyuncu): pass Şimdibusınıfiçindehareket_et()adlıbirörnekmetodutanımlayalım: class Asker(Oyuncu): def hareket_et(self): print(’yeni hareket_et() metodu’) Eğertabansınıftahareket_et()adlıbirmetotolmasaydı,Asker()adlıaltsınıf,tabansınıftan miras alınan öteki metot ve niteliklerle birlikte bir de hareket_et() adlı yeni bir örnek metodunasahipolmuşolacaktı.Ancaktabansınıftazatenhareket_et()adlıbirörnekmetodu olduğuiçin,altsınıftatanımladığımızaynıadlıörnekmetodu,tabansınıftakimetodunyerine geçipüzerineyazıyor. Buraya kadar her şey tamam. Artık bir taban sınıfa ait metodu alt sınıfa miras yoluyla aktarırken nasıl yeniden tanımlayacağımızı öğrendik. Ayrıca alt sınıflara nasıl yeni metot ve nitelikekleyeceğimizidebiliyoruz.Amamesela,self.isimveself.rütbedeğişkenlerinikorurken, taban sınıf içinde 0 değeri ile gösterilen self.güç değişkenini Asker(), İşçi() ve Yönetici() sınıflarının her biri içinde nasıl farklı bir değerle göstereceğimizi bilmiyoruz. Yani self.güç değerini Asker() sınıfı içinde 100, İşçi() sınıfı içinde 70, Yönetici() sınıfı içinde ise 50 ile göstermekisteseknasılbiryoltakipetmemizgerektiğikonusundabirfikrimizyok.İsterseniz şuanakadarbildiğimizyöntemlerikullanarakbuamacımızıgerçekleştirmeyibirdeneyelim: 43.4. MirasAlmaTürleri 859 PythonBelgeleri,Yayım4.1.3 class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): def __init__(self, isim, rütbe): self.güç = 100 class İşçi(Oyuncu): def __init__(self, isim, rütbe): self.güç = 70 class Yönetici(Oyuncu): def __init__(self, isim, rütbe): self.güç = 50 Burada taban sınıfın __init__() metodunu alt sınıflarda yeniden tanımladık. Bu kodları bu şekildeyazıpçalıştırdığımızdaself.güçdeğerininherbiralt sınıfiçinistediğimizdeğeresahip olduğunu görürüz. Ancak burada şöyle bir sorun var. Bu kodları bu şekilde yazarak self.isim veself.rütbedeğişkenlerinindeğerinimaalesefkaybettik... __init__() metodunun parametre listesine isim ve rütbe parametrelerini yazdığımız halde bunlarıkodlarımıziçindeherhangibirşekildekullanmadığımıziçin,buparametrelerinlistede görünüyorolmasıbirşeyifadeetmiyor.Yanialtsınıflardatanımladığımız__init__()metodu bizden isim ve rütbe adlı iki parametre bekliyor olsa da, bu parametrelerin değerini kodlar içinde kullanmadığımız için bu parametrelere değer atamamız herhangi bir amaca hizmet etmiyor. Gelinbusöylediklerimizikanıtlayalım: >>> import oyuncular >>> asker = oyuncular.Asker(’Ahmet’, ’Er’) >>> asker.rütbe Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’Asker’ object has no attribute ’rütbe’ >>> asker.isim (sonrakisayfayadevam) 860 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’Asker’ object has no attribute ’isim’ Busorunuçözmekiçinaltsınıflarımızışuşekildeyazabiliriz: class Asker(Oyuncu): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 100 class İşçi(Oyuncu): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 70 class Yönetici(Oyuncu): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 50 Burada self.isim ve self.rütbe değişkenlerini her bir alt sınıf için tekrar tanımladık. Bu küçük örnekte pek sorun olmayabilir, ama taban sınıfın __init__() metodunun içinde çok daha karmaşık işlemlerin yapıldığı durumlarda yukarıdaki yaklaşım hiç de pratik olmayacaktır. Ayrıca eğer miras alma işlemini, içeriğini bilmediğiniz veya başka bir dosyada bulunan bir sınıftan yapıyorsanız yukarıdaki yöntem tamamen kullanışsız olacaktır. Ayrıca aynı şeyleri tekrartekraryazmakmirasalmamekanizmasınınruhunatamamenaykırıdır.Çünkübizmiras almaişleminizatenaynışeyleritekrartekraryazmaktankurtulmakiçinyapıyoruz. Bu arada, yukarıda yapmak istediğimiz şeyi şununla karıştırmayın: Biz elbette taban sınıftaki bir niteliği, örnekleme sırasında değiştirme imkanına her koşulda sahibiz. Yani taban ve alt sınıflarınşöyletanımlanmışolduğunuvarsayarsak: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) (sonrakisayfayadevam) 43.4. MirasAlmaTürleri 861 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class Asker(Oyuncu): pass class İşçi(Oyuncu): pass class Yönetici(Oyuncu): pass Herbiraltsınıfıngüçdeğişkeninişuşekildedeğiştirebiliriz: >>> import oyuncular >>> asker = oyuncular.Asker(’Ahmet’, ’Er’) >>> asker.güç 0 Gördüğünüzgibişuandaaskeringücü0.Bunu100yapalım: >>> asker.güç = 100 >>> asker.güç 100 Aynı şeyi öteki İşçi() ve Yönetici() sınıflarının örnekleri üzerinde de yapabiliriz. Ama bizim istediğimiz bu değil. Biz, Asker() sınıfını örneklediğimiz anda gücü 100, İşçi() sınıfını örneklediğimiz anda gücü 70, Yönetici() sınıfını örneklediğimiz anda ise gücü 50 olsun istiyoruz. İşte tam bu noktada imdadımıza yepyeni bir fonksiyon yetişecek. Bu yeni fonksiyonun adı super(). 43.5 super() Hatırlarsanız,tabansınıflardanilkkezbahsederken,bunlaraüstsınıfdadendiğinisöylemiştik. Üst sınıf kavramının İngilizcesi super class’tır. İşte bu bölümde inceleyeceğimiz super() fonksiyonunun adı da buradaki ‘super’, yani ‘üst’ kelimesinden gelir. Miras alınan üst sınıfa atıftabulunansuper()fonksiyonu,mirasaldığımızbirüstsınıfınnitelikvemetotlarıüzerinde değişiklikyaparken,mevcutözellikleridemuhafazaedebilmemizisağlar. Biröncekibaşlıktaverdiğimizörneküzerindensuper()fonksiyonunuaçıklamayaçalışalım: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 (sonrakisayfayadevam) 862 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): def __init__(self, isim, rütbe): self.güç = 100 Bu kodlarda, Oyuncu() adlı taban sınıfı miras alan Asker() sınıfı, __init__() metodu içinde self.güç değerini yeniden tanımlıyor. Ancak bu şekilde taban sınıfın __init__() metodu silindiğiiçin,self.isimveself.rütbedeğişkenlerinikaybediyoruz.İştebusorunu,üstsınıfaatıfta bulunansuper()fonksiyonuileçözebiliriz. Dikkatlicebakın: class Asker(Oyuncu): def __init__(self, isim, rütbe): super().__init__(isim, rütbe) self.güç = 100 Burada__init__()metoduiçindeşöylebirsatırkullandığımızıgörüyorsunuz: super().__init__(isim, rütbe) İşte bu satırda super() fonksiyonu, tam da adının anlamına uygun olarak, miras alınan üst sınıfın __init__() metodu içindeki kodların, miras alan alt sınıfın __init__() metodu içine aktarılmasını sağlıyor. Böylece hem taban sınıfın __init__() metodu içindeki self.isim ve self.rütbeniteliklerinikorumuş,hemdeself.güçadlıyenibirnitelikeklemeimkanıeldeetmiş oluyoruz: >>> asker = oyuncular.Asker(’Ahmet’, ’Er’) >>> asker.isim ’Ahmet’ >>> asker.rütbe ’Er’ >>> asker.güç 100 Bubilgiyiötekialtsınıflaradauygulayalım: 43.5. super() 863 PythonBelgeleri,Yayım4.1.3 class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): def __init__(self, isim, rütbe): super().__init__(isim, rütbe) self.güç = 100 class İşçi(Oyuncu): def __init__(self, isim, rütbe): super().__init__(isim, rütbe) self.güç = 70 class Yönetici(Oyuncu): def __init__(self, isim, rütbe): super().__init__(isim, rütbe) self.güç = 20 Gördüğünüz gibi, super() fonksiyonu sayesinde taban sınıfın değiştirmek istediğimiz niteliklerine yeni değerler atarken, değiştirmek istemediğimiz nitelikleri ise aynı şekilde muhafazaettik. Buaradaeğertabansınıfın__init__()metodundakiparametrelistesinialtsınıftadatektek tekraretmeksizirahatsızediyorsayukarıdakikodlarışöyledeyazabilirsiniz: class Asker(Oyuncu): def __init__(self, *arglar): super().__init__(*arglar) self.güç = 100 class İşçi(Oyuncu): def __init__(self, *arglar): super().__init__(*arglar) self.güç = 70 class Yönetici(Oyuncu): def __init__(self, *arglar): super().__init__(*arglar) self.güç = 20 864 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Yıldızlı parametreleri önceki derslerimizden hatırlıyor olmalısınız. Bildiğiniz gibi, tek yıldızlı parametreler bir fonksiyonun bütün konumlu (positional) argümanlarını, parametrelerin parantez içinde geçtiği sırayı dikkate alarak bir demet içinde toplar. İşte yukarıda da bu özelliktenfaydalanıyoruz.Eğertabansınıftaisimli(keyword)argümanlardaolsaydı,ozaman daçiftyıldızlıargümanlarıkullanabilirdik. Tekveçiftyıldızlıargümanlargenellikleşuşekildegösterilir: class Asker(Oyuncu): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.güç = 100 Böylece konumlu argümanları bir demet içinde, isimli argümanları ise bir sözlük içinde toplamışoluyoruz.Budabiziüst(yadataban)sınıfınparametrelistesinialtsınıflardatekrar etmederdindenkurtarıyor. Buarada,mirasalınantabansınıfaatıftabulunansuper()fonksiyonu,Pythonprogramlama diline sonradan eklenmiş bir özelliktir. Bu fonksiyon gelmeden önce taban sınıfa atıfta bulunabilmekiçindoğrudanosınıfınadınıkullanıyorduk: class Asker(Oyuncu): def __init__(self, isim, rütbe): Oyuncu.__init__(self, isim, rütbe) self.güç = 100 veya: class Asker(Oyuncu): def __init__(self, *args): Oyuncu.__init__(self, *args) self.güç = 100 Gördüğünüz gibi, eski yöntemde taban sınıfın adını iki kez kullanmamız gerekiyor. Ayrıca __init__() fonksiyonunun parametre listesinde ilk sıraya yine self kelimesini de eklemek zorundakalıyoruz. İstersenizyukarıdagösterdiğimizeskiyöntemikullanmayadevamedebilirsinizelbette.Ancak super()fonksiyonunukullanmakeskiyöntemegörebirazdahapratiktir. Yukarıdaki örneklerde super() fonksiyonunu __init__() metodu içinde kullandık. Ancak elbette super() fonksiyonunu yalnızca __init__() fonksiyonu içinde kullanmak zorunda değiliz.Bufonksiyonubaşkafonksiyonlariçindedekullanabiliriz: class Oyuncu(): def __init__(self, isim, rütbe): self.isim = isim self.rütbe = rütbe self.güç = 0 def hareket_et(self): print(’hareket ediliyor...’) (sonrakisayfayadevam) 43.5. super() 865 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def puan_kazan(self): print(’puan kazanıldı’) def puan_kaybet(self): print(’puan kaybedildi’) class Asker(Oyuncu): def __init__(self, isim, rütbe): super().__init__(isim, rütbe) self.güç = 100 def hareket_et(self): super().hareket_et() print(’hedefe ulaşıldı.’) Bu örneğin, super() fonksiyonunun nasıl işlediğini daha iyi anlamanızı sağladığını zannediyorum. Gördüğünüz gibi, taban sınıfın hareket_et() adlı metodunu alt sınıfta tanımladığımız aynı adlı fonksiyon içinde super() fonksiyonu yardımıyla genişlettik, yani tabansınıfınhareket_et()adlıfonksiyonunayenibirişlevekledik: def hareket_et(self): super().hareket_et() print(’hedefe ulaşıldı.’) Burada super().hareket_et() satırıyla taban sınıfın hareket_et() adlı metodunu alt sınıfta tanımladığımızyenihareket_et()metoduiçindeçalıştırarak,bumetodunkabiliyetleriniyeni hareket_et()metodunaaktarıyoruz. 43.6 object Sınıfı BizburayagelinceyekadarPython’dasınıflarıikifarklışekildetanımlayabileceğimiziöğrendik: class Deneme(): pass veya: class Deneme: pass Sınıf tanımlarken parantez kullansak da olur kullanmasak da. Eğer miras alacağınız bir sınıf yoksa parantezsiz yazımı tercih edebilir, parantezli yazım tarzını ise başka bir sınıftan miras aldığınızdurumlariçinsaklayabilirsiniz: class AltSınıf(TabanSınıf): pass Ancak sağda solda incelediğiniz Python kodlarında bazen şöyle bir sınıf tanımlama şekli de görürsenizşaşırmayın: 866 Bölüm43. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 class Sınıf(object): pass Python’ın 3.x öncesi sürümlerinde sınıflar yeni ve eski tip olmak üzere ikiye ayrılıyordu. Bu sürümlerdeeskitipsınıflarşöyletanımlanıyordu: class Sınıf: pass veya: class Sınıf(): pass Yenitipsınıflariseşöyle: class Sınıf(object): pass Yani eski tip sınıflar öntanımlı olarak herhangi bir taban sınıftan miras almazken, yeni tip sınıfların object adlı bir sınıftan miras alması gerekiyordu. Dolayısıyla, tanımladığınız bir sınıfta object sınıfını miras almadığınızda, yeni tip sınıflarla birlikte gelen özelliklerden yararlanamıyordunuz. Mesela önceki derslerde öğrendiğimiz @property bezeyicisi yeni tip sınıflarla gelen bir özelliktir. Eğer Python 3 öncesi bir sürüm için kod yazıyorsanız ve eğer @propertybezeyicisinikullanmakistiyorsanıztanımladığınızsınıflardaaçıkaçıkobjectsınıfını mirasalmalısınız. Python 3’te ise bütün sınıflar yeni tip sınıftır. Dolayısıyla object sınıfını miras alsanız da almasanızda,tanımladığınızbütünsınıflaröntanımlıolarakobjectsınıfınımirasalacaktır.Yani Python3açısındanşuüçtanımlamaarasındabirfarkbulunmaz: class Sınıf: pass class Sınıf(): pass class Sınıf(object): pass Bunların hepsi de Python 3 açısından birer yeni tip sınıftır. Daha doğrusu Python 3’te bütün sınıflarbiryenitipsınıfolduğuiçin,yukarıdakisınıftanımlamalarıhepaynıtiptesınıflaraişaret eder.Python2’deiseilkikitanımlamaeskitipsınıflarıgösterirken,yalnızcaüçüncütanımlama yenitipsınıflarıgösterir. Geldik bir bölümün daha sonuna... Böylece miras almaya ilişkin temel konuları incelemiş olduk. Bu bölümde öğrendiklerimiz sayesinde, etrafta gördüğümüz, miras alma mekanizmasının kullanıldığı kodların çok büyük bir bölümünü anlayabilecek duruma geldik. Bu mekanizmaya ilişkin olarak öğrenmemiz gerekenlerin geri kalanını da bir sonraki bölümde,grafikarayüztasarımıkonusuylabirlikteelealacağız. 43.6. objectSınıfı 867 44 BÖLÜM Nesne Tabanlı Programlama (Devamı) . Uyarı Bumakaleyoğunbirşekildegeliştirilmekte,içeriğisıksıkgüncellenmektedir. Geçenbölümdeverdiğimizbilgilersayesindemirasalmakonusununtemelinioluşturantaban sınıf,altsınıfvetüremegibikavramlarlabirliktesuper()veobjectgibiaraçlarınneolduğunu veneişeyaradığınıdaöğrendik.Dolayısıylaartıkmirasalmamekanizmasınadairdaharenkli, dahateşvikediciörneklerverebiliriz.Böylece,belkidegözünüzeilkbakıştapekdematahbir şey değilmiş gibi görünen bu ‘miras alma’ denen mekanizmanın aslında ne kadar önemli bir konuolduğunasizleriiknaedebiliriz. Bu bölümde ayrıca geçen bölümlerde incelemeye fırsat bulamasak da nesne tabanlı programlamakapsamındaincelememizgerekenbaşkakonularıdaelealacağız. Nesne tabanlı programlamadan ilk bahsettiğimiz derste, nesne tabanlı programlama yaklaşımınıngrafikarayüztasarımıiçinbiçilmişkaftanolduğundansözetmiştikhatırlarsanız. Bubölümdeinceleyeceğimizkonularınbazılarınıgrafikarayüztasarımıeşliğindeanlatacağız. Grafik arayüz programlamanın bize sunduğu düğmeli-menülü görsel programların, nesne tabanlı programlamaya ilişkin soyut kavramları somut bir düzleme taşımamıza imkan tanımasısayesinde,nesnetabanlıprogramlamayailişkinçetrefillikonularıdaharahatanlama fırsatıbulacağız. 868 PythonBelgeleri,Yayım4.1.3 44.1 Tkinter Hakkında Hatırlarsanız,öncekiderslerimizdebirkaçkezTkinteradlıbirmodüldensözetmiştik.Tkinter, Python kurulumu ile birlikte gelen ve pencereli-menülü modern programlar yazmamızı sağlayangrafikarayüzgeliştirmetakımlarındanbiridir. Tkinterbirstandartkütüphanepaketiolduğuiçin,Pythonprogramlamadilinikurduğunuzda Tkinterdeotomatikolarakkurulur31. ElbettePython’dagrafikarayüzlüprogramlaryazmamızısağlayacaktekmodülTkinterdeğildir. Bunun dışında PyQt, PyGI ve Kivy gibi alternatifler de bulunur. Ancak Tkinter’in öteki alternatiflere karşı en büyük üstünlüğü hem öbürlerine kıyasla çok daha kolay olması hem de Python’la birlikte gelmesidir. PyQt, PyGI ve Kivy’yi kullanabilmek için öncelikle bunları bilgisayarınıza kurmanız gerekir. Ayrıca Tkinter dışındaki alternatifleri kullanarak yazdığınız programları dağıtırken, bu arayüz kütüphanelerini kullanıcılarınızın bilgisayarına ya kendiniz kurmanızyadakullanıcılarınızdanbukütüphanelerikurmasınıtalepetmenizgerekir. Ben size, ilerde başka arayüz takımlarına geçiş yapacak da olsanız, Tkinter’i mutlaka öğrenmenizitavsiyeederim.Hemnesnetabanlıprogramlamahemdegrafikarayüzgeliştirme kavramlarınıöğrenmekaçısındanTkintersondereceuygunbirortamdır. Biz bu bölümde Tkinter modülünü kullanarak, prosedürel programlama, nesne tabanlı programlama,sınıflar,mirasalmavenesneprogramlamayailişkinötekikonularüzerineufak tefek de olsa bazı çalışmalar yapacağız. Bu çalışmalar sayesinde bir yandan öğrendiğimiz eski konulara ilişkin güzel bir pratik yapma imkanı bulacağız, bir yandan Tkinter’in çalışmalarımızın sonucunu görsel bir şekilde izleme imkanı sağlaması sayesinde nesne tabanlıprogramlamanınçetrefillikavramlarınıanlamamızkolaylaşacak,biryandandailkkez gördüğümüzkodlarıanlamavebunlarhakkındafikiryürütmekabiliyetikazanacağız.Yanibir taşlatamıtamınaüçkuşvurmuşolacağız... 44.2 Prosedürel Bir Örnek Baştadasöylediğimizgibi,nesnetabanlıprogramlama,grafikarayüzlüprogramlargeliştirmek için son derece uygun bir programlama yaklaşımıdır. Zaten kendi araştırmalarınız sırasında da, etraftaki grafik arayüzlü programların büyük çoğunluğunun nesne tabanlı programlama yaklaşımıyla yazıldığını göreceksiniz. Biz de bu derste vereceğimiz Tkinter örneklerinde sınıflı yapıları kullanacağız. Ancak dilerseniz Tkinter’in nasıl bir şey olduğunu daha kolay anlayabilmek için öncelikle nesne tabanlı yaklaşım yerine prosedürel yaklaşımı kullanarak birkaç küçük çalışma yapalım. Zira özellikle basit kodlarda, prosedürel yapıyı anlamak nesne tabanlı programlama yaklaşımı ile yazılmış kodları anlamaktan daha kolaydır. Ancak tabii ki kodlarbüyüyüpkarmaşıklaştıkçasınıflıyapılarıkullanmakçokdahaakıllıcaolacaktır. O halde gelin isterseniz Tkinter modülünü nasıl kullanacağımızı anlamak için, bir metin dosyasıaçıpiçineşukodlarıyazalım: import tkinter (sonrakisayfayadevam) 31GNU/Linux dağıtımlarında, dağıtımı geliştiren ekip genellikle Tkinter paketini Python paketinden ayırdığı için, Tkinter’i ayrıca kurmanız gerekebilir. Eğer Python’ın etkileşimli kabuğunda import tkinter komutunu verdiğinizde bir hata mesajı alıyorsanız https://forum..com/ adresinden yardım isteyin. Eğer Windows kullanıyorsanız,böylebirprobleminizyok.Python’ıkurduğunuzandaTkinterdeemrinizeamadedir. 44.1. TkinterHakkında 869 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pencere = tkinter.Tk() pencere.mainloop() Bu kodları herhangi bir Python programı gibi kaydedip çalıştırdığınızda boş bir pencerenin açıldığınıgöreceksiniz.İşteböylecesiyahkomutsatırındanrenkligrafikarayüzegeçişyapmış oldunuz.Hadihayırlıolsun! Gördüğünüzgibi,bukodlardasınıflarıkullanmadık.Dediğimizgibi,ilketaptaTkinter’idahaiyi anlayabilmekiçinsınıflıyapılaryerineprosedürelbiryaklaşımıbenimseyeceğiz. BuradaöncelikleTkintermodülünüiçeaktardığımızadikkatedin: import tkinter Modülü bu şekilde içe aktardığımız için, modül içindeki nitelik ve metotlara erişmek istediğimizde modülün adını kullanmamız gerekecek. Mesela yukarıda modülün adını kullanarak,tkintermodülüiçindekiTk()sınıfınıörnekledik: pencere = tkinter.Tk() Dilerseniziçeaktarmaişleminişuşekildeyaparakişlerimizibirazdahakolaylaştırabiliriz: import tkinter as tk Böylecetkintermodülününnitelikvemetotlarına‘tkinter’yerine‘tk’önekiyleerişebiliriz: pencere = tk.Tk() Yukarıdaki kodları yazdığımızda, yani tkinter modülünün Tk() sınıfını örneklediğimiz anda aslında penceremiz oluştu. Ancak bu pencere örnekleme ile birlikte oluşmuş olsa da, Tkinter’in iç işleyişi gereği, ‘ana döngü’ adlı bir mekanizma çalışmaya başlamadan görünür hale gelmez. İşte bu özel ana döngü mekanizmasını çalıştırmak ve böylece oluşturduğumuz pencereyi görünür hale getirmek için, Tk() sınıf örneklerinin mainloop() adlı bir metodunu çalıştıracağız: pencere.mainloop() Gördüğünüz gibi, Tk() sınıfını pencere adıyla örnekledikten sonra Tk() sınıfının mainloop() adlımetodunapencereörneğiüzerindeneriştik. Bu ana döngü mekanizmasının benzerlerini Tkinter’in dışındaki öbür grafik arayüz tasarım araçlarındadagöreceksiniz. Buarada,yukarıdakiprosedürelörnektebile,bizistemesekdesınıflarlamuhatapolduğumuza dikkatinizi çekmek isterim. Çünkü kullandığımız tkinter modülünün kendisi halihazırda birtakım sınıflardan oluşuyor. Dolayısıyla bu modülü içe aktardığımızda, kodlarımızın içine pek çok sınıfı ister istemez dahil etmiş oluyoruz. Esasında sırf bu durum bile, grafik arayüzlü programlarda neden nesne tabanlı programlamanın tercih edildiğini gayet güzel gösteriyor bize.Neticede,kullandığımızharicikaynaklardanötürüherşekildesınıflarlavenesnetabanlı yapılarla içli dışlı olacağımız için, kendi yazdığımız kodlarda da nesne tabanlı yapılardan kaçmamızınhiçbirgerekçesiyok. Neyse... Bizkonumuzadönelim... 870 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Yukarıda Tkinter modülünü kullanarak boş bir pencere oluşturduk. Gelin isterseniz bu boş pencereüzerindebirtakımdeğişiklikleryapalım. Öncelikletkintermodülümüzüiçeaktaralım: import tkinter as tk ŞimdibumodülünTk()adlısınıfınıörnekleyelim: pencere = tk.Tk() Böylece penceremizi oluşturmuş olduk. Tkinter’le verdiğimiz ilk örnekte de gördüğünüz gibi, Tkinter’le oluşturulan boş bir pencere öntanımlı olarak 200 piksel genişliğe ve 200 piksel yüksekliğe sahip olacaktır. Ancak isterseniz, Tk() sınıfının geometry() adlı metodunu kullanarak, pencere boyutunu ayarlayabilirsiniz (Tk() sınıfının hangi metotlara sahipolduğunugörmekiçindir(pencere)komutunuverebileceğinizibiliyorsunuz): import tkinter as tk pencere = tk.Tk() pencere.geometry(’200x70’) pencere.mainloop() Kendi yazdığımız sınıflardaki nitelik ve metotlara nasıl erişiyorsak, Tk() sınıfının nitelik ve metotlarına da aynı şekilde eriştiğimize dikkat edin. Neticede bizim yazdıklarımız da sınıftır, Tk() da sınıftır. Tk() sınıfının bizimkilerden tek farkı, Tk() sınıfının Python geliştiricilerince yazılmış olmasıdır. Yazarları farklı olsa da bütün sınıflar aynı kurallara tabidir. Dolayısıyla ilgili sınıfı kullanabilmek için önce sınıfımızı örnekliyoruz, ardından da bu sınıf içinde tanımlı olan nitelik ve metotlara noktalı gösterim tekniğini kullanarak ulaşıyoruz. Burada da Tk() sınıf örneklerinin geometry() metodunu kullanarak 200x200 yerine 200x70 boyutlarında bir pencereoluşturduk: pencere.geometry(’200x70’) Şimdibuboşpencereyebiretiketbirdedüğmeekleyelim: import tkinter as tk pencere = tk.Tk() pencere.geometry(’200x70’) etiket = tk.Label(text=’Merhaba Zalim Dünya’) etiket.pack() düğme = tk.Button(text=’Tamam’, command=pencere.destroy) düğme.pack() pencere.mainloop() BuradatkintermodülününTk()sınıfınaekolarak,aynımodülünLabel()veButton()adlıiki sınıfını daha kullandık. Label() sınıfı etiketler, Button() sınıfı ise düğmeler oluşturmamızı 44.2. ProsedürelBirÖrnek 871 PythonBelgeleri,Yayım4.1.3 sağlıyor. Bu sınıfların örnekleri üzerinde çalıştırdığımız pack() metodunu ise, etiket ve düğmeleripencereüzerineyerleştirmekiçinkullanıyoruz. Label() ve Button() sınıflarının text adlı bir parametre aldığını görüyorsunuz. Bu parametrenindeğeri,etiketveyadüğmeninüzerindeneyazacağınıgösteriyor. BukodlarıdatıpkıbaşkaPythonprogramlarınıçalıştırdığınızgibiçalıştırabilirsiniz. Bu arada, Tkinter’de bir şeyi oluşturmanın ve görünür hale getirmenin iki farklı işlem gerektirdiğine özellikle dikkat edin. Mesela üzerinde ‘Merhaba Zalim Dünya’ yazan bir etiket oluşturmakiçinşukodukullanıyoruz: etiket = tk.Label(text=’Merhaba Zalim Dünya’) Bu etiketi pencere üzerine yerleştirmek, yani görünür hale getirmek için ise şu komutu kullanıyoruz: etiket.pack() Aynışekildebirdüğmeoluşturmakiçindeşukomutukullanıyoruz: düğme = tk.Button(text=’Tamam’, command=pencere.destroy) Böylece üzerinde ‘Tamam’ yazan ve tıklandığında pencereyi kapatan bir düğme oluşturmuş oluyoruz. Düğmenin üzerine tıklandığında ne olacağını Button() sınıfının command parametresi aracılığıyla belirledik. Bu parametreye, pencereörneğinindestroy()metodunu verdiğimizde pencereye kapatma sinyali gönderilecektir. Yalnız bu metodu yazarken parantezişaretlerinikullanmadığımızadikkatedin.Eğermetodupencere.destroy()şeklinde parantezli bir biçimde yazarsak, kapatma komutu daha düğmeye basmadan çalışacak ve bu durumdadüğmemizdüzgünişlemeyecektir. Tıpkı etikette olduğu gibi, düğmemizi de pencere üzerine yerleştirmek, yani görünür hale getirmekiçinpack()metodundanyararlanıyoruz: düğme.pack() Bunun, Tk() sınıfı ile mainloop() metodu arasındaki ilişkiye benzediğine dikkatinizi çekmek isterim: Tıpkı pack() metoduna benzer bir şekilde, Tk() sınıfı yardımıyla da bir pencere oluşturduktan sonra, bu pencerenin görünür hale gelebilmesi için mainloop() metodunu çalıştırmamızgerektiğinihatırlıyorsunuz. Bu kodlarda Tkinter’e ilişkin ayrıntılardan ziyade, sınıflı yapıları kodlarımıza nasıl dahil ettiğimize ve bunları nasıl kullandığımıza odaklanmanızı istiyorum. Gördüğünüz gibi, tkinter modülünden içe aktardığımız Tk(), Label() ve Button() gibi sınıfların metot ve niteliklerini, meselatıpkıkarakterdizilerininmetotveniteliklerinikullanırgibikullanıyoruz. Yukarıdaki örnekte, tkinter modülünün sınıflarını, kodlarımız içine prosedürel olarak dahil ettik. Yani her sınıfı, belli bir sıraya göre kodlarımız içinde belirtip, bunları adım adım çalıştırdık.Prosedürelprogramlamadakodlarınyazılışsırasıçokönemlidir.Bunukanıtlamak içinçokbasitbirörnekverelim: import tkinter as tk pencere = tk.Tk() (sonrakisayfayadevam) 872 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def çıkış(): etiket[’text’] = ’Elveda zalim dünya...’ düğme[’text’] = ’Bekleyin...’ düğme[’state’] = ’disabled’ pencere.after(2000, pencere.destroy) etiket = tk.Label(text=’Merhaba Zalim Dünya’) etiket.pack() düğme = tk.Button(text=’Çık’, command=çıkış) düğme.pack() pencere.protocol(’WM_DELETE_WINDOW’, çıkış) pencere.mainloop() Buradaherzamankigibiönceliklegereklimodülüiçeaktardık: import tkinter as tk DahasonraTk()sınıfıyardımıylapenceremizioluşturduk: pencere = tk.Tk() Ardındançıkış()adlıbirfonksiyontanımladık: def çıkış(): etiket[’text’] = ’Elveda zalim dünya...’ düğme[’text’] = ’Bekleyin...’ düğme[’state’] = ’disabled’ pencere.after(2000, pencere.destroy) Bu fonksiyon, pencere kapatılırken hangi işlemlerin yapılacağını belirliyor. Buna göre, programdançıkılırkensırasıylaşuişlemlerigerçekleştiriyoruz: 1. Etiketintextparametresini‘Elvedazalimdünya...’olarakdeğiştiriyoruz. 2. Düğmenintextparametresini‘Bekleyin...’olarakdeğiştiriyoruz. 3. Düğmenin state parametresini ‘disabled’ olarak değiştirerek düğmeyi basılamaz hale getiriyoruz. 4. 2000 milisaniye (yani 2 saniye) sonra ise pencere.destroy() komutunu işleterek pencereninkapanmasınısağlıyoruz. çıkış()fonksiyonunutanımladıktansonraLabel()veButton()düğmeleriaracılığıylaetiket vedüğmelerimizioluşturuyoruz: etiket = tk.Label(text=’Merhaba Zalim Dünya’) etiket.pack() düğme = tk.Button(text=’Çık’, command=çıkış) düğme.pack() 44.2. ProsedürelBirÖrnek 873 PythonBelgeleri,Yayım4.1.3 Bunagöre,düğmeyebasıldığında,commandparametresinindeğeriolançıkış()fonksiyonu çalışmayabaşlayacakvefonksiyongövdesindetanımladığımızişlemlergerçekleşecek. Bildiğiniz gibi, bir program penceresinde, o programı kapatmayı sağlayacak düğmelerin yanı sıra,birdeenüstsağ(veyasol)köşedeprogrampenceresinikapatanbir‘X’düğmesibulunur. İşte bu ‘X’ düğmesine basıldığında da pencere kapanmadan önce çıkış() fonksiyonunun çalışmasıiçinşukoduyazıyoruz: pencere.protocol(’WM_DELETE_WINDOW’, çıkış) protocol() de tıpkı geometry() gibi, Tk() sınıfının metotlarından biridir. Bu metodu WM_DELETE_WINDOW argümanıyla birlikte kullanarak, pencere üzerindeki ‘X’ düğmesine basıldığındanelerolacağınıtanımlayabiliyoruz. Son olarak da ana döngü mekanizmasını çalıştırıyoruz ve penceremizi görünür hale getiriyoruz: pencere.mainloop() Buprosedürelkodlarıtekrarönümüzealalım: import tkinter as tk pencere = tk.Tk() def çıkış(): etiket[’text’] = ’Elveda zalim dünya...’ düğme[’text’] = ’Bekleyin...’ düğme[’state’] = ’disabled’ pencere.after(2000, pencere.destroy) etiket = tk.Label(text=’Merhaba Zalim Dünya’) etiket.pack() düğme = tk.Button(text=’Çık’, command=çıkış) düğme.pack() pencere.protocol(’WM_DELETE_WINDOW’, çıkış) pencere.mainloop() Enbaştadasöylediğimizgibi,bukodlarda,satırsıralarıçokönemlidir.Meselaburadadüğmeyi oluşturan kodlarla pencere.protocol() kodlarının çalışması için bunların mutlaka çıkış() fonksiyonutanımlandıktansonrayazılmasıgerekir.Eğerbukodlarışöyleyazarsanız: import tkinter as tk pencere = tk.Tk() pencere.protocol(’WM_DELETE_WINDOW’, çıkış) def çıkış(): etiket[’text’] = ’Elveda zalim dünya...’ (sonrakisayfayadevam) 874 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) düğme[’text’] = ’Bekleyin...’ düğme[’state’] = ’disabled’ pencere.after(2000, pencere.destroy) etiket = tk.Label(text=’Merhaba Zalim Dünya’) etiket.pack() düğme = tk.Button(text=’Çık’, command=çıkış) düğme.pack() pencere.mainloop() ... programınızçalışmayacaktır. Bu durum, programcıyı, istediği kod düzenini oturtmak konusunda epey kısıtlar. Ama eğer nesne tabanlı programlama yaklaşımını kullanırsak kod akışını belirlerken daha özgür olabiliriz. Ayrıca prosedürel yaklaşımda kodlar büyüdükçe programınızın çorbaya dönme ihtimali nesne tabanlı programlama yaklaşımına göre daha fazladır. Ancak elbette nesne tabanlı programlama yaklaşımını kullanmak tek başına düzgün ve düzenli kod yazmanın teminatı değildir. Nesne tabanlı programlama yaklaşımını kullanarak da gayet sebze çorbası kıvamındakodlaryazabilirsiniz.Enbaştadasöylediğimizgibi,nesnetabanlıprogramlamabir seçenektir. Eğer istemezseniz, nesne tabanlı programlama yaklaşımını kullanmak zorunda değilsiniz. Ama elinizde böyle bir imkanınız olduğunu ve başkalarının da bu yaklaşımdan yoğunbirşekildefaydalandığınıbilmekçokönemlidir. 44.3 Sınıflı Bir Örnek Bir önceki başlıkta Tkinter’i kullanılarak prosedürel bir kod yazdık. Peki acaba yukarıdaki kodlarınesnetabanlıolaraknasılyazabiliriz? Dikkatlicebakın: import tkinter as tk class Pencere(tk.Tk): def __init__(self): super().__init__() self.protocol(’WM_DELETE_WINDOW’, self.çıkış) self.etiket = tk.Label(text=’Merhaba Zalim Dünya’) self.etiket.pack() self.düğme = tk.Button(text=’Çık’, command=self.çıkış) self.düğme.pack() def çıkış(self): self.etiket[’text’] = ’Elveda zalim dünya...’ self.düğme[’text’] = ’Bekleyin...’ self.düğme[’state’] = ’disabled’ (sonrakisayfayadevam) 44.3. SınıflıBirÖrnek 875 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.after(2000, self.destroy) pencere = Pencere() pencere.mainloop() Bukodlardagördüğünüzbütünsatırlarıanlayacakkadarnesnetabanlıprogramlamabilgisine sahipsiniz.Amagelinbizyinedebukodlarısiziniçintektekvetanetaneaçıklayalım. Öncelikletkintermodülünütkadıylaiçeaktarıyoruz: import tkinter as tk DahasonraPencere()adlısınıfımızıtanımlamayabaşlıyoruz: class Pencere(tk.Tk): ... BuradaöncelikleTk()sınıfınımirasaldığımızadikkatedin.Busayedebusınıfıniçindekibütün nitelikvemetotlarıkendiuygulamamıziçindençağırabileceğiz. Penceremiz oluşur oluşmaz pencere üzerinde bir etiket ile bir düğme olmasını planlıyoruz. Pencere oluşur oluşmaz işletilecek kodları tanımlamak için bir __init__() metoduna ihtiyacımızolduğunubiliyorsunuz: class Pencere(tk.Tk): def __init__(self): ... Ancak kendi __init__() metodumuzu tanımlarken, Tk() sınıfının kendi __init__() metodundaki işlemleri de gölgelemememiz lazım. Dolayısıyla orijinal __init__() metodunu kendi__init__()metodumuzaaktarmakiçinsuper()fonksiyonundanyararlanacağız: class Pencere(tk.Tk): def __init__(self): super().__init__() Artıktabansınıfın__init__()metodunukenditanımladığımızaltsınıfın__init__()metodu içindenözelleştirmeyebaşlayabiliriz.Öncelikleşusatırıyazıyoruz: self.protocol(’WM_DELETE_WINDOW’, self.çıkış) protocol()metodununöntanımlıdavranışı,pencerenin‘X’düğmesinebasıldığındaprogramı sonlandırmaktır.İştebizbuöntanımlıdavranışıdeğiştirmekiçinprotocol()metodunuiçeren kodu tekrar tanımlıyoruz ve ‘X’ düğmesine basıldığında çıkış() fonksiyonunun çalışmasını sağlıyoruz. Dahasonranormalbirşekildeetiketimizivedüğmemizitanımlıyoruz: self.etiket = tk.Label(text=’Merhaba Zalim Dünya’) self.etiket.pack() self.düğme = tk.Button(text=’Çık’, command=self.çıkış) self.düğme.pack() 876 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 İkifarklıyerdeatıftabulunduğumuzçıkış()fonksiyonumuziseşöyle: def çıkış(self): self.etiket[’text’] = ’Elveda zalim dünya...’ self.düğme[’text’] = ’Bekleyin...’ self.düğme[’state’] = ’disabled’ self.after(2000, self.destroy) Sonolarakdaşukodlarıyazıpprogramımızıtamamlıyoruz: pencere = Pencere() pencere.mainloop() Elbette zevkler ve renkler tartışılmaz, ancak ben yukarıdaki kodları, prosedürel kodlara göre çokdahadüzgün,düzenli,anlaşılırveokunaklıbulduğumu,bukodlarabaktığımda,programı oluşturan parçaların prosedürel kodlara kıyasla daha yerli yerinde olduğunu düşündüğümü söylemedendegeçmeyeceğim... Eğer siz aksini düşünüyorsanız sizi prosedürel yolu tercih etmekten alıkoyan hiçbir şeyin olmadığınıdabilin.Ancaktabiikibu,nesnetabanlıprogramlamadankaçabileceğinizanlamına dagelmiyor!Unutmayın,buyaklaşımısizkullanmasanızdabaşkalarıkullanıyor. 44.4 Çoklu Miras Alma Python’da bir sınıf, aynı anda birden fazla sınıfı da miras alabilir. Eğer yazdığınız bir uygulamada birden fazla taban sınıftan nitelik ve metot miras almanız gerekirse bunu şu şekildegerçekleştirebilirsiniz: class Sınıf(taban_sınıf1, taban_sınıf2): pass Bu şekilde hem taban_sınıf1 hem de taban_sınıf2’de bulunan nitelik ve metotlar aynı anda Sınıf adlısınıfadahilolacaktır. Ufakbirörnekverelim.Diyelimkielimizdeşusınıflarvar: class c1: sn1 = ’sn1’ def __init__(self): self.ön1 = ’ön1’ print(self.ön1) def örn_metot1(self): self.öm1 = ’öm1’ return self.öm1 class c2: sn2 = ’sn2’ def __init__(self): (sonrakisayfayadevam) 44.4. ÇokluMirasAlma 877 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.ön2 = ’ön2’ print(self.ön2) def örn_metot2(self): self.öm2 = ’öm2’ return self.öm2 class c3: sn3 = ’sn3’ def __init__(self): self.ön3 = ’ön3’ print(self.ön3) def örn_metot3(self): self.öm3 = ’öm3’ return self.öm3 Burada üç farklı sınıf ve her bir sınıfın içinde de birer sınıf niteliği, birer __init__() metodu, birerörnekniteliğivebirerörnekmetodugörüyoruz. Şimdibuüçsınıfıbirdentabansınıfolarakmirasalandördüncübirsınıftanımlayalım: class c4(c1, c2, c3): pass Burada, taban sınıf vazifesi görecek sınıfların adını c4 sınıfının parantezleri arasına tek tek yerleştirdiğimize dikkat edin. Bu şekilde c1, c2 ve c3 adlı sınıfları aynı anda miras almış oluyoruz. İşte bu mekanizmaya Python’da çoklu miras alma (multiple inheritance) adı veriliyor. Tekbirsınıfımirasaldığınızdahangikurallargeçerliyse,birdenfazlasınıfımirasaldığınızdada temel olarak aynı kurallar geçerlidir. Ancak çoklu miras almada birden fazla sınıf söz konusu olduğu için, miras alınan sınıfların da kendi aralarında veya başka sınıflarla nitelik ve/veya metot alışverişi yapması halinde ortaya çıkabilecek beklenmedik durumlara karşı dikkatli olmalısınız. Ayrıca çoklu miras alma işlemi sırasında, aynı adı taşıyan metotlardan yalnızca birininmirasalınacağınıdaunutmayın. Örneğin: class c1: sn1 = ’sn1’ def __init__(self): self.ön1 = ’ön1’ print(self.ön1) def örn_metot1(self): self.öm1 = ’öm1’ return self.öm1 (sonrakisayfayadevam) 878 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def ortak_metot(self): self.om = ’ortak metot_c1’ return self.om class c2: sn2 = ’sn2’ def __init__(self): self.ön2 = ’ön2’ print(self.ön2) def örn_metot2(self): self.öm2 = ’öm2’ return self.öm2 def ortak_metot(self): self.om = ’ortak metot_c2’ return self.om class c3: sn3 = ’sn3’ def __init__(self): self.ön3 = ’ön3’ print(self.ön3) def örn_metot3(self): self.öm3 = ’öm3’ return self.öm3 def ortak_metot(self): self.om = ’ortak metot_c3’ return self.om class c4(c1, c2, c3): def __init__(self): super().__init__() Burada, aynı adı taşıyan __init__() ve ortak_metot() adlı metotlardan yalnızca biri miras alınacaktır. Bunlardan hangisinin miras alınacağını az çok tahmin etmişsinizdir. Evet, doğru bildiniz.Mirasalmalistesindehangisınıföndegeliyorsaonunmetotlarımirasalınacaktır: s = c4() print(s.ortak_metot()) Gördüğünüzgibi,c4()sınıfıöncec1sınıfınımirasaldığıiçinhepc1sınıfınınmetotlarıöncelik kazanıyor. Eğersınıflarıclass c4(c2, c3, c1):şeklindemirasalsaydık,bukezdec2sınıfınınmetotları öncelikkazanacaktı. 44.4. ÇokluMirasAlma 879 PythonBelgeleri,Yayım4.1.3 Elbette,Python’ınsiziniçinbelirlediğiönceliksırasıyerinekendibelirlediğinizönceliksırasını dadayatabilirsiniz: class c4(c1, c2, c3): def __init__(self): c2.__init__(self) def ortak_metot(self): return c3.ortak_metot(self) Buradac2sınıfının__init__()metoduilec3sınıfınınortak_metot’unamirasönceliğiverdik. 44.5 Dahil Etme Bir sınıftaki nitelik ve metotları başka bir sınıf içinde kullanmanın tek yolu ilgili sınıf veya sınıfları miras almak değildir. Hatta bazı durumlarda, miras alma iyi bir yöntem dahi olmayabilir.Özelliklebirdenfazlasınıfaaitnitelikvemetotlaraihtiyaçduyduğumuzda,çoklu miras alma yöntemini kullanmak yerine, dahil etme (composition) denen yöntemi tercih edebiliriz. Peki nedir bu dahil etme denen şey? Adından da anlaşılacağı gibi, dahil etme yönteminde, taban sınıfın nitelik ve metotlarını miras almak yerine, alt sınıf içine dahil ediyoruz. Esasında bizbununörneğinigörmüştük.Şukoduhatırlıyorsunuz: import tkinter as tk class Pencere(tk.Tk): def __init__(self): super().__init__() self.protocol(’WM_DELETE_WINDOW’, self.çıkış) self.etiket = tk.Label(text=’Merhaba Zalim Dünya’) self.etiket.pack() self.düğme = tk.Button(text=’Çık’, command=self.çıkış) self.düğme.pack() def çıkış(self): self.etiket[’text’] = ’Elveda zalim dünya...’ self.düğme[’text’] = ’Bekleyin...’ self.düğme[’state’] = ’disabled’ self.after(2000, self.destroy) pencere = Pencere() pencere.mainloop() Burada aynı anda hem miras alma hem de dahil etme yönteminden yararlanıyoruz. İlk önce Tk() sınıfını miras aldık. Böylece bu sınıfın nitelik ve metotlarına doğrudan erişim elde ettik. Etiket ve düğme oluşturmamızı sağlayan Label() ve Button() sınıflarını ise Pencere() sınıfımız içine dahil ettik. Böylece bu sınıfların nitelik ve metotlarına sırasıyla self.etiket ve self.düğmeadlarıaltındaerişimkazandık. 880 Bölüm44. NesneTabanlıProgramlama(Devamı) PythonBelgeleri,Yayım4.1.3 Mirasalmavedahiletmeyöntemleriarasındatercihyaparkengenelyaklaşımımızşuolacak: Eğeryazdığımızuygulama,birbaşkasınıfıntüreviise,osınıfımirasalacağız.Amaeğerbirsınıf, yazdığımızuygulamanınbirparçasıiseosınıfıuygulamamızadahiledeceğiz. Yani mesela yukarıdaki örnekte temel olarak yaptığımız şey bir uygulama penceresi tasarlamaktır. Dolayısıyla uygulama penceremiz, tk.Tk() sınıfının doğrudan bir türevidir. O yüzdenbusınıfımirasalmayıtercihediyoruz. Pencere üzerine etiket ve düğme yerleştirmemizi sağlayan Label() ve Button() sınıfları ise, uygulama penceresinin birer parçasıdır. Dolayısıyla bu sınıfları uygulamamızın içine dahil ediyoruz. Yukarıda anlattığımız iki farklı ilişki türü ‘olma ilişkisi’ (is-a relationship) ve ‘sahiplik ilişkisi’ (has-a relationship) olarak adlandırılabilir. Olma ilişkisinde, bir sınıf ötekinin türevidir. Sahip olma ilişkisinde ise bir sınıf öteki sınıfın parçasıdır. Eğer iki sınıf arasında ‘olma ilişkisi’ varsa miras alma yöntemini kullanıyoruz. Ama eğer iki sınıf arasında ‘sahiplik ilişkisi’ varsa dahil etmeyönteminikullanıyoruz. Dipnotları: 44.5. DahilEtme 881 45 BÖLÜM Nesne Tabanlı Programlama (Devamı) Nesne tabanlı programlamaya ilişkin bu son bölümde önceki derslerde incelemeye fırsat bulamadığımızileridüzeykonulardansözedeceğiz. 45.1 İnşa, İlklendirme ve Sonlandırma Python’dabirsınıfınömrüüçaşamadanoluşur: 1. İnşa(Construction) 2. İlklendirme(initialization) 3. Sonlandırma(destruction) Biz bundan önceki derslerimizde ilklendirme sürecinin nasıl yürüdüğünü görmüştük. Bu dersimizde ise, ilklendirme sürecine de tekrar değinmekle birlikte, özellikle inşa ve sonlandırmasüreçlerinielealacağız. Önceki derslerimizden de bildiğimiz gibi, Python’da bir sınıfı ilklendirmek için __init__() adlıbirmetottanyararlanıyoruz.Ancak,adınınaksine,ilklendirme,sınıflarınoluşturulmasına ilişkin ilk basamak değildir. Python, bir sınıfın ilklendirilmesinden önce o sınıfı inşa eder. Bu inşaişlemindensorumlumetodunadıise__new__()’dur.Gelinbumetoduyakındantanımaya çalışalım. 882 PythonBelgeleri,Yayım4.1.3 45.1.1 __new__() Metodu Bildiğinizgibi,Python’dabasitbirsınıfışuşekildetanımlıyoruz: class Sınıf(): def __init__(self): print(’merhaba sınıf!’) Burada __init__() metodu, sınıfımız örneklenir örneklenmez hangi işlemlerin yapılacağını gösteriyor. Yani mesela sınıf = Sınıf() gibi bir kod yardımıyla Sınıf() adlı sınıfı örneklediğimizandaneolacağınıbu__init__()metoduiçindetanımlıyoruz: ‘ ‘ >>> # Yukarıdaki kodların sınıf.py adlı bir dosyada olduğunu varsayalım >>> import sınıf >>> snf = sınıf.Sınıf() merhaba sınıf! Gördüğünüz gibi, tam da __init__() metodunda tanımladığımız şekilde, sınıfımızı örneklediğimizandaekrana‘merhabasınıf’çıktısıverildi. Ancak yukarıda da belirttiğimiz gibi, bir sınıf örneklendiğinde çalışan ilk metot aslında __init__()değildir.Pythonbusüreçtealttanalta__new__()adlıbaşkabirmetoduçalıştırır. Gelinbunukanıtlayalım: class Sınıf(): def __new__(cls): pass def __init__(self): print(’merhaba sınıf’) Busınıfıörneklediğinizde,biröncekikodlarınaksine,ekrana‘merhabasınıf’yazısıçıktıolarak verilmeyecektir.İştebununsebebi,Python’ınöntanımlı__new__()metodununüzerineyazıp, ometodunişlevselliğiniortadankaldırmışolmanızdır.Eğer__new__()metodununöntanımlı davranışınıtaklitetmekistersenizyukarıdakikodlarışuşekildeyazmalısınız: class Sınıf(): def __new__(cls, *args, **kwargs): return object.__new__(cls, *args, **kwargs) def __init__(self): print(’merhaba sınıf’) Buradayaptığımızşeyinaslındatemelolarakbasitbirmirasalmaişlemindenibaretolduğunu görüyorolmalısınız.Bildiğinizgibi,Python’dakibütünsınıflar,eğerbaşkabirsınıfımirasolarak almıyorlarsa,otomatikolarakobjectsınıfınımirasalırlar.Yaniaslındayukarıdakisınıftanımını Pythonşöylegörür: class Sınıf(object): ... Buradaobjecttabansınıfolmuşoluyor.Butabansınıfın__new__()metodununsahipolduğu 45.1. İnşa,İlklendirmeveSonlandırma 883 PythonBelgeleri,Yayım4.1.3 işlevselliği Sınıf adlı alt sınıfa aktarabilmek için taban sınıfı kendi __new__() metodumuz içindeçağırıyoruz: class Sınıf(): def __new__(cls, *args, **kwargs): return object.__new__(cls, *args, **kwargs) İşte eğer bir sınıfın inşa edilme sürecinin nasıl işleyeceğini kontrol etmek isterseniz bu __new__()metodununüzerineyazarakmetodudeğişikliğeuğratabilirsiniz: class Sınıf(): def __new__(cls, *args, **kwargs): print(’Yeni sınıf inşa edilirken lütfen bekleyiniz...’) return object.__new__(cls, *args, **kwargs) def __init__(self): print(’merhaba sınıf’) Ancak bu noktada şunu belirtmeden de geçmeyelim. __new__() metodu, sık sık muhatap olmanız gereken bir metot değil. __new__() metodunu kullanarak yapacağınız pek çok şeyi aslındadoğrudan__init__()metoduaracılığıyladayapabilirsiniz. 884 Bölüm45. NesneTabanlıProgramlama(Devamı) 46 BÖLÜM Paketler . Uyarı Bumakaleyoğunbirşekildegeliştirilmekte,içeriğisıksıkgüncellenmektedir. Birkaç bölüm önce, Python’ın belkemiği olduğunu söylediğimiz modüller konusundan söz etmiştik. Bu bölümde de yine modüllerle bağlantılı bir konuyu ele alacağız. Konumuz Python’dakipaketler. 46.1 Paket Nedir? Öncelikle paketin ne demek olduğunu anlamaya çalışarak başlayalım. Python’da bir dizin yapısı içinde bir araya getirilen, birbiriyle bağlantılı modüllere paket adı verilir. Dolayısıyla paketlermodüllerdenoluşur. Python programlama dilinde paketler hem geniş bir yer tutar, hem de büyük bir önem taşır. Hatta Python’ı bilmenin paketleri bilmek demek olduğunu söylersek çok da abartmış olmayız. Mesela Python’la web programları yazmak için kullanılan en gözde araçlardan biri olan django web çatısı, aslında birtakım üçüncü şahıs modüllerinin bir paket yapısı içinde bir araya getirilmiş halinden başka bir şey değildir. Aynı şekilde Python’la Android ve iOS üzerinde çalışabilecek programlar yazmak isterseniz kivy adlı bir başka Python paketiniöğrenmenizgerekir.Pythonprogramlamadilinikullanarakgrafikarayüzlüyazılımlar geliştirmemizi sağlayan tkinter ise standart kütüphanede bulunan pek çok paketten yalnızca birtanesidir. Etrafta django, kivy ve tkinter gibi pek çok kullanışlı paket bulabilirsiniz. Mesela standart kütüphanedebulunansqlite3,Sqliteveritabanlarıüzerindeçalışmamızaimkantanıyançeşitli modülleri içinde barındıran bir Python paketidir. Yine standart kütüphanede bulunan urllib paketi yardımıyla internet adresleri (URL’ler) üzerinde çeşitli işlemler yapabilirsiniz. Python kurulumdiziniiçindekiLibklasörüaltındapekçokstandartPythonpaketigörebilirsiniz. 885 PythonBelgeleri,Yayım4.1.3 Pekimodüllerlepaketleribirbirindenayıranşeynedir? Öncelikle, paketler modüllere kıyasla çok daha kapsamlı bir yapıdır. Zira bir paket içinde (genellikle) birden fazla modül bulunur. Örneğin standart kütüphanede bulunan ve tek bir os.pydosyasındanoluşanosbirmodülken,içindepekçokfarklımodülübarındırancollections birpakettir.Tekbirdosyadanoluştuğuvebirdizinyapısıiçindeyeralmadığıiçinbirmodülden içe aktarma işlemi gerçekleştirmek son derece kolaydır. Paketlerden içe aktarma yaparken uymamızgerekenkurallarisehaliylebirazdahakarmaşıktır. İkincisi, bütün paketler aynı zamanda birer modüldür, ancak bütün modüller birer paket değildir.Örneğinvenvpaketindenbahsederken‘venvmodülü’demekyanlışolmaz.Ancakos modülündenbahsederken‘ospaketi’demekbirazabeskaçacaktır. Üçüncüsü, paketlerin __path__ adlı özel bir niteliği bulunur. Modüllerde ise bu nitelik bulunmaz.Örneğin: >>> import os >>> os.__path__ AttributeError: ’module’ object has no attribute ’__path__’ osbirmodülolduğuiçin,__path__niteliğinesahipdeğildir.Birdejsonpaketinebakalım: >>> import json >>> json.__path__ json ise bir paket olduğu için, __path__ niteliğine sahiptir. Birazdan bu niteliğin ne işe yaradığınıanlatacağız.Amaondanönceöğrenmenizgerekenbaşkaşeylervar. 46.2 Paket Türleri Tıpkı fonksiyonlarda ve modüllerde olduğu gibi, paketlerin de türleri vardır. Paketleri, kaynaklarınagöreikiyeayırabiliriz: • StandartPaketler • ÜçüncüŞahısPaketleri Bu türlerin ne anlama geldiğini isimlerine bakarak rahatlıkla anlayabiliyoruz. Ama gelin istersenizbunlarıkısacagözdengeçirelim. Önceliklestandartpaketlerdenbaşlayalım. 46.2.1 Standart Paketler Standart paketler, Python’ın standart kütüphanesinde bulunan paketlerdir. Tıpkı gömülü fonksiyonlar ve standart modüller gibi, standart paketler de dilin bir parçası olduklarından, bunlaraerişebilmekiçinherhangibirekyazılımindiripkurmamızagerekkalmaz;bupaketler heranemrimizeamadedir.StandartpaketlerePythonkurulumdiziniiçindekiLibklasöründen erişebilirsiniz.Birstandartpaketintamolarakhangikonumdabulunduğunuöğrenmekiçinise ilgilipaketin__path__niteliğinisorgulayabilirsiniz: 886 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 >>> import urllib >>> urllib.__path__ Eğersorguladığınızşeyinbir__path__niteliğiyoksa,paketsandığınızoşey,aslındabirpaket değildir.Örneğin: >>> import subprocess >>> subprocess.__path__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’module’ object has no attribute ’__path__’ Çünkü, bildiğiniz gibi, paketlerin aksine, modüllerin __path__ adlı bir niteliği bulunmaz. subprocessdebirpaketdeğil,modülolduğuiçin__path__sorgusuhataverecektir. Bir paketin __path__ niteliğini sorguladığınızda çıktıda hangi dizini görüyorsanız, o paketin bilgisayardaki konumu odur. Mesela yukarıda adını andığımız urllib paketinin __path__niteliğinisorgulayıp,karşımızaçıkanklasöregidelim.Paketdizinininiçiniaçtığımızda karşımızaşudosyalarçıkacak: error.py parse.py request.py response.py robotparser.py __init__.py Dahaöncededediğimizgibi,paketlermodüllerdenoluşur.İşteurllibpaketideyukarıdaismini gördüğümüz modüllerin birleşiminden oluşuyor. Python kurulum dizini içindeki Lib klasörü altındayeralanpaketleriinceleyerek,hangipaketinhangimodüllerdenoluştuğunukendiniz degörebilirsiniz. 46.2.2 Üçüncü Şahıs Paketleri Python’da standart paketlerin dışında bir de üçüncü şahıs paketleri vardır. Bunlar Python geliştiricileri haricindeki kişilerce yazılıp kullanımımıza sunulmuş araçlardır. Bu paketler, standart paketlerin aksine dilin bir parçası olmadığından, bu paketleri kullanabilmek için önceliklebunlarıbilgisayarımızakurmamızgerekir.Meseladjango,kivyveilkderslerimizden birindebahsettiğimizcx_freezebirerüçüncüşahıspaketidir. Pekibuüçüncüşahıspaketlerinineredenbulabiliriz? Hatırlarsanız Modüller konusunu işlerken ‘Üçüncü Şahıs Modüllerinden’ de söz etmiştik. Üçüncü şahıs modüllerini bulabileceğimiz başlıca kaynağın https://pypi.org adresi olduğunu ve buradan 60.000’in üzerinde üçüncü şahıs Python modülüne ulaşabileceğimizi de ifade etmiştik. İşte orada bahsettiğimiz üçüncü şahıs modülleri, aslında birer pakettir. Zira üçüncü şahıs modülleri çoğunlukla birer paket biçiminde sunulur. Dolayısıyla üçüncü şahıs modüllerine nereden ve nasıl ulaşıyorsak, üçüncü şahıs paketlerine de aynı yerden ve aynı şekilde ulaşabiliriz. Ayrıca bir üçüncü şahıs paketini kurmadan önce, ilgili paketin yardım dosyalarını veya websitesini incelemekte de fayda var. Çünkü bazı üçüncü şahıs modüllerini 46.2. PaketTürleri 887 PythonBelgeleri,Yayım4.1.3 kurabilmek için birtakım özel gereksinimleri yerine getirmeniz gerekiyor olabilir. Bu tür bilgileredeancakilgilipaketigeliştirenkişiveyaekibinwebsitesindenulaşabilirsiniz. Birüçüncüşahıspaketininhttps://pypi.orgadresindekiadınıöğrendiktensonra,bupaketişu komutlakurabilirsiniz: pip3 install paket_adı Mesela restructuredText biçimli metin dosyalarından şık ve kullanışlı belgeler üretmemizi sağlayansphinxpaketiPyPIsitesindebulunuyor.Dolayısıylabupaketikurmakiçinşukomutu verebiliriz: pip3 install sphinx Elbette,eğerbirGNU/Linuxdağıtımıkullanıyorsanız,bukomuturoothaklarıylaçalıştırmanız gerektiğinisöylememeherhaldegerekyok: sudo pip3 install sphinx pip3 adlı yazılım, sphinx paketinin bütün dosyalarını PyPI sitesinden çekip otomatik olarak bilgisayarımızakuracaktır. Birüçüncüşahıspaketinipip3komutuylakurmakyerineellekurmayıdatercihedebilirsiniz. Örnek olarak bu defa django paketini alalım. Bu paketin en son sürümünü https://pypi. org/project/Django/#files adresinden indirebilirsiniz. Ayrıca arzu ederseniz https://www. djangoproject.comadresineuğrayarakbumodülünresmiwebsitesinedegözatabilirsiniz. İndirdiğiniz tar.gz uzantılı sıkıştırılmış dosyayı açtığınızda karşısınıza pek çok dizin ve bu dizinlerin içinde de pek çok Python dosyası çıkacak. Django, geniş kapsamlı üçüncü şahıs paketlerinegüzelbirörnektir. Djangopaketiniaçıpdjango-masteradlıdizininiçinegirdiğinizde,oradasetup.pyadlıbirdosya göreceksiniz. İşte pip3 komutu yerine, bu dosyayı kullanarak da bu paketi bilgisayarımıza kurabiliriz. Dikkatlicebakın: python3 setup.py install Bukomuttaikiönemliunsurvar.Birincisi,komutuçalıştırdığımızPythonsürümü.Unutmayın, birPythonpaketinihangiPythonsürümüilekurarsanız,opaketiosürümilekullanabilirsiniz. Ben yukarıdaki komutta, sizin Python sürümünüzü başlatan komutun python3 olduğunu varsaydım. Eğer siz Python’ı başlatmak için veya başka Python programlarını çalıştırmak için farklı bir komut kullanıyorsanız, setup.py dosyasını da o komutla çalıştıracaksınız. Neticede setup.py de sıradan bir Python programıdır. Bu programı install parametresi ile birlikte çalıştırarakDjangopaketinisisteminizekurmuşoluyorsunuz.Kurulumtamamlandıktansonra, kurulumunbaşarılıolupolmadığınıtestetmekiçinPythonkomutsatırındaşukomutuverin: >>> import django Eğer herhangi bir çıktı verilmeden alt satıra geçildiyse, bir üçüncü şahıs paketi olan django’yu bilgisayarınıza başarıyla kurmuşsunuz demektir. Bu üçüncü şahıs modülünü nasıl kullanacağınızı öğrenmek için internet üzerindeki sayısız makaleden ve kitaptan yararlanabilirsiniz. 888 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 46.3 Paketlerin İçe Aktarılması Modüllerlepaketlerarasındakiönemlibirfark,paketlerinmodüllerekıyasladahakarmaşıkbir yapıdaolmasıdır.Yalnızcatekbirdosyadanoluşanmodüllerinbubasityapısındanötürü,bir modüldennitelikveyametotiçeaktarmakçokkolaydır.Meselabirmodülolanos’uşuşekilde içeaktarabiliriz: >>> import os Eğerosmodülündennameniteliğinialmakistersekşukomutukullanabiliriz: >>> from os import name os modülü içindeki bütün nitelik ve metotları içe aktarmak istediğimizde yıldızlı içe aktarma yöntemindenyararlanabiliriz: >>> from os import * Veyabumodüliçindekibirniteliğiveyametodubaşkabirisimaltındadaiçeaktarabiliriz: >>> from os import execv as exe Gelelimpaketlere... 46.3.1 import paket Mesela urllib paketini ele alalım. Tıpkı os modülünde yaptığımız gibi, urllib paketini de şu şekildeiçeaktarabiliriz: >>> import urllib Ancakosmodülününaksine,urllibpaketiniiçeaktardığımızdamevcutisimalanınaherhangi birnitelikveyametototomatikolarakaktarılmaz.Örneğinosmodülünüiçeaktardığımızdabu modülüniçeriğinin,osönekialtındamevcutisimalanınadöküldüğünübiliyoruz: >>> dir(os) Gördüğünüzgibi,modüliçeriğikullanılabilirdurumda.Listedekinitelikvemetotlaraosöneki ileerişebiliriz: >>> os.name >>> os.listdir(os.getcwd()) gibi... Ancakimport oskomutununaksine,import urllibkomutu,paketiçeriğiniotomatikolarak mevcutisimalanınaaktarmaz: >>> import urllib >>> dir(urllib) [’__builtins__’, ’__cached__’, ’__doc__’, ’__file__’, (sonrakisayfayadevam) 46.3. PaketlerinİçeAktarılması 889 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’__loader__’, ’__name__’, ’__package__’, ’__path__’, ’__spec__’] Gördüğünüz gibi listede yalnızca standart metot ve nitelikler var. Bu listede mesela paket içeriğindeolduğunubildiğimizerror.py,parse.py,request.py,response.pyverobotparser.py gibi modülleri göremiyoruz. Eğer paket içinde bulunan belirli bir modülü içe aktarmak istiyorsakbunuaçıkaçıkbelirtmeliyiz.Nasılmı?Görelim... 46.3.2 import paket.modül Meselaurllibpaketindenrequestmodülünüiçeaktarmakistersekşukomutuyazacağız: >>> import urllib.request Bu modülü yukarıdaki şekilde içe aktardığımızda, modül içindeki nitelik ve metotlara urllib.requestönekiyleerişebiliriz: >>> urllib.request.urlopen(’https://.com/’) 46.3.3 from paket import modül Yukarıda olduğu gibi, urllib paketi içindeki request modülünü import paket.modül gibi bir komutla içe aktardığımızda ilgili modülün bütün nitelik ve metotları urllib.request ismi altında içe aktarıldığından, urllib paketi içindeki request modülünün nitelik ve metotlarına ulaşabilmekiçinherdefasındaurllib.requestönekinikullanmamızgerekir.Eğerherdefasında uzun uzun urllib.request yazmak istemiyorsanız paket içindeki modülü şu şekilde içe aktarabilirsiniz: >>> from urllib import request Böylecerequestmodülününnitelikvemetotlarınayalnızcarequestönekiyleerişebilirsiniz: >>> request.urlopen(’https://.com/’) 46.3.4 from paket.modül import nitelik_veya_metot Peki bir paket içinde yer alan herhangi bir modül içindeki nitelik ve metotlara öneksiz olarak erişmekistersekneyapacağız?Pythonbizebuisteğimiziyerinegetirmemizisağlayacakbiryol dasunar. Dikkatlicebakın: from urllib.request import urlopen Bu şekilde urllib paketi içindeki request modülünden urlopen adlı metodu doğrudan içe aktarmışolduk.Dolayısıylabumetodudümdüzkullanabiliriz: >>> urlopen(’https://.com/’) 890 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 Ancak, modüller konusunu işlerken öneksiz aktarmaya ilişkin söylediklerimizin paketler için degeçerliolduğunuaklımızdançıkarmıyoruz. 46.3.5 from paket.modül import * Eğer bir paket içindeki bir modülün bütün nitelik ve metotlarını mevcut isim alanına olduğu gibiaktarmakistersenizşuiçeaktarmayönteminikullanabilirsiniz: >>> from paket.modül import * Bubilgiyiurllibmodülüneuygulayalım: >>> from urllib.request import * Bu şekilde urllib paketi içindeki request modülünün bütün nitelik ve metotlarını doğrudan mevcutisimalanınaaktarmışolduk.Buyönteminbüyükbirrahatlıksunmaklabirlikteönemli dezavantajlaradasahipolduğunugayetiyibildiğinizdeneminim. 46.4 Kendi Oluşturduğumuz Paketler Buraya kadar hep başkalarının yazdığı, hazır paketlerden söz ettik. Bu sayede bir Python paketinin yapı olarak neye benzediğini ve nasıl kullanılacağını kabataslak da olsa anlamış olduk. Elbette biz sadece başkalarının yazdığı paketleri kullanmayacağız. Bir de bizim kendi yazdığımızPythonpaketleriolacak. Kendi oluşturduğumuz paketler, adı üzerinde, kendi kendimize yazıp meydana getirdiğimiz paketlerdir. Bu paketleri iyice geliştirdikten ve başkaları için de yararlı olabilecek hale getirdikten sonra, istersek https://pypi.org adresindeki üçüncü şahıs paket deposuna yükleyebiliriz.Böylecekendigeliştirdiğimizpaketlerde,üçüncüşahısPythonpaketleriarasına girmişolur... İştebubölümde,butürpaketlerinasılyazacağımızıelealacağız. 46.4.1 Paket Oluşturmak Bir Python programı yazdığınızı düşünün. Programınızı ilk yazmaya başlarken doğal olarak programınız tek bir dosyadan oluşacaktır. Ancak elbette programınız büyüdükçe, bütün kodları tek bir dosyaya sıkıştırmak yerine, farklı işlevleri farklı dosyalar içinde tanımlamanın dahamantıklıolduğunufarkedeceksiniz.Meselaprogramıngrafikarayüzkısmınıbirdosyada tanımlarken, düğmelere, menülere bağlayacağınız işlevleri bir başka dosyada tanımlamak isteyebilirsiniz. Programınızın gerçekleştirdiği işlemleri küçük, mantıklı birimlere bölüp bunları farklı modüllere taşımanız, programınızı çok daha rahat bir şekilde idare etmenizi sağlayacaktır. Yani, yazdığınız programı birkaç modüle bölüp, bunları bir paket yapısı içinde sunmanız hem kendiniz açısından, hem de kodlarınızı okuyan başkaları açısından işleri epey kolaylaştıracaktır. Python’dabirpaketoluşturmaksonderecekolaydır.Programkodlarınıiçeren.pydosyasınıbir klasöriçinekoyduğunuzanda,oklasörünadınıtaşıyanbirpaketmeydanagetirmişolursunuz. 46.4. KendiOluşturduğumuzPaketler 891 PythonBelgeleri,Yayım4.1.3 Meselabirsipariştakipprogramıyazdığımızıdüşünelim.Anaklasörümüzünadınısiparistakip koyalım. Bu klasör içinde de komut.py, veritabani.py ve siparis.py adlı modüller olsun. Yani şöylebirdosya-dizinyapısıoluşturalım: + siparistakip |__ siparis.py |__ komut.py |__ veritabani.py İşte bu şekilde basit bir dosya-dizin yapısı oluşturduğumuzda, siparistakip adlı bir Python paketimeydanagetirmişoluyoruz32. Gelinisterseniz,siparistakipdizininingerçektenbirpaketolduğunuteyitedelim. Öncelikle paketimizi içe aktaralım. Bunun için siparistakip dizininin bulunduğu klasörde şu komutuverelim: >>> import siparistakip Şimdipaketiçeriğinikontroledelim: >>> dir(siparistakip) [’__doc__’, ’__loader__’, ’__name__’, ’__package__’, ’__path__’, ’__spec__’] Gördüğünüz gibi, listede __path__ adlı bir nitelik var. Bu niteliğin yalnızca paketlerde bulunduğunubiliyorsunuz.DemekkisiparistakipgerçektendebirPythonpaketiymiş.Bunun dışında, listede gördüğünüz __package__ niteliğini kullanarak da bir modülün paket olup olmadığınıkontroledebilirsiniz: >>> siparistakip.__package__ ’siparistakip’ Eğer test ettiğimiz modül bir paketse, __package__ niteliği bize bir paket adı verecektir. Yok eğer test ettiğimiz modül bir paket değil de alelade bir modülse, __package__ niteliği boş bir karakterdizisidöndürecektir.Meselaosmodülününbirpaketolmadığınıbiliyoruz: >>> import os >>> os.__package__ ’’ Gördüğünüzgibi,bumodülün__package__niteliğiboşbirkarakterdizisi.Ayrıcabumodülbir paketolmadığıiçin,__path__adlıbirnitelikdebarındırmıyor: >>> os.__path__ (sonrakisayfayadevam) 32DahaöncePython’ın2.xsürümlerinikullanmışolanlar,buyapınınbirpaketoluşturmakiçinyeterliolmadığını düşünebilir.ÇünküPython’ın2.xsürümlerindebirpaketoluşturabilmekiçin,siparistakipdizinininiçinde__init__.py adlı bir dosya daha oluşturmamız gerekiyordu. Ancak Python3’te bu zorunluluk ortadan kaldırıldı. Eğer bu söylediğimizşeyinneanlamageldiğinibilmiyorsanız,buuyarıyıgörmezdengelipyolunuzadevamedebilirsiniz. 892 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’module’ object has no attribute ’__path__’ Dolayısıyla bütün işaretler, gerçekten de siparistakip adlı bir paket oluşturduğumuzu gösteriyor... 46.4.2 İçe Aktarma İşlemleri Standart paketleri anlatırken, bu paketlerin her konumdan içe aktarılabileceğini söylemiştik. Aynı şey üçüncü şahıs paketleri için de geçerlidir. Çünkü gerek Python geliştiricileri, gerekse üçüncü şahıs paketleri geliştirenler, bu paketleri bize sunarken bunları Python’ın sys.path çıktısına eklemişlerdir. O yüzden standart ve üçüncü şahıs paketlerini içe aktarırken sorun yaşamayız. Ancak tabii ki kendi yazdığımız paketler sys.path listesine ekli olmadığı için, bunları içe aktarırkenbazınoktalaradikkatetmenizgerekir. Meselamasaüstündeşuyapıyasahipbirpaketoluşturalım: + paket |__ modul1.py |__ modul2.py |__ modul3.py + altdizin |__altmodul1.py |__altmodul2.py Budizindedosyaiçeriklerişöyleolsun: modul1.py: isim1 = ’modul1’ print(isim1) modul2.py: isim2 = ’modul2’ print(isim2) modul3.py: isim3 = ’modul3’ print(isim3) altmodul1.py: altisim1 = ’altmodul1’ print(altisim1) altmodul2.py: 46.4. KendiOluşturduğumuzPaketler 893 PythonBelgeleri,Yayım4.1.3 altisim2 = ’altmodul2’ print(altisim2) Şimdi paket adlı dizinin bulunduğu klasörde bir etkileşimli kabuk oturumu açalım. Yalnız bu oturumu paket dizinin içinde değil, bir üst dizinde açacaksınız. Yani o anda bulunduğunuz dizindedirveyalskomutuverdiğinizdepaketadlıdizinigörüyorolmanızlazım... Eğerdirveya lskomutununçıktısındaaltdizinadlıdizinigörüyorsanızyanlışyerdesinizdemektir.Hemenbir üstdizinegidin. Bulunduğumuzkonumdaşukomutuverelim: >>> import paket Eğer hiçbir çıktı almadan bir alt satıra geçtiyseniz her şey yolunda demektir. Eğer bir hata mesajı görüyorsanız, etkileşimli kabuk oturumunu yanlış konumda açmışsınızdır. Oturumu doğrukonumdaaçıptekrargelin... Standart paketlerde ve üçüncü şahıs paketlerinde gördüğümüz gibi, bir paketi yukarıdaki şekilde içe aktardığımızda, o pakete ait herhangi bir modül veya nitelik otomatik olarak içe aktarılmıyor. dir(paket) komutu verdiğinizde yalnızca standart niteliklerin içe aktarıldığını göreceksiniz: >>> dir(paket) [’__doc__’, ’__loader__’, ’__name__’, ’__package__’, ’__path__’, ’__spec__’] Gördüğünüz gibi, oluşturduğumuz paket, bir Python paketinin sahip olması gereken bütün nitelikleresahip. Şimdibupaketiçindekimodul1adlımodülüiçeaktaralım: >>> from paket import modul1 modul1 Böylece modul1 adlı modülün içindeki değişkenin değerini almış olduk. Paket içindeki öteki modüllerideaynışekildeiçeaktarabilirsiniz: >>> from paket import modul2 modul2 >>> from paket import modul3 modul3 Pekiyameselamodul1içindekiisim1değişkeninialmakistersekneyapacağız? Dikkatlicebakın: >>> from paket.modul1 import isim1 modul1 894 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, paket içindeki modul1 modülünün isim1 niteliğini başarıyla aldık. Örnek olmasıaçısındanötekileridealalım: >>> from paket.modul2 import isim2 modul2 >>> from paket.modul3 import isim3 modul3 Buradaki temel mantığı kavradığınızı zannediyorum. Standart modülleri incelerken bahsettiğimiz içe aktarma yöntemlerini tek tek yukarıdaki yapıya uygulayarak, buraya kadar anlattıklarımızı anlayıp anlamadığınızı test edebilirsiniz. Dilerseniz pratik yapmak açısındanbirdealtdiziniçindekimodüllereuzanalım. Önceliklealtdizin’iiçeaktaralım: >>> import paket.altdizin Bu şekilde paket adlı paketin altdizin adlı alt dizinini içe aktarmış olduk. Artık bu alt dizin içindeki modüllere ve onların niteliklerine erişebiliriz. Mesela paket adlı paketin altdizin adlı altdiziniiçindekialtmodul1adlımodülünaltisim1niteliğinialalım: >>> paket.altdizin.altmodul1.altisim1 ’altmodul1’ Gördüğünüz gibi, altisim1 niteliğine erişmek için uzun bir yol gitmemiz gerekiyor. Bu yolu kısaltmakistersenizmodülüşuşekildeiçeaktarabilirsiniz: >>> from paket.altdizin import altmodul1 Artıkaltmodul1’inniteliklerineyalnızcaaltmodul1önekiyleulaşabilirsiniz: >>> altmodul1.altisim1 ’altmodul1’ Hattadoğrudanaltisim1niteliğininkendisinidealabilirsiniz: >>> from paket.altdizin.altmodul1 import altisim1 >>> altisim1 ’altmodul1’ Gördüğünüz gibi, Python’ın içe aktarma mantığı gayet basit. Bulunduğunuz konumdan itibaren, alt dizin ve modül adlarını sırasıyla kullanarak ve bunları birbiriyle nokta işareti ile birleştirerekherbirmodülevemodüliçindekiniteliğeerişebiliyoruz. 46.4. KendiOluşturduğumuzPaketler 895 PythonBelgeleri,Yayım4.1.3 46.4.3 İçe Aktarma Mantığı Yukarıdaki örneklerden gördüğünüz gibi, Python’ın içe aktarma mekanizması gayet basit bir şekilde işliyor. Ancak yine de bu durum sizin rehavete kapılmanıza yol açmasın. Zira kimi zamanbumekanizmahiçbeklemediğinizdurumlarınortayaçıkmasınadayolaçabilir. Python’da paketler üzerinde çalışırken, Python programlama dilinin paketleri içe aktarma mekanizmasını çok iyi anlamış olmalısınız. Eğer bu mekanizmayı hakkıyla anlamadan paket yapmayakalkışırsanız,Python’ıniçeaktarmasırasındaverebileceğisürprizhatalarsizesaçbaş yoldurabilir. İşte bu bölümde Python’ın paket içe aktarma mantığı üzerine eğilerek, engebeli yüzeylerinasılaşabileceğimizianlamayaçalışacağız. İçeAktarmaİşlemininKonumu Python’da herhangi bir içe aktarma işlemi yapacağımız zaman, unutmamamız gereken en önemli konu, Python’ın bütün içe aktarma işlemlerini tek bir konumdan gerçekleştirdiği gerçeğidir.Bununnedemekolduğunuanlamakiçinçokbasitbirörnekverelim. Yukarıdaşöylebirpaketyapısıoluşturmuştuk: + paket |__ modul1.py |__ modul2.py |__ modul3.py + altdizin |__altmodul1.py |__altmodul2.py Buradaaltmodul2.pydosyasınıniçineşunuyazalım: import altmodul1 Yanibudosyaileaynıdizindebulunanaltmodul1.pydosyasını,altmodul2.pydosyasıiçinden birmodülolarakiçeaktaralım. Şimdi, daha önce yaptığımız gibi, paket adlı dizinin bulunduğu klasörde bir etkileşimli kabuk oturumuaçalımveşukomutuyazalım: >>> from paket.altdizin import altmodul2 Bukomutbizeşöylebirhatamesajıverecek: ImportError: No module named ’altmodul1’ Buhatanınsebebi,Python’ınaltmodul1adlımodülübulamıyorolmasıdır.Halbukibumodül, altmodul2ileaynıdizindebulunuyor.OhaldeacabaPythonbumodülünedenbulamıyor? Bunuanlamakiçinşöylebirdenemeyapalım: Şimdi altmodul1.py ve altmodul2.py dosyalarının bulunduğu konumda bir etkileşimli kabuk oturumubaşlatınveşukomutuverin: >>> import altmodul2 896 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, bu defa Python herhangi bir hata mesajı vermeden, impport altmodul1 komutuylaaltmodul2.pydosyasıiçindençağırdığımızaltmodul1modülününiçeriğinialabildi. Pekiamaneden? Başta da söylediğimiz gibi, Python bütün aktarma işlemlerini tek bir konumdan yapar. Yani eğer siz bir modülü üst dizinden içe aktardıysanız, o üst dizinin adı paket içindeki bütün aktarmalara önek olarak eklenecektir. Dolayısıyla paket adlı dizinin bulunduğu konumdan altdizin içindeki altmodul2.py dosyasını çağırdığınızda, altmodul2.py içindeki import altmodul1 komutu, altmodul1.py dosyasını bulamayacaktır. Ama siz altmodul2.py dosyasını kendi dizini içinden çağırdığınızda, import altmodul1 komutu, aynı dizin içindeki altmodul1.pydosyasınıbulabilecektir. Bu okuduklarınız ilk bakışta size çok karmaşıkmış gibi gelebilir, ama aslında biraz dikkat ederseniz busistemin hiç de öylekarmaşık olmadığını, aksineson derece mantıklı olduğunu göreceksiniz. Durumudahadanetleştirmekiçinşöylebirşeyyapalım: altmodul2.pydosyasınıaçıp,import altmodul1komutunuşöyleyazalım: from paket.altdizin import altmodul1 Bu değişikliği kaydettikten sonra tekrar paket dizininin bulunduğu konumda bir oturum açıp şukomutuverelim: >>> from paket.altdizin import altmodul2 İştebukezkomutumuzbaşarıylaçalıştıvealtmodul1modülünübulabildi... Şimdidealtmodul1.pyvealtmodul2.pydosyalarınınbulunduğukonumatekrardönüpburada yine bir etkileşimli kabuk oturumu başlatalım ve daha önce verdiğimiz şu komutu tekrar verelim: >>> import altmodul2 Odane!Geçenseferhatasızçalışankodbudefahataverdi: ImportError: No module named ’paket’ Gördüğünüzgibi,modülüiçeaktardığımızkonumdanötürüPythonbukezdepaketadlıpaketi bulamıyor. Birazdanbütünbusorunlarınkesinçözümünüvereceğiz.Amaondanöncebaşkabirkonudan sözedelim. BağılİçeAktarma Dediğimizgibi,biriçeaktarmaişlemininbaşarılıolabilmesi,oiçeaktarmaişlemininyapıldığı konumun neresi olduğuna ve paket içinde bulunan öteki modüllerdeki içe aktarmaların nasıl yazıldığına bağlıdır. Yani mesela normalde aynı konumda bulunan iki modül birbirini yalnızcaimport modül_adıgibibirkomutlaiçeaktarabilecekken,eğerbumodüllerüstdizinin bulunduğukonumdançağrılıyorsa,içeaktarmabaşarısızolabilir.Bununbirörneğiniyukarıda görmüştük. altdizin içinde bulunan altmodul1.py dosyasını, aynı dizindeki altmodul2.py dosyasından içe aktarmak için altmodul2.py dosyasına import altmodul1 yazdığımızda, ana paket dizininin bulunduğu konumdan altdizin içindeki altmodul2.py dosyasını from 46.4. KendiOluşturduğumuzPaketler 897 PythonBelgeleri,Yayım4.1.3 paket.altdizin import altmodul2 gibi bir komut ile içe aktarma girişimimiz başarısızlığa uğruyordu. Python’ın ilgili modülü bulabilmesini sağlamak için, altmodul2.py dosyasına import altmodul1 yazmak yerine from paket.altdizin import altmodul1 yazmıştık. İşte aynı şeyi ‘bağıl içe aktarma’ (relative import) denen bir mekanizma yardımıyla da gerçekleştirebiliriz. Bu mekanizmada içe aktarma işlemi, içe aktaran modülün bulunduğu konuma göre gerçekleşir.Birörnekverelim... altmodul2.py dosyasına import altmodul1 veya from paket.altdizin import altmodul1 yerineşunuyazalım: from . import altmodul1 Burada from kelimesinden sonra gelen nokta (.), içe aktaran modülle aynı dizine atıfta bulunuyor. Yani bu şekilde altmodul2.py’nin bulunduğu dizine atıfta bulunmuş, böylece bu dizindebulunanaltmodul1adlımodülüiçeaktarabilmişolduk.paketdizininden,hattaaltdizin dizinindenyapılacakiçeaktarmaişlemleribukomutsayesindebaşarılıolacaktır. Dediğimiz gibi, orada . işareti, içe aktaran modülle aynı dizini temsil ediyor. Eğer oraya yan yanaikinokta(..)koyacakolursanız,birüstdizineatıftabulunabilirsiniz.Meselabirüstdizinde bulunan modul3.py dosyasını altmodul2.py veya altmodul1.py dosyasından içe aktarmak isterseniz,budosyalarınherhangibirineşukoduyazabilirsiniz: from .. import modul3 Üçnoktayanyanakoyduğunuzdaise(...)ikiüstdizineatıftabulunmuşolursunuz.Ancakbu şekildepaketindışınaçıkamayacağınızıdaunutmayın.Yanimeselapaketdizinininbulunduğu konuma göre bir üst dizinde bulunan, yani paket dışındaki falanca.py adlı bir modülü şu şekildeiçeaktaramazsınız: from ... import falanca Amatabiieğerpaketinizindizinyapısıikiüstdizineçıkılmasınamüsaadeediyorsayukarıdaki komutçalışacaktır.Yanielinizdeki,aşağıdakinebenzeryapıdabirpakette: + paket |__ modul1.py |__ modul2.py |__ modul3.py + altdizin |__altmodul1.py |__altmodul2.py + altaltdizin |__altaltmodul1.py |__altaltmodul2.py altaltmodul1.py dosyasının bulunduğu konumdan itibaren iki üst dizine çıkarak modul2.py dosyasınıiçeaktarabilirsiniz: from ... import modul2 Yukarıda gösterdiğimiz bağıl içe aktarma mekanizması, paket adı belirtmeden içe aktarma işlemigerçekleştirmenizisağlar.Yanibumekanizmasayesindefrom paketadi.modul import 898 Bölüm46. Paketler PythonBelgeleri,Yayım4.1.3 altmodul yerine from . import modul gibi bir kod yazarak, aynı dizin içinde veya üst dizinlerdebulunanmodüllereatıftabulunabilirsiniz. 46.4.4 Paketlerin Yola Eklenmesi Daha önce de birkaç kez vurguladığımız gibi, içe aktarma işlemlerinde Python aradığımız modülü veya paketi bulabilmek için sys.path adlı listede görünen dizinlerin içine bakar. Eğer içe aktarmak istediğiniz paket dizini bu listede değilse, o paketi içe aktarabilmek için, komut satırınıodizininbulunduğuklasördeaçmanızgerekir.Yanistandartpaketlerveüçüncüşahıs paketlerinaksine,sys.path’eeklenmemişbirpaketiheryerdeniçeaktaramazsınız. Pekibirpaketisys.pathlistesinenasılekleyeceğiz? Aslındabusorununcevabıçokbasit.Bildiğinizgibi,sys.pathaslındabasitbirlistedenibarettir. Dolayısıyla listeler üzerinde nasıl değişiklik yapıyorsanız, sys.path üzerinde de o şekilde değişiklikyapacaksınız. Gelinisterseniz,yukarıdaoluşturduğumuzpaketadlıpaketüzerindenbiruygulamayapalım. Python’da bir paketi sys.path listesine eklerken dikkat etmemiz gereken çok önemli bir konu var:Birpaketisys.pathlistesineeklerken,paketadınakarşılıkgelendizinideğil,paketiiçeren dizini bu listeye eklemeliyiz. Yani mesela paket adlı dizin masaüstündeyse, bizim listeye masaüstününolduğudizinieklememizgerekiyor,paketinolduğudizinideğil... Dikkatlicebakın: >>> import os, sys ’ ’ ’ >>> kullanıcı = os.environ[’HOME’] #Windows ta os.environ[ HOMEPATH ] >>> masaüstü = os.path.join(kullanıcı, ’Desktop’) >>> sys.path.append(masaüstü) Böylece masaüstünün bulunduğu dizini sys.path’e eklemiş olduk. Burada uyguladığımız adımlaraşöylebirbakalım. Önceliklegereklimodülleriiçeaktardık: >>> import os, sys Amacımız masaüstünün yolunu sys.path’e eklemek. Dolayısıyla öncelikle kullanıcı dizininin nerede olduğunu tespit etmemiz lazım. Bildiğiniz gibi, kullanıcı dizinleri, bilgisayarı kuran kişininisminegörebelirlendiğiiçin,bütünbilgisayarlardabudeğerfarklıolur.Budeğerinne olduğu tespit edebilmek için os modülünün environ niteliğinden yararlanabiliriz. Bu nitelik, işletimsistemineözgüçevredeğişkenlerinitutar. GNU/Linux’takullanıcıdizininitutançevredeğişkeni‘HOME’anahtarıilegösterilir: >>> kullanıcı = os.environ[’HOME’] Windows’taise‘HOMEPATH’anahtarınıkullanıyoruz: >>> kullanıcı = os.environ[’HOMEPATH’] Kullanıcı dizinini elde ettikten sonra, masaüstüne giden yolu bulabilmek için şu komutu kullanıyoruz: 46.4. KendiOluşturduğumuzPaketler 899 PythonBelgeleri,Yayım4.1.3 >>> masaüstü = os.path.join(kullanıcı, ’Desktop’) Sırageldieldeettiğimiztamdizinyolunusys.path’eeklemeye: >>> sys.path.append(masaüstü) Gördüğünüz gibi, listelerin append() metodu yardımıyla masaüstünün yolunu sys.path adlı listeyeekledik. Artıkmasaüstündebulunanpaketlerirahatlıklaheryerdeniçeaktarabiliriz. (cid:242) Not os modülü hakkında daha geniş bilgi için os Modülü başlıklı konuyu inceleyebilirsiniz. sys modülühakkındabilgiiçinisesysModülübaşlığınıziyaretedebilirsiniz. 46.4.5 Paketlerde İsim Çakışmaları __init__.pyDosyası Dipnotları: 900 Bölüm46. Paketler 47 BÖLÜM Önemli Standart Kütüphane Modülleri Dahaöncedesöylediğimizgibi,modüllerPythonprogramlamadilininbelkemiğinioluşturur. Hatta Python’ı öğrenmek, bir bakıma modülleri öğrenmek demektir, diyebiliriz. Biz her ne kadar bu noktaya gelene kadar Python’daki bütün temel veri tiplerini ve fonksiyonları öğrenmiş olsak da modülleri öğrenmeden ve bunları etkili bir şekilde nasıl kullanacağımızı bilmedenişeyararprogramlaryazamayız. Mesela diyelim ki veritabanına kayıt yapan bir program yazacaksınız. İşte bu iş için çeşitli modüllerdenyararlanmanızgerekir. Eğer MS Excel veya MS Word gibi dosya biçimleri üzerinde çalışmalar yapacaksanız, bu dosyalarüzerindeişlemyapabilmenizisağlayanbirtakımmodüllerikullanmanızgerekir. Aynışekildegrafikbirarayüzesahipprogramlargeliştirebilmekiçindebazıstandartmodülleri veyaüçüncüşahısmodüllerinikullanmalısınız. Bu durum oyun programlama, taşınabilir cihaz programlama, ağ programlama, web programlamavebaşkaprogramlamaalanlarıiçindegeçerlidir. Geçen bölümde, modüller konusundan söz ederken Python’daki standart kütüphane modüllerine ve üçüncü şahıs modüllerine şöyle bir göz gezdirmiştik. Önümüzdeki bir kaç bölümboyuncaisebazıönemlistandartmodülleriveüçüncüşahısmodülleriniayrıntılıolarak inceleyeceğiz.Busayedeprogramcılıkufkumuzepeybirgenişlemişolacak. 47.1 Düzenli İfadeler Düzenli ifadeler Python programlama dilinin en çetrefilli konularından biridir. Öyle ki, düzenli ifadelerin Python içinde ayrı bir dil olarak düşünülmesi gerektiğini söyleyenler dahi vardır.Amabütünzorluklarınarağmenprogramlamadeneyimimizinbirnoktasındamutlaka karşımızaçıkacakolanbuyapıyıöğrenmemizdebüyükfaydavar.Düzenliifadeleriöğrendikten sonra, elle yapılması saatler sürecek bir işlemi saliseler içinde yapabildiğinizi gördüğünüzde eminimdüzenliifadelerinnebüyükbirnimetolduğunusizdeanlayacaksınız.Tabiihergüzel şey gibi, düzenli ifadelerin nimetlerinden yararlanabilecek düzeye gelmek de bir miktar kan, tervegözyaşıistiyor. 901 PythonBelgeleri,Yayım4.1.3 Peki,düzenliifadelerikullanarakneleryapabiliriz?Çokgenelbirifadeyle,buyapıyıkullanarak metinleri veya karakter dizilerini parmağımızda oynatabiliriz. Örneğin bir web sitesinde dağınıkhaldeduranverileribirçırpıdaayıklayabiliriz.Buveriler,mesela,topluhaldegörmek istediğimiz web adreslerinin bir listesi olabilir. Bunun dışında, örneğin, çok sayıda belge üzerindetekadımdaistediğimizdeğişiklikleriyapabiliriz. Ancakgenelbirkuralolarak,düzenliifadelerdenkaçabildiğimizmüddetçekaçmamızgerekir. Eğer Python’daki karakter dizisi metotları, o anda yapmak istediğimiz şey için yeterli geliyorsamutlakaometotlarıkullanmalıyız.Çünkükarakterdizisimetotları,düzenliifadelere kıyasla hem daha basit, hem de çok daha hızlıdır. Ama bir noktadan sonra karakter dizilerini kullanarak yazdığınız kodlar iyice karmaşıklaşmaya başlamışsa, kodların her tarafı if deyimleriyle dolmuşsa, hatta basit bir işlemi gerçekleştirmek için yazdığınız kod sayfa sınırlarını zorlamaya başlamışsa, işte o noktada artık düzenli ifadelerin dünyasına adım atmanız gerekiyor olabilir. Ama bu durumda Jamie Zawinski’nin şu sözünü de aklınızdan çıkarmayın: “Bazıları, bir sorunla karşı karşıya kaldıklarında şunu der: ‘Evet, burada düzenli ifadelerikullanmamgerekiyor.’İşteonlarınbirsorunudahavardırartık...” Başta da söylediğim gibi, düzenli ifadeler bize zorlukları unutturacak kadar büyük kolaylıklar sunar.Eminolunyüzlercedosyaüzerindetektekelledeğişiklikyapmaktandahazordeğildir düzenli ifadeleri öğrenip kullanmak... Hem zaten biz de bu sayfalarda bu “sevimsiz” konuyu olabildiğince sevimli hale getirmek için elimizden gelen çabayı göstereceğiz. Sizin de çaba göstermeniz, bol bol alıştırma yapmanız durumunda düzenli ifadeleri kavramak o kadar da zorlayıcıolmayacaktır.Unutmayın,düzenliifadelernekadaruğraştırıcıolsadaprogramcının en önemli silahlarından biridir. Hatta düzenli ifadeleri öğrendikten sonra onsuz geçen yıllarınızaacıyacaksınız. Şimdilafıdahafazlauzatmadanişimizekoyulalım. 47.1.1 Düzenli İfadelerin Metotları Python’dakidüzenliifadelereilişkinherşeybirmodüliçindetutulur.Bumodülünadıre.Tıpkı os modülünde, sys modülünde, tkinter modülünde ve öteki bütün modüllerde olduğu gibi, düzenliifadelerikullanabilmemiziçindeöncelikleburemodülünüiçeaktarmamızgerekecek. Buişleminasılyapacağımızıçokiyibiliyorsunuz: >>> import re Başta da söylediğimiz gibi, düzenli ifadeler bir programcının en önemli silahlarından biridir. Şu halde silahımızın özelliklerine bakalım. Yani bu yapının bize sunduğu araçları şöyle bir listeleyelim.Etkileşimlikabuktaşukoduyazıyoruz: >>> dir(re) Tabii yukarıdaki dir(re) komutunu yazmadan önce import re şeklinde modülümüzü içe aktarmışolmamızgerekiyor. Gördüğünüz gibi, re modülü içinde epey metot/fonksiyon var. Biz bu sayfada ve ilerleyen sayfalarda, yukarıdaki metotların/fonksiyonların en sık kullanılanlarını size olabildiğince yalın bir şekilde anlatmaya çalışacağız. Eğer isterseniz, şu komutu kullanarak yukarıdaki metotlar/fonksiyonlarhakkındayardımdaalabilirsiniz: >>> help(metot_veya_fonksiyon_adı) 902 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Birörnekvermekgerekirse: >>> help(re.match) Help on function match in module re: match(pattern, string, flags=0) Try to apply the pattern at the start of the string, returning a match object, or None if no match was found. Ne yazık ki, Python’ın yardım dosyaları hep İngilizce. Dolayısıyla eğer İngilizce bilmiyorsanız, bu yardım dosyaları pek işinize yaramayacaktır. Bu arada yukarıdaki yardım bölümünden çıkmakiçinklavyedekiqdüğmesinebasmanızgerekir. match()Metodu Biröncekibölümdemetotlarhakkındayardımalmaktanbahsederkenilkörneğimizimatch() metoduylavermiştik,ohaldematch()metoduiledevamedelim. match() metodunu tarif etmek yerine, isterseniz bir örnek yardımıyla bu metodun ne işe yaradığınıanlamayaçalışalım.Diyelimkielimizdeşöylebirkarakterdizisivar: >>> a = "python güçlü bir programlama dilidir." Varsayalım ki biz bu karakter dizisi içinde ‘python’ kelimesi geçip geçmediğini öğrenmek istiyoruz.Vebunudadüzenliifadelerikullanarakyapmakistiyoruz.Düzenliifadeleribuörneğe uygulayabilmekiçinyapmamızgerekenşey,önceliklebirdüzenliifadekalıbıoluşturup,daha sonra bu kalıbı yukarıdaki karakter dizisi ile karşılaştırmak. Biz bütün bu işlemleri match() metodunukullanarakyapabiliriz: >>> re.match("python", a) Burada, ‘python’ şeklinde bir düzenli ifade kalıbı oluşturduk. Düzenli ifade kalıpları match() metodunun ilk argümanıdır (yani parantez içindeki ilk değer). İkinci argümanımız ise (yani paranteziçindekiikincideğer),hazırladığımızkalıbıkendisiyleeşleştireceğimizkarakterdizisi olacaktır. KlavyedeENTERtuşunabastıktansonrakarşımızaşöylebirçıktıgelecek: <_sre.SRE_Match object; span=(0, 6), match=’python’> Bu çıktı, düzenli ifade kalıbının karakter dizisi ile eşleştiği anlamına geliyor. Yani aradığımız şey,karakterdizisiiçindebulunmuş. Yukarıdaki çıktıda gördüğümüz ifadeye Python’cada eşleşme nesnesi (match object) adı veriliyor. Çünkü match() metodu yardımıyla yaptığımız şey aslında bir eşleştirme işlemidir (match kelimesi İngilizcede ‘eşleşmek’ anlamına gelir). Biz burada ‘python’ düzenli ifadesinin a değişkeniyle eşleşip eşleşmediğine bakıyoruz. Yani re.match("python", a) ifadesi aracılığıyla ‘python’ ifadesi ile a değişkeninin tuttuğu karakter dizisinin eşleşip eşleşmediğinisorguluyoruz.Bizimörneğimizde‘python’adeğişkeninintuttuğukarakterdizisi ileeşleştiğiiçinbizebireşleşmenesnesidöndürülüyor. Bu çıktı, düzenli ifade kalıbının karakter dizisi ile eşleştiğini bildirmenin yanı sıra, bize başka birtakım bilgiler daha veriyor. Mesela bu çıktıdaki span parametresi, aradığımız ‘python’ karakterdizisinin,adeğişkeninin0.ila6.karakterleriarasındayeraldığınısöylüyorbize.Yani: 47.1. Düzenliİfadeler 903 PythonBelgeleri,Yayım4.1.3 >>> a[0:6] ’python’ Ayrıca yukarıdaki çıktıda gördüğümüz match parametresi de bize eşleşen ifadenin ‘python’ olduğubilgisiniveriyor. Birdeşuörneğebakalım: >>> re.match("Java", a) Burada ENTER tuşuna bastığımızda hiç bir çıktı almıyoruz. Aslında biz görmesek de Python burada “None” çıktısı veriyor. Eğer yukarıdaki komutu şöyle yazarsak “None” çıktısını biz de görebiliriz: >>> print(re.match("Java", a)) None Gördüğünüz gibi, ENTER tuşuna bastıktan sonra “None” çıktısı geldi. Demek ki “Java” ifadesi, “a”değişkeninintuttuğukarakterdizisiileeşleşmiyormuş.Buradançıkardığımızsonucagöre, Python match() metodu yardımıyla aradığımız şeyi eşleştirdiği zaman bir eşleşme nesnesi (matchobject)döndürüyor.Eğereşleşmeyoksa,ozamanda“None”değerinidöndürüyor. Birazkafakarıştırmakiçinşöylebirörnekverelim: >>> a = "Python güçlü bir dildir" >>> re.match("güçlü", a) Burada“a”değişkeninde“güçlü”ifadesigeçtiğihaldematch()metodubizebireşleşmenesnesi döndürmedi.Pekiamaneden? Aslında bu gayet normal. Çünkü match() metodu bir karakter dizisinin sadece en başına bakar.Yani“Pythongüçlübirdildir”ifadesinitutanadeğişkeninere.match(“güçlü”,a)gibibir fonksiyon uyguladığımızda, match()metodu a değişkeninin yalnızca en başına bakacağı ve a değişkeninin en başında “güçlü” yerine “python” olduğu için, match() metodu bize olumsuz yanıtveriyor. Aslındamatch()metodununyaptığıbuişi,karakterdizilerininsplit()metoduyardımıylada yapabiliriz: >>> a.split()[0] == "python" True Demekkiadeğişkenininenbaşında“python”ifadesivarmış.Birdeşunabakalım: >>> a.split()[0] == "güçlü" False Veyaaynıişisadecestartswith()metodunukullanarakdahiyapabiliriz: 904 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> a.startswith("python") Eğer düzenli ifadelerden tek beklentiniz bir karakter dizisinin en başındaki veriyle eşleştirme işlemiyapmaksa,split()veyastartswith()metotlarınıkullanmakdahamantıklıdır.Çünkü split()vestartswith()metotlarımatch()metodundançokdahahızlıçalışacaktır. match()metodunukullanarakbirkaçörnekdahayapalım: >>> sorgu = "1234567890" >>> re.match("1", sorgu) <_sre.SRE_Match object; span=(0, 1), match=’1’> >>> re.match("1234", sorgu) <_sre.SRE_Match object; span=(0, 4), match=’1234’> >>> re.match("124", sorgu) İstersenizşimdiyekadaröğrendiğimizşeylerişöylebirgözdengeçirelim: 1. DüzenliifadelerPython’ınçokgüçlüaraçlarındanbiridir. 2. Python’dakidüzenliifadelereilişkinbütünfonksiyonlarreadlıbirmodüliçindeyeralır. 3. Dolayısıyla düzenli ifadeleri kullanabilmek için öncelikle bu re modülünü import re diyerekiçeaktarmamızgerekir. 4. remodülününiçeriğinidir(re)komutuyardımıylalisteleyebiliriz. 5. match()metoduremodülüiçindekifonksiyonlardanbiridir. 6. match()metodubirkarakterdizisininyalnızcaenbaşınabakar. 7. Eğer aradığımız şey karakter dizisinin en başında yer alıyorsa, match() metodu bir eşleştirmenesnesidöndürür. 8. Eğeraradığımızşeykarakterdizisininenbaşındayeralmıyorsa,match()metodu“None” değeridöndürür. Daha önce söylediğimiz gibi, match() metodu ile bir eşleştirme işlemi yaptığımızda, eğer eşleşme varsa Python bize bir eşleşme nesnesi döndürecektir. Döndürülen bu eşleşme nesnesi bize span ve match parametreleri aracılığıyla, eşleşen karakter dizisinin sorgu dizisi içindeki yerini ve eşleşen dizinin ne olduğu söylüyor. span parametresinin değerine span() adlıbirmetotyardımıylaerişebiliyoruz.Örneğin: >>> import re >>> sorgu = ’Bin kunduz’ >>> eşleşme = re.match(’Bin’, sorgu) >>> eşleşme <_sre.SRE_Match object; span=(0, 3), match=’Bin’> >>> eşleşme.span() (0, 3) 47.1. Düzenliİfadeler 905 PythonBelgeleri,Yayım4.1.3 Ancak, match() metodu ile bulunan şeyin ne olduğunu eşleşme nesnesinin match parametresine bakarak görebilsek de, bu değeri bir kod yardımıyla alamıyoruz. Çünkü eşleşmenesnelerininspan()metodunabenzeyenbirmatch()metodubulunmaz. Ama istersek tabii ki bulunan şeyi de programatik olarak alma imkânımız var. Bunun için group()adlıbirbaşkametottanyararlanacağız: >>> kardiz = "perl, python ve ruby yüksek seviyeli dillerdir." >>> eşleşme = re.match("perl", kardiz) >>> eşleşme.group() ’perl’ Burada, re.match("perl", kardiz) komutunu bir değişkene atadık. Hatırlarsanız, bu fonksiyonu komut satırına yazdığımızda bir eşleşme nesnesi elde ediyorduk. İşte burada değişkeneatadığımızşeyaslındabueşleşmenesnesininkendisioluyor.Budurumuşuşekilde teyitedebilirsiniz: >>> type(eşleşme) <class ’_sre.SRE_Match’> Gördüğünüzgibi,eşleşmedeğişkeninintipibireşleşmenesnesi(matchobject).İstersenizbu nesneninmetotlarınabirgözgezdirebiliriz: >>> dir(eşleşme) Dikkat ederseniz yukarıda kullandığımız group() metodu listede görünüyor. Bu metot, doğrudan doğruya düzenli ifadelerin değil, eşleşme nesnelerinin bir metodudur. Listedeki öbür metotları da sırası geldiğinde inceleyeceğiz. Şimdi isterseniz bir örnek daha yapıp bu konuyukapatalım: >>> iddia = "Adana memleketlerin en güzelidir!" >>> nesne = re.match("Adana", iddia) >>> nesne.group() ’Adana’ Peki, eşleştirmek istediğimiz düzenli ifade kalıbı bulunamazsa ne olur? Öyle bir durumda yukarıdakikodlarhataverecektir.Hemenbakalım: >>> nesne = re.match("İstanbul", iddia) >>> nesne.group() Hatamesajımız: Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’NoneType’ object has no attribute ’group’ Böylebirhata,yazdığınızbirprogramınçökmesinenedenolabilir.Oyüzdenkodlarımızışuna benzerbirşekildeyazmamızdahamantıklıolacaktır: 906 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> nesne = re.match("İstanbul", iddia) >>> if nesne: ... print("eşleşen ifade:", nesne.group()) ... else: ... print("eşleşme başarısız!") Şimdiistersenizbumatch()metodunabiraraveripbaşkabirmetoduinceleyelim. search()Metodu Bir önceki bölümde incelediğimiz match() metodu, karakter dizilerinin sadece en başına bakıyordu. Ama istediğimiz şey tabii ki her zaman bununla sınırlı olmayacaktır. match() metodunun, karakter dizilerinin sadece başına bakmasını engellemenin yolları olmakla birlikte,bizimişimizigörecekçokdahakullanışlıbirmetoduvardırdüzenliifadelerin.Önceki bölümde dir(re) şeklinde gösterdiğimiz listeye tekrar bakarsanız, orada re modülünün search() adlı bir metodu olduğunu göreceksiniz. İşte bu yazımızda inceleyeceğimiz metot busearch()metoduolacaktır. search()metoduilematch()metoduarasındaçokönemlibirfarkvardır.match()metodubir karakter dizisinin en başına bakıp bir eşleştirme işlemi yaparken, search() metodu karakter dizisiningenelindebiraramaişlemiyapar.Yanibirieşleştirir,öbürüarar. Hatırlarsanız,match()metodunuanlatırkenşöylebirörnekvermiştik: >>> a = "Python güçlü bir dildir" >>> re.match("güçlü", a) Yukarıdaki kod, karakter dizisinin başında bir eşleşme bulamadığı için bize None değeri döndürüyordu.Amaeğeraynıişlemişöyleyaparsak,dahafarklıbirsonuçeldeederiz: >>> a = "Python güçlü bir dildir" >>> re.search("güçlü", a) <_sre.SRE_Match object; span=(7, 12), match=’güçlü’> Gördüğünüz gibi, search() metodu “güçlü” kelimesini buldu. Çünkü search() metodu, match() metodunun aksine, bir karakter dizisinin sadece baş tarafına bakmakla yetinmiyor, karakterdizisiningeneliüzerindebiraramaişlemigerçekleştiriyor. Tıpkı match() metodunda olduğu gibi, search() metodunda da span() ve group() metotlarından faydalanarak bulunan şeyin hangi aralıkta olduğunu ve bu şeyin ne olduğunu görüntüleyebiliriz: >>> kardiz = "Python güçlü bir dildir" >>> nesne = re.search("güçlü", kardiz) >>> nesne.span() (7, 12) >>> nesne.group() ’güçlü’ 47.1. Düzenliİfadeler 907 PythonBelgeleri,Yayım4.1.3 Şimdiye kadar hep karakter dizileri üzerinde çalıştık. İsterseniz biraz da listeler üzerinde örneklerverelim. Şöylebirlistemizolsun: >>> liste = ["elma", "armut", "kebap"] >>> re.search("kebap", liste) Ne oldu? Hata aldınız, değil mi? Bu normal. Çünkü düzenli ifadeler karakter dizileri üzerinde işler. Bunlar doğrudan listeler üzerinde işlem yapamaz. O yüzden bizim Python’a biraz yardımcıolmamızgerekiyor: >>> for i in liste: ... nesne = re.search("kebap", i) ... if nesne: ... print(nesne.group()) ... kebap Hattaşimdiyekadaröğrendiklerimizledahakarmaşıkbirşeylerdeyapabiliriz: >>> import re >>> from urllib.request import urlopen >>> f = urlopen("https://python-..com/") >>> for i in f: ... nesne = re.search(b’programlama’, i) ... if nesne: ... print(nesne.group()) ... b’programlama’ b’programlama’ Gördüğünüz gibi, python-..com sayfasında kaç adet “programlama” kelimesi geçiyorsahepsiekranadökülüyor. Bu arada, web sitesinde arama işlemi gerçekleştirirken urllib paketinin içindeki request modülünün urlopen() adlı fonksiyonunu kullandığımıza dikkat edin. Ayrıca search() metoduna parametre olarak bir karakter dizisi değil, bayt dizisi verdiğimizi de gözden kaçırmayın: re.search(b’programlama’, i) Sizistersenizbukodlarıbirazdahageliştirebilirsiniz: import re from urllib.request import urlopen kelime = input("python-..com’da aramak istediğiniz kelime: ") f = urlopen("https://python-..com/") data = str(f.read()) nesne = re.search(kelime, data) (sonrakisayfayadevam) 908 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if nesne: print("kelime bulundu:", nesne.group()) else: print("kelime bulunamadı!:", kelime) Burada, kullanıcıdan aldığımız kelimeyi search() metoduna göndermeden önce, siteden okuduğumuz verileri str() metodu yardımıyla karakter dizisine dönüştürdüğümüze dikkat edin.Böylecekullanıcıdangelenkarakterdizisinibaytdizisineçevirmemizegerekkalmadı. İlerdebilgimizartıncadahayetkinkodlaryazabilecekdurumageleceğiz.Amaşimdilikelimizde olanlar ancak yukarıdaki kodu yazmamıza müsaade ediyor. Unutmayın, düzenli ifadeler sahasındaısınmaturlarıatıyoruzdaha... findall()Metodu Pythonkomutsatırında,yanietkileşimlikabukta,dir(re)yazdığımızzamanaldığımızlisteye tekrarbakarsakoradabirdefindall()adlıbirmetodunolduğunugörürüz.İştebubölümde findall()adlıbuönemlimetoduincelemeyeçalışacağız. Önceşöylebirmetinalalımelimize: metin = """Guido Van Rossum Python’ı geliştirmeye 1990 yılında başlamış... Yani aslında Python için nispeten yeni bir dil denebilir. Ancak Python’un çok uzun bir geçmişi olmasa da, bu dil öteki dillere kıyasla kolay olması, hızlı olması, ayrı bir derleyici programa ihtiyaç duymaması ve bunun gibi pek çok nedenden ötürü çoğu kimsenin gözdesi haline gelmiştir. Ayrıca Google’ın da Python’a özel bir önem ve değer verdiğini, çok iyi derecede Python bilenlere iş olanağı sunduğunu da hemen söyleyelim. Mesela bundan kısa bir süre önce Python’ın yaratıcısı Guido Van Rossum Google’de işe başladı...""" Bumetiniçindegeçenbütün“Python”kelimelerinibulmakistiyoruz: print(re.findall("Python", metin)) [’Python’, ’Python’, ’Python’, ’Python’, ’Python’, ’Python’] Gördüğünüzgibi,metindegeçenbütün“Python”kelimelerinibirçırpıdalisteolarakaldık.Aynı işlemisearch()metodunukullanarakyapmakistersekyolubirazuzatmamızgerekir: >>> liste = metin.split() >>> for i in liste: ... nesne = re.search("Python", i) ... if nesne: ... print(nesne.group()) ... Python Python Python Python (sonrakisayfayadevam) 47.1. Düzenliİfadeler 909 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Python Python Gördüğünüzgibi,metindegeçenbütün“Python”kelimelerinisearch()metodunukullanarak bulmak için öncelikle “metin” adlı karakter dizisini, daha önce karakter dizilerini işlerken gördüğümüz split() metodu yardımıyla bir liste haline getiriyoruz. Ardından bu liste üzerindebirfordöngüsükuraraksearch()vegroup()metotlarınıkullanarakbütün“Python” kelimeleriniayıklıyoruz.Eğerkarakterdizisiniyukarıdakişekildelisteyedönüştürmezsekşöyle birneticealırız: >>> nesne = re.search("Python", metin) >>> print(nesne.group()) Python Buşekildemetindegeçensadeceilk“Python”kelimesinialabiliyoruz. 47.1.2 Metakarakterler Şimdiye kadar düzenli ifadelerle ilgili olarak verdiğimiz örnekler sizi biraz şaşırtmış olabilir. “Zordediğinbunlarmıydı?”diyedüşünmüşolabilirsiniz.Haklısınız,zira“zor”dediğim,buraya kadarolankısımdaverdiğimörneklerdenibaretdeğildir.Burayakadarolanbölümdeverdiğim örnekler işin en temel kısmını gözler önüne sermek içindi. Şimdiye kadar olan bölümde, mesela, “python” karakter dizisiyle eşleştirme yapmak için “python” kelimesini kullandık. Esasındabu,düzenliifadelerinentemelözelliğidir.Yani“python”karakterdizisinibirdüzenli ifadesayacakolursak(kizatenöyledir),budüzenliifadeenbaştakendisiyleeşleşecektir.Bune demek?Şöyleki:Eğeraradığınızşey“python”karakterdizisiise,kullanmanızgerekendüzenli ifadede“python”olacaktır. Diyoruz ki: “Düzenli ifadeler en başta kendileriyle eşleşirler”. Buradan şu anlam çıkıyor: Demek ki bir de kendileriyle eşleşmeyen düzenli ifadeler var. İşte bu durum, Python’daki düzenli ifadelere kişiliğini kazandıran şeydir. Biraz sonra ne demek istediğimizi daha açık anlayacaksınız.Artıkgerçekanlamıyladüzenliifadeleregirişyapıyoruz! Öncelikle,elimizdeaşağıdakigibibirlisteolduğunuvarsayalım: >>> liste = ["özcan", "mehmet", "süleyman", "selim", ... "kemal", "özkan", "esra", "dündar", "esin", ... "esma", "özhan", "özlem"] Diyelimki,bizbulisteiçinden“özcan”,“özkan”ve“özhan”öğeleriniayıklamak/almakistiyoruz. Bunuyapabilmekiçinyenibirbilgiyeihtiyacımızvar:Metakarakterler. Metakarakterler; kabaca, programlama dilleri için özel anlam ifade eden sembollerdir. Örneğindahaöncegördüğümüz\nbirbakımabirmetakarakterdir.Çünkü\nsembolüPython için özel bir anlam taşır. Python bu sembolü gördüğü yerde yeni bir satıra geçer. Yukarıda “kendisiyleeşleşmeyenkarakterler”ifadesiylekastettiğimizşeydeiştebumetakarakterlerdir. Örneğin, “a” harfi yalnızca kendisiyle eşleşir. Tıpkı “” kelimesinin yalnızca kendisiyle eşleşeceğigibi... Amamesela\tifadesikendisiyleeşleşmez.Pythonbuişaretigördüğüyerde sekme(tab)düğmesinebasılmışgibitepkiverecektir.İştedüzenliifadelerdedebunabenzer metakarakterlerden yararlanacağız. Düzenli ifadeler içinde de, özel anlam ifade eden pek 910 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 çoksembol,yanimetakaraktervardır.Bumetakarakterlerdenbiride“[]”sembolüdür.Şimdi yukarıdaverdiğimizlisteden“özcan”,“özhan”ve“özkan”öğelerinibusemboldenyararlanarak nasılayıklayacağımızıgörelim: >>> re.search("öz[chk]an", liste) Bukoduböyleyazmamamızgerektiğiniartıkbiliyoruz.Aksihaldehataalırız.Çünküdahaönce dedediğimizgibi,düzenliifadelerkarakterdizileriüzerindeişlemyapabilir.Listelerüzerinde değil.Dolayısıylakomutumuzuşuşekildevermemizgerekiyor: >>> for i in liste: ... nesne = re.search("öz[chk]an", i) ... if nesne: ... print(nesne.group()) Aynıişlemişuşekildedeyapabiliriz: >>> for i in liste: ... if re.search("öz[chk]an",i): ... print(i) Ancak, bu örnekte pek belli olmasa da, son yazdığımız kod her zaman istediğimiz sonucu vermez.Meselalistemizşöyleolsaydı: >>> liste = ["özcan demir", "mehmet", "süleyman", ... "selim", "kemal", "özkan nuri", "esra", "dündar", ... "esin", "esma", "özhan kamil", "özlem"] Yukarıdaki kod bu liste üzerine uygulandığında, sadece almak istediğimiz kısım değil, ilgisiz kısımlardagelecektir. Gördüğünüz gibi, uygun kodları kullanarak, “özcan”, “özkan” ve “özhan” öğelerini listeden kolayca ayıkladık. Bize bu imkânı veren şey ise “[ ]” adlı metakarakter oldu. Aslında “[ ]” metakarakterinin ne işe yaradığını az çok anlamış olmalısınız. Ama biz yine de şöyle bir bakalımbumetakaraktere: “[ ]” adlı metakarakter, yukarıda verdiğimiz listedeki “öz” ile başlayıp, “c”, “h” veya “k” harflerinden herhangi biri ile devam eden ve “an” ile biten bütün öğeleri ayıklıyor. Gelin bununlailgilibirörnekdahayapalım: >>> for i in liste: ... nesne = re.search("es[mr]a",i) ... if nesne: ... print(nesne.group()) Gördüğünüz gibi, “es” ile başlayıp, “m” veya “r” harflerinden herhangi biriyle devam eden ve sonunda da “a” harfi bulunan bütün öğeleri ayıkladık. Bu da bize “esma” ve “esra” çıktılarını verdi... Dediğimizgibi,metakarakterlerprogramlamadilleriiçinözelanlamifadeedensembollerdir. “Normal” karakterlerden farklı olarak, metakarakterlerle karşılaşan bir bilgisayar normalden farklı bir tepki verecektir. Yukarıda metakarakterlere örnek olarak “\n” ve “\t” kaçış dizilerini vermiştik. Örneğin Python’da print(”\n”) gibi bir komut verdiğimizde, Python ekrana “\n” yazdırmakyerinebiraltsatırageçecektir.Çünkü“\n”Pythoniçinözelbiranlamtaşımaktadır. 47.1. Düzenliİfadeler 911 PythonBelgeleri,Yayım4.1.3 Düzenliifadelerdedebirtakımmetakarakterlerinkullanıldığınıöğrendik.Bumetakarakterler, düzenli ifadeleri düzenli ifade yapan şeydir. Bunlar olmadan düzenli ifadelerle yararlı bir iş yapmak mümkün olmaz. Bu giriş bölümünde düzenli ifadelerde kullanılan metakarakterlere örnek olarak “[ ]” sembolünü verdik. Herhangi bir düzenli ifade içinde “[ ]” sembolünü gören Python, doğrudan doğruya bu sembolle eşleşen bir karakter dizisi aramak yerine, özel bir işlemgerçekleştirecektir.Yani“[]”sembolükendisiyleeşleşmeyecektir... Python’dabulunantemelmetakarakterleritoplucagörelim: [ ] . \* + ? { } ^ $ | ( ) Doğrudur, yukarıdaki karakterler, çizgi romanlardaki küfürlere benziyor. Endişelenmeyin, biz bu metakarakterleri olabildiğince sindirilebilir hale getirmek için elimizden gelen çabayı göstereceğiz. Bu bölümde düzenli ifadelerin zor kısmı olan metakarakterlere, okurlarımızı ürkütmeden, yumuşak bir giriş yapmayı amaçladık. Şimdi artık metakarakterlerin temelini attığımıza göre üstekatçıkmayabaşlayabiliriz. [](KöşeliParantez) []adlımetakaraktereöncekibölümdedeğinmiştik.Oradaverdiğimizörnekşuydu: >>> for i in liste: ... nesne = re.search("öz[chk]an", i) ... if nesne: ... print(nesne.group()) Yukarıdaki örnekte, bir liste içinde geçen “özcan”, “özhan” ve “özkan” öğelerini ayıklıyoruz. Burada bu üç öğedeki farklı karakterleri (“c”, “h” ve “k”) köşeli parantez içinde nasıl belirttiğimize dikkat edin. Python, köşeli parantez içinde gördüğü bütün karakterleri tek tek liste öğelerine uyguluyor. Önce “öz” ile başlayan bütün öğeleri alıyor, ardından “öz” hecesinden sonra “c” harfiyle devam eden ve “an” hecesi ile biten öğeyi buluyor. Böylece “özcan”öğesinibulmuşoldu.Aynıişlemi,“öz”hecesindensonra“h”harfinibarındıranve“an” hecesiylebitenöğeyeuyguluyor.Buşekildeise“özhan”öğesinibulmuşoldu.Ensonhedefise “öz” ile başlayıp “k” harfi ile devam eden ve “an” ile biten öğe. Yani listedeki “özkan” öğesi... Ennihayetindedeelimizde“özcan”,“özhan”ve“özkan”öğelerikalmışoluyor. Biröncekibölümdeyine“[]”metakarakteriyleilgiliolarakşuörneğidevermiştik: >>> for i in liste: ... nesne = re.search("es[mr]a",i) ... if nesne: ... print(nesne.group()) Bu örneğin de “özcan, özkan, özhan” örneğinden bir farkı yok. Burada da Python köşeli paranteziçindegördüğübütünkarakterleritekteklisteöğelerineuygulayıp,“esma”ve“esra” öğelerinibizeveriyor. Şimdibununlailgiliyenibirörnekverelim Diyelimkielimizdeşöylebirlistevar: 912 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> a = ["23BH56","TY76Z","4Y7UZ","TYUDZ","34534"] Mesela biz bu listedeki öğeler içinde, sayıyla başlayanları ayıklayalım. Şimdi şu kodları dikkatliceinceleyin: >>> for i in a: ... if re.match("[0-9]",i): ... print(i) ... 23BH56 4Y7UZ 34534 Burada parantez içinde kullandığımız ifadeye dikkat edin. “0” ile “9” arasındaki bütün öğeleri içeren bir karakter dizisi tanımladık. Yani kısaca, içinde herhangi bir sayı barındıran öğeleri kapsama alanımıza aldık. Burada ayrıca search() yerine match() metodunu kullandığımıza da dikkat edin. match() metodunu kullanmamızın nedeni, bu metodun bir karakter dizisinin sadece en başına bakması... Amacımız sayı ile başlayan bütün öğeleri ayıklamak olduğuna göre, yukarıda yazdığımız kod, liste öğeleri içinde yer alan ve sayı ile başlayan bütün öğeleri ayıklayacaktır.BizburadaPython’aşuemrivermişoluyoruz: “Banasayıilebaşlayanbütünöğeleribul!Önemliolanbuöğelerinsayıylabaşlamasıdır!Sayıyla başlayanbuöğeleristerharfledevametsin,isterbaşkabirkarakterle... Senyeterkibanasayı ilebaşlayanöğeleribul!” Bu emri alan Python, hemen liste öğelerini gözden geçirecek ve bize “23BH56”, “4Y7UZ” ve “34534” öğelerini verecektir. Dikkat ederseniz, Python bize listedeki “TY76Z” ve “TYUDZ” öğelerini vermedi. Çünkü “TY76Z” içinde sayılar olsa da bunlar bizim ölçütümüze uyacak şekildeenbaştayeralmıyor.“TYUDZ”öğesindeisetekbirsayıbileyok... Şimdideistersenizlistedeki“TY76Z”öğesininasılalabileceğimizebakalım: >>> for i in a: ... if re.match("[A-Z][A-Z][0-9]",i): ... print(i) Burada dikkat ederseniz düzenli ifademizin başında “A-Z” diye bir şey yazdık. Bu ifade “A” ile “Z” harfleri arasındaki bütün karakterleri temsil ediyor. Biz burada yalnızca büyük harfleri sorguladık. Eğer küçük harfleri sorgulamak isteseydik “A-Z” yerine “a-z” diyecektik. Düzenli ifademiz içinde geçen birinci “A-Z” ifadesi aradığımız karakter dizisi olan “TY76Z” içindeki “T” harfini, ikinci “A-Z” ifadesi “Y” harfini, “0-9” ifadesi ise “7” sayısını temsil ediyor. Karakterdizisiiçindekigerikalanharflervesayılarotomatikolarakeşleştirilecektir.Oyüzden onlar için ayrı bir şey yazmaya gerek yok. Yalnız bu söylediğimiz son şey sizi aldatmasın. Bu “otomatik eşleştirme” işlemi bizim şu anda karşı karşıya olduğumuz karakter dizisi için geçerlidir. Farklı nitelikteki karakter dizilerinin söz konusu olduğu başka durumlarda işler böyle yürümeyebilir. Düzenli ifadeleri başarılı bir şekilde kullanabilmenin ilk şartı, üzerinde işlem yapılacak karakter dizisini tanımaktır. Bizim örneğimizde yukarıdaki gibi bir düzenli ifade kalıbı oluşturmak işimizi görüyor. Ama başka durumlarda, duruma uygun başka kalıplar yazmak gerekebilir/gerekecektir. Dolayısıyla, tek bir düzenli ifade kalıbıyla hayatın geçmeyeceğiniunutmamalıyız. Şimdi yukarıdaki kodu search() ve group() metotlarını kullanarak yazmayı deneyin. Elde ettiğiniz sonuçları dikkatlice inceleyin. match() ve search() metotlarının ne gibi farklılıklara 47.1. Düzenliİfadeler 913 PythonBelgeleri,Yayım4.1.3 sahipolduğunukavramayaçalışın... Sorunuzolursabananasılulaşacağınızıbiliyorsunuz... Buarada,düzenliifadelerleilgilidahafazlaşeyöğrendiğimizdeyukarıdakikoduçokdahasade birbiçimdeyazabileceğiz. .(Nokta) Bir önceki bölümde “[]” adlı metakarakteri incelemiştik. Bu bölümde ise farklı bir metakarakteriinceleyeceğiz.İnceleyeceğimizmetakarakter:“.” Bu metakarakter, yeni satır karakteri hariç bütün karakterleri temsil etmek için kullanılır. Mesela: >>> for i in liste: ... nesne = re.match("es.a",i) ... if nesne: ... print(nesne.group()) ... esma esra Gördüğünüz gibi, daha önce “[]” metakarakterini kullanarak yazdığımız bir düzenli ifadeyi bu kez farklı şekilde yazıyoruz. Unutmayın, bir düzenli ifade birkaç farklı şekilde yazılabilir. Biz bunlar içinde en basit ve en anlaşılır olanını seçmeliyiz. Ayrıca yukarıdaki kodu birkaç farklı şekildedeyazabilirsiniz.Meselaşuyazımdabizimdurumumuzdageçerlibirseçenekolacaktır: >>> for i in liste: ... if re.match("es.a",i): ... print(i) Tabii ki biz, o anda çözmek durumunda olduğumuz soruna en uygun olan seçeneği tercih etmeliyiz... Yalnız,unutmamamızgerekenşey,bu“.”adlımetakarakterinsadecetekbirkarakterinyerini tutuyorolmasıdır.Yanişöylebirkullanımbizeistediğimizsonucuvermez: >>> liste = ["ahmet","kemal", "kamil", "mehmet"] >>> for i in liste: ... if re.match(".met",i): ... print(i) Burada “.” sembolü “ah” ve “meh” hecelerinin yerini tutamaz. “.” sembolünün görevi sadece tekbirkarakterinyerinitutmaktır(yenisatırkarakterihariç).Amabirazsonraöğreneceğimiz metakarakteryardımıyla“ah”ve“meh”hecelerininyerinidetutabileceğiz. “.”sembolünükullanarakbirörnekdahayapalım.Biröncekibölümdeverdiğimiz“a”listesini hatırlıyorsunuz: >>> a = [’23BH56’, ’TY76Z’, ’4Y7UZ’, ’TYUDZ’, ’34534’] Öncebulisteyebiröğedahaekleyelim: >>> a.append("1agAY54") 914 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Artıkelimizdeşöylebirlistevar: >>> a = [’23BH56’, ’TY76Z’, ’4Y7UZ’, ’TYUDZ’, ... ’34534’, "1agAY54"] Şimdibulisteyeşöylebirdüzenliifadeuygulayalım: >>> for i in a: ... if re.match(".[0-9a-z]", i): ... print(i) ... 23BH56 34534 1agAY54 Buradayaptığımızşeyçokbasit.Şuözellikleresahipbirkarakterdizisiarıyoruz: 1. Herhangi bir karakter ile başlayacak. Bu karakter sayı, harf veya başka bir karakter olabilir. 2. Ardındanbirsayıveyaalfabedekiküçükharflerdenherhangibirisigelecek. 3. Bu ölçütleri karşıladıktan sonra, aradığımız karakter dizisi herhangi bir karakter ile devamedebilir. Yukarıdakiölçütlereuyankarakterdizilerimiz:“23BH56”,“34534”,“1agAY54” Yine burada da kendinize göre birtakım değişiklikler yaparak, farklı yazım şekilleri ve farklı metotlarkullanarakneolupnebittiğinidahaiyikavrayabilirsiniz.Düzenliifadelerigereğigibi anlayabilmekiçinbolboluygulamayapmamızgerektiğiniunutmamalıyız. *(Yıldız) Bu metakarakter, kendinden önce gelen bir düzenli ifade kalıbını sıfır veya daha fazla sayıda eşleştirir.Tanımıbirazkarışıkolsadaörnekyardımıylabunudaanlayacağız: >>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"] >>> for i in yeniliste: ... if re.match("sa*t",i): ... print(i) Burada “*” sembolü kendinden önce gelen “a” karakterini sıfır veya daha fazla sayıda eşleştiriyor. Yani mesela “st” içinde sıfır adet “a” karakteri var. Dolayısıyla bu karakter yazdığımız düzenli ifadeyle eşleşiyor. “sat” içinde bir adet “a” karakteri var. Dolayısıyla bu da eşleşiyor. “saat” ve “saaat” karakter dizilerinde sırasıyla iki ve üç adet “a” karakteri var. Tabii kibunlardayazdığımızdüzenliifadeyleeşleşiyor.Listemizinensonöğesiolan“falanca”dada ilkhecedebiradet“a”karakterivar.Amabuöğedekisorun,bunun“s”harfiylebaşlamaması. Çünkübizyazdığımızdüzenliifadede,aradığımızşeyin“s”harfiilebaşlamasını,sıfırveyadaha fazlasayıda“a”karakteriiledevametmesiniveardındanda“t”harfiningelmesiniistemiştik. “falanca”öğesibukoşullarıkarşılamadığıiçinsüzgecimizindışındakaldı. Burada dikkat edeceğimiz nokta, “*” metakarakterinin kendinden önce gelen yalnızca bir karakterle ilgileniyor olması... Yani bizim örneğimizde “*” sembolü sadece “a” harfinin sıfır veya daha fazla sayıda bulunup bulunmamasıyla ilgileniyor. Bu ilgi, en baştaki “s” harfini 47.1. Düzenliİfadeler 915 PythonBelgeleri,Yayım4.1.3 kapsamıyor.“s”harfinindesıfırveyadahafazlasayıdaeşleşmesiniistersekdüzenliifademizi “s*a*t” veya “[sa]*t” biçiminde yazmamız gerekir... Bu iki seçenek içinde “[sa]*t” şeklindeki yazımı tercih etmenizi tavsiye ederim. Burada, daha önce öğrendiğimiz “[ ]” metakarakteri yardımıyla“sa”harflerininasılgrupladığımızadikkatedin... Şimdi “.” metakarakterini anlatırken istediğimiz sonucu alamadığımız listeye dönelim. Orada “ahmet” ve “mehmet” öğelerini listeden başarıyla ayıklayamamıştık. O durumda bizim başarısızolmamızanedenolankullanımşöyleydi: >>> liste = ["ahmet", "kemal", "kamil", "mehmet"] >>> for i in liste: ... if re.match(".met",i): ... print(i) Amaartıkelimizde“*”gibibiraraçolduğunagöreşimdiistediğimizşeyiyapabiliriz.Yapmamız gerekentekşey“.”sembolündensonra“*”sembolünügetirmek: >>> for i in liste: ... if re.match(".*met", i): ... print(i) Gördüğünüzgibi“ahmet”ve“mehmet”öğelerinibukezbaşarıylaayıkladık.Bunuyapmamızı sağlayan şey de “*” adlı metakarakter oldu... Burada Python’a şu emri verdik: “Bana kelime başında herhangi bir karakteri (“.” sembolü herhangi bir karakterin yerini tutuyor) sıfır veya dahafazlasayıdaiçerenvesonuda“met”ilebitenbütünöğeleriver!” Bir önceki örneğimizde “a” harfinin sıfır veya daha fazla sayıda bulunup bulunmamasıyla ilgilenmiştik. Bu son örneğimizde ise herhangi bir harfin/karakterin sıfır veya daha fazla sayıda bulunup bulunmamasıyla ilgilendik. Dolayısıyla “.*met” şeklinde yazdığımız düzenli ifade, “ahmet”, “mehmet”, “muhammet”, “ismet”, “kısmet” ve hatta tek başına “met” gibi bütünöğelerikapsayacaktır.Kısacaifadeetmekgerekirse,sonu“met”ilebitenherşey(“met” ifadesinin kendisi de dâhil olmak üzere) kapsama alanımıza girecektir. Bunu günlük hayatta nerede kullanabileceğinizi hemen anlamış olmalısınız. Mesela bir dizin içindeki bütün “mp3” dosyalarınıbudüzenliifadeyardımıylalisteleyebiliriz: >>> import os >>> import re >>> dizin = os.listdir(os.getcwd()) >>> for i in dizin: ... if re.match(".*mp3",i): ... print(i) match() metodunu anlattığımız bölümde bu metodun bir karakter dizisinin yalnızca başlangıcıyla ilgilendiğini söylemiştik. Mesela o bölümde verdiğimiz şu örneği hatırlıyorsunuzdur: >>> a = "python güçlü bir dildir" >>> re.match("güçlü", a) Bu örnekte Python bize çıktı olarak “None” değerini vermişti. Yani herhangi bir eşleşme bulamamıştı. Çünkü dediğimiz gibi, match() metodu bir karakter dizisinin yalnızca en başına bakar.Amageldiğimizşunoktadaartıkbukısıtlamayınasılkaldıracağınızıbiliyorsunuz: 916 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> re.match(".*güçlü", a) Amamatch()metodunubuşekildezorlamakyerineperformansaçısındanendoğruyolbutür işleriçinsearch()metodunukullanmakolacaktır. Bunudageçtiğimizegöreartıkyenibirmetakarakteriincelemeyebaşlayabiliriz. +(Artı) Bu metakarakter, bir önceki metakarakterimiz olan “*” ile benzerdir. Hatırlarsanız, “*” metakarakteri kendisinden önceki sıfır veya daha fazla sayıda tekrar eden karakterleri ayıklıyordu. “+” metakarakteri ise kendisinden önceki bir veya daha fazla sayıda tekrar eden karakterleri ayıklar. Bildiğiniz gibi, önceki örneklerimizden birinde “ahmet” ve “mehmet” öğelerinişuşekildeayıklamıştık: >>> for i in liste: ... if re.match(".*met",i): ... print(i) Burada“ahmet”ve“mehmet”dışında“met”şeklindebiröğedebudüzenliifadeninkapsamına girecektir.Meselalistemizşöyleolsaidi: >>> liste = ["ahmet", "mehmet", "met", "kezban"] Yukarıdaki düzenli ifade bu listedeki “met” öğesini de içine alacaktı. Çünkü “*” adlı metakarakter sıfır sayıda tekrar eden karakterleri de ayıklıyor. Ama bizim istediğimiz her zaman bu olmayabilir. Bazen de, ilgili karakterin en az bir kez tekrar etmesini isteriz. Bu durumdayukarıdakidüzenliifadeyişuşekildeyazmamızgerekir: >>> for i in liste: ... if re.match(".+met",i): ... print(i) Buradaşukomutuvermişolduk:“Banasonu‘met’ilebitenbütünöğeleriver!Amabana‘met’ öğesiniyalnızbaşınaverme!” Aynıişlemisearch()metodunukullanarakdayapabileceğimizibiliyorsunuz: >>> for i in liste: ... nesne = re.search(".+met",i) ... if nesne: ... nesne.group() ... ahmet mehmet Birdedahaönceverdiğimizşuörneğebakalım: >>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"] >>> for i in yeniliste: ... if re.match("sa*t",i): ... print(i) 47.1. Düzenliİfadeler 917 PythonBelgeleri,Yayım4.1.3 Burada yazdığımız düzenli ifadenin özelliği nedeniyle “st” de kapsama alanı içine giriyordu. Çünkü burada “*” sembolü “a” karakterinin hiç bulunmadığı durumları da içine alıyor. Ama eğerbiz“a”karakterienazbirkezgeçsinistiyorsak,düzenliifademizişuşekildeyazmalıyız: >>> for i in yeniliste: ... if re.match("sa+t", i): ... print(i) Hatırlarsanız önceki derslerimizden birinde köşeli parantezi anlatırken şöyle bir örnek vermiştik: >>> a = ["23BH56", "TY76Z", "4Y7UZ", "TYUDZ", "34534"] >>> for i in a: ... if re.match("[A-Z][A-Z][0-9]",i): ... print(i) Burada amacımız sadece “TY76Z” öğesini almaktı. Dikkat ederseniz, öğenin başındaki “T” ve “Y” harflerini bulmak için iki kez “[A-Z]” yazdık. Ama artık “+” metakarakterini öğrendiğimize göreaynıişidahabasitbirşekildeyapabiliriz: >>> for i in a: ... if re.match("[A-Z]+[0-9]",i): ... print(i) ... TY76Z Burada “[A-Z]” düzenli ifade kalıbını iki kez yazmak yerine bir kez yazıp yanına da “+” sembolünükoyarak,buifadekalıbınınbirveyadahafazlasayıdatekraretmesiniistediğimizi belirttik... “+”sembolününneişyaptığınıdaanladığımızagöre,artıkyenibirmetakarakteriincelemeye başlayabiliriz. ?(Soruİşareti) Hatırlarsanız,“*”karakterisıfıryadadahafazlasayıdaeşleşmeleri;“+”isebiryadadahafazla sayıda eşleşmeleri kapsıyordu. İşte şimdi göreceğimiz “?” sembolü de eşleşme sayısının sıfır veya bir olduğu durumları kapsıyor. Bunu daha iyi anlayabilmek için önceden verdiğimiz şu örneğebakalım: >>> yeniliste = ["st", "sat", "saat", "saaat", "falanca"] >>> for i in yeniliste: ... if re.match("sa*t",i): ... print(i) ... st sat saat saaat >>> for i in yeniliste: (sonrakisayfayadevam) 918 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ... if re.match("sa+t",i): ... print(i) ... sat saat saaat “*” ve “+” sembollerinin hangi karakter dizilerini ayıkladığını görüyoruz. Şimdi de “?” sembolününneyaptığınabakalım: >>> for i in yeniliste: ... if re.match("sa?t",i): ... print(i) ... st sat Gördüğünüz gibi, “?” adlı metakarakterimiz, kendisinden önce gelen karakterin hiç bulunmadığı(yanisıfırsayıdaolduğu)vebiradetbulunduğudurumlarıiçinealıyor.Buyüzden deçıktıolarakbizesadece“st”ve“sat”öğeleriniveriyor. Şimdi bu metakarakteri kullanarak gerçek hayatta karşımıza çıkabilecek bir örnek verelim. Bu metakarakterin tanımına tekrar bakarsak, “olsa da olur olmasa da olur” diyebileceğimiz durumlar için bu metakarakterin rahatlıkla kullanılabileceğini görürüz. Şöyle bir örnek verelim:Diyelimkibirmetinüzerindearamayapacaksınız.Aradığınızkelime“uluslararası”: metin = """Uluslararası hukuk, uluslar arası ilişkiler altında bir disiplindir. Uluslararası ilişkilerin hukuksal boyutunu bilimsel bir disiplin içinde inceler. Devletlerarası hukuk da denir. Ancak uluslar arası ilişkilere yeni aktörlerin girişi bu dalı sadece devletlerarası olmaktan çıkarmıştır.""" (cid:242) Not Bu metin https://tr.wikipedia.org/wiki/Uluslararas%C4%B1_hukuk adresinden alınıp üzerindeufakdeğişiklikleryapılmıştır. Şimdi yapmak istediğimiz şey “uluslararası” kelimesini bulmak. Ama dikkat ederseniz metin içinde “uluslararası” kelimesi aynı zamanda “uluslar arası” şeklinde de geçiyor. Bizim bu iki kullanımıdakapsayacakbirdüzenliifadeyazmamızgerekecek... >>> nesne = re.findall("[Uu]luslar ?arası", metin) >>> for i in nesne: ... print(i) Verdiğimiz düzenli ifade kalıbını dikkatlice inceleyin. Bildiğiniz gibi, “?” metakarakteri, kendinden önce gelen karakterin (düzenli ifade kalıbını) sıfır veya bir kez geçtiği durumları arıyor.Burada“?”sembolünü“ “karakterinden,yani“boşluk”karakterindensonrakullandık. Dolayısıyla, “boşluk karakterinin sıfır veya bir kez geçtiği durumları” hedefledik. Bu şekilde hem “uluslar arası” hem de “uluslararası” kelimesini ayıklamış olduk. Düzenli ifademizde 47.1. Düzenliİfadeler 919 PythonBelgeleri,Yayım4.1.3 ayrıcaşöylebirşeydahayazdık:“[Uu]”.Budagerekiyor.Çünkümetnimiziçinde“uluslararası” kelimesinin büyük harfle başladığı yerler de var... Bildiğiniz gibi, “uluslar” ve “Uluslar” kelimeleriaslaaynıdeğildir.Dolayısıylahem“u”harfinihemde“U”harfinibulmakiçin,daha önceöğrendiğimiz“[]”metakarakterinikullanıyoruz. {}(KümeParantezi) {}adlımetakarakterimizyardımıylabireşleşmedenkaçadetistediğimizibelirtebiliyoruz.Yine aynıörneküzerindengidelim: >>> for i in yeniliste: ... if re.match("sa{3}t",i): ... print(i) ... saaat Burada “a” karakterinin 3 kez tekrar etmesini istediğimizi belirttik. Python da bu emrimizi hemenyerinegetirdi. Bu metakarakterin ilginç bir özelliği daha vardır. Küme içinde iki farklı sayı yazarak, bir karakterinenazveençokkaçkeztekraretmesiniistediğimizibelirtebiliriz.Örneğin: >>> for i in yeniliste: ... if re.match("sa{0,3}t",i): ... print(i) ... st sat saat saaat sa{0,3}t ifadesiyle, “a” harfinin en az sıfır kez, en çok da üç kez tekrar etmesini istediğimiz söyledik.Dolayısıyla,“a”harfininsıfır,bir,ikiveüçkeztekrarettiğidurumlarayıklanmışoldu. Bu sayı çiftlerini değiştirerek daha farklı sonuçlar elde edebilirsiniz. Ayrıca hangi sayı çiftinin dahaönceöğrendiğimiz“?”metakarakteriyleaynıişiyaptığınıbulmayaçalışın... ^(Şapka) ^ sembolünün iki işlevi var. Birinci işlevi, bir karakter dizisinin en başındaki veriyi sorgulamaktır. Yani aslında match() metodunun varsayılan olarak yerine getirdiği işlevi bu metakarakteryardımıylaaçıkçabelirterekyerinegetirebiliyoruz.Şuörneğebakalım: >>> a = [’23BH56’, ’TY76Z’, ’4Y7UZ’, ’TYUDZ’, ... ’34534’, ’1agAY54’] >>> for i in a: ... if re.search("[A-Z]+[0-9]",i): ... print(i) ... 23BH56 TY76Z (sonrakisayfayadevam) 920 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) 4Y7UZ 1agAY54 Birdeşunabakalım: >>> for i in a: ... nesne = re.search("[A-Z]+[0-9]",i) ... if nesne: ... print(nesne.group()) ... BH5 TY7 Y7 AY5 Dikkat ederseniz, şu son verdiğimiz kod oldukça hassas bir çıktı verdi bize. Çıktıdaki bütün değerler,aynendüzenliifademizdebelirttiğimizgibi,yanyanabirveyadahafazlaharfiçeriyor ve sonra da bir sayı ile devam ediyor. Bu farklılığın nedeni, ilk kodlarda print(i) ifadesini kullanmamız. Bu durumun çıktılarımızı nasıl değiştirdiğine dikkat edin. Bir de şu örneğe bakalım: >>> for i in a: ... if re.match("[A-Z]+[0-9]",i): ... print(i) ... TY76Z Buradasadece“TY76Z”çıktısınıalmamızınnedeni,match()metodununkarakterdizilerininen başına bakıyor olması. Aynı etkiyi search() metoduyla da elde etmek için, başlıkta geçen “^” (şapka)sembolündenyararlanacağız: >>> for i in a: ... nesne = re.search("^[A-Z]+[0-9]",i) ... if nesne: ... print(nesne.group()) ... TY7 Gördüğünüz gibi, “^” (şapka) metakarakteri search() metodunun, karakter dizilerinin sadece enbaşınabakmasınısağladı.Oyüzdendebizesadece,“TY7”çıktısınıverdi.Hatırlarsanızaynı kodu,şapkasızolarak,şuşekildekullanmıştıkyukarıda: >>> for i in a: ... nesne = re.search("[A-Z]+[0-9]",i) ... if nesne: ... print(nesne.group()) ... BH5 TY7 Y7 AY5 47.1. Düzenliİfadeler 921 PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, şapka sembolü olmadığında search() metodu karakter dizisinin başına bakmakla yetinmiyor, aynı zamanda karakter dizisinin tamamını tarıyor. Biz yukarıdaki koda bir “^” sembolü ekleyerek, metodumuzun sadece karakter dizisinin en başına bakmasını istedik. O da emrimize sadakatle uydu. Burada dikkatimizi çekmesi gereken başka bir nokta da search() metodundaki çıktının kırpılmış olması. Dikkat ettiyseniz, search() metodu bize öğenin tamamını vermedi. Öğelerin yalnızca “[A-Z]+[0-9]” kalıbına uyan kısımlarını kesip attı önümüze.Çünkübizonatersinisöylemedik.Eğeröğelerintamamınıistiyorsakbunuaçıkaçık belirtmemizgerekir: >>> for i in a: ... nesne = re.search("[A-Z]+[0-9].*",i) ... if nesne: ... print(nesne.group()) ... BH56 TY76Z Y7UZ AY54 Veyametodumuzunkarakterdizisininsadeceenbaşınabakmasınıistersek: >>> for i in a: ... nesne = re.search("^[A-Z]+[0-9].*",i) ... if nesne: ... print(nesne.group()) ... TY76Z Bukodlardadüzenliifadekalıbınınsonuna“.*”sembolünüeklediğimizedikkatedin.Böylelikle metodumuzunsonuherhangibirşekildebitenöğeleribizevermesinisağladık... Başta da söylediğimiz gibi, “^” metakarakterinin, karakter dizilerinin en başına demir atmak dışında başka bir görevi daha vardır: “Hariç” anlamına gelmek... Bu görevini sadece “[]” metakarakterininiçindekullanıldığızamanyerinegetirir.Bunubirörneklegörelim.Yukarıdaki listemiz üzerinde öyle bir süzgeç uygulayalım ki, “1agAY54” öğesi çıktılarımız arasında görünmesin... Buöğeyiavlayabilmekiçinkullanmamızgerekendüzenliifadeşöyleolacaktır: [0-9A-Z][^a-z]+ >>> for i in a: ... nesne = re.match("[0-9A-Z][^a-z]+",i) ... if nesne: ... print(nesne.group()) Buradaşuölçütleresahipbiröğearıyoruz: 1. Aradığımızöğebirsayıveyabüyükharfilebaşlamalı 2. En baştaki sayı veya büyük harften sonra küçük harf GELMEMELİ (Bu ölçütü “^” işareti sağlıyor) 3. Üstelikbu“küçükharfgelmemedurumu”birveyadahafazlasayıdatekraretmeli... Yani baştaki sayı veya büyük harften sonra kaç tane olursa olsun asla küçük harf gelmemeli (Buölçütüde“+”işaretisağlıyor”) Buölçütlereuymayanteköğe“1agAY54”olacaktır.Dolayısıylabuöğeçıktıdagörünmeyecek... 922 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Burada, “^” işaretinin nasıl kullanıldığına ve küçük harfleri nasıl dışarıda bıraktığına dikkat edin. Unutmayalım, bu “^” işaretinin “hariç” anlamı sadece “[]” metakarakterinin içinde kullanıldığızamangeçerlidir. $(Dolar) Bir önceki bölümde “^” işaretinin, karakter dizilerinin en başına demir attığını söylemiştik. Yani bu sembol arama/eşleştirme işleminin karakter dizisinin en başından başlamasını sağlıyordu. Bu sembol bir bakıma karakter dizilerinin nasıl başlayacağını belirliyordu. İşte şimdigöreceğimiz“dolarişareti”de($)karakterdizilerininnasılbiteceğinibelirliyor.Busoyut açıklamalarısomutbirörneklebağlayalım: >>> liste = ["at", "katkı", "fakat", "atkı", "rahat", ... "mat", "yat", "sat", "satılık", "katılım"] Gördüğünüzgibi,elimizdeonöğelikbirlistevar.Diyelimkibizbulisteden,“at”hecesiylebiten kelimeleriayıklamakistiyoruz: >>> for i in liste: ... if re.search("at$",i): ... print(i) ... at fakat rahat mat yat sat Burada “$” metakarakteri sayesinde aradığımız karakter dizisinin nasıl bitmesi gerektiğini belirleyebildik. Eğer biz “at” ile başlayan bütün öğeleri ayıklamak isteseydik ne yapmamız gerektiğinibiliyorsunuz: >>> for i in liste: ... if re.search("^at",i): ... print(i) ... at atkı Gördüğünüz gibi, “^” işareti bir karakter dizisinin nasıl başlayacağını belirlerken, “$” işareti aynıkarakterdizisininnasılbiteceğinibelirliyor.Hattaistersekbumetakarakterleribirliktede kullanabiliriz: >>> for i in liste: ... if re.search("^at$",i): ... print(i) ... at Sonuçtamdabeklediğimizgibioldu.Verdiğimizdüzenliifadekalıbıile“at”ilebaşlayanveaynı şekildebitenkarakterdizileriniayıkladık.Budabize“at”çıktısınıverdi. 47.1. Düzenliİfadeler 923 PythonBelgeleri,Yayım4.1.3 \(TersBölü) Bu işaret bildiğimiz “kaçış dizisi”dir... Peki burada ne işi var? Şimdiye kadar öğrendiğimiz konulardan gördüğünüz gibi, Python’daki düzenli ifadeler açısından özel anlam taşıyan bir takım semboller/metakarakterler var. Bunlar kendileriyle eşleşmiyorlar. Yani bir karakter dizisi içinde bu sembolleri arıyorsak eğer, bunların taşıdıkları özel anlam yüzünden bu sembolleri ayıklamak hemencecik mümkün olmayacaktır. Yani mesela biz “$” sembolünü arıyor olsak, bunu Python’a nasıl anlatacağız? Çünkü bu sembolü yazdığımız zaman Python bunufarklıalgılıyor.Lafıdolandırmadanhemenbirörnekverelim... Diyelimkielimizdeşöylebirlistevar: >>> liste = ["10$", "25¿", "20$", "10TL", "25£"] Amacımızbulistedekidolarlıdeğerleriayıklamaksaneyapacağız?Şunudeneyelimönce: >>> for i in liste: ... if re.match("[0-9]+$",i): ... print(i) Python“$”işaretininözelanlamındandolayı,bizimsayıylabitenbirkarakterdizisiaradığımızı zannedecek, dolayısıyla da herhangi bir çıktı vermeyecektir. Çünkü listemizde sayıyla biten bir karakter dizisi yok... Peki biz ne yapacağız? İşte bu noktada “\” metakarakteri devreye girecek... Hemenbakalım: >>> for i in liste: ... if re.match("[0-9]+\$",i): ... print(i) ... 10$ 20$ Gördüğünüz gibi, “\” sembolünü kullanarak “$” işaretinin özel anlamından kaçtık... Bu metakarakteri de kısaca anlattığımıza göre yeni bir metakarakterle yolumuza devam edebiliriz... |(DikÇizgi) Bu metakarakter, birden fazla düzenli ifade kalıbını birlikte eşleştirmemizi sağlar. Bu ne demek?Hemengörelim: >>> liste = ["at", "katkı", "fakat", "atkı", "rahat", ... "mat", "yat", "sat", "satılık", "katılım"] >>> for i in liste: ... if re.search("^at|at$",i): ... print(i) ... at fakat atkı rahat (sonrakisayfayadevam) 924 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) mat yat sat Gördüğünüzgibi“|”metakarakterinikullanarakbaştavesonda“at”hecesiniiçerenkelimeleri ayıkladık. Aynı şekilde, mesela, renkleri içeren bir listeden belli renkleri de ayıklayabiliriz bu metakarakteryardımıyla... >>> for i in renkler: ... if re.search("kırmızı|mavi|sarı", i): ... print(i) Sıradasonmetakarakterimizolan“()”var... ()(Parantez) Bumetakarakteryardımıyladüzenliifadekalıplarınıgruplayacağız.Bumetakarakterbizimbir karakterdizisininistediğimizkısımlarınıayıklamamızdaçokbüyükkolaylıklarsağlayacak. Diyelim ki biz https://web.archive.org/web/20121025012131/http://www..com/py2/ icindekiler_python.html adresindeki bütün başlıkları ve bu başlıklara ait html dosyalarını bir listehalindealmakistiyoruz.Bununiçinşöylebirşeyyazabiliriz: import re from urllib.request import urlopen url = "https://web.archive.org/web/20121025012131/http://www..com/py2/ icindekiler_python.html" ˓→ f = urlopen(url) regex = ’href=".+html">.+</a>’ for i in f: nesne = re.search(regex, str(i, ’utf-8’)) if nesne: print(nesne.group()) Buradayaptığımızşeyşu: 1. Öncelikle “https://web.archive.org/web/20121025012131/http://www..com/py2/ icindekiler_python.html”sayfasınıurllibmodülüyardımıylaaçtık.Amacımızbusayfadaki başlıklarıvebubaşlıklaraaithtmldosyalarınılistelemek 2. Ardından,bütünsayfayıtaramakiçinbasitbirfordöngüsükurduk 3. Düzenli ifade kalıbımızı şöyle yazdık: ’<href=".+html">.+</a>’ Çünkü bahsi geçen web sayfasındaki html uzantılı dosyalar bu şekilde gösteriliyor. Bu durumu, web tarayıcınızda https://web.archive.org/web/20121025012131/http: //www..com/py2/icindekiler_python.html sayfasını açıp sayfa kaynağını görüntüleyerek teyit edebilirsiniz. (Firefox’ta CTRL+U’ya basarak sayfa kaynağını görebilirsiniz) 47.1. Düzenliİfadeler 925 PythonBelgeleri,Yayım4.1.3 4. Yazdığımız düzenli ifade kalıbı içinde dikkatimizi çekmesi gereken bazı noktalar var: Kalıbın “(.+html)” kısmında geçen “+” metakarakteri kendisinden önce gelen düzenli ifadenin bir veya daha fazla sayıda tekrar eden eşleşmelerini buluyor. Burada “+” metakarakterinden önce gelen düzenli ifade, kendisi de bir metakarakter olan “.” sembolü... Bu sembol bildiğiniz gibi, “herhangi bir karakter” anlamına geliyor. Dolayısıyla “.+” ifadesi şu demek oluyor: “Bana bir veya daha fazla sayıda tekrar eden bütün karakterleri bul!” Dolayısıyla burada “(.+html)” ifadesini birlikte düşünürsek, yazdığımızşeyşuanlamageliyor:“Bana‘html’ilebitenbütünkarakterdizilerinibul!” 5. “https://web.archive.org/web/20121025012131/http://www..com/py2/ icindekiler_python.html” adresinin kaynağına baktığımız zaman aradığımız bilgilerin hep şu şekilde olduğunu görüyoruz: href=”kitap_hakkinda.html”>Bu Kitap Hakkxc4xb1nda</a> Dolayısıyla aslında düzenli ifade kalıbımızı yazarken yaptığımız şey,düzenliifademizikaynaktagörünenşablonauydurmak... 6. Ayrıca çıktıdaki Türkçe karakterlerin düzgün görünmesi için de bayt dizilerini karakter dizisinedönüştürürken‘utf-8’kodlamasınıkullandık. Yukarıdaverdiğimizkodlarıçalıştırdığımızzamanaldığımızçıktışuşekildeoluyor: b’href="kitap_hakkinda.html">Bu Kitap Hakk\xc4\xb1nda</a>’ b’href="python_hakkinda.html">Python Hakk\xc4\xb1nda</a>’ ... Hemen hemen amacımıza ulaştık sayılır. Ama gördüğünüz gibi çıktımız biraz karmaşık. Bunları istediğimiz gibi düzenleyebilsek iyi olurdu, değil mi? Mesela bu çıktıları şu şekilde düzenleyebilmekhoşolurdu: Başlık: ANA SAYFA; Bağlantı: index.html İşte bu bölümde göreceğimiz “( )” metakarakteri istediğimiz şeyi yapmada bize yardımcı olacak. Dilersenizenbaştaverdiğimizkodlaratekrardönelim: import re from urllib.request import urlopen url = "http://belgeler..com/py3/index.html" f = urlopen(url) regex = ’href=".+html">.+</a>’ for i in f: nesne = re.search(regex, str(i, ’utf-8’)) if nesne: print(nesne.group()) Şimdibukodlardaşudeğişikliğiyapıyoruz: import re from urllib.request import urlopen (sonrakisayfayadevam) 926 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) url = "http://belgeler..com/py3/index.html" f = urlopen(url) çıktı = "Başlık: {};\nBağlantı: {}\n" regex = ’href="(.+html)">(.+)</a>’ for i in f: nesne = re.search(regex, str(i, ’utf-8’)) if nesne: print(çıktı.format(nesne.group(2), nesne.group(1))) Kodlarda yaptığımız değişikliklere dikkat edin ve anlamaya çalışın. Bazı noktalar gözünüze karanlıkgöründüysehiçendişeetmeyin,çünkübirsonrakibölümdebütünkaranlıknoktaları tektekaçıklayacağız.Buradaenazından,“()”metakarakterinikullanarakdüzenliifadeninbazı bölümlerininasılgrupladığımızadikkatedin. Buarada,elbettewww..comsitesindeherhangibirdeğişiklikolursayukarıdakikodların istediğiniz çıktıyı vermeyeceğini bilmelisiniz. Çünkü yazdığımız düzenli ifade .com sitesininsayfayapısıylasıkısıkıyabağlantılıdır. 47.1.3 Eşleşme Nesnelerinin Metotları group()metodu Bu bölümde doğrudan düzenli ifadelerin değil, ama düzenli ifadeler kullanılarak üretilen eşleşme nesnelerinin bir metodu olan group() metodundan bahsedeceğiz. Esasında biz bu metoduöncekibölümlerdedekullanmıştık.Amaburadabumetodabirazdahaayrıntılıolarak bakacağız. Daha önceki bölümlerden hatırlayacağınız gibi, bu metot düzenli ifadeleri kullanarak eşleştirdiğimiz karakter dizilerini görme imkanı sağlıyordu. Bu bölümde bu metodu “( )” metakarakteriyardımıyladahaverimlibirşekildekullanacağız.İstersenizilkolarakşöylebasit birörnekverelim: >>> kardiz = "python bir programlama dilidir" >>> nesne = re.search("(python) (bir) (programlama) (dilidir)", kardiz) >>> print(nesne.group()) python bir programlama dilidir Burada düzenli ifade kalıbımızı nasıl grupladığımıza dikkat edin. print(nesne.group()) komutunu verdiğimizde eşleşen karakter dizileri ekrana döküldü. Şimdi bu grupladığımız bölümleretektekerişelim: >>> nesne.group(0) ’python bir programlama dilidir’ Gördüğünüzgibi,“0”indeksieşleşenkarakterdizisinintamamınıveriyor.Birdeşunabakalım: 47.1. Düzenliİfadeler 927 PythonBelgeleri,Yayım4.1.3 >>> nesne.group(1) ’python’ Burada 1 numaralı grubun öğesi olan “python”u aldık. Gerisinin nasıl olacağını tahmin edebilirsiniz: >>> nesne.group(2) ’bir’ >>> nesne.group(3) ’programlama’ >>> nesne.group(4) ’dilidir’ Bu metodun bize ilerde ne büyük kolaylıklar sağlayacağını az çok tahmin ediyorsunuzdur. İstersenizkullanabileceğimizmetotlarıtekrarlisteleyelim: >>> dir(nesne) Bu listede group() dışında bir de groups() adlı bir metodun olduğunu görüyoruz. Şimdi bununneişyaptığınabakalım. groups()metodu Bumetot,bizekullanabileceğimizbütüngruplarıbirdemethalindesunar: >>> nesne.groups() (’python’, ’bir’, ’programlama’, ’dilidir’) Şimdiistersenizbiröncekibölümdeyaptığımızörneğegeridönelim: import re from urllib.request import urlopen url = "http://belgeler..com/py3/index.html" f = urlopen(url) çıktı = "Başlık: {};\nBağlantı: {}\n" regex = ’href="(.+html)">(.+)</a>’ for i in f: nesne = re.search(regex, str(i, ’utf-8’)) if nesne: print(çıktı.format(nesne.group(2), nesne.group(1))) 928 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Bukodlardasonsatırışöyledeğiştirelim: import re from urllib.request import urlopen url = "http://belgeler..com/py3/index.html" f = urlopen(url) çıktı = "Başlık: {};\nBağlantı: {}\n" regex = ’href="(.+html)">(.+)</a>’ for i in f: nesne = re.search(regex, str(i, ’utf-8’)) if nesne: print(nesne.groups()) Gördüğünüzgibişunabenzerçıktılareldeediyoruz: (’kitap_hakkinda.html’, ’Bu Kitap Hakkında’) (’python_hakkinda.html’, ’Python Hakkında’) (’temel_komut_satiri_bilgisi.html’, ’Temel Komut Satırı Bilgisi’) (’path.html’, ’YOL (<em>PATH</em>) Kavramı’) (’kurulum.html’, ’Python Nasıl Kurulur?’) ... ... ... Demek ki (nesne.groups()) komutu bize “( )” metakarakteri ile daha önceden gruplamış olduğumuz öğeleri bir demet olarak veriyor. Biz de bu demetin öğelerine daha sonradan rahatlıklaerişebiliyoruz... Böylece eşleştirme nesnelerinin en sık kullanılan iki metodunu görmüş olduk. Bunları daha sonrakiörneklerimizdedebolbolkullanacağız.Oyüzdenşimdilikbukonuyaaraverelim. 47.1.4 Özel Diziler Düzenli ifadeler içinde metakarakterler dışında, özel anlamlar taşıyan bazı başka ifadeler de vardır.Bubölümdebuözeldizileriinceleyeceğiz:Boşlukkarakterininyerinitutanözeldizi:\s Busembol,birkarakterdizisiiçindegeçenboşluklarıyakalamakiçinkullanılır.Örneğin: >>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"] >>> for i in a: ... nesne = re.search("[0-9]\\s[A-Za-z]+",i) ... if nesne: ... print(nesne.group()) ... 5 Ocak 4 Ekim Yukarıdakiörnekte,birsayıilebaşlayan,ardındanbiradetboşlukkarakteriiçeren,sonradabir büyük veya küçük harfle devam eden karakter dizilerini ayıkladık. Burada boşluk karakterini 47.1. Düzenliİfadeler 929 PythonBelgeleri,Yayım4.1.3 “\s”simgesiilegösterdiğimizedikkatedin. OndalıkSayılarınYeriniTutanÖzelDizi:\d Bu sembol, bir karakter dizisi içinde geçen ondalık sayıları eşleştirmek için kullanılır. Buraya kadarolanörneklerdebuişleviyerinegetirmekiçin“[0-9]”ifadesindenyararlanıyorduk.Şimdi artık aynı işlevi daha kısa yoldan, “\d” dizisi ile yerine getirebiliriz. İsterseniz yine yukarıdaki örnektengidelim: >>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"] >>> for i in a: ... nesne = re.search("\d\s[A-Za-z]+",i) ... if nesne: ... print(nesne.group()) ... 5 Ocak 4 Ekim Burada,“[0-9]”yerine“\d”yerleştirerekdahakısayoldansonucavardık. AlfanümerikKarakterlerinYeriniTutanÖzelDizi:\w Bu sembol, bir karakter dizisi içinde geçen alfanümerik karakterleri ve buna ek olarak “_” karakterinibulmakiçinkullanılır.Şuörneğebakalım: >>> a = "abc123_$%+" >>> print(re.search("\w*", a).group()) abc123_ “\w”özeldizisininhangikarakterlerieşlediğinedikkatedin.Buözeldizişuifadeyleaynıanlama gelir: [A-Za-z0-9_] Düzenli ifadeler içindeki özel diziler genel olarak bunlardan ibarettir. Ama bir de bunların büyükharfliversiyonlarıvardırki,önemliolduklarıiçinonlarıdainceleyeceğiz. Gördüğünüzgibi; 1. “\s”özeldizisiboşlukkarakterleriniavlıyor 2. “\d”özeldizisiondalıksayılarıavlıyor 3. “\w”özeldizisialfanümerikkarakterlerive“_”karakteriniavlıyor Dedik ki, bir de bunların büyük harfli versiyonları vardır. İşte bu büyük harfli versiyonlar da yukarıdakidizilerinyaptığıişintamtersiniyapar.Yani: 1. “\S”özeldizisiboşlukolmayankarakterleriavlar 2. “\D”özeldizisiondalıksayıolmayankarakterleriavlar.Yani“[^0-9]”ileeşdeğerdir. 3. “\W”özeldizisialfanümerikolmayankarakterlerive“_”olmayankarakterleriavlar.Yani [^A-Za-z0-9_]ileeşdeğerdir. 930 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 “\D”ve“\W”dizilerininyeterinceanlaşılırolduğunuzannediyorum.Buradasanırımsadece“S” dizisibirörneklesomutlaştırılmayıhakediyor: >>> a = ["5 Ocak", "27Mart", "4 Ekim", "Nisan 3"] >>> for i in a: ... nesne = re.search("\d+\S\w+",i) ... if nesne: ... print(nesne.group()) ... 27Mart Burada“\S”özeldizisininlistedebelirtilenkonumdaboşlukiçermeyenöğeyinasılbulduğuna dikkatedin. Şimdibuözeldizileriçingenelbirörnekveripkonuyukapatalım... Bilgisayarımızdaşubilgileriiçeren“adres.txt”adlıbirdosyaolduğunuvarsayıyoruz: esra : istinye 05331233445 esma : levent 05322134344 sevgi : dudullu 05354445434 kemal : sanayi 05425455555 osman : tahtakale 02124334444 metin : taksim 02124344332 kezban : caddebostan 02163222122 Amacımızbudosyadayeralanisimvetelefonnumaralarını“isim>telefonnumarası”şeklinde almak: import re dosya = open("adres.txt") for i in dosya.readlines(): nesne = re.search("(\w+)\s+:\s(\w+)\s+(\d+)",i) if nesne: print("{} > {}".format(nesne.group(1), nesne.group(3))) Buradaformülümüzşuşekilde:“Birveyadahafazlakarakter”+“birveyadahafazlaboşluk”+ “’:’işareti”+“biradetboşluk”+“birveyadahafazlasayı” İstersenizbubölümüçokbasitbirsoruylakapatalım.Sorumuzşu: Elimizde şu adresteki yığın var: https://web.archive.org/web/20130511050633/http://www. .com/denemeler/yigin.txt Yapmanızgereken,buyığıniçindekigizlimesajıdüzenliifadelerikullanarakbulmak... 47.1.5 Düzenli İfadelerin Derlenmesi compile()metodu En başta da söylediğimiz gibi, düzenli ifadeler karakter dizilerine göre biraz daha yavaş çalışırlar.Ancakdüzenliifadelerinişleyişinihızlandırmanındabazıyollarıvardır.Buyollardan biridecompile()metodunukullanmaktır.“compile”kelimesiİngilizcede“derlemek”anlamına gelir. İşte biz de bu compile() metodu yardımıyla düzenli ifade kalıplarımızı kullanmadan önce derleyerek daha hızlı çalışmalarını sağlayacağız. Küçük boyutlu projelerde compile() metodu pek hissedilir bir fark yaratmasa da özellikle büyük çaplı programlarda bu metodu kullanmakoldukçafaydalıolacaktır. 47.1. Düzenliİfadeler 931 PythonBelgeleri,Yayım4.1.3 Basitbirörneklebaşlayalım: >>> liste = ["Python2.7", "Python3.2", "Python3.3", ... "Python3.4", "Java"] >>> derli = re.compile("[A-Za-z]+[0-9]\.[0-9]") >>> for i in liste: ... nesne = derli.search(i) ... if nesne: ... print(nesne.group()) ... Python2.7 Python3.2 Python3.3 Python3.4 Burada öncelikle düzenli ifade kalıbımızı derledik. Derleme işlemini nasıl yaptığımıza dikkat edin. Derlenecek düzenli ifade kalıbını compile() metodunda parantez içinde belirtiyoruz. Daha sonra search() metodunu kullanırken ise, re.search() demek yerine, derli.search() şeklindebirifadekullanıyoruz.Ayrıcadikkatedersenizderli.search()kullanımındaparantez içindesadeceeşleşecekkarakterdizisinikullandık(i).Eğerderlemeişlemiyapmamışolsaydık, hem bu karakter dizisini, hem de düzenli ifade kalıbını yan yana kullanmamız gerekecektir. Ama düzenli ifade kalıbımızı yukarıda derleme işlemi esnasında belirttiğimiz için, bu kalıbı ikinci kez yazmamıza gerek kalmadı. Ayrıca burada kullandığımız düzenli ifade kalıbına da dikkat edin. Nasıl bir şablon oturttuğumuzu anlamaya çalışın. Gördüğünüz gibi, liste öğelerinde bulunan “.” işaretini eşleştirmek için düzenli ifade kalıbı içinde “\.” ifadesini kullandık.Çünkübildiğinizgibi,tekbaşına“.”işaretininPython açısındanözelbiranlamıvar. Dolayısıylabuözelanlamdankaçmakiçin“\”işaretinidekullanmamızgerekiyor. compile()ileDerlemeSeçenekleri Biröncekibölümdecompile()metodununneolduğunu,neişeyaradığınıvenasılkullanıldığını görmüştük. Bu bölümde ise “compile” (derleme) işlemi sırasında kullanılabilecek seçenekleri anlatacağız. re.IGNORECASEveyare.I Bildiğiniz gibi, Python’da büyük-küçük harfler önemlidir. Yani eğer “python” kelimesini arıyorsanız, alacağınız çıktılar arasında “Python” olmayacaktır. Çünkü “python” ve “Python” birbirlerinden farklı iki karakter dizisidir. İşte re.IGNORECASE veya kısaca re.I adlı derleme seçenekleri bize büyük-küçük harfe dikkat etmeden arama yapma imkanı sağlar. Hemen bir örnekverelim: import re metin = """Programlama dili, programcının bir bilgisayara ne yapmasını istediğini anlatmasının standartlaştırılmış bir yoludur. Programlama dilleri, programcının bilgisayara hangi veri üzerinde işlem yapacağını, verinin nasıl depolanıp iletileceğini, hangi koşullarda hangi işlemlerin yapılacağını tam olarak anlatmasını sağlar. Şu ana kadar 2500’den fazla (sonrakisayfayadevam) 932 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) programlama dili yapılmıştır. Bunlardan bazıları: Pascal, Basic, C, C#, C++, Java, Cobol, Perl, Python, Ada, Fortran, Delphi programlama dilleridir.""" derli = re.compile("programlama",re.IGNORECASE) print(derli.findall(metin)) Buprogramıçalıştırdığımızdaşuçıktıyıalıyoruz: [’Programlama’, ’Programlama’, ’programlama’, ’programlama’] (cid:242) Not Bumetinhttps://tr.wikipedia.org/wiki/Programlama_diliadresindenalınmıştır. Gördüğünüz gibi, metinde geçen hem “programlama” kelimesini hem de “Programlama” kelimesini ayıklayabildik. Bunu yapmamızı sağlayan şey de re.IGNORECASE adlı derleme seçeneği oldu. Eğer bu seçeneği kullanmasaydık, çıktıda yalnızca “programlama” kelimesini görürdük. Çünkü aradığımız şey aslında “programlama” kelimesi idi. Biz istersek re.IGNORECASEyerinekısacare.Iifadesinidekullanabiliriz.Aynıanlamagelecektir... re.DOTALLveyare.S Bildiğiniz gibi, metakarakterler arasında yer alan “.” sembolü herhangi bir karakterin yerini tutuyordu. Bu metakarakter bütün karakterlerin yerini tutmak üzere kullanılabilir. Hatırlarsanız,“.”metakarakterinianlatırken,bumetakarakterin,yenisatırkarakterininyerini tutmayacağını söylemiştik. Bunu bir örnek yardımıyla görelim. Diyelim ki elimizde şöyle bir karakterdizisivar: >>> a = "Ben Python,\nMonty Python" Bu karakter dizisi içinde “Python” kelimesini temel alarak bir arama yapmak istiyorsak eğer, kullanacağımızşukodistediğimizşeyiyeterinceyerinegetiremeyecektir: >>> print(re.search("Python.*", a).group()) Bukodşuçıktıyıverecektir: Python, Bunun sebebi, “.” metakarakterinin “\n” (yeni satır) kaçış dizisini dikkate almamasıdır. Bu yüzdenbukaçışdizisininötesinegeçiporadaaramayapmıyor.Amaşimdibizonabuyeteneği dekazandıracağız: >>> derle = re.compile("Python.*", re.DOTALL) >>> nesne = derle.search(a) >>> if nesne: ... print(nesne.group()) 47.1. Düzenliİfadeler 933 PythonBelgeleri,Yayım4.1.3 re.DOTALLseçeneğinisadecere.Sşeklindedekısaltabilirsiniz... 47.1.6 Düzenli İfadelerle Metin/Karakter Dizisi Değiştirme İşlemleri sub()metodu Şimdiye kadar hep düzenli ifadeler yoluyla bir karakter dizisini nasıl eşleştireceğimizi inceledik. Ama tabii ki düzenli ifadeler yalnızca bir karakter dizisi “bulmak”la ilgili değildir. Buaraçaynızamandabirkarakterdizisini“değiştirmeyi”dekapsar.Buişiçintemelolarakiki metotkullanılır.Bunlardanilkisub()metodudur.Bubölümdesub()metodunuinceleyeceğiz. Enbasitşekliylesub()metodunuşuşekildekullanabiliriz: >>> a = "Kırmızı başlıklı kız, kırmızı elma dolu sepetiyle \ ... anneannesinin evine gidiyormuş!" >>> derle = re.compile("kırmızı", re.IGNORECASE) >>> print(derle.sub("yeşil", a)) Burada karakter dizimiz içinde geçen bütün “kırmızı” kelimelerini “yeşil” kelimesiyle değiştirdik.Bunuyaparkendere.IGNORECASEadlıderlemeseçeneğindenyararlandık. Elbette sub() metoduyla daha karmaşık işlemler yapılabilir. Bu noktada şöyle bir hatırlatma yapalım.Busub()metodukarakterdizilerininreplace()metodunaçokbenzer.Amatabiiki sub()metoduhemkendibaşınareplace()metodundançokdahagüçlüdür,hemdeberaber kullanılabilecek derleme seçenekleri sayesinde replace() metodundan çok daha esnektir. Amatabiiki,eğeryapmakistediğinizişreplace()metoduylahalledilebiliyorsaendoğruyol, replace()metodunukullanmaktır... Şimdi bu sub() metodunu kullanarak biraz daha karmaşık bir işlem yapacağız. Aşağıdaki metnebakalım: metin = """Karadeniz Ereğlisi denince akla ilk olarak kömür ve demir-çelik gelir. Kokusu ve tadıyla dünyaya nam salmış meşhur Osmanlı çileği ise ismini verdiği festival günleri dışında pek hatırlanmaz. Oysa Çin’den Arnavutköy’e oradan da Ereğli’ye getirilen kralların meyvesi çilek, burada geçirdiği değişim sonucu tadına doyulmaz bir hal alır. Ereğli’nin havasından mı suyundan mı bilinmez, kokusu, tadı bambaşka bir hale dönüşür ve meşhur Osmanlı çileği unvanını hak eder. Bu nazik ve aromalı çilekten yapılan reçel de likör de bir başka olur. Bu yıl dokuzuncusu düzenlenen Uluslararası Osmanlı Çileği Kültür Festivali’nde 36 üretici arasında yetiştirdiği çileklerle birinci olan Kocaali Köyü’nden Güner Özdemir, yılda bir ton ürün alıyor. 60 yaşındaki Özdemir, çileklerinin sırrını yoğun ilgiye ve içten duyduğu sevgiye bağlıyor: "Erkekler bahçemize giremez. Koca ayaklarıyla ezerler çileklerimizi" Çileği toplamanın zor olduğunu söyleyen Ayşe Özhan da çocukluğundan bu yana çilek bahçesinde çalışıyor. Her sabah 04.00’te kalkan Özhan, çileklerini özenle suluyor. Kasım başında ektiği çilek fideleri haziran başında meyve veriyor.""" (cid:242) Not Bu metin https://web.archive.org/web/20161013002254/http://www.radikal.com.tr:80/ haber.php?haberno=40130adresindenalınmıştır. 934 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Gelin bu metin içinde geçen “çilek” kelimelerini “erik” kelimesi ile değiştirelim. Ama bunu yaparken, metin içinde “çilek” kelimesinin “Çilek” şeklinde de geçtiğine dikkat edelim. Ayrıca Türkçe kuralları gereği bu “çilek” kelimesinin bazı yerlerde ünsüz yumuşamasına uğrayarak “çileğ-”şeklinedönüştüğünüdeunutmayalım. Bumetiniçindegeçen“çilek”kelimelerini“erik”ledeğiştirmekiçinbirkaçyolkullanabilirsiniz. Birinci yolda, her değişiklik için ayrı bir düzenli ifade oluşturulabilir. Ancak bu yolun dezavantajı, metnin de birkaç kez kopyalanmasını gerektirmesidir. Çünkü ilk düzenli ifade oluşturulup buna göre metinde bir değişiklik yapıldıktan sonra, ilk değişiklikleri içeren metnin,farklıbirmetinolarakkopyalanmasıgerekir(metin2gibi...).Ardındanikincideğişiklik yapılacağı zaman, bu değişikliğin metin2 üzerinden yapılması gerekir. Aynı şekilde bu metin de, mesela, metin3 şeklinde tekrar kopyalanmalıdır. Bundan sonraki yeni bir değişiklik de bu metin3 üzerinden yapılacaktır... Bu durum bu şekilde uzar gider... Metni tekrar tekrar kopyalamakyerine,düzenliifadelerikullanarakşöylebirçözümdeüretebiliriz: import re derle = re.compile("çile[kğ]", re.IGNORECASE) def degistir(nesne): a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"} b = nesne.group().split() for i in b: return a[i] print(derle.sub(degistir, metin)) Gördüğünüzgibi,sub()metodu,argümanolarakbirfonksiyondaalabiliyor.Yukarıdakikodlar birazkarışıkgörünmüşolabilir.Tektekaçıklayalım... Öncelikleşusatırabakalım: derle = re.compile("çile[kğ]", re.IGNORECASE) Burada amacımız, metin içinde geçen “çilek” ve “çileğ” kelimelerini bulmak. Neden “çileğ”? Çünkü “çilek” kelimesi bir sesli harften önce geldiğinde sonundaki “k” harfi “ğ”ye dönüşüyor. Bu seçenekli yapıyı, daha önceki bölümlerde gördüğümüz “[ ]” adlı metakarakter yardımıyla oluşturduk. Düzenli ifade kalıbımızın hem büyük harfleri hem de küçük harfleri aynı anda bulmasıiçinre.IGNORECASEseçeneğindenyararlandık. Şimdideşusatırlarabakalım: def degistir(nesne): a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"} b = nesne.group().split() for i in b: return a[i] Burada, daha sonra sub() metodu içinde kullanacağımız fonksiyonu yazıyoruz. Fonksiyonu, def degistir(nesne) şeklinde tanımladık. Burada “nesne” adlı bir argüman kullanmamızın nedeni, fonksiyon içinde group() metodunu kullanacak olmamız. Bu metodu fonksiyon içinde “nesne” adlı argümana bağlayacağız. Bu fonksiyon, daha sonra yazacağımız sub() metodu tarafından çağrıldığında, yaptığımız arama işlemi sonucunda ortaya çıkan “eşleşme nesnesi” fonksiyona atanacaktır (eşleşme nesnesinin ne demek olduğunu ilk 47.1. Düzenliİfadeler 935 PythonBelgeleri,Yayım4.1.3 bölümlerden hatırlıyorsunuz). İşte “nesne” adlı bir argüman kullanmamızın nedeni de, eşleşmenesnelerininbirmetoduolangroup()metodunufonksiyoniçindekullanabilmek... Birsonrakisatırdabiradetsözlükgörüyoruz: a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"} Bu sözlüğü oluşturmamızın nedeni, metin içinde geçen bütün “çilek” kelimelerini tek bir “erik” kelimesiyle değiştiremeyecek olmamız... Çünkü “çilek” kelimesi metin içinde pek çok farklı biçimde geçiyor. Başta da dediğimiz gibi, yukarıdaki yol yerine metni birkaç kez kopyalayarak ve her defasında bir değişiklik yaparak da sorunu çözebilirsiniz. (Mesela önce “çilek”kelimelerinibulupbunları“erik”iledeğiştirirsiniz.Dahasonra“çileğ”kelimeleriniarayıp bunları “eriğ” ile değiştirirsiniz, vb...) Ama metni tekrar tekrar oluşturmak pek performanslı biryöntemolmayacaktır.Bizimşimdikullandığımızyöntemmetinkopyalamazorunluluğunu ortadan kaldırıyor. Bu sözlük içinde “çilek” kelimesinin alacağı şekilleri sözlük içinde birer anahtarolarak,“erik”kelimesininalacağışekilleriisebirer“değer”olarakbelirliyoruz. Sonrakisatırdaikimetotbirdenvar: b = nesne.group().split() Burada, fonksiyonumuzun argümanı olarak vazife gören eşleşme nesnesine ait metotlardan biri olan group() metodunu kullanıyoruz. Böylece derle = re.compile("çile[kğ]", re.IGNORECASE) satırı yardımıyla metin içinde bulduğumuz bütün “çilek” ve çeşitlerini alıyoruz. Karakter dizilerinin split() metodunu kullanmamızın nedeni ise group() metodunun verdiği çıktıyı liste haline getirip daha kolay manipüle etmek. Burada for i in b: print(i) komutunu verirseniz group() metodu yardımıyla ne bulduğumuzu görebilirsiniz: çileğ çilek çileğ çilek Çileğ çilek çilek çilek Çileğ çilek çilek çilek Bu çıktıyı gördükten sonra, kodlarda yapmaya çalıştığımız şey daha anlamlı görünmeye başlamışolmalı... Şimdisonrakisatırageçiyoruz: for i in b: return a[i] Burada, group() metodu yardımıyla bulduğumuz eşleşmeler üzerinde bir for döngüsü oluşturduk.Ardındandareturn a[i]komutunuvererek“a”adlısözlükiçindeyeralanöğeleri yazdırıyoruz. Bu arada, buradaki “i”nin yukarıda verdiğimiz group() çıktılarını temsil ettiğine dikkatedin.a[i]gibibirkomutverdiğimizdeaslındasırasıylaşukomutlarıvermişoluyoruz: 936 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 a["çilek"] a["çileğ"] a["çilek"] a["Çileğ"] a["çilek"] a["çilek"] a["çilek"] a["Çileğ"] a["çilek"] a["çilek"] Bu komutların çıktıları sırasıyla “erik”, “eriğ”, “erik”, “Eriğ”, “erik”, “erik”, “erik”, “Eriğ”, “erik”, “erik”olacaktır.İştebureturnsatırıbirsonrakikodolanprint(derle.sub(degistir,metin)) ifadesinde etkinlik kazanacak. Bu son satırımız sözlük öğelerini tek tek metne uygulayacak vemeselaa["çilek"]komutusayesindemetiniçinde“çilek”gördüğüyerde“erik”kelimesini yapıştıracakveböylecebizeistediğimizşekildedeğiştirilmişbirmetinverecektir... Bu kodların biraz karışık gibi göründüğünü biliyorum, ama aslında çok basit bir mantığı var: group()metoduilemetiniçindearadığımızkelimeleriayıklıyor.Ardındanda“a”sözlüğüiçinde bunlarıanahtarolarakkullanarak“çilek”veçeşitleriyerine“erik”veçeşitlerinikoyuyor... Yukarıdaverdiğimizdüzenliifadeyiböyleufakbirmetindekullanmakçokanlamlıolmayabilir. Ama çok büyük metinler üzerinde çok çeşitli ve karmaşık değişiklikler yapmak istediğinizde bukodlarınişinizeyarayabileceğinigöreceksiniz. subn()metodu Bumetoduçokkısabirşekildeanlatıpgeçeceğiz.Çünkübumetotsub()metoduylaneredeyse tamamenaynıdır.Tekfarkı,subn()metodununbirmetiniçindeyapılandeğişikliksayısınıda göstermesidir.Yanibumetodukullanarak,kullanıcılarınıza“toplamşukadarsayıdadeğişiklik yapılmıştır”şeklindebirbilgiverebilirsiniz.Bumetotçıktıolarakikiöğelibirdemetverir.Birinci öğe değiştirilen metin, ikinci öğe ise yapılan değişiklik sayısıdır. Yani kullanıcıya değişiklik sayısını göstermek için yapmanız gereken şey, bu demetin ikinci öğesini almaktır. Mesela sub()metodunuanlatırkenverdiğimizkodlarınsonsatırınışöyledeğiştirebilirsiniz: ab = derle.subn(degistir, metin) print("Toplam {} değişiklik yapılmıştır.".format(ab[1])) Yani: import re metin = """Karadeniz Ereğlisi denince akla ilk olarak kömür ve demir-çelik gelir. Kokusu ve tadıyla dünyaya nam salmış meşhur Osmanlı çileği ise ismini verdiği festival günleri dışında pek hatırlanmaz. Oysa Çin’den Arnavutköy’e oradan da Ereğli’ye getirilen kralların meyvesi çilek, burada geçirdiği değişim sonucu tadına doyulmaz bir hal alır. Ereğli’nin havasından mı suyundan mı bilinmez, kokusu, tadı bambaşka bir hale dönüşür ve meşhur Osmanlı çileği unvanını hak eder. Bu nazik ve aromalı çilekten yapılan reçel de likör de bir başka olur. Bu yıl dokuzuncusu düzenlenen Uluslararası Osmanlı Çileği Kültür Festivali’nde 36 üretici arasında yetiştirdiği çileklerle birinci olan Kocaali (sonrakisayfayadevam) 47.1. Düzenliİfadeler 937 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Köyü’nden Güner Özdemir, yılda bir ton ürün alıyor. 60 yaşındaki Özdemir, çileklerinin sırrını yoğun ilgiye ve içten duyduğu sevgiye bağlıyor: "Erkekler bahçemize giremez. Koca ayaklarıyla ezerler çileklerimizi" Çileği toplamanın zor olduğunu söyleyen Ayşe Özhan da çocukluğundan bu yana çilek bahçesinde çalışıyor. Her sabah 04.00’te kalkan Özhan, çileklerini özenle suluyor. Kasım başında ektiği çilek fideleri haziran başında meyve veriyor.""" derle = re.compile("çile[kğ]", re.IGNORECASE) def degistir(nesne): a = {"çileğ":"eriğ", "Çileğ":"Eriğ", "Çilek":"Erik", "çilek":"erik"} b = nesne.group().split() for i in b: return a[i] ab = derle.subn(degistir, metin) print("Toplam {} değişiklik yapılmıştır.".format(ab[1])) 47.1.7 Sonuç Böylelikle düzenli ifadeler konusunu bitirmiş olduk. Buradaki amacımız, size düzenli ifadeler konusunda genel bir bakış sunabilmekti. Bu yazıları okuduktan sonra kafanızda düzenli ifadelerle ilgili kabataslak da olsa bir resim oluştuysa bu yazılar amacına ulaşmış demektir. Elbette düzenli ifadeler burada anlattıklarımızdan ibaret değildir. Bu konunun üzerine eğildiğinizdeaslındadüzenliifadelerindipsizbirkuyugibiolduğunugöreceksiniz.Esasındaen başta da dediğimiz gibi, düzenli ifadeler apayrı bir dil gibidir. Doğrusu şu ki, düzenli ifadeler başlı başına bağımsız bir sistemdir. Hemen hemen bütün programlama dilleri öyle ya da böyledüzenliifadeleridestekler.Python’dadüzenliifadeleribünyesineadapteetmişdillerden biridir. Bizim düzenli ifadeler konusundaki yaklaşımımız, her zaman bunları “gerektiğinde” kullanmak olmalıdır. Dediğimiz gibi, eğer yapmak istediğiniz bir işlemi karakter dizilerinin metotlarıyardımıylayapabiliyorsanızdüzenliifadeleregirişmemekeniyisidir.Çünkükarakter dizisimetotlarıhemdahahızlıdırhemdeanlamasıdahakolaydır. 47.2 datetime Modülü Bu bölümde, zaman, saat ve tarihlerle ilgili işlemler yapmamızı sağlayan önemli bir standart kütüphanemodülündensözedeceğiz.Bumodülünadıdatetime. datetime modülü; zaman, saat ve tarihlerle ilgili işlemler yapabilmemiz için bize çeşitli fonksiyon ve nitelikler sunan bazı sınıflardan oluşur. Bu modül içinde temel olarak üç farklı sınıfbulunur. (cid:242) Not ‘Sınıf’ kavramına çok takılmayın. İlerleyen derslerde sınıflardan ayrıntılı olarak söz edeceğiz. 938 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 datetimemodülüiçindeyeralanbuüçsınıfşunlardır: 1. date sınıfı; tarihle ilgili işlemler yapabilmemizi sağlayan fonksiyon ve nitelikleri barındırır. 2. timesınıfı;zamanla/saatleilgiliişlemleryapabilmemizisağlayanfonksiyonvenitelikleri barındırır. 3. datetime sınıfı; date ve time sınıflarının birleşiminden ve ilave birkaç nitelik ve fonksiyondanoluşur. Buna göre, datetime adlı sınıf hem date sınıfını hem de time sınıfını kapsadığı için, datetime modülüileişlemyapmakistediğinizde,çoğunluklayalnızcadatetimesınıfınıkullanarakbütün işlerinizihalledebilirsiniz. Dolayısıyla: >>> from datetime import datetime Komutunu vererek datetime modülü içindeki datetime adlı sınıfı içe aktarmayı tercih edebilirsiniz. Bakalımdatetimemodülünündatetimesınıfıiçindenelervarmış: >>> dir(datetime) [’__add__’, ’__class__’, ’__delattr__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__forma t__’, ’__ge__’, ’__getattribute__’, ’__gt__’, ’__hash__’, ’__init__’, ’__le__’, ’__lt__’, ’__ne__’, ’__new__’, ’__radd__’, ’__reduce__’, ’__reduce_ex__’, ’__rep r__’, ’__rsub__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__sub__’, ’__subclass hook__’, ’astimezone’, ’combine’, ’ctime’, ’date’, ’day’, ’dst’, ’fromordinal’, ’fromtimestamp’, ’hour’, ’isocalendar’, ’isoformat’, ’isoweekday’, ’max’, ’microsecond’, ’min’, ’minute’, ’month’, ’now’, ’replace’, ’resolution’, ’second’, ’strftime’, ’strptime’, ’time’, ’timestamp’, ’timetuple’, ’timetz’, ’today’, ’toord inal’, ’tzinfo’, ’tzname’, ’utcfromtimestamp’, ’utcnow’, ’utcoffset’, ’utctimetuple’, ’weekday’, ’year’] Elbette,eğeristersenizdoğrudandatetimemodülünüdeiçeaktarabilirsiniz: >>> import datetime Bu durumda, datetime modülü içindeki datetime sınıfına erişmek için modül adını da kullanmanızgerekir: >>> dir(datetime.datetime) İşte biz bu bölümde, yukarıdaki komutun çıktısında gördüğümüz nitelik ve fonksiyonlar arasındanenönemliolanlarınıinceleyeceğiz. 47.2. datetimeModülü 939 PythonBelgeleri,Yayım4.1.3 47.2.1 now() datetime modülünün içindeki datetime sınıfının now() adlı fonksiyonu, bize içindeki bulunduğumuz andaki tarih, saat ve zaman bilgilerini verir. datetime modülünü import datetimeşeklindeiçeaktardığımızıvarsayarsakbunuşuşekildekullanıyoruz: >>> an = datetime.datetime.now() Bufonksiyonbizedatetime.datetimeadlıözelbirsınıfnesnesiverir: >>> an datetime.datetime(2014, 12, 5, 9, 54, 53, 867108) Buözelsınıfındakendineözgübirtakımnitelikleribulunur. Meselayearadlıniteliğikullanarakiçindebulunduğumuzyılısorgulayabiliriz: >>> an.year 2014 Aynışekildeaşağıdakiniteliklerde,içindebulunduğumuzanailişkinçeşitlibilgilerverir: >>> an.month #ay 12 >>> an.day #gün 5 >>> an.hour #saat 10 >>> an.minute #dakika 20 >>> an.second #saniye 33 >>> an.microsecond #mikrosaniye 337309 940 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.2.2 today() Bufonksiyonnow()ileaynıiçeriğeveişlevesahiptir.today()fonksiyonununowfonksiyonunu kullandığınızgibikullanabilirsiniz: >>> bugün = datetime.datetime.today() >>> bugün.year 2014 >>> bugün.month 12 >>> bugün.minute 35 >>> bugün.second 24 >>> bugün.microsecond 669774 47.2.3 ctime() ctime()fonksiyonu,içindebulunduğumuzanailişkintarihvezamanbilgileriniiçerenokunaklı birkarakterdizisiverir.Bufonksiyona,parametreolarakbirazönceoluşturduğumuzabenzer birdatetime.datetimesınıfıvermemizgerekir.Yani: >>> an = datetime.datetime.now() >>> tarih = datetime.datetime.ctime(an) >>> tarih ’Fri Dec 5 10:30:35 2014’ Bufonksiyontarihleriİngilizceolarakgösterir.Yukarıdakiçıktıyagöretarih5AralıkCuma2014 saat10:30:35. 47.2. datetimeModülü 941 PythonBelgeleri,Yayım4.1.3 47.2.4 strftime() strftime() fonksiyonu, size tarih ve zaman bilgilerini ihtiyaçlarınız doğrultusunda biçimlendirmeimkanısunar. Bu fonksiyon toplam iki parametre alır. İlk parametre, tıpkı ctime() fonksiyonunda olduğu gibi,birdatetime.datetimesınıfıdır.İkinciparametreise,tarih/zamanbilgisiniiçerenkarakter dizisininasılbiçimlendirmekistediğimizigösterenbirbiçimlendiricidir.Yani: >>> an = datetime.datetime.now() >>> tarih = datetime.datetime.strftime(an, ’%c’) >>> tarih ’Fri 05 Dec 2014 12:53:21 PM ’ Burada ilk parametre olarak an değişkeninin tuttuğu datetime.datetime sınıfını, ikinci parametreolarakise%cadlıbiçimlendiriciyikullandık. %cdışındabaşkatarihbiçimlendiricileridebulunur: %a haftagünününkısaltılmışadı %A haftagünününtamadı %b ayınkısaltılmışadı %B ayıntamadı %c tamtarih,saatvezamanbilgisi %d sayıdeğerlibirkarakterdizisiolarakgün %j belli bir tarihin, yılın kaçıncı gününe denk geldiğini gösteren 1-366 arası bir sayı %m sayıdeğerlibirkarakterdizisiolarakay %U bellibirtarihinyılınkaçıncıhaftasınageldiğinigösteren0-53arasıbirsayı %y yılınsonikirakamı %Y yılındörthanelitamhali %x tamtarihbilgisi %X tamsaatbilgisi 942 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Yukarıdakibiçimlendiricilerleilgilibirkaçörnekverelim: >>> datetime.datetime.strftime(an, ’%Y’) # Yıl ’2014’ >>> datetime.datetime.strftime(an, %’X’) # Saat ’12:26:32’ >>> datetime.datetime.strftime(an, ’%d’) # Gün ’05’ strftime()fonksiyonuöntanımlıolarakİngilizceçıktıverecektir: >>> datetime.datetime.strftime(an, ’%A’) ’Friday’ >>> datetime.datetime.strftime(an, ’%B’) ’December’ Eğer isterseniz, locale adlı başka bir modülü kullanarak, strftime() modülünün, sisteminizdekitanımlıdilikullanmasınısağlayabilirsiniz. Bununiçinönceliklelocalemodülünüiçeaktaralım: >>> import locale Ardından Python’ın kullanmasını istediğimiz yerel/dil bilgisini, sistemdeki öntanımlı yerel/dil olarakayarlayalım: >>> locale.setlocale(locale.LC_ALL, ’’) ’Turkish_Turkey.1254’ Bu çıktı bize sistemimizdeki tanımlı dilin/yerelin Türkçe olduğunu söylüyor. Bu komutu verdiktensonra,artıkstrftime()fonksiyonu,ilgilidile/yereleuygunbirçıktıverecektir: >>> datetime.datetime.strftime(an, ’%B’) ’Aralık’ >>> datetime.datetime.strftime(an, ’%A’) ’Cuma’ Eğeristerseniz,dilikendinizdeseçebilirsiniz.Meselaİtalyancayapalım: >>> locale.setlocale(locale.LC_ALL, ’italian’) (sonrakisayfayadevam) 47.2. datetimeModülü 943 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’Italian_Italy.1252’ >>> datetime.datetime.strftime(an, ’%B’) ’dicembre’ >>> datetime.datetime.strftime(an, ’%A’) ’venerdì’ ª Ayrıcabakınız YereldiladlarıiçinWindows’tahttps://www.microsoft.com/en-us/download/details.aspx? id=55979 adresine bakabilirsiniz. GNU/Linux’ta ise, desteklenen yerel/dil adlarını görmek içinsistemkomutsatırındalocale - akomutunuverebilirsiniz. Yukarıda gördüğünüz tarih biçimlendiricileri kullanarak istediğiniz karmaşıklıktaki tarihleri oluşturabilirsiniz.Mesela: >>> datetime.datetime.strftime(an, ’%d %B %Y’) ’05 Aralık 2014’ Veya: >>> datetime.datetime.strftime(an, ’%d.%m.%Y tarihinde buluşalım.’) ‘05.12.2014tarihindebuluşalım.’ Gördüğünüz gibi, strftime() fonksiyonu, tarihler üzerinde istediğimiz karakter dizisi biçimlendirmeişleminiuygulayabilmemizisağlıyor. 47.2.5 strptime() Diyelimkielimizde,herhangibirkaynaktangelmişşöylebirkarakterdizisivar: >>> t = ’27 Mayıs 2014’ Amacımız,tarihbilgisiiçerenbukarakterdizisinigün,ayveyılöğelerineayırmak.Bununiçin basitçeşöylebirkodyazabiliriz: >>> gün, ay, yıl = t.split() >>> gün ’27’ >>> ay ’Mayıs’ (sonrakisayfayadevam) 944 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> yıl ’2014’ Pekieğerelimizdekikarakterdizisişöylebirşeyseneyapacağız? >>> t = ’27 Mayıs 2014 saat 12:34:44’ Bunun için de t değişkeni üzerine split() metodunu uyguladıktan sonra ‘saat’ kelimesini listedenatmayıtercihedebiliriz: >>> gün, ay, yıl, saat = [i for i in t.split() if ’saat’ not in i] >>> gün ’27’ >>> ay ’Mayıs’ >>> yıl ’2014’ >>> saat ’12:34:44’ Yukarıdaki yöntemler, tarih bilgisi içeren karakter dizilerini ayıklamak için geçerli ve uygun olsadaepeymeşakkatlidir.Üstelikbuşekildeayıkladığımızverilerinkullanımalanıdaoldukça kısıtlı olacaktır. Mesela bu verileri datetime.datetime türünde verileri bekleyen uygulamalar içindekullanamayız. İşteböylebirdurumdastrptime()adlıfonksiyondevreyegirerek,tarih/zamanbilgisiiçeren herhangibirkarakterdizisinidatetime.datetimetüründebirnesneyedönüştürebilmemiziçin bizebiryolsunar. Şimdidikkatlicebakın: Elimizdekikarakterdizisişu: >>> t = ’27 Mayıs 2014 saat 12:34:44’ Şimdibukarakterdizisinistrptime()fonksiyonunukullanarakayıklıyoruz: >>> z = datetime.datetime.strptime(t, ’%d %B %Y saat %H:%M:%S’) datetime.datetime(2014, 5, 27, 0, 34, 44) Gördüğünüz gibi, strptime() fonksiyonu iki parametre alıyor. İlk parametre, ayıklamak istediğimiz,tarih-zamanbilgisiiçerenkarakterdizisi.İkinciparametreise,bukarakterdizisinin 47.2. datetimeModülü 945 PythonBelgeleri,Yayım4.1.3 yapısını temsil eden tarih biçimlendiricilerden oluşan başka bir karakter dizisi. Bu karakter dizisi,’27 Mayıs 2014 saat 12:34:44’adlıkarakterdizisininiçindeki,tarihvesaatigösteren kısımlarınherbiriiçinbirbiçimlendiriciiçeriyor: 27 ==> %d Mayıs ==> %B 2014 ==> %Y 12 ==> %H 34 ==> %M 44 ==> %S Bu şekilde bir datetime.datetime nesnesi oluşturduktan sonra, artık bu nesnenin öğelerine, herhangibirdatetime.datetimenesnesigibierişebiliriz: >>> z.month #ay 5 >>> z.day #gün 27 >>> z.year #yıl 2014 >>> z.hour #saat 12 >>> z.minute #dakika 34 >>> z.second #saniye 44 47.2.6 fromtimestamp() Hatırlarsanız os modülünü anlatırken stat() adlı bir fonksiyondan söz etmiştik. Bu fonksiyonun,dosyalarhakkındabilgialmamızısağladığınıbiliyorsunuz: >>> os.stat(’dosya_adı’) Meselabirdosyanınsondeğiştirilmetarihiöğrenmekiçinşöylebirkodkullanıyorduk: >>> os.stat(’dosya_adı’).st_mtime st_mtimeniteliğibizeşunabenzerbirçıktıveriyor: 946 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 1417784445.8881965 Bu, içinde ayrıntılı tarih bilgisi barındıran bir zaman damgasıdır (timestamp). İşte bu zaman damgasını anlamlı bir tarih bilgisine dönüştürebilmek için datetime modülünün datetime sınıfıiçindekifromtimestamp()adlıfonksiyondanyararlanacağız: >>> zaman_damgası = os.stat(’dosya_adı’).st_mtime >>> tarih = datetime.datetime.fromtimestamp(zaman_damgası) >>> tarih datetime.datetime(2014, 12, 5, 15, 0, 45, 888196) Bu şekilde bir datetime.datetime nesnesi elde ettikten sonra artık bu nesneyi istediğimiz şekildemanipüleedebiliriz.Mesela: >>> datetime.datetime.strftime(tarih, ’%c’) ’12/05/14 15:00:45’ Demek ki 1417784445.8881965 zaman damgası, içinde ‘12/05/14 15:00:45’ tarihini barındırıyormuş. 47.2.7 timestamp() Eğer datetime.datetime nesnelerinden bir zaman damgası üretmek isterseniz timestamp() fonksiyonunukullanabilirsiniz: >>> tarih = datetime.datetime.now() >>> zaman_damgası = datetime.datetime.timestamp(tarih) >>> zaman_damgası 1417790594.558625 Eğer daha sonra bu zaman damgasını anlamlı bir tarihe dönüştürmeniz gerekirse fromtimestamp()fonksiyonunukullanabileceğinizibiliyorsunuz: >>> tarih = datetime.datetime.fromtimestamp(zaman_damgası) 47.2.8 Tarihlerle İlgili Aritmetik İşlemler datetime modülünü kullanarak, tarihler arasında çıkarma-toplama gibi çeşitli aritmetik işlemlerdeyapabilirsiniz.Bubölümdebuişlemlerinasılyapacağımızıanlatacağız. 47.2. datetimeModülü 947 PythonBelgeleri,Yayım4.1.3 BelirliBirTarihiKaydetmek Python’dadatetimemodülünükullanarakbugününtarihinibirdatetime.datetimesınıfıolarak nasılalabileceğimizibiliyoruz: >>> datetime.datetime.now() veya: >>> datetime.datetime.today() Pekibizmeselabugünündeğilde,geçmiştekiveyagelecektekibelirlibirtarihialmakistersek neyapacağız? Buişiçindeyinedatetimemodülünündatetimeadlısınıfındanyararlanacağız. Diyelimki16Şubat2016,saat13:45:32’yibirdatetimesınıfıolarakkaydetmekistiyoruz.Bunun içinşöylebirkodkullanacağız: >>> tarih = datetime.datetime(2016, 2, 16, 13, 45, 32) Gördüğünüz gibi, belirli bir tarihi bir datetime.datetime nesnesi olarak kaydetmek istediğimizdedatetimesınıfınaparametreolaraksırasıylailgilitarihinyıl,ay,gün,saat,dakika vesaniyekısımlarınıgiriyoruz. Buarada,eğeristersenizbutarihiçinbirmikrosaniyedebelirtebilirsiniz: >>> tarih = datetime.datetime(2016, 2, 16, 13, 45, 32, 5) Böylecebelirlibirtarihibirdatetimesınıfıolarakkaydetmişolduk.Busınıf,datetime.datetime nesnelerininbütünözelliklerinesahiptir: >>> tarih.year #yıl 2016 >>> tarih.day #gün 16 >>> tarih.month #ay 2 948 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 İkiTarihArasındakiFarkıBulmak Size şöyle bir soru sormama izin verin: Diyelim ki bugünün tarihi 9 Aralık 2014. Doğum tarihimizin 27 Mayıs olduğunu varsayarsak, acaba 2015 yılındaki doğum günümüze kaç gün kaldığınınasılbulabiliriz? Bununiçinönceliklebugününtarihinibirdatetime.datetimenesnesiolarakalalım: >>> bugün = datetime.datetime.today() Şimdi de doğumgünümüze denk gelen tarihi bir datetime.datetime nesnesi olarak kaydedelim: >>> doğumgünü = datetime.datetime(2015, 5, 27) Şimdidebuikitariharasındakifarkıbulalım: >>> fark = doğumgünü - bugün >>> fark datetime.timedelta(168, 34694, 719236) Buradan elde ettiğimiz şey bir timedelta nesnesi. Bu nesne, tarihler arasındaki farkı gün, saniyevemikrosaniyeolaraktutanözelbirveritipidir.Yukarıdakiçıktıdananladığımızagöre, 27 Mayıs 2015 tarihi ile 9 Aralık 2014 tarihi arasında 168 gün, 34694 saniye ve 719236 mikrosaniyevarmış... Yukarıdakitimedeltanesnesininniteliklerineşuşekildeulaşabilirsiniz: >>> fark.days #gün 168 >>> fark.seconds #saniye 34694 >>> fark.microseconds #mikrosaniye 719236 İleriBirTarihiBulmak Diyelim ki 200 gün sonra hangi tarihte olacağımızı bulmak istiyoruz. Tıpkı bir önceki başlıkta tartıştığımızgibi,buisteğimiziyerinegetirmekiçindetimedeltanesnesindenyararlanacağız. Öncebugününtarihinibulalım: >>> bugün = datetime.datetime.today() Şimdi200günlükfarkıbirtimedeltanesnesiolarakkaydedelim: 47.2. datetimeModülü 949 PythonBelgeleri,Yayım4.1.3 >>> fark = datetime.timedelta(days=200) Buradadatetimemodülününtimedelta()fonksiyonunundaysadlıparametresini200değeri ile çağırdığımıza dikkat edin. days adlı parametrenin dışında, timedelta() fonksiyonu şu parametreleredesahiptir: >>> fark = datetime.timedelta(days=200, seconds=40, microseconds=30) Gördüğünüz gibi, gün dışında saniye (seconds) ve mikrosaniye (microseconds) ayarlarını da yapabiliyoruz. Yukarıdaki belirlediğimiz timedelta nesnesi doğrultusunda 200 gün, 40 saniye ve30mikrosaniyegeleceğegidelim: >>> gelecek = bugün + fark >>> gelecek datetime.datetime(2015, 6, 27, 14, 47, 32, 826771) Butarihianlamlıbirkarakterdizisinedönüştürelim: >>> gelecek.strftime(’%c’) ’27.06.2015 14:47:32’ Demek ki bugünden 200 gün, 40 saniye ve 30 mikrosaniye sonrası 27 Haziran 2015, saat 14:47:32’yedenkgeliyormuş... GeçmişBirTarihiBulmak Geçmiş bir tarihi bulmak da, tahmin edebileceğiniz gibi, ileri bir tarihi bulmaya çok benzer. Basitbirörnekverelim: >>> bugün = datetime.datetime.today() Bugünden200güngeriyegidelim: >>> fark = datetime.timedelta(days=200) >>> geçmiş = bugün - fark >>> geçmiş datetime.datetime(2014, 5, 23, 15, 5, 11, 487643) >>> geçmiş.strftime(’%c’) ’23.05.2014 15:05:11’ Demekki200günöncesi23Mayıs2014imiş... 950 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.3 math Modülü mathmodülümatematikselişlemleryapmanızıkolaylaştırmakiçinyazılmışbirmodüldür. 47.3.1 math.ceil() Verilen ondalıklı sayıyı bir üst sayıya çevirir. Sayı eğer tam sayı ise __ceil__ fonksiyonundan yararlanır. >>> math.ceil(32.05) 33 >>> math.ceil(2.98) 3 47.3.2 math.copysign() Aldığıikiparametredenikincisininişaretinibirincisineverir. >>> math.copysign(25,-12) -25.0 >>> math.copysign(-12,-15) -12.0 >>> math.copysign(-245,54) 245.0 47.3.3 math.fabs() Verilen değerin mutlak değerini alır. Gömülü fonksiyonlardan abs’den küçük bir farkı var. Çıktısınıtamsayıolarakdeğilondalıklısayıolarakdöndürüyor. >>> math.fabs(-28) 28.0 >>> abs(-28) 28 47.3.4 math.factorial() Verilensayınınfaktoriyelinidöndürüyor.EğerverilendeğerpozitiftamsayıdeğilseValueError hatasıveriyor. >>> math.factorial(5) 120 >>> math.factorial(-5) Traceback (most recent call last): File "<pyshell#10>", line 1, in <module> math.factorial(-5) ValueError: factorial() not defined for negative values 47.3. mathModülü 951 PythonBelgeleri,Yayım4.1.3 47.3.5 math.floor() ceilfonksiyonununtamtersibirişlevesahip.Verilenondalıklısayıyınınbiraltındakitamsayıyı döndürür.Sayıeğertamsayıise__floor__fonksiyonundanfaydalanır.intfonksiyonundanfarkı negatifsayılardaortayaçıkıyor. >>> math.floor(25.42) 25 >>> math.floor(-12.25) -13 >>> int(-12.25) -12 47.3.6 math.fmod() Verdiğiniz birinci parametrenin ikinci parametreye bölümünden kalanı buluyor. % operatöründenfarkınegatifsayılardaortayaçıkıyor. >>> math.fmod(45,2) 1.0 >>> math.fmod(45,14) 3.0 >>> math.fmod(45,-14) 3.0 >>> 45%-14 -11 47.3.7 math.frexp() Bu fonksiyon x bilindiğinde aşağıdaki denklemin m ve e parametrelerini bulmaya yarıyor. m değerininmutlakdeğeri0,5ve1arasındabirdeğeralıyor. x = m * 2 ** e Örnek: >>> math.frexp(1) (0.5, 1) >>> math.frexp(8) (0.5, 4) 952 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.3.8 math.fsum() sum fonksiyonuna çok benziyor. sum fonksiyonundaki bir açığı kapatıyor. sum fonksiyonu ondalıklısayılarlaçalışırkenbirazsorunçıkarabiliyor. >>> sum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 0.9999999999999999 >>> fsum([.1, .1, .1, .1, .1, .1, .1, .1, .1, .1]) 1.0 47.3.9 math.gcd() VerilenikisayınınEBOB’unuveriyor. >>> math.gcd(45,70) 5 >>> math.gcd(24,-24) 24 >>> math.gcd(36,12) 12 47.3.10 math.trunc() intfonksiyonuileaynıişiyapıyor. >>> math.trunc(15.12) 15 >>> math.trunc(-15.12) -15 >>> math.trunc(0.24) 0 >>> int(0) 0 >>> int(-15.12) -15 47.3.11 math.e eulersabitinitutanbirdeğişken.Değeri:2.718281... 47.3. mathModülü 953 PythonBelgeleri,Yayım4.1.3 47.3.12 math.pi pisayısınıtutandeğişken.Değeri:3.141592.... 47.3.13 math.tau tausabitinitutandeğişken.Değeripisayısınınikikatı. >>> math.pi*2==math.tau True 47.3.14 math.exp() eulersabitininkuvvetinialır.Yaniyaptığıişşudur:math.e**x >>> math.exp(2) 7.38905609893065 47.3.15 math.expm1() math.expfonksiyonununyaptığıiştentekfarkısonuçtan1çıkarmasıdır. >>> math.exp(12) 162754.79141900392 >>> math.expm1(12) 162753.79141900392 47.3.16 math.log() Birincideğerinikincideğeregörelogaritmasınıhesaplar. >>> math.log(10,10) 1.0 >>> math.log(25,5) 2.0 >>> math.log(5,25) 0.5 47.3.17 math.log1p() Verilensayınınbirfazlasınınetabanınagörelogaritmasınıhesaplar. >>> math.log1p(0) 0.0 >>> math.log1p(2) 1.0986122886681098 954 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.3.18 math.log2() Verilensayının2tabanındalogaritmasınıhesaplar. >>> math.log2(2) 1.0 >>> math.log2(42) 5.392317422778761 47.3.19 math.log10() Verilensayının10tabanındalogaritmasınıhesaplar. >>> math.log10(1000) 3.0 >>> math.log10(20) 1.3010299956639813 47.3.20 math.pow() ** ve gömülü fonksiyonlardan pow ile aynı işi yapıyor. Yani birinci sayının ikinci sayıya göre kuvvetinialıyor. >>> math.pow(2,5) 32.0 >>> math.pow(2,0) 1.0 >>> pow(2,5) 32 >>> pow(2,0) 1 47.3.21 math.sqrt() Verilensayınınkarekökünühesaplar. >>> math.sqrt(16) 4.0 >>> math.sqrt(225) 15.0 47.3. mathModülü 955 PythonBelgeleri,Yayım4.1.3 47.3.22 math.degrees() Verilensayıyıradyandandereceyeçevirir. >>> math.degrees(1.5707963267948966) 90.0 47.3.23 math.radians() Verilensayıyıderecedenradyanaçevirir. >>> math.radians(90) 1.5707963267948966 47.3.24 math.sin() Radyancinsindenverilensayınınsinüsünühesaplar. >>> math.sin(math.radians(60)) 0.8660254037844386 47.3.25 math.cos() Radyancinsindenverilenparametreninkosinüsünühesaplar. 47.3.26 math.tan() Radyancinsindenverilenparametrenintanjantınıhesaplar. 47.3.27 math.asin() Verilensinüsdeğerindenradyancinsindebiraçıdöndürür. 47.3.28 math.acos() Verilenkosinüsdeğerindenradyancinsindebiraçıdöndürür. 956 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.3.29 math.atan() Verilentanjantdeğerindenradyancinsindebiraçıdöndürür. 47.3.30 math.atan2() İlkdeğereyikincideğerexdersekşuişleminsonucunudöndürür:atan(y/x) 47.3.31 math.hypot() İlkdeğerexikincideğereydersekşuişleminsonucunudöndürür:sqrt(x*x+y*y). 47.3.32 math.cosh() Verilendeğerinhiperbolikkosinüsünüdöndürür. 47.3.33 math.sinh() Verilendeğerinhiperboliksinüsünüdöndürür. 47.3.34 math.tanh() Verilendeğerinhiperboliktanjantınıdöndürür. 47.3.35 math.acosh() Verilenhiperbolikkosinüsdeğerinintersinidöndürür. 47.3.36 math.asinh() Verilenhiperboliksinüsdeğerinintersinidöndürür. 47.3.37 math.atanh() Verilenhiperboliktanjantdeğerinintersinidöndürür. 47.3.38 math.gamma() Bu fonksiyon factorial fonksiyonuna çok benziyor. Farklarından biri verilen sayının bir azının faktoriyelinihesaplamasıdır.Ancakasılfarksayıbüyüdüğündeortayaçıkıyor. 47.3. mathModülü 957 PythonBelgeleri,Yayım4.1.3 >>> math.factorial(12)==math.gamma(13) True >>> math.factorial(12) 479001600 >>> math.gamma(13) 479001600.0 >>> math.factorial(35)==math.gamma(36) False >>> math.factorial(35) 10333147966386144929666651337523200000000 >>> math.gamma(36) 1.0333147966386145e+40 47.3.39 math.lgamma() Bufonksiyondahaönceöğrendiğimizikifonksiyonubirleştiriyor. >>> math.lgamma(45)==math.log(math.gamma(45)) True >>> math.log(math.gamma(45)) 125.3172711493569 >>> math.lgamma(45) 125.3172711493569 47.4 random Modülü Eğer yazdığınız programlarda, belirli bir aralıkta rastgele sayıların üretilmesine ihtiyaç duyarsanız Python’ın standart kütüphanesinde bulunan random adlı bir modülü kullanabilirsiniz. Tıpkıötekimodüllerdeolduğugibi,randommodülüdebirtakımfaydalınitelikvefonksiyonları barındırır. Biz bu bölümde, bu nitelik ve fonksiyonlar arasında en sık kullanılanları inceleyeceğiz. Elbettebumodülükullanabilmekiçinönceliklemodülümüzüiçeaktarmamızgerekiyor: import random Buişleminardından,bumodülünbizesunduğubütünişlevlerdenyararlanabiliriz. 958 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.4.1 random() random modülünün random() adlı fonksiyonunu kullanarak, 0.0 ile 1.0 arasında rastgele bir kayannoktalısayıüretebilirsiniz: >>> random.random() 0.8064301704207291 random()fonksiyonu,kendisiniherçalıştırışınızdafarklıbirkayannoktalısayıüretecektir: >>> random.random() 0.6825988062501599 Üretilensayıların0ile1arasındaolduğunuözellikledikkatiniziçekmekisterim. Meselabufonksiyonukullanarak,0ile1arası10tanesayıüretelim.Busayılarıgösterirkende noktadansonrayalnızcadörtbasamakgörüntülenmesineizinverelim: >>> for i in range(10): ... print("{:.4f}".format(random.random())) ... 0.3094 0.5277 0.1588 0.2832 0.8742 0.9989 0.6847 0.5672 0.5529 0.9717 47.4.2 uniform() Biraz önce gördüğümüz random() fonksiyonu, dikkat ederseniz herhangi bir parametre almıyordu. Çünkü bu fonksiyonun tek görevi 0 ile 1 arası sayılar üretmektir. Peki ya biz üreteceğimizsayılarınfarklıbiraralıktaolmasınıistersekneyapacağız? İşte,belirlibiraralıktakayannoktalısayılarüretmekistediğimizde,random()yerineuniform() adlıbirfonksiyonkullanacağız.Dikkatliceinceleyin: >>> random.uniform(0.5, 1.5) Bukod,herçalıştırılışında0.5ile1.5arasırastgelebirkayannoktalısayıüretecektir: >>> random.uniform(0.5, 1.5) 0.9624863371746406 (sonrakisayfayadevam) 47.4. randomModülü 959 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> random.uniform(0.5, 1.5) 0.900446344810926 47.4.3 randint() Şimdiye kadar öğrendiğimiz random() ve uniform() fonksiyonları bize yalnızca kayan noktalı sayılar üretme imkanı veriyordu. Ancak elbette biz kimi durumlarda kayan noktalı sayılar yerine tam sayılar üretmek de isteyebiliriz. İşte böyle bir durumda, random modülünün randint()adlıbaşkabirfonksiyonunukullanabiliriz. Mesela 45 ile 500 arasında rastgele bir sayı üretmek isterseniz, randint() fonksiyonunu şu şekildekullanabilirsiniz: >>> random.randint(45, 500) Bufonksiyon,herçalıştırılışında45ile500arasındarastgelebirtamsayıüretecektir. 47.4.4 choice() randommodülününchoice()adlıfonksiyonunukullanarak,diziniteliğitaşıyanveritiplerinden rastgele öğeler seçebiliriz. Bu tanım biraz anlaşılmaz gelmiş olabilir. O yüzden bunu bir örnekleaçıklayalım. Diyelimkielimizdeşöylebirlistevar: >>> liste = [’ali’, ’veli’, ’ahmet’, ... ’mehmet’, ’celal’, ’selin’, ’nihat’] Bildiğiniz gibi, listeler, dizi niteliği taşıyan veri tipleridir. Dolayısıyla choice() fonksiyonunu kullanarakbudizidenrastgelebiröğeseçebiliriz: >>> liste = [’ali’, ’veli’, ’ahmet’, ’mehmet’, ’celal’, ’selin’, ’nihat’] >>> random.choice(liste) ’ali’ >>> random.choice(liste) ’mehmet’ >>> random.choice(liste) ’selin’ Tıpkı bu örnekte olduğu gibi, karakter dizileri de dizi niteliği taşıyan bir veri tipi olduğu için, choice()fonksiyonunacevapverir: 960 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> kardiz = ’’ >>> random.choice(kardiz) ’i’ Peki acaba bu ‘i’ harfi karakter dizisinin başındaki ‘i’ harfi mi, yoksa ortasındaki ‘i’ harfi mi? Sizcebununasılanlayabiliriz? 47.4.5 shuffle() shuffle() fonksiyonunu kullanarak, dizi niteliği taşıyan veri tiplerindeki öğeleri karıştırabilirsiniz(yaniöğelerinsırasınıkarışıkbirhalegetirebilirsiniz).Mesela: >>> l = list(range(10)) 10öğelibirlistemizvar.Bulistedekiöğeler0’dan10’akadardüzgünbirşekildesıralanmış: >>> l [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Şimdibizshuffle()fonksiyonunukullanaraköğelerikarıştıracağız: >>> random.shuffle(l) >>> l [8, 0, 7, 9, 1, 4, 6, 5, 3, 2] Burada dikkat etmemiz gereken önemli nokta, shuffle() fonksiyonunun, özgün listenin kendisi üzerinde değişiklik yapıyor oluşudur. Yani liste üzerinde shuffle() metodunu uyguladıktan sonra artık özgün listeyi kaybediyoruz. Dolayısıyla elimizde artık öğeleri 0’dan 10’a kadar düzgün bir şekilde sıralanmış liste yok. Onun yerine, öğeleri karıştırılmış bir liste varelimizde. Liste üzerine shuffle() fonksiyonunu her uygulayışınızda özgün listenin öğeleri bir daha karıştırılacaktır. Pekisizebirsoru... Elinizdeşöylebirlistevar: arkadaşlar=[‘ali’,‘veli’,‘mehmet’,‘ahmet’,‘serkan’,‘selin’] Görevimiz bu listenin öğelerini karıştırmak. Ama biz aynı zamanda özgün arkadaşlar listesindekiöğesıralamasınıdakaybetmekistemiyoruz.Bununasılbaşarabiliriz? 47.4. randomModülü 961 PythonBelgeleri,Yayım4.1.3 47.4.6 randrange() randrange()fonksiyonu,yukarıdaöğrendiğimizrandint()fonksiyonuileaynıişiyapar.Yani herikifonksiyonda,bellibiraralıktarastgeletamsayılarüretir.Ancakaralarındaikiufakfark bulunur. İlköncebirincisinebakalım... Dikkatliceinceleyin: >>> random.randrage(10) 5 Gördüğünüz gibi, randrange() fonksiyonunu tek parametre ile kullanabiliyoruz. Yukarıdaki komutueğerrandint()ileyazmakistersekşunuyapmamızgerekir: >>> random.randint(0, 10) randrange() fonksiyonundan farklı olarak, randint() fonksiyonunu iki parametre ile kullanmamızgerekir.Eğerbufonksiyonatekparametreverirsekhataalırız: >>> random.randint(10) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: randint() missing 1 required positional argument: ’b’ Elbette, eğer istersek randrange() fonksiyonunu da çift parametre ile kullanarak, farklı bir sayıaralığıbelirtmeimkanınasahibiz: >>> random.randrange(10, 500) Bu komut, 10 ile 500 arası rastgele tam sayılar üretecektir. Ayrıca bu komut şununla da eşdeğerdir: >>> random.randint(10, 500) Bu iki fonksiyon arasındaki ikinci fark ise, rastgele sayı üretilecek aralığın son değeridir. Bu muğlakifadeyibirörnekleanlaşılırhalegetirmeyeçalışalım: >>> random.randrange(10, 20) Bukomut,10ile20arasındarastgelebirsayıüretir.Üretilecekendüşüksayı10iken,enbüyük sayıise19olacaktır.20sayısıaslaüretilmez. Birdeşunabakalım: >>> random.randint(10, 20) Burada da yine 10 ile 20 arasında rastgele bir sayı üretilir. Tıpkı randrange() metodunda olduğugibi,üretilecekendüşüksayı10’dur.Ancakenbüyüksayı20olacaktır. Bu iki fonksiyonu kullanırken bu farklılığa dikkat etmemiz gerekir. Aksi halde yazdığımız programlarhatalıçalışabilir. 962 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Pekisizebirsoru:Acabarandint()ilerandrange()arasındakibufarkınasılkanıtlarsınız? 47.4.7 sample() ‘Sample’kelimesi‘numune’anlamınagelir.İştekelimeninbuanlamınaparalelolaraksample() fonksiyonuda,diziniteliğitaşıyanveritiplerindenbellisayıdanumunealınabilmesinisağlar. Bakınız: >>> liste = range(100) 100öğelibirlisteoluşturduk.Şimdibulisteden5tanerastgelenumunealalım: >>> random.sample(liste, 5) [56, 74, 2, 3, 80] Gördüğünüz gibi, sample() fonksiyonunun ilk parametresi numune alınacak diziyi, ikinci parametresiisebudizidenkaçtanenumunealınacağınıgösteriyor. 47.5 Sqlite ile Veritabanı Programlama 47.5.1 Giriş Bubölümde,Python’dakiileridüzeykonulardanbiriolanveritabanıprogramlamayı(database programming) inceleyeceğiz. Dilerseniz öncelikle ‘veritabanı’ denen şeyin ne olduğunu anlamayaçalışarakişebaşlayalım. Esasında veritabanı, hiçbirimizin yabancısı olduğu bir kavram değil. Biz bu kelimeyi, teknik anlamının dışında, günlük hayatta da sıkça kullanıyoruz. Veritabanı, herkesin bildiği ve kullandığı anlamıyla, içinde veri barındıran bir ‘şey’dir. Günlük kullanımda, hakikaten, içinde veribarındıranherşeyeveritabanıdendiğiniduyarsınız. Veritabanı kelimesinin günlük kullanımdaki anlamı dışında bir de teknik anlamı vardır. Bizi esas ilgilendiren de zaten terimin teknik anlamıdır. Mesela Vikipedi’de veritabanı şöyle tanımlanıyor: Bilgisayar terminolojisinde, sistematik erişim imkânı olan, yönetilebilir, güncellenebilir, taşınabilir, birbirleri arasında tanımlı ilişkiler bulunabilen bilgiler kümesidir. Bir başka tanımı da, bir bilgisayarda sistematik şekilde saklanmış, programlarcaişlenebilecekveriyığınıdır. Yukarıdaki tanım, veritabanının ne demek olduğunu gayet iyi ifade ediyor. Ama esasında bizim veritabanı tanımı üzerinde fazlaca durmamıza gerek yok. Biz her zaman olduğu gibi işin teknik boyutuyla değil, taktik boyutuyla ilgilenmeyi tercih edeceğiz. O halde yavaş yavaş işekoyulmayabaşlayalım. Python’la veritabanı programlama işlemleri için pek çok alternatifimiz var. Python’la hangi veritabanı sistemlerini kullanabileceğinizi görmek için https://wiki.python.org/moin/ DatabaseInterfaces adresindeki listeyi inceleyebilirsiniz. Biz bunlar içinde, sadeliği, basitliği vekullanımkolaylığınedeniyleSqliteadlıveritabanıyönetimsisteminielealacağız. 47.5. SqliteileVeritabanıProgramlama 963 PythonBelgeleri,Yayım4.1.3 47.5.2 Neden Sqlite? Dediğimiz gibi, Python’da veritabanı işlemleri için kullanabileceğiniz pek çok alternatif bulunur.AmabizbütünbualternatifleriçindeSqlite’ıtercihedeceğiz.PekinedenSqlite? Sqlite’ın öteki sistemlere göre pek çok avantajı bulunur. Gelin isterseniz Sqlite’ın bazı avantajlarınaşöylebirgözgezdirelim: • Her şeyden önce Sqlite Python’un 2.5 sürümlerinden bu yana bu dilin bir parçasıdır. Dolayısıyla eğer kullandığınız Python sürümü 2.5 veya üstü ise Sqlite’ı Python’daki herhangibirmodülgibiiçeaktarabilirvekullanmayabaşlayabilirsiniz. • Sqlite herhangi bir yazılım veya sunucu kurulumu gerektirmez. Bu sayede, bu modülü kullanabilmek için öncelikle bir sunucu yapılandırmanıza da gerek yoktur. Bazı veritabanlarını kullanabilmek için arka planda bir veritabanı sunucusu çalıştırıyor olmanızgerekir.Sqlite’taiseböylebirşeyyapmazsınız. • Sqlite,ötekipekçokveritabanıalternatifinegörebasittir.BuyüzdenSqlite’ıçokkısabir süredekavrayıpkullanmayabaşlayabilirsiniz. • Sqlite özgür bir yazılımdır. Bu yazılımın baştan aşağı bütün kodları kamuya açıktır. Dolayısıyla Sqlite kodlarının her zerresini istediğiniz gibi kullanabilir, değişikliğe uğratabilir, satabilir ve ticari olan/olmayan bütün uygulamalarınızda gönül rahatlığıyla kullanabilirsiniz. • Sqlite’ın sade ve basit olması sizi yanıltmasın. Bu özelliklerine bakarak, Sqlite’ın yeteneksiz bir veritabanı sistemi olduğunu düşünmeyin. Bugün Sqlite’ı aktif olarak kullanan pek çok büyük ve tanınmış şirket bulunur. Mesela, Adobe, Apple, Mozilla/Firefox, Google, Symbian ve Sun bu şirketlerden bazılarıdır. Hatta GNOME masaüstü ortamının sevilen müzik ve video çalarlarından Banshee’de de veritabanı olarakSqlitekullanıldığınısöyleyelim. Yukarıdaki sebeplerden ötürü, veritabanı konusunu Sqlite üzerinden anlatacağız. O halde hemenyolakoyulalım. 47.5.3 Sqlite’ın Yapısı Bu bölümün en başında verdiğimiz veritabanı tanımından da anlaşılacağı gibi, veritabanları, verileri sonradan kullanılmak üzere içinde tutan bir sistemdir. Bütün ilişkisel veritabanları33nda olduğu gibi, Sqlite da bu verileri tablo benzeri bir yapı içinde tutar. Yani aslındabirSqliteveritabanıiçindekiverilerşöylebiryapıyasahiptir: tabularytabulary Sütun1 Sütun2 Sütun3 Sütun4 Sütun5 Değer1/1 Değer2/1 Değer3/1 Değer4/1 Değer5/1 Değer1/2 Değer2/2 Değer3/2 Değer4/2 Değer5/2 Değer1/3 Değer2/3 Değer3/3 Değer4/3 Değer5/3 Değer1/4 Değer2/4 Değer3/4 Değer4/4 Değer5/4 Sqliteiçindeoluşturulanyukarıdakinebenzerhertablonunbirdeismivardır.Dahadoğrusu, Sqlite ile bir tablo oluştururken, bu tabloya bir de ad vermemiz gerekir. Mesela yukarıdaki 33https://tr.wikipedia.org/wiki/%C4%B0li%C5%9Fkisel_veri_taban%C4%B1_y%C3%B6netim_sistemi 964 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 tabloya‘değerler’adınıverdiğimizivarsayabilirsiniz. Sqlite ile çalışırken veriler üzerinde yapacağımız işlemleri, yukarıdaki tablonun adını ve bu tablodakisütunlarıkullanarakgerçekleştireceğiz.BuyüzdenSqlite’ınyapısınıanlamakbüyük önem taşır. Gördüğünüz gibi, bu veritabanı sisteminin yapısını anlamak da öyle zor bir iş değildir. 47.5.4 Yardımcı Araçlar Veritabanları üzerinde yapacağımız çalışmalar sırasında, işlerimizi kolaylaştırmak için bazı hariciaraçlaradaihtiyaçduyacağız.Gelinşimdibuaraçlarıtanıyalım. Sqlitebrowser Sqlitebrowser, Sqlite veritabanlarının içeriğini grafik bir arayüz aracılığıyla görüntüleyebilmemizi sağlayan bir program. Bu program sayesinde, veritabanı üzerinde yaptığınız çalışmanın doğru sonuç verip vermediğini teyit edebilir, elinizdeki veritabanının içeriğindehangiverilerinolduğunuaçıkseçikgörebilirsiniz. Buprogramıindirmekiçinziyaretetmemizgerekenadreshttps://sqlitebrowser.org/. Eğer siz bir Windows kullanıcısı iseniz, sitedeki .exe dosyasını indirip, programı herhangi bir Windowsprogramıgibikurabilirsiniz. GNU/Linux kullanıcılarının önünde ise her zaman olduğu gibi birkaç farklı seçenek var. Öncelikle, bu program çoğu GNU/Linux dağıtımının paket deposunda zaten bulunur. Dolayısıyla bu programı dağıtımınızın paket deposu aracılığıyla rahatlıkla kurabilirsiniz. MeselaUbuntukullananlarşukomutlaprogramıkurabilir: sudo apt-get install sqlitebrowser GNU/Linux kullanıcıları, eğer arzu ederlerse, programın kaynak kodlarını sitesinden indirip programı kendileri derlemeyi de tercih edebilir. Bunun için öncelikle https://sqlitebrowser. org/adresinegidip.tar.gzuzantılıdosyayıindirin. Buprogramıderlemeyegeçmedenönceşubağımlılıklarıkurmamızgerekiyor: 1. cmake 2. libqt4-dev 3. libsqlite3-dev Ubuntu’daayrıcabuild-essentialpaketinedeihtiyacınızolacak.Ubuntukullanıcılarışukomutu vererekSqlitebrowserprogramınınbütünbağımlılıklarınısistemlerinekurabilir: sudo apt-get install build-essential cmake libqt4-dev libsqlite3-dev Bağımlılıklarıkurduktansonra,indirdiğiniz.tar.gzdosyasınıaşağıdakikomutyardımıylaaçın: tar zxvf sqlitebrowser-3.7.0.tar.gz Ben burada indirdiğiniz program sürümünün 3.7.0 olduğunu varsaydım. Sizin indirdiğiniz sürümfarklıysayukarıdakikomutuosürümegörevereceksiniz. Dahasonraşukomutuvererek,açtığınızklasörüniçinegirin: 47.5. SqliteileVeritabanıProgramlama 965 PythonBelgeleri,Yayım4.1.3 cd sqlitebrowser-3.7.0 Yine,buradadaklasöradıvesürümnumarasısizdefarklıysakomutudüzeltin. Ardındansırasıylaşukomutlarıverin(cmakekomutununyanındakinoktaişaretinedikkat!!): cmake . make sudo make install BöyleceSqlitebrowserprogramınısisteminizekurmuşoldunuz.Programınkurulduğunuteyit etmekiçinşukomutuçalıştırın: sqlitebrowser Eğerprogrampenceresiaçıldıysaherşeyyolundademektir.Eğerprogramıçalıştıramadıysanız veya yukarıdaki komutları anlamakta ve işletmekte zorluk çekiyorsanız paket deponuzdaki Sqlitebrowser sürümü ile yola devam etmenizi tavsiye ederim. Ya da eğer arzu ederseniz, https://forum..com/adresineuğrayıpyardımtalebindebulunabilirsiniz. ÖrnekVeritabanı Sqlite’ıöğrenirken,içindeörnekverilerbarındıranbirveritabanınınelimizinaltındabulunması alıştırma yapabilmek açısından faydalı olacaktır. Bunun için https://web.archive.org/ web/20170511004853/http://www..com/denemeler/kitaplar.sqlite adresindeki örnek veritabanını bilgisayarınıza indirin. Veritabanı sorgu çalışmalarımızı bu örnek veritabanı üzerindegerçekleştireceğiz. Şimdi mesela biraz önce indirip kurduğunuz Sqlitebrowser programını çalıştırın ve File > Open Database yolunu takip ederek bu kitaplar.sqlite adlı veritabanı dosyasını açın. Eğer Sqlitebrowser programını Sqlite veritabanı dosyaları ile ilişkilendirdiyseniz, kitaplar.sqlite dosyası üzerine çift tıkladığınızda da bu veritabanı dosyası otomatik olarak Sqlitebrowser programı ile açılacaktır. Ayrıca elbette veritabanı dosyası üzerine sağ tıklayıp, ‘Birlikte aç...’ seçeneğinikullanarakdaSqlitebrowserprogramınıçalıştırmayıdeneyebilirsiniz. Sqlitebrowser programını çalıştırıp, kitaplar.sqlite dosyasını da açtıktan sonra, program penceresiüzerindeki‘BrowseData’sekmesinetıklayarakveritabanınıniçindenetürverilerin olduğunu inceleyin. Gördüğünüz gibi, Sqlitebrowser programı, veritabanı içindeki verileri görselleştirmekaçısındanepeykolaylıksağlıyor.BirazdanbuverilerePythonaracılığıylanasıl erişebileceğimizideöğreneceğiz. 966 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.5.5 Yeni Bir Veritabanı Oluşturmak Bu bölümde sqlite adlı bir modül aracılığıyla yeni bir veritabanını nasıl oluşturacağımızı öğreneceğiz. Yukarıdasqliteadlıbirmodüldensözettik.Dolayısıyla,tahminedebileceğinizgibi,bumodülü kullanabilmek için öncelikle modülü içe aktarmamız gerekiyor. Bu bölümün başında da söylediğimizgibi,Sqlite,Python’ın2.5sürümündenbuyanadilinbirparçasıdır: >>> import sqlite3 Python’daSqliteveritabanısistemineaitmodül‘sqlite3’adınıtaşır.Buyüzden,bumodülüiçe aktarmak için import sqlite3 ifadesini kullanmamız gerekiyor. Eğer bu isim size çok uzun geliyorsaveyamodüladındasayılarınveharflerinbirliktebulunmasınedeniylehemsayıhem deharfgirmeyibirangaryaolarakgörüyorsanızelbettesqlite3modülünüfarklıbiradladaiçe aktarabileceğinizibiliyorsunuz.Mesela: >>> import sqlite3 as sql Veya: >>> import sqlite3 as lite Böylece sqlite3 modülünü ‘sql’ veya ‘lite’ adıyla içe aktarmış olduk. Ancak ben konuyu anlatırken, okur açısından kafa karışıklığına sebep olmamak için, modülü import sqlite3 şeklindeiçeaktarmışızgibidavranacağım. Gelelim bu modül yardımıyla nasıl veritabanı oluşturulacağına... Bunun için sqlite3 modülününconnect()adlımetodundanyararlanacağız.Bumetoduşuşekildekullanıyoruz: >>> vt = sqlite3.connect(’veritabanı_adı’) connect() metoduna verdiğimiz varitabanı_adı adlı argüman, kullanacağımız veritabanının adıdır.Eğerbelirtilenisimdebirveritabanısistemdebulunmuyorsaoadlayenibirveritabanı oluşturulacaktır.Mesela: >>> vt = sqlite3.connect(’deneme.sqlite’) Eğer bu komutu verdiğiniz dizin içinde deneme.sqlite adlı bir veritabanı yoksa, bu ada sahip birveritabanıoluşturulacaktır. Bu arada, biz veritabanı dosyasının uzantısı olarak .sqlite’ı seçtik. Ama eğer siz isterseniz kendinize uygun başka bir uzantı da belirleyebilirsiniz. Veritabanı dosyasının uzantısının ne olması gerektiği konusunda kesin kurallar bulunmaz. .sqlite uzantısının yerine, .sqlite3, .db veya .db3 gibi uzantıları tercih edenler de vardır. Hatta eğer siz isterseniz veritabanınızın uzantısını.osmanolarakdahibelirleyebilirsiniz.Bukonudaherhangibirkısıtlamabulunmaz. Yukarıdaki örnekte deneme.sqlite adını verdiğimiz bir veritabanı dosyasına, connect() metodu yardımıyla bağlandık. Elbette isteseydik connect() metoduna argüman olarak tam dosyayoludaverebilirdik: >>> import sqlite3 >>> vt = sqlite3.connect(’/home//test.sqlite’) #GNU/Linux >>> vt = sqlite3.connect(’c:/users/fozgul/desktop/test.sqlite’) #Windows 47.5. SqliteileVeritabanıProgramlama 967 PythonBelgeleri,Yayım4.1.3 Bu komut yardımıyla sabit disk üzerinde bir Sqlite veritabanı dosyası oluşturmuş oluyoruz. Ancakistersenizsqlite3ilegeçicibirveritabanıdaoluşturabilirsiniz: >>> vt = sqlite3.connect(’:memory:’) Oluşturduğunuz bu geçici veritabanı sabit disk üzerinde değil RAM (bellek) üzerinde çalışır. Veritabanını kapattığınız anda da bu geçici veritabanı silinir. Eğer arzu ederseniz, RAM üzerindedeğil,disküzerindedegeçiciveritabanlarıoluşturabilirsiniz.Bununiçindeşöylebir komutkullanıyoruz: >>> vt = sqlite3.connect(’’) Gördüğünüz gibi, disk üzerinde geçici bir veritabanı oluşturmak için boş bir karakter dizisi kullandık. Tıpkı:memory: kullanımında olduğu gibi, boş karakter dizisiyle oluşturulan geçici veritabanlarıdaveritabanıbağlantısınınkesilmesiylebirlikteortadankalkacaktır. Geçici veritabanı oluşturmak, özellikle çeşitli testler veya denemeler yaptığınız durumlarda işinize yarar. Sonradan nasıl olsa sileceğiniz, sırf test amaçlı tuttuğunuz bir veritabanını disk üzerinde oluşturmak yerine RAM üzerinde oluşturmayı tercih edebilirsiniz. Ayrıca, geçici veritabanları sayesinde, yazdığınız bir kodu test ederken bir hatayla karşılaşırsanız sorunun veritabanı içinde varolan verilerden değil, yazdığınız koddan kaynaklandığından da emin olabilirsiniz. Çünkü, dediğimiz gibi, programın her yeniden çalışışında veritabanı baştan oluşturulacaktır. Dikkatinizi çekmek istediğim bir nokta da şudur: Gördüğünüz gibi Sqlite, veritabanını o anda içinde bulunduğunuz dizin içinde oluşturuyor. Mesela MySQL kullanıyor olsaydınız, oluşturulan veritabanlarının önceden tanımlanmış bir dizin içine atıldığını görecektiniz. Örneğin GNU/Linux sistemlerinde, MySQL veritabanları /var/lib/mysql gibi bir dizinin içinde tutulur. 47.5.6 Varolan Bir Veritabanıyla Bağlantı Kurmak Biraz önce, deneme.sqlite adlı yeni bir Sqlite veritabanı oluşturmak için şöyle bir komut kullanmıştık: >>> vt = sqlite3.connect(’deneme.sqlite’) Eğer bu komutu verdiğiniz dizin içinde deneme.sqlite adlı bir veritabanı yoksa, bu ada sahip bir veritabanı oluşturulur. Eğer zaten bu adla bir veritabanı dosyanız varsa, sqlite3 bu veritabanına bağlanacaktır. Dolayısıyla Sqlite’ta hem yeni bir veritabanı oluşturmak hem de mevcutbirveritabanınabağlanmakiçinbirbiriyletamamenaynıkodlarıkullanıyoruz. Mesela biraz önce https://web.archive.org/web/20170511004853/http://www..com/ denemeler/kitaplar.sqliteadresindenindirdiğimizkitaplar.sqliteadlıveritabanınabağlanalım. Bu dosyanın bulunduğu konumda bir Python etkileşimli kabuk oturumu açtığımızı varsayarsak: >>> vt = sqlite3.connect(’kitaplar.sqlite’) komutunukullanarakkitaplar.sqliteadlıveritabanıylabağlantıkurabiliriz. 968 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.5.7 İmleç Oluşturma Yukarıda connect() metodunu kullanarak hem Sqlite ile nasıl veritabanı bağlantısı kuracağımızıhemdenasılyenibirveritabanıoluşturacağımızıöğrendik. connect() metodu, bir veritabanı üzerinde işlem yapabilmemizin ilk adımıdır. Veritabanını oluşturduktan veya varolan bir veritabanı ile bağlantı kurduktan sonra, veritabanı üzerinde işlemyapabilmekiçinsonrakiadımdabirimleçoluşturmamızgerekir. İmleçoluşturmakiçincursor()adlıbirmetottanyararlanacağız: >>> im = vt.cursor() İmleci oluşturduktan sonra artık önümüz iyice açılıyor. Böylece, yukarıda oluşturduğumuz im nesnesinin execute() metodunu kullanarak SQL komutlarını çalıştırabileceğiz. Nasıl mı? Hemenbakalım. 47.5.8 Tablo Oluşturma Önceki bölümün sonunda söylediğimiz gibi, bir imleç nesnesi oluşturduktan sonra bunun execute()metodunukullanarakSQLkomutlarınıişletebiliyoruz. Dilersenizşimdibasitbirörnekyaparakneyinneolduğunuanlamayaçalışalım. Önceliklegereklimodülüiçeaktaralım: >>> import sqlite3 Şimdi de yeni bir veritabanı dosyası oluşturalım (veya varolan bir veritabanı dosyasına bağlanalım): >>> vt = sqlite3.connect(’veritabani.sqlite’) Buveritabanıüzerindeişlemyapabilmekiçinöncelikleimlecimizioluşturalım: >>> im = vt.cursor() Şimdi de yukarıda oluşturduğumuz imlecin execute() adlı metodunu kullanarak veritabanı içindebirtablooluşturalım: >>> im.execute("CREATE TABLE adres_defteri (isim, soyisim)") Hatırlarsanız, Sqlite veritabanı sisteminin tablo benzeri bir yapıya sahip olduğunu ve bu sistemdekihertablonundabirismininbulunduğunusöylemiştik.İşteburadayaptığımızşey, ‘adres_defteri’adlıbirtablooluşturup,butabloya‘isim’ve‘soyisim’adlıikisütuneklemekten ibarettir.Yaniaslındaşöylebirşeyoluşturmuşoluyoruz: tabularytabulary isim soyisim Ayrıcaoluşturduğumuzbutablonunadınında‘adres_defteri’olduğunuunutmuyoruz... 47.5. SqliteileVeritabanıProgramlama 969 PythonBelgeleri,Yayım4.1.3 Bu işlemleri nasıl yaptığımıza dikkat edin. Burada CREATE TABLE adres_defteri (isim, soyisim)tekbirkarakterdizisidir.BukarakterdizisindekiCREATE TABLEkısmıbirSQLkomutu olup,bukomutbirtablooluşturulmasınısağlar. Burada CREATE TABLE ifadesini büyük harflerle yazdık. Ancak bu ifadeyi siz isterseniz küçük harflerledeyazabilirsiniz.BenimburadabüyükharfkullanmaktakiamacımSQLkomutlarının, ‘adres_defteri’, ‘isim’ ve ‘soyisim’ gibi öğelerden görsel olarak ayırt edilebilmesini sağlamak. Yani CREATE TABLE ifadesinin mesela ‘adres_defteri’ öğesinden kolayca ayırt edilebilmesini istediğimiçinburadaCREATE TABLEifadesinibüyükharflerleyazdım. Karakter dizisinin devamında (isim, soyisim) ifadesini görüyoruz. Tahmin edebileceğiniz gibi,bunlartablodakisütunbaşlıklarınınadınıgösteriyor.Bunagöre,oluşturduğumuztabloda ‘isim’ve‘soyisim’adlıikifarklısütunbaşlığıolacak. Bu arada, Sqlite tabloları oluştururken tablo adı ve sütun başlıklarında Türkçe karakter kullanmaktankaçınmakiyibirfikirdir.Ayrıcaeğertabloadıvesütunbaşlıklarındabirdenfazla kelimedenoluşanetiketlerkullanacaksanızbunlarıyabirbirinebitiştirinyadatırnakiçinealın. Örneğin: import sqlite3 vt = sqlite3.connect(’perso.sqlite’) im = vt.cursor() im.execute("""CREATE TABLE ’personel dosyasi’ (’personel ismi’, ’personel soyismi’, memleket)""") Ayrıca,execute()metodunaparametreolarakverilenSQLkomutlarınınaleladebirerkarakter dizisi olduğuna da dikkatinizi çekmek isterim. Bunlar Python’daki karakter dizilerinin bütün özelliklerini taşır. Mesela bu karakter dizisini execute() metoduna göndermeden önce bir değişkeneatayabilirsiniz: import sqlite3 vt = sqlite3.connect(’perso.sqlite’) im = vt.cursor() sql = """CREATE TABLE ’personel dosyasi’ (’personel ismi’, ’personel soyismi’, memleket)""" im.execute(sql) Bu kodları kullanarak oluşturduğunuz perso.sqlite adlı veritabanı dosyasının içeriğini Sqlitebrowserprogramıyardımıylagörüntüleyip,gerçekten‘personelismi’,‘personelsoyismi’ ve‘memleket’sütunlarınınoluşupoluşmadığınıkontroledin. Buarada,bukodlarıikincikezçalıştırdığınızdaşöylebirhatamesajıalacaksınız: sqlite3.OperationalError: table ’personel dosyasi’ already exists Bu hata mesajını almanız gayet normal. Bunun üstesinden nasıl geleceğinizi öğrenmek için okumayadevamedin... 970 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.5.9 Şartlı Tablo Oluşturma CREATE TABLE komutunu kullanarak tablo oluştururken şöyle bir problemle karşılaşmış olabilirsiniz.Diyelimkişukodlarıyazdınız: import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() im.execute("CREATE TABLE personel (isim, soyisim, memleket)") Bu kodları ilk kez çalıştırdığınızda, mevcut dizin altında vt.sqlite adlı bir veritabanı dosyası oluşturulacak ve bu veritabanı içinde ‘isim’, ‘soyisim’ ve ‘memleket’ başlıklı sütunlara sahip, ‘personel’adlıbirtablomeydanagetirilecektir. Ancakaynıkodlarıikincikezçalıştırdığınızdaşöylebirhatamesajıilekarşılaşacaksınız: sqlite3.OperationalError: table personel already exists Buradakisorun,vt.sqlitedosyasıiçinde‘personel’adlıbirtablonunzatenbulunuyorolmasıdır. Bir veritabanı üzerinde işlem yaparken, aynı ada sahip iki tablo oluşturamayız. Bu hatayı önlemek için şartlı tablo oluşturma yönteminden yararlanacağız. Bunun için kullanacağımız SQLkomutuşudur:CREATE TABLE IF NOT EXISTS. Örneğimizibuyenibilgiyegöretekraryazalım: import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() sorgu = """CREATE TABLE IF NOT EXISTS personel (isim, soyisim, memleket)""" im.execute(sorgu) Bu kodları kaç kez çalıştırırsanız çalıştırın, programınız hata vermeden işleyecek; eğer veritabanında ‘personel’ adlı bir tablo yoksa oluşturacak, bu adla zaten bir tablo varsa da sessizceyolunadevamedecektir. 47.5.10 Tabloya Veri Girme Buraya kadar, sqlite3 modülünü kullanarak nasıl bir veritabanı oluşturacağımızı ve çeşitli sütünlardan oluşan bir tabloyu bu veritabanına nasıl yerleştireceğimizi öğrendik. Şimdi de oluşturduğumuzbusütunbaşlıklarınınaltınıdolduracağız. Dikkatlicebakın: import sqlite3 (sonrakisayfayadevam) 47.5. SqliteileVeritabanıProgramlama 971 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() tablo_yap = """CREATE TABLE IF NOT EXISTS personel (isim, soyisim, memleket)""" değer_gir = """INSERT INTO personel VALUES (’Fırat’, ’Özgül’, ’Adana’)""" im.execute(tablo_yap) im.execute(değer_gir) . Uyarı Bu kodları çalıştırdıktan sonra, eğer veritabanının içeriğini Sqlitebrowser ile kontrol ettiyseniz verilerin veritabanına işlenmediğini göreceksiniz. Endişe etmeyin; birazdan bununnedenböyleolduğunuaçıklayacağız. Burada INSERT INTO tablo_adı VALUES adlı yeni bir SQL komutu daha öğreniyoruz. CREATE TABLE ifadesi Türkçe’de “TABLO OLUŞTUR” anlamına geliyor. INSERT INTO ise “... İÇİNE YERLEŞTİR” anlamına gelir. Yukarıdaki karakter dizisi içinde görünen VALUES ise “DEĞERLER” demektir.Yaniaslındayukarıdakikarakterdizisişuanlamagelir:“personelİÇİNE‘Fırat’,‘Özgül’ ve‘Adana’DEĞERLERİNİYERLEŞTİR.Yanişöylebirtablooluştur”: tabularytabulary isim soyisim memleket Fırat Özgül Adana Buraya kadar gayet güzel gidiyoruz. İsterseniz şimdi derin bir nefes alıp, şu ana kadar yaptığımızşeyleribirgözdengeçirelim: • Öncelikle sqlite3 modülünü içe aktardık. Bu modülün nimetlerinden yararlanabilmek için bunu yapmamız gerekiyordu. “sqlite3” kelimesini her defasında yazmak bize angarya gibi gelebileceği için bu modülü farklı bir adla içe aktarmayı tercih edebiliriz. Meselaimport sqlite3 as sqlveyaimport sqlite3 as litegibi... • sqlite3modülünüiçeaktardıktansonrabirveritabanınabağlanmamızveyaelimizdebir veritabanıyoksayenibirveritabanıoluşturmamızgerekiyor.Bununiçinconnect()adlı birfonksiyondanyararlanıyoruz.Bufonksiyonu,sqlite3.connect(’veritabanı_adı’) şeklinde kullanıyoruz. Eğer içinde bulunduğumuz dizinde, “veritabanı_adı” adlı bir veritabanı varsa Sqlite bu veritabanına bağlanır. Eğer bu adda bir veritabanı yoksa, çalışma dizini altında bu ada sahip yeni bir veritabanı oluşturulur. Özellikle deneme amaçlı işlemler yapmamız gerektiğinde, sabit disk üzerinde bir veritabanı oluşturmak yerine RAM üstünde geçici bir veritabanı ile çalışmayı da tercih edebiliriz. Bunun için yukarıdaki komutu şöyle yazıyoruz: sqlite3.connect(’:memory:’). Bu komutla RAM üzerindeoluşturduğumuzveritabanı,bağlantıkesildiğiandaortadankalkacaktır. • Veritabanımızı oluşturduktan veya varolan bir veritabanına bağlandıktan sonra yapmamız gereken şey bir imleç oluşturmak olacaktır. Daha sonra bu imlece ait metotlardan yararlanarak önemli işler yapabileceğiz. Sqlite’ta bir imleç oluşturabilmek 972 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 için db.cursor() gibi bir komut kullanıyoruz. Tabii ben burada oluşturduğunuz veritabanına“db”adınıverdiğinizivarsayıyorum. • İmlecimizi de oluşturduktan sonra önümüz iyice açılmış oldu. Şimdi dir(im) gibi bir komut kullanarak imlecin metotlarının ne olduğunu inceleyebilirsiniz. Tabii ben buradaimlece“im”adınıverdiğinizivarsaydım.Gördüğünüzgibi,listedeexecute()adlı bir metot da var. Artık imlecin bu execute() metodunu kullanarak SQL komutlarını işletebiliriz. • Yukarıda üç adet SQL komutu öğrendik. Bunlardan ilki CREATE TABLE. Bu komut veritabanı içinde bir tablo oluşturmamızı sağlıyor. İkinci komutumuz CREATE TABLE IF NOT EXISTS. Bu komut da bir tabloyu eğer yoksa oluşturmamızı sağlıyor. Üçüncü komutumuz ise INSERT INTO ... VALUES .... Bu komut, oluşturduğumuz tabloya içerik eklememizi sağlıyor. Bunları şuna benzer bir şekilde kullandığımızı hatırlıyorsunuz: im.execute("CREATE TABLE personel (isim, soyisim, memleket)") im.execute("INSERT INTO personel VALUES (’Fırat’, ’Özgül’, ’Adana’)") Burada bir şey dikkatinizi çekmiş olmalı. SQL komutlarını yazmaya başlarken çift tırnakla başladık. Dolayısıyla karakter dizisini yazarken iç taraftaki Fırat, Özgül ve Adana değerlerini yazmak için tek tırnak kullanmamız gerekti. Karakter dizileri içindeki manevra alanınızı genişletmek için, SQL komutlarını üç tırnak içinde yazmayı da tercih edebilirsiniz. Böylece karakterdizisiiçindekitekveçifttırnaklarıdaharahatbirşekildekullanabilirsiniz.Yani: im.execute("""CREATE TABLE personel (isim, soyisim, memleket)""") im.execute("""INSERT INTO personel VALUES ("Fırat", "Özgül", "Adana")""") Ayrıcaüçtırnakkullanmanızsayesinde,uzunsatırlarıgerektiğindebölerekçokdahaokunaklı kodlardayazabileceğinizibiliyorsunuz. 47.5.11 Verilerin Veritabanına İşlenmesi Bir önceki bölümde bir Sqlite veritabanına nasıl veri gireceğimizi öğrendik. Ama aslında iş sadeceverigirmeylebitmiyor.Verileriveritabanına“işleyebilmek”içinbiradımdahaatmamız gerekiyor.Meselaşuörneğebirbakalım: import sqlite3 vt = sqlite3.connect("vt.sqlite") im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS personel (isim, soyisim, sehir, eposta)""") im.execute("""INSERT INTO personel VALUES ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""") Burada öncelikle vt.sqlite adlı bir veritabanı oluşturduk ve bu veritabanına bağlandık. Ardından, vt.cursor() komutuyla imlecimizi de oluşturduktan sonra, SQL komutlarımızı çalıştırıyoruz. Önce isim, soyisim, şehir ve eposta adlı sütunlardan oluşan, “personel” adlı 47.5. SqliteileVeritabanıProgramlama 973 PythonBelgeleri,Yayım4.1.3 bir tablo oluşturduk. Daha sonra “personel” tablosunun içine “Orçun”, “Kunek”, “Adana” ve “okunek@gmail.com”değerleriniyerleştirdik. Ancakhernekadarveritabanınaveriişlemişgibigörünsekdeaslındahenüzişlenmişbirşey yoktur. İsterseniz bu durumu teyit etmek için Sqlitebrowser programını kullanabilir, tabloya verilerinişlenmediğinikendigözlerinizlegörebilirsiniz. Biz henüz sadece verileri girdik. Ama verileri veritabanına işlemedik. Bu girdiğimiz verileri veritabanınaişleyebilmekiçincommit()adlıbirmetottanyararlanacağız: >>> vt.commit() Gördüğünüz gibi, commit() imlecin değil, bağlantı nesnesinin (yani burada vt değişkeninin) birmetodudur.Şimdibusatırıdabetiğimizeekleyelim: import sqlite3 vt = sqlite3.connect("vt.sqlite") im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS personel (isim, soyisim, sehir, eposta)""") im.execute("""INSERT INTO personel VALUES ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""") vt.commit() BusonsatırıdaeklediktensonraSqliteveritabanıiçindeşöylebirtablooluşturmuşolduk: tabularytabulary isim soyisim şehir eposta Orçun Kunek Adana okunek@gmail.com Eğer vt.commit() satırını yazmazsak, veritabanı, tablo ve sütun başlıkları oluşturulur, ama sütunlarıniçeriğiveritabanınaişlenmez. 47.5.12 Veritabanının Kapatılması Bir veritabanı üzerinde yapacağımız bütün işlemleri tamamladıktan sonra, prensip olarak, o veritabanınıkapatmamızgerekir.Meselaşukodlarıelealalım: import sqlite3 vt = sqlite3.connect("vt.sqlite") im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS personel (isim, soyisim, sehir, eposta)""") (sonrakisayfayadevam) 974 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) im.execute("""INSERT INTO personel VALUES ("Orçun", "Kunek", "Adana", "okunek@gmail.com")""") vt.commit() vt.close() Buradabütünişlemleribitirdiktensonraveritabanınıkapatmakiçin,close()adlıbirmetottan yararlandık: vt.close() Bu şekilde, veritabanının ilk açıldığı andan itibaren, işletim sisteminin devreye soktuğu kaynakları serbest bırakmış oluyoruz. Esasında programımız kapandığında, açık olan bütün Sqliteveritabanlarıdaotomatikolarakkapanır.Amayinedebuişlemielleyapmakherzaman iyibirfikirdir. 47.5.13 Bağlam Yöneticisi Kullanımı Python’dabağlamyönetecisi(contextmanager)oluşturmakiçinwithdeyimikullanılır.Python withdeyiminikullanarakSqliteileişlemyaparkenbiristisnailekarşılaşırsayapılanişlemlerin otomatik olarak geri alınmasını sağlar. Eğer işlem sorunsuz gerçekleşirse herhangi bir etki yaratmaz.Aşağıdaörnekkodabakalım: import sqlite3 con = sqlite3.connect(":memory:") con.execute("CREATE TABLE personel(id INTEGER PRIMARY KEY, isim VARCHAR UNIQUE) ") ˓→ # Başarılı şekilde, con.commit() çalıştırılır. with con: con.execute("INSERT INTO personel(isim) VALUES(?)", ("Fırat",)) # Hata yakalanınca con.rollback() otomatik olarak çağırılır ve işlemler geri␣ alınır. ˓→ try: with con: con.execute("INSERT INTO personel(isim) VALUES(?)", ("Fırat",)) except sqlite3.IntegrityError: print("Aynı ismi iki defa ekleyemezsiniz!") # Bağlam yöneticisi olarak kullanılan bağlantı nesnesi yalnızca işlemleri␣ gerçekleştirir ˓→ # veya geri alır, bu nedenle bağlantı nesnesi manuel olarak kapatılmalıdır. con.close() Not: Bağlam yöneticisi ne dolaylı olarak yeni bir işlem açar ne de bağlantıyı kapatır. Kısaca işlemsonundabağlantıyıkapatmanızgerekir. 47.5. SqliteileVeritabanıProgramlama 975 PythonBelgeleri,Yayım4.1.3 47.5.14 Parametreli Sorgular Şuanakadarverdiğimizörneklerde,veritabanınagirilecekverileritektekelleyerinekoyduk. Örneğin: im.execute("""INSERT INTO personel VALUES (’Fırat’, ’Özgül’, ’Adana’)""") Ancak çoğu durumda veritabanına girilecek veriler harici kaynaklardan gelecektir. Basit bir örnekverelim: import sqlite3 with sqlite3.connect(’vt.sqlite’) as vt: im = vt.cursor() veriler = [(’Fırat’, ’Özgül’, ’Adana’), (’Ahmet’, ’Söz’, ’Bolvadin’), (’Veli’, ’Göz’, ’İskenderun’), (’Mehmet’, ’Öz’, ’Kilis’)] im.execute("""CREATE TABLE IF NOT EXISTS personel (isim, soyisim, memleket)""") for veri in veriler: im.execute("""INSERT INTO personel VALUES (?, ?, ?)""", veri) vt.commit() Buradaveritabanınaişlenecekveriler,verileradlıbirdeğişkendengeliyor.Budeğişkeniçindeki verileriveritabanınanasılyerleştirdiğimizedikkatedin: for veri in veriler: im.execute("""INSERT INTO personel VALUES (?, ?, ?)""", veri) Ayrıca her bir sütunun (‘isim’, ‘soyisim’, ‘memleket’) altına gelecek her bir değer için (mesela sırasıyla‘Fırat’,‘Özgül’,‘Adana’)biradet‘?’işaretiyerleştirdiğimizidegözdenkaçırmayın. 47.5.15 Tablodaki Verileri Seçmek Yukarıda,birveritabanınanasılverigireceğimizivebuverileriveritabanınanasılişleyeceğimizi gördük. İşin asıl önemli kısmı, bu verileri daha sonra veritabanından (yani tablodan) geri alabilmektir.Şimdibuişleminasılyapacağımızabakalım. Veritabanından herhangi bir veri alabilmek için ilk olarak SELECT veri FROM tablo_adı adlı birSQLkomutundanyararlanarakilgiliverileriseçmemizgerekiyor. Dilersenizöncebirtablooluşturalım: 976 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS faturalar (fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""") Şimdibutabloyabazıverilerekleyelim: im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") Verileriveritabanınaişleyelim: vt.commit() Yukarıdakikodlarbizeşöylebirtabloverdi: tabularytabulary fatura miktar ilk_odeme_tarihi son_odeme_tarihi Elektrik 45 23Ocak2010 30Ocak2010 Buraya kadar olan kısmı zaten biliyoruz. Bilmediğimiz ise bu veritabanından nasıl veri alacağımız.Onudaşöyleyapıyoruz: im.execute("""SELECT * FROM faturalar""") Burada özel bir SQL komutu olan SELECT veri FROM tablo_adı komutundan faydalandık. Burada joker karakterlerden biri olan “*” işaretini kullandığımıza dikkat edin.SELECT * FROM faturalarifadesişuanlamagelir:“faturalaradlıtablodakibütünöğeleriseç!” Burada “SELECT” kelimesi “SEÇMEK” demektir. “FROM” ise “...DEN/...DAN” anlamı verir. Yani “SELECT FROM faturalar” dediğimizde “faturalardan seç” demiş oluyoruz. Burada kullandığımız“*”işaretide“her şey”anlamına geldiğiiçin,“SELECT*FROMfaturalar”ifadesi “faturalardanherşeyiseç”gibibiranlamagelmişoluyor. Verileri seçtiğimize göre, artık seçtiğimiz bu verileri nasıl alacağımıza bakabiliriz. Bunun için de fetchone(), fetchall() veya fetchmany() adlı metotlardan ya da for döngüsünden yararlanacağız. 47.5. SqliteileVeritabanıProgramlama 977 PythonBelgeleri,Yayım4.1.3 47.5.16 Seçilen Verileri Almak Bu bölümde, SELECT sorgusu ile veritabanından seçtiğimiz verileri farklı yollarla nasıl çekebileceğimizi/alabileceğimiziinceleyeceğiz. fetchall()Metodu Birazönceşöylebirprogramyazmıştık: import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS faturalar (fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""") im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") vt.commit() im.execute("""SELECT * FROM faturalar""") Burada vt.sqlite adlı bir veritabanında ‘faturalar’ adlı bir tablo oluşturduk ve bu tabloya bazı veriler girdik. Daha sonra da SELECT adlı SQL komutu yardımıyla bu verileri seçtik. Şimdi de seçtiğimizbuverileriveritabanındanalacağız. Yukarıdakiprogramaşusatırıekliyoruz: veriler = im.fetchall() Burada da ilk defa gördüğümüz bir metot var: fetchall(). Gördüğünüz gibi, fetchall() imlecin bir metodudur. Yukarıda gördüğümüz SELECT * FROM faturalar komutu ‘faturalar’ adlı tablodaki bütün verileri seçiyordu. fetchall() metodu ise seçilen bu verileri alma işlevi görüyor. Yukarıda biz fetchall() metoduyla aldığımız bütün verileri veriler adlı bir değişkeneatadık. Artıkbuverilerirahatlıklayazdırabiliriz: print(veriler) Dilersenizbetiğimizitoplucagörelim: import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS faturalar (sonrakisayfayadevam) 978 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) (fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""") im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") vt.commit() im.execute("""SELECT * FROM faturalar""") veriler = im.fetchall() print(veriler) Bubetiğiilkkezçalıştırdığımızdaşöylebirçıktıalırız: [(’Elektrik’, 45, ’23 Ocak 2010’, ’30 Ocak 2010’)] Gördüğünüz gibi, veriler bir liste içinde demet halinde yer alıyor. Ama tabii siz bu verileri istediğiz gibi biçimlendirecek kadar Python bilgisine sahipsiniz. Ayrıca programı her çalıştırdığınızda INSERT INTO sorgusu tekrar işletileceği için verilerin tabloya tekrar tekrar yazılacağını, bu verileri alırken de çıktı listesinin büyüyeceğini unutmayın. Peki eğer siz bir veritabanı dosyasına verilerin yalnızca bir kez yazılmasını istiyorsanız ne yapacaksınız? Yani meselayukarıdakikodlardaşusorguyalnızcatekbirkezişletilsin: im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") Böylece veritabanını her çalıştırdığınızda ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")satırıdosyayatekrartekraryazdırılmasın. Bunuşukodlarlahalledebilirsiniz: import sqlite3, os dosya = ’vt.sqlite’ dosya_mevcut = os.path.exists(dosya) vt = sqlite3.connect(dosya) im = vt.cursor() im.execute("""CREATE TABLE IF NOT EXISTS faturalar (fatura, miktar, ilk_odeme_tarihi, son_odeme_tarihi)""") if not dosya_mevcut: im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") vt.commit() im.execute("""SELECT * FROM faturalar""") (sonrakisayfayadevam) 47.5. SqliteileVeritabanıProgramlama 979 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) veriler = im.fetchall() print(veriler) Buradakodlarımızınenbaşındavt.sqliteadlıbirveritabanınınmevcutolupolmadığınıkontrol ediyoruz(ziraeğerortadabirveritabanıdosyasıyoksa,verideyokdemektir): dosya_mevcut = os.path.exists(dosya) Eğer böyle bir dosya mevcut değilse (dolayısıyla veri mevcut değilse) INSERT INTO sorgusu işletilerekgerekliverileryerineyerleştirilecek: if not dosya_mevcut: im.execute("""INSERT INTO faturalar VALUES ("Elektrik", 45, "23 Ocak 2010", "30 Ocak 2010")""") vt.commit() Eğerböylebirdosyazatenmevcutsabusorguişletilemeyecek,onunyerinedoğrudanSELECT sorgusuna geçilecek. Böylece değerler veritabanına bir kez işlendikten sonra, programımız aynıverileritekrartekrarveritabanınayerleştirmeyeçalışmayacak. Buarada,dahaöncedebelirttiğimizgibi,tablooluştururkensütunadlarındaboşluk(veTürkçe karakter) kullanmak iyi bir fikir değildir. Mesela ilk ödeme tarihi yerine ilk_odeme_tarihi ifadesini tercih edin. Eğer kelimeler arasında mutlaka boşluk bırakmak isterseniz bütün kelimeleritırnakiçinealın.Mesela:"ilk odeme tarihi"veya"ilk ödeme tarihi"gibi. Yukarıdagördüğünüzgibi,fetchall()metodu,birveritabanındanSELECTileseçtiğimizbütün verileri önümüze getiriyor. Eğer seçilen verilerden kaç tanesini almak istediğinizi kendiniz belirlemekistiyorsanızfetchall()yerinefetchone()veyafetchmany()metotlarındanoanki amacınızauygunolanınıkullanmayıtercihedebilirsiniz.Birazdanfetchone()vefetchmany() metotlarındandasözedeceğiz. Gelin isterseniz şimdi fetchall() metodunu kullanarak veritabanlarından veri çekme konusunda biraz alıştırma yapalım. Bu alıştırmalar için, daha önce söz ettiğimiz ve bilgisayarımızaindirdiğimizkitaplar.sqliteadlıörnekveritabanınıkullanacağız. Öncelikleveritabanınabağlanalımvebirimleçoluşturalım: >>> import sqlite3 >>> vt = sqlite3.connect(’kitaplar.sqlite’) >>> im = vt.cursor() Şimdi bu veritabanındaki tabloyu seçeceğiz. Peki ama seçeceğimiz tablonun adını nereden bileceğiz? Hatırlarsanız, bir tablodaki bütün verileri seçebilmek için şu SQL sorgusunu kullanıyorduk: "SELECT * FROM tablo_adı" İşte bu sorguda ‘tablo_adı’ kısmına ne geleceğini bulabilmek için birkaç farklı yöntemden yararlanabiliriz. Bir veritabanında hangi tabloların olduğunu öğrenmek için Sqlitebrowser programını kullanabiliriz. Bir veritabanı dosyasını Sqlitebrowser ile açtıktan sonra, ‘Browse Data’ sekmesinegidip,‘Table’ifadesininkarşısındaneyazdığınabakabiliriz. 980 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Veritabanındakitablolarınadınıöğrenmeninikinciyoluşukomutlarıkullanmaktır: >>> import sqlite3 >>> vt = sqlite3.connect(’kitaplar.sqlite’) >>> im = vt.cursor() >>> im.execute("SELECT name FROM sqlite_master") >>> im.fetchall() Buradaşusatıradikkatedin: >>> im.execute("SELECT name FROM sqlite_master") Bütün Sqlite veritabanlarında, ilgili veritabanının şemasını gösteren ‘sqlite_master’ adlı bir tablo bulunur. İşte bu tabloyu sorgulayarak veritabanı hakkında bilgi edinebiliriz. Yukarıdaki örnekte, bu ‘sqlite_master’ tablosunun ‘name’ (isim) niteliğini sorguladık. Bu sorgu bize şu cevabıverdi: >>> im.fetchall() [(’kitaplar’,)] Demekkikitaplar.sqliteadlıveritabanında‘kitaplar’adlıtekbirtablovarmış. Gelinşimdibubutablodakibütünverilerialalım: >>> im.execute("SELECT * FROM kitaplar") >>> im.fetchall() Bu şekilde tablo içinde ne kadar veri varsa hepsini ekrana yazdırdık. Ancak tabii ki, bir veritabanının tamamını bir anda yazdırmak her zaman iyi bir fikir olmayabilir. Eğer veritabanının içinde milyonlarca girdi varsa bütün verilerin seçilip yazdırılması mantıklı olmayacaktır. Gelin o halde şimdi bizim seçilen verilerin ne kadarını çekeceğimizi belirleyebilmemizisağlayacakmetotlarıinceleyelim. fetchone()Metodu fetchone()metodu,birveritabanındanseçilenverilerintektekalınabilmesineizinverir. Bu metodun nasıl kullanılacağını ‘kitaplar.sqlite’ adlı örnek veritabanımız üzerinden inceleyelim: Önceveritabanınabağlanalım: >>> import sqlite3 >>> vt = sqlite3.connect(’kitaplar.sqlite’) >>> im = vt.cursor() Şimdi‘kitaplar’adlıtablodanbütünverileriseçelim: >>> im.execute("""SELECT * FROM kitaplar""") <sqlite3.Cursor object at 0x003C2D20> Artıkseçtiğimizverileritektekalmayabaşlayabiliriz: 47.5. SqliteileVeritabanıProgramlama 981 PythonBelgeleri,Yayım4.1.3 >>> im.fetchone() (’UZMANLAR İÇİN PHP’, ’Mehmet Şamlı’, ’33,00 TL’) Birtanedahaalalım: >>> im.fetchone() (’ADOBE AİR’, ’Engin Yöğen’, ’28,00 TL’) İkitanedaha... >>> im.fetchone() (’WEB TASARIM REHBERİ’, ’Mustafa Aydemir’, ’38,50 TL’) >>> im.fetchone() (’ORACLE 11g R2’, ’Teoman Dinçel’, ’34,00 TL’) fetchone()’ıngayetfaydalıbirmetotolduğuherhalindenbelli... fetchmany()Metodu Bumetot,birveritabanındanseçtiğinizverilerinistediğinizkadarınıalabilmenizeimkantanır. Dikkatlicebakın: >>> im.fetchmany(5) [(’AS 3.0 İLE SUNUCU PROGRAMLAMA’, ’Engin Yöğen’, ’24,00 TL’), (’HACKING INTERFACE’, ’Hamza Elbahadır’, ’25,00 TL’), (’JAVA VE JAVA TEKNOLOJİLERİ’, ’Tevfik Kızılören’, ’45,00 TL’), (’XML VE İLERİ XML TEKNOLOJİLERİ’, ’Musa Çiçek’, ’24,50 TL’), (’GRAFİK&ANİMASYON’, ’Anonim’, ’18,50 TL’)] Gördüğünüzgibi,beşöğedenoluşanbirlisteeldeettik. Böylece bir veritabanından seçilen verileri almanın farklı yöntemlerini öğrenmiş olduk. Bu metotların dışında, eğer arzu ederseniz for döngüsünden yararlanarak da veri çekebilirsiniz. Bununiçinherhangibirmetotkullanmanızagerekyok: >>> for veri in im: ... print(veri) Gördüğünüzgibi,fordöngüsünüdoğrudanimleçüzerindekuruyoruz. Eğer amacınız alınacak verilerin sayısını sınırlamaksa yine for döngüsünden ve fetchone() metodundanbirlikteyararlanabilirsiniz: >>> for i in range(5): ... print(im.fetchone()) 982 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Biraz sonra veri süzmeyi öğrendiğimizde, bir veritabanından veri seçip almanın daha verimli yollarınıgöreceğiz. 47.5.17 Veri Süzme Daha önce bir Sqlite veritabanında belli bir tablo içindeki bütün verileri seçmek için şu SQL komutunukullanmamızgerektiğiniöğrenmiştik: SELECT * FROM tablo_adi Ancak amacımız çoğu zaman bir tablo içindeki bütün verileri seçmek olmayacaktır. Programcılık maceramız boyunca genellikle yalnızca belli ölçütlere uyan verileri seçmek isteyeceğiz. Zira içinde milyonlarca veri barındırabilecek olan veritabanlarındaki verilerin tamamınıseçmekakılkârıdeğildir. Verileri süzme işini WHERE adlı bir SQL komutu yardımıyla gerçekleştireceğiz. Bu SQL komutununsözdizimişöyle: SELECT * FROM tablo_adı WHERE sütun_başlığı = aranan_veri Gördüğünüz gibi, bu sorguyu gerçekleştirebilmek için tablodaki sütun başlıklarını bilmemiz gerekiyor. Önceki sayfalarda, kitaplar.sqlite adlı veritabanımızdaki tabloların adını nasıl öğrenebileceğimizianlatmıştık.Hatırlarsanızbuişiçinşukomutukullanıyorduk: >>> im.execute("SELECT name FROM sqlite_master") Buşekilde,bütünSqliteveritabanlarındabulunan‘sqlite_master’adlıözelbirtablonun‘name’ niteliğini sorgulayarak, elimizdeki veritabanında bulunan tabloların adını elde edebiliyoruz. Adınıöğrendiğimiztablodakisütunbaşlıklarınıeldeetmekiçinyinebunabenzerbirkomuttan yararlanacağız.Dikkatlicebakın: >>> im.execute("SELECT sql FROM sqlite_master").fetchone() (’CREATE TABLE "kitaplar" (\n\t‘KitapAdi‘\tTEXT,\n\t‘Yazar‘\tTEXT,\n\t‘Fiyati‘\tTEXT\n)’,) ‘sqlite_master’ adlı tablonun ‘sql’ niteliğini sorguladığımızda, ilgili tabloyu oluşturmak için kullanılan SQL komutunu görüyoruz. Bu komuta dikkatli bakarsanız, tablonun ‘KitapAdi’, ‘Yazar’ ve ‘Fiyati’ olmak üzere üç sütundan oluştuğunu göreceksiniz. Elbette sütun adlarını öğrenmekiçinSqlitebrowserprogramınıdakullanabileceğiniziartıkbiliyorsunuz. Sütun adlarını öğrendiğimize göre gelin şimdi yazar adına göre veritabanında bir sorgu yapalım: >>> im.execute("SELECT * FROM kitaplar WHERE Yazar = ’Fırat Özgül’") Burada sorguyu nasıl kurduğumuza dikkat edin. Bu sorgunun ilk kısmı olan SELECT * FROM kitaplar ifadesini zaten daha önce öğrenmiştik. Yeni olan kısım WHERE Yazar = ’Fırat Özgül’. Burada da anlaşılmayacak bir şey yok. Bu şekilde, veritabanındaki ‘kitaplar’ tablosunun‘Yazar’sütununda‘FıratÖzgül’bulunanbütünkayıtlarıseçiyoruz. Şimdideseçtiğimizbuverilerialalım: 47.5. SqliteileVeritabanıProgramlama 983 PythonBelgeleri,Yayım4.1.3 >>> im.fetchall() (’HERYÖNÜYLE PYTHON’, ’Fırat Özgül’, ’34,00 TL’) Gayet başarılı... Bu arada, verileri almak için fetchall() yerine for döngüsü kullanabileceğinizidebiliyorsunuz: >>> for s in im: ... print(s) ... (’HERYÖNÜYLE PYTHON’, ’Fırat Özgül’, ’34,00 TL’) İmleç üzerinde for döngüsü kurabildiğimize göre yıldızlı parametrelerden de yararlanabileceğimizitahminetmişsinizdir: >>> print(*im) (’HERYÖNÜYLE PYTHON’, ’Fırat Özgül’, ’34,00 TL’) 47.5.18 Veritabanı Güvenliği Python’da veritabanları ve Sqlite konusunda daha fazla ilerlemeden önce çok önemli bir konudan bahsetmemiz gerekiyor. Tahmin edebileceğiniz gibi, veritabanı denen şey oldukça hassas bir konudur. Bilgiyi bir araya toplayan bu sistem, içerdeki bilgilerin değerine ve öneminedebağlıolaraküçüncüşahıslarıniştahınıkabartabilir.Ancakdepoladığınızverilerin ne kadar değerli ve önemli olduğundan bağımsız olarak veritabanı güvenliğini sağlamak, siz programcılarınasligörevidir. Pekiveritabanıyönetimsistemleriacabahangitehditlerlekarşıkarşıya? SQL komutlarını işleten bütün veritabanları için günümüzdeki en büyük tehditlerden birisi hiç kuşkusuz kötü niyetli kişilerin veritabanınıza SQL komutu sızdırma (SQL injection) girişimleridir. Şimdi şöyle bir şey düşünün: Diyelim ki siz bir alışveriş karşılığı birine 100.000 TL’lik bir çek verdiniz.Ancakçekiverdiğinizkişibuçeküzerindekimiktarıtahrifederekartırdıvebankada tahrifedilerekartırılanbumiktarıçekigetirenkişiye(hamiline)ödedi.Böylebirdurumdaepey başınızağrıyacaktır. İşteböyletatsızbirdurumlakarşılaşmamakiçin,çekverenkişiçekinüzerindekimiktarıhem rakamlahemdeyazıylabelirtmeyeözengösterir.Ayrıcarakamveyazılaraeklemeyapılmasını da engellemek için rakam ve yazıların sağına soluna “#” gibi işaretler de koyar. Böylece çeki alankişinin,kendisineizinverilendendahafazlabirmiktarıyazmasınıengellemeyeçalışır. Yukarıdakine benzer bir şey veritabanı uygulamalarında da karşımıza çıkabilir. Şimdi şu örneğebakalım: import sqlite3 #vt.sqlite adlı bir veritabanı dosyası oluşturup #bu veritabanına bağlanıyoruz. db = sqlite3.connect("vt.sqlite") (sonrakisayfayadevam) 984 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) #Veritabanı üzerinde istediğimiz işlemleri yapabilmek #için bir imleç oluşturmamız gerekiyor. im = db.cursor() #imlecin execute() metodunu kullanarak, veritabanı içinde #"kullanicilar" adlı bir tablo oluşturuyoruz. Bu tabloda #kullanıcı_adi ve parola olmak üzere iki farklı sütun var. im.execute("""CREATE TABLE IF NOT EXISTS kullanicilar (kullanici_adi, parola)""") #Yukarıda oluşturduğumuz tabloya yerleştireceğimiz verileri #hazırlıyoruz. Verilerin liste içinde birer demet olarak #nasıl gösterildiğine özellikle dikkat ediyoruz. veriler = [ ("ahmet123", "12345678"), ("mehmet321", "87654321"), ("selin456", "123123123") ] #veriler adlı liste içindeki bütün verileri kullanicilar adlı #tabloya yerleştiriyoruz. Burada tek öğeli bir demet #tanımladığımıza dikkat edin: (i,) for i in veriler: im.execute("""INSERT INTO kullanicilar VALUES %s""" %(i,)) #Yaptığımız değişikliklerin tabloya işlenebilmesi için #commit() metodunu kullanıyoruz. db.commit() #Kullanıcıdan kullanıcı adı ve parola bilgilerini alıyoruz... kull = input("Kullanıcı adınız: ") paro = input("Parolanız: ") #Burada yine bir SQL komutu işletiyoruz. Bu komut, kullanicilar #adlı tabloda yer alan kullanici_adi ve parola adlı sütunlardaki #bilgileri seçiyor. im.execute("""SELECT * FROM kullanicilar WHERE kullanici_adi = ’%s’ AND parola = ’%s’"""%(kull, paro)) #Hatırlarsanız daha önce fetchall() adlı bir metottan #söz etmiştik. İşte bu fetchone() metodu da ona benzer. #fetchall() bütün verileri alıyordu, fetchone() ise #verileri tek tek alır. data = im.fetchone() #Eğer data adlı değişken False değilse, yani bu #değişkenin içinde bir değer varsa kullanıcı adı #ve parola doğru demektir. Kullanıcıyı içeri alıyoruz. (sonrakisayfayadevam) 47.5. SqliteileVeritabanıProgramlama 985 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if data: print("Programa hoşgeldin {}!".format(data[0])) #Aksi halde kullanıcıya olumsuz bir mesaj veriyoruz. else: print("Parola veya kullanıcı adı yanlış!") Buörnektehenüzbilmediğimizbazıkısımlarvar.Amasizşimdilikbunlarıkafanızatakmayın. Nasıl olsa bu kodlarda görünen her şeyi biraz sonra tek tek öğreneceğiz. Siz şimdilik sadece işinözüneodaklanın. Yukarıdaki kodları çalıştırdığınızda, eğer kullanıcı adı ve parolayı doğru girerseniz ‘Programa hoşgeldin’çıktısınıgöreceksiniz.Eğerkullanıcıadınızveyaparolanızyanlışsabununlailgilibir uyarıalacaksınız. Herşeyiyihoş,amabukodlardaçokciddibirproblemvar. Dediğimizgibi,bukodlarçalışırken(teoride)eğerkullanıcı,veritabanındavarolanbirkullanıcı adı ve parola yazarsa sisteme kabul edilecektir. Eğer doğru kullanıcı adı ve parola girilmezse sistemkullanıcıyagirişiznivermeyecektir.Amaacabagerçektenöylemi? Şimdi yukarıdaki programı tekrar çalıştırın. Kullanıcı adı ve parola sorulduğunda da her ikisi içinşunuyazın: x’ OR ’1’ = ’1 Odane!Programsiziiçerialdı... Hemdekullanıcıadıveparoladoğruolmadığıhalde... Hatta şukodusadecekullanıcıadıkısmınagiripparolakısmınıboşbırakmanızdasistemegirişhakkı eldeetmenizeyetecektir.: x’ OR ’1’ = ’1’ -- İşte yukarıda gösterdiğimiz bu işleme “SQL sızdırma” (SQL injection) adı verilir. Kullanıcı, tıpkı en başta verdiğimiz tahrif edilmiş çek örneğinde olduğu gibi, sistemin zaaflarından yararlanarak,eldeetmeyehakkıolandandahafazlasınaerişimhakkıeldeediyor. Buradaenbasitşekliyleboolişleçlerindenbiriolanor’danyararlanıyoruz.or’unnasılişlediğini gayetiyibiliyorsunuz,amabenyinedebirkaçörnekleor’unneolduğunuveneyaptığınısize hatırlatayım.Şuörneklerebakın: >>> a = 21 >>> a == 22 False >>> b = 13 >>> b == 13 True (sonrakisayfayadevam) 986 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) >>> if a == 22 and b == 13: ... print("Merhaba!") ... >>> if a == 22 or b == 13: ... print("Merhaba!") ... Merhaba! Örneklerden de gördüğünüz gibi, and işlecinin True sonucunu verebilmesi için her iki önermenin de doğru olması gerekir. O yüzden a == 22 and b == 13 gibi bir ifade False değeri veriyor. Ancak or işlecinin True sonucu verebilmesi için iki önermeden sadece birinin doğru olması yeterlidir. Bu yüzden, sadece b == 13 kısmı True olduğu halde a == 22 or b == 13ifadesiTruesonucuveriyor... İştebizdeyukarıdakiSQLsızdırmagirişimindeor’unbu özelliğindenfaydalanıyoruz. Dilerseniznelerolupbittiğinidahaiyianlayabilmekiçin,sızdırılankodudoğrudanilgilisatıra uygulayalım: im.execute("""SELECT * FROM kullanicilar WHERE kullanici_adi = ’x’ OR ’1’ = ’1’ AND parola = ’x’ OR ’1’ = ’1’""") Sanırımbuşekildenelerolupbittiğidahanetgörülüyor.Durumubirazdahanetleştirmekiçin Python’ıyardımaçağırabiliriz: >>> kullanici_adi = ’ahmet123’ >>> parola = ’12345678’ >>> kullanici_adi == ’x’ False >>> ’1’ == ’1’ True >>> kullanici_adi == ’x’ or ’1’ == ’1’ True >>> parola == ’x’ False >>> (kullanici_adi == ’x’ or ’1’ == ’1’) and (parola == ’x’ or ’1’ == ’1’) True ’1’ == ’1’ifadesiherzamanTruedeğeriverecektir.Dolayısıylakullanıcıadınınveparolanın doğruolupolmamasıhiçbirönemtaşımaz.YaniherzamanTruedeğerinivereceğikesinolan 47.5. SqliteileVeritabanıProgramlama 987 PythonBelgeleri,Yayım4.1.3 ifadeleryardımıylayukarıdakigibibirsızdırmagirişimindebulunabilirsiniz. Yukarıda yaptığımız şey, ‘%s’ ile gösterilen yerlere kötü niyetli bir SQL komutu sızdırmaktan ibarettir. Burada zaten başlangıç ve bitiş tırnakları olduğu için sızdırılan kodda başlangıç ve bitiştırnaklarınıyazmıyoruz.Oyüzdensızdırılankodşöylegörünüyor: x’ OR ’1’ = ’1 Gördüğünüzgibi,x’inbaşındakive1’insonundakitırnakişaretlerikoymuyoruz. Pekiyukarıdaverdiğimizşukodnasılçalışıyor: x’ OR ’1’ = ’1’ -- Python’da yazdığımız kodlara yorum eklemek için “#” işaretinden yararlandığımızı biliyorsunuz. İşte SQL kodlarına yorum eklemek için de “–” işaretlerinden yararlanılır. Şimdidilersenizyukarıdakikodudoğrudanilgilisatırauygulayalımveneolduğunugörelim: im.execute("""SELECT * FROM kullanicilar WHERE kullanici_adi = ’x’ OR ’1’=’1’ --AND parola = ’%s’""") Burada yazdığımız “–” işareti AND parola = ’%s’ kısmının sistem tarafından yorum olarak algılanmasını sağlıyor. Bu yüzden kodların bu kısmı işletilmiyor. Dolayısıyla da sisteme giriş yapabilmek için sadece kullanıcı adını girmemiz yeterli oluyor. Burada ayrıca kodlarımızın çalışmasıiçin1’insonunabiradettırnakyerleştirerekkodukapattığımızadikkatedin.Çünkü normalbitiştırnağıyorumtarafındakaldı. DikkatedersenizSQLsızdırdığımızda“ahmet123”adlıkullanıcınınhesabınıelegeçirmişolduk. Peki neden ötekiler değil de “ahmet123”? Bunun sebebi, “ahmet123” hesabının tablonun en başındayeralması.Eğertablonunbaşında“admin”diyebirhesapolmuşolsaydı,veritabanına azamidüzeydezararvermeimkanınakavuşacaktınız. Peki SQL sızdırma girişimlerini nasıl önleyeceğiz? Bu girişime karşı alabileceğiniz başlıca önlem “%s” işaretlerini kullanmaktan kaçınmak olacaktır. Bu işaret yerine “?” işaretini kullanacaksınız.Yaniyukarıdakiprogramışöyleyazacağız: import sqlite3 db = sqlite3.connect("vt.sqlite") im = db.cursor() im.execute("""CREATE TABLE IF NOT EXISTS kullanicilar (kullanici_adi, parola)""") veriler = [ ("ahmet123", "12345678"), ("mehmet321", "87654321"), ("selin456", "123123123") ] for i in veriler: im.execute("""INSERT INTO kullanicilar VALUES (?, ?)""", i) (sonrakisayfayadevam) 988 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) db.commit() kull = input("Kullanıcı adınız: ") paro = input("Parolanız: ") im.execute("""SELECT * FROM kullanicilar WHERE kullanici_adi = ? AND parola = ?""", (kull, paro)) data = im.fetchone() if data: print("Programa hoşgeldin {}!".format(data[0])) else: print("Parola veya kullanıcı adı yanlış!") Dediğimiz gibi, SQL sızdırma girişimlerine karşı alabileceğiniz başlıca önlem “%s” işaretleri yerine “?” işaretini kullanmak olmalıdır. Bunun dışında, SQL komutlarını işletmeden önce bazı süzgeçler uygulamak da güvenlik açısından işinize yarayabilir. Örneğin kullanıcıdan alınacak verileri alfanümerik karakterlerle [http://www..com/blog/alfanumerik-ne-demek.html/34](arşivlinki)sınırlayabilirsiniz: if kull.isalnum() and paro.isalnum(): im.execute("""SELECT * FROM kullanicilar WHERE kullanici_adi = ’%s’ AND parola = ’%s’"""%(kull, paro)) Böylecekullanıcınınbazı“tehlikeli”karakterlerigirmesiniengelleyebilir,onlarısadeceharfve sayıgirmeyezorlayabilirsiniz. Her halükarda unutmamamız gereken şey, güvenliğin çok boyutlu bir kavram olduğudur. Birkaç önlemle pek çok güvenlik açığını engelleyebilirsiniz, ancak bütün güvenlik açıklarını bir çırpıda yamamak pek mümkün değildir. Bir programcı olarak sizin göreviniz, yazdığınız programlarıgüvenlikaçıklarınakarşısüreklitaramakveherhangibiraçıkortayaçıktığındada bunuderhalkapatmayaçalışmaktır. 47.5.19 Bölüm Soruları 1. Birveritabanıdosyasınınvarolupolmadığınınasıltespitedersiniz? 2. Bir veritabanı içinde belli bir tablonun var olup olmadığını tespit edin. Eğer yoksa o tabloyuoluşturun,varsaherhangibirişlemyapmayın. 3. Sqliteiletestamaçlıbirveritabanıoluşturun.Buveritabanıdosyası,programınızkapanır kapanmazortadankaybolmalı. 4. Aşağıdaki kodların istenen veritabanını, tabloyu, satır ve sütunları oluşturup oluşturmadığınıteyitedin: 34https://web.archive.org/web/20161127183825/http://www..com/blog/alfanumerik-ne-demek.html 47.5. SqliteileVeritabanıProgramlama 989 PythonBelgeleri,Yayım4.1.3 import sqlite3 vt = sqlite3.connect(’vt.sqlite’) im = vt.cursor() im.execute("CREATE TABLE kullanıcılar (ad, soyad, doğumtarihi, eposta)") vt.commit() vt.close() Eğerveritabanıiçeriğibeklediğinizgibideğilsesebebiniaçıklayın. 5. Sqliteilebirveritabanınınoluşturulmasıvebuveritabanınabirtakımbilgilergirilebilmesi içinsırasıylahangiişlemlerinyapılmasıgerekir? 6. Aşağıdakiresimdeyapılmayaçalışılanşeynedir? 7. sqlite3.connect(’kitaplar.sqlite’)boşbirveritabanınınmıoluşturulduğunuyoksa varolan kitaplar.sqlite adlı bir veritabanı dosyasına mı bağlandığınızı nasıl teyit edersiniz? 8. Sqlitebrowser programını ne şekilde kurdunuz? Eğer Ubuntu dışında bir GNU/Linux dağıtımınabuprogramıkurduysanız,programınkurulumaşamalarınıanlatın. 9. cmakekomutuilebirliktekullandığımız.(nokta)işaretininanlamınedir? 990 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 10. Yazdığınız bir programı kullanan kişilerin, programınızı ilk kez çalıştırdıklarında karşılarında görmeleri gereken verileri veritabanına yerleştirmek için nasıl bir yöntem takip edebilirsiniz? Kullanıcılarınız programınızı ikinci kez çalıştırdığında bu verileri görmemeli. 11. Bir önceki soruda uyguladığınız yöntemin herhangi bir kısıtlaması var mı? Bu yöntem hangidurumlardaişeyaramaz? 12. Birveritabanındakibütüntablolarınadınınasıllistelersiniz? 47.6 os Modülü Bildiğiniz gibi, işletim sistemlerinin çalışma mantığı birbirinden farklıdır. Örneğin Windows ve GNU/Linux işletim sistemleri aynı işi birbirlerinden farklı şekillerde yaparlar. Mesela Windows’tabirdiziniçindehangiklasörvedosyalarınolduğunuöğrenmekiçindirkomutunu kullanırız.GNU/Linux’taiseaynıişleviçinlsadlıbirkomutvardır. Aynı şekilde, iki işletim sistemi arasında dizin ayraçları konusunda da farklılık bulunur. Windows’tadizinleribirbirindenayırmakiçinterstaksim(\)işaretikullanılırken,GNU/Linux’ta aynıişiçindüztaksim(/)işaretikullanılır. (cid:242) Not Düz taksim işaretini Windows da kabul eder, ancak Windows’un doğal dizin ayracı ters taksimdir. İştebizhemWindows’ta,hemdeGNU/Linux’taçalışacakbirprogramyazmakistediğimizdebu farklılıklarıgözönündebulundurmamızvefarklıdurumlarınherbiriiçinayrıkodlaryazmamız gerekirken, os modülü bizi bu zahmetten kurtarır ve bize ortak bir arayüz üzerinden farklı işletimsistemleriiletutarlıbirşekildeiletişimkurabilmemizisağlayacakpekçokfonksiyonve niteliksunar. Bunitelikvefonksiyonlarınnelerolduğunudir(os)komutuylagörebileceğinizibiliyorsunuz. Bubölümde,osmodülününsunduğubufonksiyonveniteliklerinenönemlileriniveenyaygın kullanılanlarınıolabildiğinceayrıntılıbirşekildeelealmayaçalışacağız. (cid:242) Not Buradaosmodülünüimport oskomutuylaiçeaktarmışolduğunuzvarsayılmaktadır. 47.6. osModülü 991 PythonBelgeleri,Yayım4.1.3 47.6.1 os.name osmodülünün,öncekiderslerdeşöylebirdeğinipgeçtiğimiznameniteliği,kullanıcılarımızın, yazdığımızkodlarıhangiişletimsistemindeçalıştırdığıkonusundabizebilgiverir. Buniteliğişöylekullanıyoruz: >>> os.name EğerkodlarımızWindowsişletimsistemiüzerindeçalıştırılmışsaburadanşuçıktıyıalırız: ’nt’ MacOSveGNU/Linuxişletimsistemleriisebukomutaşucevabıverir: ’posix’ Dolayısıyla os.name niteliğini kullanarak farklı işletim sistemlerinde farklı çalışan programlar yazabiliriz. 47.6.2 os.sep osmodülününsepniteliği,kodlarımızınçalıştığıişletimsisteminindizinayracınınneolduğunu bizegösterir. EğerbuniteliğiWindowsişletimsistemiüzerindekullanırsakşuçıktıyıalırız: >>> os.sep ’\\’ MacOSveGNU/Linuxişletimsistemleriisebukomutaşucevabıverir: >>> os.sep ’/’ Pekibunitelikneişeyarar? Buniteliğikullanarak,farklıişletimsistemlerineözgüdizinyollarıoluşturabilirsiniz.Mesela: >>> liste = [’aylar’, ’mayıs’, ’test’] >>> os.sep.join(liste) Buradakarakterdizilerininjoin()metodunuos.sepilebirliktekullandığımızadikkatedin. BukomutuWindows’taverdiğinizdeşuçıktıyıalırsınız: ’aylar\\mayıs\\test’ AynıkomutuGNU/Linux’taverdiğinizdeiseşuçıktıyı: ’aylar/mayıs/test’ YaniyukarıdakikomutuWindows’taverdiğinizdePythonşukomutualmışgibidavranır: 992 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> liste = [’aylar’, ’mayıs’, ’test’] >>> ’\\’.join(liste) GNU/Linux’taiseşukomutu: >>> liste = [’aylar’, ’mayıs’, ’test’] >>> ’/’.join(liste) Böylece yazdığınız programlarda hangi işletim sisteminin hangi dizin ayracını kullandığını düşünmenizegerekkalmaz;bunusizinyerinizePythondüşünür... 47.6.3 os.getcwd() osmodülününgetcwd()fonksiyonubizeoandaiçindebulunduğumuzdizininadınıverir: >>> os.getcwd() ’/home//Desktop’ #GNU/Linux veya: >>> os.getcwd() ’C:\\Documents and Settings\\fozgul’ #Windows 47.6.4 os.chdir() osmodülününchdir()fonksiyonubizebirdizindenbaşkabirdizinegeçmeimkanıverir. Mesela GNU/Linux’ta, o anda bulunduğumuz dizinden /usr/bin adlı dizine geçmek için şu komutukullanabiliriz: >>> os.chdir(’/usr/bin/’) veyaWindows’taC:\DocumentsandSettings\fozgul\Desktopadlıdizinegeçmekiçinşunu: >>> os.chdir(’C:\\Documents and Settings\\fozgul\\Desktop’) Gördüğünüz gibi, gitmek istediğimiz dizin adını os.chdir() fonksiyonuna parametre olarak vermemizyeterlioluyor. 47.6. osModülü 993 PythonBelgeleri,Yayım4.1.3 47.6.5 os.listdir() os modülünün listdir() fonksiyonu, bize bir dizin içindeki dosya ve klasörleri listeleme imkanıverir.listdir(),osmodülününenkullanışlıfonksiyonlarındanbiridir. Mesela o anda içinde bulunduğumuz dizindeki dosya ve klasörleri listelemek istersek bu fonksiyonuşöylekullanabiliriz: >>> mevcut_dizin = os.getcwd() >>> os.listdir(mevcut_dizin) Eğerfarklıbirdizininiçeriğinilistelemekistersek,parametreolarakodizininadınıyazmamız yeterliolacaktır: >>> os.listdir(’/var/www’) Gördüğünüz gibi, os.listdir() komutunun çıktısı liste türünde bir veri tipidir. Dolayısıyla listelerleyapabildiğinizherşeyibununladayababilirsiniz.Meselabulisteüzerindebirdöngü kurabilirsiniz: >>> for i in os.listdir(os.getcwd()): ... print(i) Yadabirdiziniçindeki,bellibiruzantıyasahipdosyalarısüzebilirsiniz: >>> for i in os.listdir(os.getcwd()): ... if i.endswith(’.doc’): ... print(i) Bukodlarbize,adı.docilebitenbütündosyalarılisteleyecektir. Buaradakarakterdizilerininendswith()adlımetodunuhatırlıyorsunuz,değilmi? 47.6.6 os.curdir Çoğuişletimsistemindemevcutdizinigöstermekiçin‘.’adlıkarakterdizisikullanılır.Örneğin: >>> os.listdir(os.getcwd()) gibibirkomutyerineşukomutudakullanabilirsiniz: >>> os.listdir(’.’) listdir() fonksiyonuna parametre olarak verdiğimiz ‘.’ karakter dizisi o anda içinde bulunduğumuzdizinitemsileder. Eğer bu karakter dizisini elle yazmak istemiyorsanız os modülü içindeki curdir adlı nitelikten deyararlanabilirsiniz: >>> os.listdir(os.curdir) Bu arada os.getcwd() ile os.curdir’i birbirine karıştırmamalısınız. Bu ikisi aynı şey değildir. os.getcwd() çıktı olarak o anda içinde bulunduğumuz dizinin adını verir. os.curdir ise, bir 994 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 işletim sisteminde, o anda içinde bulunulan dizini temsil eden karakter dizisi ne ise onun değerinibarındırır.Budeğerçoğuişletimsisteminde‘.’adlıkarakterdizisidir. 47.6.7 os.pardir Tıpkı‘.’karakterdizisigibi,çoğuişletimsistemindebirüstdizinigöstermekiçin‘..’adlıkarakter dizisikullanılır.Örneğin: >>> os.listdir(’..’) komutu,oandaiçindebulunduğunuzdizindekideğil,birüstdizindekidosyavedizinadlarını listeleyecektir. Yine tıpkı os.curdir niteliğinde olduğu gibi, eğer bu karakter dizisini kendiniz elle yazmak istemezseniz, bu karakter dizisini içinde barındıran os.pardir adlı bir nitelikten yararlanabilirsiniz: >>> os.listdir(os.pardir) Bukomut,os.listdir(’..’)ileaynıçıktıyıverir. 47.6.8 os.startfile() . Uyarı Bu fonksiyon yalnızca Windows’ta çalışır. GNU/Linux işletim sistemlerinde bu fonksiyon tanımlıdeğildir. os modülü içindeki startfile() adlı fonksiyonun görevi bilgisayarımızda bulunan herhangi birdosyayı,ilişkilendirilmişolduğuprogramlaaçmaktır. Hemenbirörnekverelim. O anda içinde bulunduğumuz dizinde deneme.txt adlı bir dosya olduğunu varsayalım. Şimdi deşukomutuverelim: >>> os.startfile(’deneme.txt’) İşletim sisteminiz .txt uzantılı dosyaları hangi programla ilişkilendirmişse, startfile() fonksiyonudeneme.txtadlıdosyayıoprogramlaaçacaktır.Windows’ta.txtdosyalarıgenellikle Notepad programıyla ilişkilendirildiği için yukarıdaki komutu verdiğinizde muhtemelen deneme.txtdosyasınıniçeriğiNotepadprogramıaracılığıylagörüntülenecektir. Aynı şekilde, o anda bulunduğuz dizin içinde deneme.docx adlı bir dosyanın olduğunu varsayalımveşukomutuverelim: >>> os.startfile(’deneme.docx’) Bukomutdadeneme.docxdosyasınınMicrosoftWordadlıyazılımlaaçılmasınısağlayacaktır. Eğer startfile() fonksiyonuna parametre olarak bir dosya değil de dizin adı verecek olursanız, o dizin Windows Explorer ile açılır. Mesela içinde bulunduğumuz dizini Windows Explorerileaçalım: 47.6. osModülü 995 PythonBelgeleri,Yayım4.1.3 >>> os.startfile(os.curdir) Bununyerineşukomutukullanabileceğinizidebiliyorsunuz: >>> os.startfile(’.’) veya: >>> os.startfile(os.getcwd()) Buüçkomutdaaynıişleviyerinegetirir. Pekibirüstdiziniaçmakistersekneyapacağız? Dikkatlicebakın: >>> os.startfile(os.pardir) veya: >>> os.startfile(’..’) HerikikomutdaWindowsExploreryardımıylabirüstdiziningörüntülenmesinisağlayacaktır. Elbettestartfile()fonksiyonunaparametreolarakbelirlibirdizininadınıdaverebilirsiniz: >>> os.startfile(r"C:\Documents and Settings\fozgul") os.startfile() oldukça faydalı bir fonksiyondur. Hatta bu fonksiyonu sadece dosyaları açmakiçindeğil,internetsayfalarınıaçmakiçindahikullanabilirsiniz: >>> os.startfile(’www..com’) AncakbukomutunyalnızcaWindows’taçalışacağınıunutmayın.Oyüzdenbununyerine,daha önceöğrendiğimizwebbrowsermodülünükullanmakdahadoğruolacaktır. 47.6.9 os.mkdir() osmodülününmkdir()fonksiyonuyenidizinleroluşturabilmemizisağlar. Örneğin: >>> os.mkdir(’yenidizin’) Bukomut,oandaiçindebulunduğumuzdiziniçinde‘yenidizin’adlıbirdizinoluşturacaktır. Elbette eğer dizini o anda içinde bulunduğunuz dizin içinde değil de farklı bir konumda oluşturmakisterseniz,okonumunaçıkadresinibelirtebilirsiniz: >>> os.mkdir(’/home//Desktop/yenidizin’) veya: 996 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> os.mkdir(r’C:\Documents and Settings\fozgul\yenidizin’) Eğeroluşturmayaçalıştığınızdizinzatenvarsaos.mkdir()hataverecektir: >>> os.mkdir(r’C:\Documents and Settings\fozgul\yenidizin’) FileExistsError: [WinError 183] Halen varolan bir dosya oluşturulamaz: ’yenidizin’ 47.6.10 os.makedirs() os.makedirs()fonksiyonubirazönceöğrendiğimizos.mkdir()fonksiyonunaçokbenzesede aralarındaönemlifarklarbulunur. Birazönceos.mkdir()fonksiyonunuanlatırkenşöylebirörnekvermiştik: >>> os.mkdir(r’C:\Documents and Settings\fozgul\yenidizin’) ‘ Bukomutunçalışabilmesiiçin,bilgisayarımızdahalihazırdaC:DocumentsandSettingsfozgul yolunun varolması gerekir. Eğer bu yolu oluşturan dizinlerden herhangi biri mevcut değilse, ‘‘ ‘ mkdir() fonksiyonu yenidizin adlı dizini oluşturamaz. Bu fonksiyonun çalışabilmesi için, varolmayanbütündizinleritektekoluşturmanızgerekir. os.makedirs() ise os.mkdir() fonksiyonunun aksine, varolmayan üst ve alt dizinleri de oluşturmayeteneğinesahiptir.Örneğin: >>> os.makedirs(’/home//Desktop/aylar/mayıs/ödeme/’) Bu komut sırasıyla aylar, mayıs ve ödeme adlı dizinleri iç içe oluşturacaktır. Yani os.makedirs() komutunun ödeme adlı dizini oluşturması için aylar ve mayıs adlı dizinlerin öncedenvarolmasızorunludeğildir.Budizinlervarolsadaolmasadaos.makedirs()komutu ödeme dizinini oluşturabilir. Ama os.mkdir() fonksiyonu böyle değildir. Eğer os.mkdir() fonksiyonuyla ödeme dizinini oluşturmak isterseniz, öncelikle aylar ve mayıs adlı dizinleri oluşturmanızgerekir. 47.6.11 os.rename() os modülünün rename() adlı fonksiyonunu kullanarak dizinlerin adlarını değiştirebiliriz. Bu fonksiyonikiparametrealır: >>> os.rename(’dizinin_şimdiki_adı’, ’dizinin_yeni_adı’) Mesela mevcut çalışma dizininde ‘deneme’ adlı bir dizin varsa, bu dizinin adını ‘test’ olarak değiştirmekiçinşukomutuverebiliriz: >>> os.rename(’deneme’, ’test’) Eğer zaten ‘test’ adlı bir dizin varsa (ve içi boşsa), yukarıdaki komut GNU/Linux’ta ‘test’ adlı dizininüzerineyazacak,Windows’taisehataverecektir. 47.6. osModülü 997 PythonBelgeleri,Yayım4.1.3 47.6.12 os.replace() os modülünün replace() fonksiyonu biraz önce öğrendiğimiz rename() fonksiyonu gibi çalışır: >>> os.replace(’deneme’, ’test’) Bu komut, tıpkı rename() fonksiyonunda olduğu gibi, deneme adlı dizinin adını test olarak değiştirecektir. Eğer test adlı bir dizin zaten varsa, replace() fonksiyonu, hem Windows’ta hem de GNU/Linux’ta,varolanbutestdizinininüzerineyazmayaçalışır.GNU/Linux’taçoğudurumda bunubaşarır,ancakWindows’tayinedeçeşitliizinhatalarıilekarşılaşabilirsiniz. 47.6.13 os.remove() osmodülününremove()adlıfonksiyonu,bilgisayarımızdakidosyalarısilmemizisağlar: >>> os.remove(’dosya_adı’) Yalnız bu komutu çok dikkatli kullanmalısınız. Çünkü bu komut, silme işleminden önce herhangibirsorusormadan,dosyayıdoğrudansiler. 47.6.14 os.rmdir() osmodülününrmdir()fonksiyonu,içiboşbirdizinisilmekiçinkullanılır: >>> os.rmdir(’dizin_adı’) Eğer silmeye çalıştığınız dizin içinde herhangi bir başka dizin veya dosya varsa bu fonksiyon hataverecektir. Meselaşöylebirdizinyapısıdüşünelim: |___ anadizin |___ dizin1 |___ dizin2 |___ dizin3 |___ dizin4 Buarada,budizinyapısınıkolaycaoluşturmakiçinneyapmanızgerektiğinibiliyorsunuz: >>> os.makedirs(’anadizin/dizin1/dizin2/dizin3/dizin4’) Anadizinaltındaykenşukomutlarhataverecektir: >>> os.rmdir(’anadizin’) >>> os.rmdir(r’anadizin/dizin1’) >>> os.rmdir(r’anadizin/dizin1/dizin2/dizin3’) Çünkübudizinlerininhiçbirininiçiboşdeğil;herbirininiçindebirerdizinvar.Amaşukomut başarılıolacaktır: 998 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> os.rmdir(r’anadizin/dizin1/dizin2/dizin3/dizin4’) Buşekildeyukarıdoğruilerleyereksıraylabütündizinlerisilebilirsiniz: >>> os.rmdir(r’anadizin/dizin1/dizin2/dizin3/’) >>> os.rmdir(r’anadizin/dizin1/dizin2/’) >>> os.rmdir(r’anadizin/dizin1’) >>> os.rmdir(r’anadizin/’) 47.6.15 os.removedirs() os modülünün removedirs() fonksiyonu, içi boş dizin yollarını silmemizi sağlar. Peki bu ne demek? Diyelimkielimizdeşöylebirdizinyapısıvar: |___ anadizin |___ dizin1 |___ dizin2 |___ dizin3 |___ dizin4 Anadizinaltındanşukomutuverdiğimizde: >>> os.removedirs(’anadizin/dizin1/dizin2/dizin3/dizin4’) Eğer bütün dizinlerin içi boşsa, anadizin’den dizin4’e kadar olan bütün dizinler (anadizin ve dizin4dahil)silinecektir. 47.6.16 os.stat() os modülünün stat() fonksiyonu dosyalar hakkında bilgi almamızı sağlar. Bu fonksiyonu kullanarak bir dosyanın boyutunu, oluşturulma tarihini, değiştirilme tarihini ve erişilme tarihinisorgulayabiliriz. stat()fonksiyonunuşöylekullanıyoruz: >>> dosya = os.stat(’dosya_adı’) >>> dosya Buradanşunabenzerbirçıktıalırız: os.stat_result(st_mode=33279, st_ino=17732923532961356, st_dev=1745874298, st_nlink=1, st_uid=0, st_gid=0, st_size=495616, st_atime=1416488851, st_mtime=1415275662, st_ctime=1415275658) Bu, kendi içinde birtakım nitelikler barındıran özel bir veri tipidir. Bu veri tipinin barındırdığı niteliklerigörmekiçin,herzamanolduğugibidir()fonksiyonundanyararlanabilirsiniz: 47.6. osModülü 999 PythonBelgeleri,Yayım4.1.3 dir(dosya) Buradaözellikleişimizeyarayacakolanniteliklerşunlardır: st_atime dosyayaensonerişilmetarihi st_ctime dosyanınoluşturulmatarihi(Windows’ta) st_mtime dosyanınsondeğiştirilmetarihi st_size dosyanınboyutu Meselabirdosyanınboyutunuöğrenmekiçinst_sizeniteliğinişuşekildekullanabiliriz: >>> dosya = os.stat(’dosya_adı’) >>> dosya.st_size Bufonksiyonbize‘bayt’cinsindenbirçıktıverir.Bunukilobaytaçevirmekiçin,budeğeri1024’e bölebilirsiniz: >>> dosya.st_size / 1024 os modülünün stat() fonksiyonunu kullanarak bir dosyanın oluşturulma, erişilme ve değiştirilmetarihlerinideeldeedebilirsiniz: >>> dosya = os.stat(’dosya_adı’) >>> dosya.st_ctime #oluşturulma tarihi >>> dosya.st_atime #erişilme tarihi >>> dosya.st_mtime #değiştirme tarihi . Uyarı GNU/Linux’ta bir dosyanın ne zaman oluşturulduğunu öğrenmek mümkün değildir. Dolayısıyla dosya.st_ctime komutu yalnızca Windows’ta bir dosyanın oluşturulma tarihi verir.BukomutuGNU/Linux’taverdiğimizdeeldeedeceğimizşeydosyanınsondeğiştirilme tarihidir. Bu arada, yukarıdaki komutların çıktısı size anlamsız gelmiş olabilir. Birazdan, datetime adlı bir modülü öğrendiğimizde bu anlamsız görünen sayıları anlamlı tarih bilgilerine nasıl dönüştüreceğimizideanlatacağız. 1000 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.6.17 os.system() os modülünün system() fonksiyonu Python içinden sistem komutlarını veya başka programlarıçalıştırabilmemizisağlar.Mesela: >>> os.system(’notepad.exe’) 47.6.18 os.urandom() osmodülününurandom()fonksiyonurastgelebaytdizilerieldeetmekiçinkullanılabilir: >>> os.urandom(12) Bukomut,12bayttanoluşanrastgelebirdizioluşturur.Buradaneldeettiğinizrastgeledeğeri kriptografikçalışmalardaveyarastgeleparolaüretmeişlemlerindekullanabilirsiniz. 47.6.19 os.walk() Hatırlarsanız önceki sayfalarda os modülü içindeki listdir() adlı bir fonksiyondan söz etmiştik. Bu fonksiyon, bir dizinin içeriğini listeleme imkanı veriyordu bize. Mesela o anda içindebulunduğumuzdizindehangidosyavealtdizinlerinolduğunuöğrenmekiçinşöylebir komutkullanabiliyorduk: >>> os.listdir(’.’) [’build.py’, ’gtk’, ’kitap’, ’make.bat’, ’Makefile’, ’meta_conf.py’, ’py2’, ’py3’, ’theme’, ’tk2’, ’__pycache__’] Gördüğünüz gibi bu fonksiyon yalnızca kendisine parametre olarak verilen dizinin içeriğini listeliyor. Örneğin yukarıdaki çıktıda görünen gtk, kitap, py2, py3, theme, tk2 ve __pycache__birerdizin.Amalistdir()fonksiyonubudizinlerindeiçinegiripburadakiiçeriği listelemeye çalışmıyor. Eğer biz mesela theme dizininin içeriğini de listelemek istersek bunu açıkçabelirtmemizgerekir: >>> os.listdir(’theme’) [’layout.html’, ’localtoc.html’, ’pydoctheme’, ’sidebar.html’, ’static’] Veya theme dizini içindeki static adlı dizine de erişmek istersek bunu da şu şekilde açık açık ifadeetmemizgerekir: >>> os.listdir(’theme/static’) [’basic.css’, ’copybutton.js’, ’py.png’, ’sidebar.js’] Pekiyabizoandaiçindebulunduğumuzdizindenitibareniçedoğrubütündizinleriotomatik olaraktaramakistersekneyapacağız? Bunun için listdir() fonksiyonunu kullanarak özyinelemeli (recursive) bir fonksiyon yazabilirsiniz: 47.6. osModülü 1001 PythonBelgeleri,Yayım4.1.3 import os def tara(dizin): başlangıç = os.getcwd() dosyalar = [] os.chdir(dizin) for öğe in os.listdir(os.curdir): if not os.path.isdir(öğe): dosyalar.append(öğe) else: dosyalar.extend(tara(öğe)) os.chdir(başlangıç) return dosyalar (cid:242) Not Bu kodlarda henüz öğrenmediğimiz tek şey os.path.isdir() fonksiyonu. Bu fonksiyon, kendisine parametre olarak verilen bir değerin dizin olup olmadığını tespit etmemizi sağlıyor. Yukarıdaki kodlarda öncelikle o anda içinde bulunduğumuz dizinin konumunubaşlangıç adlı birdeğişkeneatıyoruz.Çünküdahasonraburayadönmemizgerekecek: başlangıç = os.getcwd() Ardındandosyalaradlıbirlisteoluşturuyoruz: dosyalar = [] Buliste,dizinleriçindekibütündosyalarıiçindebarındıracak. Dahasonra,tara()fonksiyonunaparametreolarakverilendizinadlıdizininiçinegiriyoruz: os.chdir(dizin) Budizininiçinegirdiktensonra,mevcutdiziniçindekibütünöğelerilistdir()fonksiyonuile tektektarıyoruz: for öğe in os.listdir(os.curdir): ... Eğertaramasırasındakarşılaştığımızöğebirdizindeğilise: if not os.path.isdir(öğe): ... Buöğeyi,doğrudanenbaştatanımladığımızdosyalaradlılisteyegönderiyoruz: 1002 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 dosyalar.append(öğe) Amaeğertaramasırasındakarşılaştığımızöğebirdizinise: else: ... tara() fonksiyonunun en başına dönüp, tanımladığımız bütün işlemleri bu dizin üzerine özyinelemeli olarak uyguluyoruz ve elde ettiğimiz öğeleri dosyalar adlı listeye extend() metoduileişliyoruz: dosyalar.extend(tara(öğe)) Buradanedenappend()değildeextend()kullandığımızıanlamakiçin,yukarıdakikodubirde append()ileyazıpeldeettiğinizçıktıyıdeğerlendirebilirsiniz. for döngüsünden çıktıktan sonra da tekrar en baştaki konuma dönebilmek için aşağıdaki komutuçalıştırıyoruz: os.chdir(başlangıç) Eğer bu şekilde başa dönmezsek, dizin yapısı içindeki ilk alt dizine girildikten sonra programımız o konumda takılı kalacağı için öteki üst dizinlerin içini tarayamaz. Bunun ne demekolduğunuanlamakiçinkodlarıbirdeos.chdir(başlangıç)koduolmadançalıştırmayı deneyebilirsiniz. Yukarıdaki yöntem doğru olsa da, Python’da bir dizini en dibe kadar taramanın en iyi yolu değildir. Python bize bu iş için özel bir fonksiyon sunar. İşte, bu bölümde ele alacağımız bu fonksiyonunadıwalk(). Walk kelimesi İngilizcede ‘yürümek’ anlamına gelir. walk() fonksiyonu da, kelimenin bu anlamınauygunolarak,dizinleriçinde‘yürünmesini’sağlar.Gelinbunubirazaçıklayalım. Şöylebirdurumdüşünün:Sabitdiskinizde,birdiziniçindepekçokaltdizinedağılmışbirsürü dosyavar.Yanişunungibi: +anadizin |dosya.txt |dosya.doc |dosya.xls |dosya.jpeg +resimler |resim1.jpeg |resim2.jpeg |resim3.jpeg |resim4.jpeg +başkadosyalar |dosya.pdf |dosya.zip |dosya.mp3 |dosya.ogg |dosya.jpeg 47.6. osModülü 1003 PythonBelgeleri,Yayım4.1.3 Siz bu iç içe geçmiş dosya yığını içinden, sonu .jpeg ile bitenleri tek bir yerde toplamak istiyorsunuz. Elbette, eğer isterseniz bu .jpeg dosyalarını tek tek elle bulup istediğiniz yere taşıyabilirsiniz.AmabuyöntembirPythonprogramcısınayakışmaz,değilmi? PythonprogramcılarıbutürangaryalarıkendiyapmakyerinePython’ayaptırmayıterciheder. OyüzdenbizdebuişiyapmakiçinPython’danyararlanacağız. osmodülününwalk()fonksiyonunukullanarakbugörevirahatlıklayerinegetirebilirsiniz. Pekiamanasıl? Öncelikle şu kodlar yardımıyla, yukarıdaki sözünü ettiğimiz dosya-dizin yapısını oluşturalım. Böylecedahasomutbiryapıüzerindeçalışmaimkanıeldeetmişoluruz: import os uzantılar = [’txt’, ’doc’, ’xls’, ’jpeg’, ’pdf’, ’zip’, ’mp3’, ’ogg’, ’jpeg’] şablon1 = [’{}.{}’.format(’dosya’, i) for i in uzantılar[:4]] şablon2 = [’resim{}.{}’.format(i, uzantılar[-1]) for i in range(1, 5)] şablon3 = [’{}.{}’.format(’dosya’, i) for i in uzantılar[4:]] dosyalar = [(’anadizin’, şablon1), (’resimler’, şablon2), (’başkadosyalar’, şablon3)] os.makedirs(os.sep.join([dosya[0] for dosya in dosyalar])) for dizin, şablon in dosyalar: for s in şablon: open(os.sep.join([dizin, s]), ’w’) os.chdir(dizin) Bukodlarda,şuanakadargörmediğimiz,öğrenmediğimizhiçbirşeyyok.Bukodlarırahatlıkla anlayabilecekkadarPythonbilgisinesahipsiniz. Dosya-dizin yapımızı oluşturduğumuza göre, os modülünün walk() fonksiyonunu bu yapı üzerindenasılkullanacağımızageçebiliriz. Şimdi ‘anadizin’ adlı klasörün bulunduğu dizin içinde etkileşimli kabuğu başlatalım ve şu komutlarıverelim: >>> for i in os.walk(’anadizin’): ... print(i) Buradanşuçıktıyıalacağız: (’anadizin’, [’resimler’], [’dosya.doc’, ’dosya.jpeg’, ’dosya.txt’, ’dosya.xls’]) (’anadizin\\resimler’, [’başkadosyalar’], [’resim1.jpeg’, ’resim2.jpeg’, ’resim3.jpeg’, ’resim4.jpeg’]) (’anadizin\\resimler\\başkadosyalar’, [], [’dosya.jpeg’, ’dosya.mp3’, ’dosya.ogg’, ’dosya.pdf’, ’dosya.zip’]) 1004 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 İncelemekolaylığıaçısındanbuçıktınınilkkısmınıelealalım: (’anadizin’, [’resimler’], [’dosya.doc’, ’dosya.jpeg’, ’dosya.txt’, ’dosya.xls’]) Gördüğünüzgibi,buradaüçöğelibirdemetvar.Çıktınındiğerkısımlarınıdaincelersenizaynı yapıyıgöreceksiniz.Dolayısıylaos.walk()komutubizeşuüçöğedenoluşanbirdemetverir: (kökdizin, altdizinler, dosyalar) Yukarıdakiçıktıyıincelediğinizdebuyapıyırahatlıklagörebilirsiniz: kökdizin => ’anadizin’ altdizinler => [’resimler’] dosyalar => [’dosya.doc’, ’dosya.jpeg’, ’dosya.txt’, ’dosya.xls’] kökdizin => ’anadizin\\resimler’ altdizinler => [’başkadosyalar’] dosyalar => [’resim1.jpeg’, ’resim2.jpeg’, ’resim3.jpeg’, ’resim4.jpeg’] kökdizin => ’anadizin\\resimler\\başkadosyalar’ altdizinler => [] dosyalar => [’dosya.jpeg’, ’dosya.mp3’, ’dosya.ogg’, ’dosya.pdf’, ’dosya.zip’] Mesela bu üç öğeli demet içinden yalnızca dosyaları almak isterseniz şöyle bir komut verebilirsiniz: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... print(dosyalar) Burada,os.walk(’anadizin’)komutununbizesunduğuüçöğelidemetinherbiröğesini,şu satıryardımıylatektekkökdizin,altdizinlervedosyalaradlıdeğişkenlereatıyoruz: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... ... Sonradabuüçlüiçinden,dosyalaradlıdeğişkeniekranayazdırıyoruz: >>> print(dosyalar) Budabizeşöylebirçıktıveriyor: [’dosya.doc’, ’dosya.jpeg’, ’dosya.txt’, ’dosya.xls’] [’resim1.jpeg’, ’resim2.jpeg’, ’resim3.jpeg’, ’resim4.jpeg’] [’dosya.jpeg’, ’dosya.mp3’, ’dosya.ogg’, ’dosya.pdf’, ’dosya.zip’] Gördüğünüz gibi, bu çıktıda ‘anadizin’ ve bunun altındaki bütün dizinlerde yer alan bütün dosyalar var. Bu konunun başında walk() fonksiyonunu tanımlarken dediğimiz gibi, walk() fonksiyonugerçektendedizinleriçinde‘yürünmesini’sağlıyor. 47.6. osModülü 1005 PythonBelgeleri,Yayım4.1.3 Bufonksiyonudahaiyianlamakiçinbirkaçdenemedahayapalım: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... print(altdizinler) ... [’resimler’] [’başkadosyalar’] Budabize‘anadizin’içindekialtdizinlerinisimleriniveriyor. Birdekökdizindeğişkenininneolduğunabakalım: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... print(kökdizin) ... anadizin anadizin\resimler anadizin\resimler\başkadosyalar Burada da o üçlü değişkenler arasından kökdizin’i yazdırdık ve gördük ki bu değişken bize bütün kök dizinlere ilişkin yol bilgilerini, yani dizinlerin adresini veriyor. Dolayısıyla kökdizin değişkeniiledosyalardeğişkeninibirleştirerekbirdosyanıntamadresinieldeedebiliriz. Dikkatlicebakın: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... for dosya in dosyalar: ... print(os.sep.join([kökdizin, dosya])) ... anadizin\dosya.doc anadizin\dosya.jpeg anadizin\dosya.txt anadizin\dosya.xls anadizin\resimler\resim1.jpeg anadizin\resimler\resim2.jpeg anadizin\resimler\resim3.jpeg anadizin\resimler\resim4.jpeg anadizin\resimler\başkadosyalar\dosya.jpeg anadizin\resimler\başkadosyalar\dosya.mp3 anadizin\resimler\başkadosyalar\dosya.ogg anadizin\resimler\başkadosyalar\dosya.pdf anadizin\resimler\başkadosyalar\dosya.zip Bildiğiniz gibi, dosya değişkeninin bize verdiği veri tipi bir listedir. O yüzden bu listenin öğelerinitektekalabilmekiçinbulisteüzerindedebirfordöngüsükurduğumuzadikkatedin. Eğeryukarıdakidizinleriçindeyeralanbütün.jpegdosyalarınılistelemekistersekdeşöylebir kodyazabiliriz: >>> for kökdizin, altdizinler, dosyalar in os.walk(’anadizin’): ... for dosya in dosyalar: ... if dosya.endswith(’.jpeg’): ... print(dosya) (sonrakisayfayadevam) 1006 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ... dosya.jpeg resim1.jpeg resim2.jpeg resim3.jpeg resim4.jpeg dosya.jpeg Gördüğünüzgibi,os.walk()fonksiyonugayetpratikvekullanışlıbiraraç. 47.6.20 os.environ os modülünün environ adlı niteliği, kullandığımız işletim sistemindeki çevre değişkenleri hakkındabilgiedinmemizisağlar. Bu nitelik alelade bir sözlüktür. Dolayısıyla bu sözlüğün içinde neler olduğunu şu kodlarla görebilirsiniz: >>> for k, v in os.environ.items(): ... print(k.ljust(10), v) Sözlükiçindekiistediğinizbirdeğerenasılerişeceğinizibiliyorsunuz: >>> os.environ[’HOMEPATH’] ’\\Documents and Settings\\fozgul’ >>> os.environ[’USERNAME’] ’FOZGUL’ Yalnız, Windows ve GNU/Linux işletim sistemlerinde çevre değişkenleri ve bunların adları birbirinden farklı olduğu için, doğal olarak environ niteliği de farklı işletim sistemlerinde farklı çıktılar verir. Birden fazla işletim sistemi üzerinde çalışacak şekilde tasarladığımız programlarda bu duruma dikkat etmeliyiz. Örneğin Windows’ta kullanıcı adını veren çevre değişkeni‘USERNAME’iken,GNU/Linux’tabudeğişken‘USER’olarakadlandırılır. 47.6.21 os.path os modülü üzerinde dir() fonksiyonunu uyguladığınızda, orada path adlı bir niteliğin olduğunu göreceksiniz. Bu nitelik, kendi içinde pek çok önemli fonksiyon ve başka nitelik barındırır. Şimdibubölümdeos.pathadlıbuniteliğiniçeriğiniinceleyeceğiz. 47.6. osModülü 1007 PythonBelgeleri,Yayım4.1.3 os.path.abspath() abspath()fonksiyonu,birdosyanıntamyolununneolduğunusöyler: >>> os.path.abspath(’falanca.txt’) os.path.dirname() dirname()fonksiyonu,birdosyayolunundizinkısmınıverir: >>> os.path.dirname(’/home//Desktop/falanca.txt’) ’/home//Desktop’ Bufonksiyonuabspath()fonksiyonuilebirliktekullanabilirsiniz: >>> os.path.dirname(os.path.abspath(’falanca.txt’)) ’/home//Desktop’ os.path.exists() exists()fonksiyonubirdosyaveyadizininvarolupolmadığınıkontroleder: >>> os.path.exists(’/home//Desktop/falanca.txt’) EğerböylebirdosyavarsayukarıdakikodTrueçıktısı,yoksaFalseçıktısıverir. os.path.expanduser() expanduser()fonksiyonubilgisayardakikullanıcıyaaitdizininadresiniverir: >>> os.path.expanduser(’~’) ’C:\\Documents and Settings\\fozgul’ veya: >>> os.path.expanduser(’~’) ’/home/’ Bufonksiyonukullanarak,Windows’tabelirlibirkullanıcıismivedizinideoluşturabilirsiniz: >>> os.path.expanduser(’~denizege’) ’C:\\Documents and Settings\\denizege’ 1008 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 os.path.isdir() isdir() fonksiyonu, kendisine parametre olarak verilen öğenin bir dizin olup olmadığını sorgular: >>> os.path.isdir(’/home/’) EğerparametrebirdiziniseTrue,eğerbirdosyaiseFalseçıktısıalınır. os.path.isfile() isfile() fonksiyonu, kendisine parametre olarak verilen öğenin bir dosya olup olmadığını sorgular: >>> os.path.isfile(’/home//falance.txt’) EğerparametrebirdosyaiseTrue,eğerbirdiziniseFalseçıktısıalınır. os.path.join() join() fonksiyonu, kendisine verilen parametrelerden, ilgili işletim sistemine uygun yol adreslerioluşturur: >>> os.path.join(’dizin1’, ’dizin2’, ’dizin3’) #Windows ’dizin1\\dizin2\\dizin3’ >>> os.path.join(’dizin1’, ’dizin2’, ’dizin3’) ’dizin1/dizin2/dizin3’ os.path.split() split()fonksiyonu,biryoladresininsonkısmınıbaşkısmındanayırır: >>> os.path.split(’/home//Desktop’) (’/home/’, ’Desktop’) Bufonksiyonukullanarakdosyaadlarınıdizinadlarındanayırabilirsiniz: >>> dizin, dosya = os.path.split(’/home//Desktop/falanca.txt’) >>> dizin ’/home//Desktop’ >>> dosya ’falanca.txt’ 47.6. osModülü 1009 PythonBelgeleri,Yayım4.1.3 os.path.splitext() splitext()fonksiyonudosyaadıileuzantısınıbirbirindenayırmakiçinkullanılır: >>> dosya, uzantı = os.path.splitext(’falanca.txt’) >>> dosya ’falanca’ >>> uzantı ’.txt’ Gördüğünüz gibi, kendi içinde pek çok nitelik ve fonksiyon barındıran os.path, kullandığımız işletimsistemineuygunşekildedizinişlemleriyapabilmemizisağlayansonderecefaydalıbir araçtır. Gelinistersenizşimdibirazbuos.pathniteliğininbazıönemliözelliklerindensözedelim. Hatırlarsanız önceki derslerimizde, modüllerin kaynak dosyalarını görmemizi sağlayan __file__ adlı bir araçtan söz etmiştik. Mesela bu aracı os modülü üzerinde uyguladığımızda şunabenzerbirçıktıalıyorduk: >>> os.__file__ ’C:\\Python\\lib\\os.py’ Demekkiosmodülününkaynakkodlarıbudiziniçindeyeralıyormuş... Normalde__file__niteliğiniyalnızcamodüladlarınauygulayabilirsiniz.Modüllerinnitelikve fonksiyonlarıüzerinde__file__aracıkullanılamaz: >>> os.name.__file__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’str’ object has no attribute ’__file__’ >>> os.walk.__file__ Traceback (most recent call last): File "<stdin>", line 1, in <module> AttributeError: ’function’ object has no attribute ’__file__’ Amaosmodülününpathniteliğiiçindurumbirazfarklıdır: >>> os.path.__file__ EğerbukomutuWindows’taverdiysenizşuçıktıyıalırsınız: ’C:\Python37\lib\ntpath.py’ AmaeğerbukomutuGNU/Linux’taverdiysenizşunabenzerbirçıktıalırsınız: ’/home/python37/lib/python3.7/posixpath.py’ 1010 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Gördüğünüz gibi, __file__, os.path üzerinde kullanılabiliyor. Yukarıdaki çıktılardan anladığımıza göre os.path niteliği Windows’ta ntpath, GNU/Linux’ta ise posixpath adlı birmodüleatıftabulunuyor. Dolayısıyla aslında biz os.path niteliğini kullanırken, eğer Windows’ta isek ntpath adlı bir modülü,amaeğerGNU/Linux’taisekposixpathadlıbirmodülüiçeaktarmışoluyoruz. Eğer os.path adlı ortak bir arayüz olmasaydı, yukarıda os.path başlığı altında incelediğimiz araçları kullanabilmek için, kullandığımız işletim sistemine göre posixpath veya ntpath modüllerindenuygunolanınıkendimizelleiçeaktarmakzorundakalacaktık: if os.name == ’nt’: import ntpath as path else: import posixpath as path AmaPythonprogramlamadilininbizeos.pathadlıniteliğisunmuşolmasısayesindeWindows işletim sistemi için ntpath, GNU/Linux işletim sistemi için ise posixpath modülünü ayrı ayrı içe aktarmamıza gerek kalmıyor. Bütün işi bizim yerimize Python hallediyor. Böylece farklı işletim sistemlerine ilişkin birbirinden farklı işlemleri, os.path adlı tek bir arayüz üzerinden gerçekleştirebiliyoruz. 47.7 time Modülü time modülü, bir önceki bölümde öğrendiğimiz datetime modülüne benzer. Hatta bu iki modülün aynı işi yapan ortak nitelik ve fonksiyonları vardır. Ancak datetime modülünden farklıolaraktimemodülünüdahaçoksaatleilgiliişlemleriyapmakiçinkullanacağız. Her zaman olduğu gibi, bu modülü kullanabilmek için de öncelikle modülü içe aktarmamız gerekiyor: >>> import time Modülüiçeaktardığımızagöre,artıkmodülüniçeriğindenyararlanabiliriz. 47.7.1 gmtime() Python’da (ve başka programlama dillerinde), zaman-tarih hesaplamalarında ‘zamanın başlangıcı’(EPOCH)diyebirkavrambulunur.‘Zamanınbaşlangıcı’,birişletimsisteminin,tarih hesaplamalarında sıfır noktası olarak aldığı tarihtir. Kullandığınız işletim sisteminin hangi tarihi‘zamanınbaşlangıcı’olarakkabulettiğinibulmakiçinşukomutuverebilirsiniz: >>> time.gmtime(0) Buradanşuçıktıyıalıyoruz: time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0) Bu,struct_timeadlıözelbirveritipidir.Buveritipiiçindekiniteliklereşuşekildeulaşabilirsiniz: 47.7. timeModülü 1011 PythonBelgeleri,Yayım4.1.3 >>> epoch = time.gmtime(0) >>> epoch.tm_year #yıl 1970 >>> epoch.tm_mon #ay 1 >>> epoch.tm_mday #gün 1 Demek ki zamanın başlangıcı 1 Ocak 1970 tarihi olarak alınıyormuş... İşte bilgisayarımız, içinde bulunduğumuz zaman ve saati, bu başlangıç zamanından bu yana geçen saniyeleri hesaplayarakbulur. gmtime() fonksiyonunu parametresiz olarak kullandığınızda, o anda içinde bulunduğunuz tarihvesaatbilgisinieldeedersiniz. time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10, tm_hour=12, tm_min=5,tm_sec=33,tm_wday=2,tm_yday=344,tm_isdst=0) Ancak bu çıktı, özellikle saat kısmı konusunda her zaman doğru olmayabilir. Çıktının birkaç saatsaptığınıgörebilirsiniz. 47.7.2 time() time()fonksiyonu,epok35’tanitibaren,oandaiçindebulunduğumuzanakadargeçentoplam saniyemiktarınıverir: >>> time.time() 1418213083.726988 Elde ettiğiniz bu değeri, gmtime() fonksiyonunu kullanarak anlamlı bir tarih değerine dönüştürebilirsiniz: >>> time.gmtime(time.time()) time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10, tm_hour=12, tm_min=9, tm_sec=19, tm_wday=2, tm_yday=344, tm_isdst=0) Ancakbuçıktıdaözelliklesaatkısmındasapmalarauğrayabilir. 35https://docs.python.org/3/library/time.html#epoch 1012 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.7.3 localtime() Tıpkı gmtime() fonksiyonundan olduğu gibi, anlık tarih ve zaman bilgisini bir struct_time nesnesiolarakalmakiçinlocaltime()fonksiyonunudakullanabiliriz.Bufonksiyonbizeyerel saatidoğrubirşekildeverecektir: >>> time.localtime() time.struct_time(tm_year=2014, tm_mon=12, tm_mday=10, tm_hour=14, tm_min=24, tm_sec=21, tm_wday=2, tm_yday=344, tm_isdst=0) Bunesneniniçindekiyıl,ayvegüngibibilgileretekteknasılerişebileceğinizibiliyorsunuz. 47.7.4 asctime() Baştadasöylediğimizgibi,timemodülü,datetimemodülünebenzer.Bunlarınaynıişigören çeşitlifonksiyonlarıvardır.Birörnekverelim. Hatırlarsanız, bugünün tarihini bir karakter dizisi olarak almak için datetime modülünü şu şekildekullanabiliyorduk: >>> import datetime >>> an = datetime.datetime.now() >>> datetime.datetime.ctime(an) ’Wed Dec 10 13:56:22 2014’ Yukarıdakiişlemitimemodülününasctime()fonksiyonunukullanarakdayapabiliriz: >>> import time >>> time.asctime() ’Wed Dec 10 13:58:31 2014’ asctime()fonksiyonutercihebağlıbirparametredealabilir.İstersenizbufonksiyona9öğeli birdemetveyabirstruct_timenesnesiverebilirsiniz. Yukarıda, gmtime() fonksiyonunun bir struct_time nesnesi ürettiğini öğrenmiştik. Dolayısıyla bunesneyiasctime()fonksiyonunaparametreolarakverebilirsiniz: >>> time.asctime(time.gmtime()) ’Wed Dec 10 12:14:29 2014’ >>> time.asctime(time.gmtime(0)) ’Thu Jan 1 00:00:00 1970’ Aynışekildelocaltime()fonksiyonunundabizebirstruct_time()nesnesiverdiğinibiliyoruz. Dolayısıylabufonksiyondaasctime()fonksiyonunaparametreolarakverilebilir: 47.7. timeModülü 1013 PythonBelgeleri,Yayım4.1.3 >>> time.asctime(time.localtime()) ’Wed Dec 10 14:28:05 2014’ Veya, sırasıyla yıl, ay, gün, saat, dakika, saniye, haftanın günü, yılın günü, gün ışığından yararlanma durumu değerini içeren bir demet de oluşturabilir, daha sonra bunu asctime() fonksiyonunaparametreolarakverebilirsiniz: >>> demet = (2014, 5, 27, 13, 45, 23, 0, 0, 0) >>> time.asctime(demet) Ancaközelliklehaftanıngünü,yılıngünüvegünışığındanyararlanmadurumubilgilerinidoğru tahminetmekzorolduğuiçin,budemetielleoluşturmanızıpektavsiyeetmem. 47.7.5 strftime() Hatırlarsanız datetime modülünü anlatırken, datetime sınıfı içindeki strftime() adlı bir fonksiyondan söz etmiştik. Bu fonksiyonun, tarih-saat bilgisi içeren karakter dizilerini manipüleedebilmemizisağladığınıbiliyorsunuz. Bufonksiyonuşöylekullanıyorduk: >>> import datetime >>> an = datetime.datetime.now() >>> datetime.datetime.strftime(an, ’%c’) ’10.12.2014 14:57:48’ İşteyukarıdakiişlemi,timemodülününstrftime()fonksiyonunukullanarakbirazdahapratik birşekildegerçekleştirebiliriz: >>> import time >>> time.strftime(’%c’) ’10.12.2014 14:58:02’ datetime modülünü incelerken gördüğümüz tarih biçimlendiricileri time modülü için de geçerlidir: %a haftagünününkısaltılmışadı %A haftagünününtamadı %b ayınkısaltılmışadı %B ayıntamadı %c tamtarih,saatvezamanbilgisi 1014 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 %d sayıdeğerlibirkarakterdizisiolarakgün %j belli bir tarihin, yılın kaçıncı gününe denk geldiğini gösteren 1-366 arası bir sayı %m sayıdeğerlibirkarakterdizisiolarakay %U bellibirtarihinyılınkaçıncıhaftasınageldiğinigösteren0-53arasıbirsayı %y yılınsonikirakamı %Y yılındörthanelitamhali %x tamtarihbilgisi %X tamsaatbilgisi . Uyarı Sistem yerelinin locale modülü aracılığıyla Türkçeye ayarlanmış olması gerektiğini unutmuyoruz: import locale locale.setlocale(locale.LC_ALL, ’turkish’) 47.7.6 strptime() time modülünün strptime() fonksiyonunun yaptığı iş, datetime modülünün datetime sınıfınınstrptime()fonksiyonununyaptığıişeçokbenzer: >>> import datetime >>> t = ’27 Mayıs 1980’ >>> tarih = datetime.datetime.strptime(t, ’%d %B %Y’) >>> tarih datetime.datetime(1980, 5, 27, 0, 0) Burada ‘27 Mayıs 1980’ tarihini, strptime() fonksiyonu yardımıyla bir datetime nesnesine dönüştürdük.Aynışeyişuşekildedeyapabiliriz: >>> import time >>> t = ’27 Mayıs 1980’ >>> tarih = time.strptime(t, ’%d %B %Y’) >>> tarih (sonrakisayfayadevam) 47.7. timeModülü 1015 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) time.struct_time(tm_year=1980, tm_mon=5, tm_mday=27, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=148, tm_isdst=-1) Gördüğünüz gibi, time modülünün strptime() fonksiyonu datetime modülü içindeki strptime()fonksiyonununaksinebirstruct_timenesnesiveriyor. 47.7.7 sleep() sleep() fonksiyonu, time modülünün en sık kullanılan araçlarından bir tanesidir. Bu fonksiyonukullanarakkodlarımızınişleyişinibellisürelerlekesintiyeuğratabiliriz. Basitbirörnekverelim: >>> for i in range(10): ... time.sleep(1) ... print(i) Bukodlarıçalıştırdığınızda,0’dan10’akadarolansayılarekranabasılırkenherbirsayıarasına 1’ersaniyelikduraklamalareklendiğinigöreceksiniz.Eğerarzuedersenizbusüreyi1saniyenin dealtınaçekebilirsiniz: >>> for i in range(10): ... time.sleep(0.5) ... print(i) Gördüğünüzgibi,sleep()fonksiyonuna0.5parametresinivererek,duraklamasüresinin500 milisaniyeolmasınısağladık. timemodülününsleep()fonksiyonunu,kodlarınızarasınaduraklamaeklemekistediğinizher durumdakullanabilirsiniz. 47.8 curses Modülü 47.8.1 curses Nedir? Curseskütüphanesi,metintabanlıterminalleriçinterminaldenbağımsızbirekranboyamave klavyekullanımıkolaylığısağlar.Butipterminaller,VT100s,Linuxkonsoluveçeşitliprogramlar tarafından simüle edilmiş terminallerdir. Ekran terminalleri imleci hareket ettirmek, ekranı kaydırmakvealanlarısilmekgibibazıgenelişlemleriyapabilmekiçinçeşitlikontrolkodlarını destekler. Farklı terminaller geniş ölçüde değişik kodlar kullanırlar ve genellikle kendi küçük tuhaflıklarıvardır. Curses kütüphanesi oldukça temel işlevsellikler sunar, programcıya, örtüşmeyen çoklu metin pencerelerini içeren ekranların soyutlanmasını sağlar. Bir pencerenin içerikleri çeşitli şekillerde değişebilir - bir metin girme, bu metni silme, bu metnin görüntüsünü değiştirme - ve Curses kütüphanesi doğru çıktıyı oluşturabilmek için terminale hangi kontrol kodlarının gönderilmesigerektiğiniçözer.Curses;düğmeler,onaykutuları,veyadiyaloglargibikullanıcı arayüzükonseptlerisağlamaz;eğerbugibiözelliklereihtiyacınızvarsa,Urwidgibibirkullanıcı arayüzükütüphanesinikullanmayıdüşünün. 1016 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Curses kütüphanesi ilk olarak BSD Unix için yazılmıştır; AT&T’nin Unix’in sonraki System V sürümleri için bir çok geliştirme ve yeni işlev eklendi. BSD curses artık muhafaza edilmiyor, AT&T’nin açık kaynak uygulama arayüzü olan ncurses onun yerine getirildi. Eğer Linux veya FreeBSD gibi açık kaynak Unix kullanıyorsanız, sisteminiz neredeyse kesinlikle ncurses kullanıyordemektir.MademhalihazırdakibirçokticariUnixsürümüSystemVkoduüzerine temellenmiş, burada bahsedilen bütün işlevler büyük olasılıkla kullanılabilir olacaktır. Bazı tescilliUnixlerintaşıdığıeskicursessürümleriherözelliğidesteklemeyebilir. 47.8.2 Python Curses Modülü Python modülü, curses tarafından sağlanan C işlevleri üzerinde basit bir sarıcıdır; eğer C’de curses programlamaya zaten aşinaysanız, bu bilgiyi Python’a taşımak gerçekten kolaydır. En büyükfark,Pythonarayüzeyininaddstr(),mvaddstr()vemvwaddstr()gibideğişikCişlevlerini tekbiraddstr()metodundabirleştirerekişleridahakolayyoldanhalletmesidir.Bunubirazdan birazdahaayrıntılıbirşekildegöreceğiz. 47.8.3 Bir Curses Uygulamasını Başlatma ve Sonlandırma Curses ile bir şey yapmadan önce, curses ilklendirilmelidir. Bu ilklendirme işlemi initscr() işlevini çağırarak yapılır. Bu işlev terminal tipini belirler, gerekli bütün kurulum kodlarını terminale gönderir ve çeşitli iç veri yapılarını oluşturur. Eğer başarılı olursa, initscr() tüm ekranıtemsiledenbirpenceregeridöndürür;buekranagenellikleCdeğişkeninekarşılıkgelen isimdensonrastdscrismiverilmiştir: import curses stdscr = curses.initscr() Genellikle curses uygulamaları tuşları okuyabilmek ve onları sadece belli koşullar altında görüntüleyebilmekiçintuşlarınekrandaotomatikolarakyansımasınıdevredışıbırakır.Bunun içinnoecho()işleviniçağırmakgerekir: curses.noecho() Uygulamaların , Enter tuşuna basılmasına ihtiyaç duyulmadan, anında tuşlara tepki vermesi gerekecektir;bunacbreakmodudenir,vetampongirdimodunazıttır: curses.cbreak() Terminaller genellikle imleç tuşları veya Page Up ve Home gibi gezinme tuşlarını çoklu kaçış dizisi olarak geri dönderir. Uygulamanızı bazı serileri beklemek ve buna göre işlemek için yazabilecekken,cursesbunusizinyapar;curses.KEY_LEFTgibibirözelkarakterigeridönderir. Curses’inbuişlemiyapabilmesiiçinkeypadmodunuaktifhalegetirmelisiniz: stdscr.keypad(True) Bir curses uygulamasını sonlandırmak yeni bir tanesini başlatmaktan çok daha kolaydır. Aşağıdakileri, curses’e uygun hale getirilmiş terminal ayarlarını tersine çevirmek için çağırmanızgerekebilir: 47.8. cursesModülü 1017 PythonBelgeleri,Yayım4.1.3 curses.nocbreak() stdscr.keypad(False) curses.echo() Ardındanterminalinilkişletimmodunuyüklemekiçinendwin()’içağırın: curses.endwin() Şimdiyavaşyavaşörneklerüzerindecursesmodülünüdahaiyianlamayaçalışalım. 47.8.4 Örnekler: 47.8.5 Örnek-1: Ekranınortasınabir“helloworld!”yazısıyerleştirelim. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses ekran = curses.initscr() boyutlar = ekran.getmaxyx() ekran.addstr(int(boyutlar[0]/2), int(boyutlar[1]/2 - 6), "hello world!", curses.A_BOLD) ekran.refresh() ekran.getch() curses.endwin() KodlarınAçıklamaları: Öncegereklimodülprogramıniçineaktarılır: import curses Cursesileişlemyapmadanöncemutlakaekranıntanıtılmasıgerekiyor: ekran = curses.initscr() Yazıyı ekrana yerleştirmek için satır ve sütun numaralarını yazabileceğimiz gibi, Terminal ekran boyutunun ölçülerini referans alarak bazı özel durumlarda ne yapılması gerektiğini belirtebiliriz: boyutlar = ekran.getmaxyx() Diyelimyazıyıterminalekranınıntamortasınayerleştirmekistiyoruz,ozamansütunvesatır parametrelerineekranölçülerininyarısınıdeğerolarakverebiliriz.Ancak“helloworld!”ifadesi 12karakterdenoluştuğuiçin,bukarakteruzunluğununyarısınısatırdeğerindençıkarırız: 1018 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 ekran.addstr(int(boyutlar[0]/2), int(boyutlar[1]/2 - 6), "hello world!", curses.A_BOLD) Ekranıtazeleyelim: ekran.refresh() Karakterleriyakalayalım: ekran.getch() Herhangibirtuşabasılıncaekransonlansın: curses.endwin() 47.8.6 Örnek-2: Sürekli y ekseninin ortasında bulunan ama x ekseni boyunca hareket eden bir “hello world!” yazısıoluşturalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time ekran = curses.initscr() boyutlar = ekran.getmaxyx() for i in range(boyutlar[1] - len("hello world!")): ekran.clear() ekran.addstr(int(boyutlar[0]/2), i, "hello world!", curses.A_BOLD) ekran.refresh() time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Modülleriprogramıniçineaktaralım: import curses import time Herzamankigibiönceekrantanıtılır: ekran = curses.initscr() Yineekranımızınmaksimumboyutlarınıtanımlayalım: boyutlar = ekran.getmaxyx() 47.8. cursesModülü 1019 PythonBelgeleri,Yayım4.1.3 Yazının terminal ekranında, bir animasyon gibi hareket etmesini istiyorsak, bir for döngüsü içindesütunvesatırlarıanlıkolarakdeğiştirebiliriz: for i in range(boyutlar[1] - len("hello world!")): Ekranıtemizleyelim: ekran.clear() Sürekliyeksenininortasındaolanvexeksenininiparametresinegöredeğişen“helloworld!” yazısınıkalınharflerleekranahareketlibirşekildebastıralım: ekran.addstr(int(boyutlar[0]/2), i, "hello world!", curses.A_BOLD) Ekranıtazeleyelim: ekran.refresh() time.sleep() fonksiyonunu tanımlamadığınızda ne olacağını görmek için fonksiyonu yoruma alın: time.sleep(0.05) Veprogramdanterminalieskihalinegetirecekşekildeçıkalım: curses.endwin() 47.8.7 Örnek-3: x ve y eksenleri boyunca hareket eden bir “hello world!” yazısı oluşturalım. Dilerseniz bu uygulamayıbirekrankoruyucuolarakdakullanabilirsiniz. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time ekran = curses.initscr() boyutlar = ekran.getmaxyx() ekran.nodelay(1) q = -1 x, y = 0, 0 dusey, yatay = 1, 1 while q < 0: ekran.clear() ekran.addstr(y, x, "hello world!", curses.A_BOLD) ekran.refresh() y += dusey (sonrakisayfayadevam) 1020 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) x += yatay if y == boyutlar[0] - 1: dusey = -1 elif y == 0: dusey = 1 if x == boyutlar[1] - len("hello world!") - 1: yatay = -1 elif x == 0: yatay = 1 q = ekran.getch() time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Buörnektekullanacağımızgereklimodülleriprogramıniçineaktaralım: import curses import time Herzamankigibiönceekranıtanıtalım: ekran = curses.initscr() Ekranınmaksimumboyutlarınıalalım: boyutlar = ekran.getmaxyx() nodelay()’in parametresi 1 (True) olursa yazımız ekranda hareket edebilir, 0 (False) olursa da yazısabitbirşekildedurur: ekran.nodelay(1) Döngüdeğişkeninitanımlıyoruz.Budeğişkenbasılanhertuşutemsiledecek.Böyleceherhangi birtuşabastığımızdaprogramdançıkabiliriz: q = -1 Döngüyle birlikte değişecek olan ekran satır ve sütun değerlerini ilk etapta 0 olarak belirliyoruz: x, y = 0, 0 Satır ve sütunların değerleri, biri düşey diğeri yataya müdahele edecek değişkenlere göre değiştirilecek.Buyüzdenduseyveyatayismindeikitanedeğişkenoluşturalım: dusey, yatay = 1, 1 Şimdidöngümüzüoluşturmayageçelim: while q < 0: Döngüherbaşasardığındaekrantemizlensin: 47.8. cursesModülü 1021 PythonBelgeleri,Yayım4.1.3 ekran.clear() Ekrandakiyazıhepkalınharflerle“helloworld!”yazısıolsun: ekran.addstr(y, x, "hello world!", curses.A_BOLD) Ekranıtazeleyelim: ekran.refresh() Döngüylebirliktexvey’nindeğerleriduseyveyataydeğişkenlerinegöreartırılır: y += dusey x += yatay Şayetymaksimumdeğerineulaşırsa,duseydeğişkeni-1’eeşitlenir.Böylecenegatifyyönünde hareketedebiliriz: if y == boyutlar[0] - 1: dusey = -1 Şayet y minimum değerine ulaşırsa, dusey’ değişkeni 1’e eşitlenir. Böylece pozitif y yönünde hareketedebiliriz: elif y == 0: dusey = 1 Şayetxmaksimumdeğerineulaşırsa,yataydeğişkeni-1’eeşitlenir.Böylecenegatifxyönünde hareketedebiliriz: if x == boyutlar[1] - len("hello world!") - 1: yatay = -1 Şayet x minimum değerine ulaşırsa, yatay değişkeni 1’e eşitlenir. Böylece pozitif x yönünde hareketedebiliriz: elif x == 0: yatay = 1 Ekranda bir tuşa bastığımız zaman programdan çıkabilmemiz için, q değişkeninin bütün harfleritemsiletmesinisağlayalım: q = ekran.getch() Ekrandakiyazınınhareketliliğitime.sleep()fonksiyonuilebirazazaltalım: time.sleep(0.05) Venormalterminalekranınageridönelim: curses.endwin() 1022 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.8.8 Örnek-4 ‘asdw’tuşlarıylahareketedenbir“helloworld!”yazısıoluşturalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time ekran = curses.initscr() curses.noecho() boyutlar = ekran.getmaxyx() ekran.nodelay(1) q = -1 x, y = 0, 0 while q != ord("q"): ekran.clear() ekran.addstr(y, x, "hello world!", curses.A_BOLD) ekran.refresh() q = ekran.getch() if q == ord("w") and y > 0: y -= 1 elif q == ord("s") and y < boyutlar[0] - 1: y += 1 elif q == ord("a") and x > 0: x -= 1 elif q == ord("d") and x < boyutlar[1] - len("hello world!") - 1: x += 1 time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Buörnektekullanacağımızmodülleriiçeaktaralım: import curses import time Yineherzamankigibiönceekranıoluşturalım: ekran = curses.initscr() Bastığımız tuş ekrana yansımasın diye, curses.noecho() fonksiyonunu kullanacağız. Farkı görmekiçinbufonksiyonuyorumaalın: curses.noecho() Yineekranboyutlarınıalalım: 47.8. cursesModülü 1023 PythonBelgeleri,Yayım4.1.3 boyutlar = ekran.getmaxyx() Hareketisağlamakiçinnodelay()fonksiyonunundeğerini1olarakayarlayalım: ekran.nodelay(1) Hertuşutemsiledecekolanqdeğişkenimizitanımlayalım: q = -1 Buseferekrandakiyazınındeğişenkonumlarınıxveydeğerlerinegörebelirleyelim.Başlangıç değerlerini0,0yazıyoruz: x, y = 0, 0 Şimdidöngümüzüoluşturmayageçelim.qtuşunabasılmadığısürecedöngüdevametsin: while q != ord("q"): Döngüherbaşasardığındaclear()ileyineekranıtemizleyelim: ekran.clear() Ekranıny,xkonumuna“helloworld!”stringinikalınharfliolacakşekildeekleyelim: ekran.addstr(y, x, "hello world!", curses.A_BOLD) Ekranıtazeleyelim: ekran.refresh() qtuşununbütüntuşlarıtemsiletmesinisağlayalım: q = ekran.getch() Şayetkullanıcıwtuşunabasarsavey’nindeğeri0’danbüyükse,y’nindeğeri1birimazalsın: if q == ord("w") and y > 0: y -= 1 Şayet kullanıcı s tuşuna basarsa ve y’nin değeri maksimum değerinden küçükse, y’nin değeri 1birimartırılsın: elif q == ord("s") and y < boyutlar[0] - 1: y += 1 Şayetkullanıcıatuşunabasarsavex’indeğeri0’danbüyükse,x’indeğeri1birimazalsın: elif q == ord("a") and x > 0: x -= 1 Şayet kulanıcı d tuşuna basarsa ve x’in değeri maksimum değerinden küçükse; x’in değeri 1 birimartırılsın: 1024 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 elif q == ord("d") and x < boyutlar[1] - len("hello world!") - 1: x += 1 time.sleep()’i niye kullandığımızı merak ediyorsanız, bu kodu yoruma ekleyin ve farkı gözlemleyin: time.sleep(0.05) Vebiziprogramdanterminalibozmadançıkaracakolankomutuyazmayıunutmuyoruz: curses.endwin() 47.8.9 Örnek-5: “asdw” tuşlarıyla hareket eden ve “1, 2, 3” tuşlarıyla renk değiştiren bir “hello world!” yazısı oluşturalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time ekran = curses.initscr() curses.start_color() curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) curses.noecho() boyutlar = ekran.getmaxyx() ekran.nodelay(1) g = 1 q = -1 x, y = 0, 0 while q != ord("q"): ekran.clear() ekran.addstr(y, x, "hello world!", curses.color_pair(g)) ekran.move(boyutlar[0] - 1, boyutlar[1] - 1) ekran.refresh() q = ekran.getch() if q in range(49, 52): g = int(chr(q)) if q == ord("w") and y > 0: y -= 1 elif q == ord("s") and y < boyutlar[0] - 1: if y == boyutlar[0] - 2 and x == boyutlar[1] - \ len("hello world!"): pass (sonrakisayfayadevam) 47.8. cursesModülü 1025 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) else: y += 1 elif q == ord("a") and x > 0: x -= 1 elif q == ord("d") and x < boyutlar[1] - len("hello world!"): if y == boyutlar[0] - 1 and x == boyutlar[1] - \ len("hello world!") - 1: pass else: x += 1 time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Herzamankigibikullanacağımızmodülleriprogramıniçineaktaralım: import curses import time Yineönceekranıtanımlıyoruz: ekran = curses.initscr() Herhangibirrenklendirmeişleminegeçmedenöncerenklendirmeyibaşlatmamızgerekiyor: curses.start_color() Şimdirenkçiftlerinisıralarınıbelirterekoluşturmayageçebiliriz: curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) Yinebastığımızherhangibirtuşekrandayansımaoluşturmasın: curses.noecho() Maksimumekranboyutlarınıbirdeğişkenekaydedelim: boyutlar = ekran.getmaxyx() Yine ekrandaki harekette bir gecikme olmaması için nodelay()’in parametresini 1 olarak ayarlıyoruz: ekran.nodelay(1) Yukarıda tanımladığımız renk çiftlerini kullanabilmek için bir değişken tanımlayalım. Bu değişkensayesinderenkçiftlerine,sıranumarasısayesindeerişebileceğiz: g = 1 Şimdideherzamankigibihertuşutemsiledecekqdeğişkenimizitanımlayalım: 1026 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 q = -1 Ekranayazıyıyinexveydeğerlerinegöreyerleştireceğiz.0’a0“helloworld!”yazısınınbaşlangıç değerleriolsun: x, y = 0, 0 Döngümüzütanımlayalım.Döngüqtuşunabasılmadığısürecedevametsin: while q != ord("q"): Herzamankigibiekranımızıtamamentemizleyelim: ekran.clear() Ekranın y ve x konumuna “hello world!” yazısını yerleştirelim. Aşağıdaki curses.color_pair(g)’dekigbirazdantanımlayacağımıztuşlarabastığımızdarenkdeğiştirmeye yarayacak: ekran.addstr(y, x, "hello world!", curses.color_pair(g)) İmleci ekranın en sonuna götürelim. Bu fonksiyonu kullanmadığımız zaman oluşacak olan farkıgörebilmekiçinfonksiyonuyorumaalın: ekran.move(boyutlar[0] - 1, boyutlar[1] - 1) Ekranıtazeleyelim: ekran.refresh() qbütüntuşlarıtemsilediyorolsun: q = ekran.getch() chr(49)’danchr(52)’yekadarolankarakterler1,2ve3’tür.Şayetkullanıcıbutuşlarabasarsag değişkenideğişecekveböylece“helloworld!”yazımızfarklırenkleresahipolacak: if q in range(49, 52): g = int(chr(q)) Şayetkullanıcıwtuşunabasarsavey’nindeğeri0’danbüyükse,ydeğişkeninindeğeri1birim azalsın: if q == ord("w") and y > 0: y -= 1 Şayet kullanıcı s tuşuna basarsa ve y’nin değeri maksimum değerin 1 birim eksiğinden küçükse: elif q == ord("s") and y < boyutlar[0] - 1: Yukarıdaki koşul altında şayet y maksimum değerinden 2 birim küçükse ve x’de maksimum değereulaşmışsa,hiçbirişlemyapılmasın: 47.8. cursesModülü 1027 PythonBelgeleri,Yayım4.1.3 if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"): pass Aksitaktirde,ydeğişkeninindeğeri1birimartsın: else: y += 1 Şayet kullanıcı a tuşuna basarsa ve x’in değeri 0’dan büyükse, x değişkeninin değeri 1 birim azalsın: elif q == ord("a") and x > 0: x -= 1 Şayetkullanıcıdtuşunabasarsavex’indeğerimaksimumdeğerdenküçükse: elif q == ord("d") and x < boyutlar[1] - len("hello world!"): Şayet yukarıdaki koşul altında y’nin ve x’in değerleri max değerlerinden 1 birim küçüğüne eşitse;hiçbirişlemyapılmasın: if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1: pass Aksitaktirde,xdeğişkeninindeğeri1birimartırılsın: else: x += 1 time.sleep()’in neden kullanıldığını öğrenmek için bu fonksiyonun başına yorum satırı işareti getirin: time.sleep(0.05) Veprogramdançıkıldığındaterminaltekrareskihalinegetirilsin: curses.endwin() 47.8.10 Örnek-6: “asdw” tuşlarıyla hareket eden, “1, 2, 3” tuşlarıyla renkleri değişen, “b” tuşu ile kalınlaşıp inceleşen ve “r” tuşuyla arka plan rengi ön plan rengi haline gelen bir “hello world!” yazısı oluşturalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time (sonrakisayfayadevam) 1028 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ekran = curses.initscr() curses.start_color() curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) curses.noecho() boyutlar = ekran.getmaxyx() ekran.nodelay(1) bold = 0 reverse = 0 b = [curses.A_NORMAL, curses.A_BOLD] r = [curses.A_NORMAL, curses.A_REVERSE] g = 1 q = -1 x, y = 0, 0 while q != ord("q"): ekran.clear() ekran.addstr(y, x, "hello world!", curses.color_pair(g) | b[bold] | r[reverse]) ekran.move(boyutlar[0] - 1, boyutlar[1] - 1) ekran.refresh() q = ekran.getch() if q in range(49, 52): g = int(chr(q)) elif q == 98: bold = 1 - bold elif q == 114: reverse = 1 - reverse if q == ord("w") and y > 0: y -= 1 elif q == ord("s") and y < boyutlar[0] - 1: if y == boyutlar[0] - 2 and x == boyutlar[1] - \ len("hello world!"): pass else: y += 1 elif q == ord("a") and x > 0: x -= 1 elif q == ord("d") and x < boyutlar[1] - len("hello world!"): if y == boyutlar[0] - 1 and x == boyutlar[1] - \ len("hello world!") - 1: pass else: x += 1 time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Yineörnekuygulamamızdakullanacağımızmodülleriiçeaktaralım: 47.8. cursesModülü 1029 PythonBelgeleri,Yayım4.1.3 import curses import time Gördüğünüzgibiilkolarakhepekranıtanımlıyoruz: ekran = curses.initscr() Örnek uygulamada renk kullanacağız yine. Bu yüzden renk çiftlerini tanımlamadan önce aşağıdakifonksiyonukesinkullanmamızgerekiyor: curses.start_color() Şimdi3tanerenkçiftioluşturalım: curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) Bastığımıztuşlaryineekrandayansımaoluşturmasın: curses.noecho() Ekranınmaksimumxveydeğerlerinialalım: boyutlar = ekran.getmaxyx() Animasyonumuzun ekranda görüntülenmesinin gecikmemesi için yine nodelay()’in parametresini1olarakayarlıyoruz: ekran.nodelay(1) Buseferkalınlaştırmaişleminibirtuşyardımıylayapacağız.Bununiçinboldisimlibirdeğişken oluşturalımvedeğerini0yapalım: bold = 0 “helloworld!”yazısınınarkaplanrenginiönplana,önplanrenginiisearkaplanaçevirmekiçin reverseismindebirdeğişkenoluşturalımvedeğerini0yapalım: reverse = 0 b tuşuna basılınca iki ayrı işlem yapılsın: Metin kalınlaştırılmışsa inceltilsin, yok eğer inceltilmişsekalınlaştırılsın.Buişlemiçinbirlisteoluşturalım: b = [curses.A_NORMAL, curses.A_BOLD] Aynı şekilde reverse işlemi için de birbirinin tersi olan değişkenleri barındıran bir liste oluşturalım: r = [curses.A_NORMAL, curses.A_REVERSE] Tanımladığımız renk çiftlerini kullanabilmek için yine g isimli bir değişken kullanacağız ve bu değişkenindeğerini1olarakbelirleyelim: 1030 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 g = 1 Yineekrandakihertuşutemsiledenbirqdeğişkenioluşturalım: q = -1 xvey’ninbaşlangıçdeğerlerinibelirtelim: x, y = 0, 0 Yineqtuşunabasılıncasonlananbirdöngüoluşturalım: while q != ord("q"): Ekranıtemizleyelimyine: ekran.clear() “hello world! yazısını ilgili tuşlara basılınca aktif hale gelecek biçimlendirme özellikleriyle birlikteekranaekleyelim: ekran.addstr(y, x, "hello world!", curses.color_pair(g) | b[bold] | r[reverse]) İmleciekranınsağaltköşesineyerleştirelim: ekran.move(boyutlar[0] - 1, boyutlar[1] - 1) Ekranıtazeleyelim: ekran.refresh() qbütüntuşlarıtemsiletsin: q = ekran.getch() chr(49)’danchr(52)’yekadarolankarakterler1,2ve3’tür.Şayetkullanıcıbutuşlarabasarsag değişkenideğişecekveböylece“helloworld!”yazımızfarklırenkleresahipolacak: if q in range(49, 52): g = int(chr(q)) Kullanıcı b tuşuna basarsa, bold değişkeninin değerini 1 - bold yapalım. Böylece bold 0 iken bold 1 olur, bold 1 iken de bold 0 olur. Bu şekilde yukarıda tanımladığımız b listesinin iki elemanınıdaaktifhalegetirmişoluruz: elif q == 98: bold = 1 - bold Kullanıcı “r” tuşuna basarsa, reverse’in değeini 1 - reverse yapalım. Yine aynı şekilde reverse 0 iken reverse 1 olur, reverse 1 iken de reverse 0 olur. Böylece yukarıda tanımladığımız r listesininikielemanınıdaaktifhalegetiririz: 47.8. cursesModülü 1031 PythonBelgeleri,Yayım4.1.3 elif q == 114: reverse = 1 - reverse Eğer kullanıcı w tuşuna basarsa ve y’nin değeri 0’dan büyükse, y değişkeninin değeri 1 birim azaltılsın: if q == ord("w") and y > 0: y -= 1 Şayet kullanıcı s tuşuna basarsa ve y’nin değeri maksimum değerin 1 birim eksiğinden küçükse: elif q == ord("s") and y < boyutlar[0] - 1: Yukarıdaki koşul altında, şayet y, maksimum değerinden 2 birim küçükse ve x’de maksimum değereulaşmışsa,hiçbirişlemyapılmasın: if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"): pass Aksitaktirde,ydeğişkeninindeğeri1birimartırılsın: else: y += 1 Şayet kullanıcı a tuşuna basarsa ve x’in değeri 0’dan büyükse, x değişkeninin değeri 1 birim azaltılsın: elif q == ord("a") and x > 0: x -= 1 Şayetkullanıcıdtuşunabasarsavex’indeğerimaksimumdeğerdenküçükse: elif q == ord("d") and x < boyutlar[1] - len("hello world!"): Yukarıdaki koşul altında, şayet y’nin ve x’in değerleri maksimum değerlerinden 1 birim küçüğüneeşitse,hiçbirişlemyapılmasın: if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1: pass Aksitaktirde,xdeğişkeninindeğeri1birimartırılsın: else: x += 1 Yine bu time.sleep() fonksiyonunun burada neden kullanıldığını görmek için, fonksiyonu yorumaalınvearadakifarkabakın: time.sleep(0.05) Veprogramıyineterminalibozmayacakşekildesonlandıralım: 1032 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 curses.endwin() 47.8.11 Örnek-7: Yöntuşlarıylahareketeden,“1,2,3”tuşlarıylarenklerideğişen,“b”tuşuilekalınlaşıpinceleşen ve“r”tuşuylaarkaplanrengiönplanrengihalinegelenbir“helloworld!”yazısıoluşturalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses import time ekran = curses.initscr() ekran.keypad(1) curses.start_color() curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) curses.noecho() boyutlar = ekran.getmaxyx() ekran.nodelay(1) bold = 0 reverse = 0 b = [curses.A_NORMAL, curses.A_BOLD] r = [curses.A_NORMAL, curses.A_REVERSE] g = 0 q = -1 x, y = 0, 0 while q != ord("q"): ekran.clear() ekran.addstr(y, x, "hello world!", curses.color_pair(g)| b[bold] | r[reverse]) ekran.move(boyutlar[0] -1, boyutlar[1] - 1) ekran.refresh() q = ekran.getch() if q in range(48, 52): g = int(chr(q)) elif q == 98: bold = 1 - bold elif q == 114: reverse = 1 - reverse if q == curses.KEY_UP and y > 0: y -= 1 elif q == curses.KEY_DOWN and y < boyutlar[0] - 1: if y == boyutlar[0] - 2 and x == boyutlar[1] - \ len("hello world!"): (sonrakisayfayadevam) 47.8. cursesModülü 1033 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pass else: y += 1 elif q == curses.KEY_LEFT and x > 0: x -= 1 elif q == curses.KEY_RIGHT and x < boyutlar[1] - len("hello world!"): if y == boyutlar[0] - 1 and x == boyutlar[1] - \ len("hello world!") - 1: pass else: x += 1 time.sleep(0.05) curses.endwin() KodlarınAçıklamaları: Yineörnekuygulamamızdakullanacağımızmodülleriiçeaktaralım: import curses import time Yineönceekranıtanımlayalım: ekran = curses.initscr() Şimdideyöntuşlarınınkullanılabilmesiiçinkeypad()fonksiyonunudeğeriTrueolacakşekilde çağıralım: ekran.keypad(1) Örnek uygulamada renk kullanacağız yine. Bu yüzden renk çiftlerini tanımlamadan önce aşağıdakifonksiyonukesinkullanmamızgerekiyor: curses.start_color() Şimdi3tanerenkçiftioluşturalım: curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK) curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK) Bastığımıztuşlaryineekrandayansımaoluşturmasın: curses.noecho() Ekranınmaksimumxveydeğerlerinialalım: boyutlar = ekran.getmaxyx() Animasyonumuzun ekranda görüntülenmesinin gecikmemesi için yine nodelay()’in parametresini1olarakayarlıyoruz: 1034 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 ekran.nodelay(1) Bu sefer de kalınlaştırma işlemini bir tuş yardımıyla yapacağız. Bunun için bold isimli bir değişkenoluşturalımvedeğerini0yapalım: bold = 0 “helloworld!”yazısınınarkaplanrenginiönplana,önplanrenginiisearkaplanaçevirmekiçin reverseismindebirdeğişkenoluşturalımvedeğerini0yapalım: reverse = 0 b tuşuna basılınca iki ayrı işlem yapılsın: Metin kalınlaştırılmışsa inceltilsin, yok eğer inceltilmişsekalınlaştırılsın.Buişlemiçinbirlisteoluşturalım: b = [curses.A_NORMAL, curses.A_BOLD] Aynı şekilde reverse işlemi için de birbirinin tersi olan değişkenleri barındıran bir liste oluşturalım: r = [curses.A_NORMAL, curses.A_REVERSE] Tanımladığımız renk çiftlerini kullanabilmek için yine g isimli bir değişken kullanacağız ve bu değişkenindeğerini1olarakbelirleyelim: g = 1 Yineekrandakihertuşutemsiledenbirqdeğişkenioluşturalım: q = -1 xvey’ninbaşlangıçdeğerlerinibelirtelim: x, y = 0, 0 Yineqtuşunabasılıncasonlananbirdöngüoluşturalım: while q != ord("q"): Ekranıtemizleyelimyine: ekran.clear() “hello world! yazısını, ilgili tuşlara basılınca aktif hale gelecek biçimlendirme özellikleriyle birlikteekranaekleyelim: ekran.addstr(y, x, "hello world!", curses.color_pair(g) | b[bold] | r[reverse]) İmleciekranınsağaltköşesineyerleştirelim: ekran.move(boyutlar[0] - 1, boyutlar[1] - 1) 47.8. cursesModülü 1035 PythonBelgeleri,Yayım4.1.3 Ekranıtazeleyelim: ekran.refresh() qbütüntuşlarıtemsiletsin: q = ekran.getch() chr(49)’danchr(52)’yekadarolankarakterler1,2ve3’tür.Şayetkullanıcıbutuşlarabasarsag değişkenideğişecekveböylece“helloworld!”yazımızfarklırenkleresahipolacak: if q in range(49, 52): g = int(chr(q)) Kullanıcı b tuşuna basarsa, bold değişkeninin değerini 1 - bold yapalım. Böylece bold 0 iken bold 1 olur, bold 1 iken de bold 0 olur. Bu şekilde yukarıda tanımladığımız b listesinin iki elemanınıdaaktifhalegetirmişoluruz: elif q == 98: bold = 1 - bold Kullanıcı “r” tuşuna basarsa, reverse’in değeini 1- reverse yapalım. Yine aynı şekilde reverse 0 iken reverse 1 olur, reverse 1 iken de reverse 0 olur. Böylece yukarıda tanımladığımız r listesininikielemanınıdaaktifhalegetiririz: elif q == 114: reverse = 1 - reverse Eğerkullanıcıyukarıoktuşunabasarsavey’nindeğeri0’danbüyükse;ydeğişkeninindeğeri1 birimazaltılsın: if q == curses.KEY_UP and y > 0: y -= 1 Şayetkullanıcıaşağıoktuşunabasarsavey’nindeğerimaksimumdeğerin1birimeksiğinden küçükse: elif q == curses.KEY_DOWN and y < boyutlar[0] - 1: Yukarıdaki koşul altında, şayet y, maksimum değerinden 2 birim küçükse ve x’de maksimum değereulaşmışsa,hiçbirşeyyapılmasın: if y == boyutlar[0] - 2 and x == boyutlar[1] - len("hello world!"): pass Aksitaktirde;ydeğişkeninindeğeri1birimartırılsın: else: y += 1 Şayet kullanıcı sol ok tuşuna basarsa ve x’in değeri 0’dan büyükse, x değişkeninin değeri 1 birimazaltılsın: 1036 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 elif q == curses.KEY_LEFT and x > 0: x -= 1 Şayetkullanıcısağoktuşunabasarsavex’indeğerimaksimumdeğerdenküçükse: elif q == curses.KEY_RIGHT and x < boyutlar[1] - len("hello world!"): Yukarıdaki koşul altında, şayet y’nin ve x’in değerleri maksimum değerlerinden 1 birim küçüğüneeşitse,hiçbirşeyyapılmasın: if y == boyutlar[0] - 1 and x == boyutlar[1] - len("hello world!") - 1: pass Aksitaktirdexdeğişkeninindeğeri1birimartırılsın: else: x += 1 Yine bu time.sleep() fonksiyonunun burada neden kullanıldığını görmek için, fonksiyonu yorumaalınvearadakifarkabakın: time.sleep(0.05) Veprogramıyineterminalibozmayacakşekildesonlandıralım: curses.endwin() 47.8.12 Örnek-8: Bu örnekte ekrana hazır bir metin eklemek yerine Türkçe karakterler eklemeye çalışalım. Ve ayrıcaeklediğimizkarakterlerisilmekveyabiraltsatırageçmekiçinyeniişlemlertanımlayalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import curses ekran = curses.initscr() ekran.keypad(1) curses.start_color() curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE) curses.noecho() boyutlar = ekran.getmaxyx() q = -1 x, y = 0, 0 xy = [] karakterler = [] (sonrakisayfayadevam) 47.8. cursesModülü 1037 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def karakter_ekle(karakter, num1, num2): global x, y ekran.addstr(y, x, karakter, curses.color_pair(1)) x += 1 karakterler.remove(num1) karakterler.remove(num2) while q != 27: q = ekran.getch() ekran.refresh() karakterler.append(q) if boyutlar[1] - x == 1: xy.append((y, x - 1)) y += 1 x = 0 if q == 263: if x == 0: if y != 0: y -= 1 try: x = xy[len(xy) - 1][1] xy.pop(len(xy) - 1) except IndexError: x = boyutlar[1] - 1 ekran.delch(y, x) else: pass else: ekran.delch(y, x - 1) x -= 1 elif q == 10: xy.append(curses.getsyx()) ekran.addstr(y, x, chr(10), curses.color_pair(1)) y += 1 x = 0 elif q == 261: if boyutlar[1] - x == 1: y += 1 x = 0 else: x += 1 ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 260: if x == 0: if y != 0: y -= 1 x = 78 else: (sonrakisayfayadevam) 1038 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pass else: x -= 1 ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 259: if y != 0: y -= 1 ekran.addstr(y, x, "", curses.color_pair(1)) else: pass elif q == 258: if y != boyutlar[0] - 1: y += 1 ekran.addstr(y, x, "", curses.color_pair(1)) else: pass elif q == 195: ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 196: ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 197: ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 167: karakter_ekle("\u00e7", 195, 167) elif q == 159: if 196 in karakterler: karakter_ekle("\u011f", 196, 159) elif 197 in karakterler: karakter_ekle("\u015f", 197, 159) elif q == 177: karakter_ekle("\u0131", 196, 177) elif q == 182: karakter_ekle("\u00f6", 195, 182) elif q == 188: karakter_ekle("\u00fc", 195, 188) elif q == 135: karakter_ekle("\u00c7", 195, 135) elif q == 158: if 196 in karakterler: karakter_ekle("\u011e", 196, 158) elif 197 in karakterler: karakter_ekle("\u015e", 197, 158) elif q == 176: karakter_ekle("\u0130", 196, 176) elif q == 150: karakter_ekle("\u00d6", 195, 150) elif q == 156: karakter_ekle("\u00dc", 195, 156) else: (sonrakisayfayadevam) 47.8. cursesModülü 1039 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ekran.addstr(y, x, chr(q), curses.color_pair(1)) x += 1 curses.endwin() KodlarınAçıklamaları: Herzamankigibiöncegereklimodülüprogramıniçineaktarıyoruz: import curses Bildiğinizgibicursesileişlemyapmayageçmedenönceekranıtanıtmamızgerekiyor: ekran = curses.initscr() Bu çalışmada tanımlanmamasına rağmen BACKSPACE gibi bazı özel klavye tuşlarını kullanacağımıziçinöncekeypad()fonksiyonunuçağırmalıyız: ekran.keypad(1) Yinebildiğinizgibiyazılarırenklendirmekiçinöncerenklendiriciyibaşlatmamızgerekiyor: curses.start_color() Şimdibirtektanerenkçiftioluşturalım: curses.init_pair(1, curses.COLOR_RED, curses.COLOR_WHITE) Bastığımız tuşların ekranda yansıma oluşturmaması için curses.noecho() fonksiyonunu kullanalım: curses.noecho() Ekranınmaksimumboyutlarınıbirdeğişkeneatayalım: boyutlar = ekran.getmaxyx() Yinehertuşutemsiledecekqdeğişkenimizitanımlayalım: q = -1 Şimdidesatırvesütundeğeriolarakkullanacağımızdeğişkenleritanımlayalım: x, y = 0, 0 Her bir satırı bir liste içinde tutacağız. Her satırda hangi sütunda kaldığımızı bilmemiz gerekiyorçünkükaraktersilmeişlemindebizelazımolacak: xy = [] Türkçe karakterlerin olduğu tuşlara bastığımız sırada, q’nun 1’den fazla değeri olur. Mesela Enter tuşu için konuşacak olursak karakter değeri 10’dur. elif q == 10: durumunda yapılması gerekeni rahatça belirleyebiliriz. Ama aynı durum Türkçe karakterler için geçerli değildir. Örneğin ç tuşuna basılınca yapılması gereken işlemleri belirtmek için şöyle bir koşul 1040 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 tanımlamamız gerekir: elif q == 196: durumunda bir şey yap. Sonra da elif q == 159: durumunda bir şey yap. Çünkü ç harfine bastığımız zaman iki tane karakter değeri oluşur. Bunlardan birisi 196 diğeri 159’dur. Aynı durum diğer Türkçe karakterler için de geçerlidir. Mesela ı harfine basınca oluşan karakter değerleri 196 ve 177 olur. O halde karakter değerlerinden birisinin 196 olduğu birden fazla tuş var. İşte bu tuş kombinasyonlarını birbirlerindenayırmakiçinbirlistekullanacağız: karakterler = [] Türkçe karakterleri bir fonksiyon yardımıyla ekrana eklemeye çalışalım. Buradaki karakter parametresi, Türkçe harfin unicode kodu; num1 ve num2 parametreleri ise karakterin değerleridir: def karakter_ekle(karakter, num1, num2): Fonksiyonumuzuniçineglobalalandakix,veydeğişkenleriniçekelim: global x, y Globalalandanaldığımızekranaaity,xkonumunakarakteriekleyelim: ekran.addstr(y, x, karakter, curses.color_pair(1)) Her Türkçe karakteri ekledikten sonra, x’in konumunu 1 birim artıralım ki yeni girilecek karakteriçinkullanılabiliryenibirhücreoluşsun: x += 1 Daha sonra da karakterler listesinden bu tuşu temsil eden değerleri silelim ki, bir sonraki Türkçekarakteriekranaeklemekistediğimizdesorunçıkmasın: karakterler.remove(num1) karakterler.remove(num2) Şimdide,ESCtuşunabasılmadığısüreceçalışanbirdöngüoluşturalım: while q != 27: qbütüntuşlarıtemsiletsin: q = ekran.getch() Ekranıtazeleyelim: ekran.refresh() Hertuşabastığımızdakarakterlerlistesineqdeğerieklensin: karakterler.append(q) Eğerbirsatırınsonunagelinmişse,xysatırlistesinebusatırıekleyelim: if boyutlar[1] - x == 1: xy.append((y, x - 1)) 47.8. cursesModülü 1041 PythonBelgeleri,Yayım4.1.3 Aynızamandaydeğişkeninindeğeri1birimartsınkibiraltsatıra,xdeğişkeninindeğeride0’a eşitlensinkisatırbaşınageçelim: y += 1 x = 0 EğerkullanıcıBACKSPACEtuşunabasarsavekoşulaltındaeğerxdeğişkeninindeğeri0’aeşitse: if q == 263: if x == 0: Yukarıdaki her iki koşulun altında eğer y değişkeninin değeri 0’a eşit değilse, y değişkeninin değeri1birimazaltılsın: if y != 0: y -= 1 Ayrıcax’indeğeribiröncekisatırınbittiğixdeğerineeşitlenmeyeçalışılsınvesatırlistesinden biröncekisatırsilinsin: try: x = xy[len(xy) - 1][1] xy.pop(len(xy) - 1) Bu işlem yapılırken bir sıra hatası oluşmasını bekliyoruz, bu durumda x’in değeri maksimum xdeğerineeşitlensin: except IndexError: x = boyutlar[1] - 1 Herhalükardaekranıny,xkonumundanbukaraktersilinsin: ekran.delch(y, x) BACKSPACE tuşuna basıldığı koşulun altında, eğer x değikeninin değeri 0’a eşitse ve eğer y değişkeninindeğeride0’aeşitse,hiçbirişlemyapılmasın: else: pass BACKSPACE tuşuna basıldığı koşulun altında ve eğer x değikeninin değeri 0’a eşit değilse, ekranıny,x-1konumundanbukaraktersilinsinvexdeğişkeninindeğeri1birimazaltılsın: else: ekran.delch(y, x - 1) x -= 1 Eğerkullanıcıentertuşunabasarsa:xysatırlistesineoandakiy,xdeğerleriniekleyelim,ekrana “n” kaçış dizisi eklensin, y değikeninin değeri 1 birim artırılsın ve x değişkeninin değeri 0’a eşitlensinyaniyenisatırınbaşınageçilsin: elif q == 10: xy.append(curses.getsyx()) (sonrakisayfayadevam) 1042 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ekran.addstr(y, x, chr(10), curses.color_pair(1)) y += 1 x = 0 Eğerkullanıcısağoktuşunabasarsavexdeğişkenimaksimumdeğerineulaştıysa,ydeğişkenin değeri1birimartırılsınvexdeğişkeninindeğeri0’aeşitlensin.Yaniyenibirsatırageçilsin.Yok eğerxdeğişkenimaksimumdeğerineulaşmadıysa,xdeğişkeninindeğeri1birimartırılsınve ekranaboşbirstringverisieklensin: elif q == 261: if boyutlar[1] - x == 1: y += 1 x = 0 else: x += 1 ekran.addstr(y, x, "", curses.color_pair(1)) Eğerkullanıcısoloktuşunabasarsa,xdeğişkeninindeğeri0’aeşitseveydeğişkeninindeğeri 0’a eşit değilse, y değişkeninin değeri 1 birim azaltılsın, x değişkeninin değeri 78 olarak ayarlansın, şayet hem x hem de*y* değişkeninin değeri 0’a eşitse hiç bir işlem yapılmasın. x değişkeninin değeri 0’a eşit değilse, x değişkenin değeri 1 birim azaltılsın ve ekranın yx konumunaboşbirstringeklensin: elif q == 260: if x == 0: if y != 0: y -= 1 x = 78 else: pass else: x -= 1 ekran.addstr(y, x, "", curses.color_pair(1)) Eğerkullanıcıyukarıoktuşunabasarsaveydeğişkeninindeğeri0’aeşitdeğilse,ydeğişkeninin değeri 1 birim azaltılsın ve ekranın yx konumuna boş bir string yerleştirilsin. Eğer y değişkeninindeğeri0’aeşitse,hiçbirişlemyapılmasın: elif q == 259: if y != 0: y -= 1 ekran.addstr(y, x, "", curses.color_pair(1)) else: pass Eğer kullanıcı aşağı ok tuşuna basarsa ve y değişkeni maksimum değerine eşit değilse, y değişkeninindeğeri1birimartırılsınveekranınyxkonumunaboşbirstringyerleştirilsin.Eğer ydeğişkeniekranınmaksimumydeğerinegelmişse,hiçbirişlemyapılmasın: elif q == 258: (sonrakisayfayadevam) 47.8. cursesModülü 1043 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) if y != boyutlar[0] - 1: y += 1 ekran.addstr(y, x, "", curses.color_pair(1)) else: pass Aşağıdaki kodlar Türkçe karakterleri eklemekle ilgilidir. Daha önce belirtildiği gibi Türkçe karakterler iki tane karakter değerine sahip oluyor. Dolayısıyla bir karakteri ekledikten sonra okarakterindeğerlerinikarakterlerlistesindenbirkarışılıklıkolmamasıiçinsilmekgerekiyor. Aşağıda tanımlanmış olan 3 koşul da Türkçe karakterlerin 1. değerleridir, bu üç sayısal değerdenbirisibütünTürkçekarakterlerdeortakolarakbulunuyor: elif q == 195: ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 196: ekran.addstr(y, x, "", curses.color_pair(1)) elif q == 197: ekran.addstr(y, x, "", curses.color_pair(1)) Aşağıdaki kodlarda hangi koşullarda ekrana Türkçe karakterlerin ekleneceği tanımlanmıştır. Türkçekarakterlerdoğrudanunicodekarakteriolarakeklenecektir: Küçük“ç”harfinineklenmesinisağlayankoşul: elif q == 167: karakter_ekle("\u00e7", 195, 167) Küçük“ğ”veküçük“ş”harflerinineklenmesinisağlayankoşullar: elif q == 159: if 196 in karakterler: karakter_ekle("\u011f", 196, 159) elif 197 in karakterler: karakter_ekle("\u015f", 197, 159) Küçük“ı”harfininineklenmesinisağlayankoşul: elif q == 177: karakter_ekle("\u0131", 196, 177) Küçük“ö”harfinineklenmesinisağlayankoşul: elif q == 182: karakter_ekle("\u00f6", 195, 182) Küçük“ü”harfinineklenmesinisağlayankoşul: elif q == 188: karakter_ekle("\u00fc", 195, 188) Büyük“Ç”harfinineklenmesinisağlayankoşul: 1044 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 elif q == 135: karakter_ekle("\u00c7", 195, 135) Büyük“Ğ”vebüyük“Ş”harflerinineklenmesinisağlayankoşullar: elif q == 158: if 196 in karakterler: karakter_ekle("\u011e", 196, 158) elif 197 in karakterler: karakter_ekle("\u015e", 197, 158) Büyük“İ”harfinineklenmesinisağlayankoşul: elif q == 176: karakter_ekle("\u0130", 196, 176) Büyük“Ö”harfinineklenmesinisağlayankoşul: elif q == 150: karakter_ekle("\u00d6", 195, 150) Büyük“Ü”harfinineklenmesinisağlayankoşul: elif q == 156: karakter_ekle("\u00dc", 195, 156) Ve son koşulumuzda Türkçe karakterler haricinde herhangi bir karakterin ekrana nasıl eklenmesi gerektiği tanımlanmıştır. Bu koşulda karakter yx konumuna eklenir ve x değişkeninindeğeri1birimartırılır: else: ekran.addstr(y, x, chr(q), curses.color_pair(1)) x += 1 47.8.13 Örnek-9: Buörnektedef,if,elsegibibazıözelkelimelerindiğerkelimelerdenfarklırengesahipolması içinuğraşalım.Örneğindef’idefine’denveya“def”denayırtetmeyeçalışalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import re import curses import keyword ekran = curses.initscr() curses.start_color() curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK) (sonrakisayfayadevam) 47.8. cursesModülü 1045 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK) curses.noecho() q = -1 karakterler = "" while q != ord("q"): q = ekran.getch() ekran.addstr(chr(q), curses.color_pair(1)) karakterler += chr(q) for kw in keyword.kwlist: regex1 = re.search("[^’\"]\s{}\s$".format(kw), karakterler) regex2 = re.search("^{}\s$".format(kw), karakterler) if regex1 or regex2: ekran.addstr("{}{} ".format("\b" * (len(kw) + 1), kw), curses.color_pair(2)) karakterler = "" curses.endwin() KodlarınAçıklamaları: Buörnektekullanacağımızmodülleriprogramıniçineaktaralım: import re import curses import keyword Herzamankigibiekranıtanıtıyoruz: ekran = curses.initscr() Renklendirmeişleminegeçmedenöncebildiğinizgibirenkbaşlatıcıyıçalıştırıyoruz: curses.start_color() BuörnektebirçiftPython’aözgüözelkarakterleriçin,birçiftdediğerkarakterleriçintoplam ikiçiftrenktanımlayalım: curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK) curses.init_pair(2, curses.COLOR_BLUE, curses.COLOR_BLACK) Karakterlerinekrandayansımasınıistemiyoruzdiyelim: curses.noecho() Herkarakteritemsiledecekbirkarakterseçelim.Vedeğerini-1yapalım(değerininneolduğu buörnektepekönemlideğil): q = -1 Python’a özgü karakterleri diğer karakterlerden ayırt edebilmek için bir tane string verisi oluşturalım: 1046 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 karakterler = "" qdeğişkeninin“q”’yaeşitolmadığıdurumdaçalışacakdöngüyütanımlayalım: while q != ord("q"): qdeğişkeniherkarakteritemsiletsin: q = ekran.getch() Basılanhertuşunkarakteriekrana1.sıradakirenklebirlikteeklensin: ekran.addstr(chr(q), curses.color_pair(1)) Eklenenherbirkarakter,karakterlerdeğişkeninedeeklensin: karakterler += chr(q) keyword.kwlist listesi içindeki Python’a özgü her bir özel ifade için, iki tane düzenli ifade oluşturalım: for kw in keyword.kwlist: regex1 = re.search("[^’\"]\s{}\s$".format(kw), karakterler) regex2 = re.search("^{}\s$".format(kw), karakterler) Eğeryazdığımızyazıregex1’eveyaregex2’yeuyuyorsa,ekranabuyazıfarklıbirrenkleyazılsın. Buradaki “b” * (len(kw) + 1) kod parçası kw ile temsil edilen kwlistteki her bir özel ifadeden sonra yeni eklenecek karakterin nereye eklenmesi gerektiğini belirtir. Mesela kwlistteki üç harflikbirözelifadeiçin4.hücreyeyenibirkaraktereklenmesinisağlar.Eğerbukodparçasını yazıyıekranaeklerkenyazmazsak,yenieklenenkarakterler,özelkarakterlerinüzerineyazılır: if regex1 or regex2: ekran.addstr("{}{} ".format("\b" * (len(kw) + 1), kw), curses.color_pair(2)) Ve karakterler stringimizin değerini boş bir string verisine eşitleyelim ki bir sonraki karakter içintekrarkullanabilelim: karakterler = "" Ve son olarak program kapandığında terminali eski haline getirmek için curses.endwin() fonksiyonumuzuçağıralım: curses.endwin() 47.8. cursesModülü 1047 PythonBelgeleri,Yayım4.1.3 47.9 threading Modülü KaynakKodu:https://hg.python.org/cpython/file/3.5/Lib/threading.py Bu modül; düşük seviyeli _thread modülü üzerine, yüksek seviyeli iş parçacığı yürütüm ara yüzleriinşaeder.Ayrıcaqueuemodülünedebakınız. dummy_threading modülü, _thread’in kayıp olmasından ötürü threading’in kullanılamadığı durumlariçinsağlanmıştır. Not: Aşağıda listelenmemişken, Python 2.x serilerindeki bu modülün bazı metotlarının ve fonksiyonlarınınkullandığıcamelCaseisimlerhalabumodültarafındandesteklenmektedir. Bumodülaşağıdakifonksiyonlarıtanımlar: threading.active_count() Hazırçalışmaktaolanişparçacığı(Thread)nesnelerininsayısınıgeridöndürür.Geri dönendeğerenumerate()tarafındandöndürülenlisteninuzunluğunaeşittir. threading.current_thread() Çağıranınkontroldizesinekarşılıkgelenişparçacığınesnesinigeridöndürür.Eğer çağıranınkontroldizesithreadingmodülüvasıtasıylaoluşturulmamışsa,işlevselliği sınırlandırılmışbirkukla(dummy)işparçacığı(thread)nesnesigeridöndürülür. threading.get_ident() Şimdiki iş parçacığının (Thread’in) iş parçacığı tanımlayıcısını (thread identifier’ı) geri döndürür. Bu, sıfır olmayan bir tam sayıdır. Değerinin doğrudan bir anlamı yoktur; sihirli bir çerez olarak kullanılmak üzere tasarlanmıştır, örneğin iş parçacıklarınaözgüverilerdenoluşanbirsözlüğüdizinlemekiçin. Sürüm3.3.’degelmiştir. threading.enumerate() Hazır çalışmakta olan bütün iş parçacığı (Thread) nesnelerinin listesini geri döndürür. Liste daemonic (kullanıcının doğrudan kontrolünde olmayıp arka plandaçalışan)işparçacıklarını,current_thread()tarafındanoluşturulmuşdummy (kukla) iş parçacıklarını ve ana iş parçacığını içerir. Listeye sonlandırılmış iş parçacıklarıvehenüzbaşlatılmamışişparçacıklarıdâhiledilmez. threading.main_thread() Ana iş parçacığı (main-thread) nesnesini geri döndürür. Normal durumlarda, ana işparçacığıPythonyorumlayıcısıtarafındanbaşlatılmışolanişparçacığıdır. Sürüm3.4.’degelmiştir. threading.settrace(func) Threading modülünden başlatılan bütün iş parçacıkları için bir tane izleyici fonksiyon ayarlar. Func yazan yere, her bir iş parçacığı için, run() metodu çağrılmadanönce,sys.settrace()gelecektir. threading.setprofile(func) Threading modülünden başlatılan bütün iş parçacıkları için bir tane kesit fonksiyonu ayarlar. Func yazan yere, her bir iş parçacığı için, run() metodu çağrılmadanönce,sys.setprofile()gelecektir. 1048 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 threading.stack_size([size]) Yeni iş parçacıkları oluştururken, kullanılan iş parçacığı yığın boyutunu geri döndürür. Seçeneğe bağlı olan size argümanı daha sonradan oluşturulacak iş parçacıklarıiçinyığınboyutunubelirtirve-platformkullanımındaveyaöntanımlı ayarolarak-değeri0veya32,768(32KiB)’denbüyükpozitifbirtamsayıolmalıdır. Eğer size argümanı tanımlanmazsa, değeri 0 olur. Eğer iş parçacığının yığın boyutunun değiştirilmesi desteklenmezse, bir RuntimeError hatası yükseltilir. Eğer tanımlanmış yığın boyutu geçersiz ise, ValueError hatası yükseltilir ve yığın boyutudeğiştirilmemişolur.32KiB,yorumlayıcıyayeterliyığınalanıteminetmek için yığın boyutunun desteklenen geçerli minimum değeridir. Bazı platformların, yığın boyutunun değeri üzerinde, kendilerine özgü bir takım sınırlamaları vardır. Örneğinyığınboyutunun32KiB’denbüyükolmasınıngerekliliğiveyasistemhafıza sayfası boyutunun katlarının paylaştırılmasının gerekliliği gibi - platform belgesi daha fazla bilgi vermesi için referans gösterilebilir - (4 KiB’lik sayfalar yaygındır; yığınboyutunun4096’nınkatlarıolarakkullanılması,dahaözelbilgilerinolmaması durumundaönerilenbiryaklaşımdır.)Kullanılabilenplatformlar:Windows,POSIX işparçacığıileçalışansistemler. Bumodülayrıcaaşağıdakisabitidetanımlar: threading.TIMEOUT_MAX Lock.acquire(),RLock.acquire(),Condition.wait()vb.gibiengelleyicifonksiyonların zamanaşımıparametreleriiçinmaksimumdeğereizinverilir. Sürüm3.2’degelmiştir. Bumodülaşağıdakikısımdaayrıntılarıverilenbirkaçsınıfıtanımlar. BumodülüntasarımıyaklaşıkolarakJava’nınthreadingmodeliüzerinetemellenmiştir.Ancak bununla birlikte, Java’daki her nesnenin temel davranışında olan kilit ve durum değişkenleri, Python’daayrınesnelerdir.Python’dakiThreadsınıfıJava’dakiThreadsınıfınındavranışınıbir altsetolarakdestekler;şimdiliknebiröncelik,nebirişparçacığıgrubuvardır.İşparçacıkları yok edilemez, durdurulamaz, yasaklanamaz, devam ettirilemez ve sonlandırılamaz. Java’nın Threadsınıfınınstatikmetotları,uygulandığında,modüldüzeyindekifonksiyonlarlaeşleştirilir. Aşağıdaaçıklanmışmetotlarınhepsiotomatikolarakçalıştırılır. 47.9.1 Yerel İş Parçacığı (Thread-Local) Verisi Yerelişparçacığı(thread-local)verisi,değeriişparçacığıolarakbelirlenmişbirdeğerdir.Yerel iş parçacığı verisini yönetmek için, sadece yerel sınıftan (veya bir alt sınıftan) bir tane örnek oluşturulurveözelliklerbusınıftatutulur: yerel_veri = threading.local() yerel_veri.x = 1 Ayrıişparçacıklarıiçinörneğindeğerideğişikolacaktır. classthreading.local Yerelişparçacığıverisinitemsiledensınıftır. Dahafazlaayrıntıvegenişörnekleriçin,_threading_localmodülününbelgedizisine bakın. 47.9. threadingModülü 1049 PythonBelgeleri,Yayım4.1.3 47.9.2 İş Parçacığı (Thread) Nesneleri İş parçacığı (thread) sınıfı, ayrı iş parçacıklarını kontrol eden bir etkinliği temsil eder. Bu etkinliğibelirtmekiçinikiyolvardır:yapıcıya,çağrılabilirbirnesneatamakveyabiraltsınıfta run() metodunu iptal etmek. Yapıcı dışında hiçbir metot bir alt sınıfta iptal edilmemelidir. Başkabirdeyişle,busınıfınsadece__init__()verun()metotlarıiptaledilir. Bir iş parçacığı (thread) nesnesi oluşturulduğunda, bu nesnenin etkinliği, iş parçacığının start() metodu çağrılarak başlatılmalıdır. Bu ayrılmış bir iş parçacığının kontrolündeki run() metodunuçalıştırır. Bir iş parçacığı (thread) başlatıldığında, iş parçacığı ‘canlanmış’ olarak kabul edilir. Normalde bu iş parçacığının run() metodu sonlandığında, iş parçacığının canlılığı da sonlanır - veya yürütülemeyenbirbeklentiyükseltilir-.İşparçacığınıncanlıolupolmadığınıis_alive()metodu testeder. Diğer iş parçacıkları, bir iş parçacığının join() metodunu çağırabilir. Bu metot, çağrılan iş parçacığını,join()metoduçağrılanişparçacığısonlanakadarengeller. Bir iş parçacığının bir ismi vardır ve ismi yapıcıya atanabilir ve ‘name’ özelliği vasıtasıyla okunabilirveyadeğiştirilebilir. Bir iş parçacığı daemon iş parçacığı (=daemon thread) olarak işaretlenir. Bu işaretin önemi, sadece daemon iş parçacığı kaldığında bütün Python programının sonlanmasıdır. İşaretin başlangıç değeri, oluşturulmuş olan iş parçacığından miras alınır. İşaret, daemon özelliği (property)veyadaemon’unyapıcıargümanıtarafındanayarlanabilir. Not:Daemonişparçacıklarıbilgisayarkapatıldığındaanibirşekildesonlanır.Açılmışdosyalar, veritabanı hareketleri gibi birçok kaynak, düzgün bir şekilde serbest bırakılmayabilir. Eğer iş parçacıklarının düzgün bir şekilde durmasını istiyorsanız, onları non-daemonic (daemonic olmayacakşekilde)ayarlayınveEventgibiuygunbirsinyalmekanizmasıkullanın. Python programında bir tane ana iş parçacığı (main-thread) nesnesi vardır ve bu nesne başlangıçtaki iş parçacığının kontrol edilmesine yarar. Bu nesne bir daemon iş parçacığı değildir. Kukla iş parçacığı nesnelerinin (dummy thread objects) oluşturulma ihtimali vardır. Bunlar yabancı olarak kabul edilebilecek, kontrolleri threading modülünün dışında olan C kodları gibi iş parçacıklarıdır. Kukla iş parçacıklarının sınırlı işlevsellikleri vardır; daima canlı ve daemonic özelliktedirler ve join() ve diğerleri ile kullanılamazlar. Yabancı iş parçacıklarının sonlandırılmalarınınsaptanmasınınimkânsızolduğusüreceaslasilinemezler. class.threading.Thread(group=None,target=None,name=None,args=(),kwargs={},*, daemon=None) Bu yapıcı her zaman anahtar kelime argümanlarıyla birlikte çağrılmalıdır. Argümanlarşunlardır: group: Değeri, None olmalıdır. ThreadGroupClass uygulandığında, gelecektekigenişletmeiçinsaklanır. target: Değeri, run() metodu tarafından çalıştırılan, çağrılabilir bir nesnedir. Değeri ön tanımlı olarak None olur ve değeri None olursa hiçbirşeyinçağrılmayacağıanlamınagelir. name: İş parçacığının ismidir. Ön tanımlı değeri özel olarak “Thread-N” biçiminden yapılmıştır. Buradaki N’nin değeri küçük ondalıkbirsayıdır. 1050 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 args:Hedefinyürütülmesiiçindemetveritipindebirargümandır.Ön tanımlıolarakboşbirdemetverisidir. kwargs: Hedefin yürütülmesi için sözlük veri tipinde bir anahtar kelimeargümanıdır.Öntanımlıolarakboşbirsözlükverisidir. daemon:EğerdeğeriNonedeğilse,daemon,birişparçacığınınbariz birşekildedaemonicolupolmadığınıayarlar.Şayetdeğeriöntanımlı olarakbırakılırsa(yanideğeriNoneolursa),daemonicözellikoandaki aktifişparçacığındanmirasalınır. Eğer bir alt sınıf yapıcıyı iptal ederse, iş parçacığı ile bir işlem yapmadan önce, temel sınıfın yapıcısının (Thread.__init__()’in) çalıştırılmışolduğundaneminolunmasıgerekir. Sürüm3.3.’dedeğiştirildi.Daemonargümanıeklendi. start() İşparçacığınınetkinliğinibaşlatır. Herbirişparçacığıiçinbirkezçağrılmasıgerekir.Ayrılmışişparçacığı kontrolüiçinde,run()metodununçalıştırılmasınıayarlar. Bir iş parçacığı için, bu metot birden çok çağrıldığında, bir RuntimeErrorhatasıyükseltir. run() İşparçacığınınetkinliğinitemsileder. Bu metodu, bir alt sınıfta iptal edebilirsiniz. Standart run() metodu, target argümanı olarak bilinen nesnenin yapıcısına atanmış çağrılabilir nesneyi, varsa args ve kwargs* argümanlarından alınan ardışıkveanahtarkelimeliargümanlarlabirliktesırasıylaçalıştırır. join(timeout=None) İş parçacığı sonlana kadar bekler. Bu; join() metodu çağrılan iş parçacığıyanormalolarak,yayürütülemeyenbirbeklentivasıtasıyla yadaseçeneğebağlızamanaşımıgerçekleşipsonlanakadar,çağrılan başkabirişparçacığınıblokeeder. timeout (zaman aşımı) argümanı hazır olduğunda ve değeri None olmadığında, işlemin zaman aşımını saniye olarak belirten, kayan noktalı bir sayı olmalıdır. join() her zaman None değerini geri döndürdüğü için, bir zaman aşımının gerçekleşip gerçekleşmediğine kararvermekiçinjoin()sonrasındais_alive()metodunuçağırın.Şayet işparçacığıhalencanlıise,join()’inçağrılmasızamanaşımınauğrar. timeout argümanı hazır olmadığında ve değeri None olmadığında, işlem,işparçacığısonlanakadarblokeolacaktır. Birişparçacığıiçinbirçokkezjoin()metoduçağrılabilir. Bir girişim, hali hazırdaki iş parçacığını bir çıkmaza sokarsa, join() metodu bir RuntimeError hatası yükseltir. Aynı hata, bir iş parçacığı başlatılmadanöncejoin()metoduçağrılırsadayükseltilir. Name 47.9. threadingModülü 1051 PythonBelgeleri,Yayım4.1.3 Sadece tanımlama amaçları için bir karakter dizisi (string) kullanılır. Bir anlamı yoktur. Çoklu iş parçacıklarına aynı isim verilebilir. Başlangıçismiyapıcıtarafındanayarlanır. getName() setName() İsim için eski program uygulama ara yüzü alıcısı/ayarlayıcısı. Name özelliği(property)yerinedoğrudanbunukullanın. ident İş parçacığının tanıtlayıcısıdır veya eğer bir iş parçacığı başlatılmamışsadeğeriNone’dır.Değerisıfırolmayanbirtamsayıdır. Daha fazla bilgi için _thread.get_ident() fonksiyonuna bakın. İş parçacığı tanıtlayıcıları, bir iş parçacığı sonlandığında ve başka bir tanesi oluşturulduğunda geri dönüştürülebilir. İş parçacığı sonlandıktansonrabiletanıtlayıcıkullanılabilir. is_alive() Birişparçacığınınaktifolupolmadığınınöğrenilmesinisağlar. Bumetot;run()metodununbaşlamasındanönceverun()metodunun sonlanmasınakadarTruedeğerinigeridöndürür.enumerate()modül fonksiyonubütüncanlıişparçacıklarınınbirlistesinigeridöndürür. daemon Birişparçacığının,birdaemonişparçacığıolupolmadığınınbelirleyen bir boolean (True veya False) değeridir. Bu özellik start() metodu çağrılmadan önce ayarlanmalıdır aksi halde bir RuntimeError hatası yükseltilir. Başlangıçtaki değeri, oluşturulan iş parçacığından miras alınır;anaişparçacığıbirdaemonişparçacığıdeğildir,böyleceanaiş parçacığı içinde oluşturulan bütün iş parçacıklarının daemon değeri öntanımlıolarakFalseolur. Geriye, cansız, daemon olmayan iş parçacıkları kaldığında, bütün Pythonprogramısonlandırılır. isDaemon() setDaemon() Daemonuneskialıcı/ayarlayıcıprogramuygulamaarayüzü;birözellik olarakkullanmakyerinedoğrudanbunukullanın. CPython Uygulaması Hakkında Ayrıntı: CPython’da, Global Yorumlayıcı Kilidinden (Global Interpreter Lock) ötürü yalnızca bir adet iş parçacığı bir kere Python kodunu çalıştırabilir (belirli performans odaklı kütüphanelerin bu kısıtlamanın üstesinden gelmesine rağmen). Eğer uygulamanızın çok çekirdekli makinelerin hesaplama kaynaklarından daha fazla yararlanmasını istiyorsanız multiprocessing’i veya concurrent.futures.ProcessPoolExecutor’u kullanmanız tavsiye edilir. Yine de çoklu girdi/çıktı görevlerini eş zamanlı olarak çalıştırmak istiyorsanız,threadingbununiçinhalenuygunbirmodeldir. 1052 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.9.3 Lock (Kilit) Nesneleri Birilkelkilit,kilitlendiğindebelirlibirişparçacığınaaitolmayan,bireşzamanlamailkelidir.Bu kilit, Python’da, doğrudan _thread uzantı modülünden uyarlanan, hali hazırda kullanılabilir olanendüşükseviyedekieşzamanlamailkelidir. Bir ilkel kilitin “kilitli (=locked)” ve “kilitli değil (=unlocked)” olmak üzere iki tane durumu vardır. Bu kilit oluşturulurken “kilitli değil” durumundadır. Kilidin iki tane temel metodu vardır;acquire()verelease().Kilidindurumu“kilitlideğil”olduğunda,acquire()durumu“kilitli” hale çevirir ve acil olarak geri döndürülür. Kilidin durumu “kilitli” olduğunda, bir başka iş parçacığında release() çağrılıp, durumu “kilitli değil” şeklinde değiştirene kadar, acquire() iş parçacığını bloke eder, daha sonra acquire() çağrısı kilidi “kilitli” şeklinde sıfırlar ve geri döndürür.release()metodu,kilitsadece“kilitli”durumdaikençağrılmalıdır;bumetot,kilidin durumunu “kilitli değil” diye değiştirir ve acil olarak geri döndürülür. Şayet bir girişim kilitli olmayanbirkilidiserbestbırakmayaçalışırsa,biradetRuntimeErrorhatasıyükseltilir. Kilitlerayrıcaiçerikyönetimprotokolünüdedesteklerler. Birden fazla iş parçacığı acquire() ile bloke edilip, kilit durumlarının “kilitli değil” şeklinde değişmesi beklendiğinde, sadece bir iş parçacığının kilidi, release() çağrısıyla “kilitli değil” durumuna getirilir; bekleyen iş parçacıklarından hangisinin getirileceği tanımlı değildir ve uygulamalarabağlıolarakdeğişiklikgösterebilir. Tümmetotlarotomatikolarakyürütülür. Classthreading.Lock Sınıf,ilkelkilitnesneleriniuyarlar.Birkezbirişparçacığınakilitkazandırıldığında, sonrakigirişimler,kilitserbestbırakılanakadar,işparçacığınıblokeeder;herhangi birişparçacığıkilidiserbestbırakabilir. Sürüm3.3.’dedeğiştirildi.Kurucufonksiyondanbirsınıfadeğiştirildi. acquire(blocking=True,timeout=-1) Bloklayanveyabloklamayanbirkilitkazandırır. blocking argümanı True olarak (ön tanımlı değerdir) çağrıldığında, kilit serbest bırakalana kadar iş parçacığını bloke eder ve sonra kilidi tekrar “kilitli”konumagetirirveTruedeğerinigeridöndürür. blockingargümanıFalseolarakçağrıldığında,işparçacığınıblokeetmez. Şayetbirçağrıblocking’iTrueolarakayarlarsa,işparçacığınıblokeeder ve acil olarak False değerini geri döndürür; diğer türlü, kilidi “kilitli” durumagetirirveTruedeğerinidöndürür. Kayan noktalı timeout (zaman aşımı) argümanı pozitif bir değer alarak çağrıldığında, en çok timeout argümanında belirtilen değere kadar, kilitlenemediğisüreceişparçacığınıblokeeder.timeoutargümanının-1 olması sınırsız bir bekleme süresi olacağını belirtir. Blocking argümanı Falseayarlandığında,birtimeoutargümanıbelirlemekyasaklanmıştır. İş parçacığı başarıyla kilitlenmişse, geri dönen değer True olur, şayet başarıylakilitlenmemişseFalseolur(örneğinzamanaşımınauğramışsa). Sürüm3.2.’dedeğiştirildi.timeoutparametresiyenidir. Sürüm 3.2.’de değiştirildi. Kilitleme POSIX’te sinyaller tarafından şimdi iptaledilebilir. 47.9. threadingModülü 1053 PythonBelgeleri,Yayım4.1.3 release() Birkilidiserbestbırakır.Bumetot,kilitlenmişbirişparçacığıhariçheriş parçacığındançağrılabilir. Kilit“kilitli”durumagetirildiğinde,onu“kilitlideğil”şeklindedeğiştirirve geridöndürür.Eğerbaşkaişparçacıkları,kilitlerinin“kilitlideğil”şeklinde değişmelerinibekleyerekblokeedilmişse,ilerlemekiçinkesinolarakbir tanesineizinverin. Kilitliolmayanbirkilitçağrıldığında,birRuntimeErrorhatasıyükseltilir. Bumetotilegeridönenbirdeğeryoktur. 47.9.4 Rlock (Yeniden Girilir Kilit) Nesneleri Bir yeniden girilir kilit, aynı iş parçacığı tarafından bir çok kere kullanıma sokulabilen bir eş zamanlama ilkelidir. Dahili olarak, bu kilit, ilkel kilitlerin kullandığı kilitli/kilitli değil durumuna ilaveten “sahip olunan iş parçacığı” ve “recursion (öz yineleme)” kavramlarını kullanır.Kilitlidurumda,bazıişparçacıklarıbukilidesahipolurken;kilitliolmadığıdurumda, hiçbirişparçacığıbukilidesahipdeğildir.Kilidikilitlemekiçin,işparçacığıbukilidinacquire() metodunuçağırır;buişlemişparçacığınınkilidesahipolduğunubirkezgeridöndürür.Kilidi açmak için, iş parçacığı kilidin release() metodunu çağırır. acquire() / release() çağrı çiftleri iç içegeçebilir;sadecesonrelease()çağrısı(endıştakiçağrıçiftindenolanrelease())kilidi“kilitli değil”durumagetirirveacquire()ilebloklanmışdiğerişparçacığınınilerlemesiiçinizinverir. Yenidengirilirkilitlerayrıcaiçerikyönetimprotokolünüdesteklerler. Classthreading.Rlock Busınıfyenidengirilirkilitnesneleriniuygular.Biryenidengirilirkilit,onuedinmiş bir iş parçacığı tarafından serbest bırakılmalıdır. Bir iş parçacığı bir kez yeniden girilir bir kilidi edindiğinde, aynı iş parçacığı kilidi engellemeden tekrar edinebilir; işparçacığı,kilidiheredinmesinekarşılıkbirkezonuserbestbırakmalıdır. Rlock’ın, platform tarafından desteklenen, Rlock sınıfının elle tutulur en etkili versiyonunugeridöndürenbirkurucufonksiyonuolduğununotedin. acquire(blocking=True,timeout=-1) Bloklayanvebloklamayanbirkilitedinin. Argümansız çağrıldığında: Eğer bu iş parçacığı zaten kilide sahipse, öz-yineleme seviyesini 1 derece artırır ve ani bir şekilde geri döndürür. Diğer türlü, eğer başka bir iş parçacığı bu kilide sahipse, kilit çözülene kadar iş parçacığını engeller. Eğer bir kez -hiç bir iş parçacığının sahibi olmadığı- bir kilit açılmışsa, sahibini yakalar, öz-yineleme değerini 1 olarak ayarlar ve geri döndürülür. Eğer birden fazla iş parçacığı kilit açılana kadar engelleniyorsa, her seferinde sadece bir tane iş parçacığı bukilidesahipolacaktır.Budurumdageridönenbirdeğerolmaz. blocking argümanı True olarak ayarlanıp çağrılırsa, argümansız çağrıldığındayaptıklarınınaynısınıyaparveTruedeğerigeridöndürülür. blocking argümanı False olarak ayarlanıp çağrılırsa, iş parçacığını bloke etmez. Eğer argümanı olmayan bir çağrı engellenirse, hızlı bir şekilde 1054 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 False değeri geri döndürülür; diğer türlü, argümansız çağrıldığında yaptıklarınınaynısınıyaparveTruedeğerigeridöndürülür. timeout argümanı pozitif bir kayan noktalı sayı olarak ayarlanıp çağrılırsa, iş parçacığı timeout argümanında belirlenen saniye kadar kiliditekraredinemediğisüreceengellenir.KilitedinilmişseTruedeğerini geridöner,timeoutzamanıdolmuşsaFalsedeğerigeridöner. Sürüm3.2.’dedeğiştirildi.timeoutparametresiyenidir. release() Bir kilidi serbest bırakır, öz yineleme (recursion) seviyesini azaltır. Öz yineleme değeri, azaltımdan sonra sıfır olursa, (hiç bir iş parçacığı tarafından sahip olunmayan) kilidi “kilitli değil” şeklinde sıfırlar ve diğer iş parçacıkları kilidin açılmasını beklemek için engellenirse, bu iş parçacıklarından kesinlikle bir tanesine işlenmesi için izin verir. Eğer öz yineleme seviyesi azaltımdan sonra halen sıfır olmamışsa, kilit “kilitli” durumagelirveçağrılanişparçacığıtarafındansahiplenilir. Bu yöntemi sadece çağrılan iş parçacığı bir kilide sahip olduğu zaman çağırın. Eğer kilit, açık durumda ise, bu yöntemi çağırmak bir RuntimeErrorhatasıyükseltir. Geridönenbirdeğeryoktur. 47.9.5 Condition (Durum) Nesneleri Bir durum değişkeni her zaman bir kilitle ilişkilidir; bu değişken içeri aktarılabilir veya varsayılan olarak bir tane oluşturulabilir. Bir tanesini içeri aktarmak, bir kaç durum nesnesi aynıkilidiortaklaşakullandığındakullanışlıdır.Kilit,durumnesnesininbirparçasıdır:onuayrı olarakizleyemezsiniz. Bir durum nesnesi, içerik yönetim protokolüne uyar: Ekli engelleme süresi için durum değişkenini with deyimi ile birlikte kullanmak ilgili kilidi elde edilmesini sağlar. acquire() ve release()yöntemleriayrıcabahsigeçenkilitleilgiliolanyöntemleriçağırır. Diğer yöntemler tutulan kilitle birlikte çağrılmalıdır. wait() yöntemi kilidi serbest bırakır ve sonra iş parçacığı onu notify() veya notify_all() ile çağırıp uyandırana kadar, iş parçacığını engeller.Birkezuyandırıldığında,wait()onuyenidenedinirvegeridöndürür.Ayrıcabirzaman aşımısüresibelirlemekdemümkündür. notify()yöntemi,eğerişparçacıklarınınherhangibiribekliyorsa,durumdeğişkeninibekleyen iş parçacıklarından birisini uyandırır. notify_all() yöntemi ise durum değişkenini bekleyen bütünişparçacıklarınıuyandırır. Not:notify()venotify_all()yöntemlerikilitleriserbestbırakmaz;bu,notify()veyanotify_all()’u çağırmış ve sonunda kilidin sahiplğinden feragat eden bir iş parçası veya iş parçacıkları uyandırıldığında,wait()çağrısıileacilolarakgeridöndürülmeyeceklerianlamınagelir. Durumnesnelerikullanantipikprogramlamastillindekilit,bazıpaylaşılandurumlaraerişimi senkronizeetmekiçinkullanılır;belirlidurumdeğişimleriyleilgiliolanişparçacıkları,notify() veya notify_all()’u çağırırken, bekleyenler için olası istenilen bir duruma göre durumu değiştirdiklerinde, istenen durumu görene kadar tekrar tekrar wait() yöntemini çağırır. Örneğin; takip eden kod, sınırsız bir tampon kapasitesine sahip genel bir üretici-tüketici durumudur: 47.9. threadingModülü 1055 PythonBelgeleri,Yayım4.1.3 ’ # Bir item i tüketir with cv: while not an_item_is_available(): cv.wait() get_an_available_item() ’ # Bir item i üretir with cv: make_an_item_available() cv.notify() while döngüsü uygulamanın durumunu kontrol etmek için gereklidir, çünkü wait() keyfi olarak uzun bir sürede geri dönebilir ve notify() çağrısını bildiren koşul, hiç bir zaman doğru olmayabilir. Bu çoklu iş parçacığı programlamaya özgü bir durumdur. wait_for() yöntemi durum kontrolünü otomatik hale getirmek ve zaman aşımı hesaplamalarını kolaylaştırmak içinkullanılır: ’ # Bir item i tüketir with cv: cv.wait_for(an_item_is_available) get_an_available_item() Sadece bir veya bir kaç bekleyen iş parçacığının, durum değişmesiyle ilgili olup olmamadıklarına göre notify() ve notify_all() arasında seçim yapın. Örneğin, tipik bir üretici-tüketici durumunda, bir itemi tampona eklemek sadece bir tüketici iş parçacığının uyandırılmasınıgerektirir. classthreading.Condition(lock=None) Bu sınıf durum değişkeni nesnelerini sağlar. Bir durum değişkeni bir veya birden çok iş parçacığının, başka bir iş parçacığı tarafından onaylanana kadar, beklemesineizinverir. Eğer lock argümanı veriliyse ve değeri None değilse, bir Lock veya RLock nesnesi olmalıdır ve temel kilit olarak kullanılmalıdır.Diğer türlü, yeni bir RLock nesnesi oluşturulurvetemelkilitolarakkullanılır. Sürüm3.3’dedeğiştirildi:Kurucufonksiyondanbirsınıfadeğiştirildi. acquire(*args) Temel kilidi edinir. Bu yöntem temel kilit üzerinde ilgili yöntemi çağırır; geridönendeğer,yöntemneyigeridöndürüyorsaoolur. release() Temelkilidiserbestbırakır.Buyöntemtemelkilitüzerindeilgiliyöntemi çağırır;geridönenbirdeğeriyoktur. wait(timeout=None) Onaylanana veya zaman aşımına uğrayana kadar bekler. Eğer çağıran iş parçacığı bu kilidi edinmemişse, bu yöntem çağrıldığında bir RuntimeErrorhatasıyükseltilir. Buyöntemtemelkilidiserbestbırakırvesonrabaşkabirişparçacığının 1056 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 içindeki aynı durum değişkeni için notify() veya notify_all() çağrısı tarafından uyandırılana kadar veya seçime bağlı zaman aşımı gerçekleşene kadar iş parçacığını engeller. Bir kez uyandırıldığında veyazamanaşımınauğradığında,kilidiyenidenedinirvegeridöndürür. timeout argümanı belirlenmiş ve değeri None olmadığında, değeri, işlemin zaman aşımı süresini saniyelerle belirten kayan noktalı bir sayı olmalıdır. Temel kilit RLock olduğunda, release() yöntemi kullanılarak serbest bırakılamaz, çünkü bu durum birden çok kez öz yinelemeli olarak elde edildiğinden kilidi açmaz. Bunun yerine, RLock sınıfının iç arayüzü, öz yinelemeliolarakbiçokdefaeldeedilsebilegerçektenkitler.Sonradiğer bir iç arayüz, kilit yeniden edinildiğinde ön yineleme seviyesini yeniden düzenlemekiçinkullanılır. Belirlibirzamanaşımınauğramadığısürece,geridönendeğerTrueolur, budurumdaisegeridönendeğerFalseolur. Sürüm 3.2’de değiştirildi: Önceden yöntem hep None değerini geri döndürüyordu. wait_for(predicate,timeout=None) Bir durum doğru değerlendirene kadar bekler, predicate (=yüklem) sonucu bir boolean değer olarak yorumlanacak olan, çağrılabilir bir şey olmalıdır. timeout argümanı maksimum bekleme zamanı olarak sağlanmıştır. Bu araç yöntemi wait()’i yüklem sağlanana kadar veya zaman aşımı oluşana kadar tekrar tekrar çağırabilir. Geri dönen değer yüklemin son geri dönen değeridir ve yöntem zaman aşımına uğrarsa False olarak değerlendirilir. timeoutözelliğiniyoksaymak,buyöntemiçağırmakkabacaaşağıdakini yazmaklaeşdeğerdir: while not predicate(): cv.wait() Bu yüzden, aynı kural wait() ile aynı şekilde kullanılır: Kilit çağrıldığında tutulur ve geri döndürmede yeniden elde edilir. Yüklem, tutulan kilit ile değerlendirilir. Sürüm3.2’degelenyenibirözellik. notify(n=1) Ön-tanımlıolarak,varsabudurumubekleyenbirişparçacığınıuyandırır. Eğer çağrılan iş parçacığı bu yöntem çağrıldığında daha önce kilidi edinmemişse,birRuntimeErrorhatasıyükseltilir. Bu yöntem en fazla n tane durum değişkenini bekleyen iş parçacığını uyandırır;hiçbirişparçacığıbeklemiyorsa,işlemyapılmaz. Hali hazırdaki uygulama, eğer en az n tane iş parçacığı bekliyorsa, kesinliklentaneişparçacığınıuyandırır.Ancak,budavranışagüvenmek 47.9. threadingModülü 1057 PythonBelgeleri,Yayım4.1.3 pekgüvenilirdeğildir.İleride,iyileştirilmişbiruygulamazamanzamann tanedenfazlaişparçacığıuyandırabilir. Not: Uyandırılmış bir iş parçacığı, kilidi yeniden elde edinceye kadar wait() tarafından geri dönmez. notify() kilidi serbest bırakmıyorsa, çağıranıserbestbırakmalıdır. notify_all() Bu durumu bekleyen bütün iş parçacıklarını uyandırır. Bu yöntem notify() gibi davranır, fakat bir tanesi yerine, bekleyen bütün iş parçacıklarını uyandırır. Eğer bu yöntem çağrıldığında, çağıran iş parçacığı kilidi daha önce edinmemişse, bir RuntimeError hatası yükseltilir. 47.9.6 Semaphore Nesneleri Bu, bilgisayar bilimi tarihindedeki en eski senkronizasyon ilkellerinden biridir, Hollandalı bilgisayar bilimcisi Edsger W. Dijkstra tarafından icat edilmiştir (acquire() ve release() yerine P()veV()isimlerinikullanıyordu.). Bir semafor, her acquire() çağrısında azaltılan ve her release() çağrısında artırılan içsel bir sayacı yönetir. Sayaç sıfırın altına hiç bir zaman inemez; acquire() bu sayacın sıfır olduğunu bulursa,işparçacığınıbaşkabirişparçacığırelease()’içağıranakadarengeller. Semaforlarayrıcaiçerikyönetimprotokülünüdesteklerler. classthreading.Semaphore(value=1) Busınıfsemaforenesneleriniuygular.Birsemaforrelease()’inçağrılmasayısından, acquire()’in çağrılma sayısını çıkartan ve bir başlangıç değerini eklemekle temsil edilen bir sayacı yönetir. acquire(), sayacı negatif bir sayı yapmadan geri döndürene kadar, eğer gerekliyse iş parçacığını engelleyebilir. Eğer verili değilse, valueargümanınındeğeriön-tanımlıolarak1’dir. Seçeneğe bağlı argüman, iç sayacın başlangıc değerini verir; ön-tanımlı olarak değeri1’dir.Eğervalueargümanınındeğerine1’denazbirsayıverilirse,ValueError hatasıyükseltilir. Sürüm3.3’dedeğiştirildi.Kurucufonksiyondanbirsınıfadeğiştirildi. acquire(blocking=True,timeout=None) Birsemaforeldeeder. Argümanlar olmadan çağrıldığında: eğer iç sayaç girişte sıfırdan büyükse, onu bir birim azaltır ve acilen geri döner. Eğer girişte değeri sıfır ise, başka bir iş parçacığı release()’i çağırıp değerini sıfırdan daha büyük bir sayı yapana kadar, engeller. Bu uygun bir kilitleyici ile birlikte yapılır böylece bir çok acquire() çağrıları engellenir, release() bunlardan kesinlikle bir tanesini uyandıracaktır. Uygulama bir tanesini rastgele seçer, böylece engellenmiş iş parçacıkları uyandırıldığında oluşan düzene güvenmemek gerekir. True değeri geri döner (veya süresizolarakengeller). blocking argümanı False olarak ayarlanmış bir şekilde çağrılırsa, iş parçacığını engellemez. Eğer argümansız bir çağrı iş parçacığını 1058 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 engellerse, acil olarak False değerini geri döndürür; diğer türlü, argümansız olarak çağrıldığının aynısını yapar ve True değerini geri döndürür. timeout argümanı None’dan farklı bir şey olacak şekilde çağrılırsa, en fazla timeout argümanındaki belirtilen saniye kadar iş parçacığını engeller.Eğerbuaradaeldeetmebaşarılıbirşekildetamamlanmamışsa, Falsedeğerinigeridöndürür.Diğertürlü,Truedeğerinigeridöndürür. release() Bir semaforu serbest bırakır, iç sayacı bir birim artırır. Girişte sıfır olduğundavediğerbirişparçacığı,sayacıntekrarsıfırdanbüyükbirsayı olmasınıbeklediğinde,buişparçacığınıuyandırır. classthreading.BoundedSemaphore(value=1) Busınıf,bağlanmışsemafornesnesiniuygular.Bağlanmışsemafor,halihazırdaki değerin, ilk değeri aşmadığından emin olmak için kontrol eder. Eğer aşmışsa, ValueError hatası yükseltilir. Bir çok durumda semaforlar sınırlı kapasiteli kaynakları korumak için kullanılır. Eğer semafor birden fazla kez serbest bırakılmışsa, bu bir bug olduğuna işarettir. Eğer verili değilse, value argümanının ön-tanımlıdeğeri1’dir. Sürüm3.3’dedeğiştirildi.Kurucufonksiyondansınıfadeğiştirildi. SemaforÖrneği Semaforlar genellikle sınırlı kapasiteli kaynakları korumak için kullanılır, örneğin, bir veritabanı sunucusunda. Kaynağın boyutunun sabit olduğu hangi durumda olursa olsun, bağlanmış bir semafor kullansanız iyi olur. Çalışan iş parçacıklarını oluşturmadan önce, ana işparçacığınızsemaforubaşlatacaktır: maxconnections = 5 # ... pool_sema = BoundedSemaphore(value=maxconnections) Bir kez oluşturulduğunda, çalışan iş parçacıkları semafor’un acquire() ve release() yöntemlerini,sunucuyabağlanmayaihtiyaçduyduklarındaçağırır: with pool_sema: conn = connectdb() try: # ... bağlantıyı kullan ... finally: conn.close() Bağlanmış semaforun kullanılması, elde edildiğinden daha fazla serbest bırakılması gibi bir programlamahatasınıtespitedememeşansınıazaltır. 47.9. threadingModülü 1059 PythonBelgeleri,Yayım4.1.3 47.9.7 Event (Olay) Nesneleri Bu,işparçacıklarıarasındakiiletişimiçinenbasitmekanizmadır:Birişparçacığıbirolayısinyal edervediğerişparçacığıdabunubekler. Bir olay nesnesi set() yöntemi ile değeri True olan ve clear() yöntemiyle de değeri False olan biriçişaretiyönetir.wait()yöntemiişaretindeğeriTrueolanakadarişparçacığınıengeller. classthreading.Event Busınıfolaynesneleriniuygular.Birolay,set()yöntemiiledeğeriTrueolanvclear() yöntemiyle de değeri False olan bir işareti yönetir. wait() yöntemi iş parçacığını, işaretindeğeriTrueolanakadarengeller.İşaretindeğeriilkolarakFalse’dur. Sürüm3.3’dedeğiştirildi.Kurucubirfonksiyondanbirsınıfadeğiştirildi. is_set() SadeceiçişaretTrueolduğundaTruedeğerinigeridöndürür. set() İçişaretiTrueolaakayarlar.Trueolmasınıbekleyenbütünişparçacıkları uyandırılır.wait()’içağıranişparçacığı,birkezişaretTrueolursa,birdaha engellenmeyecektir. clear() İç işareti False olarak sıfırlar. Sonradan, wait()’i çağıran iş parçacıkları, set(),içişaretitekrarTrueyapanakadarengellenecektir. wait(timeout=None) İçişaretTrueolanakadarişparçacığınıengeller.EğergirişteiçişaretTrue olursa, acil olarak geri döner. Diğer türlü, başka bir iş parçacığı, işareti Trueyapmakiçinset()’içağıranakadarveyaseçimebağlıtimeoutsüresi dolanakadar,işparçacığınıengeller. timeout argümanı kullanılarak çağrıldığında ve değeri None olmadığında, değeri, işlemin zaman aşımı süresini saniyelerle belirten kayannoktalıbirsayıolmalıdır. Bu yöntem, ancak iç işaretin değeri True olarak ayarlanmışsa, True değerini geri döndürür, wait() çağrısından önce veya çağrı başladıktansonra,timeoutdeğeriverilmemişseveişlemzamanaşımına uğramamışsaherzamanTruedeğerinigeridöndürür. Sürüm 3.1’de değiştirildi: Daha önceden, bu yöntem her zaman None değerinigeridöndürürdü. 1060 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.9.8 Timer (Zamanlayıcı) Nesneleri Bu sınıf, sadece belirli bir zaman geçtikten sonra çalıştırılan bir eylemi, -bir zamanlayıcıyı- temsil eder. Timer, Thread’in bir alt sınıfı olup, ayrıca özel bir iş parçacığı oluşturma işlevi örneğidir. Zamanlayıcılar, tıpkı iş parçacıkları gibi start() yöntemi çağrılarak başlatılır. Zamanlayıcı (eylemi başlamadan önce) cancel() yöntemi çağrılarak durdurulabilir. Zamanlayıcının eyleminin gerçekleşmesininden önce bekleyeceği aralık, kullanıcının tanımladığı aralık olmayabilir. Örneğin: def hello(): print("hello, world") t = Timer(30.0, hello) t.start() # 30 saniye sonra, "hello, world" yazısı ekrana bastırılacak. classthreading.Timer(interval,function,args=None,kwargs=None) interval (=aralık) argümanında belirtilen saniyelerden sonra, args argümanları ve kwargs anahtar argümanlarıyla birlikte çalışan bir fonksiyonun atandığı bir zamanlayıcı oluşturur. Eğer args, None (ön-tanımlı değeri bu) ise, boş bir liste kullanılacaktır. Eğer kwargs, None ise (ön-tanımlı değeri bu) ise, boş bir sözlük kullanılacaktır. Sürüm3.3’dedeğiştirildi:Kurucufonksiyondansınıfadeğiştirildi. cancel() Zamanlayıcıyıdurdururvezamanlayıcınıneylemininçalıştırılmasınıiptal eder. Bu sadece eğer zamanlayıcı halen kendi bekleme evrendiseyse çalışır. 47.9.9 Barrier (Engel) Nesneleri Sürüm3.2’degelenyenibirözelliktir. Bu sınıf, birbirini bekleme ihtiyacında olan sabit sayıdaki iş parçacıklarının kullanması için basit senkronizasyon ilkelleri sağlar. Her bir iş parçacığı wait() yöntemini çağırarak engeli aşmayaçalışırvebütünişparçacıklarıaynıçağrıyıyapanakadardaişparçacıklarıengellenir. Bunoktadabütünişparçacıklarıaynıandaserbestbırakılır. Engelaynısayıdakiişparçacıklarıiçinbirçokkeztekrarkullanılabilir. Aşağıdakiörnek,biristemcivesunucuişparçacınısenkronizeetmekiçinbasitbiryoldur: b = Barrier(2, timeout=5) def server(): start_server() b.wait() while True: connection = accept_connection() (sonrakisayfayadevam) 47.9. threadingModülü 1061 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) process_server_connection(connection) def client(): b.wait() while True: connection = make_connection() process_client_connection(connection) classthreading.Barrier(parties,action=None,timeout=None) Bir partide bulunan değişik sayıdaki iş parçacığı için bir engel nesnesi oluşturur. actionargümanıyazıldığında,işparçacıklarındanbiritarafından,serbestbırakıldığı zaman çağrılan, çağrılabilir bir şeydir. timeout argümanı belirtilmediği zaman değeriwait()yöntemiiçinöntanımlıdeğeridir. wait(timeout=None) Engeli geçer. İş parçacıkları partisi engele doğru bu fonksiyonu çağırmışsa, aynı anda hepsi birden serbest bırakılır. Eğer bir timeout değeri belirlenirse, sınıf yapıcısına verilmiş herhangi bir tercih için kullanılır. Geri dönen değer, 0 ile parti sayısının 1 eksiği arasında bir tamsayıdır, herbirişparçacığıiçindeğişebilir.Bu,birtakımözelidareişleriyapacak olanbirişparçacığınıseçmekiçinkullanılabilir.Örneğin: i = barrier.wait() if i == 0: # Sadece bir iş parçacığı bunu bastırmaya ihtiyaç duyar. print("engel geçildi") Eğer yapıcıya bir tane action sağlanmışsa, iş parçacıklarından bir tanesi serbest bırakılmadan önce onu çağırmış olacaktır. Bu çağrım bir hata yükseltirse,engelkırılandurumuniçineyerleştirilir. Eğer çağrı zaman aşımına uğrarsa, engel kırılan durumun içine yerleştirilir. Bu yöntem, beklenildiği gibi, eğer engel kırılmışsa veya iş parçacığı beklerkensıfırlanmışsa,BrokenBarrierErrorhatasıyükseltebilir. reset() Engeli ön-tanımlı değerine, boş duruma geri döndürür. Onu bekleyen herişparçacığıBrokenBarrierErrorhatasınıalır. Durumubilinmeyenbazıişparçacıklarıolduğunda,bufonksiyonunbazı dış senkronizasyonlara ihtiyaç duyabileceğini not edin. Eğer bir engel kırıldığında,onuterkedip,yenibirtaneoluşturmakdahaiyibiryoldur. abort() Bir engeli kırılmış bir duruma sokar. Bu, canlı veya ileride çağrılacak bütünçağrılarıBrokenBarrierErrorhatasıylabaşarısızlığauğramalarıiçin wait()’i yöntemini çağırır. Bunu, eğer uygulamayı çıkmazdan kurtarmak için,iptaledilmeyeihtiyaçduyuyorsakullanın. 1062 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Bu, iş parçacıklarından bir tanesinin ters gitmesine karşı hassas bir timeoutdeğeriileoluşturulmuşbirengeliotomatikolarakkorumakiçin tercihedilebilir. parties Engeligeçmesigerekenişparçacığısayısıdır. n_waiting Halihazırdaengeldebekleyenişparçacığısayısıdır. broken Eğer engel kırılan durumun içindeyse, değeri True olan bir boolean verisidir. exceptionthreading.BrokenBarrierError Bu beklenti, RuntimeError’un bir alt sınıfıdır, Barrier nesnesi sıfırlandığında veya kırıldığındayükseltilir. 47.9.10 Kilitleri, Durumları ve Semaforları with deyimi ile birlikte kullanmak Bumodültarafındansağlanan,acquire()verelease()fonksiyonunasahipbütünnesneleriçerik yönetimi olarak with deyimi için kullanılabilir. acquire() yöntemi, engellemeye girildiğinde, release()yöntemideengellemedençıkıldığındaçağrılacaktır.Bundanötürüaşağıdakikodlar: with some_lock: # Bir şeyler yap... şuişlemindengidir: some_lock.acquire() try: # Bir şeyler ya... finally: some_lock.release() Halihazırda,Lock,RLockCondition,SemaphoreveBoundedSemapgorenesneleriwithdeyimi içerikyönetimiolarakkullanılabilir. 47.9.11 Örnekler: Örnek-1: Thread’ı kullanmanın en kolay yolu; onu bir hedef fonksiyonuyla örnekleyip, start() fonksiyonunuçağırarakçalıştırmaktır. Kodlar: #/usr/bin/env python3 # -*- coding: utf-8 -*- import threading (sonrakisayfayadevam) 47.9. threadingModülü 1063 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’ def f(): # Thread in iş fonksiyon. print("iş") for i in range(4): t = threading.Thread(target=f) t.start() KodlarınAçıklamaları: Yukarıdaki kodlarda, f isminde bir tane fonksiyon oluşturulmuş ve içine “iş” string verisini ekranayazdıranbirprint()fonksiyonudahiledilmiştir.Dahasonrafordöngüsünükullanarak, dört tane iş parçacığı nesnesi örneği oluşturulmuştur. Bütün iş parçacıklarının hedef fonksiyonu,f’tir.Vebuprogramçalıştırıldığındadörtkereekrana“iş”yazısıyazdırılır. Örnek-2: Bir iş parçacığı oluşturmak ve hangi işi yapacağını söylemek için argüman atamak kullanılacakyollardanbirisidir.İkinciörnektethread’insonradanbastıracağıbirsayıargümanı fonksiyondatanımlanmıştır. Kodlar: #/usr/bin/env python3 # -*- coding: utf-8 -*- import threading def f(sayi): print("iş {}".format(sayi)) for i in range(4): t = threading.Thread(target=f, args=(i, )) t.start() KodlarınAçıklamaları: Bir iş parçacığı oluştururken, iş parçacığının etkin olacağı fonksiyonun eğer bir fonksiyon parametresi varsa, onu args parametresine yazarak, iş parçacığının hedefi olmasını sağlayabiliriz. Örnek-3: İşparçacıklarınıadlanırmakveyatanıtmakiçinÖrnek-2’deolduğugibiargümanlarıkullanmak oldukça gereksizdir. Ancak bu demek değildir ki argüman kullanmak gereksizdir. Sadece iş parçacığının ismini belirtirken bu yöntemi kullanmak gereksizdir demek istiyorum. Yoksa argümanlara ihtiyaç duyacağımız çok fazla durumla karşılaşmamız mümkün. Şundan bahsetmek istiyorum; her Thread örneğinin ismiyle birlikte, iş parçacığı oluşturulduğunda değişen,rastgelebirdeğerivardır.Thread’leriisimlendirmek,sunucuişlemleriyle,birçokfarklı hizmetişlerininbirlikteyürütülmesindekolaylıksağlar. 1064 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import threading import time def f(): print(threading.currentThread().getName(), "Başlıyor") time.sleep(2) print(threading.currentThread().getName(), "Bitiyor") def g(): print(threading.currentThread().getName(), "Başlıyor") time.sleep(5) print(threading.currentThread().getName(), "Bitiyor") t1 = threading.Thread(name="Birinci servis", target=f) t2 = threading.Thread(name="İkinci servis", target=g) t3 = threading.Thread(target=f) t4 = threading.Thread(target=g) t1.start() t2.start() t3.start() t4.start() KodlarınAçıklamaları: Buörnektekişukısmabirbakalım: def f(): print(threading.currentThread().getName(), "Başlıyor") time.sleep(2) print(threading.currentThread().getName(), "Bitiyor") f() fonksiyonu çağrıldığında, ismi neyse o şekilde “filanca Başlıyor” şeklinde bir yazı ekrana bastırılacak. Sonra 2 saniye bekledikten sonra “filanca Bitiyor” şeklinde bir yazı ekrana bastırılacak. Ancakbudurumuişparçacığınesnesinitanımlarkendeğiştirebiliyoruz.Yani: t1 = threading.Thread(name="Birinci servis", target=f) t2 = threading.Thread(name="İkinci servis", target=g) yukarıda olduğu gibi iş parçacığını tanımladığımızda, t1 ve t2 iş parçacıklarına kendimiz isim vermiş oluyoruz. Bu isimleri vermediğimizde iş parçacığının ismi Thread-1 şeklinde bir isme sahip olur. t3 ve t4 isimli iş parçacıklarının name argümanının yazılmamış olduğuna dikkat edin.BuikiişparçacığınınismimleridolayısıylaThread-1veThread-2olacaktır. 47.9. threadingModülü 1065 PythonBelgeleri,Yayım4.1.3 Örnek-4: Şimdi gelin threading’i daha rahat anlayabileceğimiz bir örnek oluşturalım. Bildiğiniz gibi herhangibirtkinteruygulamasınıçalıştırabilmemiziçinmainloop()fonksiyonunuçağırmamız gerekiyor. Ve bu fonksiyon, programı sonlandıran herhangi bir işlem tanımlanmamışsa, sürekliçalışırdurumdaoluyor.Pekibizaynıandabirtanesitkinter’eaitolanikitanedöngüyü aynıandaçalıştıramazmıyız?Elbetteçalıştırabiliriz,iştecevabı: Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- try: import Tkinter as tk except ImportError: import tkinter as tk import threading root = tk.Tk() entry = tk.Entry(master=root) entry.grid(row=0, column=0) def f(): button = tk.Button(master=root, text="Button") while True: if entry.get() == "": button.grid_forget() else: button.grid(row=1, column=0) t1 = threading.Thread(target=f) t1.daemon = True t1.start() t1.join(1) root.mainloop() KodlarınAçıklamaları: Bu örneği çalıştırdığınızda, göreceksiniz ki, entry widgetine yazı yazdığınızda button widgeti beliriyor, entry widgeti boş olduğunda ise ortadan kayboluyor. Bu işlem basit bir denetleme işlemidir ve tahmin edeceğiniz gibi fonksiyonun içindeki while döngüsü bu işe yarıyor. t1 isimli threading örneğini oluşturduktan sonra onun daemon özelliğinin değerini True olarak değiştirdiğimizigörüyorsunuz.Buişlemiyapmaktakiamacımız,programısonlandırdığımızda, geriye sadece daemonic iş parçacıklarının kalmasını sağlamak ve böylece programdan çıkmamızı sağlamak. Eğer bu daemon özelliğini aktif hale getirmemiş olsaydık, tkinter penceresini kapattığımız halde, programın sonlanmadığını görürdük. t1.join(1) kodu da, bu işparçacığının1saniyesonrasısonlanmasınıistediğimizibelirtir. Örnek-5: ŞimdideLocknesnesiylealakalıbirörnekyapalım. 1066 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import threading def f(): print("f fonksiyonu") def g(): print("g fonksiyonu") def h(): print("h fonksiyonu") t1 = threading.Thread(target=f) t2 = threading.Thread(target=g) t3 = threading.Thread(target=h) lock = threading.Lock() lock.acquire() t1.start() lock.acquire(blocking=True, timeout=3) t2.start() lock.acquire(blocking=True, timeout=1) t3.start() KodlarınAçıklamaları: Öncegereklimodülüprogramıniçineaktardık: import threading Sonrafarklıişparçacıklarınınçağıracağıüçtanefonksiyontanımladık: def f(): print("f fonksiyonu") def g(): print("g fonksiyonu") def h(): print("h fonksiyonu") Dahasonrafonksiyonlarıişparçacıklarınınhedefihalinegetirdik: 47.9. threadingModülü 1067 PythonBelgeleri,Yayım4.1.3 t1 = threading.Thread(target=f) t2 = threading.Thread(target=g) t3 = threading.Thread(target=h) Sonrakilitnesnemizioluşturdukvekilitnesnemizinacquire()fonksiyonunuargümansızolarak çağırdık. Eğer argümanlı çağırsaydık da değişen bir şey olmazdı, çünkü kilit bir sonraki acquire()fonksiyonunuçağırdığımızzamanengellemeyebaşlayacak: lock = threading.Lock() lock.acquire() t1isimliişparçacığınıbaşlattık;engellenmedençalışmayabaşladı: t1.start() Ve şimdi lock.acquire() yöntemini blocking ve timeout argümanlarıyla birlikte çağıralım. Bu yöntemi t1.start()’ı çağırmadan önce ikinci kez çağırsaydık o zaman, t1 iş parçacığı da engellenecekti. timeout parametresine 3 yazalım. Yani 3 saniyeliğine diğer işlemleri engellesin: lock.acquire(blocking=True, timeout=3) Üçsaniyegeçtiktensonrat2işparçacığınıbaşlatalım: t2.start() lock.acquire() fonksiyonunu bir kez daha çağırabiliriz, bu kez 1 saniyeliğine diğer görevleri engellesin: lock.acquire(blocking=True, timeout=1) Vesonolarakdat3işparçacığınıbaşlatalım: t3.start() Yukarıdaki örnekte, ekrana önce “f fonksiyonu” yazıldı, “f fonksiyonu” yazısı ekrana yazdırıldıktan üç saniye sonra ekrana “g fonksiyonu” yazıldı, ve “g fonksiyonu” ekrana yazdırıldıktanbirsaniyesonrada“hfonksiyonu”ekranayazıldı. Örnek-6:Şimdideacquire()yönteminibirkezyazarak,buyöntemdensonragelenişlemlerin engellenmediğibirörnekyazalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import threading class Thread(threading.Thread): def __init__(self, lock): threading.Thread.__init__(self) (sonrakisayfayadevam) 1068 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.lock = lock def run(self): self.lock.acquire() print("{} kilidi edindi.".format(self.name)) # self.lock.acquire(blocking=True, timeout=3) self.lock.release() print("{} kilidi serbest bıraktı.".format(self.name)) __lock__ = threading.Lock() t1 = Thread(lock=__lock__) t2 = Thread(lock=__lock__) t1.start() t2.start() KodlarınAçıklamaları: Herzamankigibiöncemodülümüzüprogramıniçineaktaralım: import threading Şimdidethreading.Thread’imirasalanbirsınıfoluşturalım.Vebusınıfınlockismindebirtane deözelliğiolsun: class Thread(threading.Thread): def __init__(self, lock): threading.Thread.__init__(self) self.lock = lock Bildiğinizgibithreading.Thread()’inrun()isimlibiryöntemivar.Buyöntemioverrideyapalım, yani modülün run() yöntemi yerine bizim yazacağımız run() yöntemi kullanılsın. Bu yöntem, ilk olarak self.lock.acquire() fonksiyonunu çağırsın. Hemen altında, iş parçacığının kilidi edindiğine dair mesajı ekrana yazdıran print() fonksiyonunu çağıralım. Bir altındaki yoruma alınmış # self.lock.acquire(blocking=True, timeout=3) kısmı, yorumdan çıkarırsanız, alttaki işlemlerin çalışabilmesi için üç saniye beklemek zorunda kalırsınız. self.lock.release() ile de kilidiserbestbırakıyoruz.verun()fonksiyonununsonsatırındadakilidinserbestbırakıldığına ‘ dairmesajıekranabastıranbirprint() fonksiyonuçağıralım: def run(self): self.lock.acquire() print("{} kilidi edindi.".format(self.name)) # self.lock.acquire(blocking=True, timeout=3) self.lock.release() print("{} kilidi serbest bıraktı.".format(self.name)) Sınıfıoluşturduk,örneklerioluşturmadanöncekilidimizioluşturalım: __lock__ = threading.Lock() Şimdideişparçacıklarımızıoluşturuponlarıbaşlatalım: 47.9. threadingModülü 1069 PythonBelgeleri,Yayım4.1.3 t1 = Thread(lock=__lock__) t2 = Thread(lock=__lock__) t1.start() t2.start() Örnek-7: Şimdi de RLock ile ilgili bir örnek yapalım. Lock ile RLock arasındaki en belirgin fark, Lock’ın kilidini bir başka iş parçacığı açabilir olması, oysa RLock’ın kilidini, kilidi edinmiş olan iş parçacığınınaçmasıgerekir. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import threading class Thread(threading.Thread): def __init__(self, lock): threading.Thread.__init__(self) self.lock = lock def run(self): self.lock.acquire(blocking=True, timeout=3) print("{} çalışıyor.".format(self.name)) self.lock.acquire(blocking=True, timeout=1) print("{} çalışması bitti.".format(self.name)) __lock__ = threading.RLock() t1 = Thread(lock=__lock__) t2 = Thread(lock=__lock__) t1.start() t2.start() KodlarınAçıklamaları: Herzamankigibiöncethreadinmodülünüprogramıniçineaktarıyoruz: import threading lockparametresiolanvethreading.Thread()sınıfınımirasalanbirsınıfoluşturuyoruz: class Thread(threading.Thread): def __init__(self, lock): threading.Thread.__init__(self) self.lock = lock Yine run() yöntemini override edelim. Bu run() fonksiyonu altında çağırdığımız ilk fonksiyon self.lock.acquire(blocking=True, timeout=3) fonksiyonudur. Bu fonksiyon kilidi edinecek olan ilk iş parçacığına uygulanmaz. Bir sonraki satırda, iş parçacığının çalıştığına dair 1070 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 ekrana bir yazı yazdırıyoruz (print(“{} çalışıyor.”.format(self.name))). Onun da altında kilidi self.lock.acquire(blocking=True,timeout=1)fonksiyonuilebirdahaediniyoruz.Birişparçacığı RLock kilidini ikinci kez kendi işlemlerini engellemeden elde edebilir. Ve run() yönteminin son satırında da çalışmanın bittiğine dair ekrana bir yazı yazdırıyoruz (print(“{} çalışması bitti.”.format(self.name))): def run(self): self.lock.acquire(blocking=True, timeout=3) print("{} çalışıyor.".format(self.name)) self.lock.acquire(blocking=True, timeout=1) print("{} çalışması bitti.".format(self.name)) Sınıfıoluşturduk,örneklerioluşturmadanöncekilidimizioluşturalım: __lock__ = threading.RLock() Şimdideişparçacıklarımızıoluşturuponlarıbaşlatalım: t1 = Thread(lock=__lock__) t2 = Thread(lock=__lock__) t1.start() t2.start() Not: Bu örnekte RLock kilidine sahip olan iş parçacığı t1’dir. Dolayısıyla kilidi sadece o açabilir.Buörneğiçalıştırdığınızda,t1işparçacığınınkilitedindiğiniamaserbestbırakmadığını görüyoruz. Eğer t1 bu kilidi serbest bıraksaydı, iş parçacıkları arasında bekleme süresi olmayacaktı. Örnek-8: ŞimdideCondition()ileilgilibirörnekyapalım.Buörnektebirüreticibirdetüketiciişparçacığı oluşturacağız. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import time import threading class Uretici(threading.Thread): def __init__(self, condition, liste): threading.Thread.__init__(self) self.condition = condition self.liste = liste def run(self): count = 1 while count < 10: self.condition.acquire() print("{} condition’u edindi.".format(self.name)) (sonrakisayfayadevam) 47.9. threadingModülü 1071 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.liste.append(count) print("{} listeye {} tarafından eklendi." .format(count, self.name)) self.condition.notify() print("condition {} tarafından bildirildi.".format(self.name)) self.condition.release() print("condition {} tarafından serbest bırakıldı." .format(self.name)) count += 1 time.sleep(0.5) class Tuketici(threading.Thread): def __init__(self, condition, liste): threading.Thread.__init__(self) self.condition = condition self.liste = liste def run(self): while True: self.condition.acquire() print("{} condition’u edindi.".format(self.name)) while True: if self.liste: sayi = self.liste.pop() print("{}, {} {}".format( sayi, self.name, "tarafından listeden düşürüldü.")) break print("condition {} {}".format( self.name, "tarafından bekletiliyor.")) self.condition.wait() self.condition.release() print("condition {} {}".format( self.name, "tarafından serbest bırakıldı.")) __condition__ = threading.Condition() __liste__ = [] t1 = Uretici(condition=__condition__, liste=__liste__) t2 = Tuketici(condition=__condition__, liste=__liste__) t1.start() t2.start() KodlarınAçıklamaları: Herzamankigibiöncegereklimodülleriprogramıniçineaktarıyoruz: import time (sonrakisayfayadevam) 1072 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) import threading Şimdi, threading.Thread sınıfının özelliklerini miras alan bir üretici sınıf tanımlayalım; bu sınıftan bir örnek türetilmek istendiği zaman kullanıcı condition argümanını ve liste argümanınıgirmekzorundakalsın: class Uretici(threading.Thread): def __init__(self, condition, liste): threading.Thread.__init__(self) self.condition = condition self.liste = liste Busınıfınbirtanerun()metoduzatenmevcutamabizburun()metodunudeğiştirelim: def run(self): Burun()yöntemindeaşağıdakileryapılsın: 1. countisimlidahasonraself.liste’yeeklenmeküzerebirdeğişkentanımlayalım: count = 1 2. Birtanedöngüoluşturalım,budöngücount,10’danküçükolduğusürecedevametsin: while count < 10: 3. DöngüiçindeişparçacığıCondition’uedinsinveekranadaCondition’ueldeettiğinedair biryazıyazdırılsın: self.condition.acquire() print("{} condition’u edindi.".format(self.name)) 4. İşparçacığışimdidecountdeğişkeniniself.liste’yeeklesinveekranabuişlemleilgilibir yazıyazdırılsın: self.liste.append(count) print("{} listeye {} tarafından eklendi." .format(count, self.name)) 5. Sonra,işparçacığı,durumunubildirsinvebildirildiğinedairekranabiryazıyazdırılsın: self.condition.notify() print("condition {} tarafından bildirildi.".format(self.name)) 6. Şimdi de iş parçacığı Condition’u serbest bıraksın ve serbest bıraktığına dair ekrana bir yazıyazdıralım: self.condition.release() print("condition {} tarafından serbest bırakıldı." .format(self.name)) 7. count değişkenini 1 birim artıralım ve time.sleep(0.5) fonksiyonunu çağırarak işlemler arasındabirazzamangeçmesinibekleyelim: 47.9. threadingModülü 1073 PythonBelgeleri,Yayım4.1.3 count += 1 time.sleep(0.5) Şimdi de, threading.Thread sınıfının özelliklerini miras alan bir tüketici sınıf tanımlayalım; yine bu sınıftan bir örnek türetilmek istendiği zaman kullanıcı condition argümanını ve liste argümanınıgirmekzorundakalsın: class Tuketici(threading.Thread): def __init__(self, condition, liste): threading.Thread.__init__(self) self.condition = condition self.liste = liste Busınıfındabirtanerun()metoduzatenmevcutamabizburun()metodunudeğiştirelim: def run(self): Burun()yöntemindeaşağıdakileryapılsın: 1. Sonsuzbirdöngüoluşturalım,budöngüiçerisindekitüketiciişparçacığıCondition’uelde etsinveeldeettiğinedairbilgiyiekranayazdıralım: while True: self.condition.acquire() print("{} condition’u edindi.".format(self.name)) 2. Bir tane daha sonsuz döngü oluşturalım, Bu döngüde de bir koşul oluşturalım, koşulumuz self.liste True değeri veriyorsa olsun ve bu koşul altında sayi isimli bir değişkeni self.liste’den düşürelim. Ekrana da iş parçacığının bu sayıyı listeden düşürdüğününbilgisiniyazdıralım,sonradabukoşulaltındakidöngüdençıkılsın: while True: if self.liste: sayi = self.liste.pop() print("{}, {} {}".format( sayi, self.name, "tarafından listeden düşürüldü.")) break 3. Yine ikinci döngünün içindeyken her zaman Condition’u bekletelim ve beklediğine dair yazı ekrana yazdırılsın, şayet bunu yapmazsak, döngü başa sardığında iş parçacığı Condition’utekraredinirveprogramoradadonupkalır: print("condition {} {}".format( self.name, "tarafından bekletiliyor.")) self.condition.wait() ‘ 4. İlkdöngümüzüniçindeCondition’userbestbırakalım.BuörnekteCondition() userbest ‘ bırakmazsak,birsorunlakarşılaşmayız.Amaikitanetüketiciolduğudurumlarda while döngüsünü kırabilecek bir durum oluşturabiliriz ve döngü kırıldıktan sonra iş parçacığı kilidihalatutmayadevamediyorolabilir,buyüzdenkilidiserbestbırakmakgerekir: 1074 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 self.condition.release() print("condition {} {}".format( self.name, "tarafından serbest bırakıldı.")) Ve son olarak Condition(), Uretici(), Tüketici() sınıflarından birer örnek ve boş bir liste oluşturalım. Condition() sınıfından oluşturduğumuz örnek ve listeyi Uretici() ve Tuketici() sınıflarından oluşturduğumuz örneklere argüman olarak yazalım. Sonra da iş parçacıklarını çalıştıralım: __condition__ = threading.Condition() __liste__ = [] t1 = Uretici(condition=__condition__, liste=__liste__) t2 = Tuketici(condition=__condition__, liste=__liste__) t1.start() t2.start() Not: Bu örneği çalıştırdığımızda Uretici() sınıf örneği boş listeye 9 tane eleman ekleyecek ve Tuketici()sınıförneğiiselisteyeeklenenbuelemanlarıtekteksilecek.VesonolarakTuketici() sınıfıkendisinibeklemeyealacak. Örnek-9: ŞimdideSemaphore()nesnesiylealakalıbirörnekyapalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import time import threading semaphore = threading.Semaphore() def f(): print("f fonksiyonu başlıyor.") semaphore.acquire() print("f fonksiyonu semaforu edindi.") for i in range(5): print("f fonksiyonu ’{}’ itemini işliyor.".format(i)) time.sleep(1) semaphore.release() print("f fonksiyonu semaforu serbest bırakıyor.") print("f fonksiyonu bitiyor.") def g(): print("g fonksiyonu başlıyor") while not semaphore.acquire(): print("Semafor henüz kullanılamıyor.") (sonrakisayfayadevam) 47.9. threadingModülü 1075 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) time.sleep(1) else: print("g fonksiyonu semaforu edindi.") for i in range(5): print("g fonksiyonu ’{}’ itemini işliyor.".format(i)) time.sleep(1) semaphore.release() print("g fonksiyonu semaforu serbest bırakıyor.") t1 = threading.Thread(target=f) t2 = threading.Thread(target=g) t1.start() t2.start() Not: Bu örnekte kullanılan Semaphore() nesnesi yerine, Lock(), RLock, Condition() ve BoundedSemaphore() nesnelerini de kullanabilirsiniz. Bu örnek BoundedSemaphore() ve Condition()nesneleriiçinpekuygunbirörnekolmasada,Lock(),RLocknesneleriiçinbuörneği kullanmaktabirsakıncayok. KodlarınAçıklamaları: Öncemodüllerimiziprogramıniçineaktaralım: import time import threading ŞimdiSemaphore()nesnesindenbirtaneörnekoluşturalım: semaphore = threading.Semaphore() Buörnektef()veg()isimliikitanefonksiyonkullanacağız.Öncef()fonksiyonunuoluşturalım, fonksiyonçağrılırçağrılmaz,ekranabiryazıyazdırılsın: def f(): print("f fonksiyonu başlıyor.") Dahasonraişparçacığısemaforuedinsinveeldeettiğinedairbiryazıekranayazdırılsın: semaphore.acquire() print("f fonksiyonu semaforu edindi.") Şimdidefonksiyoniçindebasitbirişlemtanımlayalım: for i in range(5): print("f fonksiyonu ’{}’ itemini işliyor.".format(i)) time.sleep(1) İş parçacığı semaforu serbest bıraksın ve serbest bıraktığına dair ekrana bir yazı yazdırılsın, sonolarakdafonksiyonunçalışmasınınbittiğinedairekranabiryazıyazdırılsın: 1076 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 semaphore.release() print("f fonksiyonu semaforu serbest bırakıyor.") print("f fonksiyonu bitiyor.") Şimdideg()fonksiyonunuoluşturalım.Fonksiyonçağrıldığında,fonksiyonunbaşladığınadair biryazıekranayazdırılsın: def g(): print("g fonksiyonu başlıyor") İş parçacığı bu kilidi edinmediği sürece ekrana bir yazı yazdırılsın. Ancak acquire() fonksiyonunun blocking argümanını False yapmadığımız için bu yazı ekrana yazdırılmayacaktır. İsterseniz bir de acquire(blocking=None) yazarak örneği bir daha çalıştırın: while not semaphore.acquire(): print("Semafor henüz kullanılamıyor.") time.sleep(1) Eğerişparçacığısemaforuedindiyseaşağıdakiişlemleryapılsın: else: print("g fonksiyonu semaforu edindi.") for i in range(5): print("g fonksiyonu ’{}’ itemini işliyor.".format(i)) time.sleep(1) Sonolarakbuişparçacığıdasemaforuserbestbıraksın: semaphore.release() print("g fonksiyonu semaforu serbest bırakıyor.") Örnek-10: ŞimdideBoundedSemaphore()ileilgilibirörnekyapalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import threading import time def f(item, bs): bs.acquire() time.sleep(1) print(item) bs.release() (sonrakisayfayadevam) 47.9. threadingModülü 1077 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) bounded_semaphore = threading.BoundedSemaphore(value=2) for i in range(10): t = threading.Thread(target=f, args=(i, bounded_semaphore)) t.start() KodlarınAçıklamaları: Yineherzamankigibiöncemodülleriprogramıniçineaktaralım: import threading import time Şimdi de bir tane f() fonksiyonu tanımlayalım. Bu fonksiyonun item ve bs isminde iki tane argümanı olsun. item argümanını for listesindeki her bir eleman için, bs argümanını da semaphoreiçinkullanacağız: def f(item, bs): Fonksiyonu çağıran iş parçacığı bağlanmış semaforu elde etsin, sonra 1 saniye bekleyelim ve for döngüsünün elemanını ekrana yazdıralım, son olarak da bağlanmış semaforu serbest bırakalım: bs.acquire() time.sleep(1) print(item) bs.release() Şimdiglobalalandabirtanebağlanmışsemaforoluşturalımvevalueargümanına2yazalım: bounded_semaphore = threading.BoundedSemaphore(value=2) Son olarak bir tane for döngüsü içinde 10 tane iş parçacığı oluşturalım. Bu iş parçacıklarının argsargümanında,listeninosıradakielemanıvetanımladığımızbağlanmışsemaforolsun: bounded_semaphore = threading.BoundedSemaphore(value=2) for i in range(10): t = threading.Thread(target=f, args=(i, bounded_semaphore)) t.start() Not:Buörneğiçalıştırdığınızda,ekranasayılarınikişerikişeryazdırıldığınıgöreceksiniz.Bunun olmasınısağlayan,bağlanmışsemaforunvaluedeğerinin2olarakyazılmasıdır. Örnek-11: ŞimdideEvent()ilealakalıbirörnekyapalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import time import threading (sonrakisayfayadevam) 1078 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class Uretici(threading.Thread): def __init__(self, event, liste): threading.Thread.__init__(self) self.event = event self.liste = liste def run(self): count = 1 while count < 10: self.liste.append(count) print("{} listeye {} tarafından eklendi." .format(count, self.name)) self.event.set() print("event {} tarafından ayarlandı.".format(self.name)) self.event.clear() print("event {} tarafından temizlendi.".format(self.name)) count += 1 time.sleep(0.5) class Tuketici(threading.Thread): def __init__(self, event, liste): threading.Thread.__init__(self) self.event = event self.liste = liste def run(self): while True: if self.liste: sayi = self.liste.pop() print("{}, {} tarafından listeden düşürüldü." .format(sayi, self.name)) self.event.wait() __event__ = threading.Event() __liste__ = [] t1 = Uretici(event=__event__, liste=__liste__) t2 = Tuketici(event=__event__, liste=__liste__) t1.start() t2.start() KodlarınAçıklamaları: Modüllerimiprogramıniçineaktaralım: import time import threading 47.9. threadingModülü 1079 PythonBelgeleri,Yayım4.1.3 Şimdi Uretici isminde, event ve liste argümanlarına sahip, threading.Thread() sınıfından türetilmişbirsınıfoluşturalım: class Uretici(threading.Thread): def __init__(self, event, liste): threading.Thread.__init__(self) self.event = event self.liste = liste Bu sınıfa run() isminde bir tane fonksiyon ekleyelim. Bildiğiniz gibi bu fonksiyon threading.Thread() sınıfına ait olan bir fonksiyon, dolayısıyla burada yine yazacağımız fonksiyon,orjinalfonksiyonunüzerineyazılacak: def run(self): Fonksiyondacountismindebirtanedeğişkenkullanacağız.Budeğişken10’danküçükolduğu sürecewhiledöngüsüçalışmayadevamedecek: count = 1 while count < 10: Şimdi listemize count değişkenini ekleyelim ve ekrana count’un listeye eklendiğine dair bir yazıyazdıralım: self.liste.append(count) print("{} listeye {} tarafından eklendi." .format(count, self.name)) Şimdi Event() sınıfının önce set() fonksiyonunu sonra da clear() fonksiyonunu çağıralım, her birişlemiçinekranabiryazıyazdıralım: self.event.set() print("event {} tarafından ayarlandı.".format(self.name)) self.event.clear() print("event {} tarafından temizlendi.".format(self.name)) countdeğişkeni1birimartsınvetime.sleep(0.5)fonksiyonuile0.5saniyebekleyelim: count += 1 time.sleep(0.5) ŞimdidebenzerşekildeTuketicisınıfımızıoluşturalım: class Tuketici(threading.Thread): def __init__(self, event, liste): threading.Thread.__init__(self) self.event = event self.liste = liste Busınıfınrun()metodundadatanımlayalım: def run(self): 1080 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Yinebirdöngüoluşturalımveself.listemevcutolduğusürece,listedensayiismindekideğişken düşürülsünveekranabusayınındüşürüldüğünedairbiryazıyazdırılsın: while True: if self.liste: sayi = self.liste.pop() print("{}, {} tarafından listeden düşürüldü." .format(sayi, self.name)) Ve Event() sınıfının wait() fonksiyonunu çağıralım. Bu fonksiyon, yapacak hiç bir işlem kalmadığındabeklemeyedevamedilmesinisağlayacak: self.event.wait() Event(), Uretici() ve Tuketici() sınıflarından birer örnek oluşturalım ayrıca boş bir liste tanımlayalımsonolarakdaişparçacıklarımızıbaşlatalım: __event__ = threading.Event() __liste__ = [] t1 = Uretici(event=__event__, liste=__liste__) t2 = Tuketici(event=__event__, liste=__liste__) t1.start() t2.start() Not: Bu örneği çalıştırdığınızda, Uretici() 9 tane elemanı listeye eklerken, Tuketici()’de bu listeyeeklenenelemanlarılistedensilecek.ListedensilinecekbirşeykalmayıncadaTuketici() kendisinibeklemeyealacak. Örnek-12: ŞimdideBarrier()nesnesiylealakalıbirörnekyapalım. Kodlar: #!/usr/bin/env python3 # -*- coding: utf-8 -*- import time import random import threading def f(b): time.sleep(random.randint(2, 10)) print("{} iş parçacığının uyandırıldığı tarih: {}" .format(threading.current_thread().getName(), time.ctime())) b.wait() print("{} iş parçacığının engeli geçtiği tarih: {}" .format(threading.current_thread().getName(), time.ctime())) barrier = threading.Barrier(3) for i in range(3): (sonrakisayfayadevam) 47.9. threadingModülü 1081 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) t = threading.Thread(target=f, args=(barrier,)) t.start() KodlarınAçıklamaları: Herzamankigibiöncegereklimodülleriprogramıniçineaktaralım: import time import random import threading Şimdi b argümanına sahip, f isminde bir tane fonksiyon oluşturalım. Bu fonksiyonda önce time.sleep(random.randint(2, 10)) fonksiyonunu çağırarak 2 ile 10 saniye arasında belirsiz bir süre bekleneceğini belirtelim. Daha sonra ekrana iş parçacığının uyandırıldığı tarih ekrana yazdırılsın, sonra da Barrier() nesnemizin wait() yöntemini çağıralım, son olarak da işparçacığınınengeligeçtiğitarihekranayazdırılsın: def f(b): time.sleep(random.randint(2, 10)) print("{} iş parçacığının uyandırıldığı tarih: {}" .format(threading.current_thread().getName(), time.ctime())) b.wait() print("{} iş parçacığının engeli geçtiği tarih: {}" .format(threading.current_thread().getName(), time.ctime())) FonksiyonuoluşturduktansonrabarrierismindebirtaneBarrier()nesnesiörneğioluşturalım. Bunesneninargümanına3vermemizinsebebi,3taneişparçacığıileçalışıyorolmamızdır: barrier = threading.Barrier(3) Son olarak bir for döngüsü oluşturalım, bu for döngüsü 3 tane threading.Thread() örneği üretsinvedöngüiçindebuörnekleribaşlatalım: barrier = threading.Barrier(3) for i in range(3): t = threading.Thread(target=f, args=(barrier,)) t.start() Not: Barrier() nesnesinin özelliğine göre, oluşturulan bu iş parçacıklarının uyandırılma zamanlarıfarklıolsada,işparçacıklarıaynıandaengeliaşarlar. 47.10 sched modülü Bu modülün amacı belirli fonksiyonları sırayla çalıştırmaktır. Modülün içinde scheduler diye birsınıfmevcut.(Sınıfınadıdikkatettiysenizküçükharflebaşlıyor.)Bumodülükullanmadan önceschedulersınıfındanbirörnekoluşturmalısınız: import sched s=sched.scheduler() 1082 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Örneğimizi bu şekilde oluşturabiliriz. Ancak bu şekilde oluşturmamız bize daha sonra sorun teşkil edebilir. Bu sınıfın iki tane parametresi var. Bunlardan ilki: timefunc. Bu parametrenin varsayılan değeri time.monotonic. Örnek oluşturulurken bu parametreyi time.time olarak ayarlayalım. Bunun sebebini birazdan açıklayacağım. İkinci ve son parametre ise delayfunc. Bu parametrenin varsayılan değeri time.sleep. Bu parametreyi de kodun okunaklılığı açısındanbelirtelim.Sonuçolarakörneğimizişuşekildetanımlayalım: import sched, time s=sched.scheduler(time.time, time.sleep) Şimdisırabuörneğinmetodlarında. 47.10.1 scheduler.enter() Bu metod çalıştırılacak fonksiyonların sıraya eklenmesini sağlıyor. 5 tane parametresi var. İlki bekleme süresini belirliyor. İkincisi önceliğini belirliyor. Eğer aynı zamanda çalışacak fonksiyonlar varsa önceliğine göre çalıştırılır. Üçüncüsü çalışacak fonksiyon. Diğer ikisi isimli parametre. Bunlardan argument olan eğer varsa demet olarak fonksiyonun parametrelerini alıyor.Diğerininadıdatahminedeceğinizüzerekwargs.Değeridesözlükolarakfonksiyonun isimliparametreleri. schedulersınıfınındelayfuncparametresiburadakullanılıyor. 47.10.2 scheduler.enterabs() Bu metod enter metodundan çok da farklı değil. Tek farkı ilk değeri bekleme süresini değil çalışacağısüreyibelirliyor. schedulersınıfınıntimefuncparametresiburadakullanılıyor. 47.10.3 scheduler.cancel() enterveyaenterabsilesırayaeklenmişfonksiyonlarısıradançıkarmayısağlıyor. 47.10.4 scheduler.empty() EğersıradaherhangibirfonksiyonyoksaTruedöndürür.EğerfonksiyonvarsaFalsedöndürür. 47.10.5 scheduler.run() Sıradaki fonksiyonları hazırlandığı şekilde çalıştırır. Tek parametresi olan blocking eğer False iseilkçalışacakfonksiyonunçalışmasınakalansüreyidöndürür. 47.10. schedmodülü 1083 PythonBelgeleri,Yayım4.1.3 47.10.6 scheduler.queue Bu değişken scheduler nesnelerinin sahip olduğu ve bizim kullanabileceğimiz tek değişken. DahaöncesırayaeklenmişEventnesnelerinitutuyor. 47.10.7 Örnekler Anlatım biraz kafa karıştırıcı oldu. Ancak şimdi birkaç Örnek yaparak mantığını kavramanızı sağlayalım. >>> import sched,time >>> s=sched.scheduler(time.time,time.sleep) >>> def zamanı_yazdır(sıra): print(f"Zaman: {time.time()} ,{sıra}") >>> def farklı_zamanları_yazdır(): print(time.time()) s.enter(10,1,zamanı_yazdır,argument=("Birinci",)) s.enter(5,1,zamanı_yazdır,argument=("İkinci",)) s.enter(5,2,zamanı_yazdır,argument=("Üçüncü",)) s.enter(5,1,zamanı_yazdır,argument=("Dördüncü",)) s.run() print(time.time()) >>> farklı_zamanları_yazdır() 1532176259.627274 Zaman: 1532176264.6953058 ,İkinci Zaman: 1532176264.6953058 ,Dördüncü Zaman: 1532176264.6953058 ,Üçüncü Zaman: 1532176269.6955397 ,Birinci 1532176269.7111597 Çalışmaya başladıktan 5 saniye sonra “İkinci”, “Üçüncü” ve “Dördüncü” çalıştı. “İkinci” ve “Dördüncü”nün sırası aynıydı. O yüzden tanımlanma sıralarına bakıldı. “Üçüncü”nün öncelik sırası 2 olduğu için onlardan daha sonra yazıldı. “Birinci” onlardan 5 saniye sonra yani çalışmayabaşladıktan10saniyesonraçalıştı. Birbaşkaörnek: import sched,time s=sched.scheduler(time.time,time.sleep) yazdırılacak_değer="Merhaba Dünya" def değiştir(): global yazdırılacak_değer yazdırılacak_değer="Merhaba Zalim Dünya" def yazdır(): print(yazdırılacak_değer) suan=time.time() if(s.empty()): (sonrakisayfayadevam) 1084 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) s.enterabs(suan+5,1,yazdır) s.enterabs(suan+6,2,değiştir) s.enterabs(suan+6,1,yazdır) s.enter(10,1,yazdır) s.run() if bloğunda eğer sıra boşsa çalışmasını söyledik. Sıra boş olduğu için altındaki fonksiyonlar çalışacaktır. İlk önce 5 saniye sonra bir kere yazdır fonksiyonu çalışacaktır. Daha sonra çalışmaya başladıktan 6 saniye sonra ikinci yazdır fonksiyonu çalışacaktır. Çıktısı ilkiyle aynı olur. Ancak hemen sonra çalışan değiştir fonksiyonu ile yazdırılacak_değer değiştiği için 10. saniyedeçalışanyazdırfonksiyonufarklıbirçıktıveriyor. Şuşekildefantastikbirdöngüoluşturulabilir: import sched,time s=sched.scheduler(time.time,time.sleep) suan=time.time() def çıktı(): global suan suan+=2 print(suan) s.enterabs(suan,1,çıktı) s.enter(5,1,çıktı) s.run() Her iki saniyede bir aynı kod çalışacaktır. Eğer 2’yi değiştirirseniz süreyi de düzenlemiş olursunuz. 47.11 json Modülü JSON farklı diller arasında iletişimi sağlamak için geliştirilmiş basit bir veri formatıdır. Bu veri formatı Python’daki sözlük ve listelere çok benzer. İki tür kullanımı vardır. Birincisi anahtar-değermantıylaçalışır. { "Ad": "Fırat", "Soyad": "Özgül" } JSON ifadelerinde her öğe arasında virgül olmalıdır. Anahtar ve değer ikilisi arasında ise iki noktakullanılır. İkinci kullanımı ise liste tipine çok benzer. Bu kullanımda anahtar-değer değil, sadece değer verilir. { "Fırat", "Özgül" } 47.11. jsonModülü 1085 PythonBelgeleri,Yayım4.1.3 JSON modülünde 4 ana fonksiyon bulunuyor. Bunlardan ikisi Python ile JSON oluşturmaya yararkendiğerikisiJSONverileriniçözmeyeyarar.JSONoluşturanfonksiyonlarşuikisidir: 1. json.dump 2. json.dumps JSONverileriniçözenikifonksiyoniseşunlardır: 1. json.load 2. json.loads 47.11.1 json.dump ve json.dumps Bu iki fonksiyonu birlikte yazmak istedim. Çünkü ikisinin parametreleri neredeyse aynı. Aralarındakifarkiseşu: dumpfonksiyonuçıktıyıillakibirdosyaiçineaktarır.Yanisizealbuseninistediğin JSON çıktısı demez. Bunu diyen dumps fonksiyonudur. dumps fonksiyonu str tipindebirdeğerdöndürürkendumpfonksiyonuhiçbirdeğerdöndürmez. O yüzden python.org sitesinden alınan şu örneklerde dump yerine dumps fonksiyonu kullanılmış.EğerdumpfonksiyonunukullanacaksanızJSON’adönüşmesiniistediğinizifadeden sonradosyayıbulundurandeğişkeniyazın. >>> import json >>> json.dumps([’foo’, {’bar’: (’baz’, None, 1.0, 2)}]) ’["foo", {"bar": ["baz", null, 1.0, 2]}]’ >>> print(json.dumps("\"foo\bar")) "\"foo\bar" >>> print(json.dumps(’\u1234’)) "\u1234" >>> print(json.dumps(’\\’)) "\\" >>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)) {"a": 0, "b": 0, "c": 0} >>> from io import StringIO >>> io = StringIO() >>> json.dump([’streaming API’], io) >>> io.getvalue() ’["streaming API"]’ Bufonksiyonlarınbirkaçparametresivar.Şimdisırabunlarınneişeyaradığınıöğrenmekte. skipkeys Normalde Python, JSON oluştururken anahtar veya değer basit tipte (str,int,float...) değilse TypeError hatası verir. Eğer bu parametre True (Varsayılan False) ise hata vermek yerine o ikiliyiatlar. ensure_ascii Eğer bu parametre True (varsayılan olarak) ise çıktıda ASCII tablosuna uymayan karakterlerdenkaçınır.Falseisebunadikkatetmez. 1086 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> import json >>> json.dumps(["üzüm"],ensure_ascii=True) ’["\\u00fcz\\u00fcm"]’ >>> json.dumps(["üzüm"],ensure_ascii=False) ’["üzüm"]’ indent Eğernegatifolmayanbirtamsayıveyabirkarakterdizisiisegirintilemesayesindedahagüzel birçıktıalmanızısağlar.Eğer0,negatifsayıveyaboşkarakterdizisi(“”)iseheröğeyiyenisatıra basar.None(varsayılan)isedipdibebirçıktıverir.Pozitifbirsayıverildiğindeonuboşluksayısı kabulederekgirintilemeyapar.Karakterdizisiifadesineşuikisiyeterinceaçıkbirörnek:\t,\n (cid:242) Not Karakterdizisikullanımı3.2sürümüitibariilebaşladı. >>> print(json.dumps({"Özellikler":{"Hız":150,"Ses":"10db"}},indent=None)) {"\u00d6zellikler": {"H\u0131z": 150, "Ses": "10db"}} >>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent=4)) { "Ozellikler": { "Hiz": 150, "Ses": "10db" } } >>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent="\n")) { "Ozellikler": { "Hiz": 150, "Ses": "10db" } } >>> print(json.dumps({"Ozellikler":{"Hız":150,"Ses":"10db"}},indent=0)) { "Ozellikler": { "Hiz": 150, "Ses": "10db" } } separators Buparametreverilendeğeriöğelerarasındaayraçolarakkullanır.Verilendeğertupletipinde olmalıdır.Varsayılanolarakşukullanılır:(“,”,“:“)AncakindentparametresiNonedeğerindeyse 47.11. jsonModülü 1087 PythonBelgeleri,Yayım4.1.3 ilkvirgüldeğerideikinoktagibisonunaboşlukalır.Yanişuşekildeolur:(”,“,“:“) >>> json.dumps({"Elma":42,"Armut":25,"kiraz":65},separators=("?","!")) ’{"Elma"!42?"Armut"!25?"kiraz"!65}’ 47.11.2 json.load ve json.loads Buikifonksiyondadumpvedumpsgibibirbirineçokbenziyor.Hattafarklarıbileneredeyse aynı. load fonksiyonu sadece dosyadaki JSON verilerini Python verisine çevirirken loads fonksiyonu veriyi parametre olarak alıyor. dump ve dumps’da olduğu gibi parametreleri tamamenaynı. Burayabirkaçörnekkodyazalım. >>> json.loads(’{"mezuniyet": "üniversite", "Bölüm": "Tıp"}’) {’mezuniyet’: ’üniversite’, ’Bölüm’: ’Tıp’} >>> json.loads(’["\\u00fcz\\u00fcm"]’) [’üzüm’] Şimdidesırafonksiyonlarınaldığıparametrelerde. object_hook Döndürülendeğerinveritipinideğiştirmenizisağlar.Bunubirkodileaçıklayalım. >>> json.loads(’{"mezuniyet": "üniversite", "Bölüm": "Tıp"}’,object_hook=list) [’mezuniyet’, ’Bölüm’] Gördüğünüzgibiçıktıyılistetipindeverdi.Ancakbunuyapmakiçinsadeceanahtarlarıaldı. object_pairs_hook object_pairs_hook, object_hook ile benzer görevler yapıyor. İkisi arasında öncelik object_pairs_hook’da. Eğer anahtar değer ilişkisinden oluşan bir JSON verisiyse object_pairs_hookdeğilseobject_hookparametresikullanılır. >>> json.loads(’{"Ad": "Fırat", "Soyad": "Özgül"}’,object_pairs_hook=str) "[(’Ad’, ’Fırat’), (’Soyad’, ’Özgül’)]" >>> json.loads(’["Fırat", "Özgül"]’,object_pairs_hook=dict,object_hook=list) [’Fırat’, ’Özgül’] parse_int int tipindeki değerlerin Python koduna dönüştürülürken hangi tipin kullanılması gerektiğini belirler.Bunubirkodlaaçıklamakdahakolayolursanıyorum: >>> json.loads(’{"Satılan": 54, "Kalan": 46}’,parse_int=float) {’Satılan’: 54.0, ’Kalan’: 46.0} parse_float parse_intparametresininyaptığınıfloattipindekisayılariçinyapar. >>> json.loads(’[23, 45.2, "", 512.128]’,parse_int=bool,parse_float=list) [True, [’4’, ’5’, ’.’, ’2’], ’’, [’5’, ’1’, ’2’, ’.’, ’1’, ’2’, ’8’]] 1088 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.12 timeit Modülü Kaynak Kodu: https://github.com/python/cpython/blob/3.5/Lib/timeit.py Belge Kaynağı: https://docs.python.org/3.5/library/timeit.html Bu modül küçük kod parçalarının çalışma sürelerini ölçmeyi sağlar. Hem komut satırı arayüzünehemdeçağrılabilirbirarayüzesahiptir.Çalışmasüreleriniölçmekiçinbirçokortak tuzaktan kaçınır. Tim Peters’in O’Reilly tarafından yayımlanan Python Cookbook kitabının “Algoritmalar”bölümününgirişinedegözatın. 47.12.1 Temel Örnekler Takipedenörnek,komutsatırıarayüzününüçdeğişikdeyiminasılkarşılaştırdığınıgösteriyor: python3 -m timeit ’"-".join(str(n) for n in range(100))’ 10000 loops, best of 3: 29 usec per loop python3 -m timeit ’"-".join([str(n) for n in range(100)])’ 10000 loops, best of 3: 25.3 usec per loop python3 -m timeit ’"-".join(map(str, range(100)))’ 10000 loops, best of 3: 20 usec per loop Bu,Pythonarayüzündenşukodlarlagerçekleştirilebilir: import timeit timeit.timeit(’"-".join(str(n) for n in range(100))’, number=10000) 0.30339929000001575 timeit.timeit(’"-".join([str(n) for n in range(100)])’, number=10000) 0.2637243290000697 timeit.timeit(’"-".join(map(str, range(100)))’, number=10000) 0.2151021940001101 timeit sadece komut satırı arayüzü kullanıldığında yineleme sayısını otomatik olarak belirleyecektir.Örneklerbölümündegelişmişörneklerbulabilirsiniz. 47.12.2 Python Arayüzü Modül,üçkolaylıkfonksiyonuvebirtopluluksınıfıtanımlar: timeit.timeit(stmt=’pass’, setup=’pass’, timer=<default timer>, number=1000000, globals=None) Veriliifadeyle,kurulumkoduylavetimerfonksiyonuylabirTimerörneğioluşturun ve onun timeit() yöntemini çalıştırma sayıları ile çalıştırın. İsteğe bağlı globals bağımsızdeğişkeni,kodunçalıştırılacağıadalanınıbelirtir. Sürüm3.5’dedeğiştirildi:İsteğebağlıglobalsbağımsızdeğişkenieklendi. 47.12. timeitModülü 1089 PythonBelgeleri,Yayım4.1.3 timeit.repeat(stmt=’pass’, setup=’pass’, timer=<default timer>, repeat=3, number=1000000,globals=None) Veriliifadeyle,kurulumkoduylavetimerfonksiyonuylabirTimerörneğioluşturun ve onun repeat() yöntemini tekrarlanma sayısı ve çalıştırma sayıları ile çalıştırın. İsteğebağlıglobalsbağımsızdeğişkeni,kodunçalıştırılacağıadalanınıbelirtir. Sürüm3.5’dedeğiştirildi:İsteğebağlıglobalsbağımsızdeğişkenieklendi. timeit.default_timer() Herzamantime.perf_counter()olanvarsayılanzamanlayıcı Sürüm3.3’dedeğiştirildi:Şimdivarsayılansayıcıtime.perf_counter() classtimeit.Timer(stmt=’pass’,setup=’pass’,timer=<timerfunction>,globals=None) Küçükkodparçalarınınçalışmahızınınzamanlamasıiçinsınıf. Yapıcı; zamanlamanın yapılması için bir ifade, kurulum için fazladan bir ifade ve zamanlama fonksiyonu alır. Her ifadenin varsayılan değeri pass olur; timer fonksiyonu platforma bağımlıdır (docstring modülüne bakınız). Ayrıca stmt ve setup,birbirlerinden‘;’işaretiileayrılançoksayıdaifadeyiiçerebilirveyaçoksatır başıolandizideğişkenleriniiçermedikçeyenisatırlarıiçerebilir.Deyimvarsayılan olaraktimeit’inadalanındayürütülecektir;budavranış,globalalanabirisimalanı geçirerekkontroledilebilir. Birinci ifadenin çalışma hızını ölçmek için timeit() yöntemini kullanın. repeat(), timeit() yöntemini bir çok kez çağırmak ve sonuç listesini geri döndürmek için bir kolaylıktır.setupparametresininçalışmazamanı,bütünçalışmazamanındanhariç tutulmuştur. stmtvesetupparametreleriargümansızçağrılabilennesneleralabilir.Bu,çağrıları, sonradan timeit() fonksiyonuyla çalıştırılacak şekilde, timer fonksiyonunun içine gömer.Budurumdailavefonksiyonçağrılarınedeniylezamanlamayükününbiraz dahafazlaolacağınıunutmayın. Sürüm3.5’dedeğiştirildi:İsteğebağlıolarakglobalsparametresieklendi. timeit(number=1000000) Anaifadeninzamansayısıylailgiliçalışmaları.Bu,birkezsetupifadesini çalıştırır ve sonra ana ifadeyi birkaç kez çalıştırmak için, float tipinde saniyelerle ölçülen zamanı geri döndürür. Döngünün kaç kez tekrar edileceğiniargümanbelirler,varsayılandeğeribirmilyondur.Anaifade, setupifadesivetimerfonksiyonuyapıcıyageçirilmekiçinkullanılırlar. Not: Varsayılan olarak, timeit() fonksiyonu zamanlama süresince garbage collection’u etkisiz bırakır. Bu yaklaşımın avantajı, bağımsız zamanlamaları daha çok karşılaştırılabilir yapmaktır. Dezavantajı ise, garbage collection (çöp toplayıcısı), ölçüm esnasında fonksiyonun performansının önemli bir parçası olabilir. Böylece garbage collection (çöptoplayıcısı)setupdeğişkeninin(stringinin)ilkifadesiolarakyeniden aktifedilebilir.Örneğin: timeit.Timer("for i in range(10): oct(i)", "gc.enable()"). timeit() ˓→ 1090 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 repeat(repeat=3,number=1000000) timeit()’ibirkaçkezçağırır. Bu timeit()’i tekrar çağıran, sonuçları listeleyen bir kolaylık fonksiyonudur. Birinci argüman timeit()’in kaç kez çağrılacağını belirler. İkinciparametreisetimeit()’inargümanıdır. Not: Sonuç vektörlerinden alınan değerlerin aritmetik ortalamasını ve standart sapmasını rapor olarak sunmada cazip bir yöntemdir. Ancak bu çok kullanışlı değildir. Tipik bir durumda, en küçük değer, makinenin verili kod parçasını ne kadar hızlı şekilde çalıştırdığına dair zayıfbirgöstergedir;sonuçvektörleriiçindekiyüksekdeğerlerPython’ın hızının değişkenliğinden kaynaklanmaz, ancak diğer işlemlerin tutarlı zamanlamaçalışmasınakarışmasındankaynaklanır.Yaniendüşükdeğer sizinilgilenmenizgerekentekdeğerolabilir.Ondansonra,bütünvektöre bakıpistatistikyerinesağduyuyabaşvurabilirsiniz. print_exc(file=name) Zamanlamakodunungeriizinibastırmayayardımcıolur. Tipikkullanım: t = Timer(...) #try/except bloğunun dışında try: t.timeit(...) # ya da t.repeat(...) except Exception: t.print_exc() Standart geri izinin avantajı, derlenen şablondaki kaynak çizgilerinin görüntülenecek olmasıdır. İsteğe bağlı file argümanı geri izinin nereye gönderileceğinibelirler,varsayılandeğerisys.stderr’dir. 47.12.3 Komut Satırı Arayüzü Birprogramolarakkomutsatırıarayüzündençağrılırkenşuyapıkullanılır: python -m timeit [-n N] [-r N] [-u U] [-s S] [-t] [-c] [-h] [statement ...] Takipedenseçenekler: -n N, --number=N İfadenin kaç kez çalıştırılacağını belirler. -r N, --repeat=N timer’ın kaç kez tekrar edileceğini (varsayılan değeri 3) belirler. -s S, --setup=S Bir kez ilksel olarak çalıştırılacak ifadeyi (varsayılan değeri ‘pass‘)␣ (sonrakisayfayadevam) 47.12. timeitModülü 1091 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) belirler. ˓→ -p, --process Duvar saati zamanını değil de, işlem zamanını ölçer. Varsayılan değeri␣ ‘time.perf_counter()‘ yerine ‘time.process_time()‘’dir. ˓→ Sürüm 3.3’de gelmiş yeni bir özellik. -t, --time (onaylanmamış) ‘time.time()‘’ı kullanır. -u, --unit=U Zamanlayıcı çıktısının zaman birimini belirler; usec, msec veya sec␣ birimleri seçilebilir. ˓→ Sürüm 3.5’de gelmiş yeni bir özellik. -c, --clock (onaylanmamış) ‘time.clock()‘’u kullanır. -v --verbose Ham zamanlama sonuçlarını bastırır, daha fazla basamak kesinliği için␣ tekrarlar. ˓→ -h -help Kısa bir kullanım mesajı bastırır ve sonlanır. Çok satırlı ifadeler, her bir satırı ayrı bir ifade argümanı olacak şekilde verilebilir; girintili çizgiler,birargümanıntırnakişaretleriiçinealınarakveöndegelenboşluklarlakullanılabilir. Şayet-ndeğerigirilmezse,uygundöngüsayısı,toplamsüre0.2saniyeolanakadaronunüstleri olacakşekildehesaplanır. default_timer() ölçümleri makinede çalışan diğer programlar tarafından etkilenebilir, bu yüzdenhassasölçümyapmakgerektiğindeeniyisi,zamanlamayıbirkaçkeztekraretmekve enuygunzamanıseçmektir.-rseçeneğibuişlemiçinuygundur;varsayılanüçyinelemesayısı birçokdurumdayeterlidir.CPUsüresiniölçmekiçintime.process_time()’ıkullanabilirsiniz. Not: Bir geçiş ifadesi çalıştırmakla ilgili belirli bir temel yük vardır. Buradaki kod bunu gizlemeye çalışmaz fakat siz bunun farkında olmalısınız. Temel yük, programı argümansız çağırarakölçülebilirvePythonsürümleriarasındafarklılıklargösterir. 1092 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.12.4 Örnekler Sadecebaşlangıçtabirkezçalıştırılmaküzerebirsetup(kurulum)ifadesikullanılabilir: python -m timeit -s ’text = "sample string"; char="g"’ ’char in text’ 10000000 loops, best of 3: 0.0482 usec per loop python -m timeit -s ’text = "sample string"; char="g"’ ’text.find(char)’ 10000000 loops, best of 3: 0.178 usec per loop Pythonarayüzüiçin: import timeit timeit.timeit(’char in text’, setup=’text = "sample string"; char = "g"’) 0.048954748002870474 timeit.timeit(’text.find(char)’, setup=’text = "sample string"; char = "g"’) 0.2300617519977095 Aynıişlemtimer()sınıfınıvemetotlarınıkullanarakdayapılabilir: import timeit t = timeit.Timer(’char in text’, setup=’text = "sample string"; char = "g"’) t.timeit() 0.049284196000371594 t.repeat() [0.051710191000893246, 0.04452369999853545, 0.04527571799917496] Sonrakiörneklerçoksatırlıifadelerinzamanölçümününnasılyapılacağınıgösterir.Aşağıdaki örnekte, hasattr() ve try/except’in maliyeti, nesne özelliklerinin nasıl kaybedilip ortaya konduğunutestetmekiçinkarşılaştırılmıştır: python -m timeit ’try:’ ’ str.__bool__’ ’except AttributeError:’ ’ pass’ 1000000 loops, best of 3: 0.99 usec per loop python -m timeit ’if hasattr(str, "__bool__"): pass’ 1000000 loops, best of 3: 0.476 usec per loop python -m timeit ’try:’ ’ int.__bool__’ ’except AttributeError:’ ’ pass’ 1000000 loops, best of 3: 0.966 usec per loop python -m timeit ’if hasattr(int, "__bool__"): pass’ 1000000 loops, best of 3: 0.479 usec per loop Pythonarayüzüiçin: import timeit # özellik kayıp s = """\ (sonrakisayfayadevam) 47.12. timeitModülü 1093 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) try: str.__bool__ except AttributeError: pass """ timeit.timeit(stmt=s, number=100000) 0.08558237599936547 s = "if hasattr(str, ’__bool__’): pass" timeit.timeit(stmt=s, number=100000) 0.0541383109994058 # özellik mevcut s = """\ try: int.__bool__ except AttributeError: pass """ timeit.timeit(stmt=s, number=100000) 0.011753970000427216 s = "if hasattr(int, ’__bool__’): pass" timeit.timeit(stmt=s, number=100000) 0.016129147999890847 timeit()’i tanımladığınız fonksiyonda kullanmak için önemli bir ifade içeren bir setup parametresigeçirebilirsiniz: def test(): """Test fonksiyonu""" L = [i for i in range(100)] if __name__ == ’__main__’: import timeit print(timeit.timeit("test()", setup="from __main__ import test")) 4.163065000997449 Bir diğer seçenek şimdiki global ad alanı içerisinde çalıştırılacak globals()’i genel alan parametrelerinegeçirmektir.Bubireyselolarakiçeaktarmalarıbelirtmeyegöredahakolaydır: def f(x): return x**2 def g(x): return x**4 def h(x): (sonrakisayfayadevam) 1094 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) return x**8 import timeit print(timeit.timeit(’[func(42) for func in (f,g,h)]’, globals=globals())) 1.632076413003233 timeit’ikullanarakbenzerişlemleriyapankodlardanhangisinindahaperformanslıolduğunu görebilirsiniz: python -m timeit ’"a" + "b"’ 100000000 loops, best of 3: 0.0183 usec per loop python -m timeit ’"{}.{}".format("a", "b")’ 1000000 loops, best of 3: 0.215 usec per loop python -m timeit ’"%s%s" %("a", "b")’ 10000000 loops, best of 3: 0.117 usec per loop python -m timeit ’"".join(("a", "b"))’ 10000000 loops, best of 3: 0.109 usec per loop Pythonarayüzüiçin: import timeit timeit.timeit(’"a" + "b"’, number=1000000) 0.018340642998737167 timeit.timeit(’"{}{}".format("a", "b")’, number=1000000) 0.3770097929991607 timeit.timeit(’"%s%s" %("a", "b")’, number=1000000) 0.2078534940010286 timeit.timeit(’"".join(("a", "b"))’, number=1000000) 0.1585119779992965 47.13 sys Modülü Tıpkı os modülü gibi, sys de Python programlama dilindeki önemli standart kütüphane modüllerinden biridir. Bu modül, kullandığınız Python sürümü ile ilgili bilgi edinmenizi ve kullandığınızPythonsürümüileçeşitliişlemleryapabilmenizisağlar. Bütünmodüllerdeolduğugibi,bumodülüdeşukomutlaiçeaktarıyoruz: >>> import sys Bu modülün içinde hangi nitelik ve fonksiyonların olduğunu görmek için şu komutu kullanabileceğinizibiliyorsunuz: 47.13. sysModülü 1095 PythonBelgeleri,Yayım4.1.3 >>> dir(sys) Gördüğünüz gibi bu modül içinde de epeyce fonksiyon ve nitelik var. Biz bu bölümde, sys modülününenyaygınkullanılan,enönemlifonksiyonveniteliklerinielealacağız. İlkolarakexit()fonksiyonuilebaşlayalım... 47.13.1 sys.exit() sys modülünün exit() fonksiyonunu kullanarak, programınızın işleyişini durdurabilir, programınızıkapanmayazorlayabilirsiniz.Basitbirörnekverelim: import sys sayı = input(’Bir sayı girin: ’) if int(sayı) < 0: print(’çıkılıyor...’) sys.exit() else: print(sayı) Eğer kullanıcı 0’dan küçük bir sayı girerse programımız sys.exit() komutunun etkisiyle çalışmayıdurdurupkapanacaktır. 47.13.2 sys.argv sys modülünün argv niteliği, yazdığımız program çalıştırılırken kullanılan parametreleri bir listehalindetutar. Gelinistersenizbununnedemekolduğunubirörneküzerindegösterelim. Şimdimeselamasaüstündedeneme.pyadlıbirdosyaoluşturunveiçineşunlarıyazın: import sys print(sys.argv) Buprogramışukomutlaçalıştırın: python deneme.py Programıçalıştırdığınızdaşunabenzerbirçıktıalacaksınız: [’deneme.py’] Gördüğünüz gibi, sys.argv komutu bize bir liste veriyor. Bu listenin ilk öğesi, yazdığımız programınadı.Yanideneme.py. Şimdiaynıprogramıbirdeşuşekildeçalıştıralım: 1096 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 python deneme.py parametre Budefaprogramımızbizeşuçıktıyıverecek: [’deneme.py’, ’parametre’] Gördüğünüz gibi, sys.argv komutu, programın ismi ile birlikte, bu programa parametre olarak verilen değerleri de bir liste halinde saklıyor. Bu oldukça önemli ve kullanışlı bir özelliktir.Buözelliktenpekçokfarklışekillerdeyararlanabilirsiniz. Mesela: import sys def çık(): print(’Çıkılıyor...’) sys.exit() if len(sys.argv) < 2: print(’Gerekli parametreleri girmediniz!’) çık() elif len(sys.argv) > 2: print(’Çok fazla parametre girdiniz!’) çık() elif sys.argv[1] in [’-v’, ’-V’]: print(’Program sürümü: 0.8’) else: mesaj = ’Girdiğiniz parametre ({}) anlaşılamadı!’ print(mesaj.format(sys.argv[1])) çık() Buradaönceliklemodülümüzüiçeaktardık: import sys Bunuyapmadan,omodülükullanamayacağımızıbiliyorsunuz. Ardındançık()adlıbirfonksiyontanımladık: def çık(): print(’Çıkılıyor...’) sys.exit() Programısonlandırmakistediğimizdebufonksiyonukullanacağız. Dahasonraşöylebirifbloğuoluşturduk: if len(sys.argv) < 2: print(’Gerekli parametreleri girmediniz!’) çık() 47.13. sysModülü 1097 PythonBelgeleri,Yayım4.1.3 Eğer sys.argv listesinin uzunluğu 2’den düşükse, programımız herhangi bir parametre olmadan, yalnızca ismiyle çalıştırılmış demektir. Bu durumda kullanıcıya ‘Gerekli parametrelerigirmediniz!’mesajınıgösteripprogramısonlandırıyoruz. Sonrakikodbloğumuzşöyle: elif len(sys.argv) > 2: print(’Çok fazla parametre girdiniz!’) çık() Eğer sys.argv listesi 2’den büyükse, programımız birden fazla parametre ile çalıştırılmış demektir. Bu durumda kullanıcıya ‘Çok fazla parametre girdiniz!’ mesajını gösterip yine programısonlandırıyoruz. Birsonrakikodlarımızşöyle: elif sys.argv[1] in [’-v’, ’-V’]: print(’Program sürümü: 0.8’) Eğersys.argvlistesininikinciöğesi-vveya-Viseprogramımızınsürümbilgisiniveriyoruz. Sonolarakdaşubloğuyazıyoruz: else: mesaj = ’Girdiğiniz parametre ({}) anlaşılamadı!’ print(mesaj.format(sys.argv[1])) çık() Kullanıcının -v veya -V dışında bir parametre girmesi durumunda ise, girilen parametrenin anlaşılamadığıkonusundakullanıcıyıbilgilendiripprogramdançıkıyoruz. Aşağıda,programımızınhangikomutlarahangikarşılıklarıverdiğinigörüyorsunuz: C:\Users\fozgul\Belgelerim> python deneme.py Gerekli parametreleri girmediniz! Çıkılıyor... C:\Users\fozgul\Belgelerim> python deneme.py -a Girdiğiniz parametre (-a) anlaşılamadı! Çıkılıyor... C:\Users\fozgul\Belgelerim> python deneme.py -a -b Çok fazla parametre girdiniz! Çıkılıyor... C:\Users\fozgul\Belgelerim> python deneme.py -v Program sürümü: 0.8 C:\Users\fozgul\Belgelerim> python deneme.py -V Program sürümü: 0.8 1098 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.13.3 sys.executable Eğer, yazdığınız bir programda, programınızın çalıştığı sistemdeki Python’ın çalıştırılabilir dosyasınınadınıveyolunuöğrenmenizgerekirsebuniteliğikullanabilirsiniz: >>> sys.executable C:\Python37python.exe 47.13.4 sys.getwindowsversion() Bufonksiyon,kullanılanWindowssürümüneilişkinbilgiverir: >>> sys.getwindowsversion() sys.getwindowsversion(major=5, minor=1, build=2600, platform=2, service_pack=’Service Pack 3’) . Uyarı BufonksiyonyalnızcaWindows’taçalışır.GNU/Linux’tabufonksiyontanımlıdeğildir. Bu fonksiyon kendi içinde de bazı nitelikler barındırır. Bunları görmek için şu komutu kullanabilirsiniz: >>> ver = sys.getwindowsversion() >>> dir(ver) [’__add__’, ’__class__’, ’__contains__’, ’__delattr__’, ’__dir__’, ’__doc__’, ’__eq__’, ’__format__’, ’__ge__’, ’__getattribute__’, ’__getitem__’, ’__getnewargs__’, ’__gt__’, ’__hash__’, ’__init__’, ’__iter__’, ’__le__’, ’__len__’, ’__lt__’, ’__mul__’, ’__ne__’, ’__new__’, ’__reduce__’, ’__reduce_ex__’, ’__repr__’, ’__rmul__’, ’__setattr__’, ’__sizeof__’, ’__str__’, ’__subclasshook__’, ’build’, ’count’, ’index’, ’major’, ’minor’, ’n_fields’, ’n_sequence_fields’, ’n_unnamed_fields’, ’platform’, ’product_type’, ’service_pack’, ’service_pack_major’, ’service_pack_minor’, ’suite_mask’] Buniteliklereerişmekiçinşusözdiziminikullanabilirsiniz: >>> ver.service_pack() 47.13. sysModülü 1099 PythonBelgeleri,Yayım4.1.3 47.13.5 sys.path Modüller konusunu işlerken sys modülünün path niteliğinden söz etmiştik. O yüzden orada söylediklerimizitekrarlamayacağız. 47.13.6 sys.platform osmodülünüincelerkenöğrendiğimiznameniteliğigibi,sysmodülününplatformadlıniteliği de,kodlarımızınçalıştığıişletimsistemihakkındabizebilgiverir: >>> sys.platform EğerbukomutuGNU/Linux’taverirseklinuxçıktısı,Windows’taverirsekwin32çıktısı,MacOS X’teverirsekdarvinçıktısıalırız. 47.13.7 sys.prefix sysmodülününprefixniteliğiPython’ınhangidizinekurulduğunugösterir: >>> sys.prefix ’/home/local/python’ Veya: >>> sys.prefix ’C:\\Python’ 47.13.8 sys.ps1 sysmodülününps1niteliği,etkileşimlikabuktaki‘>>>’işaretinitutar: >>> sys.ps1 ’>>> ’ Eğeristersenizbuişaretideğiştirebilirsiniz: >>> sys.ps1 = ’+++ ’ Bukomutuverdiktensonra‘>>>’işaretinin‘+++’olarakdeğiştiğinigöreceksiniz. 1100 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 47.13.9 sys.ps2 EtkileşimlikabuktaPythonbizdengirdiğimizkodlarındevamınıbeklediğinigöstermekiçin‘...’ işaretinikullanır: >>> a = 5 >>> if a == 5: ... sysmodülününps2niteliği,işteetkileşimlikabuktakidevamsatırlarındagördüğümüzbu‘...’ işaretinitutar: >>> sys.ps2 ’... ’ Eğeristersenizbuişaretideğiştirebilirsiniz: >>> sys.ps1 = ’--- ’ Bukomutuverdiktensonra‘...’işaretinin‘—’olarakdeğiştiğinigöreceksiniz. 47.13.10 sys.version sysmodülününversionniteliğikullandığınızPythonsürümüneilişkinayrıntılıbilgiverir: >>> sys.version ’3.7.0 (default, 19.08.2024, 12:24:55) [GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux’ 47.13.11 sys.version_info sysmodülününversion_infoniteliğidekullandığınızPythonsürümüneilişkinbilgiverir: >>> sys.version_info sys.version_info(major=|major3|, minor=|minor3|, micro=|micro3|, releaselevel=’final’, serial=0) Bunitelikkendiiçindebirtakımbaşkaniteliklerdebarındırır: >>> dir(sys.version_info) [’count’, ’index’, ’major’, ’micro’, ’minor’, ’n_fields’, ’n_sequence_fields’, ’n_unnamed_fields’, ’releaselevel’, ’serial’] Buniteliklerenasılulaşacağınızıbiliyorsunuz: >>> sys.version_info.major #büyük sürüm numarası >>> sys.version_info.minor #küçük sürüm numarası >>> sys.version_info.micro #minik sürüm numarası 47.13. sysModülü 1101 PythonBelgeleri,Yayım4.1.3 47.13.12 sys.winver sysmodülününwinverniteliğiPython’ınbüyüksürümnumarasıylaküçüksürümnumarasını verir: >>> sys.winver 3.7 . Uyarı BunitelikyalnızcaWindows’taçalışır;GNU/Linux’tatanımlıdeğildir. 47.13.13 sys.stdout Öncekiderslerimizdendebildiğinizgibistdout,‘standartçıktıkonumu’,yaniprogramlarımızın çıktılarınıstandartolarakverdiklerikonumanlamınageliyor. Python’dayazdığımızprogramlarçıktılarınıstandartolarakkomutsatırınaverir.Yanimesela: >>> print(’merhaba zalim dünya’) komutunuverdiğimizde,bukomutunçıktısıkomutekranındagörünecektir. Python’da standart çıktı konumununun neresi olacağı bilgisi sys modülünün stdout adlı niteliğiiçindetutulur: >>> import sys >>> sys.stdout <_io.TextIOWrapper name=’<stdout>’ mode=’w’ encoding=’cp1254’> Standart çıktı konumuna yazmanın en yaygın yolunun print() komutunu kullanmak olduğunubiliyoruz.Bukomut,standartçıktıkonumuneresiiseorayayazacaktır. Standart çıktı konumuma yazmanın başka bir yolu da doğrudan sys.stdout niteliğinin write()metodunukullanmaktır. Dikkatlicebakın: >>> sys.stdout.write(’merhaba zalim dünya’) print()komutundanfarklıolaraksys.stdout.write()fonksiyonuşöylebirçıktıverir: merhaba zalim dünya19 Burada, çıktının sonundaki 19 sayısı ‘merhaba zalim dünya’ karakter dizisinin uzunluğunu gösteriyor.sys.stdout.write()fonksiyonuetkileşimlikabuktakullanıldığındaböylebirçıktı verir.Amaeğerbukodlarıbirdosyayayazıpçalıştırırsanızsonraki19sayısıgörünmez. Bu arada, her ne kadar print() ve sys.stdout.write() birbirine benzese de aralarında önemli farklar bulunur. Örneğin print() fonksiyonu parametre olarak her türlü veri tipini alabilir. Ancak sys.stdout.write() fonksiyonu parametre olarak yalnızca karakter dizisi alabilir: 1102 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 >>> sys.stdout.write(12) Traceback (most recent call last): File "<stdin>", line 1, in <module> TypeError: must be str, not int Dolayısıylasys.stdout.write()fonksiyonunaparametreolarakvereceğinizdeğeriöncelikle karakterdizisineçevirmenizgerekir: >>> sys.stdout.write(str(12)) 122 (cid:242) Not Sondaki 2 sayısının ‘12’ karakter dizisinin uzunluğunu gösterdiğini söylemiştik. Bu kodları dosyayayazıpçalıştırdığınızdayalnızca12çıktısıalırsınız. print() ile sys.stdout.write() arasındaki önemli bir fark da, print() fonksiyonu yazma işleminden sonra bir sonraki satıra geçerken, sys.stdout.write() fonksiyonunun geçmemesidir. . Uyarı sys.stdout.write() fonksiyonu etkileşimli kabuktan çalıştırıldığında ve dosyadan çalıştırıldığındabirbirindenfarklıçıktılarverir.Oyüzdenaşağıdakiörnekleridosyayayazıp çalıştırmanızıtavsiyeederim. Meselaşuörneğebakalım: for i in ’’: print(i) Bukomutşuçıktıyıverir: i s t i h z a Gördüğünüzgibi,print()fonksiyonu,döngüyegirenheröğeyiyenisatırabasıyor. Birdesys.stdout.write()fonksiyonununneyaptığınabakalım: import sys (sonrakisayfayadevam) 47.13. sysModülü 1103 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) for i in ’’: sys.stdout.write(i) Bukomutlariseşuçıktıyıverir: Gördüğünüz gibi, sys.stdout.write() fonksiyonu öğelerin hepsini aynı satıra bastı. Eğer öğelerinayrısatırlarabasılmasınıistiyorsanızbunuaçıkçabelirtmelisiniz: import sys for i in ’’: sys.stdout.write(i+’\n’) sys.stdout.write()fonksiyonununotomatikolaraksatırbaşıkarakterinibasmıyoroluşunu kullanarakkronometrebenzeribirprogramyazabilirsiniz: import sys sayaç = 0 while True: sys.stdout.write(str(sayaç)+’\r’) sayaç += 1 Burada, önceki derslerimizde öğrendiğimiz kaçış dizilerinden \r’yi kullanarak, her öğenin ekranabasılmasınınardındansatırınenbaşınadönülmesinisağladık.Böyleceöğeleryanyana değildebirbirlerininüstünebasılmışoldu. Bu arada, eğer yukarıdaki kodlar herhangi bir çıktı vermeden bekliyorsa, kodları şu şekilde yazın: import sys sayaç = 0 while True: sys.stdout.write(str(sayaç)+’\r’) sys.stdout.flush() sayaç += 1 Burada eklediğimiz sys.stdout.flush() satırı, Python’ın tamponda beklettiği verileri çıktıya göndermesini sağlar. Siz bu ‘flush’ kavramını print() fonksiyonundan hatırlıyor olmalısınız (print()fonksiyonununflushparametresi). Hatırlarsanız, ‘flush’ kavramının yanısıra, print() fonksiyonunu işlerken öğrendiğimiz bir başka kavram da standart çıktı konumunun değiştirilmesi idi. print() fonksiyonuna verdiğimizfileparametresiyardımıylaprogramlarımızınstandartolarakçıktıverdiğikonumu değiştirebiliyorduk: 1104 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 f = open(’çıktılar.txt’, ’w’) print(’merhaba zalim dünya’, file=f) Burada çıktılar.txt adlı bir dosya oluşturduk ve bunu print() fonksiyonunun file parametresineatayarak,çıktılarıkomutsatırıyerineçıktılar.txtadlıdosyayagönderdik. Aynıişlemisys.stdoutaracılığıyladayapabileceğimizibiliyorsunuz: import sys f = open(’çıktılar.txt’, ’w’): sys.stdout = f sys.stdout.write(’merhaba zalim dünya’) Gerçi bu sizin bilmediğiniz bir şey değil. Zira siz bunu print() Fonksiyonu konusunu işlerken degörmüştünüz... 47.13.14 sys.stderr Öncekibölümdegördüğümüzşukodlarıtekrarönümüzealalım: import sys f = open(’çıktılar.txt’, ’w’) sys.stdout = f sys.stdout.write(’merhaba zalim dünya’) Bu kodlar, bildiğiniz gibi, çıktı olarak verilmek istenen değerlerin çıktılar.txt adlı bir dosyaya yönlendirilmesinisağlıyor.Ancakkodlarımızıbuşekildeyazdığımızdasadecenormaldeğerler yönlendirilecektir. Mesela çalışma esnasında ortaya çıkan hatalar yine komut ekranına basılmayadevamedecektir: import sys f = open(’çıktılar.txt’, ’w’) sys.stdout = f sys.stdout.write(1/0) Bu kodları çalıştırdığınızda, standart çıktı konumu yönlendirilmiş olmasına rağmen, hata mesajıkomutsatırınabasılacaktır: Traceback (most recent call last): File "deneme.py", line 5, in <module> sys.stdout.write(1/0) ZeroDivisionError: division by zero Çünkü Python’da hata mesajlarının öntanımlı olarak basıldığı yer komut satırıdır. Nasıl çıktılarınstandartolarakbasıldığıyeriteknikolarak‘standartçıktıkonumu’(StandardOutput - stdout) olarak adlandırıyorsak, hataların standart olarak basıldığı yeri de teknik olarak ‘standarthatakonumu’(StandardError-stderr)olarakadlandırıyoruz. Tıpkıstdout’umanipüleedebildiğimizgibi,stderr’idemanipüleedebiliriz: 47.13. sysModülü 1105 PythonBelgeleri,Yayım4.1.3 import sys f =open(’hatalar.txt’, ’w’) sys.stderr = f sys.stderr.write(1/0) Budurumda,programımızınişleyişisırasındaortayaçıkanhatalarhatalar.txtadlıbirdosyaya yönlendirilecektir. Bubilgiyikullanarakşöylebirkoddayazabiliriz: import sys çıktılar = open(’çıktılar.txt’, ’w’) hatalar = open(’hatalar.txt’, ’w’) sys.stdout = çıktılar sys.stderr = hatalar print(’normal çıktı’) print(’hata mesajı: ’, 1/0) Bukodlarıçalıştırdığınızda,hatamesajıüretmedenbaşarıylatamamlanançıktılarınçıktılar.txt adlıdosyaya,hatamesajlarınınisehatalar.txtadlıdosyayayönlendirildiğinigöreceksiniz. 47.13.15 sys.stdin Python’daüçadetstandartkonumbulunur: 1. Standartçıktıkonumu-stdout 2. Standarthatakonumu-stderr 3. Standartgirdikonumu-stdin İlkikisinizatengörmüştük.Üçüncüsünüdeşimdielealacağız. BildiğinizgibiPython’dakullanıcıdanverialmakiçininput()fonksiyonunukullanıyoruz: sayı = input(’Lütfen bir sayı girin: ’) Bu fonksiyonun görevi, standart girdi konumuna girilen verileri okumaktır. Python’daki standartgirdikonumu(genellikle)komutsatırıolduğuiçin,input()fonksiyonuverilerikomut satırındanokur. Python’da standart girdi konumunu tutan değişken sys.stdin’dir. Dolayısıyla eğer isterseniz, verileri kullanıcıdan input() fonksiyonu yerine doğrudan sys.stdin niteliği aracılığıyla da alabilirsiniz: >>> import sys >>> sys.stdin.read() Bu komutları verdiğinizde, komut satırı sizden veri almaya hazır hale gelir. Bu şekilde istediğiniz kadar veriyi komut satırına girebilirsiniz. Veri girişini durdurmak istediğinizde ise 1106 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Windows’ta CTRL+C, GNU/Linux’ta ise CTRL+D tuşlarına basmanız gerekir. Bu şekilde komut satırınıterkettiğinizde,girmişolduğunuzdeğerlerbirkarakterdizisiolarakekranabasılacaktır. sys.stdinniteliği,bizeveriokumakiçinüçfarklıfonksiyonsunar: 1. sys.stdin.read() 2. sys.stdin.readline() 3. sys.stdin.readlines() read()fonksiyonubirdenfazlasatıriçerenverileringirilmesinemüsaadeederveçıktıolarak birkarakterdizisiverir: >>> sys.stdin.read() (Girdi) Fırat Özgül Adana (Çıktı) ’Fırat\nÖzgül\nAdana\n’ readline() fonksiyonu tek bir satır içeren verilerin girilmesine müsaade eder ve çıktı olarak birkarakterdizisiverir: >>> sys.stdin.readline() (Girdi) Fırat (Çıktı) ’Fırat\n’ readlines() fonksiyonu birden fazla satır içeren verilerin girilmesine müsaade eder ve çıktı olarakbirlisteverir: >>> sys.stdin.readlines() (Girdi) Fırat Özgül Adana (Çıktı) [’Fırat\n’, ’Özgül\n’, ’Adana\n’] Gelinistersenizsys.stdinniteliğininnasılkullanılabileceğineilişkinbirkaçörnekverelim: import sys with open(’kayıtlar.txt’, ’w’) as kayıtlar: while True: satırlar = sys.stdin.readline() if satırlar.strip() == ’:q’: break else: kayıtlar.write(satırlar) 47.13. sysModülü 1107 PythonBelgeleri,Yayım4.1.3 Buradakayıtlar.txtadlıbirdosyaoluşturduköncelikle.Dahasonradareadline()fonksiyonu aracılığıyla kullanıcıdan aldığımız bütün verileri bu dosyaya yazdık. Kullanıcının programdan çıkabilmesini sağlamak için de ‘:q’ tuş kombinasyonunu ayarladık. Böylece komut satırından çalışanbasitbirmetindüzenleyiciyazmışolduk! Tıpkı sys.stdout ve sys.stderr konumlarını değiştirdiğimiz gibi, sys.stdin konumunu da değiştirebiliriz. Böylece verileri komut satırı aracılığıyla değil, mesela bir dosya aracılığıyla alabiliriz. Aşağıdakiörneğidikkatliceinceleyin: import sys f = open(’oku.txt’) sys.stdin = f while True: satırlar = sys.stdin.readline() if satırlar.strip() == ’:q’: break else: sys.stdout.write(satırlar) Bu kodları yazdıktan sonra, bu kodların bulunduğu dizinde oku.txt adlı bir dosya oluşturun. Ardından programınızı çalıştırın. Programınız şu anda sizden veri girmenizi bekliyor. Verileri oku.txtadlıdosyayagireceksiniz. oku.txt adlı dosyayı açıp bir şeyler yazın. Veri girerken dosyayı her kaydedişinizde dosya içindeki verilerin komut satırına düştüğünü göreceksiniz. Veri girişini tamamladıktan sonra dosyanınensonsatırına‘:q’yazıpdosyayıkaydettiğinizandadaprogramınızkapanacaktır. 47.14 argparse Modülü 47.14.1 Giriş Yazdığımızheruygulamagrafikarayüzünesahipolmaz.Bazıuygulamalarkomutsatırınadaha uygundurvebuuygulamalarbazıparametrelereihtiyaçduyar.argparsemodülükullanıcıdan aldığımız parametreler için yardım mesajları, nasıl kullanıldığına yönelik mesajları üretir. Ayrıcabumodülkullanıcıgeçersizparametregirerseuygunhatamesajınıbastırır. AyrıştırıcıOluşturmak İlk olarak modülümüzü dahil etmemiz gerekiyor. Modülümüzü dahil ettikten sonra ayrıştırıcımıziçinnesneoluşturuyoruz.: import argparse ArdındanArgumentParserüzerindenyenibirnesneoluşturuyoruz.: 1108 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 ayristirici = argparse.ArgumentParser(description=’Bu uygulama bazı işler␣ yapıyor.’) ˓→ Artıkargümanlarekleyebiliriz. ArgümanEklemek ArgumentParser nesnesine gerekli tüm bilgileri verdikten sonra, add_argument() fonksiyonu ileargümanlarıekleyebiliriz. Örnek: ayristirici.add_argument(’-i’, ’--ilk_arguman’, nargs=’+’, required=False, help= "Bu ilk argümandır") ˓→ ayristirici.add_argument(’-a’, ’--ikinci_arguman’, required=False, help="Bu␣ ikinci argümandır") ˓→ İki argümanımızı eklemiş olduk. Şimdi ayristirici.print_help() ile çıktımızı bastıralım ve inceleyelim. Not: Normal şartlarda argparse modülü komut satırı için uygundur ancak etkileşimli kabukta çalışırken sonuçları görmek için argparse modülünün print_help() fonksiyonunukullanacağız. ArgümanAyrıştırmak ArgumentParser nesnesi parse_args() fonksiyonu yardımıyla argümanları ayrıştırmamıza sağlar.Etkileşimlikabuğumuza: ayristirici.parse_args([’-a’, ’7’]) yazalımveçıktımızıinceleyelim. Çıktımız: Namespace(ikinci_arguman=’7’) parse_args fonksionuna biz ‘-a’ parametresine vermemize rağmen ayrıştırıcımız bize argümaninikinciisminiveonaatadığımızdeğeri-7-verdi. 47.14.2 ArgumentParser Nesnesi TemelolarakArgumentParsernesnemizinyapısı: class argparse.ArgumentParser(prog=None, usage=None, description=None,␣ epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars= ˓→ ’-’, fromfile_prefix_chars=None, argument_default=None, conflict_handler= ˓→ ’error’, add_help=True, allow_abbrev=True) ˓→ Yeni bir ArgumentParser nesnesi oluşturulduğunda alacağı tüm argümanlar anahtar kelime -keyword-olarakiletilmeli. 47.14. argparseModülü 1109 PythonBelgeleri,Yayım4.1.3 ArgümanlarveAçıklamaları • prog:Uygulamanınadı(varsayılan:sys.argv[0]) • usage: Uygulamanın kullanım amacını açıklayan bir metin. (varsayılan: Uygulamaya eklenenparametrelerdenoluşur) • description:Argümanyardımındanönceekranaçıkaraçıklamametni(varsayılan:None) • epilog:Argümanyardımındansonraekranaçıkanaçıklamametni(varsayılan:None) • parents:FarklıbirArgumentParsernesnesininsahipolduğuargümanlarıdahileder. • formatter_class:Yardımçıktılarınıkişiselleştirir. • prefix_chars:İsteğebağlıargümanlarınönünekonulankarakteriayarlar.(varsayılan:-) • fromfile_prefix_chars: Ek argümanların okunması gereken dosyayı önekleyen karakter kümesi.(varsayılan:None) • argument_default:Argümanlariçinglobaldeğer.(varsayılan:None) • conflict_handler:Çakışanargümanlariçinçözümstratejisi.(genelliklegereksiz) • add_help:-h/–helpseçeneğiniayrıştırıcıyaekler.(varsayılan:True) • allow_abbrev: Kısaltmalar net değilse uzun seçeneklerin kısaltılmasını sağlar. (Varsayılan:None) progargümanı ArgumentParser nesnesi varsayılan olarak sys.argv[0] çıktısını uygulama ismi olarak kullanır. Bugenellikletercihedilenbiryöntemdirçünküçoğuzamanuygulamaismiiledosyaismiaynı olur. ilkuygulama.pyisimlibirdosyaoluşturalımveiçinekodlarımızıyazalım: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, help=’foo yardım’) print(ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [--foo FOO] optional arguments: -h, --help show this help message and exit --foo FOO foo help Gördüğümüz gibi uygulama ismimiz ekrana çıktı ancak biz uygulamamızın ismini farklı kullanmak istiyorsak? O zaman ArgumentParser nesnesine prog parametresini uygulama isminiverelim: import argparse ayristirici = argparse.ArgumentParser(prog=’Bu benim ilk uygulamam’) (sonrakisayfayadevam) 1110 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ayristirici.add_argument(’--foo’, help=’foo yardım’) print(ayristirici.print_help()) Çıktımız: usage: Bu benim ilk uygulamam [-h] [--foo FOO] optional arguments: -h, --help show this help message and exit --foo FOO foo yardım Uygulamamızınismideğişti. usageargümanı Yazdığımız uygulamaya kullanıcı için küçük bir açıklama eklemek isteyebiliriz. Bu işlem için usageargümanıbizeyetişiyor. Hemenkodumuzudeneyelim.: import argparse ayristirici = argparse.ArgumentParser(usage=’Bu uygulama şimdilik tek parametre␣ alıyor. ’) ˓→ ayristirici.add_argument(’--parametre’, help=’parametre yardım’) print(ayristirici.print_help()) Çıktımız: usage: Bu uygulama şimdilik tek parametre alıyor. optional arguments: -h, --help show this help message and exit --parametre PARAMETRE parametre yardım Eğer biz usage parametresini kullanmasaydık o zaman uygulamamız varsayılan olarak tüm parametrelerinsıralıhalinikullanacaktı.: usage: ilkprogram.py [-h] [--parametre PARAMETRE] optional arguments: -h, --help show this help message and exit --parametre PARAMETRE parametre yardım 47.14. argparseModülü 1111 PythonBelgeleri,Yayım4.1.3 descriptionargümanı descriptionargümanıileuygulamamıziçinkısabilgivenasılçalıştığıhakkındaaçıklamasunar. Yardımmesajıveparametrelerarasındaaçıklamasunar. Kodumuzuyazalım: import argparse ayristirici = argparse.ArgumentParser(description=’Uygulama hakkında açıklama␣ metni’) ˓→ ayristirici.add_argument(’--parametre’, help=’parametre yardım’) print(ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [--parametre PARAMETRE] Uygulama hakkında açıklama metni optional arguments: -h, --help show this help message and exit --parametre PARAMETRE parametre yardım Varsayılan olarak çıktımız belli bir alana sığdırılır ancak bunu değiştirmek isterseniz ‘ ‘ formatter_class argümanıkullanılır. epilogargümanı Yazdığımız bazı uygulamalar daha fazla açıklamaya ihtiyaç duyabilir. Bunun için epilog parametresinikullanırız. Örnek: import argparse ayristirici = argparse.ArgumentParser(epilog=’Uygulama hakkında ikinci açıklama ’) ˓→ ayristirici.add_argument(’--parametre’, help=’parametre yardım’) print(ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [--parametre PARAMETRE] optional arguments: -h, --help show this help message and exit --parametre PARAMETRE parametre yardım Uygulama hakkında ikinci açıklama 1112 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Varsayılan olarak çıktımız belli bir alana sığdırılır ancak bunu değiştirmek isterseniz ‘ ‘ formatter_class argümanıkullanılır. parentsargümanı Bazı durumlarda, argüman ayrıştırıcılar ortak argüman kümesini paylaşabilir. Argüman tanımlarını tekrarlamak yerine ortak argümanları bir kere tanımlayarak tanımlayıp parents argümanı ile farklı ayrıştırıcılarda kullanabiliriz. parents argümanı ArgumentParser nesnesi alır.Pythondosyamızıaçalımvebukoduyazalım: import argparse ana_ayristirici = argparse.ArgumentParser(add_help=False) ana_ayristirici.add_argument(’--ilk_arguman’) ana_ayristirici.add_argument(’--ikinci_arguman’) ikinci_ayristirici = argparse.ArgumentParser(parents=[ana_ayristirici]) ikinci_ayristirici.add_argument(’ucuncu_arguman’) print(ikinci_ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [--ilk_arguman ILK_ARGUMAN] [--ikinci_arguman IKINCI_ARGUMAN] ucuncu_arguman positional arguments: ucuncu_arguman optional arguments: -h, --help show this help message and exit --ilk_arguman ILK_ARGUMAN --ikinci_arguman IKINCI_ARGUMAN parentsargümanıileana_ayristiricimızınargümanlarınıikinci_ayristirimizdakullanmışolduk. ‘ ‘ NOT: Ana ayrıştırıcımıza add_help=False eklememiz gerekir çünkü her iki ‘ ‘ ayrıştırıcımız -h/–help argümanınasahipolurvebuçakışmasebebiyleuygulamamız ‘ ‘ raise hatasıverir. add_helpargümanınıkaldırıpkodumuzuçalıştıralım: Traceback (most recent call last): File "ilkprogram.py", line 7, in <module> ikinci_ayristirici = argparse.ArgumentParser(parents=[ana_ayristirici]) File "/usr/lib/python3.7/argparse.py", line 1681, in __init__ self._add_container_actions(parent) File "/usr/lib/python3.7/argparse.py", line 1450, in _add_container_actions group_map.get(action, self)._add_action(action) File "/usr/lib/python3.7/argparse.py", line 1580, in _add_action action = super(_ArgumentGroup, self)._add_action(action) File "/usr/lib/python3.7/argparse.py", line 1390, in _add_action self._check_conflict(action) (sonrakisayfayadevam) 47.14. argparseModülü 1113 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) File "/usr/lib/python3.7/argparse.py", line 1529, in _check_conflict conflict_handler(action, confl_optionals) File "/usr/lib/python3.7/argparse.py", line 1538, in _handle_conflict_error raise ArgumentError(action, message % conflict_string) argparse.ArgumentError: argument -h/--help: conflicting option strings: -h, -- help ˓→ formatter_classargümanı ArgumentParser nesnesi alternatif bir biçimlendirme sınıfı tanımlayıp, yardım mesajlarını kişiselleştirilmesineizinverir.Şimdilikdörtsınıfasahiptir.: class argparse.RawDescriptionHelpFormatter class argparse.RawTextHelpFormatter class argparse.ArgumentDefaultsHelpFormatter class argparse.MetavarTypeHelpFormatter RawDescriptionHelpFormatter ve RawTextHelpFormatter metinsel açıklamaların nasıl görüneceği üzerinde daha fazla kontrol sağlar. Varsayılan olarak ArgumentParser nesnesi descriptionveepilogiçinsatırkaydırmaözelliğinesahiptir. Kodumuzudeneyelim: import argparse ayristirici = argparse.ArgumentParser( description=’’’Uzunca bir açıklama yazıyoruz ve alt satıra inelim.’’’, epilog=’’’ Uygulama sonu açıklama metnimiz.’’’) ayristirici.print_help() Çıktımız: usage: ilkprogram.py [-h] Uzunca bir açıklama yazıyoruz ve alt satıra inelim. optional arguments: -h, --help show this help message and exit Uygulama sonu açıklama metnimiz. Görüldüğü üzere biz alt satıra inmiş olsak bile çıktımız aynı satırda görünüyor. Şimdi uygulamamıza formatter_class parametresine RawDescriptionHelpFormatter ekleyelim. Kodumuzubuşekildedeğiştirelim: 1114 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 import argparse import textwrap ayristirici = argparse.ArgumentParser( formatter_class=argparse.RawDescriptionHelpFormatter, epilog=textwrap.dedent(’’’\ Uygulama sonu açıklama metnimiz. Burası ikinci satırımız.’’’)) ayristirici.print_help() Çıktımızıinceleyelim: usage: ilkprogram.py [-h] optional arguments: -h, --help show this help message and exit Uygulama sonu açıklama metnimiz. Burası ikinci satırımız. Görüldüğüüzereyazdığımızaçıklamametniikincisatırageçti. RawTextHelpFormatter maintains whitespace for all sorts of help text, including argument descriptions. However, multiple new lines are replaced with one. If you wish to preserve multipleblanklines,addspacesbetweenthenewlines. ArgumentDefaultsHelpFormatter sınıfı ile argümanların varsayılan değerleri hakkında bilgi eklenebilir.Örnek: import argparse ayristirici = argparse.ArgumentParser( formatter_class=argparse.ArgumentDefaultsHelpFormatter) ayristirici.add_argument(’--ilk_arguman’, type=int, default=81, help=’Bu␣ argüman varsayılan değeri 81!’) ˓→ ayristirici.add_argument(’ikinci_argüman’, default=[1, 2, 3], help=’İkinci␣ argüman yardim mesajı!’) ˓→ ayristirici.print_help() Çıktımız: usage: ilkprogram.py [-h] [--ilk_arguman ILK_ARGUMAN] ikinci_argüman positional arguments: ikinci_argüman İkinci argüman yardim mesajı! (default: [1, 2, 3]) optional arguments: -h, --help show this help message and exit --ilk_arguman ILK_ARGUMAN Bu argüman varsayılan değeri 81! (default: 81) Çıktımızabaktığımızzamanyardımmesajlarınınyanındavarsayılanolarakaldığıdeğerleribize gösteriyor. 47.14. argparseModülü 1115 PythonBelgeleri,Yayım4.1.3 MetavarTypeHelpFormattersınıfıileargümanınalacağıdeğerintipiniekranabasılır.Örnek: import argparse ayristirici = argparse.ArgumentParser( formatter_class=argparse.MetavarTypeHelpFormatter) ayristirici.add_argument(’--a’, type=int) ayristirici.add_argument(’--ikinci_argüman’, type=dict) ayristirici.print_help() Çıktımız: usage: ilkprogram.py [-h] [--a int] [--ikinci_argüman dict] optional arguments: -h, --help show this help message and exit --a int --ikinci_argüman dict Çıktımızabaktığımızdahangiargümanınalacağıdeğertipiargümanınyanındagörünür. prefix_charsargümanı Genellikle komut satırı uygulamalrında argümanlar - ön ekini alır. (Örnek: -f / –arguman) Ayrıştırıcımız bazı durumlarda farklı veya ek ön eklere ihtiyaç duyabilir. Örneğin: +f veya /arguman ArgumentParser nesnemizi oluştururken prefix_chars argümanını kullanarak bu isteğimizisağlarız.ÖrnekKod: import argparse ayristirici = argparse.ArgumentParser(prefix_chars=’-+’) ayristirici.add_argument(’+f’) ayristirici.add_argument(’++arguman’) ayristirici.print_help() Çıktımız: usage: ilkprogram.py [-h] [+f F] [++arguman ARGUMAN] optional arguments: -h, --help show this help message and exit +f F ++arguman ARGUMAN 1116 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 fromfile_prefix_charsargümanı Bazı zamanlar örneğin uzun argüman listelerini içeren bir uygulama yazdığımız zaman, argümanları komut satırında yazmak yerine bir dosya içerisinde tutmak daha mantıklı olur. ArgumentParser nesnesine fromfile_prefix_chars argümanı verildiği zaman daha sonra belirtilen karakterlerden herhangi biriyle başlayan argümanlar dosya olarak kabul edilir ve içerdikleriargümanlariledeğiştirilir.Kodumuzuyazalım: import argparse with open(’args.txt’, ’w’) as fp: fp.write(’-i\nbar’) ayristirici = argparse.ArgumentParser(fromfile_prefix_chars=’@’) ayristirici.add_argument(’-i’) print(ayristirici.parse_args([’@args.txt’])) Kodumuzusatırsatırinceleyelim. • withopen(... satırındaargs.txtdosyasınıwmodundaaçıyoruz. • fp.write... satırında i argümanını ekliyoruz ve i argümanına bar parametresini dosyamızayazıyoruz. • Üçüncüsatırımızdaayristiricinesnemizioluşturuyoruz. • Ardındaniargümanınıekliyoruz. • Busatırdaparse_argskomutuileargümanımızıvealacağıdeğerinidöndürüyoruz. Bir dosyadan okunan argümanlar varsayılan olarak her satırda bir tane olmalı ve komut satırındakiorijinaldosyabaşvuruargümanıileaynıyerdeymişgibielealınmalıdır.Bunedenle örnekte,[‘@args.txt36’]ifadesi[‘-i’,‘bar’]ifadesineeşdeğerolarakkabuledilir. argument_defaultargümanı Genellikle, argüman varsayılanları, varsayılan olarak add_argument() fonksiyonu veya belirli bir ad-değer çiftleri kümesiyle set_defaults() fonksiyonunun çağrılmasıyla belirlenir. Ancak bazı durumlarda bağımsız değişkenler için tek bir ayrıştırıcıyı varsayılan olarak belirlemek yararlıolablir.Örneğinparse_args()çağrıldığında,nitelikoluşturmayıglobalolarakbastırmak içinargument_default=SUPPRESS’ikullanırız.ÖrnekKod: import argparse ayristirici = argparse.ArgumentParser(argument_default=argparse.SUPPRESS) ayristirici.add_argument(’--arguman’) ayristirici.add_argument(’-ikinci_arguman’) print(ayristirici.parse_args([’--arguman’, ’1’, ’-ikinci_arguman’, ’python’])) print(ayristirici.parse_args([])) Çıktımız: 36’@args.txt 47.14. argparseModülü 1117 PythonBelgeleri,Yayım4.1.3 Namespace(arguman=’1’, ikinci_arguman=’python’) Namespace() Çıktımıza baktığımız zaman parse_args() fonksiyonuna değer verildiğinde bize ad alanı (namespace)olarakargümanımızıvealdığıdeğeridöndürüyor.İlkadalanımızistediğimizgibi çıktıyı verdi ikincisi ise boş şimdi argument_default=argparse.SUPPRESS’i kaldıralım ve çıktıyı tekrarkontroledelim. YeniÇıktımız: Namespace(arguman=’1’, ikinci_arguman=’python’) Namespace(arguman=None, ikinci_arguman=None) Görüldüğü üzere ikinci çıktımız bu sefer argümanın isimlerini ve değerlerini verdi ancak değerleriolmadığıiçinNoneolarakdöndü. allow_abbrevargümanı Normal şartlarda parse_args() fonksiyonuna argüman listesi verdiğiniz zaman uzun seçeneklerin kısaltmalarını kabul eder. Eğer bu özelliği devre dışı bırakmak isterseniz allow_abbrev=Falseşeklindekullanabilirsiniz. ÖrnekKod: import argparse ayristirici = argparse.ArgumentParser(allow_abbrev=True) ayristirici.add_argument(’--foobar’) ayristirici.add_argument(’--foonley’) print(ayristirici.parse_args([’--foon’, ’Argüman Değeri’])) Bukodumuzdaallow_abbrevdeğeriTrueçıktımızabaktığımızzaman: Namespace(foobar=None, foonley=’Argüman Değeri’) parse_args() fonksiyonuna –foon değeri vermemize rağmen Python devamını tamamladı ve –foonleyargümanınadeğeriatadışimdiallow_abbrevdeğeriniFalseyapalım. Çıktımız: usage: ilkprogram.py [-h] [--foobar FOOBAR] [--foonley FOONLEY] ilkprogram.py: error: unrecognized arguments: --foon Argüman Değeri Görüldüğü üzere ilkprogram.py: error: unrecognized arguments hatası verdi. Bu hatanın sebebikısaltmaolarakverdiğimizargümanıPythontanımadı. 1118 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 conflict_handlerargümanı ArgumentParser nesnesi varsayılan olarak aynı argümanların kullanımına izin vermez. Eğer aynıargümanlarıkullanmayadenersenizhataverecektir.Örnek: import argparse ayristirici= argparse.ArgumentParser() ayristirici.add_argument(’-i’, ’--ilk_argüman’, help=’eski argümanın yardım␣ metni’) ˓→ ayristirici.add_argument(’--ilk_argüman’, help=’yeni argümanın yardım metni’) Çıktımız: Traceback (most recent call last): ... raise ArgumentError(action, message % conflict_string) argparse.ArgumentError: argument --ilk_argüman: conflicting option string: -- ilk_argüman ˓→ İki argüman aynı olduğu için uygulamamız hata verdi. Bazen (örneğin parents argümanını kullandığımız zaman) Aynı argümanların eskisini geçersiz kılmak (üstüne yazmak) kullanışlı olablir. Bu özelliği kullanmak için conflict_handler argümanına resolve değerini veriyoruz. Örnek: import argparse ayristirici = argparse.ArgumentParser(conflict_handler=’resolve’) ayristirici.add_argument(’-i’, ’--ilk_argüman’, help=’eski argümanın yardım␣ metni’) ˓→ ayristirici.add_argument(’--ilk_argüman’, help=’yeni argümanın yardım metni’) print(ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [-i ILK_ARGÜMAN] [--ilk_argüman ILK_ARGÜMAN] optional arguments: -h, --help show this help message and exit -i ILK_ARGÜMAN eski argümanın yardım metni --ilk_argüman ILK_ARGÜMAN yeni argümanın yardım metni ‘ ‘ NOT: ArgumentParser nesnesi yalnızca yeni verilen argümanın üzerine yazılır. ‘ ‘ Eğer eski argüman birden farklı seçeneği varsa ( -i/–ilk_argüman gibi) yeni eklediğiniz hangi argüman ise onun üzerine yazılır. Çıktımıza baktığımız zaman ‘ ‘ ‘ ‘ sadece –ilk_argüman üzerineyazıldı -i argümanınınüzerineyazılmaolmadı. 47.14. argparseModülü 1119 PythonBelgeleri,Yayım4.1.3 add_helpargümanı ArgumentParser nesnesi varsayılan olarak ayrıştırıcıların yardım mesajlarını sade şekilde ekranayazdırır.Örnekkodumuzubirmetindosyasınayazıpardından,terminaldedosyamızın bulunduğudizindeterminalimizdepython3ilkprogram.py-hşeklindekomutunuçalıştıralım: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’-i’, help=’Yardım metni’) ayristirici.parse_args() Çıktımız: usage: ilkprogram.py [-h] [-i I] optional arguments: -h, --help show this help message and exit -i I Yardım metni Görüldüğü üzere argümanlarımız hakkında basitçe bir yardim belgesi ekrana çıktı. Bazı durumlarda yardım metinlerini devre dışı bırakmak isteyebiliriz. Bu durumda add_help argümanınaFalsedeğeriniveririz.Azönceyazdığımızkodubuşekildedeğiştiripterminalden tekrarçalıştıralım.: import argparse ayristirici = argparse.ArgumentParser(add_help=False) ayristirici.add_argument(’-i’, help=’Yardım metni’) ayristirici.parse_args() Çıktımız: usage: ilkprogram.py [-i I] ilkprogram.py: error: unrecognized arguments: -h Artıkyardımmetniyok. ‘ ‘ ‘ ‘ Yardım seçeneği genellikle -h / –help ’dir. Bunun istisnası, eğer prefix_chars ‘ ‘ ‘ ‘ argümanı kullanılmışsa ve - içermezse, bu durumda -h / –help geçerli değildir. Bu durumda, prefix_chars içindeki ilk karakter yardım seçeneklerini ön ek olarak kullanılır: Örnek: import argparse ayristirici = argparse.ArgumentParser(prefix_chars=’+/’) ayristirici.print_help() Çıktı: 1120 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 usage: ilkprogram.py [+h] optional arguments: +h, ++help show this help message and exit 47.14.3 add_argument() Fonksiyonu ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][,␣ default][, type][, choices][, required][, help][, metavar][, dest]) ˓→ Parametrelerveaçıklamaları • nameveyaflags:İsimveyaseçenektanımlamakiçinoluşturulandizi.Örnek:-s,–silveya sil. • action:Komutsatırındarastlanırsayapılacakeylem. • nargs:Kullanılmasıgerekenkomutsatırıargümanlarınınsayısı. • const:Bazıeylemvenargsseçeneklerininseçimleriningerektirdiğisabitbirdeğer. • default:Komutsatırındaargümanbulunmazsavarsayılandeğer. • type:Argümanındönüştürüleceğideğertürü. • choices:Argümanlariçinizinverilendeğerlerinbiraralığıayarlar. • required:Argümanınihmaledilipedilmeyeceğiiçinkullanılır.(yalnızcaisteğebağlı) • help:Argümanınyaptığıhakkındaaçıklama. • metavar:Kullanımmesajlarındakiargümaniçinbirisim. • dest:parse_args()tarafındandöndürülennesneyeeklenecekniteliğinadı. nameveyaflags(isimveyabayrak) Add_argument()fonksiyonu,-fveya–foogibiisteğebağlıbirargümanmıyoksakonumsalbir argüman mı olduğunu bilmesi gerekir. Add_argument() fonksiyonuna iletilen ilk argümanlar bunedenlebirdizibayrakveyabasitbirargümanadıolmalıdır.Örneğinisteğebağlıargüman eklemekiçin: parser.add_argument(’-f’, ’--foo’) Eğerkonumsalargümaneklemekistersek: parser.add_argument(’bar’) Buşekildeekleyebiliriz. Parse_args() fobksiyonu çağrıldığında, isteğe bağlı argümanlar - ön eki tarafından tanımlanır vekalanargümanlarınkonumsalolduğuvarsayılır:Kodlarıyazalım.: 47.14. argparseModülü 1121 PythonBelgeleri,Yayım4.1.3 import argparse ayristirici = argparse.ArgumentParser(prog=’PROG’) ayristirici.add_argument(’-f’, ’--foo’) ayristirici.add_argument(’bar’) print(ayristirici.parse_args([’BAR’])) print(ayristirici.parse_args([’BAR’, ’--foo’, ’FOO’])) print(ayristirici.parse_args([’--foo’, ’FOO’])) Çıktımız: Namespace(bar=’BAR’, foo=None) Namespace(bar=’BAR’, foo=’FOO’) usage: PROG [-h] [-f FOO] bar PROG: error: the following arguments are required: bar Çıktımıza baktığımız zaman bar argümanı konumsal olduğu için ve son parse_args() fonksiyonundakullanmadığımıziçinuygulamamızhataverdi. action ArgumentParser nesnesi,argüman eylemleri ile ilişkilendirir. Bu eylemler, kendisiyle ilişkilendirilmiş komut satırı argümanları ile hemen hemen her şeyi yapabilir, ancak çoğu eylem yalnızca parse_args() fonksiyonunun döndürdüğü nesneye bir nitelik ekler. Action anahtarsözcüğüargümanı,komutsatırıargümanlarınınnasılelealınmasıgerektiğinibelirtir. Bazısağlananeylemler: • store-Busadeceargümanındeğerinisaklar.Buvarsayılaneylemdir.Örneğin: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--arguman’) print(ayristirici.parse_args(’--arguman 1’.split())) Çıktımız: Namespace(arguman=’1’) • store_const - const anahtar sözcüğü argümanı tarafından belirtilen değeri saklar. store_const eylemi, genellikle bir tür bayrak belirten isteğe bağlı değişkenlerle birlikte kullanılır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--arguman’, action=’store_const’, const=42) print(ayristirici.parse_args([’--arguman’])) Çıktımız: 1122 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Namespace(arguman=42) • store_true ve store_false - Bunlar, sırasıyla True ve False değerlerini depolamak için kullanılanstore_costdurumlarıdır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--arguman’, action=’store_true’) ayristirici.add_argument(’-i’, action=’store_false’) ayristirici.add_argument(’-y’, action=’store_false’) print(ayristirici.parse_args(’--arguman -i’.split())) Çıktımız: Namespace(arguman=True, i=False, y=True) • append-Listesaklarveherargümandeğerinilisteyeekler.Birseçeneğinbirdençokkez belirtilmesineizinvermekiçinkullanışlıdır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--arguman’, action=’append’) print(ayristirici.parse_args(’--arguman 1 --arguman 2’.split())) Çıktımız: Namespace(arguman=[’1’, ’2’]) • append_const - Bir listeyi depolar ve const anahtar sözcüğü argümanı tarafından belirtilen değeri listeye ekler. ( const anahtar sözcüğü argümanı varsayılan olarak ‘ ‘ None dır) append_const genellikle birden fazla argüman sabitlerini aynı listeye kaydetmesigerektiğindekullanışlıdır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--str’, dest=’types’, action=’append_const’,␣ const=str) ˓→ ayristirici.add_argument(’--dict’, dest=’types’, action=’append_const’,␣ const=dict) ˓→ print(ayristirici.parse_args(’--str --dict’.split())) Çıktımız: 47.14. argparseModülü 1123 PythonBelgeleri,Yayım4.1.3 Namespace(types=[<class ’str’>, <class ’dict’>]) • count - Anahtar kelime argümanının kullanılma sayısını sayar. Bu ayrıntı düzeylerini artırmakiçinkullanışlıdır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--say’, ’-s’, action=’count’) print(ayristirici.parse_args([’-sss’])) Çıktımız: Namespace(say=3) • help-Geçerliayrıştırıcıdakitümseçenekleriçineksiksizyardımmesajıyazdırırvesonra uygulamasonlanır. • version-Sürümbilgisiyazdırır. Örnek: import argparse ayristirici = argparse.ArgumentParser(prog=’PROG’) ayristirici.add_argument(’--v’, action=’version’, version=’%(prog)s 2.0’) print(ayristirici.parse_args([’--v’])) Çıktımız: PROG 2.0 nargs ArgumentParser nesnesi her argümanı tek bir işlem ile ilişkilendirir. nargs anahtar sözcüğü birargümanıfarklısayıdaargümanıtekbirişlemileilişkilendirir. • N(tamsayı)-Nargümanlarıkomutsatırındanbirlistehalindealınır. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, nargs=3) ayristirici.add_argument(’bar’, nargs=1) print(ayristirici.parse_args(’c --foo a b d’.split())) Çıktımız: 1124 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Namespace(bar=[’c’], foo=[’a’, ’b’, ’d’]) nargs=1biradetlisteelemanılisteler.Buvarsayılandeğerdenfarklıdır • ?Komutsatırındanbirargümanalınacakvetekbiröğeolaraküretilecektir.Eğerkomut satırındaargümanyoksa,varsayılandeğerüretilir. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, nargs=’?’, const=’c’, default=’d’) ayristirici.add_argument(’-b’, nargs=’?’, default=’d’) print(ayristirici.parse_args([’-b’, ’--foo’, ’YY’])) print(ayristirici.parse_args([’-b’, ’--foo’])) print(ayristirici.parse_args([])) Çıktımız: Namespace(b=None, foo=’YY’) Namespace(b=None, foo=’c’) Namespace(b=’d’, foo=’d’) nargs=’?’birkullanımalanıdahavardır.Bualanisteğebağlıdosyagirdiveçıktılarıdır.Python EtkileşimliKabuğumuzdaKodumuzuYazalım: import argparse import sys parser = argparse.ArgumentParser() parser.add_argument(’infile’, nargs=’?’, type=argparse.FileType(’r’), default=sys.stdin) parser.add_argument(’outfile’, nargs=’?’, type=argparse.FileType(’w’), default=sys.stdout) parser.parse_args([’input.txt’, ’output.txt’]) parser.parse_args([]) Çıktımız: Namespace(infile=<_io.TextIOWrapper name=’input.txt’ encoding=’UTF-8’>, outfile=<_io.TextIOWrapper name=’output.txt’ encoding=’UTF-8’>) Namespace(infile=<_io.TextIOWrapper name=’<stdin>’ encoding=’UTF-8’>, outfile=<_io.TextIOWrapper name=’<stdout>’ encoding=’UTF-8’>) • *-Mevcuttümkomutsatırıargümanlarıbirlistehalindetoplanır.Genelolaraknargs=’*’ ile birden fazla konumsal argüman almanın bir anlamı olmadığını unutmayın. Ancak birdenfazlaisteğebağlıargümanınargs=’*’ilealmakmümkündür. Örnek: import argparse ayristirici = argparse.ArgumentParser() (sonrakisayfayadevam) 47.14. argparseModülü 1125 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ayristirici.add_argument(’--foo’, nargs=’*’) ayristirici.add_argument(’--bar’, nargs=’*’) ayristirici.add_argument(’baz’, nargs=’*’) print(ayristirici.parse_args(’a b --foo x y --bar 1 2’.split())) Çıktımız: Namespace(bar=[’1’, ’2’], baz=[’a’, ’b’], foo=[’x’, ’y’]) Çıktımızı incelediğimiz zaman baz bizim konumsal argümanımızdır diğerleri ise isteğe bağlı argümandır.Eğerbazargümanındannargs=’*’kaldırırsak: usage: ilkprogram.py [-h] [--foo [FOO [FOO ...]]] [--bar [BAR [BAR ...]]] baz ilkprogram.py: error: unrecognized arguments: b Şeklindehataverir. • +-*gibidavranır.Mevcuttümkomutsatırıargümanlarıbirlistehalindetoplanır.Ayrıca, enazbirkomutsatırıargümanıyoksa,birhatamesajıoluşturulur. Örnek: import argparse ayristirici = argparse.ArgumentParser(prog=’PROG’) ayristirici.add_argument(’foo’, nargs=’+’) print(ayristirici.parse_args([’a’, ’b’])) print(ayristirici.parse_args([])) Çıktımız: Namespace(foo=[’a’, ’b’]) usage: PROG [-h] foo [foo ...] PROG: error: the following arguments are required: foo Çıktımızabaktığımızzamanparse_args()fonksiyonunalistehalindedeğergönderincebizead alanınıdöndürüyor.Ancakboşbirlistegönderincehataveriyor. • argparse.REMAINDER - Kalan tüm komut satırı argümanları bir liste halinde toplanır. Diğerkomutsatırıyardımcılarınıgönderilenkomutsatırıyardımcılarıiçinkullanışlıdır. Örnek: import argparse ayristirici = argparse.ArgumentParser(prog=’PROG’) ayristirici.add_argument(’--foo’) ayristirici.add_argument(’command’) ayristirici.add_argument(’args’, nargs=argparse.REMAINDER) print(ayristirici.parse_args(’--foo B cmd --arg1 XX ZZ’.split())) Çıktımız: 1126 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Namespace(args=[’--arg1’, ’XX’, ’ZZ’], command=’cmd’, foo=’B’) Eğer nargs anahtar sözcüğü sağlanmazsa, kullanılan argümanların sayısı action tarafından belirlenir. Genellikle bu, tek bir komut satırı argümanının kullanılacağı ve tek bir öğenin üretileceğianlamınagelir. const ‘ ‘ ‘const argümanı komut satırından okunamayan ancak ‘ArgumentParser() için gerekli sabit değerleritutar.Enyaygınikikullanımıvardır. • add_argument()fonksiyonuaction=’store_const’veyaaction=’append_cost’ileçağrıldığı zaman bu iki eylem const değerini parse_args() tarafından döndürülen nesnenin niteliklerineekler. • add_argument()fonksiyonuisteğebağlıkarakterdizisi(-f veya–foogibi)venargs=’?’ile çağrıldığızamansıfırveyabirkomutsatırıargümanıtarafındantakipedilebilecekisteğe bağlı argüman oluşturur. Komut satırı argümanları ayrıştırılırken isteğe bağlı seçenek dizesibağımsızdeğişkenilekarşılaşmazsaconstdeğerikabuledilir. default Tümisteğebağlıargümanlarvebazıkonumsalargümanlarkomutsatırındabazenatlanabilir. default anahtar sözcüğü argümanı ile eğer argüman değer almazsa varsayılan bir değer atanabilir.VarsayılanolarakdefaultNonedeğerinesahiptir.Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, default=42) print(ayristirici.parse_args([’--foo’, ’2’])) print(ayristirici.parse_args([])) Çıktımız: Namespace(foo=’2’) Namespace(foo=42) İlk parse_args() fonksiyonunda değer atadığımız için foo argümanının yeni değeri ‘2’ oluyor ancak ikinci parse_args() fonksiyonunda değer olmadığı için varsayılan değerimiz 42 ekrana çıkıyor. default değeri karakter dizisi (string) ise ayrıştırıcı değeri argüman gibi ayırır. Eğer değerintipideğiştirilmekistenirsetypekullanılır.Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, default=42, type=int) print(ayristirici.parse_args([’--foo’, ’2’])) print(ayristirici.parse_args([])) Çıktımız: 47.14. argparseModülü 1127 PythonBelgeleri,Yayım4.1.3 Namespace(foo=2) Namespace(foo=42) Görüldüğüüzereilkdeğerimizkarakterdizisiyerineartıktamsayı(int)oldu. type ArgumentParser() nesnesi varsayılan olarak komut satırından okuduğu değerleri karakter dizisi (string) olarak alır. Bazı durumlarda farklı tiplerde değişkenlere ihtiyaç duyarız. Bunun için type kullanılır. Şimdi uygulamamızı çalıştırdığımız dizine args.txt dosyası oluşturalım ve kodumuzuçalıştıralım.Kod: import argparse ayristirici = argparse.ArgumentParser() ayristirici .add_argument(’foo’, type=int) ayristirici .add_argument(’bar’, type=open) print(ayristirici .parse_args(’2 args.txt’.split())) Çıktımız: Namespace(bar=<_io.TextIOWrapper name=’args.txt’ mode=’r’ encoding=’UTF-8’>,␣ foo=2) ˓→ Çıktıya baktığımız zaman bar argümanının dosya hakkında bilgiler içeren bir takım detaylar varvefooisetamsayıdeğerinesahip. choices Bazen argümanlar belirli değerler ile sınırlandırmak gerekir. Bu durumda choices kullanılır. Eğer kullanıcı geçerli argüman verdiyse uygulama devam edeğer ancak verilen argüman geçersizisehatamesajıdöner. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’oyun’, choices=[’tas’, ’kagit’, ’makas’]) print(ayristirici.parse_args([’kagit’])) print(ayristirici.parse_args([’ates’])) Çıktı: Namespace(oyun=’kagit’) usage: ilkprogram.py [-h] {tas,kagit,makas} ilkprogram.py: error: argument oyun: invalid choice: ’ates’ (choose from ’tas’, ’kagit’, ’makas’) ˓→ 1128 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Çıktımızabaktığımızzamanilkargümanımızgeçerliolduğuiçinbirhataalmadık.Ancakikinci argümanımız geçersiz olduğundan dolayı uygulamamız bize geçerli argümanlar arasında seçimyapmamızısöylüyor. required argparse modülü genellikle -f veya –foo gibi isteğe bağlı seçimler ile çalışır ancak bazı durumlarda zorunlu argümanlar vermek gerekebilir. Böyle durumlarda required=True kullanılır. ÖrnekKod: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, required=True) print(ayristirici.parse_args([’--foo’, ’Degisken’])) print(ayristirici.parse_args([])) Çıktımız: Namespace(foo=’Degisken’) usage: ilkprogram.py [-h] --foo FOO ilkprogram.py: error: the following arguments are required: --foo Çıktımızı incelediğimiz zaman bir değişken atadığımız için uygulama hatasız çalıştı ancak ikincisindedeğişkenolmadığıiçinhataverdi. NOT:Zorunluseçimlergenelliklekötüformolarakkabuledilir.Çünkübuparametreler özünde isteğe bağlıdır ve kullanıcılar isteğe bağlı olmasını ister. Mümkün olduğunca kullanmamakgerekir. help helpdeğerikarakterdizisiolarakdeğeralırvebudeğerargümanlarhakkındayardımmetinleri içerir. Kullanıcı yardım istediğinde bulununca (genellikle -h veya –help) yardım metinleri görünür. ÖrnekKod: import argparse ayristirici= argparse.ArgumentParser() ayristirici.add_argument(’--foo’, help=’foo için yardım metni’) ayristirici.add_argument(’bar’, help=’bar için yardım metni’) print(ayristirici.parse_args([’-h’])) Çıktımız: usage: ilkprogram.py [-h] [--foo FOO] bar (sonrakisayfayadevam) 47.14. argparseModülü 1129 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) positional arguments: bar bar için yardım metni optional arguments: -h, --help show this help message and exit --foo FOO foo için yardım metni help çeşitli formatlama yöntemlerini içerir. Bu sayede değerlerinizi farklı yerlerde kullanabilirsiniz.Örnek: import argparse ayristirici = argparse.ArgumentParser(prog=’merhaba dünya’) ayristirici.add_argument(’bar’, default=42, help=’bar argümanı için yardım metni ayrıca bu␣ uygulamannın adı: %(prog)s (varsayılan değeri: %(’ ˓→ ’default)s)’) print(ayristirici.print_help()) Çıktımız: usage: merhaba dünya [-h] bar positional arguments: bar bar argümanı için yardım metni ayrıca bu uygulamannın adı: merhaba dünya (varsayılan değeri: 42) optional arguments: -h, --help show this help message and exit Görüldüğüüzereuygulamamızınadıvevarsayılandeğerimizekranabasıldı. metavar ArgumentParser() nesnesi yardım metinlerini oluşturduğu zaman, beklenen her argümana atıfta bulunmak için bir yola ihtiyaç duyar. Varsayılan olarak ArgumentParser() nesnesi dest değerini her nesnenin “ismi” olarak kullanır. Varsayılan olarak, konumsal argüman eylemleri için dest değeri doğrudan kullanılır ve isteğe bağlı argüman eylemleri için dest değeri büyük harfedönüştürülür.ÖrnekKod: import argparse parser = argparse.ArgumentParser() parser.add_argument(’--foo’) parser.add_argument(’bar’) print(parser.parse_args(’X --foo Y’.split())) print(parser.print_help()) Çıktımız: 1130 Bölüm47. ÖnemliStandartKütüphaneModülleri PythonBelgeleri,Yayım4.1.3 Namespace(bar=’X’, foo=’Y’) usage: ilkprogram.py [-h] [--foo FOO] bar positional arguments: bar optional arguments: -h, --help show this help message and exit --foo FOO Ayrıcametavaralternatifisimbelirtebilir. Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, metavar=’YYY’) ayristirici.add_argument(’bar’, metavar=’XXX’) print(ayristirici.print_help()) Çıktımız: usage: ilkprogram.py [-h] [--foo YYY] XXX positional arguments: XXX optional arguments: -h, --help show this help message and exit --foo YYY Konumsalargümanımızınismimetavariledeğişti. ‘ ‘ ‘ ‘ NOT: metavar yalnızca ekran ismini değiştirir, parse_args() ile kontrol ettiğiniz ‘ ‘ zaman dest değerinikullandığınıgörebilirsiniz. dest destileargümanlarakişiselleştirilmişisimlerverebilirsiniz.Örnek: import argparse ayristirici = argparse.ArgumentParser() ayristirici.add_argument(’--foo’, dest=’bar’) print(ayristirici.parse_args(’--foo XXX’.split())) Çıktımız: Namespace(bar=’XXX’) 47.14. argparseModülü 1131 PythonBelgeleri,Yayım4.1.3 Bu yardım sayfası https://docs.python.org/3/library/argparse.html referans alınarak hazırlanmıştır. 1132 Bölüm47. ÖnemliStandartKütüphaneModülleri 48 BÖLÜM Üçüncü Taraf Modüller 48.1 Colorama Modülü Coloramamodülü,konsolpenceresindekiyazılarırenklendirmeyivestilvermeyisağlar. 48.1.1 Kurulum Varsayılan python’a colorama modülünü kurmak için bilgisayarınızın komut satırına şunları girin: pipinstallcolorama (cid:242) Not BukomutlarıWindowsortamındaverebilmekiçinpython’uyolaeklemenizgerekir.Python kurulum aşamasında altta bulunan add to Path seçeneğini işaretlediyseniz python yola eklenmiştir. 48.1.2 Kullanım Coloramamodülünüanlayabilmekiçinbasitbirörnekyapalım: from colorama import Fore, Back, Style, init init(autoreset=True) print(Fore.RED + ’sade kırmızı yazı’) print(Back.GREEN + ’Yeşil arkaplan’) print(Style.DIM + ’Python’) print(Style.RESET_ALL) print(’Tekrar normal haline döndü’) 1133 PythonBelgeleri,Yayım4.1.3 GördüğünüzüzerecoloramamodülününFore,BackveStylesınıflarınınbelirlenmişnitelikleri ile herhangi bir karakter dizimizi birleştirip yazdırdığımızda niteliğe göre renkli yazılar elde ediyoruz.Foreyazınınkendisi,Backarkaplanı,Styleisestiliniilgilendirir. Pekinedeninitfonksiyonunuçağırdık? İnitbildiğinizüzere“initalization”(ilklendirme)sözcüğününkısaltılmışıdır.Buradakikullanımı da sözcük anlamıyla uyumludur. Yani bizim renklendirme işlemimizde birtakım ayarları yapmamız için bir başlangıçtır. Bunu yapmamız zorunludur. Yapmazsak kodlarımız renklenmeyecek,sadecerenkkoduekranabastırılacaktır. Bu noktada bir detaya değinelim: Bu Fore, Back ve Style sınıflarının belirlenmiş nitelikleri aslındaaleladebirkarakterdizisidir: print(’\033[31m’ + ’sade kırmızı yazı’) print(’\033[30m’) # Ve yeniden öntanımlı renge döndük Gördüğünüzgibiyukarıdakiyleaynısonucueldeettik. ŞimdiFore,BackveStylesınıflarınınençokkullanılanrenkniteliklerinigörelim: Fore:BLACK,RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE,RESET. Back:BLACK,RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE,RESET. Style:DIM,NORMAL,BRIGHT,RESET_ALL Coloramamodülününtermcolormodülüilekullanımı Termcolormodülücoloramamodülünükullanırkenişimizçokkolaylaştırır. from colorama import init from termcolor import colored #termcolor modülü colorama kullandığı için ilklendirme şarttır init() #İlk parametremiz karakter dizimiz, ikinci parametremiz rengi, üçüncü ise␣ arkaplan rengidir. ˓→ print(colored(’Hello, World!’, ’green’, ’on_red’)) # colored fonksiyonundan dönen değeri kullanabilmek için yazdırmamız gerekir. (cid:242) Not termcolormodülüyüklügelmemektedir,kurulumaşamasındakikodlardacoloramayerine termcoloryazarakkurabilirsiniz. Termcolormodülüiledahafazlabilgiiçin:https://pypi.org/project/termcolor/ 1134 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.1.3 İnit fonksiyonun argümanları İnitfonksiyonununbirçokisimliargümanıbulunur: autoreset=False from colorama import Fore, init init(autoreset=True) print(Fore.RED + "Bu kırmızı olur ama;") print("Bunun rengi default’tur") from colorama import Fore, init init(autoreset=False) #Böyle yapsak da değişmez: init() #çünkü bu zaten öntanımlıdır print(Fore.RED+"Artık bundan sonra yazdırılan her şey değiştirilmediği sürece␣ kırmızıdır") ˓→ print("mesela bu kırmızı") Diğerlerine ihtiyacınızın olmayacağını düşündüğümüz için buraya yazmadık. Diğer argümanlarıcoloramaPyPIsayfasındagörebilirsiniz. 48.2 django Paketi BubelgelerDjangoframeworkunuanlatanresmibaşlatıcınınçevirisidir.Kaynağı: https://docs.djangoproject.com/en/2.0/intro/tutorial01/ 48.2.1 İLK DJANGO PROJENİ YAZ, part 1 Bir örnekle öğrenmeye başlayalım. Bu örnekte basit bir anket uygulaması oluşturacağız. Uygulamaikikısımdanoluşacak: 1. Anketlerinoylanmasıiçinherkeseaçıkbirsite 2. Anketleridüzenlemekveyaekleyipsilmekiçinbiradminpaneli Senin Djangoyu yüklediğini varsayıyoruz. Komut isteminde aşağıdaki komutu çalıştırarak DjangonunyüklüolupolmadığınaveDjangosürümüneulaşabilirsin: python -m django --version Eğer Django yüklüyse yüklü olan versiyonu görmelisin. Eğer değilse “No module named django”yazısıilekarşılaşmalısın. 48.2. djangoPaketi 1135 PythonBelgeleri,Yayım4.1.3 Birprojeoluştur Komutsatırındacdkomutuylakomutunuzusaklamakistediğinizdizinegidinveaşağıdakikodu çalıştırın: django-admin startproject mysite Bu kod bulunduğunuz dizinde mysite dizinini yaratacak. Şimdi startproject komutunun oluşturduklarınabakalım: mysite/ manage.py mysite/ __init__.py settings.py urls.py wsgi.py Endışardakimysite/dizini,projeniziçinsadecebirkapsayıcıdır.AdıDjangoiçinönemlideğil. Beğendiğiniz herhangi bir şeyle yeniden adlandırabilirsiniz. manage.py: Komut satırından django projesiyle etkileşime geçmenizi sağlayan bir programdır. İçerideki mysite/ dizini , projeniz için gerçek bir python paketidir. mysite/init.py: Boş bir python dosyasıdır. mysite/ dizininin python paketi olmasını sağlar. mysite/setting.py: Django projesinin ayarları ile ilgili bir dosya. mysite/urls.py: Projeniz için URL’leri barındıran dosya. mysite/wsgi.py: WSGI uyumluwebsunucularıiçinprojenizehizmetedecekbirgirişnoktası. Geliştirmesunucusu Şimdi django projemizin çalışıp çalışmadığını kontrol edelim. Komut satırında dışarıdaki mysitedizininegidinveaşağıdakikoduçalıştırın: python manage.py runserver Çıktıolarakşunugörmelisin: Performing system checks... System check identified no issues (0 silenced). You have unapplied migrations; your app may not work properly until they are␣ applied. ˓→ Run ’python manage.py migrate’ to apply them. April 29, 2018 - 15:50:53 Django version 2.0, using settings ’mysite.settings’ Starting development server at http://127.0.0.1:8000/ Quit the server with CONTROL-C. (cid:242) Not 1136 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Veritabanıylailgiliuyarıyıdikkatealmayın. Djangogeliştirmesunucusunubaşlattınız. Kullanılanportudeğiştirme runserver komutu geliştirme sunucusu için standart olarak 8000 portunu kullanır. Eğer bu portu değiştirmek isterseniz bunu komuta argüman olarak verin. Mesela aşağıdaki komut 8080portundageliştirmesunucusunuçalıştırıyor: python manage.py runserver 8080 Eğer sunucunun IP adresini değiştirmek isterseniz port ile birlikte belirtin. Örnek olarak kullanılabilirtümIP’leridinlemekistiyorsanızşukoduçalıştırın: python manage.py runserver 0:8000 Yukarıdayazdığımızkodda0’ınanlamı0.0.0.0(Yanibirkısaltma). Biranketuygulamasıoluşturalım Artık proje ortamımız kuruldu. Çalışmaya başlayabiliriz. Django’da yazdığımız her uygulama birpythonpaketindenoluşurveDjango’dauygulamanındiziniotomatikolarakoluşturulur.Bu sayede dizin oluşturmakla uğraşacağımız zamanda kod yazabiliriz. Bir uygulama oluşturmak içinkomutsatırındamanage.pyileaynıdizinegelinveşukomutuyazın: python manage.py startapp polls pollsisimlibirdizinoluşturulacak.Bakaklımiçindenelervar: polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py Budizinanketuygulamamızınmerkeziolacak. 48.2. djangoPaketi 1137 PythonBelgeleri,Yayım4.1.3 İlkview’ımızıyazalım Hadiyazmayabaşlayalım.Şimdipolls/views.pyaçınveşukodlarıyazın: from django.http import HttpResponse def index(request): return HttpResponse("Hello, world. You’re at the polls index.") Bu Django’da yazılabilecek en basit view. Artık bu view ı çağırabilmek için bir URL haritasına ihtiyacımız var ve URL haritası için de URL şemasına. polls dizininde urls.py isimli bir dosya oluşturarak uygulamanın URL şemasını da oluşturmuş oluruz.(Dosya Gezgininden kendiniz urls.pyisimlibirpythonmodülüoluşturun.)Uygulamadizinisonolarakşöylegörünmeli: polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py urls.py Şimdideyenioluşturduğumuzpollsdizinindekiurls.pydosyasındaşukodlaryazılıolmalı: from django.urls import path from . import views urlpatterns = [ path(’’, views.index, name=’index’), ] Burada oluşturduğumuz URL şemasını gerçek Url şemasında tanıtmanın vakti geldi. Bunun için mysite dizinindeki urls.py dosyasında include fonksiyonunu içe aktarıp url listesini aktarmadakullanacağız.Sonuçolarakmysitedizinindekiurls.pydosyanızşuhalegelmeli: from django.contrib import admin from django.urls import include, path urlpatterns = [ path(’polls/’, include(’polls.urls’)), path(’admin/’, admin.site.urls), ] Artık index view’ını bir dizine bağladınız. Test etmenin vakti geldi. Komut satırında şu kodu çalıştırın: python manage.py runserver include() fonksiyonu diğer URL şemalarına ulaşmamıza izin verir. Django include ile karşılaştığındaeşleşenURL’yikalanişlemleriçinverilenURLşemasınagönderir. 1138 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.2.2 İLK DJANGO PROJENİ YAZ, part 2 VeritabanıKurulumu Şimdimysite/settings.pydosyasınıaçın.ÖnceTIME_ZONEdeğeriniEurope/Istanbulyaparak İstanbul’aayarlayın. (cid:242) Not Dosyanın en başındaki INSTALLED_APPS ayarına dikkat edin. Projenizde kullandığınız uygulamalarıtutar.Yenibiruygulamakullanacağınızzamanbulisteyeeklemelisiniz. Varsayılanolarakgelenuygulamalarşunlardır: django.contrib.admin --> Yönetici panelini oluşturur. django.contrib.auth --> Bir kimlik doğrulama sistemi. django.contrib.contenttypes --> İçerik türleri için bir framework. django.contrib.sessions --> Bir oturum frameworku django.contrib.messages --> Bir mesajlaşma frameworku django.contrib.staticfiles --> Statik dosyaları yönetmek için bir framework. Bu uygulamalardan bazıları en az bir veritabanı kullanıyor. Ancak bu veritabanlarının kullanılabilmesiiçinbirtablooluşturmalıyız.Otablodaşukomutlaoluşuyor: python manage.py migrate Modeloluşturalım Şimdi modellerimizi tanımlayacağız. Anket uygulamamızda iki tane model olacak: Question(Soru), Choice(Seçenek). Question modeli bir soru ve yayınlama tarihi içerecek. Choice modeli ise iki alandan oluşacak: Bir yazı alanı ve oy çetelesi. Her Choice bir Question ileilişkiliolacak.Şimdipolls/models.pydosyasınışuşekildedüzenleyin: from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(’date published’) class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) Burada iki model oluşturduk. Bu modeller django.db.models.Model sınıfını miras alıyor ve veritabanı alanını temsil eden değişkenlere sahip. Bu veritabanı alanlarının her biri bir Field sınıfı ile ilişkili. Mesela CharField karakter dizilerini , DateTimeField tarih ve zamanı veritabanına eklemek için. Bu sistem Django’nun, her alanın hangi veri tipini tuttuğunu 48.2. djangoPaketi 1139 PythonBelgeleri,Yayım4.1.3 anlamasını sağlar. Bazı Field sınıfları zorunlu olarak parametreye ihtiyaç duyuyor. Buna en iyiörnekolanCharFieldsınıfımax_lengthdeğeriolmadançalışmıyor.Fieldsınıflarıisteğebağlı parametreleredesahip.Meselavotesdeğerinindefaultparametresi-kibizbuörnekte0olarak ayarladık-buna bir örnek.Son olarak ForeignKey kullanarak her Choice örneğini bir Question örneğiileilişkilendirdik. ModellerinAktifleştirilmesi ModelkodlarıDjango’yabazıbilgilerverir.Djangobubilgilerleşunlarıyapabilir: 1. Uygulamaiçinbirveritabanışemasıoluşturmak. 2. QuestionveChoicenesneleriiçinbirveritabanıerişimAPI’ıoluşturmak. Fakat önce polls uygulamasını projeye yüklemeliyiz. Projeye yüklemek için setting.py dosyasınıaçıpINSTALLED_APPSayarınıdüzenlemeliyiz.Bulisteyepolls/apps.pydosyasındaki PollsConfig sınıfını referans olarak ekleyelim. setting.py dosyasındaki INSTALLED_APPS son halişöyleolmalı: INSTALLED_APPS = [ ’polls.apps.PollsConfig’, ’django.contrib.admin’, ’django.contrib.auth’, ’django.contrib.contenttypes’, ’django.contrib.sessions’, ’django.contrib.messages’, ’django.contrib.staticfiles’, ] Artık Django, polls isimli uygulamamızı projeye eklediğimizi biliyor. Şimdi farklı bir komutu çalıştıralım: python manage.py makemigrations polls Talimatlarabenzerşeylergörmelisiniz: Migrations for ’polls’: polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice makemigrationskomutuileürettiğimizmodellerdedeğişiklikyaptığımızı(Aynızamandayeni modeller ürettiğimizi de) ve değişikliklerin migration olarak depolanmasını istediğimizi söyledik. Migrationlar senin modellerindeki değişiklerin depolanma şeklidir(ve bu yüzden veritabanı şeması). İstersen yeni modelinin migrationını okuyabilirsin. Migration polls/migrations/0001_inital.py isimli dosyada. Endişelenmeyin, bu dosyayı her zaman okumak zorunda değilsiniz. “migrate” komutu, senin veritabanı şemanı otomatik olarak yönetmek için migrationları çalıştırır. Birazdan bu konuya tekrar geleceğiz. Ama önce migrationın çalıştırdığı SQL dosyasına bakalım. “sqlmigrate” komutuna migration adını parametreolarakverinveSQLçıktısınıalın: 1140 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 python manage.py sqlmigrate polls 0001 İngilizceyönergetarzındabirşeylergörüyorolmalısın: BEGIN; -- -- Create model Choice -- CREATE TABLE "polls_choice" ( "id" serial NOT NULL PRIMARY KEY, "choice_text" varchar(200) NOT NULL, "votes" integer NOT NULL ); -- -- Create model Question -- CREATE TABLE "polls_question" ( "id" serial NOT NULL PRIMARY KEY, "question_text" varchar(200) NOT NULL, "pub_date" timestamp with time zone NOT NULL ); -- -- Add field question to choice -- ALTER TABLE "polls_choice" ADD COLUMN "question_id" integer NOT NULL; ALTER TABLE "polls_choice" ALTER COLUMN "question_id" DROP DEFAULT; CREATE INDEX "polls_choice_7aa0f6ee" ON "polls_choice" ("question_id"); ALTER TABLE "polls_choice" ADD CONSTRAINT "polls_choice_question_id_246c99a640fbbd72_fk_polls_question_id" FOREIGN KEY ("question_id") REFERENCES "polls_question" ("id") DEFERRABLE INITIALLY DEFERRED; COMMIT; Aşağıdakileredikkatet: • Çıktı kullandığınız veritabanına göre değişir. Yukarıdaki örnek PostgreSQL için yazılmıştır. • Tabloadı,uygulamanınadınıvemodelinadını(küçükharflerle)kullanarakotomatik olarakoluşturulur.(Budavranışgeçersizkılınabilir.) • Birincilanahtarlar(ID)otomatikolarakeklenir.(Budageçersizkılınabilir.) • DüzenlenirkenDjango,foreignkeyalanınınadına“_id”ekler.(Evet,bunudageçersiz kılabilirsiniz.) • Kullandığınız veritabanına göre düzenlenmiştir. Bu yüzden auto_increment(MySQL), serial(PostgreSQL) gibi veritabanına özgü alan türleri otomatikolarakayarlanır.Aynışeyalanadlarınınalıntılanmasıiçindegeçerlidir. • sqlmigratekomutuaslındaveritabanındakimigrationlarıçalıştırmaz.Sadeceonları seningörebileceğinSQLkodlarıhalindeekranayazdırır.BuDjangonunyaptıklarını 48.2. djangoPaketi 1141 PythonBelgeleri,Yayım4.1.3 kontroletmekveyaSQLkodlarınıdüzenlemekiçinkullanışlıdır. Eğerbunuilgiçekicibulduysanbirdeşunuçalıştır:pythonmanage.pycheck.Bukodprojende herhangibirproblemolupolmadığınıveritabanıylauğraşmadankontroleder.Şimdimigrate komutunutekrarçalıştırıpmodelleriveritabanındaoluştur: python manage.py migrate migrate komutu daha önce uygulanmayan tüm migrationları alır (Django, veritabanınızda django_migrations adlı özel bir tablo kullanarak hangi uygulamaların uygulandığını izler) ve bunları veritabanınıza karşı çalıştırır - temel olarak modelinize yaptığınız değişiklikleri veritabanındaki şema ile senkronize eder. Migrationlar çok güçlüdür ve zamanla, projenizi geliştirirken, veritabanınızı veya tablolarınızı silmenize ve yenilerini oluşturmanıza gerek kalmadanmodellerinizideğiştirmenizeizinverir-verikaybetmedenveritabanınızıcanlıhale getirme konusunda uzmanlaşmıştır. Eğiticinin daha sonraki bir bölümünde bunları daha ayrıntılı bir şekilde ele alacağız, ancak şimdilik, model değişikliklerini yapmak için üç adımlı kılavuzuhatırlayın: • Modelideğiştirin(models.pyde) • pythonmanage.pymakemigrationskomutunuçalıştırarakbudeğişiklikleriçinmigration oluşturun. • python manage.py migrate komutunu çalıştırarak bu değişiklikleri veritabanına uygulayın. APIileoynayalım Şimdi etkileşimli kabuğa atlayıp Django’nun sunduğu API ile uğraşalım. Etkileşimli kabuğu çağırmakiçinşukomutukullanın: python manage.py shell Basitçe python yazmak yerine bunu kullanıyoruz. Çünkü manage.py dosyası kullanacağımız djangodosyalarınıiçeaktarıyor.KabuğagirdiktensonraveritabanıAPI’ınıkeşfedin: >>> from polls.models import Choice, Question # Az önce yazdığımız model␣ sınıflarını içe aktar. ˓→ #Henüz sistemde Question nesnesi yok. >>> Question.objects.all() <QuerySet []> # Yeni bir Question nesnesi oluştur. # Varsayılan ayarlar dosyasında saat dilimleri desteği etkinleştirilmiştir, bu␣ nedenle ˓→ # Django pub_date değişkeni için tzinfo ile bir tarih bekler. timezone.now()’ı␣ kullanın. ˓→ # datetime.datetime.now () yerine ve doğru olanı yapacağız. >>> from django.utils import timezone >>> q = Question(question_text="What’s new?", pub_date=timezone.now()) # Oluşturduğumuz nesneyi veritabanına kaydedelim. Bunun için save() metodunu␣ (sonrakisayfayadevam) 1142 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) kullanmalısın. ˓→ >>> q.save() # Şimdi bir ID’ye sahip. >>> q.id 1 # Python ile model alan değerlerine erişin. >>> q.question_text "What’s new?" >>> q.pub_date datetime.datetime(2012, 2, 26, 13, 0, 0, 775217, tzinfo=<UTC>) # Öznitelikleri değiştirip save() metodunu çağıralım. >>> q.question_text = "What’s up?" >>> q.save() # objects.all(), veritabanındaki tüm Questionları görüntüler. >>> Question.objects.all() <QuerySet [<Question: Question object (1)>]> Bir dakika! <Question: Question object (1)> bu nesne ilişkisi hiç yararlı değil. Question modeline(polls/models.pydosyasında)__str__()metodunuekleyelim(Choicemodelinede): from django.db import models class Question(models.Model): # ... def __str__(self): return self.question_text class Choice(models.Model): # ... def __str__(self): return self.choice_text Modellerinize,yalnızcaetkileşimlikomutistemiyleçalışırkenkendirahatlığınıziçindeğil,aynı zamandanesnelerintemsillerininDjango’nunotomatikolarakoluşturulanyöneticisiboyunca kullanılmasından dolayı __str__() yöntemlerini eklemeniz önemlidir. Bunların normal Python yöntemleriolduğunuunutmayın.Bunukanıtlamakiçinözelbiryöntemekleyelim: #polls/models.py import datetime from django.db import models from django.utils import timezone class Question(models.Model): # ... (sonrakisayfayadevam) 48.2. djangoPaketi 1143 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def was_published_recently(self): return self.pub_date >= timezone.now() - datetime.timedelta(days=1) Python standart kütüphanesinden datetime modülünü ve Django’nun saat dilimleri ile ilgili kütüphanesindentimezonemodülünüiçeaktaralım. Bu yaptığımız değişiklikleri kaydetmek için şu komutla yeni bir kabuk açalım:: python manage.pyshell >>> from polls.models import Choice, Question # Eklediğimiz __str__() fonksiyonunun çalıştığından emin olalım. >>> Question.objects.all() <QuerySet [<Question: What’s up?>]> # Django’nun içinde veritabanı araması için zengin bir API var. >>> Question.objects.filter(id=1) <QuerySet [<Question: What’s up?>]> >>> Question.objects.filter(question_text__startswith=’What’) <QuerySet [<Question: What’s up?>]> # Bu yıl paylaşılan question nesnelerini bulalım. >>> from django.utils import timezone >>> current_year = timezone.now().year >>> Question.objects.get(pub_date__year=current_year) <Question: What’s up?> # Veritabanında olmayan bir ID değerini parametre olarak verirseniz # size bir hata çıktısı verecektir. >>> Question.objects.get(id=2) Traceback (most recent call last): ... DoesNotExist: Question matching query does not exist. # Birincil anahtar aramalarda en çok kullanılan ifadedir, bundan dolayı # Django birincil anahtar aramaları için bir kısayola sahip. # Sonraki örnek şu kodla aynı :Question.objects.get(id=1). >>> Question.objects.get(pk=1) <Question: What’s up?> # Yazdığımız metodun da çalıştığından emin olalım. >>> q = Question.objects.get(pk=1) >>> q.was_published_recently() True # Question nesnemize birkaç Choice nesnesi oluşturalım. >>> q = Question.objects.get(pk=1) # Bu Question nesnesine hiçbir Choice nesnesi bağlı değil(şimdilik) >>> q.choice_set.all() (sonrakisayfayadevam) 1144 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) <QuerySet []> # 3 Choice nesnesi oluşturalım. >>> q.choice_set.create(choice_text=’Not much’, votes=0) <Choice: Not much> >>> q.choice_set.create(choice_text=’The sky’, votes=0) <Choice: The sky> >>> c = q.choice_set.create(choice_text=’Just hacking again’, votes=0) # Choice nesnelerinin Question nesnelerine erişimi var. >>> c.question <Question: What’s up?> # Ve tam tersi: Question nesnelerinin de Choice nesnelerine erişimi var. >>> q.choice_set.all() <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]> >>> q.choice_set.count() 3 # API, ihtiyaç duyduğunuz kadarıyla ilişkileri otomatik olarak takip eder. # İlişkileri ayırmak için çift alt çizgi kullanın. # Bu, istediğiniz kadar derin bir seviyede çalışır. Sınır yok. # Bir Question nesnesi için bu yıl yayımlanan tüm Choice nesnelerini bulalım. # (Yukarıda oluşturduğumuz current_year değişkenini kullanalım). >>> Choice.objects.filter(question__pub_date__year=current_year) <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]> # delete() fonksiyonunu kullanarak bir Choice nesnesini silelim. >>> c = q.choice_set.filter(choice_text__startswith=’Just hacking’) >>> c.delete() YöneticiPaneli Biryöneticikullanıcısıoluşturalım Yönetici paneline giriş yapmak için bir süper kullanıcıya ihtiyacımız var. Komut satırında şu koduçalıştıralım: python manage.py createsuperuser İstediğinizkullanıcıadınıgirinveenterabasın: Username: admin Sizdenemailadresiistenecektir.Doldurmakistemezsenizboşbırakın: Email address: admin@example.com Sonolarakşifrenizigirin.Sizdenikikereşifreisteyecek(İkincisidoğrulamaiçin). 48.2. djangoPaketi 1145 PythonBelgeleri,Yayım4.1.3 Password: ********** Password (again): ********* Superuser created successfully. GeliştirmeSunucusunuBaşlatın Django’dayöneticipanelivarsayılanolarakaktiftir.Geliştirmesunucusunubaşlatalımveonu birazaraştıralım: python manage.py runserver Şimdi tarayıcınızı açın ve yerel alan adınızda “/admin/” sayfasına gidin.(Mesela şöyle http://127.0.0.1:8000/admin/)Şöylebiryöneticisayfasıgörüyorolmalısın: YöneticiPanelineGirişyapalım Şimdi oluşturduğun süper kullanıcı ile yönetici paneline giriş yap. Yönetici panelinin anasayfasınıgörüyorolmalısın: 1146 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Birkaç düzenlenebilen içerik türü görmelisiniz: gruplar ve kullanıcılar. Django tarafından gönderilenkimlikdoğrulamaçerçevesidjango.contrib.authtarafındansağlanmıştır. Anketuygulamamızıyöneticipanelindenkontroledelim Fakatbizimanketuygulamamıznerede?Yöneticipanelininanasayfasındagözükmüyor. Busorunuçözmekiçinyapmanızgerekentekşey:YöneticipanelineQuestionnesnelerimizin yönetici panelinden düzenlenebildiğini söylemek. Bunu yapmak için polls/admin.py dosyasınıaçıpşukodladüzenlemek: from django.contrib import admin from .models import Question admin.site.register(Question) Yöneticipanelininişlevselliğinikeşfedelim Questionnesnelerinikaydettiğimizegöreyöneticipanelininanasayfasışuşekildegözükmeli: Question yazısına tıkla. Şimdi Question nesnelerinin değiştirme sayfasındasın. Bu sayfa veritabanındaki tüm Question nesnelerini gösterir ve değiştirmek için birini seçmeni sağlar. Şuandahaönceoluşturduğumuz“What’sup?”nesnesivar: Düzenlemekiçin“What’sup?”nesnesinetıkla: 48.2. djangoPaketi 1147 PythonBelgeleri,Yayım4.1.3 Buradabirkaçnot: • BuformQuestionmodelindenotomatikolarakoluşturulur. • FarklımodelalanlarınakarşılıkolarakuygunHTMLetiketlerikullanılır. • DateTimeFieldalanıiçin“Bugün”veya“Şimdi”gibikısayollarbulunur. Alttaraftabirkaçayarbulunuyor: • Save–Değişikliklerikaydedervedeğişikliklistesisayfasınanesnetipiniekler. • Saveandcontinueediting–Değişikliklerikaydedervesayfayıyenidenyükler. • Saveandaddanother–Değişikliklerikaydederveyenibiryüklemesayfasıaçar. • Delete–Gösterilennesneyisiler. “Date Published” değeri, part 1’de oluşturduğunuz zamanla uyuşmuyorsa muhtemelen TIME_ZONE ayarı için doğru değeri ayarlamamışsınız. Değiştirin, sayfayı yeniden yükleyin ve doğrudeğeringörünüpgörünmediğinikontroledin. “Today”ve“Now”kısayollarınıtıklayarak“DatePublished”değerinideğiştirin.Ardından“Save andcontinueediting”itıklayın.Dahasonrasağüstteki“History”yitıklayın.Bunesnedeyapılan tümdeğişiklikleri,değişikliğiyapankişinindeğişiklikyaptığızamanvekullanıcıadıylalisteleyen birsayfagörürsünüz: 1148 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.2.3 İLK DJANGO PROJENİ YAZ, part 3 GenelBakış Görünüm, genellikle belirli bir işleve hizmet eden ve belirli bir şablona sahip olan Django uygulamanızdakibirWebsayfasıtürüdür.Örneğin,birbloguygulamasındaaşağıdakiviewları (viyıvları)kullanabilirsiniz: • Bloganasayfası–>Sonbirkaçgönderiyigösterir. • Gönderidetaysayfası–>Gönderiyeözelsayfa • Yıltabanlıarşivsayfası–>Tümayları,belirlibiryıldakigönderilerlebirliktegörüntüler. • Ay tabanlı arşiv sayfası –> Tüm günleri, belirli bir ay içindeki gönderilerle birlikte görüntüler. • Güntabanlıarşivsayfası–>Belirtilengüneaittümkayıtlarıgörüntüler. • Yorumeylemi–>Belirlibirgirdiyeyorumgönderilmesinisağlar. Anketuygulamamızdaaşağıdakidörtviewasahipolacağız: • Sorudizinsayfası–>Sonbirkaçsoruyugösterir. • Soru detay sayfası –> Bir soru metni görüntüler (sonuçsuz ancak oy kullanacak biçimdedir.). • Sorusonuçsayfası–>Sorununsonucunugösterir. • Oylamaeylemi–>Belirlibirsorudabelirlibirseçimiçinoylamayapar. Django’da web sayfaları ve diğer içerikler viewlara gönderilir. Her view basit bir Python fonksiyonuileilişkilidir(veyasınıftemelliviewlardabirmetotla).Django,istenenURL’yi(Alan adındansonraURL’ninbirbölümü)inceleyerekbirviewseçecektir. Web’de bulunduğunuz süre içinde “ME2 / Siteler / dirmod.asp? Sid = & type = gen & mod = Core+Sayfalar&gid=A6CD4967199A42D9B65B1B”gibigüzelliklerlekarşılaşmışolabilirsiniz. Django’nunbizebundandahazarifURLkalıplarısağladığınıbilmektenmemnunolacaksınız. BirURLdesenibasitçegenelbirURLformudur.Örneğin:/newsarchive/<year>/<month>/. BirURL’denviewaulaşmakiçinDjango,URLconfsolarakbilinenşeyikullanır.BirURLconf,URL modelleriniviewlaraeşler. Birkaçviewyazalım Şimdi pools/views.py dosyasına birkaç view daha ekleyelim. Bu viewlar biraz farklı çünkü birerargümanlarıvar: def detail(request, question_id): return HttpResponse("You’re looking at question %s." % question_id) def results(request, question_id): response = "You’re looking at the results of question %s." return HttpResponse(response % question_id) (sonrakisayfayadevam) 48.2. djangoPaketi 1149 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def vote(request, question_id): return HttpResponse("You’re voting on question %s." % question_id) Yeniviewlarımızıpools.urlsdosyasınapathfonksiyonuylaçağırarakekleyelim: from django.urls import path from . import views urlpatterns = [ # ex: /polls/ path(’’, views.index, name=’index’), # ex: /polls/5/ path(’<int:question_id>/’, views.detail, name=’detail’), # ex: /polls/5/results/ path(’<int:question_id>/results/’, views.results, name=’results’), # ex: /polls/5/vote/ path(’<int:question_id>/vote/’, views.vote, name=’vote’), ] Tarayıcınıza “/polls/34/” sayfasına göz atın. detail fonksiyonu çalışacak ve URL’de tanımladığınız ID her neyse onu gösterecektir. “/Polls/34/results/” ve “/Polls/34/vote/” sayfalarınıdadeneyin.Bunlarsonuçveoylamasayfalarınıgösterecektir. Birisi sitenizden “/polls/34/” sayfasını istediğinde Django mysite.urls modülünü çalıştırır. ÇünküROOT_URLCONFayarındabumodülbelirtilmiştir.urlpatternsisimlideğişkenibulurve desenlerisıraylageçirir.“polls/”eşleşmesinibulduktansonraeşleşenmetni(“polls/”)çıkarırve gerikalanmetni(“34/”)işlemindevamıiçinpolls.urlsdosyasındakiURLconf’agönderir.Orada “<int:question_id>/”ileeşleşirvedetailviewışöylebirçıktıylaçalışır: detail(request=<HttpRequest object>, question_id=34) question_id=34 kısmı <int:question_id> kısmından geliyor. Küçüktür ve büyüktür işaretleri kullanmak URL’nin bir kısmını yakalar ve viewa isimli parametre olarak yollar.:question_id> kısmıparametreninisminitanımlar.<int:kısmıiseyakalanmasıgerekenveritürünübelirtir. URL’ninsonuna.htmlgibiifadelereklemeyegerekyok.İstersenizböylebirşeyyapabilirsiniz: path(’polls/latest.html’, views.index), Fakatbunuyapmayın.Çoksaçma. 1150 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Gerçektenbirşeyleryapanviewlaryazalım Herviewikişeyiyapmakilesorumludur:HttpResponsenesnesiyleistenensayfayıdöndürmek veHttp404gibibirhataoluşturmak.Gerisisizekalmış. Viewın bir veritabanındaki kayıtları okuyabilir. Sayfa kalıplarını(template) kullanabilir(Django’nun ve 3. taraf bir sayfa kalıbı). PDF, XML çıktısı veya ZIP dosyası oluşturabilir.İstediğinPythonkütüphanesinikullanabilir. PratikolduğuiçinDjango’nunkendiveritabanıAPI’ınıkullanalım.İşteson5soruyuyayınlanma tarihinegörearalarınavirgülkoyaraksıralayıpsunanbirindexviewı: #polls/views.py from django.http import HttpResponse from .models import Question def index(request): latest_question_list = Question.objects.order_by(’-pub_date’)[:5] output = ’, ’.join([q.question_text for q in latest_question_list]) return HttpResponse(output) # Diğer viewlar(detail, results, vote) değişmedi. Burada bir problem var: Sayfanın düzeni viewdaki sabit koddan ibaret. Eğer sayfanın görünüşünü değiştirmek istersen Python kodunu düzenleyeceksiz. Django’nun sayfa kalıbı sistemi,viewınkullanabileceğibirsayfakalıbıoluşturaraktasarımıPython’danayırır. İlk önce polls klasöründe bir templates klasörü oluştur. Django sayfa kalıplarını burada arayacak. ProjendekiTEMPLATESayarıDjango’nunsayfakalıplarınıneyegöreyükleyipyorumlayacağını açıklar. Varsayılan olarak DjangoTemplates kullanılır. Eğer APP_DIRS seçeneği True ise DjangoTemplatesINSTALLED_APPS’dekiheruygulamadizinindetemplatesdizininiarar. Yeni oluşturduğun templates dizininde polls isimli bir dizin oluştur ve onun da içinde index.html isimli bir dosya oluştur. Diğer bir deyişle şablon şurada olmalı: polls/templates/polls/index.html. Çünkü şablon yükleyicisi yukarıda anlatıldığı şekliyle çalıştığındaDjangoiçindekibuşablonakolaycapolls/index.htmlşeklindebaşvurabilirsiniz. Aşağıdakikodubuşablonayerleştirin: {% if latest_question_list %} <ul> {% for question in latest_question_list %} <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a> </li> ˓→ {% endfor %} </ul> {% else %} <p>No polls are available.</p> {% endif %} Şimdipolls/views.pyindexviewınışablonukullanacakşekildegüncelleyelim: 48.2. djangoPaketi 1151 PythonBelgeleri,Yayım4.1.3 from django.http import HttpResponse from django.template import loader from .models import Question def index(request): latest_question_list = Question.objects.order_by(’-pub_date’)[:5] template = loader.get_template(’polls/index.html’) context = { ’latest_question_list’: latest_question_list, } return HttpResponse(template.render(context, request)) Bukodpolls/index.htmlisimlişablonuyüklervebiriçerikiletir.Buiçerikşablonundeğişken isimleriylePythonnesnelerinieşleştirenbirsözlüktür. Tarayıcınızda “/polls/” ekleyerek sayfayı yeniden yükleyin. Bir önceki bölümden “What’s up” sorusunuiçerenbirlistegörmelisiniz.Linksorunundetaysayfasınagötürür. render() Bu şablon yüklemek için çok sıradan bir deyimdir, içeriği doldurur ve bir HttpResponse nesnesiyle işlenmiş şablon sonucunu döndürür. Burada index viewının tamamen tekrar yazılmışhalivar: from django.shortcuts import render from .models import Question def index(request): latest_question_list = Question.objects.order_by(’-pub_date’)[:5] context = {’latest_question_list’: latest_question_list} return render(request, ’polls/index.html’, context) Bunu tüm bu görünümlerde yaptıktan sonra, artık yükleyici ve HttpResponse’yi içe aktarmamız gerekmiyor (detay, sonuç ve oylama için hala bu yöntemleri kullanıyorsanız HttpResponse’yitutmakisteyeceksiniz). renderfonksiyonu,ilkparametreolarakrequestnesnesini,ikiniciparametreolarakşablonun adını ve üçüncü parametre olarak isteğe bağlı bir sözlük alır. İçerikle işlenmiş şablonun HttpResponsenesnesinidöndürür. 1152 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 404hatası Şimdisorudetaysayfasınıelealalım.Busayfaverilenanketiçinsorumetninigösterir.Buişi sağlayanview: from django.http import Http404 from django.shortcuts import render from .models import Question # ... def detail(request, question_id): try: question = Question.objects.get(pk=question_id) except Question.DoesNotExist: raise Http404("Question does not exist") return render(request, ’polls/detail.html’, {’question’: question}) Buradakiyeniolayımızşu:İstenenkimliğesahipbirsoruyoksaviewHttp404hatasıyollar. polls/detail.html şablonuna ne koyabildiğimizi tartışacağız ancak yukarıdaki örneği hızlıca çalıştırmakistiyorsanızsadeceşunuyazın: {{ question }} Bubaşlamakiçinyeterli. get_object_or_404() Bueğernesnevarsagetfonksiyonunukullanaraknesneyigetirir,yoksaHttp404hatasıyollar. Buradadetayviewınıntamamentekraryazılmışhalivar: from django.shortcuts import get_object_or_404, render from .models import Question # ... def detail(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, ’polls/detail.html’, {’question’: question}) get_object_or_404() fonkiyonu ilk parametre olarak Django modelini ve get fonksiyonuna vermekiçinistediğinizsayıdaisimliparametreyialır.EğernesneyoksaHttp404hatasıyollar. Ayrıca, get_object_or_404 fonksiyonu üzerine kurulu get_list_or_404 fonkiyonu da vardır. Tek farkıgetyerinefilterkullanır.EğerlisteboşsaHttp404hatasıverir. 48.2. djangoPaketi 1153 PythonBelgeleri,Yayım4.1.3 Şablonsistemikullanalım Anketuygulamanızdakidetayviewınageridönelim.İçerikdeğişkeniquestiongözönünealınıp tekraryazıldığındapolls/detail.htmlşablonuşöylegörülmeli: <h1>{{ question.question_text }}</h1> <ul> {% for choice in question.choice_set.all %} <li>{{ choice.choice_text }}</li> {% endfor %} </ul> Şablon sistemi değişken özelliklerine erişmek için nokta arama sözdizimini kullanır. {{ question.question_text }} örneğinde Django önce sözlükte question nesnesini arar. Bunu başaramazsa, bu durumda çalışan bir öznitelik aramaya çalışır. O da başarısız olsaydı, liste diziniaramayıdenerdi. question.choice_set.all metodu {% for %} döngüsünde çağırılır. Metod Choice nesnelerini iterable olarak döndüren ve {% for %} döngüsünde kullanmak için en müsait kod olan question.choice_set.all()olarakyorumlanır. ŞablonlardakisabitURL’lerikaldıralım Hatırla, polls/index.html şablonunda sorular için link yazdığımızda linki kısmen böyle kodlamıştık: <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li> BukodlamadatipindeçoksayıdaşabloniçerenprojelerdeURL’lerideğiştirmeyekalktığımızda sorun ortaya çıkıyor. Bununla birlikte, polls.urls modülünde path fonksiyonlarında name değişkenini tanımladığımızdan, url yapılandırmalarınızda tanımlanmış belirli URL yolları üzerinekuruludüzeni{%url%}templateetiketinikullanarakkaldırabilirsiniz: <li><a href="{% url ’detail’ question.id %}">{{ question.question_text }} </a></li> Bunun çalışma şekli, polls.urls modülünde belirtilen URL tanımını aramaktır. Tam olarak ‘detail’URL’sininadınınneredetanımlandığınıgörebilirsiniz: ... ’ ’ # {% url %} şablon etiketiyle çağrılan name değeri path(’<int:question_id>/’, views.detail, name=’detail’), ... Eğer anket detay sayfasının URL’sini değiştirmek istersen -mesela “polls/specifics/12/” gibi- bunuşablonyadaşablonlardayapmakyerinepolls/urls.py’deyapmanızyeterli: ... ’ ’ # specifics sözcüğü eklendi. path(’specifics/<int:question_id>/’, views.detail, name=’detail’), ... 1154 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 URLalanları Buöğreticibiruygulamayasahip:polls.GerçekbirDjangoprojesibelkibeşbelkionbelkidaha fazlauygulamayasahipolur.PekiDjangofarklıURLalanlarınınasılbirbirindenayırır?Mesela pollsuygulamasıdetayviewınasahipveaynıprojedebirdebloguygulamasıdetaysayfasına sahip.Djangohangiuygulamanınviewınınçağırıldığınınasılbilebilir? Cevap: URL şemasına alan adı eklemek. Alan adı oluşturmak için polls/urls.py dosyasında app_namedeğişkeniekleyelim: from django.urls import path from . import views app_name = ’polls’ urlpatterns = [ path(’’, views.index, name=’index’), path(’<int:question_id>/’, views.detail, name=’detail’), path(’<int:question_id>/results/’, views.results, name=’results’), path(’<int:question_id>/vote/’, views.vote, name=’vote’), ] Şimdipolls/index.htmlşablonundadeğiştirelim: <li><a href="{% url ’polls:detail’ question.id %}">{{ question.question_text }} </a></li> ˓→ 48.2.4 İLK DJANGO PROJENİ YAZ, part 4 Basitbirformyazalım Hadi bir <form> etiketi içerecek şekilde anket detay şablonumuzu (“polls/detail.html”) güncelleyelim: <h1>{{ question.question_text }}</h1> {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %} <form action="{% url ’polls:vote’ question.id %}" method="post"> {% csrf_token %} {% for choice in question.choice_set.all %} <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{ { choice.id }}"> ˓→ <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label> <br> ˓→ {% endfor %} <input type="submit" value="Vote"> </form> Hızlıbirözet: 48.2. djangoPaketi 1155 PythonBelgeleri,Yayım4.1.3 • Yukarıdaki şablon, her soru seçimi için bir radyo düğmesi görüntüler. Her radyo düğmesinin değeri, ilişkili soru seçiminin ID’sidir. Her radyo düğmesinin adı “choice” dır. Bunun anlamı, biri radyo düğmelerinden birini seçip formu gönderdiğinde POST yöntemi ile şu veri yollanır: choice=#ID#. Burada ID değeri seçilen butonun id’sidir. HTMLformlarıböyleçalışır. • Formun action değerini {% url ‘polls:vote’ question.id %} olarak ayarladık. ve method=”post” ayarını da ekledik. method=”post” yazmak çok önemli (Alternatifi: method=”get”).Çünküsunucutarafıylayapılanverialışverişininyöntemininibelirler.Bir veri alışverişi yapan bir form oluşturduğunda hep method=”post” kullan.Bu Django’ya özelbirdurumdeğil,iyibirWebgeliştirmeyöntemi. • forloop.counterdeğişkeniiçindebulunduğufordöngüsününkaçkezdöndüğünütutar. • Bir POST formu oluşturduğumuzdan (bu verileri değiştirme etkisi yapabilir), Siteler ArasıİstekSahteciliği(CrossSiteRequestForgeries)konusundaendişelenmemizgerekir. Neyse ki, çok fazla endişelenmenize gerek yok, çünkü Django buna karşı korumak için kullanımıkolaybirsistemlebirliktegeliyor.Kısacası,dahiliURL’lerihedefalantümPOST formları,{%csrf_token%}şablonetiketinikullanmalıdır. Şimdi, gönderilen verileri işleyen ve onunla bir şeyler yapan bir Django viewı oluşturalım. Hatırla,part3’teanketuygulamasıiçinbusatırıiçerenbirURLconfoluşturduk: path(’<int:question_id>/vote/’, views.vote, name=’vote’), Ayrıcagöstermelikbirvoteviewıyazmıştık.Hadigerçekbirviewaçevirelim: from django.http import HttpResponse, HttpResponseRedirect from django.shortcuts import get_object_or_404, render from django.urls import reverse from .models import Choice, Question # ... def vote(request, question_id): question = get_object_or_404(Question, pk=question_id) try: selected_choice = question.choice_set.get(pk=request.POST[’choice’]) except (KeyError, Choice.DoesNotExist): # Soru oylama formunu tekrar göster return render(request, ’polls/detail.html’, { ’question’: question, ’error_message’: "You didn’t select a choice.", }) else: selected_choice.votes += 1 selected_choice.save() # POST verileriyle başarılı bir şekilde ilgilendikten sonra # daima bir HttpResponseRedirect döndürün. Bu, bir kullanıcı # geri düğmesine basarsa verilerin iki kez gönderilmesini önler. return HttpResponseRedirect(reverse(’polls:results’, args=(question.id, ))) ˓→ Bukod,henüzgörmediğimizbazışeyleriiçeriyor: 1156 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 • request.POST, gönderilen verilere anahtar adına göre erişmenizi sağlayan, sözlük benzeribirnesnedir.Budurumda,request.POST[‘choice’]seçilenseçeneğinkimliğinibir karakterdizisiolarakdöndürür.request.POSTdeğerleriherzamankarakterdizisidir. (cid:242) Not Django’nunGETverilerineaynışekildeerişmekiçinderequest.GETsağladığınıunutmayın. Ancak verilerin yalnızca bir POST çağrısı yoluyla değiştirilmesini sağlamak için kodumda request.POSTaçıkçakullanıyoruz. • POST verilerinde seçim yapılmadıysa, request.POST[‘choice’] KeyError hatası verir. YukarıdakikodKeyError’ukontrolederveseçimyapılmadığıtakdirdesoruformunuhata mesajıileyenidengörüntüler. • Seçim sayısını artırdıktan sonra, kod normal bir HttpResponse yerine bir HttpResponseRedirect döndürür. HttpResponseRedirect tek bir argüman alır: kullanıcınınyönlendirileceğiURL. • Bu örnekte HttpResponseRedirect yapıcısında reverse fonksiyonunu kullanıyoruz. Bu fonksiyon, görüntüleme işinde bir URL’yi sabit olmaktan kurtarmanıza yardımcı olur. ÇalıştırmakistediğimizviewınadıvebuviewaişaretedenURLmodelinindeğişkenkısmı verilir. Bu durumda, part 3’te kurduğumuz URLconf’u kullanarak, bu reverse çağrısı bir karakterdizisidöndürür.Bunungibi: ’/polls/3/results/’ Burada 3 question.id değeridir. Bu yeniden yönlendirilen URL daha sonra son sayfayı görüntülemekiçin‘results’viewınıçağırır. Birisi bir soruya oy verdikten sonra, vote viewı sorunun sonuç sayfasına yönlendirir. Bu görünümüyazalım: from django.shortcuts import get_object_or_404, render def results(request, question_id): question = get_object_or_404(Question, pk=question_id) return render(request, ’polls/results.html’, {’question’: question}) Bupart3’teyazdığımızdetailviewıylahemenhemenaynı.Tekfarkşablonadı.Bugereksizliği dahasonradüzeltiriz. Şimdipolls/results.htmlşablonunuoluşturalım: <h1>{{ question.question_text }}</h1> <ul> {% for choice in question.choice_set.all %} <li>{{ choice.choice_text }} -- {{ choice.votes }} vote{{ choice. votes|pluralize }}</li> ˓→ {% endfor %} </ul> (sonrakisayfayadevam) 48.2. djangoPaketi 1157 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) <a href="{% url ’polls:detail’ question.id %}">Vote again?</a> Şimdi tarayıcında /polls/1/ adresine git ve soruyu oyla. Her oy verdiğinizde güncellenen bir sonuç sayfası görmelisiniz. Bir seçim yapmadan formu gönderirseniz, hata mesajını görmelisiniz. Kalıpviewlarkullanalım detail ve results viewları çok basitve biraz da gereksizler. Anketlerin listesini görüntüleyen index()viewıdaonlarabenzerbirviewdır. Bu viewlar, temel bir Web geliştirme durumunu gösterir: Veritabanından URL’deki parametreyegöreverialmak,şablonyüklemekveişlenmişşablonudöndürmek.Buçokyaygın olduğuiçinDjango“Kalıpview”adındabirkolaylıksağlar. Kalıpviewlar,biruygulamayazmakiçinPythonkodunuyazmanızgerekmediğinoktayaortak kalıplarısoyutlar. Kalıp view sistemini kullanmak için anket uygulamamızı düzenleyelim. Böylece gereksiz bir takımkodusilebiliriz.Düzenlememizdeşuadımlarıuygulayacağız: 1. URLconf’udeğiştir. 2. Gereksizviewlardanbazılarınısil. 3. Django’nunkalıpviewlarınıtemelalanyeniviewlaryaz. URLconf’udeğiştir İlkönce,polls/urls.pydosyasınıaçınveURLconf’uşöyledeğiştirin: from django.urls import path from . import views app_name = ’polls’ urlpatterns = [ path ( ’’ , views . IndexView . as_view (), name = ’index’ ), path ( ’<int:pk>/’ , views . DetailView . as_view (), name = ’detail’ ), path ( ’<int:pk>/results/’ , views . ResultsView . as_view (), name = ’results’ ), ˓→ path ( ’<int:question_id>/vote/’ , views . vote , name = ’vote’ ), ] İkinci ve üçüncü desenlerin yol dizilerinde eşleşen kalıbın adının <question_id>’den <pk>’ye değiştiğini 1158 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Görünümlerideğiştir ‘ ‘ Şimdi index, detail ve results viewlarını kaldıracağız ve Django’nun kalıp viewlarını kullanacağız.Bunuyapmakiçinpolls/views.pydosyasınıaçvebunabenzerşekildedeğiştir: from django.http import HttpResponseRedirect from django.shortcuts import get_object_or_404, render from django.urls import reverse from django.views import generic from .models import Choice, Question class IndexView(generic.ListView): template_name = ’polls/index.html’ context_object_name = ’latest_question_list’ def get_queryset(self): """Return the last five published questions.""" return Question.objects.order_by(’-pub_date’)[:5] class DetailView(generic.DetailView): model = Question template_name = ’polls/detail.html’ class ResultsView(generic.DetailView): model = Question template_name = ’polls/results.html’ def vote(request, question_id): ... # yukarıdakiyle aynı, hiçbir değişiklik yok. Buradaikikalıpviewkullanıyoruz:ListViewveDetailView.ListViewnesnelerinlistesinigösterir. DetailViewisebelirlibirnesnetürünündetaysayfasınıgösterir. • Her kalıp viewın hangi modele etki edeceğini bilmesi gerekir. Bu model özniteliği kullanılaraksağlanır. • DetailView kalıp viewı, URL’den yakalanan birincil anahtar değerinin pk olarak adlandırılmasını bekler. Bu nedenle kalıp viewlar için question_id ifadesini pk olarak değiştirdik. Varsayılan olarak, DetailView kalıp viewı <app name>/<model name>_detail.html adlı bir şablon kullanır. Bizim durumumuzda polls/question_detail.html şablonunu kullanırdı. template_name özelliği, Django’ya otomatik olarak oluşturulan varsayılan şablon adı yerine belirli bir şablon adı kullanmasını bildirmek için kullanılır. Bu, results viewının ve detail viewının,herikisidesahnearkasındakiDetailViewolsabile,farklıbirşablonasahipolmasını sağlar. DurumListViewveIndexViewiçindeaynı. 48.2. djangoPaketi 1159 PythonBelgeleri,Yayım4.1.3 Sunucuyuçalıştırınvekalıpviewlarıtemelalanyenianketuygulamanıdene. 48.2.5 İçerik İşlemcileri İçerikİşlemcileriNedir Dilden bağımsız olarak yazdığımız her uygulama DRY (Don’t Repeat Yourself, Kendini Tekrar Etme) ilkesine sahip olmalıdır. Bu sayede yazılan kodların okunabilirliği daha yüksek, fazlalıklarıvekarmaşıklıklarıdahaazolur. Djangoyazılımiskeletindeiçerikişlemcileribuişeyarar.Birkeretanımlanandeğişkenoproje içindeoluşturulantümuygulamalardakullanılabilir. Oluşturduğumuzheriçerikişlemcisibiranahtar(lar)-değer(ler)şeklindedönmelidir.Budeğer tipiPythondilininsahipolduğuveritipiolansözlüktür. İçerikİşlemcileriNasılOluşturulur? Öncelikle bir Django projesi ve projemiz için bir uygulama oluşturuyoruz. Oluşturduğumuz uygulamanın içine context_processors.py isimli bir dosya oluşturuyoruz. Bundan sonra oluşturduğumuz tüm içerik işleyicilerini bu dosya altında toplayacağız. Son olarak oluşturduğumuz context_processors.py dosyasını settings.py dosyasının altında projemize bildirmemizgerekir.Bununiçinsettings.pydosyasınıaçıp TEMPLATES = [ { ’BACKEND’: ’django.template.backends.django.DjangoTemplates’, ’DIRS’: [os.path.join(BASE_DIR, ’templates’)] , ’APP_DIRS’: True, ’OPTIONS’: { ’context_processors’: [ ’django.template.context_processors.debug’, ’django.template.context_processors.request’, ’django.contrib.auth.context_processors.auth’, ’django.contrib.messages.context_processors.messages’, ], }, }, ] bu kısmı buluyoruz. Ardından kendi oluşturacağımız içerik işleyicilerini diğerlerinin yanına ekliyoruz. Bu ekleme sırasında sözdizimi önemlidir ve bu şekilde olmalıdır. uygulama_adi.içerik_işlemcisi_dosya_adi.içerik_işlemcisi_adiYenihaliaşağıdakigibiolmalı. TEMPLATES = [ { ’BACKEND’: ’django.template.backends.django.DjangoTemplates’, ’DIRS’: [os.path.join(BASE_DIR, ’templates’)] , (sonrakisayfayadevam) 1160 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) ’APP_DIRS’: True, ’OPTIONS’: { ’context_processors’: [ ’django.template.context_processors.debug’, ’django.template.context_processors.request’, ’django.contrib.auth.context_processors.auth’, ’django.contrib.messages.context_processors.messages’, ’deneme.context_processors.ilk_islec’, ], }, }, ] İlkişlecimizbasitolmasıamacıylaisimveülkedöndürsün.Bununiçincontext_processors.py ve ilk işlecimizi yazalım. Yazacağımız işleçler fonksiyon şeklinde olmalıdır ve bu fonksiyon requestparametresinidışarıdanalmalıdır. def ilk_islec(request): isim = "Mehmet" ulke = "Türkiye" return {’isim’: isim, ’ulke’: ulke} Buşekildeilkişlecimiziyazdıkşimdiisimveulkeadındaikitaneanahtardeğerdöndürdük.Bu değerleri istediğimiz HTML sayfasında kullanabiliriz. Denemek için templates klasörü altında index.htmloluşturalımardındanHTMLdosyasmızaaşağıdakikoduyazalım. <!DOCTYPE html> <html> <head> <title>Django - İçerik İşlemcileri</title> </head> <body> <p>Merhaba, benim adım {{ isim }} ve şu an bu ülkedeyim: {{ ulke }} </p> </body> </html> HTML sayfasımızı oluşturduktan sonra view oluşturacağız. Bunun için oluşturduğumuz uygulamanınaltdizinindebulunanviews.pydosyasına from django.shortcuts import render def view(request): return render(request, ’index.html’) Şeklindebasitbirviewfonksiyonuekleyelim.Sonolarakurls.pydosyasınayazdığımızviewiçin URLyoluekleyeceğiz. 48.2. djangoPaketi 1161 PythonBelgeleri,Yayım4.1.3 from django.urls import path from deneme.views import view urlpatterns = [ path(’index’, view), ] Tüm yapacağımız bu kadar! Artık tarayıcıda oluşturduğumuz sayfayı çalıştırınca anahtarlarımızınyerindedeğişkenlerimizvar. İçerikİşlemcileriNerelerdeKullanılabilir? Django ile proje geliştirirken kullanıcının tarayıcıda göreceği HTML kısımlarını ortak olan kısımlarını tek bir noktadan çekebiliriz. Böylece ortak bir blok değiştiği zaman tüm sayfaları tekrar düzeltmeye gerek kalmaz. Bunu yapmak için oluşturduğumuz tüm view’lere ana tema blogumuzu, tüm sayfalarda ortak olan diğer blok parçalarının yollarını içerik işlecinde tanımlayabiliriz. İçerikİşlemcimiz: def template_path(request): base_dir = os.path.dirname(os.path.dirname(__file__)) components_dir = os.path.join(base_dir, ’templates/components/’) base_component = os.path.join(components_dir, ’base_components/base.html’) common_components = os.path.join(components_dir, ’common_components/’) archive = os.path.join(common_components, ’archive.html’) quick_links = os.path.join(common_components, ’quick_links.html’) search_not_found = os.path.join(common_components, ’search_not_found.html’) social_account = os.path.join(common_components, ’social_account.html’) tag_cloud = os.path.join(common_components, ’tag_cloud.html’) blockquote = os.path.join(common_components, ’blockquote.html’) return {’base_components’: base_component, ’archive’: archive, ’quick_links’:␣ quick_links, ˓→ ’search_not_found’: search_not_found, ’social_account’: social_account, ’tag_cloud’: tag_cloud, ˓→ ’blockquote’: blockquote} HTMLSayfamız: {% extends base_components %} {% block title %}İletişime Geç {% endblock %} {% block s_content %} <!-- s-content ================================================== --> <section class="s-content s-content--narrow"> <div class="row"> <div class="s-content__header col-full"> <h1 class="s-content__header-title"> İletişime Geç </h1> (sonrakisayfayadevam) 1162 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) </div> <!-- end s-content__header --> <div class="col-full s-content__main"> <h3>Merhaba De :)</h3> <p class="lead">Sosyal medya hesapları üzerinden bana␣ ulaşabilirsin. </p> ˓→ <ul class="s-content__author-social" style="display: flex;␣ justify-content: center"> ˓→ {% for i in social %} <li> <a href="{{ i.sm_url }}" target="_blank"><i class=" {{ i.sm_icon_class }}" ˓→ style= "font-size: 48px" ˓→ aria- hidden="true"></i></a> ˓→ </li> {% endfor %} </ul> </div> <!-- end s-content__main --> </div> <!-- end row --> </section> <!-- s-content --> <{% endblock %} Örnek HTML sayfamızda {% extends base_components %} ile base_components değişkenini içerikişlemcisindetanımlamıştık,busayedebirdahadosyaadresiniyazmamızagerekkalmaz. Bununyerineherview’dedosyayolunuyazabilirdikancakdosyamızınyoludeğişirsetümview fonksiyonlarındadosyayolunudeğiştirmekzorundakalacaktık. Genelolarakkullanımşekliböyleoluyor. Bu makale için hazırladığım koda bu adres37 üzerinden ulaşabilir, bu kodu detaylı olarak inceleyebilirsiniz. 48.2.6 Django ile reCAPTCHA Kullanımı 1. Giriş. 1.1reCAPTCHANedir? reCAPTCHAtemelindeinternetsayfalarınıngüvenliğiinsanvebotdavranışlarının ayrılmasınısağlayanbiruygulamadır. 1.2NedenreCAPTCHAKullanmalıyım? Biryorumsistemidüşünelimherhangibirgüvenlikönlemiolmayan,birgecebasitbirsaldırıile milyonlarcaistenmeyenyorumeklenebilir.Butürolaylarınönünegeçmekiçinbazıönlemler alabiliriz.Yorumeklerkenbasitbirmatematiksorusuveyaeskiyöntemcaptchakullanabiliriz ancakbunlarartıkpekkullanışlıdeğiller.Enbasitindeneskiusulcaptchalarsizebozulmuşbir görüntü verir ve o görüntüde bulunan matematik işlemini veya harfleri ister. Bazen bunlar aşırı bozulmalar oluyor ve görüntünün okunması neredeyse imkânsız hale geliyor. Bunun yerinereCAPTCHAgibibirserviskullanarakbutürsıkıntılarınönünegeçebiliriz. 37https://github.com/mehmetkiran/context_processors_django 48.2. djangoPaketi 1163 PythonBelgeleri,Yayım4.1.3 2. Kurulum. 2.1reCAPTCHAServisineKayıtOlmak. reCAPTCHA kullanmak için öncelikle sitesi üzerinden bir uygulama oluşturmak gerekli. Bu adres38 üzerindenGooglereCAPTCHAservisinekaydolmakgerekli. Kaydolmasayfasınıaçtığımızzamanbiziböylebirsayfakarşılıyor.Buradabulunanbölümleri açıklayalım. • Etiket:Uygulamamızıaçıklayacakisim. • reCAPTCHAtürü:İnternetsitemizdekullanacağımızreCAPTCHAtürünüburadan seçiyoruz. – reCAPTCHA s3: Bu sürümde kullanıcının bot olup olmadığını bir puan yardımıylahesaplayanvesizebupuanıdöndürenbirJavascriptAPI’dır. – reCAPTCHA s2: Kullanıcı isteklerini yine kullanıcının eylemleri ile doğrulayan sürümdür. – “Robotdeğilim”OnayKutusu:Kullanıcıya“BenRobotDeğilim”şeklindebirkutu işaretletir. . 38https://www.google.com/recaptcha/admin/create 1164 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 • GörünmezreCAPTCHArozeti:İstekleriarkaplandadoğrular.GörünmezreCAPTCHA rozetiilekullanıcınınbironaykutusunatıklamasıgerekmez.Bununyerinekullanıcı sitenizdebulunandüğmeyetıkladığızamanbirJavascriptAPIçağrısıbaşlatılır. . • reCAPTCHAv2(Android):Androidservisleriiçinkullanılacakolanseçimdir. Detaylariçinadrese39 bakabilirsiniz. • Alan Adları: Bu uygulamayı hazırlayacağınız servislerin hangi alan adları altında kullanacağınızıbelirler. Not:Kayıtişleminizburadagirdiğinizalanadlarıvealtalanadlarıylasınırlıdır.Başkabirdeyişle example.com kayıt işlemi subdomain.example.com adresini de kaydeder. Geçerli bir alan adındaanamakinebulunmalıdır;yol,bağlantınoktası,sorguveyaparçabulunmamalıdır. • Sahipler: reCAPTCHA uygulamasına yeni yöneticiler ekleyebilirsiniz. Varsayılan olarak sizinhesabınızeklidir. • reCAPTCHAHizmetŞartları’nıkabuledin:Servisikullanmakiçinservissahibitarafından bizleresunulanşartlarıkabuletmemizgerekli. • Site sahiplerine uyarı gönder: Şüpheli trafik gibi durumlarda mail yardımıyla uyarılar gönderir. Yapılandırma işlemi oldukça kolay biz bu metin boyunda reCAPTCHA s2 Robot Değilim onay kutusunukullanacağız.Uygulamamızıkayıtettiğimizzamanbizeikiadetanahtarhazırlanacak. BuanahtarlardanSiteAnahtarıolansitemizinHTMLtarafındaGizliAnahtarolanisesitemizin arkaplanındaolacaktır.GizliAnahtarıaslakullanıcılarilepaylaşmayınvesitenizinHTML tarafındakullanmayınız. reCAPTCHAtarafıylaişimizbitti.ŞimdireCAPTCHA’yıuygulamamızaentegreetmekaldı. 39https://developers.google.com/recaptcha 48.2. djangoPaketi 1165 PythonBelgeleri,Yayım4.1.3 2.2reCAPTCHAServisiniUygulamayaEkleme. reCAPTCHAservisinisitemizeeklerkenikiaşamalıolarakyapacağız.İlkaşamasısitemizin ön yüz için ikincisi için arka uç tarafında yapacağız. Bu belgede anlatılacak reCAPTCHA servisinibiryorumsistemineekleyeceğiz. 2.2.1reCAPTCHAServisiniÖnYüziçinHazırlama. Google Geliştirici Belgelerine40 baktığımız zaman ön yüz tarafı için işimiz aşırı kolay. ÖnceliklereCAPTCHAJavascriptdosyasınıprojemizedahilediyoruz.: <script src="https://www.google.com/recaptcha/api.js" async defer></script> reCAPTCHAservisneihtiyaçduyduğumuzformaaşağıdakikoduekliyoruz.: <div class="g-recaptcha" data-sitekey="your_site_key"></div> data-sitekeyniteliğinereCAPTCHAtarafındanbizesağlananSiteAnahtarınıekliyoruz. Önyüziletümişimizbu. 2.2.2reCAPTCHAServisiniArkaUçTarafınaEkleme. Kendimize örnek bir proje ve bu proje için bir uygulama oluşturuyoruz. Gerekli anlatımlar önceki derslerde mevcuttur. Öncelikle örnek bir model oluşturuyoruz. Ben reCAPTCHA servisini yorum sisteminde kullanacağım içi yorumlar için bir model oluşturuyorum. from django.db import models class Comments(models.Model): id = models.AutoField(primary_key=True) name = models.CharField(max_length=55, verbose_name=’Kullanıcı Adınız’) comment = models.TextField(verbose_name=’Yorumunuz’) Ardındanyorumuygulamamızıniçineforms.pyadındabirdosyaoluşturuyoruz. from django import forms from blog.models import * class CommentForm(forms.ModelForm): class Meta: model = Comments fields = [ ’name’, ’comment’, ] Şimdi ise kullanıcıyı karşılayacak sayfayı yazıyoruz. templates klasörü altında index.html adındabirdosyaoluşturalımveiçinebukodlarıyazalım. <html> <head> <title>reCAPTCHA Demo</title> (sonrakisayfayadevam) 40https://developers.google.com/recaptcha/docs/display 1166 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) <script src="https://www.google.com/recaptcha/api.js" async defer></script> </head> <body> <h4>Yorum Gönder</h4> <form method="POST"> {% csrf_token %} {{ form.as_p }} <div class="g-recaptcha" data-sitekey= "6LdBO6cZAAAAAKVrVb26js1qHkeg23ks213nQgpBq7L6dva9lMuwTmX"></div> ˓→ <br/> <input type="submit" value="Gönder"> </form> <hr> <h4>Gelen Yorumlar:</h4> <hr> {% for comment in comments %} <p><b>İsim: {{ comment.name }}</b> <br>Yorum: <b>{{ comment.comment }}</b></ p> ˓→ <hr> {% endfor %} </body> </html> Kısaca HTML kodlarımızdan bahsedersek POST yöntemiyle gönderilecek bir form hazırladık. Ardından {% csrf_token %} değişkenini ekledik. Böylece formumuz doğru şekilde çalışacak. ‘ Ardından forms.py sayfasında hazırladığımız formu kullanıcıya gösteriyoruz. Son olarak da Google Belgelerinde aldığımız reCAPTCHA kodunu ekledik. Gelen yorumlar kısmında ise başarıylakaydedilenyorumlaryeralacak. Sıratümişiyapacakviews.pydosyasında. from django.shortcuts import render #1 from blog.models import Comments #2 from recaptcha import recaptcha_check #3 from blog.forms import CommentForm #4 def index(request): #5 comments = Comments.objects.all() #6 comment_form = CommentForm(request.POST or None) #7 recaptcha_response = request.POST.get(’g-recaptcha-response’) #8 recaptcha_response_result = recaptcha_check(recaptcha_response) #9 if recaptcha_response_result is True and comment_form.is_valid(): #10 comment_form.save() #11 context = { # 12 ’form’: comment_form, ’comments’: comments } return render(request, ’index.html’, context) #13 Örnekkodumuzyukarıda.Bukodusatırsatırinceleyelim. 48.2. djangoPaketi 1167 PythonBelgeleri,Yayım4.1.3 • #1,#2,#3,#4Bu4kodsatırıgerekliihtiyaçduyduğumuzkütüphanevemodülleridahil ediyoruz. • #5indexismindebirfonksiyonoluşturuyoruz. • #6AnasayfamızdatümyorumlarılistelemekbusatırdaCommentsmodelindebulunan tümkayıtlarılisteliyoruz. • #7forms.pysayfasındaoluşturduğumuzformuburadaçağırıpbirdeğişkeneatıyoruz. • #8 reCAPTCHA Django Formunda olmadığı için bu satırda POST yöntemiyle ‘g-recaptcha-responsedeğişkenindeğerinialıyoruz. • #9recaptcha_checkisimlibirfonksiyonhazırladıkböylecedahatemizbirgörünümelde ediyoruz.BufonksiyonönyüztarafındangelenkoduGoogle’ındoğrulamasunucusuna gönderiyor. Eğer sunucu doğrulamayı yaparsa sonuç olarak True veya hata olursa hatanınsebebiniiçerenbirsonuçdönecektir. • #10 Bu satırda hazırladığımız recaptcha_check fonksiyonundan gelen değer ve Django Formunun geçerliliğini kontrol ediyoruz. Eğer iki karşılama da olumlu ise kod if bloğu devameder. • #11DjangoFormunukayıtediyor. • #12 context isimli bir sözlük hazırlıyoruz ve içine Django Formunu ve kayıt edilen tüm yorumlarıekliyoruz. • #13renderfonksiyonuileindex.htmldosyasınıcontextdeğişkeniniekliyoruz. recaptcha_checkfonksiyonunusatırsatırinceleyelim. import requests #1 def recaptcha_check(recaptcha_response): #2 verify_url = ’https://www.google.com/recaptcha/api/siteverify’ #3 value = { #4 ’secret’: ’6LdBO6cZAAAAAAALlKFW656QWAPLOKasoPfLfYTVWV91Quo0H2tWBfRrc’, ’response’: recaptcha_response } response = requests.post(verify_url, value) #5 result = response.json() #6 if result[’success’] is True: #7 return True else: #8 return {’status’: result[’success’], ’reason’: result[’error-codes’]} # • #1requestskütüphanesinidahilediyoruz. • #2 recaptcha_response parametresini alan recaptcha_check isimli bir fonksiyon hazırlıyoruz. • #3Googledoğrulamasunucusununadresiniyazıyoruz. • #4 value isimli değişken oluşturuyoruz ve içine reCAPTCHA’nın uygulamasını kurulumunu yaparken bize sağlanan Gizli Anahtar değerini secret anahtarına, fonksiyonagelenrecaptcha_responsedeğeriniresponseanahtarınaatıyoruz. 1168 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 • #5requestskütüphanesinikullanarakPOSTyöntemiyleGoogledoğrulamasunucusuna valuedeğişkeninigönderiyoruz. • #6Googledoğrulamasunucusundangelendeğerijsonhalinegetiriyoruz. • #7EğerdönensonuçbaşarılıisefonksiyonTruedöndürür • #8Sonuçbaşarısızolursanedenbaşarısızolduğudahilbirsözlükdeğeridöndürür. 48.2.7 DjangoKişiselleştirilmişKullanıcıModeliniDahiliModelileGenişletmek Djangoiçindehazırbirçokmodülvemodellerilegelir.Bunlardanbiridekullanıcımodeli.Bu model ile hazırladığınız Django projesine çok hızlı bir şekilde üyelik sistemi geliştirebilirsiniz. Ancakbazenbumodeltekbaşınayeterligelmez.Böyledurumlardakendiyazdığımızmodeli Djangoilegelenkullanıcımodeliilegenişletebiliriz. BuYönteminAvantajlarıNeler? Django kullanıcı modeli yetki yönetim sistemi ve bazı hazır fonksiyonlar ile beraber gelir. Bu sayede kullanıcıların yetkisiz erişimlerini, yetki yönetimlerini, giriş, çıkış, parola değiştirme fonksiyonlarına ve bazı bezeyicilere(decarator) sahip oluruz. Bunlar sayesinde projemiz çok hızlışekildeilerleyebilir. DjangoAdminPanelindenKullanıcıveGrupİzinleriYönetimi 48.2. djangoPaketi 1169 PythonBelgeleri,Yayım4.1.3 NasılYapılır? Projemize bir adet uygulama ekliyoruz. Bu uygulama kullanıcı modelimizi barındıracak ve Django’nun dahili kullanıcı modeli ile genişletilecek. settings.py dosyamıza AUTH_USER_MODEL = uygulama_adi.model_adi değişkenini ekliyoruz böylece varsayılan kullanıcımodelinigeçersizkılarakkendimodelimizikullanabiliriz. Hazırladığınız uygulamayı settings.py dosyasında INSTALLED_APPS kısmına eklemeyiunutmayın. Ardından uygulamamızın models.py dosyasında bir model oluşturmamız gerekli. Bu model dosyasını dahili Django kullanıcı modeli ile genişleteceğz. Öncelikle genişleşme sırasında doğru olan modeli seçmeliyiz. Django bize iki adet sınıf sunuyor bunlar Abstractuser ve AbstractBaseUser. • AbstractUser: Bu model ile beraber temel kullanıcı veri giriş alanları da geliyor. (Ad, soyad,songiriş,kayıttarihivs.) • AbstractBaseUser: Bu model ile beraber sadece kimlik doğrulama fonksiyonları gelmekte.Kullanıcıverigirişalanlarıgelmiyor. BuanlatıdaAbstractUserilegenişletmeyapacağız.Sınıfımızıyazıyoruzvetestetmekamacıyla fazladanverigirişalanlarıekleyelim.Örnekkod: class CustomUserModel(AbstractUser): website = models.URL_Fields(verbose_name=’Web Sitesi’, blank=True) os = models.CharField(verbose_name=’Kullandığı İşletim Sistemi’,␣ max_length=256) ˓→ def __int__(self): return self.id Hazırladığımızmodeliveritabanışemamızauygulayacağız. python manage.py makemigrations python manage.py migrate YaptıklarımızıkontroletmekiçinPythonkonsolunuaçarakmodelimizidahiledelim. from user.models import * CustomUserModel._meta.get_fields() Çıktı: (<ManyToOneRel: admin.logentry>, <django.db.models.fields.AutoField: id>, <django.db.models.fields.CharField:password>,<django.db.models.fields.DateTimeField: last_login>, <django.db.models.fields.BooleanField: is_superuser>, <django.db.models.fields.CharField: username>, <django.db.models.fields.CharField: first_name>, <django.db.models.fields.CharField: last_name>, <django.db.models.fields.EmailField: email>, <django.db.models.fields.BooleanField: is_staff>, <django.db.models.fields.BooleanField: is_active>, <django.db.models.fields.DateTimeField:date_joined>,<django.db.models.fields.URLField: website>,<django.db.models.fields.CharField:os>,<django.db.models.fields.related.ManyToManyField: groups>,<django.db.models.fields.related.ManyToManyField:user_permissions>) 1170 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Çıktıyı incelediğimiz zaman <django.db.models.fields.URLField: website>, <django.db.models.fields.CharField:os>verigirişyerlerinigörüyoruz.Böyleceyaptıklarımızın sıkıntısızcasistemeişlendiğinianlayabiliriz.ArtıkDjango’nundahiliyetkliendirmevekullanıcı sisteminikendikullanıcımodelimizüzerindenkullanabiliriz. 48.3 Kivy Paketi Bu belgelerin kaynak kodlarına ulaşmak için Github41 adresini ziyaret edebilir ve eğer istersenizkatkıdabulunarakbukaynağıniyileştirilmesineyardımcıolabilirsiniz. Soru,sorunvegörüşleriçinForum42 sayfasınıkullanabilirsiniz. 48.3.1 Kivy Nedir? Kivy Android’den Windows’a kadar birden fazla işletim sistemini destekleyen bir grafik arayüz kütüphanesidir. Açık kaynak kodludur ve %90 Python ile yazılmıştır. Kaynak kodlarını incelemek isterseniz şu43 linke tıklayabilirsiniz. Ayrıca bu github adresinde yer alan, Kivy ile ilgiliörneklerideincelemekistersenizlinke44 tıklayabilirsiniz. Kivy çizim işlemlerini SDL2 kullanarak yapmaktadır. Doğal olarak pencere araçları, alışık olduğumuz Android veya diğer mobil pencere araçlarına benzemiyor(görünüm olarak). Kendinehasşekillerivar,yaniyerelişletimsisteminingrafiklerinikullanmıyor.Ekranaçizilen pencere araçlarının png haline, bilgisayarınızdaki kivy klasörünün altında ulaşabilirsiniz. kivy/data/imagesaltındaşöylebirpngdosyasıvar 41https://github.com//python- 42https://forum..com 43https://github.com/kivy/kivy 44https://github.com/kivy/kivy/tree/master/examples 48.3. KivyPaketi 1171 PythonBelgeleri,Yayım4.1.3 Bu png dosyasını kesinlikle silmemelisiniz,boyutlarında kesinlikle oynama yapmamalısınız. AksitakdirdeKivypencerearaçlarıekranaçizilmeyecektirvehataverecektir. Kivy ile yazdığınız programları aynen veya birkaç değişiklik ile Android’de, Windows’ta çalıştırabilirsiniz.Yazdığınızprogramlarıbuildozeryardımıilepaketleyebilirsiniz(androidveya iosiçin).Bunlarayerigeldiğindedeğinmeyeçalışacağız. Kivy kullanabilmeniz tabi ki Python temeliniz olmalı ve Kivy’i sisteminize kurmalısınız. Python’da sınıf yapılarını bilmeniz size ekstra bir katkı sağlar. Kivy programlarını nesne yönelimliolarakyazmak,çokdahasağlamvedüzenliprogramlarınortayaçıkmasınısağlar. Evet, Kivy hakkında biraz bilgi sahibi olduğumuza göre artık Kivy ile programlamaya giriş yapabiliriz... 1172 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.3.2 Kurulum Burada çok detaylı olarak kurulumu anlatmayacağız. Gerekli linkleri vereceğim, eğer yine de kurulumdasorunyaşarsanızforumdakonuaçarakbelirtebilirsiniz. Kurulumabaşlamadanöncedikkatedilmesigerekenbirdurumvar.EğerKivyileprogramlama yapacaksanız,bilgisayarınızdaPythonkuruluolmalıdır. Kivy’indesteklediğisürümleriaçıklayacakolursak; Python2.7>=Kivy<Python3.0 Python3.4>=Kivy Python2.7sürümündenPython3.0sürümünekadar,aynızamandaPython3.4sürümünden itibaren ileri sürümlerde destekleniyor. Bu bilgiye göre, Python sürümünüzün Kivy programlamaiçinuygunolupolmadığınıtespitedebilirsiniz. İşletimsisteminizegörekurulumiçin,aşağıdaverdiğimkılavuzsayfalarınabakabilirsiniz. Windowsiçinkurulum: https://kivy.org/doc/stable/installation/installation-windows.html Linuxiçinkurulum: https://kivy.org/doc/stable/installation/installation-linux.html OSXiçinkurulum https://kivy.org/doc/stable/installation/installation-osx.html Türkçekaynak: http://kivy-tr.readthedocs.io/tr/latest/kurulum.html Kivy kütüphanesini kurduysanız, bir sorun olup olmadığını test etmek için şöyle basit bir programyazalım.Ekranaboşbirpencereçıkaralım. # -*- coding: utf-8 -*- from kivy.app import App App().run() Kodu kaydedip çalıştırırsanız, ekrana boş bir siyah pencere çıkacaktır. Güzel, artık Kivy ile programlamayabaşlayabiliriz:) Yukarıdadayazdığımgibi,detaylıolarakanlatmadık.Çünkübirdenfazlaplatformiçinyazılmış bir kütüphane olduğu için, her birine ayrılmış anlatım sayfaları ile yetindik. Yine de bir sorununuzolursa,kuramazsanızforumakonuaçabilirsiniz.Kivyresmikaynaklarındabulunan kurulumkılavuzuiçinşu45 bağlantıyatıklayabilirsiniz. 45https://kivy.org/doc/stable/gettingstarted/installation.html 48.3. KivyPaketi 1173 PythonBelgeleri,Yayım4.1.3 48.3.3 Kivy Programlamaya Giriş BuyazıylaKivyderslerinegirişyapacağız.Önceklasikbaşlangıçolan“merhabadünya”örneği yapacağızvesıraylakodumuzuinceleyeceğiz. Bundan önceki yazılarda da bahsettiğimiz gibi, Kivy ile programlamadan verim almak istiyorsanız Python sınıflar konusunda temel bilginiz olmalıdır. Çünkü genelde sınıfları kullanacağım ve bu yüzden yazdığım kodları(her ne kadar açıklama yapsam da) anlayabilmek için, temel de olsa, bilgili olmanız gerekir. Burdan, “Kivy sınıflar ile kullanılmak zorundadır” anlamı çıkmasın. Zaten sınıf yapısı çok zor değil, biraz pratik yaparak mantığını kavrayabilirsiniz. Kivy kütüphanesini sıkıntısız bir şekilde kurduğunuzu varsayarak ilk örneğimize geçiş yapıyoruz. Herhangibiraçıklamayapmadanöncehemenkodlarıverelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class Program(App): def build(self): yazi = Label(text = "Merhaba Dünya") return yazi Program().run() Kodukaydedipçalıştırdığınızdaekranda,karşınızaaşağıdakigibibirpencereçıkacaktır. 1174 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Şimdi sıra ile kodumuzu inceleyelim. İlk iki satır, her programın başına yazılan klasik satırlardır.SadeceilksatırLinuxiçingeçerli. Sonrakisatırda from kivy.app import App programınbelkemiğinioluşturanAppsınıfınıimportediyoruz.Anapencerebusınıfyardımıyla oluşturulur,programadairtanımlamalargeneldebusınıfileyapılır. Birsonrakisatır from kivy.uix.label import Label ekranda yazı göstermemizi sağlayan Label sınıfını import ettik, yani kullanmak üzere içeriye aktardık.Artıkgereklisınıflarıimportettiğimizegöreanaprogramımızıtanımlayabiliriz Bir sonraki satırda, Program adında bir sınıf oluşturduk ve App sınıfından miras aldık. Miras almakdemek,öncedenoluşturulansınıfıtekrarkullanmaküzerebirsınıfakatmak,eklemek. Yani biz burda programımızı oluşturabilmek için App sınıfını, kendi ana sınıfımıza miras aldık ve kullanmaya başladık. Ve sınıfımızda build adında bir metot tanımladık. Bu metot, programımızçalıştığındaekrandagösterilecekanadüzeni,bileşenlerigeridöndürür.Genelde bir pencere düzeni geri döndürülür. Biz şimdilik basit bir şekilde ekranda yazı göstermek istedik ve bunu geri döndürdük. İleride pencere düzenlerini gördüğümüzde onları geri döndüreceğiz.Şimdilikörneğimizebakalım 48.3. KivyPaketi 1175 PythonBelgeleri,Yayım4.1.3 Şimdiyekadaryaptıklarımız,ihtiyacımızolanşeyleriimportetmek,anasınıfımızıoluşturmak, ekranda gösterilecek nesneleri geri döndürmek. Artık programımızı çalıştırmamız gerekiyor. BunudaProgram().run()kısmındayaptık. KvDili Kivyprogramlarınıgeliştirmekiçingeliştirilenbirdildir.Kullanımıbasittir.Yukarıdayaptığımız programıbirdekvdiliilegerçekleştirelim. Öncelikle ana dosyamızı hazırlıyoruz. Benim ana dosyamın adı main.py . Ve bu dosyamın yanına bir tane program.kv dosyası oluşturuyorum. Ana sınıfımın ismi neyse, kv dosyama onunadınıverdim.main.pydosyamıniçerisineaşağıdakikodlarıyazıyorum #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App class Program(App): pass Program().run() Şimdi program.kv dosyasının içerisine şunları yazalım. Amacımız ekranda merhaba dünya yazmak Label: text:"Merhaba Dünya" Programımızın build tarafından geri döndürülecek olan pencere düzenini, kv dili yardımıyla oluşturduk.Yapmamızgerekenmain.pydosyamızıçalıştırmakvesonucugörmek. kv dili kullanırken, aynen Python’da olduğu gibi girintilemeye dikkat etmelisiniz. Aksi taktirde hata verecektir. Kv dili, Kivy ile programlama yaparken oldukça kolaylık sağlar. Biz de derslerimizde bazen yaptığımız örnekleri kv diliyle de yapacağız. Bir programı birinci bölümdeki gibi sınıflarla da yazabilirsiniz, kv dili yardımıyla da yazabilirsiniz. Hatta bazı kısımları kv diliyle de yazabilirsiniz. Yerine göre değişecektir, illa ki kv diline ihtiyacınız olacaktır. UygulamaÖzellikleri Yazdığımız Kivy programının bazı niteliklerini değiştirebiliriz. Örneğin, siz yukarıda programı çalıştırdığınızda programın başlığını henüz tanımlamadığınız için pencerenin başlığı ana sınıfınadıileaynıdır.İstersenizbunudeğiştirebilirsiniz. #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label (sonrakisayfayadevam) 1176 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class Program(App): def build(self): self.title = "" return Label(text = "Merhaba Dünya") Program().run() Kivy’de bir program başlarken, ekrana pencere çizilmeden önce birtakım metotlar çalışır. Bunlardan birisi on_start() metodu. Bu metot içerisine, ekrana pencere çizilmeden önce yani programımız başlamadan yapmak istediğimiz tanımlamaları yazabiliriz. Örneğin başlığı burada tanımlayabiliriz, ya da veritabanımız varsa bağlantıları burada başlatabiliriz. Kullanımınadairbasitbirörnek #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class Program(App): def on_start(self): self.title = "" def build(self): return Label(text = "Merhaba Dünya") Program().run() Ancakdikkatedilmesigerekenbirdurumvar.on_start()metodu,build()metoduçalıştırıldıktan sonraçağrılır. Kivyuygulamamızdabelliolaylardaçalışanbaşkametotlardavar. on_stop(): Bu metot, programımız sona erdiğinde çalıştırılır. Böylece son olarak yapmak istediğimizişlemleri(örneğinaçıkdosyalarıkapatmak)buradayapabiliriz on_pause():androidveyaiosüzerindeprogramımızarkaplanaalındığındabumetotçalıştırılır. on_resume():Kullanıcıarkaplanaaldığıuygulamamızatekrardönersebumetotçalıştırılır. Şimdibunlarınhepsinibiraradakullandığımızbirörnekgörelimvekonuyubitirelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class Program(App): def on_start(self): self.title = "" (sonrakisayfayadevam) 48.3. KivyPaketi 1177 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) # bir takım işlemler... def on_stop(self): # Uygulama kapatılırken... pass def on_pause(self): # Uygulama arkaplana alınırken... # Burda return True yapmanız gerekiyor return True def on_resume(self): # Tekrar giriş yapıldığında yazımızı değiştiriyoruz self.yazi.text = "Programa tekrar hoşgeldiniz" def build(self): self.yazi = Label(text = "Merhaba Dünya") return self.yazi Program().run() 48.3.4 Pencere düzenleri Merhaba arkadaşlar. Bir önceki yazıda, Kivy ile ilk programımızı yazdık,kv diline kısaca göz attıkveprogramımızadairbazıözellikleritanıdık. Hatırlarsanızbiröncekidersteekrana“MerhabaDünya”yazmıştık.Tabikiprogramlarbukadar basitolamaz.Yaniekrandabaşkaaraçlardaolacaktır.Buton,Metingirişalanı,Seçimkutuları gibiaraçlardaolacaktırelbette. Bu pencere araçlarını ekranda gösterirken belli bir düzen içerisinde yerleştirmeliyiz ki, programın görüntüsü güzel olsun ve kullanıcıyı memnun etsin. Şimdi adım adım pencere düzenlerimizitanımayabaşlayalım. (cid:242) Not Penceredüzenleribukadarıylasınırlıdeğil.Buradaençokkullanılanlaranlatılmıştır BoxLayout kivy.uix.boxlayout.BoxLayout Bupenceredüzeni,içerisineyerleştirilenaraçlarıyanyanaveyaaltaltayerleştirir.Hemenbir örneklegörelim. from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout (sonrakisayfayadevam) 1178 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class Program(App): def build(self): duzen = BoxLayout() yazi1 = Label(text = "Merhaba") yazi2 = Label(text = "Dünya") duzen.add_widget(yazi1) duzen.add_widget(yazi2) return duzen Program().run() Ekrangörüntüsü Şimdi sıra ile kodumuzu inceleyelim.İlk satırda App sınıfını import ettik. Daha sonra ekrana yazı yazmamızı sağlayan Label sınıfını import ettik. Ve son olarak, pencere düzenimiz olan BoxLayoutsınıfınıimportettik. Bir pencere düzenini kullanabilmek için öncelikle onu tanımlamanız gerekir. duzen isminde bir değişkenle tanımladık ve iki adet yazımızı bu düzenin içine add_widget() fonksiyonu ile 48.3. KivyPaketi 1179 PythonBelgeleri,Yayım4.1.3 ekledik. Bir pencere düzeninin içerisine pencere aracı eklemek için add_widget() fonksiyonu kullanılır.Birpencerearacınıkaldırmakiçinise,remove_widget()fonksiyonukullanılır. Eğer BoxLayout pencere düzenini tanımlarken herhangi bir parametre vermezseniz elemanları yanyana dizecektir. Eğer alt alta dizmesini isterseniz orientation parametresini kullanmanızgerekir. Örnek; from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout class Program(App): def build(self): duzen = BoxLayout(orientation = "vertical") yazi1 = Label(text = "Merhaba") yazi2 = Label(text = "Dünya") duzen.add_widget(yazi1) duzen.add_widget(yazi2) return duzen Program().run() Ekrangörüntüsü 1180 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibieklenenelemanlarıaltaltayerleştirdi.Pekiikisinibiraradakullanabileceğimiz birörnekyapabilirmiyiz?Evet.Birkullanıcıgirişekranıyapalım.Amasadecegörüntüolarak, yaniherhangibirişlemyapmayacak.Sadecepenceredüzeninigöstermekiçinyapacağız. Amacımızşunabenzerbirpencereoluşturmak; Hemaltaltaelemanlarvar,hemdeyanyana.Şimdiböylebirpencereyinasıloluşturacağımızı görelim. from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout from kivy.uix.button import Button from kivy.uix.textinput import TextInput (sonrakisayfayadevam) 48.3. KivyPaketi 1181 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) class Program(App): def build(self): self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların␣ hepsini tutan ana pencere düzenimiz ˓→ self.ilkSatir = BoxLayout() self.ikinciSatir = BoxLayout() self.nick = Label(text = "Nick") self.nickKutu = TextInput() self.sifre = Label(text = "Şifre") self.sifreKutu = TextInput() self.buton = Button(text = "Giriş Yap") self.ilkSatir.add_widget(self.nick) self.ilkSatir.add_widget(self.nickKutu) self.ikinciSatir.add_widget(self.sifre) self.ikinciSatir.add_widget(self.sifreKutu) # Şimdi hepsini ana düzene yerleştiriyoruz self.anaDuzen.add_widget(self.ilkSatir) self.anaDuzen.add_widget(self.ikinciSatir) self.anaDuzen.add_widget(self.buton) return self.anaDuzen Program().run() Ekrangörüntüsü 1182 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Şimdi kodumuzu adım adım inceleyelim. Yukarıda gördüğünüz gibi Button ve TextInput sınıflarını import ettik. Button sınıfı ile butonlar oluşturabiliriz. Butona tıklandığında yapılmasını istediğimiz işlemler tanımlayabiliriz. Ancak bu derste pencere düzenlerini incelediğimiziçinbutonumuzaherhangibirgörevvermedik. TextInput, kullanıcıdan girdi almayı sağlar. Böylece kullanıcı ile iletişime geçebiliriz, girdilere göreişlemleryapabiliriz. Örneğimiz 3 tane BoxLayout düzeninden oluşuyor. Birincisi, tüm elemanları alt alta tutacak olan “anaDuzen”, İkincisi Nick ve Nick girme kutusunu yan yana tutacak olan “ilkSatir”, ve sonuncusu Şifre ve Şifre girme kutusunu yan yana tutacak olan “ikinciSatir”. Butonumuzu sadece anaDuzen’e eklememiz yeterli.Unutmayın bir pencere düzeninin içine başka bir penceredüzeniekleyebilirsiniz. Pekibuörneğimizikvdiliileyazsaydıknasılolurdu?Hemenbakalım BoxLayout: orientation: "vertical" BoxLayout: Label: text:"Nick" TextInput: BoxLayout: Label: text:"Şifre" TextInput: Button: text:"Giriş Yap" BoxLayoutileilgilibukadarörnekyeterlisanırım.Sizdekendinizegöreörnekleryaparakveya verilenörnekleriinceleyipdeğiştirerekkonuyupekiştirebilirsiniz. 48.3. KivyPaketi 1183 PythonBelgeleri,Yayım4.1.3 FloatLayout kivy.uix.floatlayout.FloatLayout FloatLayoutpenceredüzeni,araçlarıistediğimizboyuttavekoordinattayerleştirebileceğimiz bir pencere düzenidir. Her zaman olduğu gibi önce import etmeliyiz ve kullanmak üzere tanımlamalıyız.Birörnekyapalım #!/usr/bin/env python # -*- coding:utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.floatlayout import FloatLayout # gerekli sınıfları import ettik class Program(App): def build(self): duzen = FloatLayout() # pencere düzenimizi tanımladık buton = Button(text = "Merhaba", size_hint = (.1,.1), pos = (10,10)) duzen.add_widget(buton) # butonumuzu yerleştiriyoruz return duzen Program().run() Ekrangörüntüsü 1184 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Butonumuzu tanımlarken size_hint ve pos şeklinde iki tane parametre verdik. Bunlardan size_hint parametresi, butonumuzun ekrana orantılı bir şekilde boyutlandırılması içindir. Yani, .1 yazdığımızda, pencerenin boyutunun 10’da 1’i kadar genişlikte ve yükseklikte boyutlandırılır.Eğer.5yazsaydıkekranınboyutununyarısıkadarolacaktı.BuaradaPython’da .Xgösterimi0.Xgösterimiileaynıdır,bunudaburadabelirtmişolalım. size_hint ile butonumuzun boyutlarını belirledikten sonra, pos parametresi ile FloatLayout pencere düzenindeki yerini belirledik. pos = (10,10) yani sıra ile 10 pixel soldan uzaklık, 10 pixelaşağıdanuzaklıkşeklindetanımlanır.Kivy’de(0,0)noktasısol-altköşedir. Eğer butonumuza bu parametreleri vermeden pencere düzenimize eklersek, tüm ekranı dolduracakşekildeboyutlandırılacaktır. FloatLayoutpenceredüzenimizindeboyutunuayarlayabiliriz.Bununiçin duzen = FloatLayout(size = (300,300)) gibi bir tanımlama yapmamız yeterli. Aynı şekilde pencereye orantılı olmasını istersek, size_hintparametresinideverebiliriz.Birörnekleberabergörelim #!/usr/bin/env python # coding:utf-8 from kivy.app import App from kivy.uix.button import Button from kivy.uix.floatlayout import FloatLayout (sonrakisayfayadevam) 48.3. KivyPaketi 1185 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) # gerekli sınıfları import ettik class Program(App): def build(self): duzen = FloatLayout(size_hint = (.5,.5)) # pencere boyutunun yarısı␣ kadar ˓→ buton = Button(text = "Merhaba") # FloatLayout pencere düzenimizi tam␣ doldursun diye, parametre vermedik ˓→ duzen.add_widget(buton) # butonumuzu yerleştiriyoruz return duzen Program().run() Ekrangörüntüsü FloatLayout pencere düzenine eklenen araçların, ekrana orantılı bir şekilde yerleştirilmesini istersek,pos_hintparametresinikullanabiliriz.Böylecepenceremizinboyutuneolursaolsun, orantılı bir şekilde yerleştirilecektir. Aşağıdaki kodları çalıştırıp pencerenin boyutlarıyla 1186 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 oynarsanız,nedemekistediğimiçokdahaiyianlarsınız. Kullanımışuşekilde; #!/usr/bin/env python # coding:utf-8 from kivy.app import App from kivy.uix.button import Button from kivy.uix.floatlayout import FloatLayout # gerekli sınıfları import ettik class Program(App): def build(self): duzen = FloatLayout() button = Button(text=’Hello world’, size_hint=(.2, .1), pos_hint={’x’:.2, ’y’:.2}) duzen.add_widget(button) # butonumuzu yerleştiriyoruz return duzen Program().run() FloatLayout pencere düzeni ile ilgili anlatacaklarımız bu kadar. FloatLayout pencere düzeni, üzerindeserbestkonumlandırmayapıldığıiçinanimasyoniçinuygundur.Sadeceörnekolması açısından, aşağıdaki kodu çalıştırın ve ne olduğunu görün. Kodu anlamanızı istemiyorum, ileridezatenanlatacağız,sadecekodunsonuçlarınıgörmenizyeterli. #!/usr/bin/env python # coding:utf-8 from kivy.app import App from kivy.uix.button import Button from kivy.uix.floatlayout import FloatLayout from kivy.clock import Clock # gerekli sınıfları import ettik class Program(App): def build(self): self.x = 0 self.y = 2 self.duzen = FloatLayout() self.buton = Button(text=’Hello world’, size_hint=(.2, .1), (sonrakisayfayadevam) 48.3. KivyPaketi 1187 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) pos = (self.x,self.y)) self.duzen.add_widget(self.buton) Clock.schedule_interval(self.animasyon,0.1) return self.duzen def animasyon(self,event = None): self.x = self.x + 1 self.buton.pos = (self.x,self.y) Program().run() GridLayout kivy.uix.gridlayout.GridLayout Merhabaarkadaşlar.BiröncekibölümdeFloatLayoutpenceredüzeninianlattık.FloatLayout, üzerinde koordinat bilgisi ile yerleştirme yapabileceğimiz bir pencere düzenidir diyerek kısa birtekraryapmışolalım. Bu bölümde GridLayout pencere düzenini inceleyeceğiz. GridLayout, ızgara şeklinde yerleştirmeye imkan veren bir pencere düzenidir. Örneğin şöyle bir görüntü elde etmek için GridLayoutpenceredüzenikullanılabilir 1188 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 GridLayout ile ilgili önemli iki kavram vardır. Birincisi rows, yani satır. GridLayout pencere düzeninin max kaç satırdan oluşmasını istiyorsak, rows parametresini kullanırız. Diğeri ise, cols yani sütun. GridLayout pencere düzenimizin max kaç sütundan oluşmasını istiyorsak, cols parametresini kullanabiliriz. Şimdi ayrı ayrı ikisiyle ilgili birer örnek yapalım ve nasıl kullanacağımızıgörelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.gridlayout import GridLayout class (App): def build(self): govde = GridLayout(cols = 2) # Max 2 sütundan oluşmasını istedik # 2 sütundan sonra alta kayacaktır # Birden fazla buton ekleyerek nasıl göründüğüne bakalım # for döngüsü ile ekleyelim for i in range(10): govde.add_widget(Button(text = "{}".format(i+1))) return govde ().run() Bakalımnasılgörünüyor 48.3. KivyPaketi 1189 PythonBelgeleri,Yayım4.1.3 Gördüğünüzgibi,nekadarelemaneklersekekleyelimherzaman2sütunuaşmayacakşekilde yerleştiriliyor. Eğer bir sütunun genişliğini biraz daraltmak istersek, aynı sütuna denk gelen elemanlarasize_hint_xparametresinivermemizgerekiyor.Birörneküzerindengörelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.gridlayout import GridLayout class (App): def build(self): govde = GridLayout(cols = 2) # Max 2 sütundan oluşmasını istedik # 2 sütundan sonra alta kayacaktır # Birden fazla buton ekleyerek nasıl göründüğüne bakalım # for kullanarak ekleyelim for i in range(10): if(i%2 == 0): # Aynı sütuna denk gelenler için govde.add_widget(Button(text = "{}".format(i+1), (sonrakisayfayadevam) 1190 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) size_hint_x = .4)) else: govde.add_widget(Button(text = "{}".format(i+1))) return govde ().run() widthparametresinidekullanabiliriz #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.gridlayout import GridLayout class (App): def build(self): govde = GridLayout(cols = 2) # Max 2 sütundan oluşmasını istedik # 2 sütundan sonra alta kayacaktır (sonrakisayfayadevam) 48.3. KivyPaketi 1191 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) # Birden fazla buton ekleyerek nasıl göründüğüne bakalım # for kullanarak ekleyelim for i in range(10): if(i%2 == 0): # Aynı sütuna denk gelenler için govde.add_widget(Button(text = "{}".format(i+1), size_hint_x = None, width = 200)) else: govde.add_widget(Button(text = "{}".format(i+1))) return govde ().run() size_hint_x = None kısmını neden yazdığımıza gelirsek, eğer orantılı boyutlandırmaya None değerivermezsek,widthileboyutubelirlememizeizinvermeyecektir.OyüzdenNonedeğeri vererekboyutlandırmayıwidthileyapabildik. Şimdi,rowskullanımıylaileilgiliörnekyapalım. #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.gridlayout import GridLayout class (App): def build(self): govde = GridLayout(rows = 2) # Max 2 sütundan oluşmasını istedik # 2 sütundan sonra alta kayacaktır # Birden fazla buton ekleyerek nasıl göründüğüne bakalım # for döngüsü ile ekleyelim for i in range(10): govde.add_widget(Button(text = "{}".format(i+1))) return govde ().run() 1192 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Aynı şekilde görüldüğü gibi, ne kadar eleman eklersek ekleyelim, her zaman 2 satır olacak şekilde yerleştiriliyor. Boyutlandırmak için, GridLayout nesnemizi tanımlarken row_default_heightparametresinivererek,varsayılanyüksekliğiniayarlayabiliriz. Eğer GridLayout ile ilgili daha çok bilgiye ulaşmak isterseniz, Kivy GridLayout46 sayfasına bakabilirsiniz. AnchorLayout kivy.uix.anchorlayout.AnchorLayout Pencere araçlarını belli yönlere yaslamak isterseniz, AnchorLayout kullanabilirsiniz. Örneğin sağ-yukarı, veya orta-aşağı gibi. Yalnız, bu pencere düzeninin kullanımı biraz farklı. Diğer pencere düzenleri içerisine eklenen elemanları belli bir düzene göre yerleştiriyordu. Ancak AnchorLayout kullanımı bundan farklı, AnchorLayout daha çok içine pencere araçlarının yaslanmasında yardımcı bir eleman olarak düşünülebilir.Bir örnekle sanırım daha iyi anlayabiliriz. Öncelikle pencere düzenini tanımlayalım. Pencere aracımız X ekseninde sola yaslıveYeksenindeortadadursun. anchor = AnchorLayout(anchor_x = "left",anchor_y = "center") Şimdi,sol-orta’yayerleştirilmesiniistediğimizpencerearacınıbununiçinekoyuyoruz.Örneğin birbutonkoyalım.Yalnızbubutonunboyutlarınıbizbelirlemezsekekranıkaplayacaktır. 46https://kivy.org/doc/stable/api-kivy.uix.gridlayout.html 48.3. KivyPaketi 1193 PythonBelgeleri,Yayım4.1.3 buton = Button(text = "Sol Orta",size_hint = (.2,.2)) anchor.add_widget(buton) İşteönemlinoktaburası.İçinebutoneklediğimizbupenceredüzeni,kendiiçindesol-orta’ya yerleştirmeyecektir. Yerleşim için, bu pencere düzenini FloatLayout gibi bir pencere düzeni içerisindegöstermeliyiz. self.govde = FloatLayout() self.govde.add_widget(anchor) Yerleştirdikten sonra, butonumuz AnchorLayout yardımıyla sol-ortada duracaktır. Şimdi örneğitamolarakverelim. # coding: utf-8 from kivy.app import App from kivy.uix.widget import Widget from kivy.uix.floatlayout import FloatLayout from kivy.uix.anchorlayout import AnchorLayout from kivy.uix.button import Button class AnchorOrnek(App): def build(self): self.govde = FloatLayout() anchor = AnchorLayout(anchor_x = "left",anchor_y = "center") buton = Button(text = "Sol Orta",size_hint = (.2,.2)) anchor.add_widget(buton) self.govde.add_widget(anchor) return self.govde AnchorOrnek().run() Programıçalıştırdıktansonraşöylebirekranbizikarşılayacaktır 1194 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 anchor_x ile kullanılabilecek değerler: “left”,”right”,”center” anchor_y ile kullanılabilecek değerler:“top”,”bottom”,”center” StackLayout kivy.uix.stacklayout.StackLayout Stack yani Türkçe karşılığı olarak yığıt, tam da kelime anlamı olarak pencere araçlarını bir tarafayığarakyerleştirir.Örneğinsağ-yukarışeklindetanımladığımızda,eklenenherpencere aracını bu tarafa yığarak yerleştirmeye başlayacaktır. Aşağıdaki png dosyasına bakarak daha iyianlayabiliriz 48.3. KivyPaketi 1195 PythonBelgeleri,Yayım4.1.3 İçerisine yerleştirilecek pencere araçlarının boyutunu değiştirmek gerekiyor. Yoksa diğer penceredüzenlerindedeolduğugibi,tamamenbulunduğualanıkaplayacakvediğerpencere araçlarınındüzgünbirşekildeyerleştirilmesineengelolacaktır.Şimdi,birörneklebupencere düzeninikullanalım #coding: utf-8 from kivy.app import App from kivy.uix.button import Button from kivy.uix.stacklayout import StackLayout class Program(App): def build(self): govde = StackLayout(orientation = "lr-tb") for i in range(1,11): govde.add_widget(Button(text = "{}".format(i),size_ hint = (None,None),size = (100,50))) ˓→ return govde Program().run() Ekrangörüntüsü 1196 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 StackLayout oluştururken kullandığımız orientation parametresi, yerleştirmenin hangi yönlerdenhangiyöneolacağınıbelirtmekiçinkullanılır.Budurumdabizimyazdığımızdeğere bakarsak,lr-tb,LeftRight-TopBottomyanisoldansağaveyukarıdanaşağışeklinde.Buşekilde kullanılabilecekkombinasyonlar lr-tbtb-lrrl-tbtb-rllr-btbt-lrrl-btbt-rl Ekrandabirdenfazlabutonoluşturmakiçinfordöngüsükullandıkvebubutonlarınboyutunu belirttik. Boyutu sığmayan butonlar otomatik olarak bir alt satıra yerleştirilir, resimde de gördüğünüzgibi. padding StackLayout çerçevesi ve içerisindeki pencere araçlarının arasında ne kadar boşluk olacağını belirtir.Varsayılanolarak[0,0,0,0] 48.3. KivyPaketi 1197 PythonBelgeleri,Yayım4.1.3 spacing Yerleştirilenpencerearaçlarıarasındanekadarboşlukolacağınıbelirtir.Varsayılanolarak[0,0] 48.3.5 Temel Pencere Araçları Bu bölümde, Kivy içerisinde bulunan pencere araçlarından bahsedeceğiz. Bu bölüm, Kivy APIkaynaklarındanyardımalarakoluşturulmuştur.KivydökümanlarındaWidgets47sayfasına bakabilirsiniz Tüm pencere araçları Widget sınıfından türetilmiştir. Widget boş bir pencere aracıdır. Siz de isterseniz Widget sınıfını kullanarak kendi pencere aracınızı oluşturabilirsiniz. Biz de yeri geldiğindeburadaWidgetileilgiliörnekleryapacağız. Pencere araçları kullanıcı ile iletişim imkanı verir, görsel arayüzü anlamlı kılar. Boş pencere hiçbiranlamifadeetmez,ancakpencerearaçlarıylaanlamlıolur.Pencerearaçlarınıikikısımda anlatmayıdüşünüyoruz.Birincikısımdabuton,yazı,metinkutusugibitemelpencerearaçlarını anlatacağız. İkinci kısımda ileri seviye pencere araçlarından bahsedeceğiz. Android tarzı menüler, slayt pencereleri,popuppencerelerigibiaraçlarıikincikısımdaanlatacağız Tabi ki bunlar Kivy dökümanlarında ikiye ayrılmış değil, sadece burada anlatım için benimsenmiştir.Amaçyazılarındahadüzgünveanlamlıbirşekildesıralanmasıdır. Öyleysebaşlayalım Label kivy.uix.label.Label Bildiğiniz gibi Label, ekranda yazı göstermeyi sağlayan bir pencere aracıdır. Nasıl import edeceğimizivenasılkullanabileceğimizibirörneklegörelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba ben bir yazıyım :)") return yazi ().run() Label sınıfıyla birlikte kullanabileceğimiz bazı özellikleri birer örnek ve kısa bir açıklama ile aşağıdabelirteceğim. 47https://kivy.org/doc/stable/guide/widgets.html 1198 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 font_size Yazınınboyutunupixelcinsindenifadeetmeyisağlar.Varsayılanolarak15sp’dir #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba ben bir yazıyım :)", font_size = "25sp") return yazi ().run() halign Yazıyı sağa,sola veya ortaya hizalamak için kullanılır. Varsayılan olarak “left” değerini alır. Verebilinecekdeğerler;left,right,center #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba ben bir yazıyım :)\nSağa yaslı bir yazı... ", ˓→ font_size = "25sp", halign = "right") return yazi ().run() 48.3. KivyPaketi 1199 PythonBelgeleri,Yayım4.1.3 color Yazınınrenginideğiştirmekiçinkullanılır.Listeveyademetolarakdeğeralır.RGBAcinsinden değeralabilir.Varsayılandeğer:[1,1,1,1] #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba\nben bir yazıyım", font_size = "25sp", color = [0,.3,.9,1]) return yazi ().run() bold-italic Yazıyıkalınveeğikgöstermekiçinkullanılır. #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba\nben bir yazıyım", font_size = "25sp", color = [0,.3,.9,1], bold = True, italic = True) return yazi ().run() 1200 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 line_height Satırarasıgenişliğiayarlamakiçinkullanılır.Varsayılandeğeri1’dir. #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Merhaba\nben bir yazıyım", font_size = "25sp", color = [0,.3,.9,1], line_height = 2) return yazi ().run() markup Daha önce HTML tag’leri kullandıysanız markup kullanımını anlamanız gayet kolay olacaktır. Ancak kullanmadıysanız da sorun değil. Zira kolaydır. markup, tag’ler yardımı ile yazınızı biçimlendirmenizisağlar.Kullanılabilirtag’lerşunlardır. [b][/b]:Kalınyazı [i][/i]:İtalicyazı [u][/u]:Altıçiziliyazı [s][/s]:Üstüçiziliyazı [font=][/font]:Fontbelirleme.İnternettenindirdiğinizfontdosyasınınadınıverebilirsiniz.Font dosyasıileprogramınızaynıklasördeolmalı. [size=][/size]:Yazıboyutu [color=#RGB][/color]:Renkliyazı [ref=deger][/ref]: Yazıya bir link ekler. Bu link’e tıklandığı zaman, belirlenen fonksiyona gönderilecektir. [anchor=name]:Yazıyaekleyerek,yazınınsolüstköşesinegörekoordinatbilgisialmayısağlar. yazi.anchorsileerişilebilir. [sub][/sub]:altsimgeolarakyazmayısağlar.Logaritmikgösterimlerdekullanılabilir. [sup][/sup]:üstsimgeolarakyazmayısağlar.Üslüsayılarınyazımındakullanabiliriz Şimdibunlarıbirörnekiçerisindegörelim. 48.3. KivyPaketi 1201 PythonBelgeleri,Yayım4.1.3 #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): string = """ [size=20] [color=#090]Renkli[/color] [size=15]Size 15[/size] [i]italic[/i] [b]bold[/b] [ref=Link]Tıkla[/ref] [u]Altı çizili[/u] [s]Üstü çizili[/s] [font=Pacifico]Font[/font] 2[sup]8[/sup] log[sub]2[/sub]10 [/size] """ # Tüm yazıyı [size=20] [/size] arasına alarak boyutunu artırdım yazi = Label(text = string,markup = True) ’ # markup = True değerini vermezseniz yazınız tag lerle birlikte␣ yorumlanmaz ˓→ ’ # yani tag ler etkisiz hale gelir # kapatmak için, markup = False değerini vermelisiniz yazi.bind(on_ref_press = self.tikla) # ref ile belirlediğimiz yazıya tıklandığı zaman # self.tikla metodumuz çalışacaktır # Burada amaç, ref ile belirlediğimiz yazıya tıklandığı zaman # hangi metodun çalışacağını belirlemektir. # bu bir olaydır. Olayları ileride göreceğiz # şimdilik bu örneği anlamanız yeterli return yazi def tikla(self,nesne,deger): ’ print("Deger: {}".format(deger)) # [ref=deger] kısmındaki deger i␣ yazdırır ˓→ ().run() Örnekte kullandığım Pacifico font’unu internet üzerinden kolaylıkla temin edebilirsiniz. İndirdiktensonraprogramınanadosyasınınyanınakoymanızgerekiyor.Yoksafontdosyasının bulunamadığınadairhatamesajıylakarşılaşırsınız. 1202 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Yazınızın özelliklerine sonradan erişebilir, isterseniz bunları değiştirebilirsiniz. yazi.ozellik şeklinde ilgili özelliğe erişebilir, yazi.ozellik = yeni_deger ile de yeni değerini verebilirsiniz. Örneğin,biryazınıniçeriğiniverenginideğiştirelim #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.label import Label class (App): def build(self): yazi = Label(text = "Eski değer..", color = [0,.3,.9,1]) yazi.text = "Yeni değer.." yazi.color = [1,0,0,1] return yazi ().run() LabelileilgilidahafazlabilgiiçinKivyLabel48 sayfasınıziyaretedebilirsiniz Button kivy.uix.button.Button Button pencere aracı, butonlar oluşturmayı sağlar ve kivy.uix.button içerisinde bulunur. Bir butona tıklandığı zaman olaylar meydana gelir. Mesela butona tıklanma olayı, basılı tutulma olayı, butonu bırakma olayı vs hepsi birer olaydır ve event olarak adlandırılır. Event ingilizceolay,hareketdemektir.Butonlarolaylarlaanlamkazanır.Birbutonuntıklanmaolayını fonksiyonlaryardımıyladinleriz,olaygerçekleştiğizamanfonksiyonumuzdaçalışmışolur.Biz debufonksiyoniçerisindeyapılmasınıistediğimizişlemleriyazarız. Kivyiçerisindebutonlar,birerLabelsayılabilirler.Label’denfarkıtıklanabiliraraçlardır.Onun dışındaLabelilebirliktekullanılantümözellikleriButtonsınıfıylabirliktekullanabiliriz.Elbette bir Label’den fazlasına sahiptir. Bunları da birazdan inceleyeceğiz. Öncelikle bir butonun nasıloluşturulduğunuvebubutonunolaylarını(örneğinbutonatıklama)nasıldinleyeceğimizi görelim. #!/usr/bin/env python # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.button import Button from kivy.uix.boxlayout import BoxLayout class (App): (sonrakisayfayadevam) 48https://kivy.org/doc/stable/api-kivy.uix.label.html 48.3. KivyPaketi 1203 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def build(self): self.govde = BoxLayout(orientation = "vertical") self.yazi = Label(text = "Bildiri Ekranı") self.buton = Button(text = "Tıkla",size_hint_y = .3) self.buton.bind(on_press = self.press) # Basılma olayını self.press fonksiyonuna bağladık # Yani butona basıldığı anda self.press fonksiyonumuz␣ çalışacaktır ˓→ self.buton.bind(on_release = self.release) # Bırakılma olayını self.release fonksiyonuna bağladık # Yani buton bırakıldığı anda self.release fonksiyonumuz␣ çalışacaktır ˓→ self.govde.add_widget(self.yazi) self.govde.add_widget(self.buton) return self.govde def press(self,nesne): self.yazi.text = "Buton’a basıldı" def release(self,nesne): self.yazi.text = "Buton bırakıldı" Şimdikoduinceleyelim.İlkolarakgereklisınıflarımızıimportettik.BirtaneBoxLayoutpencere düzenioluşturduk,içerisinedeyazımızıvebutonumuzuekledik.Butonumuzunyazımızagöre dikeydedahaazyerkaplamasıiçinsize_hint_yparametresine.3değeriniverdik. Sonra,butonumuzunbind()metoduileon_pressolayını,self.pressfonksiyonumuzabağladık. Fonksiyon ismini istediğiniz şekilde belirleyebilirsiniz. Ancak dikkat etmeniz gereken şey, fonksiyonun aldığı parametrelerdir. Fonksiyonumuz self hariç bir tane daha parametre alır. Bu parametre, olayın kaynağı olan pencere aracıdır. Dolayısıyla butona tıkladığımızda olayın kaynağıbubutonoluyor. Buttonsınıfınadairbazıözellikleritanımlamayalım background_color Butonumuzunarkaplanrengi.(r,g,b,a)formatındadeğeralır. buton = Button(text = "Buton", background_color = [1,1,0,1]) veya buton.background_color = [1,1,0,1] 1204 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 background_normal Butonun basılı olmadığı durumdaki arkaplan resmi. Resmin adını yazmanız yeterlidir. Resminiz ana program ile aynı klasörde olmalıdır. Eğer bir alt klasörde ise, mesela images klasöründeise“images/resim.png”yazmalısınız buton = Button(text = "Buton",background_normal = "resim.png") veya buton.background_normal = "resim.png" background_down Butonabasılıhaldekiarkaplanresmi.background_normalileaynıdır. buton = Button(text = "Buton",background_down = "resim.png") veya buton.background_down = "resim.png" disabled Butonun aktif olup olmama durumu. True değeri verilirse buton deaktif hale gelecektir. Bu durumdabutonatıklamayapılamaz.EğerFalsedeğeriverilirsebutonaktifhalegelecektir buton = Button(text = "Buton",disabled = True) veya buton.disabled = True background_disabled_normal Butonaktifolmadığıdurumdakiarkaplanresmi buton = Button(text = "Buton",background_disabled_normal = "resim.png") veya buton.background_disabled_normal = "resim.png" 48.3. KivyPaketi 1205 PythonBelgeleri,Yayım4.1.3 background_disabled_down Butonaktifolmadığıdurumda,butonabasıldığızamanbelirlenenarkaplanresmi buton = Button(text = "Buton",background_disabled_down = "resim.png") veya buton.background_disabled_down = "resim.png" border Butonun kenar genişlikleri. [alt,sağ,üst,sol] formatında değer alır. Varsayılan değeri [16,16,16,16] buton = Button(text = "Buton",border = [2,2,2,2]) veya buton.border = [2,2,2,2] Buttonsınıfıylailgilidahadetaylıbilgiiçinhttps://kivy.org/doc/stable/api-kivy.uix.button.html TextInput kivy.uix.textinput.TextInput TextInput,kullanıcıdangirdialmayısağlar,programlardaçokkullandığımızmetinkutularıdır. Tek satırlı, çok satırlı, yıldızlı girdi alma ve daha birçok işlem için kullanılabilir. Aynı zamanda CTRL+C,CTRL+Zgibikısayoltuşlarıdakullanılabilir. kivy.uix.textinput modülü içerisinde yer alır. Hatırlarsanız BoxLayout konusunda bir örnek yapmıştık. Bu örnek kullanıcıdan nick ve şifre almak üzere tasarlanmıştı ama henüz birşey yapamıyordu.İşteşimdibuyazdığımızörneğikullanılabilirhalegetireceğiz. Öncelikleörneğimizitekraryazalım from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout from kivy.uix.button import Button from kivy.uix.textinput import TextInput class Program(App): def build(self): self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların␣ hepsini tutan ana pencere düzenimiz ˓→ self.ilkSatir = BoxLayout() self.ikinciSatir = BoxLayout() (sonrakisayfayadevam) 1206 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.nick = Label(text = "Nick") self.nickKutu = TextInput() self.sifre = Label(text = "Şifre") self.sifreKutu = TextInput() self.buton = Button(text = "Giriş Yap") self.ilkSatir.add_widget(self.nick) self.ilkSatir.add_widget(self.nickKutu) self.ikinciSatir.add_widget(self.sifre) self.ikinciSatir.add_widget(self.sifreKutu) # Şimdi hepsini ana düzene yerleştiriyoruz self.anaDuzen.add_widget(self.ilkSatir) self.anaDuzen.add_widget(self.ikinciSatir) self.anaDuzen.add_widget(self.buton) return self.anaDuzen Program().run() Nickaldığımızmetinkutusunuteksatırlıhalegetirmeliyiz.YanikullanıcıEnter’abastığızaman altsatırageçmemeli.Bununiçin nickKutu = TextInput(multiline = False) yazmamızyeterli.Böyleceartıkaltsatırageçmeyecek,sağadoğruyazmayadevamedecektir. Bu arada eğer multiline değeri “False” ise, kullanıcı Enter’a bastığında metin kutusu odaktan çıkacaktır. Şimdi de parolayı aldığımız kutucuğu tek satırlı hale getirelim ve yazılanların görünmemesi içinparolayıyıldızlıhalegetirelim. sifreKutu = TextInput(multiline = False, password = True) Böylece kullanıcı şifresini girdiğinde, yazdığı karakter değil yıldız görünecektir. Varsayılan olarakyıldızdır.Değiştirmekisterseniz; sifreKutu = TextInput(multiline = False,password = True,pasword_mask = "?") Yada sifreKutu.password_mask = "?" Şimdi de butonumuza olay ekleyelim. Yani butona basıldığı zaman kutulardaki bilgileri alsın vekontroletsin.Eğerbilgilerdoğruolursa“Girişbaşarılı”yazsın,hatalıysa“HatalıGiriş”yazsın. 48.3. KivyPaketi 1207 PythonBelgeleri,Yayım4.1.3 Kodumuzuyenidenyazacakolursak # coding: utf-8 from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout from kivy.uix.button import Button from kivy.uix.textinput import TextInput class Program(App): def build(self): self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların␣ hepsini tutan ana pencere düzenimiz ˓→ self.ilkSatir = BoxLayout() self.ikinciSatir = BoxLayout() self.nick = Label(text = "Nick") self.nickKutu = TextInput(multiline = False) self.sifre = Label(text = "Şifre") self.sifreKutu = TextInput(multiline = False, password = True, password_mask = "?") self.buton = Button(text = "Giriş Yap") self.buton.bind(on_press = self.kontrol) # Butonumuza tıklama olayı␣ ekledik ˓→ self.ilkSatir.add_widget(self.nick) self.ilkSatir.add_widget(self.nickKutu) self.ikinciSatir.add_widget(self.sifre) self.ikinciSatir.add_widget(self.sifreKutu) # Şimdi hepsini ana düzene yerleştiriyoruz self.anaDuzen.add_widget(self.ilkSatir) self.anaDuzen.add_widget(self.ikinciSatir) self.anaDuzen.add_widget(self.buton) return self.anaDuzen def kontrol(self,event = None): if(self.nickKutu.text == "admin" and self.sifreKutu.text == "12345"): print("Giriş Başarılı") else: (sonrakisayfayadevam) 1208 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) print("Hatalı Giriş") Program().run() Programıçalıştırıpkullanıcıadını“admin”veparolayı“12345”olarakgirerseniz“GirişBaşarılı” yazılacaktır.Ancakikisindenherhangibiriniyanlışyazarsanız“HatalıGiriş”yazılacaktır. Kutulardaki metinleri kutu.text niteliği yardımıyla aldık. Bu bir String değerdir ve eğer kullanıcıdansayıaldığımızdabununStringolarakbizeverildiğinivebunuInteger’açevirmemiz gerektiğiniunutmayalım. TextInputGirdileriniKontrolEtme TextInputaracımızagirilengirdilerikontroletmekistersek,TextInput.insert_text()metodunun üzerine yazmalıyız. Yani bu sınıfı miras alıp insert_text() metodunu kendimize göre tekrar yazmalıyız.Hemenbirörneklebunugörelim # coding: utf-8 from kivy.app import App from kivy.uix.textinput import TextInput class MyInput(TextInput): def insert_text(self,substring,from_undo = False): s = substring.upper() return super(MyInput,self).insert_text(s,from_undo) class Program(App): def build(self): return MyInput() Program().run() Programımıza girilen karakter ister küçük ister büyük olsun, her zaman büyük olarak metin kutusunaeklenecektir.Pekibununasılyaptık?ÖncelikleTextInput()sınıfınımirasaldık.Miras almaişlemininesneyönelimliprogramlamadanbiliyorolmanızgerekiyor.Kısacamirasalma, önceden yazılan bir sınıfı yeni yazılan sınıfa katma, onun özelliklerini de kullanmaktır. Biz burada kendimize ait bir metin kutusu yapmak istediğimiz için, ilk olarak TextInput sınıfını mirasaldık. Bu sınıf, girilen yazıları inser_text() metoduyla işlediği için, biz de bu metodu yeniden yazdık. Böylece bir karakter girildiği zaman TextInput sınıfının insert_text() metodu değil, bizim yazdığımız sınıfın insert_tex() metodu çalışacaktır. Böylece biz de gelen karakterleri işleyebileceğiz.Girilenkarakter“substring”argümanıylagelir.Bunuişleyipüstsınıfaişlenmiş olarak göndereceğiz. Biz de burada gelen karakter upper() metoduyla büyük karaktere 48.3. KivyPaketi 1209 PythonBelgeleri,Yayım4.1.3 dönüştürdük ve üst sınıfın insert_text() metodunu değiştirilmiş karakterle birlikte çağırdık. Mirasaldığımızsınıfınmetodunuçağırmakiçinsuper()metodundanyararlanıyoruz. Bir karakteri değiştirdiğimiz gibi, bu karakterin yazılmamasını da sağlayabiliriz. Diyelim ki “j” harfinin hiç girilmemesini istiyorsunuz, bu durumda “j” harfinin girilmesini şu şekilde engelleyebilirsiniz. # coding: utf-8 from kivy.app import App from kivy.uix.textinput import TextInput class MyInput(TextInput): def insert_text(self,substring,from_undo = False): if(substring.lower() == "j"): return False else: return super(MyInput,self).insert_text(substring,from_undo) class Program(App): def build(self): return MyInput() Program().run() Programabüyük“J”harfidegirilebileceğiiçin,gelenbüyükkarakteriküçülterekkontroledip, hiçbirşekildebuharfingirişineizinvermiyoruz. Şimdi,TextInputilebirliktekullanabileceğimizbazınitelikleriveolaylarıinceleyelim. selection_text TextInput üzerinde bir yazı seçildiği zaman, bu seçili yazıya selection_text ile erişebiliriz. Böyleceseçiliyazıüzerindeişlemleryapabiliriz. focus TextInput üzerine odaklanıldığı zaman veya odaktan ayrıldığı zaman meydana gelen olay. Örnekkullanım def on_focus(instance, value): if value: print(’Odaklanıldı’, instance) else: print(’Odaktan çıktı’, instance) (sonrakisayfayadevam) 1210 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) textinput = TextInput() textinput.bind(focus=on_focus) copy(veri<str>) Copyfonksiyonu,kopyalamahafızasınaverilen“veri”değerinikopyalar.“veri”argümanıString olmalıdır. Eğer “veri” argümanı verilmezse, o anda metin kutusu üzerinde seçili olan metni hafızayakopyalar. metinKutusu.copy() Yada metinKutusu.copy("kopyala") cut() Copyileaynıişiyapmaklaberaber,kopyaladığımetnimetinkutusundansiler,yanibildiğimiz kesmeişleminiyapar. paste() Kopyalamahafızasındakimetni,metinkutusunaoandakicursorpozisyonunayerleştirir. readonly Eğer metin kutusundaki ifadenin kullanıcı tarafından değiştirilmesini istemiyorsanız, readonly niteliğine True değerini vermelisiniz. Böylece kullanıcılar metin kutusundaki metni değiştiremeyecekancakokuyupkopyalayabilecektir. metinKutusu.readonly = True tab_width Tab tuşunun varsayılan değeri 4’tür. Eğer bu değeri değiştirmek isterseniz tab_width parametresinebudeğerisayıolarakvermelisiniz. 48.3. KivyPaketi 1211 PythonBelgeleri,Yayım4.1.3 text TextInputiçerisindekimetindebirdeğişiklikolduğuzaman,bir“text”olayımeydanagelir.Bu olayıaşağıdakiörnektekigibielealabiliriz def on_text(instance, value): print("TextInput metni değişti: {}".format(value)) textinput = TextInput() textinput.bind(text=on_text) CheckBox kivy.uix.checkbox.CheckBox Onay kutuları, genelde bir seçeneğin seçilip seçilmeyeceği veya birden fazla seçenek arasındanbirtanesininseçilmesigerektiğidurumlardakullanılır.Örneğin,internetsitelerinde üye girişi yaparken bize sorulan “Hesabımı Hatırla” sorusunun yanında bir tane onay kutusu vardır. Seçili olduğunda, bir sonraki girişiniz otomatik yapılacaktır demektir. Eğer seçili olmazsatarayıcıkapandığızamanbilgilerinizartıkhatırlanmayacaktır. Çokluseçimeörnekverecekolursak,formlardacinsiyetsorulduğuzamanBay-Bayanşeklinde iki seçenekten birisinin seçilmesi gerektiği durumlarda kullanılır. Kivy, bu iki aracı da kullanabilmemiz için bize sunmuştur. Şimdi bunları nasıl kullanacağımızı görelim. Önceki yazılardayazdığımızörneğebirdeonaykutusuekleyelim # coding: utf-8 from kivy.app import App from kivy.uix.label import Label from kivy.uix.boxlayout import BoxLayout from kivy.uix.button import Button from kivy.uix.textinput import TextInput from kivy.uix.checkbox import CheckBox class Program(App): def build(self): self.anaDuzen = BoxLayout(orientation = "vertical") # Elemanların␣ hepsini tutan ana pencere düzenimiz ˓→ self.ilkSatir = BoxLayout() self.ikinciSatir = BoxLayout() self.nick = Label(text = "Nick") self.nickKutu = TextInput(multiline = False) self.sifre = Label(text = "Şifre") self.sifreKutu = TextInput(multiline = False, (sonrakisayfayadevam) 1212 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) password = True, password_mask = "?") self.buton = Button(text = "Giriş Yap") self.buton.bind(on_press = self.kontrol) # Butonumuza tıklama olayı␣ ekledik ˓→ self.ilkSatir.add_widget(self.nick) self.ilkSatir.add_widget(self.nickKutu) self.ikinciSatir.add_widget(self.sifre) self.ikinciSatir.add_widget(self.sifreKutu) self.onaySatir = BoxLayout(size_hint_y = .3) # onay kutumuzu ve yazımızı tutacak olan BoxLayout # Boyutunu biraz küçülttük :) self.onayYazi = Label(text = "Beni Hatırla") self.onayKutu = CheckBox() self.onaySatir.add_widget(self.onayYazi) self.onaySatir.add_widget(self.onayKutu) # Şimdi hepsini ana düzene yerleştiriyoruz self.anaDuzen.add_widget(self.ilkSatir) self.anaDuzen.add_widget(self.ikinciSatir) self.anaDuzen.add_widget(self.onaySatir) self.anaDuzen.add_widget(self.buton) return self.anaDuzen def kontrol(self,event = None): if(self.nickKutu.text == "admin" and self.sifreKutu.text == "12345"): if(self.onayKutu.active): print("Giriş Başarılı ve bilgileriniz hatırlanacak") else: print("Giriş Başarılı, bilgileriniz hatırlanmayacak") else: print("Hatalı Giriş") Program().run() 48.3. KivyPaketi 1213 PythonBelgeleri,Yayım4.1.3 BoxLayoutiçerisinebirsatırdahaekledik.Busatırımız,“BeniHatırla”yazısınıveonaykutusunu taşıyor. Girişi kontrol ettiğimiz kontrol() fonksiyonunda onay kutusunun “active” yani seçili olup olmadığını kontrol ettik. Onay kutusunun seçili olup olmadığını “active” niteliğiyle öğrenebiliriz. Eğer True ise, kutu seçili demektir. Eğer False ise, onay kutusu seçili değil demektir. CheckBox pencere aracını, RadioButton olarak kullanmak isterseniz elinizdeki onay kutularınıngruplarınaaynıdeğerlerivermenizgerekiyor.Örneğin kutu1 = CheckBox(group = 1) kutu2 = CheckBox(group = 1) kutu3 = CheckBox(group = 2) kutu4 = CheckBox(group = 2) kutu1vekutu2aynıgruptaolduğuiçin,biriaktifolduğundadiğerideaktifolacaktır. 1214 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 CheckBoxileilgilibazıniteliklerebakalım color CheckBox görünümünü(rengini) değiştirmek için kullanılabilir. Liste veya demet olarak parametrealır active Eğer bir CheckBox’ın aktif olma olayını ele almak isterseniz, bind ile tanımlayıp active parametresinefonksiyonunuzuyazmanızgerekir def on_checkbox_active(checkbox, value): if value: print(’Checkbox’, checkbox, ’aktif’) else: print(’Checkbox’, checkbox, ’deaktif’) checkbox = CheckBox() checkbox.bind(active=on_checkbox_active) Fonksiyonunuzikiparametrealmalıdır.BirincisiCheckBox’ınkendisi,diğeriaktifolupolmama durumunubelirtenbooleanbirparametre(TrueveyaFalse). 48.3. KivyPaketi 1215 PythonBelgeleri,Yayım4.1.3 Image kivy.uix.image.Image Eğer uygulamamızda resim göstermek istersek, Image kullanabiliriz. Kivy ile resimleri kullanmakoldukçakolay.Birdenfazlaresimformatınıdestekliyor.Yapmamızgerekensadece gereklisınıfıimportetmekveresimdosyasınınyolunuyazmak.Birörneklegörelim. # coding:utf-8 from kivy.uix.image import Image from kivy.app import App class (App): def build(self): resim = Image(source = "resim.png") return resim ().run() resim.pngdosyası,programınızınanadosyasıileaynıdizindeolmalıdır.Aksitakdirdeekranda beyaz boş bir alan gösterilir. Resim gösterildiği zaman, boyutu neyse o şekilde yerleştirilir. Resminboyutlandırılmasınıbirazdannitelikleriincelediğimizzamangöreceğiz. Resimleri sadece bilgisayarınızdaki bir dosyadan değil, aynı zamanda internet üzerinden gösterebilirsiniz.BununiçinAsyncImagekullanılır.Buyrunörneklegörelim:) # coding:utf-8 from kivy.uix.image import Image,AsyncImage from kivy.app import App class (App): def build(self): resim = AsyncImage(source = "https://www.blogger.com/img/blogger- logotype-color-black-1x.png") ˓→ return resim ().run() Resim internet üzerinde yüklenirken, resmin halen yüklenmekte olduğunu gösteren bir “loading” gif’i resmin yerinde durur. Resim yüklenince “loading” gif’i kaldırılır. Eğer bu “loading” gif’ini değiştirmek isterseniz, Loader sınıfını import edip, varsayılanı değiştirmeniz gerekir. from kivy.loader import Loader # import etme Loader.loading_image = "your.gif" # varsayılanı değiştirme 1216 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 ResminBoyutlarınıDeğiştirme Birresminboyutlarınıdeğiştirebiliriz.Bununiçinkvdilindenyardımalabiliriz. Image: source:"resim.png" width:100 height:600 size_hint_x:None size_hint_y:None keep_ratio:False allow_stretch:True Resmin istenilen şekilde boyutlandırılabilmesi için, orantılı boyutlandırma özellikleri None yapılmalıdır. Ve resmin en-boy oranını koruma özelliği False, uzatılma özelliği True yapılmalıdır.Artıkresminboyutlarıylaistediğimizgibioynayabiliriz:) allow_stretch Resmimizin bulunduğu alanı tam olarak doldurmasını istiyorsak kullanabiliriz. Değer olarak TrueveyaFalsealabilir.Truedeğeriverildiğinde,bulunduğualanagöreboyutuartırılır.Ancak en-boyoranıkorunur.Örneğin,eniboyundanbüyükolanbirresim,boyutuarttığızamanda eniboyundanbüyükolacaktır. keep_ratio allow_stretchilebirlikte,en-boyoranınıkorumadanbulunduğualanıtamolarakdoldurmasını istersek, keep_ratio değerini False yapmalıyız. Bu parametre de, True veya False olarak iki değeralır. anim_delay Eğeryüklediğinizresimbirgifise(veyabaşkabiranimasyonformatı),resimkareleriarasında geçişsüresinianim_delayileayarlayabilirsiniz.Varsayılanolarak0.25’tir.Yanisaniyede4kare. anim_loop Gif dosyamızın kaç kere döngüye gireceğini belirtebiliriz. Örneğin gif’in sadece 1 kez çalışmasınıistersek, resim.anim_loop = 1 yazmalıyız.Böylecegifresmimizbirkereçalışacakveduracaktır.Varsayılanolarak0’dırve-1 değeriverilirseduracaktır 48.3. KivyPaketi 1217 PythonBelgeleri,Yayım4.1.3 reload() Diskten okuduğumuz resmi değiştirdiğimizde, bunu uygulama içinde güncellemek istersek reload()metodunukullanabiliriz. ProgressBar kivy.uix.progressbar.ProgressBar ProgressBarilebirişleminnekadarınıntamamlandığınıgörselolarakgösterebiliriz.Kullanımı gayetbasit.Basitbirörnekyapalım # -*- coding: utf-8 -*- from kivy.app import App from kivy.uix.progressbar import ProgressBar from kivy.clock import Clock class (App): def build(self): self.bar = ProgressBar(max = 100) self.deger = 0 Clock.schedule_once(self.say,1) # 1 ms sonra self.say adlı fonksiyona␣ git ˓→ return self.bar def say(self,event = None): if(self.deger <= 100): self.bar.value = self.deger self.deger += 5 Clock.schedule_once(self.say,.5) ().run() ProgressBar’mızıtanımladıkvemaxdeğerini100olarakverdik.Yanieğerbarımızındeğerinien fazla100olarakverebiliriz.Eğer10olarakbelirleseydik,enfazla10değeriniverebilirdik.Sonra Clockyardımıylasayacımız100olanakadardöngüyegirdikvebarımızındeğerinideğiştirdik. 1218 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.3.6 Uygulama 1 - Resim Görüntüleyici Şimdiye kadar öğrendiklerimiz ile örnek bir uygulama yapma zamanı geldi. Çünkü uygulamadıkçaöğrenmemizeksikkalır.Oyüzdenbirörnekyapalım Örneğimiz bir resim görüntüleyici. Bir klasör içinde bulunan resimleri listeler, sonra bunları ileri ve geri butonlarına bastıkça görüntüler. Planımız ise şöyle. Girişte bir yazı ve bir progressbar olacak. Resimler yüklenirken progressbar üzerinde yüklenme durumu gösterilecek. Tabi, resimler az olduğunda çok hızlı bir şekilde yüklenecek. Ancak örnekte de bulunsundiyebirprogressbareklemekistedim. Resimlerimiz yüklendikten sonra, ekrandaki yazıyı ve progressbar’ı kaldırıp yerine ana ekranımızı koyacağız. Bunu da ayrı bir fonksiyon içinde yaptık. O zaman şimdi kodumuzu görelim,sonradaincelemeyebaşlayalım # -*- coding: utf-8 -*- # Resim Görüntüleyici # from kivy.app import App from kivy.uix.boxlayout import BoxLayout from kivy.uix.label import Label from kivy.uix.button import Button from kivy.uix.widget import Widget from kivy.uix.image import Image from kivy.clock import Clock from kivy.uix.progressbar import ProgressBar import os class Program(App): def resimYukle(self,dosya_yolu): # Format listesi liste = ["png","gif","jpeg","jpg"] # Dosyaların listesini alma dosyaListesi = os.listdir(dosya_yolu) self.sayac = 0 self.bar.max = len(dosyaListesi) self.bar.value = 0 # Resim dosyalarını tespit etme for i in dosyaListesi: if(i.split(".")[-1] in liste): self.resimListesi.append(i) self.sayac += 1 self.bar.value = self.sayac # Resimlerin yüklenmesi bittikten sonra, görüntüleme ekranını başlatmak␣ üzere ˓→ # self.basla fonksiyonuna git (sonrakisayfayadevam) 48.3. KivyPaketi 1219 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.yukleniyor.text = "Resimler yüklendi" Clock.schedule_once(self.basla,1.5) def build(self): self.resimYolu = "resim/" self.resimListesi = list() self.resimSirasi = 0 self.yukleniyor = Label(text = "Resimler yükleniyor...") self.bar = ProgressBar() self.govde = BoxLayout(orientation = "vertical") self.govde.add_widget(self.yukleniyor) self.govde.add_widget(self.bar) # Resimleri yüklemek üzere, self.resimYukle fonksiyonuna git Clock.schedule_once(lambda event = None:self.resimYukle(self.resimYolu), 1) ˓→ return self.govde def basla(self,event = None): # Ekrandaki tüm araçları kaldırıyoruz self.govde.clear_widgets() # Ve yeni araçlarımızı ekliyoruz self.bilgi = Label(text = "[color=#05f][/color] Resim␣ Görüntüleyici", ˓→ markup = True, size_hint_y = .1) self.resim = Image(source = self.resimYolu+self.resimListesi[0], allow_stretch = True, keep_ratio = True) # Geri ve ileri butonlarını taşıyan BoxLayout self.butonBar = BoxLayout(size_hint_y = .15) self.ileri = Button(text = "ileri", size_hint_x = .2, on_release = self.ileriYukle ) self.geri = Button(text = "geri", size_hint_x = .2, on_release = self.geriYukle) self.butonBar.add_widget(self.geri) self.butonBar.add_widget(Widget()) (sonrakisayfayadevam) 1220 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.butonBar.add_widget(self.ileri) self.govde.add_widget(self.bilgi) self.govde.add_widget(self.resim) self.govde.add_widget(self.butonBar) def ileriYukle(self,event = None): self.resimSirasi += 1 # Eğer resim sırası listemizin boyutunu aşmamışsa if(self.resimSirasi < len(self.resimListesi)): try: self.resim.source = self.resimYolu+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: self.bilgi.text = "Yuklenemedi: {}".format(self. resimListesi[self.resimSirasi]) ˓→ # Eğer liste boyutunu aşmışsa, bunu sıfırlıyoruz else: try: self.resimSirasi = 0 self.resim.source = self.resimYolu+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: self.bilgi.text = "Yuklenemedi: {}".format(self. resimListesi[self.resimSirasi]) ˓→ def geriYukle(self,event = None): self.resimSirasi -= 1 # Eğer resim sırası listemizin boyutunun altına düşmemişse if(self.resimSirasi >= 0): try: self.resim.source = self.resimYolu+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: print(e) self.bilgi.text = "Yuklenemedi: {}".format(self. resimListesi[self.resimSirasi]) ˓→ # Eğer düşmüşse, yani negatif olduysa # sırayı listenin sonuna alıyoruz (sonrakisayfayadevam) 48.3. KivyPaketi 1221 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) else: try: self.resimSirasi = len(self.resimListesi)-1 self.resim.source = self.resimYolu+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: print(e) self.bilgi.text = "Yuklenemedi: {}".format(self. resimListesi[self.resimSirasi]) ˓→ Program().run() Öncelikle,programımızbaşlarbaşlamazyazıyıveprogressbar’ıekliyoruzsonradaresimlerin yüklenmesiiçinself.resimYuklefonksiyonunagidiyoruz. def resimYukle(self,dosya_yolu): # Format listesi liste = ["png","gif","jpeg","jpg"] # Dosyaların listesini alma dosyaListesi = os.listdir(dosya_yolu) self.sayac = 0 self.bar.max = len(dosyaListesi) self.bar.value = 0 # Resim dosyalarını tespit etme for i in dosyaListesi: if(i.split(".")[-1] in liste): self.resimListesi.append(i) self.sayac += 1 self.bar.value = self.sayac # Resimlerin yüklenmesi bittikten sonra, görüntüleme ekranını başlatmak␣ üzere ˓→ # self.basla fonksiyonuna git self.yukleniyor.text = "Resimler yüklendi" Clock.schedule_once(self.basla,1) Bu fonksiyonda ilk olarak, hangi resim formatlarını göstereceğimizi bir listede tuttuk. Farklı resim formatları da ekleyebilirsiniz. Biz şimdilik bu 4 formatı tercih ettik. Bu formatlar dışındakiresimleridikkatealmayacaktır. Formatlarımızı tanımladıktan sonra, os.listdir() yardımıyla hangi klasördeki resimleri göstermek istiyorsak, o klasördeki dosyaları liste olarak elde ediyoruz. Bakın resimleri değil, dosyaları diyorum. Çünkü os.listdir() sadece verilen dizindeki dosyaların listesini verir. Bu listedenresimdosyalarını,bizimbelirlediğimizformattaolanları,ayırtetmekbizimişimiz. Bu yüzden hemen aşağısında for döngüsü ile bu listenin elemanlarını tek tek kontrol ettik, ve uzantısı bizim belirttiğimiz uzantılardan biriyle eşleşiyorsa, self.resimListesi adlı listemize 1222 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 ekledik. Tüm resimleri tespit ettikten sonra, 1 saniye sonra self.basla fonksiyonuna gidiyoruz. Bu fonksiyonda, ekrandaki tüm araçları self.govde.clear_widgets() ile temizledik ve yeni araçlarımızıekledik. def basla(self,event = None): # Ekrandaki tüm araçları kaldırıyoruz self.govde.clear_widgets() # Ve yeni araçlarımızı ekliyoruz self.bilgi = Label(text = "[color=#05f][/color] Resim Görüntüleyici", markup = True, size_hint_y = .1) self.resim = Image(source = self.resimYolu+os.sep+self.resimListesi[0], allow_stretch = True, keep_ratio = True) # Geri ve ileri butonlarını taşıyan BoxLayout self.butonBar = BoxLayout(size_hint_y = .15) self.ileri = Button(text = "ileri", size_hint_x = .2, on_release = self.ileriYukle ) self.geri = Button(text = "geri", size_hint_x = .2, on_release = self.geriYukle) self.butonBar.add_widget(self.geri) self.butonBar.add_widget(Widget()) self.butonBar.add_widget(self.ileri) self.govde.add_widget(self.bilgi) self.govde.add_widget(self.resim) self.govde.add_widget(self.butonBar) Bufonksiyondayabancıolduğumuzbirkodyoksanırım.Kullandığımıztümpencerearaçlarını daha önce gördük. Sadece butonBar içine eklediğimiz bir adet boş widget var. Onu da iki butonunarasınıdoldurmakiçinekledik.Eklemeseydikdeolurdutabi. Butonlarımızı ekledik ve ileri butonuna tıklandığı zaman, self.ileriYukle fonksiyonumuzun çalışmasınısağladık. def ileriYukle(self,event = None): self.resimSirasi += 1 # Eğer resim sırası listemizin boyutunu aşmamışsa if(self.resimSirasi < len(self.resimListesi)): try: (sonrakisayfayadevam) 48.3. KivyPaketi 1223 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.resim.source = self.resimYolu+os.sep+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self. resimSirasi]) ˓→ # Eğer liste boyutunu aşmışsa, bunu sıfırlıyoruz else: try: self.resimSirasi = 0 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self. resimSirasi]) ˓→ İlk olarak resimSirasi değişkenini 1 artırıyoruz ve sonra da bu değerin listemizin boyutunu aşıp aşmadığını kontrol ediyoruz. Çünkü eğer boyutunu aşarsa, “liste boyutu aşıldı” hatası alabiliriz.Buyüzdeneğerboyutuaştıysa,değerinitekrardan0yapıyoruz Geributonumuziçindebenzerşeyleriyapıyoruz def geriYukle(self,event = None): self.resimSirasi -= 1 # Eğer resim sırası listemizin boyutunun altına düşmemişse if(self.resimSirasi >= 0): try: self.resim.source = self.resimYolu+os.sep+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: print(e) self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self. resimSirasi]) ˓→ # Eğer düşmüşse, yani negatif olduysa # sırayı listenin sonuna alıyoruz else: try: self.resimSirasi = len(self.resimListesi)-1 self.resim.source = self.resimYolu+os.sep+self.resimListesi[self. resimSirasi] ˓→ self.bilgi.text = self.resimListesi[self.resimSirasi] except Exception as e: print(e) self.bilgi.text = "Yuklenemedi: {}".format(self.resimListesi[self. (sonrakisayfayadevam) 1224 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) resimSirasi]) ˓→ Burada farklı olarak, resimSirasi değerinin eksiye düşüp düşmediğini kontrol ettik. Eksiye düştüyse, tekrar listenin sonuna alıyoruz. Böylece bir döngü içinde resimlerin görüntülenmesinisağladık. Örnekte bulunan os.sep, bulunduğunuz işletim sisteminde kullanılan dizin ayracını verir. Linux kullanıyorsanız, “/” Windows kullanıyorsanız “\” veya “" olarak belirlenir. Örnekte kullanmamızınsebebi,resimyoluveresimadınıbirleştirdiğimizdearayadizinayracıkoymak. Eğerkoymazsak,resminbulunamadığınadairhataalırız. >>> resimYolu+os.sep+resim "resim/resim.jpg" >>> resimYolu+resim "resimresim.jpg" Benörnektegörüntülemekistediğimresimleri,programileaynıklasördebulunan“resim”adlı klasörekoydum.Eğeraynıklasördebulunmayanbaşkabirklasörülistelemekisterseniz,tam dizinivermenizgerekiyor.Yani“C:\resimler”gibi. Programıngörüntüsüşöyle Gayet güzel çalışıyor. Kodu elimden geldiği kadar anlaşılır yazmaya çalıştım. Eğer 48.3. KivyPaketi 1225 PythonBelgeleri,Yayım4.1.3 anlamadığınız bir kısım olursa, veya hata olduğunu düşündüğünüz bir kısım varsa Forum49 üzerindenulaşabilirsiniz. 48.3.7 Olaylar Olaylardanöncekibölümlerdebahsetmiştik,ancakdetaylıolarakanlatmamıştık.Bubölümde olaylardan biraz daha detaylı bir şekilde bahsedeceğiz. Öncelikle olay nedir tanımlamaya çalışalım. Bir olay, kullanıcı etkileşimi sonucu oluşabilen durumların tümüne denir. Örneğin kullanıcınınbirbutonatıklaması,birpencerearacınınüzerinemouseilegelmesi,birpencere aracından mouse tıklamasını kaldırması veya bir pencere aracını seçmesi(checkbox gibi araçlar)bütünhepsibirerolayolarakelealınır. Kullanıcı taraflı gerçekleşmeyen, ancak birer olay olarak ele alınan durumlar da vardır. Örneğinbirresminyüklenmeyebaşlaması,yüklenmesininbitmesidurumlarıdabirerolaydır. Bunlaradayerigeldiğindedeğineceğiz. Olaylar, kullanıcı hareketlerini yorumlamanın iyi bir yoludur. Bu hareketleri yorumlamak için, fonksiyonlarımızı ilgili olaylara bağlamalıyız. Örneğin kullanıcı butona bastığı zaman şu fonksiyonumçalışsın,bendegereklibilgilerialarakişlemyapayım. Şimdibazıbellibaşlıolaylarıinceleyelim. ClockOlayları Clockileilgilidahaöncebirörnekyapmıştık.Clocksınıfı,belirtilensüresonundabirfonksiyon çalıştırmaküzeretasarlanmıştır.İştebusüresonundafonksiyonuçalıştırması,birolayolarak elealınıyor.Clockiçinzamanlayıcıdadiyebiliriz. Clock sınıfını iki şekilde kullanabiliriz. Birincisi, fonksiyonun sadece bir kez çağrılması. Yani belirtilensüresonunda,fonksiyonçalıştırılırveişlemtamamlanır.Birörneklegörelim # coding: utf-8 from kivy.app import App from kivy.clock import Clock from kivy.uix.label import Label class Program(App): def build(self): self.yazi = Label(text = "Merhaba") Clock.schedule_once(self.degistir,3) # 3 saniye sonra, self.degistir␣ adlı fonksiyonu çalıştır ˓→ return self.yazi def degistir(self,event): self.yazi.text = "Dünya" (sonrakisayfayadevam) 49https://forum..com 1226 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) Program().run() Program başladıktan 3 saniye sonra, ekrandaki “Merhaba” yazısı, “Dünya” yazısıyla değiştirilecektir.Böyleceişlemtamamlanmışolacaktır. Clocksınıfınınbirbaşkakullanımıise,belliaralıklarlasürekliçalışmasıdır.Fonksiyonuçalıştırır, sonra belirtilen süre kadar bekler ve sonra tekrar çalıştırır. Bunu, siz sonlandırana kadar veya program kapanana kadar yapmaya devam eder. Saat örneği, bu kullanım için çok iyi birörnektir. # coding: utf-8 from kivy.app import App from kivy.clock import Clock from kivy.uix.label import Label import datetime class Program(App): def build(self): self.yazi = Label(text = "Merhaba",markup = True) Clock.schedule_interval(self.degistir,1) # 1 saniye sonra, self. degistir adlı fonksiyonu çalıştır ˓→ return self.yazi def degistir(self,event): zaman = datetime.datetime.now() self.saat = "[size=25sp]{}:{}:{}[/size]".format(zaman.hour,zaman. minute,zaman.second) ˓→ self.yazi.text = self.saat Program().run() Programda kullandığımız datetime modülü, zaman bilgisini elde etmek içindir. Dikkat ettiyseniz, sürekli çalışmasını istediğimizde Clock.schedule_interval() kullanıyoruz. Bir saniye aralıklaçalışmasınısağlayarak,ekrandazamanbilgisinigöstermişolduk. Herikikullanımşeklindedikkatetmemizgerekenşey,çalıştırılacakolanfonksiyonunmutlaka bir argüman almasıdır. Burda kullandığımız “self” dışında alması gereken bir argüman olduğunugörüyoruz.Buargüman,belirlediğimizzamanınkendisidir. EğertanımladığınızbirClocknesnesinikaldırmakisterseniz; # Tanımladık self.event = Clock.schedule_interval(self.fonk,2) self.event2 = Clock.schedule_once(self.fonk2,5) # Ve bunları kaldırıyoruz (sonrakisayfayadevam) 48.3. KivyPaketi 1227 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.event.cancel() Clock.unschedule(self.event2) GirdiOlayları Kullanıcı girdisi sonucu oluşan olaylardır. Tıklama, basılı halde sürükleme, bırakma, mouse tekerleği hareketi gibi hareketler sonucu oluşan olaylardır. Daha önce buna benzer olayları bazıpencerearaçlarımızdaelealmıştık.BunlardanbirisiButtonsınıfıydı.Birbutonunüzerine tıklanmasıon_press,bırakılmaolayıdaon_releaseiledinleniyordu. Genelde bir pencere aracının sahip olduğu olaylar, ilgili API50 kaynağında bulunur. Böylece kaynağabakarak,elealmakistediğimizolaylarıbind()yardımıylabağlayabiliriz.Basitbirörnek yapalımisterseniz # coding: utf-8 from kivy.app import App from kivy.uix.boxlayout import BoxLayout from kivy.uix.textinput import TextInput class Program(App): def build(self): self.metin_kutusu = TextInput() self.metin_kutusu.bind(text = self.kontrol) return self.metin_kutusu def kontrol(self,instance,value): print(value) Program().run() TextInput pencere aracı üzerinde herhangi bir yazı yazıldığında çalışacak olan kontrol fonksiyonumuzu tanımladık. Bu fonksiyon iki adet parametre alıyor(self hariç). Bunlardan instance, pencere aracının kendisi, diğeri ise bunun içerdiği metindir. Herhangi bir karakter girişinde kontrol fonksiyonumuz çağrılacaktır. Bağlama işlemini de bind() ile yaptığımıza dikkatedin. Bunun gibi birçok pencere aracının sahip olduğu olayları API kaynağından inceleyebilirsiniz. Bizdeyerigeldiğindebunlaradeğineceğizvekullanacağız. 50https://kivy.org/doc/stable/api-index.html 1228 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.3.8 Pencere Araçları - 2 Pencere araçlarının birinci bölümünde, oldukça temel olan araçları inceledik. Bu bölümde, programındahakullanışlıolmasınısağlayan,dahaiyibirgörünümimkanıveren,dahadinamik olan,dahaileripencerearaçlarınıinceleyeceğiz. Popup Bazenprogramçalışırkenbeklenmedikbirişlemgerçekleştiğindekullanıcıyabilgivermekiçin birmesajkutusugösterilir.Yadabazenkullanıcınınekbilgigirebilmesiiçinbirformgöstermek istenirse ekranda küçük bir dialog ekranı gösterilir. Bunların hepsini Popup pencereleri ile yapabiliriz. Kivy’de Popup pencereleri, üzerinde başka pencere araçlarını taşırlar. Örneğin ekranda mesaj göstermek istersek, Popup penceresinin içerisinde bir Label tanımlayabiliriz. Birazdanörneklerleberabergöreceğiz. Popuppencerelerinioluşturmakiçinönceliklekivy.uix.popup.Popupsınıfınıimportetmeliyiz. Sonra da mutlaka içerisinde yer alacak başka bir pencere aracını belirtmeliyiz. Şimdi bir butonatıklandığızamanekrandabelirenPopuppenceresiörneğiniyapalım #coding: utf-8 from kivy.app import App from kivy.uix.popup import Popup from kivy.uix.button import Button from kivy.uix.label import Label class (App): def build(self): self.buton = Button(text = "Bir Mesajınız Var!") self.buton.bind(on_release = self.mesaj) return self.buton def mesaj(self,instance = None): popup = Popup(title = "Mesajınız", content = Label(text = "Tebrikler! İlk Popup pencereyi␣ başarıyla\noluşturdunuz.") ˓→ ) popup.open() ().run() Örneğimiz oldukça basit. Bir buton tanımladık ve tıklandığı zaman mesaj() metoduna geçiş yaptık. Bu metodumuzun içerisinde de bir tane Popup penceresi oluşturduk ve gerekli özelliklerini tanımladık. title, Popup penceresinin üst kısmında gösterilecek başlığını ifade eder. content ise, Popup penceresi içerisinde gösterilecek pencere aracını ifade eder. Bu pencerearacısadeceLabel,Buttongibiaraçlardeğil,birpenceredüzenideolabilir. 48.3. KivyPaketi 1229 PythonBelgeleri,Yayım4.1.3 #coding: utf-8 from kivy.app import App from kivy.uix.popup import Popup from kivy.uix.button import Button from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout class (App): def build(self): self.buton = Button(text = "Bir Mesajınız Var!") self.buton.bind(on_release = self.mesaj) return self.buton def mesaj(self,instance = None): govde = GridLayout(rows = 2,column = 1) govde.add_widget(Label(text = "[color=#0f0]Gönderen:[/color]", markup = True, size_hint_y = .2 )) govde.add_widget(Label(text = "Popup penceresi başarıyla oluşturuldu", markup = True, halign = "left")) popup = Popup(title = "Mesajınız",content = govde) popup.open() ().run() Ekrangörüntüsü 1230 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 48.3. KivyPaketi 1231 PythonBelgeleri,Yayım4.1.3 Popuppenceresinikapatmakistediğinizde,bunuyapmanınbiryoluolmadığınıgördünüzdeğil mi? Evet, çünkü yazdığımız örnekte pencerenin kapatılmasını sağlayacak bir kod yazmadık. PekibirPopuppenceresininasılkapatabiliriz? Bununikiyoluvar.Birincisi,Popuppenceresidışındakibiralanabasıldığızamanpencerenin kapatılmasıdır. Yukarıdaki örneğimizde Popup penceremiz tam ekran olarak açıldığı için Popup dışındaki bir alana basamıyoruz. Bu yüzden popup penceremizin boyutlarını değiştirelim ve Popup dışındaki bir alana basıldığı zaman kapanması için auto_dismiss özelliğiniaktifedelim #coding: utf-8 from kivy.app import App from kivy.uix.popup import Popup from kivy.uix.button import Button from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout class (App): def build(self): self.buton = Button(text = "Bir Mesajınız Var!") self.buton.bind(on_release = self.popAc) return self.buton (sonrakisayfayadevam) 1232 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) def popAc(self,instance = None): govde = GridLayout(rows = 2,column = 1) govde.add_widget(Label(text = "[color=#0f0]Gönderen:[/color]", markup = True, size_hint_y = .2 )) govde.add_widget(Label(text = "Popup penceresi\nbaşarıyla oluşturuldu.\ nPencereyi kapatmak için\nalan dışında bir\nyere tıklayın", ˓→ markup = True, halign = "left")) # Penceremizin boyutlarını 200x200 olarak ayarladık # size_hint = (None,None) yazmamızın sebebi # otomatik orantılı boyutlandırmayı kapatmak # ve pixel bazında boyutlandırmaya izin vermek içindir popup = Popup(title = "Mesajınız", content = govde, auto_dismiss = True, size_hint = (None,None), size = (200,200)) popup.open() ().run() Programı çalıştırıp, Popup alanı dışındaki bir alana tıklarsanız Popup kapatılacaktır. Popup pencerelerini kapatmanın bir diğer yolu, dismiss() metodunu kullanmaktır. Bu sefer ki örneğimizde kullanıcı programdan çıkmak istesin ve biz de, evet - hayır dialog kutusu göstererek onaylayalım. Eğer kullanıcı hayır derse, Popup pencereyi kapatalım. Evet derse programdançıkışyapalım. #coding: utf-8 from kivy.app import App from kivy.uix.popup import Popup from kivy.uix.button import Button from kivy.uix.label import Label from kivy.uix.gridlayout import GridLayout from kivy.uix.widget import Widget from kivy.uix.boxlayout import BoxLayout from kivy.core.window import Window class (App): def build(self): (sonrakisayfayadevam) 48.3. KivyPaketi 1233 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) self.buton = Button(text = "Çıkış Yap") self.buton.bind(on_release = self.cikis) return self.buton def cikis(self,instance = None): govde = GridLayout(cols = 1) govde.add_widget(Label(markup = True,text = "[color=#fff]Çıkmak istiyor␣ musunuz?[/color]",size_hint_y = .1)) ˓→ govde.add_widget(Widget(size_hint_y = .1)) buton = BoxLayout(size_hint_y = .2) buton.add_widget(Button(text = "Evet",markup = True,size_hint_y = .7,on_ release = self.kontrol)) ˓→ buton.add_widget(Button(text = "Hayır",markup = True,size_hint_y = .7, on_release = self.kontrol)) ˓→ govde.add_widget(buton) # Penceremizin boyutlarını 200x200 olarak ayarladık # size_hint = (None,None) yazmamızın sebebi # otomatik orantılı boyutlandırmayı kapatmak # ve pixel bazında boyutlandırmaya izin vermek içindir self.popup = Popup(title = "Çıkış", content = govde, auto_dismiss = False, size_hint = (None,None), size = (200,200)) self.popup.open() def kontrol(self,instance = None): buton_yazisi = instance.text if(buton_yazisi == "Evet"): Window.close() else: self.popup.dismiss() ().run() Şimdi örneğimizi biraz inceleyelim. İlk olarak bir buton tanımladık ve tıklanıp bırakıldığı zaman(on_release) cikis() metoduna geçiş yapmasını sağladık. Bu metod içerisinde kullanıcıya çıkış yapmak istediğinden emin olup olmadığını soracağımız bir Popup penceresi 1234 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 göstereceğiz.VebuPopuppenceresiiçerisindeyeralacakgövdemizitanımladık.Gövdemizbir GridLayoutvebizbununiçerisineyazımızıvebutonlarımızıkoyarakrahatlıklaPopupüzerinde gösterebiliriz. İki adet buton ekledik. Evet ve Hayır butonları. Dikkat ederseniz ikisinin de olaylarına aynı metodu verdik. Yani iki butondan hangisi basılırsa basılsın kontrol() metoduna geçiş yapılacaktır. Biz de bu metod içerisinde tıklanan butonun yazısını ele aldık ve eğer “Evet” butonuna basıldıysa, Window sınıfının close() metodunu kullanarak programdan sağlıklı bir şekildeçıkışyaptık.Yazacağınızprogramlarda,programınızıniçerisindebiryerdeprogramdan çıkışyapmakisterseniz,bumetodukullanmanızıtavsiyeederim. Sonra, eğer “Hayır” butonuna basıldıysa popup penceremizi dismiss() metodu yardımıyla kapattık.Böylecekodumuzutamamlamışolduk. Popuppenceresineaitbazıözellikleriinceleyelim seperator_color Popup penceresi ile başlık arasında bulunan uzun çizginin rengini değiştirmek için kullanılır. Liste veya demet olarak değer alır. Varsayılan olarak [47 / 255., 167 / 255., 212 / 255., 1.] değerinesahiptir separator_height Uzunçizgininyüksekliğiniayarlayabilirsiniz.Varsayılanolarak2dpdir. title_align Başlığınpozisyonunuifadeeder.“left”,”right”,”center”ve“justify”değerlerinialır title_color Aynı zamanda, başlığın rengini de değiştirebilirsiniz. Liste veya demet olarak değer alır. Varsayılandeğeri[1,1,1,1]. title_font Başlığınyazıtipinibelirtir 48.3. KivyPaketi 1235 PythonBelgeleri,Yayım4.1.3 title_size Anlaşıldığıgibi,başlığınboyutunuifadeeder.Varsayılanolarak14spdir. 48.4 Pyperclip Modülü Bumodülpanoişlemleriilealakalıdır.Kopyala-yapıştırgibiişlemleriyapmamızısağlar. 48.4.1 Kurulum Bumodülükurmakiçinkomutsatırınaaşağıdakikodlarıvermelisiniz: pipinstallpyperclip Modülkurulumundabirhatailekarşılaşırsanızforum..com’dandestekalabilirsiniz. 48.4.2 Kullanım copy Bufonksiyonpanoyaverikopyalamanızısağlar.Aldığıtekargümankopyalanacakveridir. Örnekler: from pyperclip import copy copy("Bu veri panoya kopyalanacak veridir.") copyfonksiyonunuçalıştırdıktansonrametnimizpanoyakopyalanmışolacak.Dilerseniztest edebilirsiniz. paste Bufonksiyonoandapanodakiveriyialmamızısağlar.Fonskiyonpanodakiveriyidöndürür. from pyperclip import paste result = paste() print(result) Gördüğünüz kodlar o anda panoda bulunan veriyi ekrana yazdıracaktır.. Eğer panoda veri yoksaboşkarakterdizisidöndürülür. 1236 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 waitForPaste Panoda veri varsa veriyi döndürür, eğer yoksa panoya veri gelene kadar bekler, geldiğinde döndürür. from pyperclip import waitForPaste print("Panoda veri varsa ekrana yazdirilacak, yoksa gelene kadar beklenecek.") result = waitForPaste() print(result) waitForNewPaste Bu fonksiyon da yukarıdakine benzer. O an panoda veri varsa bile, yeni veri gelene kadar bekler.Panodakiveridebirdeğişiklikolduğuanyeniveridöndürülür. from pyperclip import waitForNewPaste print("Panoya yeni veri geldigi an ekrana yazdirilacak.") result = waitForNewPaste() print(result) 48.4.3 NotImplementedError Hatası Eğer GNU/Linux dağıtımlarından birini kullanıyorsanız, modülümüzü kullanırken NotImplementedError hatası alabilirsiniz. Bu sorunu çözmek için aşağıdaki yöntemlerden sadecebirtanesiniuygulamanızyeterlidir. 1.Yöntem xselaracınıkurabilirsiniz.EğerDebiantabanlıbirdağıtımkullanıyorsanız; sudo apt-get install xsel EğerFedorakullanıyorsanız; sudo dnf install xsel 2.Yöntem xcliparacınıkurabilirsiniz.EğerDebiantabanlıbirdağıtımkullanıyorsanız; sudo apt-get install xclip EğerFedorakullanıyorsanız; sudo dnf install xcode 48.4. PyperclipModülü 1237 PythonBelgeleri,Yayım4.1.3 3.Yöntem SisteminizeGtkkurabilirsiniz: pip install Gtk 4.Yöntem SisteminizePyQt4kurabilirsiniz. pip install PyQt4 48.5 Tornado paketi Bu belgeler eş-zamansız olarak çok sayıda bağlantı kurabilen bir web frameworkünü anlatmaktadır. 48.5.1 Tornado Eğer yazdığınız sitede gerçek zamanlı(real-time) bağlantılar kullanacaksanız ya da bir mikro çerçeveye(micro framework) ihtiyacınız varsa tornado tamamen sizin ihtiyaçlarınız için tasarlanmışbirçerçeve. Kurulum Tornado’yukullanmakiçinönceindirmemizgerekiyor.Aşağıdakikomutukomutistemcisinde yazın: pip install tornado Successfullyinstalledtornado-6.1yazısınıgördüysenizsorunsuzcainmiştir. ProjeOluşturma Tornado,herhangibirdizindeaçtığınızherhangibirdosyadaçalışabilir.Yaninormalbirpython dosyası açalım ve yazmaya başlayalım. Ben torn isimli bir klasör açıp __init__.py dosyasında yazacağım.Öncedosyanınanabileşenleriniyazalım: import tornado.web import tornado.ioloop app = tornado.web.Application() app.listen(8888) tornado.ioloop.IOLoop.current().start() 1238 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Hemenburadaneyaptığımızıaçıklayalım. Öncekullanacağımızmodülleriiçeriaktardık: import tornado.web import tornado.ioloop Dahasonrabirsitemiziçalıştırmakiçingerekliayarlarıyaptık: app = tornado.web.Application() # İleride yönlendirme(routing) için kullanacağımız araç. app.listen(8888) # Port olarak 8888 belirledik. Siz başka bir sayı seçebilirsiniz. tornado.ioloop.IOLoop.current().start() # Sitemizi çalıştırmaya başladık Sitemizi açmak için önce yazdığımız dosyayı çalıştıralım. Daha sonra http://localhost:8888/ adresinegidelim.Elbettefarklıbirportseçtiysenizportudeğiştirmeyiunutmayın. Siteye girdiğiniz zaman sizi 404: Not Found yazısı karşılayacak. Çünkü daha hiç sayfa oluşturmadık.Hadişimdibirsayfaoluşturalım. SayfaSunma Sitemizde sayfa sunmak için bir view yazmalıyız. Geleneği bozmayalım ve “Merhaba Zalim Dünya” yazarak başlayalım. Bu iş için Application’da olduğu gibi tornado.web modülünü kullancağız.BuseferRequestHandlerisimlibirsınıfbizeyardımcıolacak. Şimdiyazacağımızkodlarıiçeaktarmaileappdeğişkeniarasınayazalım: class Merhaba(tornado.web.RequestHandler): # View için bir sınıf oluşturduk def get(self): # Sayfayı yollayan fonksiyonumuz self.write("Merhaba, Zalim Dünya!") # En basit yolu kullanarak "Merhaba, Zalim Dünya!" yazdık İlkviewımızıyazdık.Şimdidosyamızıtekrarçalıştırıptestedelim. Sonuçta bir değişiklik olmadığını göreceksiniz. Yani hâlâ 404: Not Found yazıyor. Çünkü sitemizegelenistekleviewarasındakibağlantıyıkurmadık.Hadihemenyapalım. Kullanıcınınsiteyegirmesiylesunucuyabiristekyollanır.Buistekkullanıcınınadresçubuğuna yazdığı ifadeyle doğrudan ilişkilidir. Mesela kullanıcı http://localhost:8888// yazarsa bizden // adresini istemiştir. Eğer biz bu adresi bir view ile ilişkilendirdiysek bu view çalışır. Eğer ilişkilendirmediysek 404 hatası alırız. Biz Tornado’da bu ilişkilendirme işini Application’danfaydalanarakyapıyoruz.Yaniapp=tornado.web.Application()diyeyazdığımız bölümüdüzenleyeceğiz: app = tornado.web.Application([ ("/", Merhaba) ]) 48.5. Tornadopaketi 1239 PythonBelgeleri,Yayım4.1.3 Şuan/isteğiileMerhabaviewıarasındabirilişkikurduk.Nasılyazdığımızadikkatedelim:Bir listeiçindeönceisteksonraviewiçerenbirdemet.Eğerdahafazlavieweklemekistersenizaynı liste içine demet ekleyerek yapabilirsiniz. http://localhost:8888/ adresine giderek Merhaba, ZalimDünya!yazdığınıgörebiliriz. Yazdığımızkodlarıtoplucapaylaşayım: import tornado.web import tornado.ioloop class Merhaba(tornado.web.RequestHandler): # View için bir sınıf oluşturduk def get(self): # Sayfayı yollayan fonksiyonumuz self.write("Merhaba, Zalim Dünya!") # En basit yolu kullanarak "Merhaba, Zalim Dünya!" yazdık app = tornado.web.Application([ ("/", Merhaba) ]) app.listen(8888) tornado.ioloop.IOLoop.current().start() Template(Şablon)Sistemi Sitemizde göstereceğimiz sayfaları html formatında yazıp kaydetmeliyiz. Daha sonra bu dosyalarıTornadoileçağırıpservisetmeliyiz. Göstereceğimiz sayfalar ikiye ayrılıyor: “Statik” ve “Dinamik”. Statik sayfalar Tornado’nun çağırıp değiştirmeden servis ettiği dosyalardır. Dinamik sayfalar ise Tornado’nun çağırdıktan sonradüzenleyipservisettiğidosyalardır. Öncebirhtmldosyasıoluşturalım,ardındanbudosyayıservisedelim. <!DOCTYPE html> <html> <head> <title>Merhaba Zalim Dünya</title> </head> <body> <h1>Merhaba Zalim Dünya</h1> </body> </html> Budosyayı“index.html”ismiyletornklasörümekaydedeceğim.Sizbaşkabirisimlebaşkabir klasöredekaydedebilirsiniz.HemenservisetmekiçinMerhabaview’ınıdüzenleyelim: class Merhaba(tornado.web.RequestHandler): def get(self): loader = tornado.template.Loader(".") (sonrakisayfayadevam) 1240 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) sayfa = loader.load("index.html").generate() self.write(sayfa) Ben servis etmek için Merhaba view’ını düzenlemeyi tercih ettim. Ancak siz yeni bir view yazmak isteyebilirsiniz. Bu durumda yazdığınız view’ı yeni bir istek ile eşleştirmeniz gerekir. Buişiçindebirörnekveripkodlarımızıaçıklayayım.Oluşturduğunuzview’ınadıolsun ve//isteğiileilişkilendirelim: app = tornado.web.Application([ ("/", Merhaba), # Buradaki virgülü koymayı unutmayınız ("//", ) ]) Budurumugeçipyukarıdakikodlaratekrarbakalım.İlksatırdaeklediğimizkod: loader = tornado.template.Loader(".") Burada Html dosyalarımızın bulunduğu dizini Tornado’ya bildirdik. Eğer Html dosyalarınız farklıbirdizindeyeralıyorsabenim.yazdığımyeriodiziniledeğiştirmelisiniz. Pekinedenbildirdik?ÇünküwebprogramlamadaHtml,Css,Js,Resimgibidosyalarkendilerine ait bir klasörde bulunur. Biz Html dosyalarının bulunduğu klasörü bildirerek tekrar tekrar yazmaktankurtulduk.İkincieklediğimizsatırabakalım: sayfa = loader.load("index.html").generate() Buradadahaönceoluşturduğumuzloaderdeğişkeninikullanaraksayfamızıgetirdik.generate fonksiyonunukullanaraksayfayıTornado’nunsunabileceğibirhaledönüştürdük.Dahasonra writefonksiyonuylasayfamızıgösterdik: self.write(sayfa) Şimdi de dinamik sayfaların nasıl oluşturulduğuna bakalım. Dinamik sayfaların çağrıldıktan sonra düzenlendiğini söylemiştik. Düzenleyeceğimiz yeri Tornado’ya bildirmek için ‘ Template (Şablon) denen bir yöntemden faydalanacağız. Değişiklik yapmak istediğimiz ‘ yeri 2 tane küme parantezi içinde bir isimle Html dosyamızda kullanıyoruz. Hemen bir index.htmldosyasınıdüzenleyerekbirörnekverelim. <!DOCTYPE html> <html> <head> <title>Merhaba {{ }}</title> </head> <body> <h1>Merhaba {{ }}</h1> </body> </html> Burada{{}}yazarakisimlibirdeğişkentanımladık.Tabikisizfarklıbirdeğişken isimiseçebilirsiniz. Şu an __init__.py dosyamızı çalıştırıp http://localhost:8888/ adresine gidersek 500 hatasıyla 48.5. Tornadopaketi 1241 PythonBelgeleri,Yayım4.1.3 karşılaşacağız.__init__.py’ninçalıştığıkomutistemcisinebakarsakbirhatagöreceğiz. NameError: name ’’ is not defined Bu hatadan isimli bir değişken tanımlayıp ona bir değer vermediğimiz için karşımıza çıktı.Budeğişkenedeğervermekiçingeneratefonksiyonunukullanacağız: sayfa = loader.load("index.html").generate(="") __init__.pydosyasınıtekrarçalıştırdığımızdaMerhabayazısıylakarşılaşacağız. Aklınızaşöylebirsorutakılmışolabilir:BuşekildeyapmakyerineHtmldosyasınıdüzenlemek dahakolayolmazmı? ElbettekiolabilirancakaynıişiyapanbirkaçviewdahayazdığımızdabirkaçHtmldosyasıdaha oluşturmamızgerekir.Meselasitemizeşuikiviewdakatıldığındadinamikolarakoluşturmak dahamantıklıoluyor: class Merhaba_(tornado.web.RequestHandler): def get(self): loader = tornado.template.Loader(".") sayfa = loader.load("index.html").generate(="") self.write(sayfa) class Merhaba_Dünya(tornado.web.RequestHandler): def get(self): loader = tornado.template.Loader(".") sayfa = loader.load("index.html").generate(="Dünya") self.write(sayfa) Templatesistemindekullanabileceğimizbirözellikdahavar:if,else,else,for.Fakatbuözelliği 2 küme işareti arasında değil 1 küme 1 yüzde işareti arasında kullanıyoruz: {% else %}. Bu özelliği anlatma için listelerden faydalanalım. Merhaba viewımızı değişkenine bir liste verecekşekildedüzenleyelim: class Merhaba(tornado.web.RequestHandler): def get(self): loader = tornado.template.Loader(".") liste = [0, 1, 2, 3] sayfa = loader.load("index.html").generate(=liste) self.write(sayfa) HemenbusayılarılisteleyecekbirTemplate(Şablon)yazalım.Bulistedeçiftsayılarbüyük,tek sayılarküçükgözüksün. <!DOCTYPE html> <html> <body> {% for sayı in %} {% if sayı%2==0 %} <h1> {{ sayı }} </h1> {% else %} <h4> {{ sayı }} </h4> (sonrakisayfayadevam) 1242 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) {% end %} {% end %} </body> </html> Gördüğünüzgibigenelolarakpythonileçokbenzerbiryapıyasahipancakçokönemlibirfark var. for döngüsü bir end ifadesiyle bitiyor. Aynı şekilde birbiriyle ilişkili kontrol ifadeleri(if, else)hepbirliktebirendilebitiyor. 48.5.2 Tornado(devamı) Websocket Bazenamacımızwebsayfalarısunmakolmaz.Uygulamamızlasürekliolarakverialışverişinde bulunmakisteriz.Meselaçevrimiçioyunlardaveyamesajlaşmauygulamalarındabudurumla sıkkarşılaşırız.AncakHTTPprotokolübuişiçinyetersizkalır.ÇünküHTTPprotokolüenbasit haliyle şu şekilde çalışır: Kullanıcı istek yollar, sunucu isteğe karşılık sayfa yollar, bağlantı kesilir. Sürekli olarak bağlantı kurmak istediğimizde yeni bir protokol kullanmalıyız: WS. WS protokolü kullanıcı veya sunucu kapatana kadar bağlantı açık kalır. Sunucu veya kullanıcı herhangibiristekolmadanbirbirineveriyollayabilir. Websocket’ler, en basit tabirle HTTP yerine WS protokolü kullanan view’lardır. Biz bir view tanımlarken sadece get metodunu yazmıştık. Çünkü bir view sadece sayfamızı sunuyordu. Ancak websocket’ler sadece sayfa sunmuyorlar, aynı zamanda veri de alıyorlar. Bu yüzden 3 tanemetodasahipler:on_open,on_message,on_close. Websocket ile bağlantı kurulduğunda on_open metodu çağrılıyor. Websocket’e mesaj geldiğinde on_message metodu çağrılıyor. Websocket’in bağlantısı kapatıldığında on_close metoduçağrılıyor. Biz view ile kullanıcıya veri yollarken write metodundan faydalanmıştık. Fakat websocket’ler buişiçinwrite_messagemetodunukullanıyor. Şimdigelenmesajlarıgerigönderenbirwebsocketyazalım: import tornado.web import tornado.ioloop import tornado.websocket class Geri(tornado.websocket.WebSocketHandler): def on_open(self): print("Bağlantı kuruldu") def on_message(self, mesaj): print(mesaj) self.write_message(mesaj) def on_close(self): print("Bağlantı kapandı") (sonrakisayfayadevam) 48.5. Tornadopaketi 1243 PythonBelgeleri,Yayım4.1.3 (öncekisayfadandevam) app = tornado.web.Application([ ("/ws/geri", Geri) ]) app.listen(8888) tornado.ioloop.IOLoop.current().start() İlk işimiz yeni bir kütüphane eklemek oldu.Bu kütüphane bizim websocket yazmamız için gereklisınıfıbulunduruyor. import tornado.websocket Yenibirsınıfoluşturduk: class Geri(tornado.websocket.WebSocketHandler): Bu sınıf bizim websocket’imiz. Daha önce view yazarken tornado.web.RequestHandler sınıfından faydalanmıştık. Şimdi ise tornado.websocket.WebSocketHandler sınıfından faydalandık. Websocket ile bağlantı kurulduğunda bize Bağlantı kuruldu yazması için on_open metodunu düzenledik: def on_open(self): print("Bağlantı kuruldu") Websocket’e mesaj geldiğinde onu yazdırıp geri yollaması için on_message metodunu düzenledik.Buradametodumuzunbirparametresidahaolduğunadikkatedelim: def on_message(self, mesaj): # Mesajı yazdır print(mesaj) # Mesajı geri yolla self.write_message(mesaj) Websocketkapandığındaekranayazdırmasıiçinon_closemetodunudüzenledik: def on_close(self): print("Bağlantı kapandı") GerekliyönlendirmeyiyapmasıiçinApplicationnesnemizidüzenledik: app = tornado.web.Application([ ("/ws/geri/", Geri) ]) Burada 2 önemli nokta var. Biz hem websocket’leri hem view’ları aynı Application nesnesine yazıyoruz.Buradaayrımyapmakiçingeneldewebsocket’lerinisteklerini“/ws/”ilebaşlatmaya önem veriyoruz. Diğer sıkıntı ise gelen isteklerin protokollerine göre ayrılmadan işlenmesi. Yani kullanıcı “HTTP ile mi istekte bulundu, WS ile mi istekte bulundu?” diye sorulmuyor. Bu ayrımdirektolarakbizimoisteğekarşıneyazdımızileilgili. 1244 Bölüm48. ÜçüncüTarafModüller PythonBelgeleri,Yayım4.1.3 Websocket’lere tarayıcımızdaki adres çubuğuna yazarak ulaşamayız. Tarayıcımızdaki adres çubuğu sadece HTTP protokolünü kullanır. Websocket’lere ulaşmak için kütüphaneleri kullanıyoruz. Ben size javascript ile nasıl bağlantı kurabileceğinizi göstereceğim. Bu noktada basitseviyedejavascriptbilgisinesahipolmanızgerekiyor. (cid:242) Not Burada javascript için yazdığımız kodları tarayıcınızın konsolunda yazabilirsiniz. (TarayıcınızdaF12tuşunabasınveyukarıdakisekmelerden“console”yazanıseçin.) __init__.pydosyamızıçalıştıralımvejavascriptkodlarımızıyazmayabaşlayalım. ws isminde bir Websocket nesnesi oluşturacağız. Javascript’te nesne oluşturmak için var deyimi kullanılıyor ve satır sonuna ; koyuluyor. Bir Websocket nesnesi oluştururken hangi siteyebağlanacağımızıbelirtiyoruz: var ws = new WebSocket("ws://localhost/ws/geri/"); Bu kodda HTTP yerine WS protokolünü kullandığıza ve nasıl kullanıldığına dikkat edelim: Normaldehttpyazdığımızyerewsyazdık. Şimdimesajgeldiğindeçalışacakolanonmessagefonksiyonumuzuyazalım.BizimPython’da yaptığımız gibi nesnenin devamına . koyup on_message ekleyerek tanımlayacağız. Javascript’te fonksiyon tanımlarken function deyimi kullanılıyor. Parametreler function deyiminden hemen sonra parantez içinde tanımlanıyor. Fonksiyon ile ilgili kodlar küme parantezleriiçindeyine;kullanarakyazılıyor. Yazdığımız fonksiyon gelen mesajları konsolumuzda yazdırsın. Konsolda yazdırmak istediğimizyazılarıconsole.logfonksiyonunaparametreolarakveriyoruz. ws.onmessage = function(mesaj){console.log(mesaj)} Tornado’damesajyollamakiçinwrite_messagemetodunukullanmıştık.Javascript’teisesend metodunukullanacağız. 48.5. Tornadopaketi 1245 49 BÖLÜM Katkıda Bulunanlar Yeterincegözbebeğininolduğuyerdetümhatalarsığdadır. —LinusTorvalds Bu sayfada, Python3 belgelerine herhangi bir şekilde katkıda bulunanların isimleri bir liste halindeyeralıyor. Lütfen siz de belgelerde gördüğünüz hataları GitHub51 aracılığı ile bildirmekten ya da düzeltmekten çekinmeyin. Katkılarınız, bu belgelerin hem daha az hata içermesini hem de dahaçokkişiyeulaşmasınısağlayacaktır. • HakanDemiral • BarbarosAkkurt • ŞebnemDuyar • OnurEker • EmreErözgün • TayfunYaşar • MetinHırçın • AhmetÖztekin • Mesutİdiz • LeventCiva • FıratEkinci • TalhaKesler • ÖmerGök 51https://github.com//python- 1246 PythonBelgeleri,Yayım4.1.3 • YunusEmreBulut • ErhanPaşaoğlu • CemreEfeKarakaş • SalimYıldırım • ÇağatayGenlik • ValehAsadlı • HalitTuranArıcan • LeventGüler • YaşarCelep • UğurUyar • SerdarÇağlar • AhmetOnurYıldırım • Anılİlginoğlu • HüseyinUlaşYeltürk • NuriAcar • AzatFıratÇimen • AykutKardaş • SezerBozkır • AlicanUzunhan • ÖzgürÖzer • KerimYıldız • MuhammedYılmaz • AhmetErdoğan • AbdurrahmanDursun • TahirUzelli • MehmetAkbay • MehmetÇelikyontar • SavaşZengin • TuncayGüven • CaferUluç • NikitaTürkmen • AxolotlAxolotl • BurakKadirEr 1247 PythonBelgeleri,Yayım4.1.3 • MuhammedHattapAlkan • Husamsdu • AhmetBurakÖzyurt • YunusKale • AdemKurtipek • AliSezişli • EkremDinçel • RamazanSancar • BeyazıtUysal • RamazanEmreOsmanoglu • ZekiAkyol • MertcanBilek 49.1 Hakan Demiral • Sonlanan.comprojesininulaşılamayanlinkleriWaybackMachineveritabanındaki engüncelhalleriilegüncellendi. • Navigationbarkısmındakikırıkpdflinkikaldırılarakaçıklamasıyapıldı. 49.2 Barbaros Akkurt • echo $HOME komutunun, C:\Users\falanca şeklinde gösterilen çıktısı /home/ olarakdüzeltildi. 49.3 Şebnem Duyar • ‘dahtaa’şeklindeyazılan‘daha’kelimesidüzeltildi. • Bölmeişleminde30olarakgösterilendeğer3olarakdeğiştirildi. • 23+5işleminin27olarakgösterilensonucu28olarakdüzeltildi. 1248 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 49.4 Onur Eker • Satırdakikaymadüzeltildi. • bdeğişkeninin23olarakverilendeğeri10olarakdüzeltildi. • count()örneğininaçıklamasında2olarakbelirtilenkaraktersayısı1olarakdüzeltildi. 49.5 Emre Erözgün • type()ileyazılanörnekint()ileyenidenyazıldı. • Tamsayıyaçevrilmesiunutulanöğelersayıyaçevrildi. • Hatalıçıktıverencount()örneğidüzeltildi. 49.6 Tayfun Yaşar • Koyulmasıunutulankümeparantezlerikarakterdizisiiçineyerleştirildi. 49.7 Metin Hırçın • ‘etkileşimlikabul’şeklindeyazılanifade‘etkileşimlikabuk’olarakdüzeltildi. • ‘içidnde’şeklindeyazılanifade‘içinde’olarakdüzeltildi. • ‘görünmüyür’şeklindeyazılanifade‘görünmüyor’olarakdüzeltildi. • ‘öğrendikce’şeklindeyazılanifade‘öğrendikçe’olarakdüzeltildi. • ‘dizilerinne’şeklindeyazılanifade‘dizilerine’olarakdüzeltildi. • Birbirinden‘,’işaretiileayrılananahtar-değerçiftleri‘:’işaretiileayrıldı. • ‘yanınıra’şeklindeyazılanifade‘yanısıra’olarakdüzeltildi. 49.8 Ahmet Öztekin • ‘yukarı’şeklindeyazılanifade‘yukarıda’olarakdüzeltildi. • rjust()metodununyanlışyazılançıktısıdüzeltildi. • l1şeklindeyazılandeğişkenadıli1olarakdüzeltildi. 49.4. OnurEker 1249 PythonBelgeleri,Yayım4.1.3 49.9 Mesut İdiz • ‘farkedemezsiniz’şeklindeyazılankelime‘farkedemezseniz’olarakdüzeltildi. • Unutulanbir‘a’harfieklendi. • Cümle içinde “’=’ işleci” ifadesinden sonra yazılan “sayı2” ifadesi doğru yerine yerleştirildi. • ‘farlıdır’şeklindeyazılankelime‘farklıdır’olarakdüzeltildi. 49.10 Levent Civa • ‘ayrıntılılarıyla’şeklindeyazılankelime‘ayrıntılarıyla’olarakdüzeltildi. • Toplamkarakteruzunluğunailişkinörnekkoddakimantıkhatasıgiderildi. 49.11 Fırat Ekinci • Örnektetersyazılan‘Osman’ve‘Mehmet’isimlerininsırasıdüzeltildi. 49.12 Talha Kesler • Kontrolmekanizmalıeval()kodlarındakihatadüzeltildi. • Hesapmakinesikodlarındakieksikkarakterdizisidüzeltildi. 49.13 Ömer Gök • Dosyakarşılaştırmakodlarındakideğişkenhatalarıgiderildi. 49.14 Yunus Emre Bulut • ‘Önclelikle’olarakyazılankelime‘Öncelikle’olarakdüzeltildi. • Kırıkbağlantıdüzeltildi. • 8bityerineyanlışlıkla7bitolarakbelirtilensayıdüzeltildi. 1250 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 49.15 Erhan Paşaoğlu • ‘Bununsebebibirsayıile(45)karakterdizisini(“45”)birbiriyletoplamayaçalışmamızdır’ cümlesi ‘Bunun sebebi bir sayı (45) ile bir karakter dizisini (“45”) birbiriyle toplamaya çalışmamızdır’şeklindedüzeltilerekdahaberrakbirhalegetirildi. 49.16 Cemre Efe Karakaş • split()olarakyazılanmetotadıstrip()olarakdüzeltildi. 49.17 Salim Yıldırım • falanca.png”olarakyazılankarakterdizisi“falanca.png”olarakdüzeltildi. • ‘tatlilar’şeklindeyazılankelime‘tatlılar’olarakdüzeltildi. • "{:,}.format(1234567890) olarak yazılan kod "{:,}".format(1234567890) olarak düzeltildi. • "{:b}.format(2)olarakyazılankod"{:b}".format(2)olarakdüzeltildi. • Belgegüncellemesiesnasındayanlışlıklaparagraftansilinenkısımtekrareklendi. 49.18 Çağatay Genlik • (50087).bit_length()kodunun2olarakgösterilençıktısı16olarakdüzeltildi. 49.19 Valeh Asadlı • listeolarakbelirtilenlisteadlarıüyelerolarakdüzeltildi. • Demetiçinde‘mehmetşeklindeyazılankarakterdizisi‘mehmet’olarakdüzeltildi. • TBMMolarakbelirtilenkarakterdizisi‘TBMM’olarakdüzeltildi. • ‘\nolarakyazılankarakterdizisi‘\n’olarakdüzeltildi. 49.20 Halit Turan Arıcan • “Buradaikincisıradakisayılarilksıradakisayılarınikilisistemdekikarşılıklarıdır.Üçüncü sıradaki sayılar ise her bir sayının kaç bit olduğunu, yani bir bakıma ikili sayma sisteminde kaç basamağa sahip olduğunu gösteriyor,” cümlesinde ‘sıra’ kelimeleri ‘sütun’kelimeleriiledeğiştirilerekifadetarzınındahaanlaşılırolmasısağlandı. 49.15. ErhanPaşaoğlu 1251 PythonBelgeleri,Yayım4.1.3 49.21 Levent Güler • PDF için kapak tasarımı [bkz. https://web.archive.org/web/20150831052508/http:// .com/forum/viewtopic.php?f=40&t=2487] • Komutun, ‘uzak çok uzak...’ olarak gösterilen çıktısı ’uzak çok uzak...’ olarak düzeltildi. • C:\\aylar\\nisan\\toplam masraf şeklinde gösterilen dizin yolu C:\aylar\nisan\toplam masraf şeklindedüzeltildi. • ‘\\n’olarakyazılankaçışdizisi‘\n’olarakdüzeltildi. • İkikezaynışekildeyazılankodlardüzeltildi. • Yanlışlıklast_sizeyerineyazılanst_mtimeniteliğideğiştirildi. • Karakterdizisininsonunaeklenmesiunutulansatırbaşıkarakteri(’\n’)eklendi. 49.22 Yaşar Celep • ‘onlu, sekizli ve onaltılı’ şeklinde yazılması gerekirken ‘onlu ve onaltılı’ olarak belirtilen ifadedüzeltildi. 49.23 Uğur Uyar • ‘print() fonksiyonu, kendisine verilen parametreler arasına birer nokta yerleştirir,’ cümlesi ‘print() fonksiyonu, kendisine verilen parametreler arasına birer boşluk yerleştirir,’olarakdüzeltildi. 49.24 Serdar Çağlar • Programsonundakapatılmasıunutulanbirdosyakapatıldı. • Listeiçindeyeralansayılarınbazılarındaki,hatayayolaçanbiçimbozukluğugiderildi. • print(çeviri_tablosu[i])yerinehatalıolarakprint(i)şeklindeyazılankoddüzeltildi. • Uyarıüzerine,belgePython’ınensonsürümünegöregözdengeçirildi. 49.25 Ahmet Onur Yıldırım • ’{:o}’.format(1980) yerine hatalı olarak ’:o’.format(1980) şeklinde yazılan kod düzeltildi. • closed()olarakbelirtilennitelikclosedolarakdüzeltildi. • sözlük = harfler.index(i)olarakyazılankodsözlük[i] = harfler.index(i)olarak düzeltildi. • ‘ifaye’olarakyazılankelime‘ifadeye’olarakdüzeltildi. 1252 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 • ‘aktarmadağımız’olarakyazılankelime‘aktarmadığımız’olarakdüzeltildi • Çıktıyaeklenmesiunutulanfonk8_fonksiyonueklendi. • Bazı GNU/Linux dağıtımlarında webbrowser modülünün open() fonksiyonuna verilen websitesiadreslerinin‘http’önekiyleyazılmasıgerektiğinedairbirnoteklendi. • ‘ayna’olarakyazılankelime‘aynı’olarakdüzeltildi. • Yanlışlıkla‘prezantabl’olarakyazılanlisteöğesi‘konuşkan’olarakdüzeltildi. • ‘mimtarisi’olarakyazılankelime‘mimarisi’olarakdüzeltildi. • %PROCESSOR_ARCHITECTURE olarak yazılan çevre değişkeni %PROCESSOR_ARCHITECTURE%olarakdüzeltildi. 49.26 Anıl İlginoğlu • ‘denene’olarakyazılankelime‘deneme’olarakdüzeltildi. 49.27 Hüseyin Ulaş Yeltürk • ‘listedindeki’olarakyazılankelime‘listesindeki’olarakdüzeltildi. • Yanlışlıklaçiftyazılan‘teknik’kelimesidüzeltildi. • ‘niteliği’olarakyazılankelime‘niteliğin’olarakdüzeltildi. 49.28 Nuri Acar • ‘nitelğin’olarakyazılankelime‘niteliğin’olarakdüzeltildi. • colorama modülü anlatımı, “print(Fore.RED + ‘sade kırmızı yazı)” satırı parantez içi sonundaolmasıgereken‘işaretieklendi. • Fonksiyonlarkonusu,cümlesonuharfhatasıdüzeltmesi. kalacaktır.=>kalacaktık. • Gömülü fonksiyonlar konusu, liste isimlendirmesi eksikliği yüzünden devamındaki kodlardaortayaçıkan“NameError:name‘l’isnotdefined”hatasıdüzeltmesi. [400,176,64,...] l=[400,176,64,...] • Modüller konusu, __name__ Niteliği, kod satır sıralaması düzeltmesi. Program opsiyonlarıgörüntülenmedenişlemnumarasıgirilmesiistenmesidurumudüzeltmesi. 49.26. Anılİlginoğlu 1253 PythonBelgeleri,Yayım4.1.3 49.29 Azat Fırat Çimen • ‘gün_sayısı’olarakyazılandeğişkenadı‘gün’olarakdüzeltildi. 49.30 Aykut Kardaş • nşeklindeyazılankaçışdizisi,\nolarakdüzeltildi. 49.31 Sezer Bozkır • ‘derini’şeklindeyazılankelime‘değerini’olarakdüzeltildi. 49.32 Alican Uzunhan • if bloğundakigirintikaymasıdüzeltildi. • ‘gözde’şeklindeyazılankelime‘göze’olarakdüzeltildi. • Örnekbirkoddakideğişkenveişleçhatasıdüzeltildi. • ‘kullanmasınız’şeklindeyazılankelime‘kullanmasanız’olarakdüzeltildi. • ‘programımımızın’şeklindeyazılankelime‘programımızın’olarakdüzeltildi. • self.__personelolarakyazılandeğişkenself._personelolarakdüzeltildi. • ‘mekanizmasınına’olarakyazılankelime‘mekanizmasına’olarakdüzeltildi. • ‘konularıde’olarakyazılanifade‘konularıda’olarakdüzeltildi. • ‘akrarırken’olarakyazılankelime‘aktarırken’olarakdüzeltildi. • sa\*tolarakgörünendüzenliifadesa*tolarakdüzeltildi. • print(im)şeklindeyazılanprint(veri)olarakdüzeltildi. • ‘yardınıyla’olarakyazılankelime‘yardımıyla’olarakdüzeltildi. • ‘Buradakadar’olarakyazılanifade‘burayakadar’olarakdüzeltildi 49.33 Özgür Özer • ‘Flemenkçe’olarakyazılankelime‘Felemenkçe’olarakdüzeltildi. • ‘komutunun’olarakyazılankelime‘komutun’olarakdüzeltildi. • Yanlışlıklaikikezyazılan‘bir’kelimesitekeindirildi. • ‘fonksiyonun’olarakyazılankelime‘fonksiyonunun’olarakdüzeltildi. 1254 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 49.34 Kerim Yıldız • ‘yime’olarakyazılankelime‘yine’olarakdüzeltildi. 49.35 Muhammed Yılmaz • ‘randrage’olarakyazılanfonksiyonadı‘randrange’olarakdüzeltildi. 49.36 Ahmet Erdoğan • print(’a’, ’b’, end=’’)komutununçıktıgörünümüdüzeltildi. 49.37 Abdurrahman Dursun • Cümledeyanlışyerdekullanılan‘end’ve‘sep’kelimeleridüzeltildi. • Yanlışlıkla‘alnımızdik’olarakyazılanifade‘başımızdik’olarakdüzeltildi. • Kendisindenöncekicümledeifadeedilenfikritekraredengereksizbircümleparagraftan çıkarıldı. • Karakterdizisinin,unutulankapatmatırnağıyerinekoyuldu. 49.38 Tahir Uzelli • Yanlışlıkla‘8adetbir’şeklindeyazılanifade‘8adetbit’olarakdüzeltildi. 49.39 Mehmet Akbay • Yanlışlıkla‘a1.txt’olarakbelirtilendosyaadı‘hakkında.txt’olarakdüzeltildi. 49.40 Mehmet Çelikyontar • Yanlışlıkla‘satı1’olarakyazılankelime‘satır1’olarakdüzeltildi. 49.34. KerimYıldız 1255 PythonBelgeleri,Yayım4.1.3 49.41 Savaş Zengin • Kodlardakieksikparantezdüzeltildi. • [^A-Z-a-z_]düzenliifadesi[^A-Za-z0-9_]olarakdüzeltildi. • Kodlarayanlışlıklafazladaneklenen\işaretikaldırıldı. 49.42 Tuncay Güven • python3.pdf adlıbelgeninyanlışyazılanindirmeadresidüzeltildi. 49.43 Cafer Uluç • ‘GNU-dışı’ifadesi‘GNUdışı’olarakdüzeltildi. • ‘websitesi’kelimesi‘websitesi’olarakdüzeltildi. 49.44 Nikita Türkmen • Kodlardakibiradetfazlaboşlukkarakterikaldırıldı. • Yanlışlıkla3milisaniyeolarakbelirtilendeğer300milisaniyeolarakdüzeltildi. • Çalışan.personelolarakbelirtilmesigerekirkenpersonelolarakbelirtilendeğişkenadı düzeltildi. 49.45 Axolotl Axolotl • Yanlışlıkla‘yukarı’olarakyazılankelime‘yukarıda’olarakdüzeltildi. • Kodlardakiyanlışgirintilemedüzeltildi. • Gereksizbirvirgülişaretikaldırıldı. • Yanlışlıkla‘olmadığını’olarakyazılankelime‘oluşmadığını’olarakdüzeltildi. • Sürümbilgisinigösterençıktıdaki‘Python’ifadesikaldırıldı. • ‘metodununa’olarakyazılankelime‘metoduna’olarakdüzeltildi. • Gereksizbirvirgülişaretikaldırıldı. • ‘ilermeye’olarakyazılankelime‘ilerlemeye’olarakdüzeltildi. • Kodunhatalıçıktısıdüzeltildi. • ‘<’işareti‘>’olarakdüzeltildi. • Kodlardakigereksizbirparantezkaldırıldı. • Cümledekigereksizbirvirgülişaretikaldırıldı. • Küçükharflebaşlanancümledüzeltildi. 1256 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 • ‘isim 5 karakterden küçükse’ ifadesi ‘isim 5 karakterse veya bundan küçükse’ olarak düzeltildi. • Unutulanbir‘a’harfieklendi. • Cümlesonundaunutulannoktaişaretieklendi. • ‘metodunu’olarakyazılankelime‘metodu’olarakdüzeltildi. • ASCIItablosuileilgilibirhatadüzeltildi. • Kullanıcıadıveparolaileilgilikodlardakibirhatagiderildi. • Yanlışyerekoyulannoktaişaretikaldırıldı. • Cümlede farklı nesne grupları birbirinden ayırılırken virgül yerine noktalı virgül işareti kullanıldı. • ‘işlemini’olarakyazılankelime‘işlemi’olarakdüzeltildi. • ‘işare’olarakyazılankelime‘işareti’olarakdüzeltildi. • Unutulankodçıktısıeklendi. • İkinoktaişaretindensonrabüyükharflebaşlamasıgerekencümledüzeltildi. • ‘istemiyorsanuz’olarakyazılankelime‘istemiyorsanız’olarakdüzeltildi. • ‘oyununun’olarakyazılankelime‘oyunun’olarakdüzeltildi. • ‘O’olarakyazılmasıgerekirken‘Y’olarakyazılankarakterdüzeltildi. • ‘programımın’olarakyazılankelime‘programın’olarakdüzeltildi. 49.46 Burak Kadir Er • “56715değeriolduğuiçin”ifadesi“56700değeriolduğuiçin”olarakdüzeltildi. • ‘Pekı’kelimesi‘Peki’olarakdüzeltildi. • “Verebileceğimizi, ‘ama’ bunun bir yolu yordamı olduğunu biliyorsunuz” cümlesi “Verebileceğimizi‘ve’bununbiryoluyordamıolduğunubiliyorsunuz”olarakdeğiştirildi. • ‘Herbir’ve‘herzamanki’kelimeleridüzeltildi. • Demetlerkısmındagramerdüzeltmesiyapıldı. • Evaluatekısmındaanlatımıpekiştirmeaçısındaneval’likodörneğieklendi. • Listelerinmetotlarıkısmındakelimedüzeltmesiyapıldı. • ‘Doğruda’kelimesi‘doğrudan’olarakdüzeltildi. • Saymasistemlerikısmındaki‘herbir’kelimesidüzeltildi. • ‘veirleri’,‘verileri’olarakdüzeltildi. • “Yani karşı karşıya olduğunuz ‘duruma’ değerlendirip”, “Yani karşı karşıya olduğunuz ‘durumu’değerlendirip”olarakdüzeltildi. • ‘iyideniyine’,‘iyideniyiye’olarakdeğiştirildi. • Gerekliyeresoruişaretieklendi. 49.46. BurakKadirEr 1257 PythonBelgeleri,Yayım4.1.3 • Yanlışlıklaikikezyazılan‘eğer’kelimesidüzeltildi. • Sözlüklerinmetotlarıkısmındakelimedüzeltmesiyapıldı. • ‘yanısıra’,‘yanısıra’olarakdüzeltildi. • Fonksiyonlarkısmındakigramerhatasıdüzeltildi. • Fonksiyonlarkısmındakikelimehatasıdüzeltildi. • ‘metodununa’,‘metoduna’olarakdüzeltildi. • Gömülüfonksiyonlarkısmındakelimedüzeltmesiyapıldı. • ‘yanlızca’,‘yalnızca’olarakdüzeltildi. • Yanlışlıklabitişikyazılmışolan‘yanısıra’kelimesidüzeltildi. • Gömülü fonksiyonlar kısmında birden çok kez yanlış yazılmış olan ‘herbir’ kelimeleri düzeltildi. • Input fonksiyonunun değişken adı girilmesi gereken yerde yanlışlıkla özyinelemeli fonksiyongirilenyerdüzeltildi. • Modüllerkısmındagramerhatasıdüzeltildi. • Modüllerkısmındakelimedüzeltmesiyapıldı. • NesneTabanlıProgramlama(OOP)kısmındaki‘herbir’kelimesi,‘herbir’olarakdüzeltildi. • ‘şipariş’,‘sipariş’olarakdüzeltildi. • Nesne Tabanlı Programlama(OOP) kısmındaki ‘yanısıra’ kelimesi, ‘yanı sıra’ olarak düzeltildi. • Nesne Tabanlı Programlama(OOP) kısmında ‘örnek niteliği’ olarak yazılmış olan kelime, ‘sınıfniteliği’olarakdüzeltildi. • NesneTabanlıProgramlama(Devamı)kısmındabirdençokkelimedüzeltmesiyapıldı. • NesneTabanlıProgramlama(Devamı)kısmındaki‘yanısıra’,‘yanısıra’olarakdüzeltildi. • NesneTabanlıProgramlama(Devamı)kısmındaki‘sözdizimi’,‘sözdizimi’olarakdüzeltildi. • NesneTabanlıProgramlama(Devamı)kısmındaki‘vesaire’,‘vesaire’olarakdüzeltildi. • NesneTabanlıProgramlama(Devamı)kısmındabirdençokkelimedüzeltmesiyapıldı. • NesneTabanlıProgramlama(Devamı)kısmındaki‘yanısıra’,‘yanısıra’olarakdüzeltildi. • Nesne Tabanlı Programlama(Devamı) kısmında birden çok kez yanlış yazılmış olan ‘herbir’kelimeleridüzeltildi. • Nesne Tabanlı Programlama(Devamı) kısmındaki ‘herzamanki’, ‘her zamanki’ olarak düzeltildi. • NesneTabanlıProgramlama(Devamı)kısmındabirdençokkelimedüzeltmesiyapıldı. • Nesne Tabanlı Programlama(Devamı) kısmındaki “bu sınıfları ‘uygulamamız’ içine dahil ediyoruz”cümlesi“busınıfları‘uygulamamızın’içinedahilediyoruz”olarakdüzeltildi. • Paketlerkısmındakelimedüzeltmesiyapıldı. • Düzenliİfadelerkısmındakelimedüzeltmesiyapıldı. • Düzenliİfadelerkısmındaki‘birkaç’,“birkaç’olarakdüzeltildi. 1258 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 • Düzenliİfadelerkısmındaki‘paramtresinin’,‘parametresinin’olarakdüzeltildi. • Düzenliİfadelerkısmındaki‘websitesinde’,‘websitesinde’olarakdüzeltildi. • Düzenliİfadelerkısmındakibozuklinklerdüzeltildi. • Düzenliİfadelerkısmındakelimedüzeltmesiyapıldı. • HataYakalamakısmındagerekliyerenoktaeklendi. • HataYakalamakısmındakelimedüzeltmesiyapıldı. • Randommodülükısmındabirdençokkelimedüzeltmesiyapıldı. • OSmodülükısmındabirdençokkelimedüzeltmesiyapıldı. • Bezeyicilerkısmındabirleşikyazılanbağlaçdüzeltildi. • Bezeyicilerkısmındaki‘ÖrnekOlarak’,‘Örnekolarak’olarakdüzeltildi. • Bezeyiciler kısmındaki “Çağrılabilir ‘objeleri’ örnek verecek olursak”, “Çağrılabilir ‘objelere’örnekverecekolursak”olarakdüzeltildi. • Bezeyicilerkısmındaki‘methodunun’,‘metodunun’olarakdüzeltildi. • Bezeyicilerkısmındaki‘Tabiki’,‘Tabiiki’olarakdüzeltildi. • Bezeyicilerkısmındakibircümledeanlatımbozukluğugiderildi. • Bezeyicilerkısmınınsonbölümündekihatalıkoddüzeltildi. • Bezeyicilerkısmındakisoncümlelerdenbirindekianlatımbozukluğugiderildi. 49.47 Muhammed Hattap Alkan • Bezeyiciler(decoratorlar)konusueklendi. 49.48 Husamsdu • Birdenfazlayazımhatasıdüzeltildi. 49.49 Ahmet Burak Özyurt • Birden fazla Python sürmümünün yönetilebilmesi için mevcut olan pyenv aracının kurulumuvekullanımıhakkındarehberhazırlandı. • Python2desteğininsonlandırılmasıylailgilieklemeyapıldı. • f-stringkullanımıhakkındadetaylarveörneklereklendi. 49.47. MuhammedHattapAlkan 1259 PythonBelgeleri,Yayım4.1.3 49.50 Yunus Kale • Fonksiyonlarkonusundakikodhatasıdüzeltildi. • ColoramaModülündekibirkodhatasıveyazımyanlışıdüzeltildi. 49.51 Adem Kurtipek • Kaçış dizileri kısmındaki print("\N{LATIN CAPITAL LETTER S WITH CEDILLA}") komutunun,çıktısıolarakgösterilenşdeğeriŞolarakdeğiştirildi. 49.52 Ali Sezişli • Biryazımhatasıdüzeltildi. • RHELveCentOStarafındapython3kurulumuiçinkomuteklendi. • pyenvbağımlılıklarınınkurulumundaFedoraveRHEL/CentOSayrıldı. 49.53 Ekrem Dinçel • BelgelerintekrardanPDFveEPUBolarakinşaedilmesisağlandı. • Bozuklinklerdüzeltildi. 49.54 Ramazan Sancar • “KoşulDeyimleri”içerisindetanımauygunaçıklamadüzeltildi. • LISENCEiçindeyeralanhatalı(bozuk)bağlantıdüzeltildi. 49.55 Beyazıt Uysal • ‘/Ucuncu_taraf_moduller/kivy_dersleri/widgets.rst’ dosyası altında bulunan bir kod bloğundaikikezkütüphaneimportugiderildi. • islecler.rst dosyası içerisinde bulunan “görüntülecektir” kelimesi “görüntülenecektir” olarakdüzeltildi. • kurulum.rst dosyası içerisinde bulunan “yazağımız” kelimesi “yazacağımız” olarak düzeltildi. • donguler.rstaltındayeralan‘DosyalarınİçeriğiniKarşılaştırma’başlığındakodaçıklama hatasıdüzeltildi. • sozlukler.rst dosyasında yer alan ve sözlüklerin sıraya sahip olmasıyla ilgili not, HTML dosyasındahatalıbirgörünümesahipti,ancakbusorungiderildi. 1260 Bölüm49. KatkıdaBulunanlar PythonBelgeleri,Yayım4.1.3 49.56 Ramazan Emre Osmanoglu • Coloramadokumanlarieklendi. • Pyperclipdokumanlarieklendi. • Recursiondokumanindakibasecaseduzenlendi. 49.57 Zeki Akyol • Kodiçermeyendüzmetindekitekrarlayanbiryazımhatasıdüzeltildi. 49.58 Mertcan Bilek • Bitwise(Bitsel)İşleçleridokumanlarieklendi. 49.56. RamazanEmreOsmanoglu 1261
```